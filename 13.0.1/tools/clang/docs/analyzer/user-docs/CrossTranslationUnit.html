
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>2.1. Cross Translation Unit (CTU) Analysis &#8212; Clang 13 documentation</title>
    <link rel="stylesheet" href="../../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="3. Developer Docs" href="../developer-docs.html" />
    <link rel="prev" title="2. User Docs" href="../user-docs.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>Clang 13 documentation</span></a></h1>
        <h2 class="heading"><span>2.1. Cross Translation Unit (CTU) Analysis</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="../user-docs.html">2. User Docs</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="../developer-docs.html">3. Developer Docs</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <div class="section" id="cross-translation-unit-ctu-analysis">
<h1>2.1. Cross Translation Unit (CTU) Analysis<a class="headerlink" href="#cross-translation-unit-ctu-analysis" title="Permalink to this headline">¶</a></h1>
<p>Normally, static analysis works in the boundary of one translation unit (TU).
However, with additional steps and configuration we can enable the analysis to inline the definition of a function from
another TU.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#overview" id="id6">Overview</a></p></li>
<li><p><a class="reference internal" href="#pch-based-analysis" id="id7">PCH-based analysis</a></p>
<ul>
<li><p><a class="reference internal" href="#manual-ctu-analysis" id="id8">Manual CTU Analysis</a></p></li>
<li><p><a class="reference internal" href="#automated-ctu-analysis-with-codechecker" id="id9">Automated CTU Analysis with CodeChecker</a></p></li>
<li><p><a class="reference internal" href="#automated-ctu-analysis-with-scan-build-py-don-t-do-it" id="id10">Automated CTU Analysis with scan-build-py (don’t do it)</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#on-demand-analysis" id="id11">On-demand analysis</a></p>
<ul>
<li><p><a class="reference internal" href="#id2" id="id12">Manual CTU Analysis</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id13">Automated CTU Analysis with CodeChecker</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id14">Automated CTU Analysis with scan-build-py (don’t do it)</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id6">2.1.1. Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>CTU analysis can be used in a variety of ways. The importing of external TU definitions can work with pre-dumped PCH
files or generating the necessary AST structure on-demand, during the analysis of the main TU. Driving the static
analysis can also be implemented in multiple ways. The most direct way is to specify the necessary commandline options
of the Clang frontend manually (and generate the prerequisite dependencies of the specific import method by hand). This
process can be automated by other tools, like <a class="reference external" href="https://github.com/Ericsson/codechecker">CodeChecker</a> and scan-build-py
(preference for the former).</p>
</div>
<div class="section" id="pch-based-analysis">
<h2><a class="toc-backref" href="#id7">2.1.2. PCH-based analysis</a><a class="headerlink" href="#pch-based-analysis" title="Permalink to this headline">¶</a></h2>
<p>The analysis needs the PCH dumps of all the translations units used in the project.
These can be generated by the Clang Frontend itself, and must be arranged in a specific way in the filesystem.
The index, which maps symbols’ USR names to PCH dumps containing them must also be generated by the
<cite>clang-extdef-mapping</cite>. Entries in the index <em>must</em> have an <cite>.ast</cite> suffix if the goal
is to use PCH-based analysis, as the lack of that extension signals that the entry is to be used as a source-file, and parsed on-demand.
This tool uses a <a class="reference internal" href="../../JSONCompilationDatabase.html"><span class="doc">compilation database</span></a> to
determine the compilation flags used.
The analysis invocation must be provided with the directory which contains the dumps and the mapping files.</p>
<div class="section" id="manual-ctu-analysis">
<h3><a class="toc-backref" href="#id8">2.1.2.1. Manual CTU Analysis</a><a class="headerlink" href="#manual-ctu-analysis" title="Permalink to this headline">¶</a></h3>
<p>Let’s consider these source files in our minimal example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// main.cpp</span>
<span class="kt">int</span> <span class="nf">foo</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">3</span> <span class="o">/</span> <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// foo.cpp</span>
<span class="kt">int</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And a compilation database:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>
  <span class="o">{</span>
    <span class="s2">&quot;directory&quot;</span>: <span class="s2">&quot;/path/to/your/project&quot;</span>,
    <span class="s2">&quot;command&quot;</span>: <span class="s2">&quot;clang++ -c foo.cpp -o foo.o&quot;</span>,
    <span class="s2">&quot;file&quot;</span>: <span class="s2">&quot;foo.cpp&quot;</span>
  <span class="o">}</span>,
  <span class="o">{</span>
    <span class="s2">&quot;directory&quot;</span>: <span class="s2">&quot;/path/to/your/project&quot;</span>,
    <span class="s2">&quot;command&quot;</span>: <span class="s2">&quot;clang++ -c main.cpp -o main.o&quot;</span>,
    <span class="s2">&quot;file&quot;</span>: <span class="s2">&quot;main.cpp&quot;</span>
  <span class="o">}</span>
<span class="o">]</span>
</pre></div>
</div>
<p>We’d like to analyze <cite>main.cpp</cite> and discover the division by zero bug.
In order to be able to inline the definition of <cite>foo</cite> from <cite>foo.cpp</cite> first we have to generate the <cite>AST</cite> (or <cite>PCH</cite>) file
of <cite>foo.cpp</cite>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ <span class="nb">pwd</span> $ /path/to/your/project
$ clang++ -emit-ast -o foo.cpp.ast foo.cpp
$ <span class="c1"># Check that the .ast file is generated:</span>
$ ls
compile_commands.json  foo.cpp.ast  foo.cpp  main.cpp
$
</pre></div>
</div>
<p>The next step is to create a CTU index file which holds the <cite>USR</cite> name and location of external definitions in the
source files:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ clang-extdef-mapping -p . foo.cpp
c:@F@foo# /path/to/your/project/foo.cpp
$ clang-extdef-mapping -p . foo.cpp &gt; externalDefMap.txt
</pre></div>
</div>
<p>We have to modify <cite>externalDefMap.txt</cite> to contain the name of the <cite>.ast</cite> files instead of the source files:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ sed -i -e <span class="s2">&quot;s/.cpp/.cpp.ast/g&quot;</span> externalDefMap.txt
</pre></div>
</div>
<p>We still have to further modify the <cite>externalDefMap.txt</cite> file to contain relative paths:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ sed -i -e <span class="s2">&quot;s|</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span><span class="s2">/||g&quot;</span> externalDefMap.txt
</pre></div>
</div>
<p>Now everything is available for the CTU analysis.
We have to feed Clang with CTU specific extra arguments:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ <span class="nb">pwd</span>
/path/to/your/project
$ clang++ --analyze <span class="se">\</span>
    -Xclang -analyzer-config -Xclang experimental-enable-naive-ctu-analysis<span class="o">=</span><span class="nb">true</span> <span class="se">\</span>
    -Xclang -analyzer-config -Xclang ctu-dir<span class="o">=</span>. <span class="se">\</span>
    -Xclang -analyzer-output<span class="o">=</span>plist-multi-file <span class="se">\</span>
    main.cpp
main.cpp:5:12: warning: Division by zero
  <span class="k">return</span> <span class="m">3</span> / foo<span class="o">()</span><span class="p">;</span>
         ~~^~~~~~~
<span class="m">1</span> warning generated.
$ <span class="c1"># The plist file with the result is generated.</span>
$ ls -F
compile_commands.json  externalDefMap.txt  foo.ast  foo.cpp  foo.cpp.ast  main.cpp  main.plist
$
</pre></div>
</div>
<p>This manual procedure is error-prone and not scalable, therefore to analyze real projects it is recommended to use
<cite>CodeChecker</cite> or <cite>scan-build-py</cite>.</p>
</div>
<div class="section" id="automated-ctu-analysis-with-codechecker">
<h3><a class="toc-backref" href="#id9">2.1.2.2. Automated CTU Analysis with CodeChecker</a><a class="headerlink" href="#automated-ctu-analysis-with-codechecker" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="https://github.com/Ericsson/codechecker">CodeChecker</a> project fully supports automated CTU analysis with Clang.
Once we have set up the <cite>PATH</cite> environment variable and we activated the python <cite>venv</cite> then it is all it takes:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ CodeChecker analyze --ctu compile_commands.json -o reports
$ ls -F
compile_commands.json  foo.cpp  foo.cpp.ast  main.cpp  reports/
$ tree reports
reports
├── compile_cmd.json
├── compiler_info.json
├── foo.cpp_53f6fbf7ab7ec9931301524b551959e2.plist
├── main.cpp_23db3d8df52ff0812e6e5a03071c8337.plist
├── metadata.json
└── unique_compile_commands.json

<span class="m">0</span> directories, <span class="m">6</span> files
$
</pre></div>
</div>
<p>The <cite>plist</cite> files contain the results of the analysis, which may be viewed with the regular analysis tools.
E.g. one may use <cite>CodeChecker parse</cite> to view the results in command line:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ CodeChecker parse reports
<span class="o">[</span>HIGH<span class="o">]</span> /home/egbomrt/ctu_mini_raw_project/main.cpp:5:12: Division by zero <span class="o">[</span>core.DivideZero<span class="o">]</span>
  <span class="k">return</span> <span class="m">3</span> / foo<span class="o">()</span><span class="p">;</span>
           ^

Found <span class="m">1</span> defect<span class="o">(</span>s<span class="o">)</span> in main.cpp


----<span class="o">====</span> <span class="nv">Summary</span> <span class="o">====</span>----
-----------------------
Filename <span class="p">|</span> Report count
-----------------------
main.cpp <span class="p">|</span>            <span class="m">1</span>
-----------------------
-----------------------
Severity <span class="p">|</span> Report count
-----------------------
HIGH     <span class="p">|</span>            <span class="m">1</span>
-----------------------
----<span class="o">=================</span>----
Total number of reports: <span class="m">1</span>
----<span class="o">=================</span>----
</pre></div>
</div>
<p>Or we can use <cite>CodeChecker parse -e html</cite> to export the results into HTML format:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ CodeChecker parse -e html -o html_out reports
$ firefox html_out/index.html
</pre></div>
</div>
</div>
<div class="section" id="automated-ctu-analysis-with-scan-build-py-don-t-do-it">
<h3><a class="toc-backref" href="#id10">2.1.2.3. Automated CTU Analysis with scan-build-py (don’t do it)</a><a class="headerlink" href="#automated-ctu-analysis-with-scan-build-py-don-t-do-it" title="Permalink to this headline">¶</a></h3>
<p>We actively develop CTU with CodeChecker as the driver for this feature, <cite>scan-build-py</cite> is not actively developed for CTU.
<cite>scan-build-py</cite> has various errors and issues, expect it to work only with the very basic projects only.</p>
<p>Example usage of scan-build-py:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ /your/path/to/llvm-project/clang/tools/scan-build-py/bin/analyze-build --ctu
analyze-build: Run <span class="s1">&#39;scan-view /tmp/scan-build-2019-07-17-17-53-33-810365-7fqgWk&#39;</span> to examine bug reports.
$ /your/path/to/llvm-project/clang/tools/scan-view/bin/scan-view /tmp/scan-build-2019-07-17-17-53-33-810365-7fqgWk
Starting scan-view at: http://127.0.0.1:8181
  Use Ctrl-C to exit.
<span class="o">[</span><span class="m">6336</span>:6431:0717/175357.633914:ERROR:browser_process_sub_thread.cc<span class="o">(</span><span class="m">209</span><span class="o">)]</span> Waited <span class="m">5</span> ms <span class="k">for</span> network service
Opening in existing browser session.
^C
$
</pre></div>
</div>
</div>
</div>
<div class="section" id="on-demand-analysis">
<span id="ctu-on-demand"></span><h2><a class="toc-backref" href="#id11">2.1.3. On-demand analysis</a><a class="headerlink" href="#on-demand-analysis" title="Permalink to this headline">¶</a></h2>
<p>The analysis produces the necessary AST structure of external TUs during analysis. This requires the
exact compiler invocations for each TU, which can be generated by hand, or by tools driving the analyzer.
The compiler invocation is a shell command that could be used to compile the TU-s main source file.
The mapping from absolute source file paths of a TU to lists of compilation command segments used to
compile said TU are given in YAML format referred to as <cite>invocation list</cite>, and must be passed as an
analyer-config argument.
The index, which maps function USR names to source files containing them must also be generated by the
<cite>clang-extdef-mapping</cite>. Entries in the index must <em>not</em> have an <cite>.ast</cite> suffix if the goal
is to use On-demand analysis, as that extension signals that the entry is to be used as an PCH-dump.
The mapping of external definitions implicitly uses a
<a class="reference internal" href="../../JSONCompilationDatabase.html"><span class="doc">compilation database</span></a> to determine the compilation flags used.
The analysis invocation must be provided with the directory which contains the mapping
files, and the <cite>invocation list</cite> which is used to determine compiler flags.</p>
<div class="section" id="id2">
<h3><a class="toc-backref" href="#id12">2.1.3.1. Manual CTU Analysis</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>Let’s consider these source files in our minimal example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// main.cpp</span>
<span class="kt">int</span> <span class="nf">foo</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">3</span> <span class="o">/</span> <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// foo.cpp</span>
<span class="kt">int</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The compilation database:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>
  <span class="o">{</span>
    <span class="s2">&quot;directory&quot;</span>: <span class="s2">&quot;/path/to/your/project&quot;</span>,
    <span class="s2">&quot;command&quot;</span>: <span class="s2">&quot;clang++ -c foo.cpp -o foo.o&quot;</span>,
    <span class="s2">&quot;file&quot;</span>: <span class="s2">&quot;foo.cpp&quot;</span>
  <span class="o">}</span>,
  <span class="o">{</span>
    <span class="s2">&quot;directory&quot;</span>: <span class="s2">&quot;/path/to/your/project&quot;</span>,
    <span class="s2">&quot;command&quot;</span>: <span class="s2">&quot;clang++ -c main.cpp -o main.o&quot;</span>,
    <span class="s2">&quot;file&quot;</span>: <span class="s2">&quot;main.cpp&quot;</span>
  <span class="o">}</span>
<span class="o">]</span>
</pre></div>
</div>
<p>The <cite>invocation list</cite>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;/path/to/your/project/foo.cpp&quot;</span>:
  - <span class="s2">&quot;clang++&quot;</span>
  - <span class="s2">&quot;-c&quot;</span>
  - <span class="s2">&quot;/path/to/your/project/foo.cpp&quot;</span>
  - <span class="s2">&quot;-o&quot;</span>
  - <span class="s2">&quot;/path/to/your/project/foo.o&quot;</span>

<span class="s2">&quot;/path/to/your/project/main.cpp&quot;</span>:
  - <span class="s2">&quot;clang++&quot;</span>
  - <span class="s2">&quot;-c&quot;</span>
  - <span class="s2">&quot;/path/to/your/project/main.cpp&quot;</span>
  - <span class="s2">&quot;-o&quot;</span>
  - <span class="s2">&quot;/path/to/your/project/main.o&quot;</span>
</pre></div>
</div>
<p>We’d like to analyze <cite>main.cpp</cite> and discover the division by zero bug.
As we are using On-demand mode, we only need to create a CTU index file which holds the <cite>USR</cite> name and location of
external definitions in the source files:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ clang-extdef-mapping -p . foo.cpp
c:@F@foo# /path/to/your/project/foo.cpp
$ clang-extdef-mapping -p . foo.cpp &gt; externalDefMap.txt
</pre></div>
</div>
<p>Now everything is available for the CTU analysis.
We have to feed Clang with CTU specific extra arguments:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ <span class="nb">pwd</span>
/path/to/your/project
$ clang++ --analyze <span class="se">\</span>
    -Xclang -analyzer-config -Xclang experimental-enable-naive-ctu-analysis<span class="o">=</span><span class="nb">true</span> <span class="se">\</span>
    -Xclang -analyzer-config -Xclang ctu-dir<span class="o">=</span>. <span class="se">\</span>
    -Xclang -analyzer-config -Xclang ctu-invocation-list<span class="o">=</span>invocations.yaml <span class="se">\</span>
    -Xclang -analyzer-output<span class="o">=</span>plist-multi-file <span class="se">\</span>
    main.cpp
main.cpp:5:12: warning: Division by zero
  <span class="k">return</span> <span class="m">3</span> / foo<span class="o">()</span><span class="p">;</span>
         ~~^~~~~~~
<span class="m">1</span> warning generated.
$ <span class="c1"># The plist file with the result is generated.</span>
$ ls -F
compile_commands.json  externalDefMap.txt  foo.cpp  main.cpp  main.plist
$
</pre></div>
</div>
<p>This manual procedure is error-prone and not scalable, therefore to analyze real projects it is recommended to use
<cite>CodeChecker</cite> or <cite>scan-build-py</cite>.</p>
</div>
<div class="section" id="id3">
<h3><a class="toc-backref" href="#id13">2.1.3.2. Automated CTU Analysis with CodeChecker</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="https://github.com/Ericsson/codechecker">CodeChecker</a> project fully supports automated CTU analysis with Clang.
Once we have set up the <cite>PATH</cite> environment variable and we activated the python <cite>venv</cite> then it is all it takes:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ CodeChecker analyze --ctu --ctu-ast-loading-mode on-demand compile_commands.json -o reports
$ ls -F
compile_commands.json  foo.cpp main.cpp  reports/
$ tree reports
reports
├── compile_cmd.json
├── compiler_info.json
├── foo.cpp_53f6fbf7ab7ec9931301524b551959e2.plist
├── main.cpp_23db3d8df52ff0812e6e5a03071c8337.plist
├── metadata.json
└── unique_compile_commands.json

<span class="m">0</span> directories, <span class="m">6</span> files
$
</pre></div>
</div>
<p>The <cite>plist</cite> files contain the results of the analysis, which may be viewed with the regular analysis tools.
E.g. one may use <cite>CodeChecker parse</cite> to view the results in command line:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ CodeChecker parse reports
<span class="o">[</span>HIGH<span class="o">]</span> /home/egbomrt/ctu_mini_raw_project/main.cpp:5:12: Division by zero <span class="o">[</span>core.DivideZero<span class="o">]</span>
  <span class="k">return</span> <span class="m">3</span> / foo<span class="o">()</span><span class="p">;</span>
           ^

Found <span class="m">1</span> defect<span class="o">(</span>s<span class="o">)</span> in main.cpp


----<span class="o">====</span> <span class="nv">Summary</span> <span class="o">====</span>----
-----------------------
Filename <span class="p">|</span> Report count
-----------------------
main.cpp <span class="p">|</span>            <span class="m">1</span>
-----------------------
-----------------------
Severity <span class="p">|</span> Report count
-----------------------
HIGH     <span class="p">|</span>            <span class="m">1</span>
-----------------------
----<span class="o">=================</span>----
Total number of reports: <span class="m">1</span>
----<span class="o">=================</span>----
</pre></div>
</div>
<p>Or we can use <cite>CodeChecker parse -e html</cite> to export the results into HTML format:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ CodeChecker parse -e html -o html_out reports
$ firefox html_out/index.html
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id14">2.1.3.3. Automated CTU Analysis with scan-build-py (don’t do it)</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>We actively develop CTU with CodeChecker as the driver for feature, <cite>scan-build-py</cite> is not actively developed for CTU.
<cite>scan-build-py</cite> has various errors and issues, expect it to work only with the very basic projects only.</p>
<p>Currently On-demand analysis is not supported with <cite>scan-build-py</cite>.</p>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="../user-docs.html">2. User Docs</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="../developer-docs.html">3. Developer Docs</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2007-2022, The Clang Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.2.
    </div>
  </body>
</html>