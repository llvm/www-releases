<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>FIR Language Reference &#8212; The Flang Compiler</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=e491ac2d" />
    <script src="_static/documentation_options.js?v=79410cf7"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Flang command line argument reference" href="FlangCommandLineReference.html" />
    <link rel="prev" title="Design: FIR Array operations" href="FIRArrayOperations.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>The Flang Compiler</span></a></h1>
        <h2 class="heading"><span>FIR Language Reference</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="FIRArrayOperations.html">Design: FIR Array operations</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="FlangCommandLineReference.html">Flang command line argument reference</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <!-- Autogenerated by mlir-tblgen; don't manually edit -->
<section id="fir-language-reference">
<h1>FIR Language Reference<a class="headerlink" href="#fir-language-reference" title="Link to this heading">¶</a></h1>
<p>This page contains an overview of the Fortran IR operations, their syntax, and example usages.</p>
<section id="fir-operations">
<h2>FIR Operations<a class="headerlink" href="#fir-operations" title="Link to this heading">¶</a></h2>
<section id="fir-absent-fir-absentop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.absent</span></code> (::fir::AbsentOp)<a class="headerlink" href="#fir-absent-fir-absentop" title="Link to this heading">¶</a></h3>
<p><em>Create value to be passed for absent optional function argument</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.absent` type($intype) attr-dict
</pre></div>
</div>
<p>Given the type of a function argument, create a value that will signal that
an optional argument is absent in the call. On the caller side, fir.is_present
can be used to query if the value of an optional argument was created with
a fir.absent operation.
It is undefined to use a value that was created by a fir.absent op in any other
operation than fir.call and fir.is_present.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %1 = fir.absent fir.box&lt;fir.array&lt;?xf32&gt;&gt;
  fir.call @_QPfoo(%1) : (fir.box&lt;fir.array&lt;?xf32&gt;&gt;) -&gt; ()
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="results">
<h4>Results:<a class="headerlink" href="#results" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">intype</span></code></p></td>
<td><p>any reference or box like</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-addc-fir-addcop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.addc</span></code> (::fir::AddcOp)<a class="headerlink" href="#fir-addc-fir-addcop" title="Link to this heading">¶</a></h3>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.addc` operands attr-dict `:` type($result)
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">Commutative</span></code>, <code class="docutils literal notranslate"><span class="pre">SameOperandsAndResultType</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">ArithFastMathInterface</span></code>, <code class="docutils literal notranslate"><span class="pre">InferTypeOpInterface</span></code>, <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="attributes">
<h4>Attributes:<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td>Floating point fast math flags</td></tr>
</table>
</section>
<section id="operands">
<h4>Operands:<a class="headerlink" href="#operands" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">lhs</span></code></p></td>
<td><p>any floating point complex type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">rhs</span></code></p></td>
<td><p>any floating point complex type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id1">
<h4>Results:<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">result</span></code></p></td>
<td><p>any type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-address-of-fir-addrofop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.address_of</span></code> (::fir::AddrOfOp)<a class="headerlink" href="#fir-address-of-fir-addrofop" title="Link to this heading">¶</a></h3>
<p><em>Convert a symbol to an SSA value</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.address_of` `(` $symbol `)` attr-dict `:` type($resTy)
</pre></div>
</div>
<p>Convert a symbol (a function or global reference) to an SSA-value to be
used in other operations. References to Fortran symbols are distinguished
via this operation from other arbitrary constant values.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %p = fir.address_of(@symbol) : !fir.ref&lt;f64&gt;
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id2">
<h4>Attributes:<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>symbol</code></td><td>::mlir::SymbolRefAttr</td><td>symbol reference attribute</td></tr>
</table>
</section>
<section id="id3">
<h4>Results:<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">resTy</span></code></p></td>
<td><p>any addressable</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-allocmem-fir-allocmemop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.allocmem</span></code> (::fir::AllocMemOp)<a class="headerlink" href="#fir-allocmem-fir-allocmemop" title="Link to this heading">¶</a></h3>
<p><em>Allocate storage on the heap for an object of a given type</em></p>
<p>Creates a heap memory reference suitable for storing a value of the
given type, T.  The heap refernce returned has type <code class="docutils literal notranslate"><span class="pre">!fir.heap&lt;T&gt;</span></code>.
The memory object is in an undefined state.  <code class="docutils literal notranslate"><span class="pre">allocmem</span></code> operations must
be paired with <code class="docutils literal notranslate"><span class="pre">freemem</span></code> operations to avoid memory leaks.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %0 = fir.allocmem !fir.array&lt;10 x f32&gt;
  fir.freemem %0 : !fir.heap&lt;!fir.array&lt;10 x f32&gt;&gt;
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">AttrSizedOperandSegments</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">MemoryEffectOpInterface</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{MemoryEffects::Allocate</span> <span class="pre">on</span> <span class="pre">::mlir::SideEffects::DefaultResource}</span></code></p>
<section id="id4">
<h4>Attributes:<a class="headerlink" href="#id4" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>in_type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr>
<tr><td><code>uniq_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>bindc_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
</table>
</section>
<section id="id5">
<h4>Operands:<a class="headerlink" href="#id5" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">typeparams</span></code></p></td>
<td><p>variadic of any integer</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">shape</span></code></p></td>
<td><p>variadic of any integer</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id6">
<h4>Results:<a class="headerlink" href="#id6" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>Reference to an ALLOCATABLE attribute type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-alloca-fir-allocaop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.alloca</span></code> (::fir::AllocaOp)<a class="headerlink" href="#fir-alloca-fir-allocaop" title="Link to this heading">¶</a></h3>
<p><em>Allocate storage for a temporary on the stack given a type</em></p>
<p>This primitive operation is used to allocate an object on the stack.  A
reference to the object of type <code class="docutils literal notranslate"><span class="pre">!fir.ref&lt;T&gt;</span></code> is returned.  The returned
object has an undefined/uninitialized state.  The allocation can be given
an optional name.  The allocation may have a dynamic repetition count
for allocating a sequence of locations for the specified type.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %c = ... : i64
  %x = fir.alloca i32
  %y = fir.alloca !fir.array&lt;8 x i64&gt;
  %z = fir.alloca f32, %c

  %i = ... : i16
  %j = ... : i32
  %w = fir.alloca !fir.type&lt;PT(len1:i16, len2:i32)&gt; (%i, %j : i16, i32)
</pre></div>
</div>
<p>Note that in the case of <code class="docutils literal notranslate"><span class="pre">%z</span></code>, a contiguous block of memory is allocated
and its size is a runtime multiple of a 32-bit REAL value.</p>
<p>In the case of <code class="docutils literal notranslate"><span class="pre">%w</span></code>, the arguments <code class="docutils literal notranslate"><span class="pre">%i</span></code> and <code class="docutils literal notranslate"><span class="pre">%j</span></code> are LEN parameters
(<code class="docutils literal notranslate"><span class="pre">len1</span></code>, <code class="docutils literal notranslate"><span class="pre">len2</span></code>) to the type <code class="docutils literal notranslate"><span class="pre">PT</span></code>.</p>
<p>Finally, the operation is undefined if the ssa-value <code class="docutils literal notranslate"><span class="pre">%c</span></code> is negative.</p>
<p>Fortran Semantics:
There is no language mechanism in Fortran to allocate space on the stack
like C’s <code class="docutils literal notranslate"><span class="pre">alloca()</span></code> function. Therefore fir.alloca is not control-flow
dependent. However, the lifetime of a stack allocation is often limited to
a small region and a legal implementation may reuse stack storage in other
regions when there is no conflict. For example, take the following code
fragment.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">CALL </span><span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="k">CALL </span><span class="n">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="w">  </span><span class="k">CALL </span><span class="n">foo</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>A legal implementation can allocate a stack slot and initialize it with the
constant <code class="docutils literal notranslate"><span class="pre">1</span></code>, then pass that by reference to foo. Likewise for the second
and third calls to foo, each stack slot being initialized accordingly. It is
also a conforming implementation to reuse the same stack slot for all three
calls, just initializing each in turn. This is possible as the lifetime of
the copy of each constant need not exceed that of the CALL statement.
Indeed, a user would likely expect a good Fortran compiler to perform such
an optimization.</p>
<p>Stack allocations have a maximum lifetime concept: their uses must not
exceed the lifetime of the closest parent operation with the
AutomaticAllocationScope trait, IsIsolatedFromAbove trait, or
LoopLikeOpInterface trait. This restriction is meant to ease the
insertion of stack save and restore operations, and to ease the conversion
of stack allocation into heap allocation.</p>
<p>Until Fortran 2018, procedures defaulted to non-recursive. A legal
implementation could therefore convert stack allocations to global
allocations. Such a conversion effectively adds the SAVE attribute to all
variables.</p>
<p>Some temporary entities (large arrays) probably should not be stack
allocated as stack space can often be limited. A legal implementation can
convert these large stack allocations to heap allocations regardless of
whether the procedure is recursive or not.</p>
<p>The pinned attribute is used to flag fir.alloca operation in a specific
region and avoid them being hoisted in an alloca hoisting pass.</p>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">AttrSizedOperandSegments</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">MemoryEffectOpInterface</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{MemoryEffects::Allocate</span> <span class="pre">on</span> <span class="pre">::mlir::SideEffects::AutomaticAllocationScopeResource}</span></code></p>
<section id="id7">
<h4>Attributes:<a class="headerlink" href="#id7" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>in_type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr>
<tr><td><code>uniq_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>bindc_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>pinned</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr>
</table>
</section>
<section id="id8">
<h4>Operands:<a class="headerlink" href="#id8" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">typeparams</span></code></p></td>
<td><p>variadic of any integer</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">shape</span></code></p></td>
<td><p>variadic of any integer</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id9">
<h4>Results:<a class="headerlink" href="#id9" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>Reference to an entity type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-array-access-fir-arrayaccessop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.array_access</span></code> (::fir::ArrayAccessOp)<a class="headerlink" href="#fir-array-access-fir-arrayaccessop" title="Link to this heading">¶</a></h3>
<p><em>Fetch the reference of an element of an array value</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.array_access` $sequence `,` $indices (`typeparams` $typeparams^)? attr-dict `:`
              functional-type(operands, results)
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">array_access</span></code> provides a reference to a single element from an array
value. This is <em>not</em> a view in the immutable array, otherwise it couldn’t
be stored to. It can be see as a logical copy of the element and its
position in the array. This reference can be written to and modified without
changing the original array.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">array_access</span></code> operation is used to fetch the memory reference of an
element in an array value.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">real</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">...</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">...</span>
</pre></div>
</div>
<p>One can use <code class="docutils literal notranslate"><span class="pre">fir.array_access</span></code> to recover the implied memory reference to
the element <code class="docutils literal notranslate"><span class="pre">a(i,j)</span></code> in an array expression <code class="docutils literal notranslate"><span class="pre">a</span></code> as shown above. It can also
be used to recover the reference element <code class="docutils literal notranslate"><span class="pre">a(r,s+1)</span></code> in the second
expression.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %s = fir.shape %n, %m : (index, index) -&gt; !fir.shape&lt;2&gt;
  // load the entire array &#39;a&#39;
  %v = fir.array_load %a(%s) : (!fir.ref&lt;!fir.array&lt;?x?xf32&gt;&gt;, !fir.shape&lt;2&gt;) -&gt; !fir.array&lt;?x?xf32&gt;
  // fetch the value of one of the array value&#39;s elements
  %1 = fir.array_access %v, %i, %j : (!fir.array&lt;?x?xf32&gt;, index, index) -&gt; !fir.ref&lt;f32&gt;
</pre></div>
</div>
<p>It is only possible to use <code class="docutils literal notranslate"><span class="pre">array_access</span></code> on an <code class="docutils literal notranslate"><span class="pre">array_load</span></code> result value or
a value that can be trace back transitively to an <code class="docutils literal notranslate"><span class="pre">array_load</span></code> as the
dominating source. Other array operation such as <code class="docutils literal notranslate"><span class="pre">array_amend</span></code> can be in
between.</p>
<p>TODO: The above restriction is not enforced. The design of the operation
might need to be revisited to avoid such restrictions.</p>
<p>More information about <code class="docutils literal notranslate"><span class="pre">array_access</span></code> and other array operations can be
found in flang/docs/FIRArrayOperations.md.</p>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">AttrSizedOperandSegments</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id10">
<h4>Operands:<a class="headerlink" href="#id10" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">sequence</span></code></p></td>
<td><p>FIR array type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">indices</span></code></p></td>
<td><p>variadic of coordinate type</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">typeparams</span></code></p></td>
<td><p>variadic of any integer</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id11">
<h4>Results:<a class="headerlink" href="#id11" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">element</span></code></p></td>
<td><p>Reference to an entity type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-array-amend-fir-arrayamendop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.array_amend</span></code> (::fir::ArrayAmendOp)<a class="headerlink" href="#fir-array-amend-fir-arrayamendop" title="Link to this heading">¶</a></h3>
<p><em>Mark an array value as having been changed by reference.</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.array_amend` $sequence `,` $memref attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">array_amend</span></code> operation marks an array value as having been changed via
a reference obtained by an <code class="docutils literal notranslate"><span class="pre">array_access</span></code>. It acts as a logical transaction
log that is used to merge the final result back with an <code class="docutils literal notranslate"><span class="pre">array_merge_store</span></code>
operation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  // fetch the value of one of the array value&#39;s elements
  %1 = fir.array_access %v, %i, %j : (!fir.array&lt;?x?xT&gt;, index, index) -&gt; !fir.ref&lt;T&gt;
  // modify the element by storing data using %1 as a reference
  %2 = ... %1 ...
  // mark the array value
  %new_v = fir.array_amend %v, %2 : (!fir.array&lt;?x?xT&gt;, !fir.ref&lt;T&gt;) -&gt; !fir.array&lt;?x?xT&gt;
</pre></div>
</div>
<p>More information about <code class="docutils literal notranslate"><span class="pre">array_amend</span></code> and other array operations can be
found in flang/docs/FIRArrayOperations.md.</p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id12">
<h4>Operands:<a class="headerlink" href="#id12" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">sequence</span></code></p></td>
<td><p>FIR array type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">memref</span></code></p></td>
<td><p>Reference to an entity type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id13">
<h4>Results:<a class="headerlink" href="#id13" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>FIR array type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-array-coor-fir-arraycoorop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.array_coor</span></code> (::fir::ArrayCoorOp)<a class="headerlink" href="#fir-array-coor-fir-arraycoorop" title="Link to this heading">¶</a></h3>
<p><em>Find the coordinate of an element of an array</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.array_coor` $memref (`(`$shape^`)`)? (`[`$slice^`]`)? $indices (`typeparams`
              $typeparams^)? attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Compute the location of an element in an array when the shape of the
array is only known at runtime.</p>
<p>This operation is intended to capture all the runtime values needed to
compute the address of an array reference in a single high-level op. Given
the following Fortran input:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">real</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">...</span>
</pre></div>
</div>
<p>One can use <code class="docutils literal notranslate"><span class="pre">fir.array_coor</span></code> to determine the address of <code class="docutils literal notranslate"><span class="pre">a(i,j)</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %s = fir.shape %n, %m : (index, index) -&gt; !fir.shape&lt;2&gt;
  %1 = fir.array_coor %a(%s) %i, %j : (!fir.ref&lt;!fir.array&lt;?x?xf32&gt;&gt;, !fir.shape&lt;2&gt;, index, index) -&gt; !fir.ref&lt;f32&gt;
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">AttrSizedOperandSegments</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id14">
<h4>Operands:<a class="headerlink" href="#id14" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">memref</span></code></p></td>
<td><p>any reference or box</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">shape</span></code></p></td>
<td><p>any legal shape or shift type</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">slice</span></code></p></td>
<td><p>FIR slice</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">indices</span></code></p></td>
<td><p>variadic of coordinate type</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">typeparams</span></code></p></td>
<td><p>variadic of any integer</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id15">
<h4>Results:<a class="headerlink" href="#id15" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>Reference to an entity type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-array-fetch-fir-arrayfetchop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.array_fetch</span></code> (::fir::ArrayFetchOp)<a class="headerlink" href="#fir-array-fetch-fir-arrayfetchop" title="Link to this heading">¶</a></h3>
<p><em>Fetch the value of an element of an array value</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.array_fetch` $sequence `,` $indices (`typeparams` $typeparams^)? attr-dict `:`
              functional-type(operands, results)
</pre></div>
</div>
<p>Fetch the value of an element in an array value.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">real</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">...</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">...</span>
</pre></div>
</div>
<p>One can use <code class="docutils literal notranslate"><span class="pre">fir.array_fetch</span></code> to fetch the (implied) value of <code class="docutils literal notranslate"><span class="pre">a(i,j)</span></code> in
an array expression as shown above. It can also be used to extract the
element <code class="docutils literal notranslate"><span class="pre">a(r,s+1)</span></code> in the second expression.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %s = fir.shape %n, %m : (index, index) -&gt; !fir.shape&lt;2&gt;
  // load the entire array &#39;a&#39;
  %v = fir.array_load %a(%s) : (!fir.ref&lt;!fir.array&lt;?x?xf32&gt;&gt;, !fir.shape&lt;2&gt;) -&gt; !fir.array&lt;?x?xf32&gt;
  // fetch the value of one of the array value&#39;s elements
  %1 = fir.array_fetch %v, %i, %j : (!fir.array&lt;?x?xf32&gt;, index, index) -&gt; f32
</pre></div>
</div>
<p>It is only possible to use <code class="docutils literal notranslate"><span class="pre">array_fetch</span></code> on an <code class="docutils literal notranslate"><span class="pre">array_load</span></code> result value.</p>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">AttrSizedOperandSegments</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id16">
<h4>Operands:<a class="headerlink" href="#id16" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">sequence</span></code></p></td>
<td><p>FIR array type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">indices</span></code></p></td>
<td><p>variadic of coordinate type</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">typeparams</span></code></p></td>
<td><p>variadic of any integer</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id17">
<h4>Results:<a class="headerlink" href="#id17" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">element</span></code></p></td>
<td><p>any type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-array-load-fir-arrayloadop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.array_load</span></code> (::fir::ArrayLoadOp)<a class="headerlink" href="#fir-array-load-fir-arrayloadop" title="Link to this heading">¶</a></h3>
<p><em>Load an array as a value.</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.array_load` $memref (`(`$shape^`)`)? (`[`$slice^`]`)? (`typeparams` $typeparams^)?
              attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>This operation taken with array_merge_store captures Fortran’s
copy-in/copy-out semantics. One way to think of this is that array_load
creates a snapshot copy of the entire array. This copy can then be used
as the “original value” of the array while the array’s new value is
computed. The array_merge_store operation is the copy-out semantics, which
merge the updates with the original array value to produce the final array
result. This abstracts the copy operations as opposed to always creating
copies or requiring dependence analysis be performed on the syntax trees
and before lowering to the IR.</p>
<p>Load an entire array as a single SSA value.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">real</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">o</span><span class="p">:</span><span class="n">n</span><span class="p">,</span><span class="n">p</span><span class="p">:</span><span class="n">m</span><span class="p">)</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">...</span>
</pre></div>
</div>
<p>One can use <code class="docutils literal notranslate"><span class="pre">fir.array_load</span></code> to produce an ssa-value that captures an
immutable value of the entire array <code class="docutils literal notranslate"><span class="pre">a</span></code>, as in the Fortran array expression
shown above. Subsequent changes to the memory containing the array do not
alter its composite value. This operation lets one load an array as a
value while applying a runtime shape, shift, or slice to the memory
reference, and its semantics guarantee immutability.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %s = fir.shape_shift %o, %n, %p, %m : (index, index, index, index) -&gt; !fir.shapeshift&lt;2&gt;
  // load the entire array &#39;a&#39;
  %v = fir.array_load %a(%s) : (!fir.ref&lt;!fir.array&lt;?x?xf32&gt;&gt;, !fir.shapeshift&lt;2&gt;) -&gt; !fir.array&lt;?x?xf32&gt;
  // a fir.store here into array %a does not change %v
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">AttrSizedOperandSegments</span></code></p>
<section id="id18">
<h4>Operands:<a class="headerlink" href="#id18" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">memref</span></code></p></td>
<td><p>any reference or box</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">shape</span></code></p></td>
<td><p>any legal shape or shift type</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">slice</span></code></p></td>
<td><p>FIR slice</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">typeparams</span></code></p></td>
<td><p>variadic of any integer</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id19">
<h4>Results:<a class="headerlink" href="#id19" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>FIR array type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-array-merge-store-fir-arraymergestoreop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.array_merge_store</span></code> (::fir::ArrayMergeStoreOp)<a class="headerlink" href="#fir-array-merge-store-fir-arraymergestoreop" title="Link to this heading">¶</a></h3>
<p><em>Store merged array value to memory.</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.array_merge_store` $original `,` $sequence `to` $memref (`[` $slice^ `]`)? (`typeparams`
              $typeparams^)? attr-dict `:` type(operands)
</pre></div>
</div>
<p>Store a merged array value to memory.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">real</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span>
</pre></div>
</div>
<p>One can use <code class="docutils literal notranslate"><span class="pre">fir.array_merge_store</span></code> to merge/copy the value of <code class="docutils literal notranslate"><span class="pre">a</span></code> in an
array expression as shown above.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %v = fir.array_load %a(%shape) : ...
  %r = fir.array_update %v, %f, %i, %j : (!fir.array&lt;?x?xf32&gt;, f32, index, index) -&gt; !fir.array&lt;?x?xf32&gt;
  fir.array_merge_store %v, %r to %a : !fir.ref&lt;!fir.array&lt;?x?xf32&gt;&gt;
</pre></div>
</div>
<p>This operation merges the original loaded array value, <code class="docutils literal notranslate"><span class="pre">%v</span></code>, with the
chained updates, <code class="docutils literal notranslate"><span class="pre">%r</span></code>, and stores the result to the array at address, <code class="docutils literal notranslate"><span class="pre">%a</span></code>.</p>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">AttrSizedOperandSegments</span></code></p>
<section id="id20">
<h4>Operands:<a class="headerlink" href="#id20" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">original</span></code></p></td>
<td><p>FIR array type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">sequence</span></code></p></td>
<td><p>FIR array type</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">memref</span></code></p></td>
<td><p>any reference or box</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">slice</span></code></p></td>
<td><p>FIR slice</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">typeparams</span></code></p></td>
<td><p>variadic of any integer</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-array-modify-fir-arraymodifyop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.array_modify</span></code> (::fir::ArrayModifyOp)<a class="headerlink" href="#fir-array-modify-fir-arraymodifyop" title="Link to this heading">¶</a></h3>
<p><em>Get an address for an array value to modify it.</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.array_modify` $sequence `,` $indices (`typeparams` $typeparams^)? attr-dict
              `:` functional-type(operands, results)
</pre></div>
</div>
<p>Modify the value of an element in an array value through actions done
on the returned address. A new array value is also
returned where all element values of the input array are identical except
for the selected element which is the value after the modification done
on the element address.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">real</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="c">! Elemental user defined assignment from type(SomeType) to real.</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value_of_some_type</span>
</pre></div>
</div>
<p>One can use <code class="docutils literal notranslate"><span class="pre">fir.array_modify</span></code> to update the (implied) value of <code class="docutils literal notranslate"><span class="pre">a(i)</span></code>
in an array expression as shown above.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %s = fir.shape %n : (index) -&gt; !fir.shape&lt;1&gt;
  // Load the entire array &#39;a&#39;.
  %v = fir.array_load %a(%s) : (!fir.ref&lt;!fir.array&lt;?xf32&gt;&gt;, !fir.shape&lt;1&gt;) -&gt; !fir.array&lt;?xf32&gt;
  // Update the value of one of the array value&#39;s elements with a user
  // defined assignment from %rhs.
  %new = fir.do_loop %i = ... (%inner = %v) {
    %rhs = ...
    %addr, %r = fir.array_modify %inner, %i : (!fir.array&lt;?xf32&gt;, index) -&gt; (fir.ref&lt;f32&gt;, !fir.array&lt;?xf32&gt;)
    fir.call @user_def_assign(%addr, %rhs) (fir.ref&lt;f32&gt;, fir.ref&lt;!fir.type&lt;SomeType&gt;&gt;) -&gt; ()
    fir.result %r : !fir.ref&lt;!fir.array&lt;?xf32&gt;&gt;
  }
  fir.array_merge_store %v, %new to %a : !fir.ref&lt;!fir.array&lt;?xf32&gt;&gt;
</pre></div>
</div>
<p>An array value modification behaves as if a mapping function from the indices
to the new value has been added, replacing the previous mapping. These
mappings can be added to the ssa-value, but will not be materialized in
memory until the <code class="docutils literal notranslate"><span class="pre">fir.array_merge_store</span></code> is performed.</p>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">AttrSizedOperandSegments</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id21">
<h4>Operands:<a class="headerlink" href="#id21" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">sequence</span></code></p></td>
<td><p>FIR array type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">indices</span></code></p></td>
<td><p>variadic of coordinate type</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">typeparams</span></code></p></td>
<td><p>variadic of any integer</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id22">
<h4>Results:<a class="headerlink" href="#id22" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>Reference to an entity type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>«unnamed»</p></td>
<td><p>FIR array type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-array-update-fir-arrayupdateop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.array_update</span></code> (::fir::ArrayUpdateOp)<a class="headerlink" href="#fir-array-update-fir-arrayupdateop" title="Link to this heading">¶</a></h3>
<p><em>Update the value of an element of an array value</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.array_update` $sequence `,` $merge `,` $indices (`typeparams` $typeparams^)? attr-dict
              `:` functional-type(operands, results)
</pre></div>
</div>
<p>Updates the value of an element in an array value. A new array value is
returned where all element values of the input array are identical except
for the selected element which is the value passed in the update.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">real</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span>
</pre></div>
</div>
<p>One can use <code class="docutils literal notranslate"><span class="pre">fir.array_update</span></code> to update the (implied) value of <code class="docutils literal notranslate"><span class="pre">a(i,j)</span></code>
in an array expression as shown above.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %s = fir.shape %n, %m : (index, index) -&gt; !fir.shape&lt;2&gt;
  // load the entire array &#39;a&#39;
  %v = fir.array_load %a(%s) : (!fir.ref&lt;!fir.array&lt;?x?xf32&gt;&gt;, !fir.shape&lt;2&gt;) -&gt; !fir.array&lt;?x?xf32&gt;
  // update the value of one of the array value&#39;s elements
  // %r_{ij} = %f  if (i,j) = (%i,%j),   %v_{ij} otherwise
  %r = fir.array_update %v, %f, %i, %j : (!fir.array&lt;?x?xf32&gt;, f32, index, index) -&gt; !fir.array&lt;?x?xf32&gt;
  fir.array_merge_store %v, %r to %a : !fir.ref&lt;!fir.array&lt;?x?xf32&gt;&gt;
</pre></div>
</div>
<p>An array value update behaves as if a mapping function from the indices
to the new value has been added, replacing the previous mapping. These
mappings can be added to the ssa-value, but will not be materialized in
memory until the <code class="docutils literal notranslate"><span class="pre">fir.array_merge_store</span></code> is performed.</p>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">AttrSizedOperandSegments</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id23">
<h4>Operands:<a class="headerlink" href="#id23" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">sequence</span></code></p></td>
<td><p>FIR array type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">merge</span></code></p></td>
<td><p>any type</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">indices</span></code></p></td>
<td><p>variadic of coordinate type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">typeparams</span></code></p></td>
<td><p>variadic of any integer</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id24">
<h4>Results:<a class="headerlink" href="#id24" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>FIR array type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-box-addr-fir-boxaddrop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.box_addr</span></code> (::fir::BoxAddrOp)<a class="headerlink" href="#fir-box-addr-fir-boxaddrop" title="Link to this heading">¶</a></h3>
<p><em>Return a memory reference to the boxed value</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.box_addr` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>This operator is overloaded to work with values of type <code class="docutils literal notranslate"><span class="pre">box</span></code>,
<code class="docutils literal notranslate"><span class="pre">boxchar</span></code>, and <code class="docutils literal notranslate"><span class="pre">boxproc</span></code>.  The result for each of these
cases, respectively, is the address of the data, the address of the
<code class="docutils literal notranslate"><span class="pre">CHARACTER</span></code> data, and the address of the procedure.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %51 = fir.box_addr %box : (!fir.box&lt;f64&gt;) -&gt; !fir.ref&lt;f64&gt;
  %52 = fir.box_addr %boxchar : (!fir.boxchar&lt;1&gt;) -&gt; !fir.ref&lt;!fir.char&lt;1&gt;&gt;
  %53 = fir.box_addr %boxproc : (!fir.boxproc&lt;!P&gt;) -&gt; !P
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id25">
<h4>Operands:<a class="headerlink" href="#id25" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">val</span></code></p></td>
<td><p>any box</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id26">
<h4>Results:<a class="headerlink" href="#id26" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>any code or data reference</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-boxchar-len-fir-boxcharlenop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.boxchar_len</span></code> (::fir::BoxCharLenOp)<a class="headerlink" href="#fir-boxchar-len-fir-boxcharlenop" title="Link to this heading">¶</a></h3>
<p><em>Return the LEN type parameter from a boxchar value</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.boxchar_len` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Extracts the LEN type parameter from a <code class="docutils literal notranslate"><span class="pre">boxchar</span></code> value.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %45 = ... : !boxchar&lt;1&gt;  // CHARACTER(20)
  %59 = fir.boxchar_len %45 : (!fir.boxchar&lt;1&gt;) -&gt; i64  // len=20
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id27">
<h4>Operands:<a class="headerlink" href="#id27" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">val</span></code></p></td>
<td><p>CHARACTER type descriptor.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id28">
<h4>Results:<a class="headerlink" href="#id28" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>any integer</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-box-dims-fir-boxdimsop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.box_dims</span></code> (::fir::BoxDimsOp)<a class="headerlink" href="#fir-box-dims-fir-boxdimsop" title="Link to this heading">¶</a></h3>
<p><em>Return the dynamic dimension information for the boxed value</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.box_dims` $val `,` $dim attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Returns the triple of lower bound, extent, and stride for <code class="docutils literal notranslate"><span class="pre">dim</span></code> dimension
of <code class="docutils literal notranslate"><span class="pre">val</span></code>, which must have a <code class="docutils literal notranslate"><span class="pre">box</span></code> type.  The dimensions are enumerated from
left to right from 0 to rank-1. This operation has undefined behavior if
<code class="docutils literal notranslate"><span class="pre">dim</span></code> is out of bounds.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %c1   = arith.constant 0 : i32
  %52:3 = fir.box_dims %40, %c1 : (!fir.box&lt;!fir.array&lt;*:f64&gt;&gt;, i32) -&gt; (index, index, index)
</pre></div>
</div>
<p>The above is a request to return the left most row (at index 0) triple from
the box. The triple will be the lower bound, extent, and byte-stride, which
are the values encoded in a standard descriptor.</p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">InferTypeOpInterface</span></code>, <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id29">
<h4>Operands:<a class="headerlink" href="#id29" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">val</span></code></p></td>
<td><p>box or class</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">dim</span></code></p></td>
<td><p>any integer</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id30">
<h4>Results:<a class="headerlink" href="#id30" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>index</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>«unnamed»</p></td>
<td><p>index</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>index</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-box-elesize-fir-boxelesizeop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.box_elesize</span></code> (::fir::BoxEleSizeOp)<a class="headerlink" href="#fir-box-elesize-fir-boxelesizeop" title="Link to this heading">¶</a></h3>
<p><em>Return the size of an element of the boxed value</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.box_elesize` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Returns the size of an element in an entity of <code class="docutils literal notranslate"><span class="pre">box</span></code> type.  This size may
not be known until runtime.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %53 = fir.box_elesize %40 : (!fir.box&lt;f32&gt;) -&gt; i32  // size=4
  %54 = fir.box_elesize %40 : (!fir.box&lt;!fir.array&lt;*:f32&gt;&gt;) -&gt; i32
</pre></div>
</div>
<p>In the above example, <code class="docutils literal notranslate"><span class="pre">%53</span></code> may box an array of REAL values while <code class="docutils literal notranslate"><span class="pre">%54</span></code>
must box an array of REAL values (with dynamic rank and extent).</p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id31">
<h4>Operands:<a class="headerlink" href="#id31" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">val</span></code></p></td>
<td><p>box or class</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id32">
<h4>Results:<a class="headerlink" href="#id32" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>any integer</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-box-isalloc-fir-boxisallocop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.box_isalloc</span></code> (::fir::BoxIsAllocOp)<a class="headerlink" href="#fir-box-isalloc-fir-boxisallocop" title="Link to this heading">¶</a></h3>
<p><em>Is the boxed value an ALLOCATABLE?</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.box_isalloc` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Determine if the boxed value was from an ALLOCATABLE entity. This will
return true if the originating box value was from a <code class="docutils literal notranslate"><span class="pre">fir.embox</span></code> op
with a mem-ref value that had the type !fir.heap<T>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %r = ... : !fir.heap&lt;i64&gt;
  %b = fir.embox %r : (!fir.heap&lt;i64&gt;) -&gt; !fir.box&lt;i64&gt;
  %a = fir.box_isalloc %b : (!fir.box&lt;i64&gt;) -&gt; i1  // true
</pre></div>
</div>
<p>The canonical descriptor implementation will carry a flag to record if the
variable is an <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code>.</p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id33">
<h4>Operands:<a class="headerlink" href="#id33" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">val</span></code></p></td>
<td><p>The type of a Fortran descriptor</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id34">
<h4>Results:<a class="headerlink" href="#id34" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>bool-like</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-box-isarray-fir-boxisarrayop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.box_isarray</span></code> (::fir::BoxIsArrayOp)<a class="headerlink" href="#fir-box-isarray-fir-boxisarrayop" title="Link to this heading">¶</a></h3>
<p><em>Is the boxed value an array?</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.box_isarray` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Determine if the boxed value has a positive (&gt; 0) rank. This will return
true if the originating box value was from a fir.embox with a memory
reference value that had the type !fir.array<T> and/or a shape argument.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %r = ... : !fir.ref&lt;i64&gt;
  %c_100 = arith.constant 100 : index
  %d = fir.shape %c_100 : (index) -&gt; !fir.shape&lt;1&gt;
  %b = fir.embox %r(%d) : (!fir.ref&lt;i64&gt;, !fir.shape&lt;1&gt;) -&gt; !fir.box&lt;i64&gt;
  %a = fir.box_isarray %b : (!fir.box&lt;i64&gt;) -&gt; i1  // true
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id35">
<h4>Operands:<a class="headerlink" href="#id35" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">val</span></code></p></td>
<td><p>The type of a Fortran descriptor</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id36">
<h4>Results:<a class="headerlink" href="#id36" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>bool-like</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-box-isptr-fir-boxisptrop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.box_isptr</span></code> (::fir::BoxIsPtrOp)<a class="headerlink" href="#fir-box-isptr-fir-boxisptrop" title="Link to this heading">¶</a></h3>
<p><em>Is the boxed value a POINTER?</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.box_isptr` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Determine if the boxed value was from a POINTER entity.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %p = ... : !fir.ptr&lt;i64&gt;
  %b = fir.embox %p : (!fir.ptr&lt;i64&gt;) -&gt; !fir.box&lt;i64&gt;
  %a = fir.box_isptr %b : (!fir.box&lt;i64&gt;) -&gt; i1  // true
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id37">
<h4>Operands:<a class="headerlink" href="#id37" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">val</span></code></p></td>
<td><p>The type of a Fortran descriptor</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id38">
<h4>Results:<a class="headerlink" href="#id38" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>bool-like</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-box-offset-fir-boxoffsetop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.box_offset</span></code> (::fir::BoxOffsetOp)<a class="headerlink" href="#fir-box-offset-fir-boxoffsetop" title="Link to this heading">¶</a></h3>
<p><em>Get the address of a field in a fir.ref&lt;fir.box&gt;</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.box_offset` $box_ref $field attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Given the address of a fir.box, compute the address of a field inside
the fir.box.
This allows keeping the actual runtime descriptor layout abstract in
FIR while providing access to the pointer addresses in the runtime
descriptor for OpenMP/OpenACC target mapping.</p>
<p>To avoid requiring too much information about the fields that the runtime
descriptor implementation must have, only the base_addr and derived_type
descriptor fields can be addressed.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    %addr = fir.box_offset %box base_addr : (!fir.ref&lt;!fir.box&lt;!fir.array&lt;?xi32&gt;&gt;&gt;) -&gt; !fir.llvm_ptr&lt;!fir.ref&lt;!fir.array&lt;?xi32&gt;&gt;&gt;
    %tdesc = fir.box_offset %box derived_type : (!fir.ref&lt;!fir.box&lt;!fir.type&lt;t&gt;&gt;&gt;) -&gt; !fir.llvm_ptr&lt;!fir.tdesc&lt;!fir.type&lt;t&gt;&gt;&gt;

</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id39">
<h4>Attributes:<a class="headerlink" href="#id39" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>field</code></td><td>fir::BoxFieldAttrAttr</td><td>allowed 32-bit signless integer cases: 0, 1</td></tr>
</table>
</section>
<section id="id40">
<h4>Operands:<a class="headerlink" href="#id40" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">box_ref</span></code></p></td>
<td><p>any reference</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id41">
<h4>Results:<a class="headerlink" href="#id41" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>fir.ref or fir.llvm_ptr</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-boxproc-host-fir-boxprochostop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.boxproc_host</span></code> (::fir::BoxProcHostOp)<a class="headerlink" href="#fir-boxproc-host-fir-boxprochostop" title="Link to this heading">¶</a></h3>
<p><em>Returns the host instance pointer (or null)</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.boxproc_host` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Extract the host context pointer from a boxproc value.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %8 = ... : !fir.boxproc&lt;(!fir.ref&lt;!fir.type&lt;T&gt;&gt;) -&gt; i32&gt;
  %9 = fir.boxproc_host %8 : (!fir.boxproc&lt;(!fir.ref&lt;!fir.type&lt;T&gt;&gt;) -&gt; i32&gt;) -&gt; !fir.ref&lt;tuple&lt;i32, i32&gt;&gt;
</pre></div>
</div>
<p>In the example, the reference to the closure over the host procedure’s
variables is returned. This allows an internal procedure to access the
host’s variables. It is up to lowering to determine the contract between
the host and the internal procedure.</p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id42">
<h4>Operands:<a class="headerlink" href="#id42" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">val</span></code></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</section>
<section id="id43">
<h4>Results:<a class="headerlink" href="#id43" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>Reference to an entity type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-box-rank-fir-boxrankop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.box_rank</span></code> (::fir::BoxRankOp)<a class="headerlink" href="#fir-box-rank-fir-boxrankop" title="Link to this heading">¶</a></h3>
<p><em>Return the number of dimensions for the boxed value</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.box_rank` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Return the rank of a value of <code class="docutils literal notranslate"><span class="pre">box</span></code> type.  If the value is scalar, the
rank is 0.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %57 = fir.box_rank %40 : (!fir.box&lt;!fir.array&lt;*:f64&gt;&gt;) -&gt; i32
  %58 = fir.box_rank %41 : (!fir.box&lt;f64&gt;) -&gt; i32
</pre></div>
</div>
<p>The example <code class="docutils literal notranslate"><span class="pre">%57</span></code> shows how one would determine the rank of an array that
has deferred rank at runtime. This rank should be at least 1. In %58, the
descriptor may be either an array or a scalar, so the value is nonnegative.</p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">MemoryEffectOpInterface</span></code></p>
<section id="id44">
<h4>Operands:<a class="headerlink" href="#id44" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">box</span></code></p></td>
<td><p>fir.box or fir.class type or reference</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id45">
<h4>Results:<a class="headerlink" href="#id45" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>any integer</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-box-typecode-fir-boxtypecodeop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.box_typecode</span></code> (::fir::BoxTypeCodeOp)<a class="headerlink" href="#fir-box-typecode-fir-boxtypecodeop" title="Link to this heading">¶</a></h3>
<p><em>Return the type code the boxed value</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.box_typecode` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Returns the descriptor type code of an entity of <code class="docutils literal notranslate"><span class="pre">box</span></code> type.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %1 = fir.box_typecode %0 : (!fir.box&lt;T&gt;) -&gt; i32
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id46">
<h4>Operands:<a class="headerlink" href="#id46" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">box</span></code></p></td>
<td><p>box or class</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id47">
<h4>Results:<a class="headerlink" href="#id47" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>any integer</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-box-tdesc-fir-boxtypedescop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.box_tdesc</span></code> (::fir::BoxTypeDescOp)<a class="headerlink" href="#fir-box-tdesc-fir-boxtypedescop" title="Link to this heading">¶</a></h3>
<p><em>Return the type descriptor for the boxed value</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.box_tdesc` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Return the opaque type descriptor of a value of <code class="docutils literal notranslate"><span class="pre">box</span></code> type. A type
descriptor is an implementation defined value that fully describes a type
to the Fortran runtime.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %7 = fir.box_tdesc %41 : (!fir.box&lt;f64&gt;) -&gt; !fir.tdesc&lt;f64&gt;
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id48">
<h4>Operands:<a class="headerlink" href="#id48" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">box</span></code></p></td>
<td><p>box or class</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id49">
<h4>Results:<a class="headerlink" href="#id49" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>FIR Type descriptor type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-call-fir-callop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.call</span></code> (::fir::CallOp)<a class="headerlink" href="#fir-call-fir-callop" title="Link to this heading">¶</a></h3>
<p><em>Call a procedure</em></p>
<p>Call the specified function or function reference.</p>
<p>Provides a custom parser and pretty printer to allow a more readable syntax
in the FIR dialect, e.g. <code class="docutils literal notranslate"><span class="pre">fir.call</span> <span class="pre">&#64;sub(%12)</span></code> or <code class="docutils literal notranslate"><span class="pre">fir.call</span> <span class="pre">%20(%22,%23)</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %a = fir.call %funcref(%arg0) : (!fir.ref&lt;f32&gt;) -&gt; f32
  %b = fir.call @function(%arg1, %arg2) : (!fir.ref&lt;f32&gt;, !fir.ref&lt;f32&gt;) -&gt; f32
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">ArithFastMathInterface</span></code>, <code class="docutils literal notranslate"><span class="pre">CallOpInterface</span></code></p>
<section id="id50">
<h4>Attributes:<a class="headerlink" href="#id50" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>callee</code></td><td>::mlir::SymbolRefAttr</td><td>symbol reference attribute</td></tr>
<tr><td><code>procedure_attrs</code></td><td>::fir::FortranProcedureFlagsEnumAttr</td><td>Fortran procedure attributes</td></tr>
<tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td>Floating point fast math flags</td></tr>
</table>
</section>
<section id="id51">
<h4>Operands:<a class="headerlink" href="#id51" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">args</span></code></p></td>
<td><p>variadic of any type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id52">
<h4>Results:<a class="headerlink" href="#id52" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>variadic of any type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-char-convert-fir-charconvertop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.char_convert</span></code> (::fir::CharConvertOp)<a class="headerlink" href="#fir-char-convert-fir-charconvertop" title="Link to this heading">¶</a></h3>
<p><em>Primitive to convert an entity of type CHARACTER from one KIND to a
different KIND.</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.char_convert` $from `for` $count `to` $to attr-dict `:` type(operands)
</pre></div>
</div>
<p>Copy a CHARACTER (must be in memory) of KIND <em>k1</em> to a CHARACTER (also must
be in memory) of KIND <em>k2</em> where <em>k1</em> != <em>k2</em> and the buffers do not
overlap. This latter restriction is unchecked, as the Fortran language
definition eliminates the overlapping in memory case.</p>
<p>The number of code points copied is specified explicitly as the second
argument. The length of the !fir.char type is ignored.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  fir.char_convert %1 for %2 to %3 : !fir.ref&lt;!fir.char&lt;1,?&gt;&gt;, i32,
      !fir.ref&lt;!fir.char&lt;2,20&gt;&gt;
</pre></div>
</div>
<p>Should future support for encodings other than ASCII be supported, codegen
can generate a call to a runtime helper routine which will map the code
points from UTF-8 to UCS-2, for example. Such remappings may not always
be possible as they may involve the creation of more code points than the
<code class="docutils literal notranslate"><span class="pre">count</span></code> limit. These details are left as future to-dos.</p>
<section id="id53">
<h4>Operands:<a class="headerlink" href="#id53" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">from</span></code></p></td>
<td><p>any reference</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">count</span></code></p></td>
<td><p>any integer</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">to</span></code></p></td>
<td><p>any reference</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-cmpc-fir-cmpcop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.cmpc</span></code> (::fir::CmpcOp)<a class="headerlink" href="#fir-cmpc-fir-cmpcop" title="Link to this heading">¶</a></h3>
<p><em>Complex floating-point comparison operator</em></p>
<p>A complex comparison to handle complex types found in FIR.</p>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">SameOperandsAndResultShape</span></code>, <code class="docutils literal notranslate"><span class="pre">SameTypeOperands</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">ArithFastMathInterface</span></code>, <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id54">
<h4>Attributes:<a class="headerlink" href="#id54" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td>Floating point fast math flags</td></tr>
</table>
</section>
<section id="id55">
<h4>Operands:<a class="headerlink" href="#id55" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">lhs</span></code></p></td>
<td><p>any floating point complex type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">rhs</span></code></p></td>
<td><p>any floating point complex type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id56">
<h4>Results:<a class="headerlink" href="#id56" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>any logical</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-convert-fir-convertop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.convert</span></code> (::fir::ConvertOp)<a class="headerlink" href="#fir-convert-fir-convertop" title="Link to this heading">¶</a></h3>
<p><em>Encapsulates all Fortran entity type conversions</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.convert` $value attr-dict `:` functional-type($value, results)
</pre></div>
</div>
<p>Generalized type conversion. Convert the ssa-value from type T to type U.
Not all pairs of types have conversions. When types T and U are the same
type, this instruction is a NOP and may be folded away. This also supports
integer to pointer conversion and pointer to integer conversion.</p>
<p>This operation also allows limited interaction between FIR and LLVM
dialects by allowing conversion between FIR pointer types and llvm.ptr type.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">%</span><span class="n">v</span> <span class="o">=</span> <span class="o">...</span> <span class="p">:</span> <span class="n">i64</span>
  <span class="o">%</span><span class="n">w</span> <span class="o">=</span> <span class="n">fir</span><span class="o">.</span><span class="n">convert</span> <span class="o">%</span><span class="n">v</span> <span class="p">:</span> <span class="p">(</span><span class="n">i64</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">i32</span>
</pre></div>
</div>
<p>The example truncates the value <code class="docutils literal notranslate"><span class="pre">%v</span></code> from an i64 to an i32.</p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id57">
<h4>Operands:<a class="headerlink" href="#id57" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">value</span></code></p></td>
<td><p>any type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id58">
<h4>Results:<a class="headerlink" href="#id58" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">res</span></code></p></td>
<td><p>any type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-coordinate-of-fir-coordinateop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.coordinate_of</span></code> (::fir::CoordinateOp)<a class="headerlink" href="#fir-coordinate-of-fir-coordinateop" title="Link to this heading">¶</a></h3>
<p><em>Finds the coordinate (location) of a value in memory</em></p>
<p>Compute the internal coordinate address starting from a boxed value or
unboxed memory reference. Returns a memory reference. When computing the
coordinate of an array element, the rank of the array must be known and
the number of indexing expressions must not exceed the rank of the array.</p>
<p>This operation will apply the access map from a boxed value implicitly.</p>
<p>Unlike LLVM’s GEP instruction, one cannot stride over the outermost
reference; therefore, the leading 0 index must be omitted.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %i = ... : index
  %h = ... : !fir.heap&lt;!fir.array&lt;100 x f32&gt;&gt;
  %p = fir.coordinate_of %h, %i : (!fir.heap&lt;!fir.array&lt;100 x f32&gt;&gt;, index) -&gt; !fir.ref&lt;f32&gt;
</pre></div>
</div>
<p>In the example, <code class="docutils literal notranslate"><span class="pre">%p</span></code> will be a pointer to the <code class="docutils literal notranslate"><span class="pre">%i</span></code>-th f32 value in the
array <code class="docutils literal notranslate"><span class="pre">%h</span></code>.</p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id59">
<h4>Attributes:<a class="headerlink" href="#id59" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>baseType</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr>
</table>
</section>
<section id="id60">
<h4>Operands:<a class="headerlink" href="#id60" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">ref</span></code></p></td>
<td><p>any reference or box</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">coor</span></code></p></td>
<td><p>variadic of coordinate type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id61">
<h4>Results:<a class="headerlink" href="#id61" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>fir.ref or fir.llvm_ptr</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-dt-component-fir-dtcomponentop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.dt_component</span></code> (::fir::DTComponentOp)<a class="headerlink" href="#fir-dt-component-fir-dtcomponentop" title="Link to this heading">¶</a></h3>
<p><em>Define extra information about a component inside fir.type_info</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.dt_component` $name (`lbs` $lower_bounds^)? (`init` $init_val^)? attr-dict
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">fir</span><span class="o">.</span><span class="n">dt_component</span> <span class="n">i</span> <span class="n">lbs</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="n">init</span> <span class="nd">@init_val</span>
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">HasParent&lt;TypeInfoOp&gt;</span></code></p>
<section id="id62">
<h4>Attributes:<a class="headerlink" href="#id62" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>lower_bounds</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr>
<tr><td><code>init_val</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr>
</table>
</section>
</section>
<section id="fir-dt-entry-fir-dtentryop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.dt_entry</span></code> (::fir::DTEntryOp)<a class="headerlink" href="#fir-dt-entry-fir-dtentryop" title="Link to this heading">¶</a></h3>
<p><em>Map entry in a dispatch table</em></p>
<p>An entry in a dispatch table.  Allows a function symbol to be bound
to a specifier method identifier.  A dispatch operation uses the dynamic
type of a distinguished argument to determine an exact dispatch table
and uses the method identifier to select the type-bound procedure to
be called.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">fir</span><span class="o">.</span><span class="n">dt_entry</span> <span class="n">method_name</span><span class="p">,</span> <span class="nd">@uniquedProcedure</span>
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">HasParent&lt;TypeInfoOp&gt;</span></code></p>
<section id="id63">
<h4>Attributes:<a class="headerlink" href="#id63" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>method</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>proc</code></td><td>::mlir::SymbolRefAttr</td><td>symbol reference attribute</td></tr>
</table>
</section>
</section>
<section id="fir-declare-fir-declareop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.declare</span></code> (::fir::DeclareOp)<a class="headerlink" href="#fir-declare-fir-declareop" title="Link to this heading">¶</a></h3>
<p><em>Declare a variable</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.declare` $memref (`(` $shape^ `)`)? (`typeparams` $typeparams^)?
              (`dummy_scope` $dummy_scope^)?
              attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Tie the properties of a Fortran variable to an address. The properties
include bounds, length parameters, and Fortran attributes.</p>
<p>The memref argument describes the storage of the variable. It may be a
raw address (fir.ref<T>), or a box or class value or address (fir.box<T>,
fir.ref&lt;fir.box<T>&gt;, fir.class<T>, fir.ref&lt;fir.class<T>&gt;).</p>
<p>The shape argument encodes explicit extents and lower bounds. It must be
provided if the memref is the raw address of an array.
The shape argument must not be provided if memref operand is a box or
class value or address, unless the shape is a shift (encodes lower bounds)
and the memref if a box value (this covers assumed shapes with local lower
bounds).</p>
<p>The typeparams values are meant to carry the non-deferred length parameters
(this includes both Fortran assumed and explicit length parameters).
It must always be provided for characters and parametrized derived types
when memref is not a box value or address.</p>
<p>Example:</p>
<p>CHARACTER(n), OPTIONAL, TARGET :: c(10:, 20:)</p>
<p>Can be represented as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>func.func @foo(%arg0: !fir.box&lt;!fir.array&lt;?x?x!fir.char&lt;1,?&gt;&gt;&gt;, %arg1: !fir.ref&lt;i64&gt;) {
  %c10 = arith.constant 10 : index
  %c20 = arith.constant 20 : index
  %1 = fir.load %ag1 : fir.ref&lt;i64&gt;
  %2 = fir.shift %c10, %c20 : (index, index) -&gt; !fir.shift&lt;2&gt;
  %3 = fir.declare %arg0(%2) typeparams %1 {fortran_attrs = #fir.var_attrs&lt;optional, target&gt;, uniq_name = &quot;c&quot;}
  // ... uses %3 as &quot;c&quot;
}
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">AttrSizedOperandSegments</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">FortranVariableOpInterface</span></code>, <code class="docutils literal notranslate"><span class="pre">MemoryEffectOpInterface</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{MemoryEffects::Allocate</span> <span class="pre">on</span> <span class="pre">::fir::DebuggingResource}</span></code></p>
<section id="id64">
<h4>Attributes:<a class="headerlink" href="#id64" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>uniq_name</code></td><td>::mlir::StringAttr</td><td>An Attribute containing a string</td></tr>
<tr><td><code>fortran_attrs</code></td><td>::fir::FortranVariableFlagsAttr</td><td></td></tr>
<tr><td><code>data_attr</code></td><td>::cuf::DataAttributeAttr</td><td>CUDA Fortran variable attributes</td></tr>
</table>
</section>
<section id="id65">
<h4>Operands:<a class="headerlink" href="#id65" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">memref</span></code></p></td>
<td><p>any reference or box</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">shape</span></code></p></td>
<td><p>any legal shape or shift type</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">typeparams</span></code></p></td>
<td><p>variadic of any integer</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">dummy_scope</span></code></p></td>
<td><p>Dummy scope type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id66">
<h4>Results:<a class="headerlink" href="#id66" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>any reference or box</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-dispatch-fir-dispatchop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.dispatch</span></code> (::fir::DispatchOp)<a class="headerlink" href="#fir-dispatch-fir-dispatchop" title="Link to this heading">¶</a></h3>
<p><em>Call a type-bound procedure</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.dispatch` $method `(` $object `:` qualified(type($object)) `)`
              ( `(` $args^ `:` type($args) `)` )? (`-&gt;` type($results)^)?
              (`proc_attrs` $procedure_attrs^)? attr-dict
</pre></div>
</div>
<p>Perform a dynamic dispatch on the method name via the dispatch table
associated with the first operand.  The attribute <code class="docutils literal notranslate"><span class="pre">pass_arg_pos</span></code> can be
used to select a dispatch operand other than the first one.  The absence of
<code class="docutils literal notranslate"><span class="pre">pass_arg_pos</span></code> attribute means nopass.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  // fir.dispatch with no attribute.
  %r = fir.dispatch &quot;methodA&quot;(%o) : (!fir.class&lt;T&gt;) -&gt; i32

  // fir.dispatch with the `pass_arg_pos` attribute.
  %r = fir.dispatch &quot;methodA&quot;(%o : !fir.class&lt;T&gt;) (%o : !fir.class&lt;T&gt;) -&gt; i32 {pass_arg_pos = 0 : i32}
</pre></div>
</div>
<section id="id67">
<h4>Attributes:<a class="headerlink" href="#id67" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>method</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>pass_arg_pos</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>procedure_attrs</code></td><td>::fir::FortranProcedureFlagsEnumAttr</td><td>Fortran procedure attributes</td></tr>
</table>
</section>
<section id="id68">
<h4>Operands:<a class="headerlink" href="#id68" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">object</span></code></p></td>
<td><p>Class type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">args</span></code></p></td>
<td><p>variadic of any type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id69">
<h4>Results:<a class="headerlink" href="#id69" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">results</span></code></p></td>
<td><p>variadic of any type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-divc-fir-divcop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.divc</span></code> (::fir::DivcOp)<a class="headerlink" href="#fir-divc-fir-divcop" title="Link to this heading">¶</a></h3>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.divc` operands attr-dict `:` type($result)
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">SameOperandsAndResultType</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">ArithFastMathInterface</span></code>, <code class="docutils literal notranslate"><span class="pre">InferTypeOpInterface</span></code>, <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id70">
<h4>Attributes:<a class="headerlink" href="#id70" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td>Floating point fast math flags</td></tr>
</table>
</section>
<section id="id71">
<h4>Operands:<a class="headerlink" href="#id71" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">lhs</span></code></p></td>
<td><p>any floating point complex type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">rhs</span></code></p></td>
<td><p>any floating point complex type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id72">
<h4>Results:<a class="headerlink" href="#id72" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">result</span></code></p></td>
<td><p>any type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-do-loop-fir-doloopop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.do_loop</span></code> (::fir::DoLoopOp)<a class="headerlink" href="#fir-do-loop-fir-doloopop" title="Link to this heading">¶</a></h3>
<p><em>Generalized loop operation</em></p>
<p>Generalized high-level looping construct. This operation is similar to
MLIR’s <code class="docutils literal notranslate"><span class="pre">scf.for</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %l = arith.constant 0 : index
  %u = arith.constant 9 : index
  %s = arith.constant 1 : index
  fir.do_loop %i = %l to %u step %s unordered {
    %x = fir.convert %i : (index) -&gt; i32
    %v = fir.call @compute(%x) : (i32) -&gt; f32
    %p = fir.coordinate_of %A, %i : (!fir.ref&lt;!fir.array&lt;?xf32&gt;&gt;, index) -&gt; !fir.ref&lt;f32&gt;
    fir.store %v to %p : !fir.ref&lt;f32&gt;
  }
</pre></div>
</div>
<p>The above example iterates over the interval <code class="docutils literal notranslate"><span class="pre">[%l,</span> <span class="pre">%u]</span></code>. The unordered
keyword indicates that the iterations can be executed in any order.</p>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">AttrSizedOperandSegments</span></code>, <code class="docutils literal notranslate"><span class="pre">RecursiveMemoryEffects</span></code>, <code class="docutils literal notranslate"><span class="pre">RecursivelySpeculatableImplTrait</span></code>, <code class="docutils literal notranslate"><span class="pre">SingleBlockImplicitTerminator&lt;ResultOp&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">SingleBlock</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">ConditionallySpeculatable</span></code>, <code class="docutils literal notranslate"><span class="pre">LoopLikeOpInterface</span></code></p>
<section id="id73">
<h4>Attributes:<a class="headerlink" href="#id73" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>unordered</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr>
<tr><td><code>finalValue</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr>
<tr><td><code>reduceAttrs</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
<tr><td><code>loopAnnotation</code></td><td>::mlir::LLVM::LoopAnnotationAttr</td><td></td></tr>
</table>
</section>
<section id="id74">
<h4>Operands:<a class="headerlink" href="#id74" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">lowerBound</span></code></p></td>
<td><p>index</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">upperBound</span></code></p></td>
<td><p>index</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">step</span></code></p></td>
<td><p>index</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">reduceOperands</span></code></p></td>
<td><p>variadic of any type</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">initArgs</span></code></p></td>
<td><p>variadic of any type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id75">
<h4>Results:<a class="headerlink" href="#id75" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">results</span></code></p></td>
<td><p>variadic of any type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-dummy-scope-fir-dummyscopeop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.dummy_scope</span></code> (::fir::DummyScopeOp)<a class="headerlink" href="#fir-dummy-scope-fir-dummyscopeop" title="Link to this heading">¶</a></h3>
<p><em>Define a scope for dummy arguments</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.dummy_scope` attr-dict `:` type(results)
</pre></div>
</div>
<p>An abstract handle to be used to associate dummy arguments of the same
subroutine between each other. By lowering, all [hl]fir.declare
operations representing declarations of dummy arguments of a subroutine
use the result of this operation. This allows recognizing the references
of these dummy arguments as belonging to the same runtime instance
of the subroutine even after MLIR inlining. Thus, the Fortran aliasing
rules might be applied to those references based on the original
declarations of the dummy arguments.
For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  subroutine test(x, y)
    real, target :: x, y
    x = y ! may alias
    call inner(x, y)
  contains
    subroutine inner(x, y)
      real :: x, y
      x = y ! may not alias
    end subroutine inner
  end subroutine test
</pre></div>
</div>
<p>After MLIR inlining this may look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  func.func @_QPtest(
      %arg0: !fir.ref&lt;f32&gt; {fir.target},
      %arg1: !fir.ref&lt;f32&gt; {fir.target}) {
    %0 = fir.declare %arg0 {fortran_attrs = #fir.var_attrs&lt;target&gt;} :
        (!fir.ref&lt;f32&gt;) -&gt; !fir.ref&lt;f32&gt;
    %1 = fir.declare %arg1 {fortran_attrs = #fir.var_attrs&lt;target&gt;} :
        (!fir.ref&lt;f32&gt;) -&gt; !fir.ref&lt;f32&gt;
    %2 = fir.load %1 : !fir.ref&lt;f32&gt;
    fir.store %2 to %0 : !fir.ref&lt;f32&gt;
    %3 = fir.declare %0 : (!fir.ref&lt;f32&gt;) -&gt; !fir.ref&lt;f32&gt;
    %4 = fir.declare %1 : (!fir.ref&lt;f32&gt;) -&gt; !fir.ref&lt;f32&gt;
    %5 = fir.load %4 : !fir.ref&lt;f32&gt;
    fir.store %5 to %3 : !fir.ref&lt;f32&gt;
    return
  }
</pre></div>
</div>
<p>Without marking %3 and %4 as declaring the dummy arguments
of the same runtime instance of <code class="docutils literal notranslate"><span class="pre">inner</span></code> subroutine the FIR
AliasAnalysis cannot deduce non-aliasing for the second load/store pair.
This information may be preserved by using fir.dummy_scope operation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  func.func @_QPtest(
      %arg0: !fir.ref&lt;f32&gt; {fir.target},
      %arg1: !fir.ref&lt;f32&gt; {fir.target}) {
    %h1 = fir.dummy_scope : i1
    %0 = fir.declare %arg0 dummy_scope(%h1)
        {fortran_attrs = #fir.var_attrs&lt;target&gt;} :
        (!fir.ref&lt;f32&gt;) -&gt; !fir.ref&lt;f32&gt;
    %1 = fir.declare %arg1 dummy_scope(%h1)
        {fortran_attrs = #fir.var_attrs&lt;target&gt;} :
        (!fir.ref&lt;f32&gt;) -&gt; !fir.ref&lt;f32&gt;
    %2 = fir.load %1 : !fir.ref&lt;f32&gt;
    fir.store %2 to %0 : !fir.ref&lt;f32&gt;
    %h2 = fir.dummy_scope : i1
    %3 = fir.declare %0 dummy_scope(%h2) : (!fir.ref&lt;f32&gt;) -&gt; !fir.ref&lt;f32&gt;
    %4 = fir.declare %1 dummy_scope(%h2) : (!fir.ref&lt;f32&gt;) -&gt; !fir.ref&lt;f32&gt;
    %5 = fir.load %4 : !fir.ref&lt;f32&gt;
    fir.store %5 to %3 : !fir.ref&lt;f32&gt;
    return
  }
</pre></div>
</div>
<p>Note that even if <code class="docutils literal notranslate"><span class="pre">inner</span></code> is called and inlined twice inside
<code class="docutils literal notranslate"><span class="pre">test</span></code>, the two inlined instances of <code class="docutils literal notranslate"><span class="pre">inner</span></code> must use two different
fir.dummy_scope operations for their fir.declare ops. This
two distinct fir.dummy_scope must remain distinct during the optimizations.
This is guaranteed by the write memory effect on the DebuggingResource.</p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">InferTypeOpInterface</span></code>, <code class="docutils literal notranslate"><span class="pre">MemoryEffectOpInterface</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{MemoryEffects::Write</span> <span class="pre">on</span> <span class="pre">::fir::DebuggingResource}</span></code></p>
<section id="id76">
<h4>Results:<a class="headerlink" href="#id76" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>Dummy scope type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-emboxchar-fir-emboxcharop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.emboxchar</span></code> (::fir::EmboxCharOp)<a class="headerlink" href="#fir-emboxchar-fir-emboxcharop" title="Link to this heading">¶</a></h3>
<p><em>Boxes a given CHARACTER reference and its LEN parameter</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.emboxchar` $memref `,` $len attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Create a boxed CHARACTER value. The CHARACTER type has the LEN type
parameter, the value of which may only be known at runtime.  Therefore,
a variable of type CHARACTER has both its data reference as well as a
LEN type parameter.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">CHARACTER</span><span class="p">(</span><span class="nb">LEN</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">var</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %4 = ...         : !fir.ref&lt;!fir.array&lt;10 x !fir.char&lt;1&gt;&gt;&gt;
  %5 = arith.constant 10 : i32
  %6 = fir.emboxchar %4, %5 : (!fir.ref&lt;!fir.array&lt;10 x !fir.char&lt;1&gt;&gt;&gt;, i32) -&gt; !fir.boxchar&lt;1&gt;
</pre></div>
</div>
<p>In the above <code class="docutils literal notranslate"><span class="pre">%4</span></code> is a memory reference to a buffer of 10 CHARACTER units.
This buffer and its LEN value (10) are wrapped into a pair in <code class="docutils literal notranslate"><span class="pre">%6</span></code>.</p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id77">
<h4>Operands:<a class="headerlink" href="#id77" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">memref</span></code></p></td>
<td><p>any reference</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">len</span></code></p></td>
<td><p>any integer</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id78">
<h4>Results:<a class="headerlink" href="#id78" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>CHARACTER type descriptor.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-embox-fir-emboxop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.embox</span></code> (::fir::EmboxOp)<a class="headerlink" href="#fir-embox-fir-emboxop" title="Link to this heading">¶</a></h3>
<p><em>Boxes a given reference and (optional) dimension information</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.embox` $memref (`(` $shape^ `)`)? (`[` $slice^ `]`)? (`typeparams` $typeparams^)?
              (`source_box` $sourceBox^)? (`map` $accessMap^)? attr-dict `:`
              functional-type(operands, results)
</pre></div>
</div>
<p>Create a boxed reference value. In Fortran, the implementation can require
extra information about an entity, such as its type, rank, etc.  This
auxiliary information is packaged and abstracted as a value with box type
by the calling routine. (In Fortran, these are called descriptors.)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %c1 = arith.constant 1 : index
  %c10 = arith.constant 10 : index
  %5 = ... : !fir.ref&lt;!fir.array&lt;10 x i32&gt;&gt;
  %6 = fir.embox %5 : (!fir.ref&lt;!fir.array&lt;10 x i32&gt;&gt;) -&gt; !fir.box&lt;!fir.array&lt;10 x i32&gt;&gt;
</pre></div>
</div>
<p>The descriptor tuple may contain additional implementation-specific
information through the use of additional attributes.
Specifically,
- shape: emboxing an array may require shape information (an array’s
lower bounds and extents may not be known until runtime),
- slice: an array section can be described with a slice triple,
- typeparams: for emboxing a derived type with LEN type parameters,
- sourceBox: A box to read information from such as CFI type,
type descriptor or element size to populate the new descriptor.
- accessMap: unused/experimental.
- allocator_idx: specify special allocator to use.</p>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">AttrSizedOperandSegments</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id79">
<h4>Attributes:<a class="headerlink" href="#id79" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>accessMap</code></td><td>::mlir::AffineMapAttr</td><td>AffineMap attribute</td></tr>
<tr><td><code>allocator_idx</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>
</section>
<section id="id80">
<h4>Operands:<a class="headerlink" href="#id80" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">memref</span></code></p></td>
<td><p>any reference</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">shape</span></code></p></td>
<td><p>any legal shape type</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">slice</span></code></p></td>
<td><p>FIR slice</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">typeparams</span></code></p></td>
<td><p>variadic of any integer</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">sourceBox</span></code></p></td>
<td><p>Class type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id81">
<h4>Results:<a class="headerlink" href="#id81" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>box or class</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-emboxproc-fir-emboxprocop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.emboxproc</span></code> (::fir::EmboxProcOp)<a class="headerlink" href="#fir-emboxproc-fir-emboxprocop" title="Link to this heading">¶</a></h3>
<p><em>Boxes a given procedure and optional host context</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.emboxproc` $func (`,` $host^)? attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Creates an abstract encapsulation of a PROCEDURE POINTER along with an
optional pointer to a host instance context. If the pointer is not to an
internal procedure or the internal procedure does not need a host context
then the form takes only the procedure’s symbol.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %f = ... : (i32) -&gt; i32
  %0 = fir.emboxproc %f : ((i32) -&gt; i32) -&gt; !fir.boxproc&lt;(i32) -&gt; i32&gt;
</pre></div>
</div>
<p>An internal procedure requiring a host instance for correct execution uses
the second form. The closure of the host procedure’s state is passed as a
reference to a tuple. It is the responsibility of the host to manage the
context’s values accordingly, up to and including inhibiting register
promotion of local values.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %4 = ... : !fir.ref&lt;tuple&lt;!fir.ref&lt;i32&gt;, !fir.ref&lt;i32&gt;&gt;&gt;
  %g = ... : (i32) -&gt; i32
  %5 = fir.emboxproc %g, %4 : ((i32) -&gt; i32, !fir.ref&lt;tuple&lt;!fir.ref&lt;i32&gt;, !fir.ref&lt;i32&gt;&gt;&gt;) -&gt; !fir.boxproc&lt;(i32) -&gt; i32&gt;
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id82">
<h4>Operands:<a class="headerlink" href="#id82" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">func</span></code></p></td>
<td><p>function type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">host</span></code></p></td>
<td><p>Reference to an entity type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id83">
<h4>Results:<a class="headerlink" href="#id83" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-extract-value-fir-extractvalueop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.extract_value</span></code> (::fir::ExtractValueOp)<a class="headerlink" href="#fir-extract-value-fir-extractvalueop" title="Link to this heading">¶</a></h3>
<p><em>Extract a value from an aggregate SSA-value</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.extract_value` $adt `,` $coor attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Extract a value from an entity with a type composed of tuples, arrays,
and/or derived types. Returns the value from entity with the type of the
specified component. Cannot be used on values of <code class="docutils literal notranslate"><span class="pre">!fir.box</span></code> type.
It can also be used to access complex parts and elements of a character
string.</p>
<p>Note that the entity ssa-value must be of compile-time known size in order
to use this operation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %f = fir.field_index field, !fir.type&lt;X{field:i32}&gt;
  %s = ... : !fir.type&lt;X&gt;
  %v = fir.extract_value %s, %f : (!fir.type&lt;X&gt;, !fir.field) -&gt; i32
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id84">
<h4>Attributes:<a class="headerlink" href="#id84" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>coor</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>
</section>
<section id="id85">
<h4>Operands:<a class="headerlink" href="#id85" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">adt</span></code></p></td>
<td><p>any composite</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id86">
<h4>Results:<a class="headerlink" href="#id86" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">res</span></code></p></td>
<td><p>FIR dialect type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-field-index-fir-fieldindexop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.field_index</span></code> (::fir::FieldIndexOp)<a class="headerlink" href="#fir-field-index-fir-fieldindexop" title="Link to this heading">¶</a></h3>
<p><em>Create a field index value from a field identifier</em></p>
<p>Generate a field (offset) value from an identifier.  Field values may be
lowered into exact offsets when the layout of a Fortran derived type is
known at compile-time. The type of a field value is <code class="docutils literal notranslate"><span class="pre">!fir.field</span></code> and
these values can be used with the <code class="docutils literal notranslate"><span class="pre">fir.coordinate_of</span></code>, <code class="docutils literal notranslate"><span class="pre">fir.extract_value</span></code>,
or <code class="docutils literal notranslate"><span class="pre">fir.insert_value</span></code> instructions to compute (abstract) addresses of
subobjects.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %f = fir.field_index field, !fir.type&lt;X{field:i32}&gt;
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id87">
<h4>Attributes:<a class="headerlink" href="#id87" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>field_id</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>on_type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr>
</table>
</section>
<section id="id88">
<h4>Operands:<a class="headerlink" href="#id88" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">typeparams</span></code></p></td>
<td><p>variadic of any integer</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id89">
<h4>Results:<a class="headerlink" href="#id89" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">res</span></code></p></td>
<td><p>FIR dialect type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-end-fir-firendop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.end</span></code> (::fir::FirEndOp)<a class="headerlink" href="#fir-end-fir-firendop" title="Link to this heading">¶</a></h3>
<p><em>The end instruction</em></p>
<p>The end terminator is a special terminator used inside various FIR
operations that have regions.  End is thus the custom invisible terminator
for these operations.  It is implicit and need not appear in the textual
representation.</p>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">Terminator</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
</section>
<section id="fir-freemem-fir-freememop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.freemem</span></code> (::fir::FreeMemOp)<a class="headerlink" href="#fir-freemem-fir-freememop" title="Link to this heading">¶</a></h3>
<p><em>Free a heap object</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.freemem` $heapref attr-dict `:` qualified(type($heapref))
</pre></div>
</div>
<p>Deallocates a heap memory reference that was allocated by an <code class="docutils literal notranslate"><span class="pre">allocmem</span></code>.
The memory object that is deallocated is placed in an undefined state
after <code class="docutils literal notranslate"><span class="pre">fir.freemem</span></code>.  Optimizations may treat the loading of an object
in the undefined state as undefined behavior.  This includes aliasing
references, such as the result of an <code class="docutils literal notranslate"><span class="pre">fir.embox</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %21 = fir.allocmem !fir.type&lt;ZT(p:i32){field:i32}&gt;
  ...
  fir.freemem %21 : !fir.heap&lt;!fir.type&lt;ZT&gt;&gt;
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">MemoryEffectOpInterface</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{MemoryEffects::Free</span> <span class="pre">on</span> <span class="pre">::mlir::SideEffects::DefaultResource}</span></code></p>
<section id="id90">
<h4>Operands:<a class="headerlink" href="#id90" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">heapref</span></code></p></td>
<td><p>Reference to an ALLOCATABLE attribute type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-global-len-fir-globallenop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.global_len</span></code> (::fir::GlobalLenOp)<a class="headerlink" href="#fir-global-len-fir-globallenop" title="Link to this heading">¶</a></h3>
<p><em>Map a LEN parameter to a global</em></p>
<p>A global entity (that is not an automatic data object) can have extra LEN
parameter (compile-time) constants associated with the instance’s type.
These values can be bound to the global instance used <code class="docutils literal notranslate"><span class="pre">fir.global_len</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  global @g : !fir.type&lt;t(len1:i32)&gt; {
    fir.global_len len1, 10 : i32
    %1 = fir.undefined !fir.type&lt;t(len1:i32)&gt;
    fir.has_value %1 : !fir.type&lt;t(len1:i32)&gt;
  }
</pre></div>
</div>
<section id="id91">
<h4>Attributes:<a class="headerlink" href="#id91" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>lenparam</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>intval</code></td><td>::mlir::IntegerAttr</td><td>arbitrary integer attribute</td></tr>
</table>
</section>
</section>
<section id="fir-global-fir-globalop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.global</span></code> (::fir::GlobalOp)<a class="headerlink" href="#fir-global-fir-globalop" title="Link to this heading">¶</a></h3>
<p><em>Global data</em></p>
<p>A global variable or constant with initial values.</p>
<p>The example creates a global variable (writable) named
<code class="docutils literal notranslate"><span class="pre">&#64;_QV_Mquark_Vvarble</span></code> with some initial values. The initializer should
conform to the variable’s type.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">fir</span><span class="o">.</span><span class="k">global</span> <span class="nd">@_QV_Mquark_Vvarble</span> <span class="p">:</span> <span class="nb">tuple</span><span class="o">&lt;</span><span class="n">i32</span><span class="p">,</span> <span class="n">f32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="o">%</span><span class="mi">1</span> <span class="o">=</span> <span class="n">arith</span><span class="o">.</span><span class="n">constant</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">i32</span>
    <span class="o">%</span><span class="mi">2</span> <span class="o">=</span> <span class="n">arith</span><span class="o">.</span><span class="n">constant</span> <span class="mf">2.0</span> <span class="p">:</span> <span class="n">f32</span>
    <span class="o">%</span><span class="mi">3</span> <span class="o">=</span> <span class="n">fir</span><span class="o">.</span><span class="n">undefined</span> <span class="nb">tuple</span><span class="o">&lt;</span><span class="n">i32</span><span class="p">,</span> <span class="n">f32</span><span class="o">&gt;</span>
    <span class="o">%</span><span class="n">z</span> <span class="o">=</span> <span class="n">arith</span><span class="o">.</span><span class="n">constant</span> <span class="mi">0</span> <span class="p">:</span> <span class="n">index</span>
    <span class="o">%</span><span class="n">o</span> <span class="o">=</span> <span class="n">arith</span><span class="o">.</span><span class="n">constant</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">index</span>
    <span class="o">%</span><span class="mi">4</span> <span class="o">=</span> <span class="n">fir</span><span class="o">.</span><span class="n">insert_value</span> <span class="o">%</span><span class="mi">3</span><span class="p">,</span> <span class="o">%</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="n">z</span> <span class="p">:</span> <span class="p">(</span><span class="nb">tuple</span><span class="o">&lt;</span><span class="n">i32</span><span class="p">,</span> <span class="n">f32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="o">&lt;</span><span class="n">i32</span><span class="p">,</span> <span class="n">f32</span><span class="o">&gt;</span>
    <span class="o">%</span><span class="mi">5</span> <span class="o">=</span> <span class="n">fir</span><span class="o">.</span><span class="n">insert_value</span> <span class="o">%</span><span class="mi">4</span><span class="p">,</span> <span class="o">%</span><span class="mi">2</span><span class="p">,</span> <span class="o">%</span><span class="n">o</span> <span class="p">:</span> <span class="p">(</span><span class="nb">tuple</span><span class="o">&lt;</span><span class="n">i32</span><span class="p">,</span> <span class="n">f32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">f32</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="o">&lt;</span><span class="n">i32</span><span class="p">,</span> <span class="n">f32</span><span class="o">&gt;</span>
    <span class="n">fir</span><span class="o">.</span><span class="n">has_value</span> <span class="o">%</span><span class="mi">5</span> <span class="p">:</span> <span class="nb">tuple</span><span class="o">&lt;</span><span class="n">i32</span><span class="p">,</span> <span class="n">f32</span><span class="o">&gt;</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">IsolatedFromAbove</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">Symbol</span></code></p>
<section id="id92">
<h4>Attributes:<a class="headerlink" href="#id92" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>symref</code></td><td>::mlir::SymbolRefAttr</td><td>symbol reference attribute</td></tr>
<tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr>
<tr><td><code>initVal</code></td><td>::mlir::Attribute</td><td>any attribute</td></tr>
<tr><td><code>constant</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr>
<tr><td><code>target</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr>
<tr><td><code>linkName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>data_attr</code></td><td>::cuf::DataAttributeAttr</td><td>CUDA Fortran variable attributes</td></tr>
<tr><td><code>alignment</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr>
</table>
</section>
</section>
<section id="fir-has-value-fir-hasvalueop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.has_value</span></code> (::fir::HasValueOp)<a class="headerlink" href="#fir-has-value-fir-hasvalueop" title="Link to this heading">¶</a></h3>
<p><em>Terminator for GlobalOp</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.has_value` $resval attr-dict `:` type($resval)
</pre></div>
</div>
<p>The terminator for a GlobalOp with a body.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">global</span> <span class="nd">@variable</span> <span class="p">:</span> <span class="nb">tuple</span><span class="o">&lt;</span><span class="n">i32</span><span class="p">,</span> <span class="n">f32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="o">%</span><span class="mi">0</span> <span class="o">=</span> <span class="n">arith</span><span class="o">.</span><span class="n">constant</span> <span class="mi">45</span> <span class="p">:</span> <span class="n">i32</span>
    <span class="o">%</span><span class="mi">1</span> <span class="o">=</span> <span class="n">arith</span><span class="o">.</span><span class="n">constant</span> <span class="mf">100.0</span> <span class="p">:</span> <span class="n">f32</span>
    <span class="o">%</span><span class="mi">2</span> <span class="o">=</span> <span class="n">fir</span><span class="o">.</span><span class="n">undefined</span> <span class="nb">tuple</span><span class="o">&lt;</span><span class="n">i32</span><span class="p">,</span> <span class="n">f32</span><span class="o">&gt;</span>
    <span class="o">%</span><span class="mi">3</span> <span class="o">=</span> <span class="n">arith</span><span class="o">.</span><span class="n">constant</span> <span class="mi">0</span> <span class="p">:</span> <span class="n">index</span>
    <span class="o">%</span><span class="mi">4</span> <span class="o">=</span> <span class="n">fir</span><span class="o">.</span><span class="n">insert_value</span> <span class="o">%</span><span class="mi">2</span><span class="p">,</span> <span class="o">%</span><span class="mi">0</span><span class="p">,</span> <span class="o">%</span><span class="mi">3</span> <span class="p">:</span> <span class="p">(</span><span class="nb">tuple</span><span class="o">&lt;</span><span class="n">i32</span><span class="p">,</span> <span class="n">f32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="o">&lt;</span><span class="n">i32</span><span class="p">,</span> <span class="n">f32</span><span class="o">&gt;</span>
    <span class="o">%</span><span class="mi">5</span> <span class="o">=</span> <span class="n">arith</span><span class="o">.</span><span class="n">constant</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">index</span>
    <span class="o">%</span><span class="mi">6</span> <span class="o">=</span> <span class="n">fir</span><span class="o">.</span><span class="n">insert_value</span> <span class="o">%</span><span class="mi">4</span><span class="p">,</span> <span class="o">%</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="mi">5</span> <span class="p">:</span> <span class="p">(</span><span class="nb">tuple</span><span class="o">&lt;</span><span class="n">i32</span><span class="p">,</span> <span class="n">f32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">f32</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="o">&lt;</span><span class="n">i32</span><span class="p">,</span> <span class="n">f32</span><span class="o">&gt;</span>
    <span class="n">fir</span><span class="o">.</span><span class="n">has_value</span> <span class="o">%</span><span class="mi">6</span> <span class="p">:</span> <span class="nb">tuple</span><span class="o">&lt;</span><span class="n">i32</span><span class="p">,</span> <span class="n">f32</span><span class="o">&gt;</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">HasParent&lt;GlobalOp&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">Terminator</span></code></p>
<section id="id93">
<h4>Operands:<a class="headerlink" href="#id93" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">resval</span></code></p></td>
<td><p>any type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-if-fir-ifop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.if</span></code> (::fir::IfOp)<a class="headerlink" href="#fir-if-fir-ifop" title="Link to this heading">¶</a></h3>
<p><em>If-then-else conditional operation</em></p>
<p>Used to conditionally execute operations. This operation is the FIR
dialect’s version of <code class="docutils literal notranslate"><span class="pre">loop.if</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %56 = ... : i1
  %78 = ... : !fir.ref&lt;!T&gt;
  fir.if %56 {
    fir.store %76 to %78 : !fir.ref&lt;!T&gt;
  } else {
    fir.store %77 to %78 : !fir.ref&lt;!T&gt;
  }
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">NoRegionArguments</span></code>, <code class="docutils literal notranslate"><span class="pre">RecursiveMemoryEffects</span></code>, <code class="docutils literal notranslate"><span class="pre">RecursivelySpeculatableImplTrait</span></code>, <code class="docutils literal notranslate"><span class="pre">SingleBlockImplicitTerminator&lt;ResultOp&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">SingleBlock</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">ConditionallySpeculatable</span></code>, <code class="docutils literal notranslate"><span class="pre">RegionBranchOpInterface</span></code></p>
<section id="id94">
<h4>Operands:<a class="headerlink" href="#id94" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">condition</span></code></p></td>
<td><p>1-bit signless integer</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id95">
<h4>Results:<a class="headerlink" href="#id95" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">results</span></code></p></td>
<td><p>variadic of any type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-insert-on-range-fir-insertonrangeop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.insert_on_range</span></code> (::fir::InsertOnRangeOp)<a class="headerlink" href="#fir-insert-on-range-fir-insertonrangeop" title="Link to this heading">¶</a></h3>
<p><em>Insert sub-value into a range on an existing sequence</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.insert_on_range` $seq `,` $val custom&lt;CustomRangeSubscript&gt;($coor) attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Insert copies of a value into an entity with an array type of constant shape
and size.
Returns a new ssa-value with the same type as the original entity.
The values are inserted at a contiguous range of indices in Fortran
row-to-column element order as specified by lower and upper bound
coordinates.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %a = fir.undefined !fir.array&lt;10x10xf32&gt;
  %c = arith.constant 3.0 : f32
  %1 = fir.insert_on_range %a, %c from (0, 0) to (7, 2) : (!fir.array&lt;10x10xf32&gt;, f32) -&gt; !fir.array&lt;10x10xf32&gt;
</pre></div>
</div>
<p>The first 28 elements of %1, with coordinates from (0,0) to (7,2), have
the value 3.0.</p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id96">
<h4>Attributes:<a class="headerlink" href="#id96" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>coor</code></td><td>::mlir::DenseIntElementsAttr</td><td>index elements attribute</td></tr>
</table>
</section>
<section id="id97">
<h4>Operands:<a class="headerlink" href="#id97" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">seq</span></code></p></td>
<td><p>FIR array type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">val</span></code></p></td>
<td><p>any type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id98">
<h4>Results:<a class="headerlink" href="#id98" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>FIR array type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-insert-value-fir-insertvalueop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.insert_value</span></code> (::fir::InsertValueOp)<a class="headerlink" href="#fir-insert-value-fir-insertvalueop" title="Link to this heading">¶</a></h3>
<p><em>Insert a new sub-value into a copy of an existing aggregate</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.insert_value` $adt `,` $val `,` $coor attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Insert a value into an entity with a type composed of tuples, arrays,
and/or derived types. Returns a new ssa-value with the same type as the
original entity. Cannot be used on values of <code class="docutils literal notranslate"><span class="pre">!fir.box</span></code> type.
It can also be used to set complex parts and elements of a character
string.</p>
<p>Note that the entity ssa-value must be of compile-time known size in order
to use this operation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %a = ... : !fir.array&lt;10xtuple&lt;i32, f32&gt;&gt;
  %f = ... : f32
  %o = ... : i32
  %c = arith.constant 1 : i32
  %b = fir.insert_value %a, %f, %o, %c : (!fir.array&lt;10x20xtuple&lt;i32, f32&gt;&gt;, f32, i32, i32) -&gt; !fir.array&lt;10x20xtuple&lt;i32, f32&gt;&gt;
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id99">
<h4>Attributes:<a class="headerlink" href="#id99" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>coor</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
</table>
</section>
<section id="id100">
<h4>Operands:<a class="headerlink" href="#id100" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">adt</span></code></p></td>
<td><p>any composite</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">val</span></code></p></td>
<td><p>any type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id101">
<h4>Results:<a class="headerlink" href="#id101" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>any composite</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-is-assumed-size-fir-isassumedsizeop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.is_assumed_size</span></code> (::fir::IsAssumedSizeOp)<a class="headerlink" href="#fir-is-assumed-size-fir-isassumedsizeop" title="Link to this heading">¶</a></h3>
<p><em>Detect if a boxed value is an assumed-size array</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.is_assumed_size` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Fir box SSA values may describe assumed-size arrays. This operation
allows detecting this, even for assumed-rank box.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %a = fir.is_assumed_size %b : (!fir.box&lt;!fir.array&lt;*:f64&gt;&gt;) -&gt; i1
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id102">
<h4>Operands:<a class="headerlink" href="#id102" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">val</span></code></p></td>
<td><p>box or class</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id103">
<h4>Results:<a class="headerlink" href="#id103" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>bool-like</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-is-present-fir-ispresentop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.is_present</span></code> (::fir::IsPresentOp)<a class="headerlink" href="#fir-is-present-fir-ispresentop" title="Link to this heading">¶</a></h3>
<p><em>Is this optional function argument present?</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.is_present` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Determine if an optional function argument is PRESENT (i.e. that it was not
created by a fir.absent op on the caller side).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  func @_QPfoo(%arg0: !fir.box&lt;!fir.array&lt;?xf32&gt;&gt;) {
    %0 = fir.is_present %arg0 : (!fir.box&lt;!fir.array&lt;?xf32&gt;&gt;) -&gt; i1
    ...
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id104">
<h4>Operands:<a class="headerlink" href="#id104" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">val</span></code></p></td>
<td><p>any reference or box like</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id105">
<h4>Results:<a class="headerlink" href="#id105" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>bool-like</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-iterate-while-fir-iterwhileop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.iterate_while</span></code> (::fir::IterWhileOp)<a class="headerlink" href="#fir-iterate-while-fir-iterwhileop" title="Link to this heading">¶</a></h3>
<p><em>DO loop with early exit condition</em></p>
<p>This single-entry, single-exit looping construct is useful for lowering
counted loops that can exit early such as, for instance, implied-DO loops.
It is very similar to <code class="docutils literal notranslate"><span class="pre">fir::DoLoopOp</span></code> with the addition that it requires
a single loop-carried bool value that signals an early exit condition to
the operation. A <code class="docutils literal notranslate"><span class="pre">true</span></code> disposition means the next loop iteration should
proceed. A <code class="docutils literal notranslate"><span class="pre">false</span></code> indicates that the <code class="docutils literal notranslate"><span class="pre">fir.iterate_while</span></code> operation should
terminate and return its iteration arguments. This is a degenerate counted
loop in that the loop is not guaranteed to execute all iterations.</p>
<p>An example iterate_while that returns the counter value, the early
termination condition, and an extra loop-carried value is shown here. This
loop counts from %lo to %up (inclusive), stepping by %c1, so long as the
early exit (%ok) is true. The iter_args %sh value is also carried by the
loop. The result triple is the values of %i=phi(%lo,%i+%c1),</p>
<p>iteration.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">%</span><span class="n">v</span><span class="p">:</span><span class="mi">3</span> <span class="o">=</span> <span class="n">fir</span><span class="o">.</span><span class="n">iterate_while</span> <span class="p">(</span><span class="o">%</span><span class="n">i</span> <span class="o">=</span> <span class="o">%</span><span class="n">lo</span> <span class="n">to</span> <span class="o">%</span><span class="n">up</span> <span class="n">step</span> <span class="o">%</span><span class="n">c1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="o">%</span><span class="n">ok</span> <span class="o">=</span> <span class="o">%</span><span class="n">okIn</span><span class="p">)</span> <span class="n">iter_args</span><span class="p">(</span><span class="o">%</span><span class="n">sh</span> <span class="o">=</span> <span class="o">%</span><span class="n">shIn</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i16</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">%</span><span class="n">shNew</span> <span class="o">=</span> <span class="n">fir</span><span class="o">.</span><span class="n">call</span> <span class="nd">@bar</span><span class="p">(</span><span class="o">%</span><span class="n">sh</span><span class="p">)</span> <span class="p">:</span> <span class="p">(</span><span class="n">i16</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">i16</span>
    <span class="o">%</span><span class="n">okNew</span> <span class="o">=</span> <span class="n">fir</span><span class="o">.</span><span class="n">call</span> <span class="nd">@foo</span><span class="p">(</span><span class="o">%</span><span class="n">sh</span><span class="p">)</span> <span class="p">:</span> <span class="p">(</span><span class="n">i16</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">i1</span>
    <span class="n">fir</span><span class="o">.</span><span class="n">result</span> <span class="o">%</span><span class="n">i</span><span class="p">,</span> <span class="o">%</span><span class="n">okNew</span><span class="p">,</span> <span class="o">%</span><span class="n">shNew</span> <span class="p">:</span> <span class="n">index</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i16</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">RecursiveMemoryEffects</span></code>, <code class="docutils literal notranslate"><span class="pre">RecursivelySpeculatableImplTrait</span></code>, <code class="docutils literal notranslate"><span class="pre">SingleBlockImplicitTerminator&lt;ResultOp&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">SingleBlock</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">ConditionallySpeculatable</span></code>, <code class="docutils literal notranslate"><span class="pre">LoopLikeOpInterface</span></code></p>
<section id="id106">
<h4>Attributes:<a class="headerlink" href="#id106" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>finalValue</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr>
</table>
</section>
<section id="id107">
<h4>Operands:<a class="headerlink" href="#id107" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">lowerBound</span></code></p></td>
<td><p>index</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">upperBound</span></code></p></td>
<td><p>index</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">step</span></code></p></td>
<td><p>index</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">iterateIn</span></code></p></td>
<td><p>1-bit signless integer</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">initArgs</span></code></p></td>
<td><p>variadic of any type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id108">
<h4>Results:<a class="headerlink" href="#id108" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">results</span></code></p></td>
<td><p>variadic of any type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-len-param-index-fir-lenparamindexop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.len_param_index</span></code> (::fir::LenParamIndexOp)<a class="headerlink" href="#fir-len-param-index-fir-lenparamindexop" title="Link to this heading">¶</a></h3>
<p><em>Create a field index value from a LEN type parameter identifier</em></p>
<p>Generate a LEN parameter (offset) value from a LEN parameter identifier.
The type of a LEN parameter value is <code class="docutils literal notranslate"><span class="pre">!fir.len</span></code> and these values can be
used with the <code class="docutils literal notranslate"><span class="pre">fir.coordinate_of</span></code> instructions to compute (abstract)
addresses of LEN parameters.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %e = fir.len_param_index len1, !fir.type&lt;X(len1:i32)&gt;
  %p = ... : !fir.box&lt;!fir.type&lt;X&gt;&gt;
  %q = fir.coordinate_of %p, %e : (!fir.box&lt;!fir.type&lt;X&gt;&gt;, !fir.len) -&gt; !fir.ref&lt;i32&gt;
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id109">
<h4>Attributes:<a class="headerlink" href="#id109" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>field_id</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>on_type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr>
</table>
</section>
<section id="id110">
<h4>Operands:<a class="headerlink" href="#id110" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">typeparams</span></code></p></td>
<td><p>variadic of any integer</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id111">
<h4>Results:<a class="headerlink" href="#id111" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">res</span></code></p></td>
<td><p>FIR dialect type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-load-fir-loadop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.load</span></code> (::fir::LoadOp)<a class="headerlink" href="#fir-load-fir-loadop" title="Link to this heading">¶</a></h3>
<p><em>Load a value from a memory reference</em></p>
<p>Load a value from a memory reference into an ssa-value (virtual register).
Produces an immutable ssa-value of the referent type. A memory reference
has type <code class="docutils literal notranslate"><span class="pre">!fir.ref&lt;T&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">!fir.heap&lt;T&gt;</span></code>, or <code class="docutils literal notranslate"><span class="pre">!fir.ptr&lt;T&gt;</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %a = fir.alloca i32
  %l = fir.load %a : !fir.ref&lt;i32&gt;
</pre></div>
</div>
<p>The ssa-value has an undefined value if the memory reference is undefined
or null.</p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">FirAliasTagOpInterface</span></code></p>
<section id="id112">
<h4>Attributes:<a class="headerlink" href="#id112" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr>
</table>
</section>
<section id="id113">
<h4>Operands:<a class="headerlink" href="#id113" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">memref</span></code></p></td>
<td><p>any reference</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id114">
<h4>Results:<a class="headerlink" href="#id114" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">res</span></code></p></td>
<td><p>FIR dialect type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-mulc-fir-mulcop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.mulc</span></code> (::fir::MulcOp)<a class="headerlink" href="#fir-mulc-fir-mulcop" title="Link to this heading">¶</a></h3>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.mulc` operands attr-dict `:` type($result)
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">Commutative</span></code>, <code class="docutils literal notranslate"><span class="pre">SameOperandsAndResultType</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">ArithFastMathInterface</span></code>, <code class="docutils literal notranslate"><span class="pre">InferTypeOpInterface</span></code>, <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id115">
<h4>Attributes:<a class="headerlink" href="#id115" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td>Floating point fast math flags</td></tr>
</table>
</section>
<section id="id116">
<h4>Operands:<a class="headerlink" href="#id116" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">lhs</span></code></p></td>
<td><p>any floating point complex type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">rhs</span></code></p></td>
<td><p>any floating point complex type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id117">
<h4>Results:<a class="headerlink" href="#id117" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">result</span></code></p></td>
<td><p>any type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-negc-fir-negcop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.negc</span></code> (::fir::NegcOp)<a class="headerlink" href="#fir-negc-fir-negcop" title="Link to this heading">¶</a></h3>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.negc` operands attr-dict `:` type($result)
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">SameOperandsAndResultType</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">InferTypeOpInterface</span></code>, <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id118">
<h4>Operands:<a class="headerlink" href="#id118" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">operand</span></code></p></td>
<td><p>any floating point complex type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id119">
<h4>Results:<a class="headerlink" href="#id119" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">result</span></code></p></td>
<td><p>any type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-no-reassoc-fir-noreassocop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.no_reassoc</span></code> (::fir::NoReassocOp)<a class="headerlink" href="#fir-no-reassoc-fir-noreassocop" title="Link to this heading">¶</a></h3>
<p><em>Synthetic op to prevent reassociation</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.no_reassoc` $val attr-dict `:` type($val)
</pre></div>
</div>
<p>Primitive operation meant to intrusively prevent operator reassociation.
The operation is otherwise a nop and the value returned is the same as the
argument.</p>
<p>The presence of this operation prevents any local optimizations. In the
example below, this would prevent possibly replacing the multiply and add
operations with a single FMA operation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">%</span><span class="mi">98</span> <span class="o">=</span> <span class="n">arith</span><span class="o">.</span><span class="n">mulf</span> <span class="o">%</span><span class="mi">96</span><span class="p">,</span> <span class="o">%</span><span class="mi">97</span> <span class="p">:</span> <span class="n">f32</span>
  <span class="o">%</span><span class="mi">99</span> <span class="o">=</span> <span class="n">fir</span><span class="o">.</span><span class="n">no_reassoc</span> <span class="o">%</span><span class="mi">98</span> <span class="p">:</span> <span class="n">f32</span>
  <span class="o">%</span><span class="n">a0</span> <span class="o">=</span> <span class="n">arith</span><span class="o">.</span><span class="n">addf</span> <span class="o">%</span><span class="mi">99</span><span class="p">,</span> <span class="o">%</span><span class="mi">95</span> <span class="p">:</span> <span class="n">f32</span>
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">SameOperandsAndResultType</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">InferTypeOpInterface</span></code>, <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id120">
<h4>Operands:<a class="headerlink" href="#id120" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">val</span></code></p></td>
<td><p>any type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id121">
<h4>Results:<a class="headerlink" href="#id121" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">res</span></code></p></td>
<td><p>FIR dialect type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-rebox-assumed-rank-fir-reboxassumedrankop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.rebox_assumed_rank</span></code> (::fir::ReboxAssumedRankOp)<a class="headerlink" href="#fir-rebox-assumed-rank-fir-reboxassumedrankop" title="Link to this heading">¶</a></h3>
<p><em>Create an assumed-rank box given another assumed-rank box</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.rebox_assumed_rank` $box `lbs` $lbs_modifier
              attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Limited version of fir.rebox for assumed-rank. Only the lower bounds,
attribute, and element type may change.</p>
<p>The input may be a box or a reference to a box, in which case the operation
reads the incoming reference.
Since a fir.shift cannot be built without knowing the rank statically,
lower bound changes are encoded via a LowerBoundModifierAttribute.
Attribute and element type change are encoded in the result type.
Changing the element type is only allowed if the input type is a derived
type that extends the output element type.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  fir.rebox_assumed_rank %1 lbs zeroes : (!fir.box&lt;!fir.array&lt;*:f32&gt;&gt;) -&gt; !fir.box&lt;!fir.array&lt;*:f32&gt;&gt;
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">MemoryEffectOpInterface</span></code></p>
<section id="id122">
<h4>Attributes:<a class="headerlink" href="#id122" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>lbs_modifier</code></td><td>::fir::LowerBoundModifierAttributeAttr</td><td>Describes how to modify lower bounds</td></tr>
</table>
</section>
<section id="id123">
<h4>Operands:<a class="headerlink" href="#id123" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">box</span></code></p></td>
<td><p>any legal ref or box type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id124">
<h4>Results:<a class="headerlink" href="#id124" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>box or class</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-rebox-fir-reboxop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.rebox</span></code> (::fir::ReboxOp)<a class="headerlink" href="#fir-rebox-fir-reboxop" title="Link to this heading">¶</a></h3>
<p><em>Create a box given another box and (optional) dimension information</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.rebox` $box (`(` $shape^ `)`)? (`[` $slice^ `]`)?
              attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Create a new boxed reference value from another box. This is meant to be
used when the taking a reference to part of a boxed value, or to an entire
boxed value with new shape or type information.</p>
<p>The new extra information can be:</p>
<ul class="simple">
<li><p>new shape information (new lower bounds, new rank, or new extents.
New rank/extents can only be provided if the original fir.box is
contiguous in all dimension but maybe the first row). The shape
operand must be provided to set new shape information.</p></li>
<li><p>new type (only for derived types). It is possible to set the dynamic
type of the new box to one of the parent types of the input box dynamic
type. Type parameters cannot be changed. This change is reflected in
the requested result type of the new box.</p></li>
</ul>
<p>A slice argument can be provided to build a reference to part of a boxed
value. In this case, the shape operand must be absent or be a fir.shift
that can be used to provide a non default origin for the slice.</p>
<p>The following example illustrates creating a fir.box for x(10:33:2)
where x is described by a fir.box and has non default lower bounds,
and then applying a new 2-dimension shape to this fir.box.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %0 = fir.slice %c10, %c33, %c2 : (index, index, index) -&gt; !fir.slice&lt;1&gt;
  %1 = fir.shift %c0 : (index) -&gt; !fir.shift&lt;1&gt;
  %2 = fir.rebox %x(%1) [%0] : (!fir.box&lt;!fir.array&lt;?xf32&gt;&gt;, !fir.shift&lt;1&gt;, !fir.slice&lt;1&gt;) -&gt; !fir.box&lt;!fir.array&lt;?xf32&gt;&gt;
  %3 = fir.shape %c3, %c4 : (index, index) -&gt; !fir.shape&lt;2&gt;
  %4 = fir.rebox %2(%3) : (!fir.box&lt;!fir.array&lt;?xf32&gt;&gt;, !fir.shape&lt;2&gt;) -&gt; !fir.box&lt;!fir.array&lt;?x?xf32&gt;&gt;
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">AttrSizedOperandSegments</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id125">
<h4>Operands:<a class="headerlink" href="#id125" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">box</span></code></p></td>
<td><p>box or class</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">shape</span></code></p></td>
<td><p>any legal shape or shift type</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">slice</span></code></p></td>
<td><p>FIR slice</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id126">
<h4>Results:<a class="headerlink" href="#id126" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>box or class</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-result-fir-resultop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.result</span></code> (::fir::ResultOp)<a class="headerlink" href="#fir-result-fir-resultop" title="Link to this heading">¶</a></h3>
<p><em>Special terminator for use in fir region operations</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.result` ($results^ `:` type($results))? attr-dict
</pre></div>
</div>
<p>Result takes a list of ssa-values produced in the block and forwards them
as a result to the operation that owns the region of the block. The
operation can retain the values or return them to its parent block
depending upon its semantics.</p>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">HasParent&lt;IfOp,</span> <span class="pre">DoLoopOp,</span> <span class="pre">IterWhileOp&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">ReturnLike</span></code>, <code class="docutils literal notranslate"><span class="pre">Terminator</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code>, <code class="docutils literal notranslate"><span class="pre">RegionBranchTerminatorOpInterface</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id127">
<h4>Operands:<a class="headerlink" href="#id127" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">results</span></code></p></td>
<td><p>variadic of any type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-save-result-fir-saveresultop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.save_result</span></code> (::fir::SaveResultOp)<a class="headerlink" href="#fir-save-result-fir-saveresultop" title="Link to this heading">¶</a></h3>
<p><em>Save an array, box, or record function result SSA-value to a memory location</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.save_result` $value `to` $memref (`(` $shape^ `)`)? (`typeparams` $typeparams^)?
              attr-dict `:` type(operands)
</pre></div>
</div>
<p>Save the result of a function returning an array, box, or record type value
into a memory location given the shape and LEN parameters of the result.</p>
<p>Function results of type fir.box, fir.array, or fir.rec are abstract values
that require a storage to be manipulated on the caller side. This operation
allows associating such abstract result to a storage. In later lowering of
the function interfaces, this storage might be used to pass the result in
memory.</p>
<p>For arrays, result, it is required to provide the shape of the result. For
character arrays and derived types with LEN parameters, the LEN parameter
values must be provided.</p>
<p>The fir.save_result associated to a function call must immediately follow
the call and be in the same block.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %buffer = fir.alloca fir.array&lt;?xf32&gt;, %c100
  %shape = fir.shape %c100
  %array_result = fir.call @foo() : () -&gt; fir.array&lt;?xf32&gt;
  fir.save_result %array_result to %buffer(%shape)
  %coor = fir.array_coor %buffer%(%shape), %c5
  %fifth_element = fir.load %coor : f32
</pre></div>
</div>
<p>The above fir.save_result allows saving a fir.array function result into
a buffer to later access its 5th element.</p>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">AttrSizedOperandSegments</span></code></p>
<section id="id128">
<h4>Operands:<a class="headerlink" href="#id128" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">value</span></code></p></td>
<td><p>fir.box, fir.array or fir.type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">memref</span></code></p></td>
<td><p>any reference</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">shape</span></code></p></td>
<td><p>any legal shape type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">typeparams</span></code></p></td>
<td><p>variadic of any integer</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-select-case-fir-selectcaseop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.select_case</span></code> (::fir::SelectCaseOp)<a class="headerlink" href="#fir-select-case-fir-selectcaseop" title="Link to this heading">¶</a></h3>
<p><em>Fortran’s SELECT CASE statement</em></p>
<p>Similar to <code class="docutils literal notranslate"><span class="pre">select</span></code>, <code class="docutils literal notranslate"><span class="pre">select_case</span></code> provides a way to express Fortran’s
SELECT CASE construct.  In this case, the selector value is matched
against variables (not just constants) and ranges.  The structure is
the same as <code class="docutils literal notranslate"><span class="pre">select</span></code>, but <code class="docutils literal notranslate"><span class="pre">select_case</span></code> allows for the expression of
more complex match conditions.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">fir</span><span class="o">.</span><span class="n">select_case</span> <span class="o">%</span><span class="n">arg</span> <span class="p">:</span> <span class="n">i32</span> <span class="p">[</span>
        <span class="c1">#fir.point, %0, ^bb1(%0 : i32),</span>
        <span class="c1">#fir.lower, %1, ^bb2(%2,%arg,%arg2,%1 : i32,i32,i32,i32),</span>
        <span class="c1">#fir.interval, %2, %3, ^bb3(%2,%arg2 : i32,i32),</span>
        <span class="c1">#fir.upper, %arg, ^bb4(%1 : i32),</span>
        <span class="n">unit</span><span class="p">,</span> <span class="o">^</span><span class="n">bb5</span><span class="p">]</span>
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">AttrSizedOperandSegments</span></code>, <code class="docutils literal notranslate"><span class="pre">Terminator</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">BranchOpInterface</span></code></p>
<section id="id129">
<h4>Operands:<a class="headerlink" href="#id129" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">selector</span></code></p></td>
<td><p>any type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">compareArgs</span></code></p></td>
<td><p>variadic of any type</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">targetArgs</span></code></p></td>
<td><p>variadic of any type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="successors">
<h4>Successors:<a class="headerlink" href="#successors" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Successor</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">targets</span></code></p></td>
<td><p>any successor</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-select-fir-selectop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.select</span></code> (::fir::SelectOp)<a class="headerlink" href="#fir-select-fir-selectop" title="Link to this heading">¶</a></h3>
<p><em>A multiway branch</em></p>
<p>A multiway branch terminator with similar semantics to C’s <code class="docutils literal notranslate"><span class="pre">switch</span></code>
statement.  A selector value is matched against a list of constants
of the same type for a match.  When a match is found, control is
transferred to the corresponding basic block.  A <code class="docutils literal notranslate"><span class="pre">select</span></code> must have
at least one basic block with a corresponding <code class="docutils literal notranslate"><span class="pre">unit</span></code> match, and
that block will be selected when all other conditions fail to match.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">fir</span><span class="o">.</span><span class="n">select</span> <span class="o">%</span><span class="n">arg</span><span class="p">:</span><span class="n">i32</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">^</span><span class="n">bb1</span><span class="p">(</span><span class="o">%</span><span class="mi">0</span> <span class="p">:</span> <span class="n">i32</span><span class="p">),</span>
                       <span class="mi">2</span><span class="p">,</span> <span class="o">^</span><span class="n">bb2</span><span class="p">(</span><span class="o">%</span><span class="mi">2</span><span class="p">,</span><span class="o">%</span><span class="n">arg</span><span class="p">,</span><span class="o">%</span><span class="n">arg2</span> <span class="p">:</span> <span class="n">i32</span><span class="p">,</span><span class="n">i32</span><span class="p">,</span><span class="n">i32</span><span class="p">),</span>
                      <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">^</span><span class="n">bb3</span><span class="p">(</span><span class="o">%</span><span class="n">arg2</span><span class="p">,</span><span class="o">%</span><span class="mi">2</span> <span class="p">:</span> <span class="n">i32</span><span class="p">,</span><span class="n">i32</span><span class="p">),</span>
                       <span class="mi">4</span><span class="p">,</span> <span class="o">^</span><span class="n">bb4</span><span class="p">(</span><span class="o">%</span><span class="mi">1</span> <span class="p">:</span> <span class="n">i32</span><span class="p">),</span>
                    <span class="n">unit</span><span class="p">,</span> <span class="o">^</span><span class="n">bb5</span><span class="p">]</span>
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">AttrSizedOperandSegments</span></code>, <code class="docutils literal notranslate"><span class="pre">Terminator</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">BranchOpInterface</span></code></p>
<section id="id130">
<h4>Operands:<a class="headerlink" href="#id130" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">selector</span></code></p></td>
<td><p>any type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">compareArgs</span></code></p></td>
<td><p>variadic of any type</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">targetArgs</span></code></p></td>
<td><p>variadic of any type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id131">
<h4>Successors:<a class="headerlink" href="#id131" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Successor</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">targets</span></code></p></td>
<td><p>any successor</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-select-rank-fir-selectrankop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.select_rank</span></code> (::fir::SelectRankOp)<a class="headerlink" href="#fir-select-rank-fir-selectrankop" title="Link to this heading">¶</a></h3>
<p><em>Fortran’s SELECT RANK statement</em></p>
<p>Similar to <code class="docutils literal notranslate"><span class="pre">select</span></code>, <code class="docutils literal notranslate"><span class="pre">select_rank</span></code> provides a way to express Fortran’s
SELECT RANK construct.  In this case, the rank of the selector value
is matched against constants of integer type.  The structure is the
same as <code class="docutils literal notranslate"><span class="pre">select</span></code>, but <code class="docutils literal notranslate"><span class="pre">select_rank</span></code> determines the rank of the selector
variable at runtime to determine the best match.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">fir</span><span class="o">.</span><span class="n">select_rank</span> <span class="o">%</span><span class="n">arg</span><span class="p">:</span><span class="n">i32</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">^</span><span class="n">bb1</span><span class="p">(</span><span class="o">%</span><span class="mi">0</span> <span class="p">:</span> <span class="n">i32</span><span class="p">),</span>
                            <span class="mi">2</span><span class="p">,</span> <span class="o">^</span><span class="n">bb2</span><span class="p">(</span><span class="o">%</span><span class="mi">2</span><span class="p">,</span><span class="o">%</span><span class="n">arg</span><span class="p">,</span><span class="o">%</span><span class="n">arg2</span> <span class="p">:</span> <span class="n">i32</span><span class="p">,</span><span class="n">i32</span><span class="p">,</span><span class="n">i32</span><span class="p">),</span>
                            <span class="mi">3</span><span class="p">,</span> <span class="o">^</span><span class="n">bb3</span><span class="p">(</span><span class="o">%</span><span class="n">arg2</span><span class="p">,</span><span class="o">%</span><span class="mi">2</span> <span class="p">:</span> <span class="n">i32</span><span class="p">,</span><span class="n">i32</span><span class="p">),</span>
                           <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">^</span><span class="n">bb4</span><span class="p">(</span><span class="o">%</span><span class="mi">1</span> <span class="p">:</span> <span class="n">i32</span><span class="p">),</span>
                         <span class="n">unit</span><span class="p">,</span> <span class="o">^</span><span class="n">bb5</span><span class="p">]</span>
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">AttrSizedOperandSegments</span></code>, <code class="docutils literal notranslate"><span class="pre">Terminator</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">BranchOpInterface</span></code></p>
<section id="id132">
<h4>Operands:<a class="headerlink" href="#id132" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">selector</span></code></p></td>
<td><p>any type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">compareArgs</span></code></p></td>
<td><p>variadic of any type</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">targetArgs</span></code></p></td>
<td><p>variadic of any type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id133">
<h4>Successors:<a class="headerlink" href="#id133" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Successor</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">targets</span></code></p></td>
<td><p>any successor</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-select-type-fir-selecttypeop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.select_type</span></code> (::fir::SelectTypeOp)<a class="headerlink" href="#fir-select-type-fir-selecttypeop" title="Link to this heading">¶</a></h3>
<p><em>Fortran’s SELECT TYPE statement</em></p>
<p>Similar to <code class="docutils literal notranslate"><span class="pre">select</span></code>, <code class="docutils literal notranslate"><span class="pre">select_type</span></code> provides a way to express Fortran’s
SELECT TYPE construct.  In this case, the type of the selector value
is matched against a list of type descriptors.  The structure is the
same as <code class="docutils literal notranslate"><span class="pre">select</span></code>, but <code class="docutils literal notranslate"><span class="pre">select_type</span></code> determines the type of the selector
variable at runtime to determine the best match.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  fir.select_type %arg : !fir.box&lt;()&gt; [
      #fir.type_is&lt;!fir.type&lt;type1&gt;&gt;, ^bb1(%0 : i32),
      #fir.type_is&lt;!fir.type&lt;type2&gt;&gt;, ^bb2(%2 : i32),
      #fir.class_is&lt;!fir.type&lt;type3&gt;&gt;, ^bb3(%2 : i32),
      #fir.type_is&lt;!fir.type&lt;type4&gt;&gt;, ^bb4(%1,%3 : i32,f32),
      unit, ^bb5]
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">AttrSizedOperandSegments</span></code>, <code class="docutils literal notranslate"><span class="pre">Terminator</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">BranchOpInterface</span></code></p>
<section id="id134">
<h4>Operands:<a class="headerlink" href="#id134" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">selector</span></code></p></td>
<td><p>any type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">compareArgs</span></code></p></td>
<td><p>variadic of any type</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">targetArgs</span></code></p></td>
<td><p>variadic of any type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id135">
<h4>Successors:<a class="headerlink" href="#id135" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Successor</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">targets</span></code></p></td>
<td><p>any successor</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-shape-fir-shapeop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.shape</span></code> (::fir::ShapeOp)<a class="headerlink" href="#fir-shape-fir-shapeop" title="Link to this heading">¶</a></h3>
<p><em>Generate an abstract shape vector of type <code class="docutils literal notranslate"><span class="pre">!fir.shape</span></code></em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.shape` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>The arguments are an ordered list of integral type values that define the
runtime extent of each dimension of an array. The shape information is
given in the same row-to-column order as Fortran. This abstract shape value
must be applied to a reified object, so all shape information must be
specified.  The extent must be nonnegative.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %d = fir.shape %row_sz, %col_sz : (index, index) -&gt; !fir.shape&lt;2&gt;
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id136">
<h4>Operands:<a class="headerlink" href="#id136" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">extents</span></code></p></td>
<td><p>variadic of any integer</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id137">
<h4>Results:<a class="headerlink" href="#id137" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>shape of a multidimensional array object</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-shape-shift-fir-shapeshiftop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.shape_shift</span></code> (::fir::ShapeShiftOp)<a class="headerlink" href="#fir-shape-shift-fir-shapeshiftop" title="Link to this heading">¶</a></h3>
<p><em>Generate an abstract shape and shift vector of type <code class="docutils literal notranslate"><span class="pre">!fir.shapeshift</span></code></em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.shape_shift` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>The arguments are an ordered list of integral type values that is a multiple
of 2 in length. Each such pair is defined as: the lower bound and the
extent for that dimension. The shifted shape information is given in the
same row-to-column order as Fortran. This abstract shifted shape value must
be applied to a reified object, so all shifted shape information must be
specified.  The extent must be nonnegative.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %d = fir.shape_shift %lo, %extent : (index, index) -&gt; !fir.shapeshift&lt;1&gt;
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id138">
<h4>Operands:<a class="headerlink" href="#id138" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">pairs</span></code></p></td>
<td><p>variadic of any integer</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id139">
<h4>Results:<a class="headerlink" href="#id139" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>shape and origin of a multidimensional array object</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-shift-fir-shiftop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.shift</span></code> (::fir::ShiftOp)<a class="headerlink" href="#fir-shift-fir-shiftop" title="Link to this heading">¶</a></h3>
<p><em>Generate an abstract shift vector of type <code class="docutils literal notranslate"><span class="pre">!fir.shift</span></code></em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.shift` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>The arguments are an ordered list of integral type values that define the
runtime lower bound of each dimension of an array. The shape information is
given in the same row-to-column order as Fortran. This abstract shift value
must be applied to a reified object, so all shift information must be
specified.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %d = fir.shift %row_lb, %col_lb : (index, index) -&gt; !fir.shift&lt;2&gt;
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id140">
<h4>Operands:<a class="headerlink" href="#id140" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">origins</span></code></p></td>
<td><p>variadic of any integer</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id141">
<h4>Results:<a class="headerlink" href="#id141" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>lower bounds of a multidimensional array object</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-slice-fir-sliceop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.slice</span></code> (::fir::SliceOp)<a class="headerlink" href="#fir-slice-fir-sliceop" title="Link to this heading">¶</a></h3>
<p><em>Generate an abstract slice vector of type <code class="docutils literal notranslate"><span class="pre">!fir.slice</span></code></em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.slice` $triples (`path` $fields^)? (`substr` $substr^)? attr-dict `:`
              functional-type(operands, results)
</pre></div>
</div>
<p>The array slicing arguments are an ordered list of integral type values
that must be a multiple of 3 in length.  Each such triple is defined as:
the lower bound, the upper bound, and the stride for that dimension, as in
Fortran syntax. Both bounds are inclusive. The array slice information is
given in the same row-to-column order as Fortran. This abstract slice value
must be applied to a reified object, so all slice information must be
specified.  The extent must be nonnegative and the stride must not be zero.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %d = fir.slice %lo, %hi, %step : (index, index, index) -&gt; !fir.slice&lt;1&gt;
</pre></div>
</div>
<p>To support generalized slicing of Fortran’s dynamic derived types, a slice
op can be given a component path (narrowing from the product type of the
original array to the specific elemental type of the sliced projection).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %fld = fir.field_index component, !fir.type&lt;t{...component:ct...}&gt;
  %d = fir.slice %lo, %hi, %step path %fld :
      (index, index, index, !fir.field) -&gt; !fir.slice&lt;1&gt;
</pre></div>
</div>
<p>Projections of <code class="docutils literal notranslate"><span class="pre">!fir.char</span></code> type can be further narrowed to invariant
substrings.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %d = fir.slice %lo, %hi, %step substr %offset, %width :
      (index, index, index, index, index) -&gt; !fir.slice&lt;1&gt;
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">AttrSizedOperandSegments</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id142">
<h4>Operands:<a class="headerlink" href="#id142" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">triples</span></code></p></td>
<td><p>variadic of any integer</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">fields</span></code></p></td>
<td><p>variadic of coordinate type</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">substr</span></code></p></td>
<td><p>variadic of any integer</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id143">
<h4>Results:<a class="headerlink" href="#id143" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>FIR slice</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-store-fir-storeop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.store</span></code> (::fir::StoreOp)<a class="headerlink" href="#fir-store-fir-storeop" title="Link to this heading">¶</a></h3>
<p><em>Store an SSA-value to a memory location</em></p>
<p>Store an ssa-value (virtual register) to a memory reference.  The stored
value must be of the same type as the referent type of the memory
reference.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %v = ... : f64
  %p = ... : !fir.ptr&lt;f64&gt;
  fir.store %v to %p : !fir.ptr&lt;f64&gt;
</pre></div>
</div>
<p>The above store changes the value to which the pointer is pointing and not
the pointer itself. The operation is undefined if the memory reference,
<code class="docutils literal notranslate"><span class="pre">%p</span></code>, is undefined or null.</p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">FirAliasTagOpInterface</span></code></p>
<section id="id144">
<h4>Attributes:<a class="headerlink" href="#id144" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr>
</table>
</section>
<section id="id145">
<h4>Operands:<a class="headerlink" href="#id145" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">value</span></code></p></td>
<td><p>any type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">memref</span></code></p></td>
<td><p>any reference</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-string-lit-fir-stringlitop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.string_lit</span></code> (::fir::StringLitOp)<a class="headerlink" href="#fir-string-lit-fir-stringlitop" title="Link to this heading">¶</a></h3>
<p><em>Create a string literal constant</em></p>
<p>An FIR constant that represents a sequence of characters that correspond
to Fortran’s CHARACTER type, including a LEN.  We support CHARACTER values
of different KINDs (different constant sizes).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %1 = fir.string_lit &quot;Hello, World!&quot;(13) : !fir.char&lt;1&gt; // ASCII
  %2 = fir.string_lit [158, 2345](2) : !fir.char&lt;2&gt;      // Wide chars
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id146">
<h4>Results:<a class="headerlink" href="#id146" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>FIR character type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-subc-fir-subcop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.subc</span></code> (::fir::SubcOp)<a class="headerlink" href="#fir-subc-fir-subcop" title="Link to this heading">¶</a></h3>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.subc` operands attr-dict `:` type($result)
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">SameOperandsAndResultType</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">ArithFastMathInterface</span></code>, <code class="docutils literal notranslate"><span class="pre">InferTypeOpInterface</span></code>, <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id147">
<h4>Attributes:<a class="headerlink" href="#id147" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td>Floating point fast math flags</td></tr>
</table>
</section>
<section id="id148">
<h4>Operands:<a class="headerlink" href="#id148" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">lhs</span></code></p></td>
<td><p>any floating point complex type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">rhs</span></code></p></td>
<td><p>any floating point complex type</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id149">
<h4>Results:<a class="headerlink" href="#id149" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">result</span></code></p></td>
<td><p>any type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-type-desc-fir-typedescop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.type_desc</span></code> (::fir::TypeDescOp)<a class="headerlink" href="#fir-type-desc-fir-typedescop" title="Link to this heading">¶</a></h3>
<p><em>Get type descriptor for a given type</em></p>
<p>Generates a constant object that is an abstract type descriptor of the
specified type.  The meta-type of a type descriptor for the type <code class="docutils literal notranslate"><span class="pre">T</span></code>
is <code class="docutils literal notranslate"><span class="pre">!fir.tdesc&lt;T&gt;</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %t = fir.type_desc !fir.type&lt;&gt; // returns value of !fir.tdesc&lt;!T&gt;
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id150">
<h4>Attributes:<a class="headerlink" href="#id150" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>in_type</code></td><td>::mlir::TypeAttr</td><td>Fortran surface type</td></tr>
</table>
</section>
<section id="id151">
<h4>Results:<a class="headerlink" href="#id151" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">res</span></code></p></td>
<td><p>FIR dialect type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-type-info-fir-typeinfoop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.type_info</span></code> (::fir::TypeInfoOp)<a class="headerlink" href="#fir-type-info-fir-typeinfoop" title="Link to this heading">¶</a></h3>
<p><em>Derived type information</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.type_info` $sym_name (`noinit` $no_init^)? (`nodestroy` $no_destroy^)?
              (`nofinal` $no_final^)? (`extends` $parent_type^)? attr-dict `:` $type
              (`dispatch_table` $dispatch_table^)?
              (`component_info` $component_info^)?
</pre></div>
</div>
<p>Define extra information about a !fir.type&lt;&gt; that represents
a Fortran derived type.</p>
<p>The optional dispatch table region defines a dispatch table with the derived
type type-bound procedures. It contains a list of associations
between method identifiers and corresponding <code class="docutils literal notranslate"><span class="pre">FuncOp</span></code> symbols.
The ordering of associations in the map is determined by the front end.</p>
<p>The “no_init” flag indicates that this type has no components requiring default
initialization (including setting allocatable component to a clean deallocated
state).</p>
<p>The “no_destroy” flag indicates that there are no allocatable components
that require deallocation.</p>
<p>The “no_final” flag indicates that there are no final methods for this type,
for its parents ,or for components.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  fir.type_info @_QMquuzTfoo noinit nofinal : !fir.type&lt;_QMquuzTfoo{i:i32}&gt; dispatch_table {
    fir.dt_entry method1, @_QFNMquuzTfooPmethod1AfooR
    fir.dt_entry method2, @_QFNMquuzTfooPmethod2AfooII
  }
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">IsolatedFromAbove</span></code>, <code class="docutils literal notranslate"><span class="pre">SingleBlockImplicitTerminator&lt;FirEndOp&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">SingleBlock</span></code></p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">Symbol</span></code></p>
<section id="id152">
<h4>Attributes:<a class="headerlink" href="#id152" title="Link to this heading">¶</a></h4>
<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr>
<tr><td><code>parent_type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr>
<tr><td><code>no_init</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr>
<tr><td><code>no_destroy</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr>
<tr><td><code>no_final</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr>
</table>
</section>
</section>
<section id="fir-unboxchar-fir-unboxcharop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.unboxchar</span></code> (::fir::UnboxCharOp)<a class="headerlink" href="#fir-unboxchar-fir-unboxcharop" title="Link to this heading">¶</a></h3>
<p><em>Unbox a boxchar value into a pair value</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.unboxchar` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Unboxes a value of <code class="docutils literal notranslate"><span class="pre">boxchar</span></code> type into a pair consisting of a memory
reference to the CHARACTER data and the LEN type parameter.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %45   = ... : !fir.boxchar&lt;1&gt;
  %46:2 = fir.unboxchar %45 : (!fir.boxchar&lt;1&gt;) -&gt; (!fir.ref&lt;!fir.char&lt;1&gt;&gt;, i32)
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id153">
<h4>Operands:<a class="headerlink" href="#id153" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">boxchar</span></code></p></td>
<td><p>CHARACTER type descriptor.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id154">
<h4>Results:<a class="headerlink" href="#id154" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>Reference to an entity type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>«unnamed»</p></td>
<td><p>any integer</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-unboxproc-fir-unboxprocop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.unboxproc</span></code> (::fir::UnboxProcOp)<a class="headerlink" href="#fir-unboxproc-fir-unboxprocop" title="Link to this heading">¶</a></h3>
<p><em>Unbox a boxproc value into a pair value</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.unboxproc` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Unboxes a value of <code class="docutils literal notranslate"><span class="pre">boxproc</span></code> type into a pair consisting of a procedure
pointer and a pointer to a host context.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %47   = ... : !fir.boxproc&lt;() -&gt; i32&gt;
  %48:2 = fir.unboxproc %47 : (!fir.ref&lt;() -&gt; i32&gt;, !fir.ref&lt;tuple&lt;f32, i32&gt;&gt;)
</pre></div>
</div>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id155">
<h4>Operands:<a class="headerlink" href="#id155" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Operand</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">boxproc</span></code></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</section>
<section id="id156">
<h4>Results:<a class="headerlink" href="#id156" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>«unnamed»</p></td>
<td><p>function type</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">refTuple</span></code></p></td>
<td><p>Reference to an entity type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-undefined-fir-undefop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.undefined</span></code> (::fir::UndefOp)<a class="headerlink" href="#fir-undefined-fir-undefop" title="Link to this heading">¶</a></h3>
<p><em>Explicit undefined value of some type</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.undefined` type($intype) attr-dict
</pre></div>
</div>
<p>Constructs an ssa-value of the specified type with an undefined value.
This operation is typically created internally by the mem2reg conversion
pass. An undefined value can be of any type except <code class="docutils literal notranslate"><span class="pre">!fir.ref&lt;T&gt;</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %a = fir.undefined !fir.array&lt;10 x !fir.type&lt;T&gt;&gt;
</pre></div>
</div>
<p>The example creates an array shaped ssa-value. The array is rank 1, extent
10, and each element has type <code class="docutils literal notranslate"><span class="pre">!fir.type&lt;T&gt;</span></code>.</p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id157">
<h4>Results:<a class="headerlink" href="#id157" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">intype</span></code></p></td>
<td><p>any type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="fir-unreachable-fir-unreachableop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.unreachable</span></code> (::fir::UnreachableOp)<a class="headerlink" href="#fir-unreachable-fir-unreachableop" title="Link to this heading">¶</a></h3>
<p><em>The unreachable instruction</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.unreachable` attr-dict
</pre></div>
</div>
<p>Terminates a basic block with the assertion that the end of the block
will never be reached at runtime.  This instruction can be used
immediately after a call to the Fortran runtime to terminate the
program, for example.  This instruction corresponds to the LLVM IR
instruction <code class="docutils literal notranslate"><span class="pre">unreachable</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">fir</span><span class="o">.</span><span class="n">unreachable</span>
</pre></div>
</div>
<p>Traits: <code class="docutils literal notranslate"><span class="pre">Terminator</span></code></p>
</section>
<section id="fir-zero-bits-fir-zeroop">
<h3><code class="docutils literal notranslate"><span class="pre">fir.zero_bits</span></code> (::fir::ZeroOp)<a class="headerlink" href="#fir-zero-bits-fir-zeroop" title="Link to this heading">¶</a></h3>
<p><em>Explicit polymorphic zero value of some type</em></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.zero_bits` type($intype) attr-dict
</pre></div>
</div>
<p>Constructs an ssa-value of the specified type with a value of zero for all
bits.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  %a = fir.zero_bits !fir.box&lt;!fir.array&lt;10 x !fir.type&lt;T&gt;&gt;&gt;
</pre></div>
</div>
<p>The example creates a value of type box where all bits are zero.</p>
<p>Interfaces: <code class="docutils literal notranslate"><span class="pre">NoMemoryEffect</span> <span class="pre">(MemoryEffectOpInterface)</span></code></p>
<p>Effects: <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Effect{}</span></code></p>
<section id="id158">
<h4>Results:<a class="headerlink" href="#id158" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Result</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><code class="docutils literal notranslate"><span class="pre">intype</span></code></p></td>
<td><p>any type</p></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="FIRArrayOperations.html">Design: FIR Array operations</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="FlangCommandLineReference.html">Flang command line argument reference</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2017-2025, The Flang Team.
      Last updated on Mar 04, 2025.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>