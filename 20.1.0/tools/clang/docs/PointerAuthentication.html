<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Pointer Authentication &#8212; Clang 20.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=e491ac2d" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=eafc0fe6" />
    <script src="_static/documentation_options.js?v=383a7952"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Matrix Types" href="MatrixTypes.html" />
    <link rel="prev" title="Objective-C Automatic Reference Counting (ARC)" href="AutomaticReferenceCounting.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Clang 20.1.0 documentation</span></a></h1>
        <h2 class="heading"><span>Pointer Authentication</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="AutomaticReferenceCounting.html">Objective-C Automatic Reference Counting (ARC)</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="MatrixTypes.html">Matrix Types</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="pointer-authentication">
<h1>Pointer Authentication<a class="headerlink" href="#pointer-authentication" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id2">Introduction</a></p></li>
<li><p><a class="reference internal" href="#basic-concepts" id="id3">Basic Concepts</a></p>
<ul>
<li><p><a class="reference internal" href="#discriminators" id="id4">Discriminators</a></p></li>
<li><p><a class="reference internal" href="#signing-schemas" id="id5">Signing Schemas</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#language-features" id="id6">Language Features</a></p>
<ul>
<li><p><a class="reference internal" href="#language-extensions" id="id7">Language Extensions</a></p>
<ul>
<li><p><a class="reference internal" href="#feature-testing" id="id8">Feature Testing</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#ptrauth-h" id="id9"><code class="docutils literal notranslate"><span class="pre">&lt;ptrauth.h&gt;</span></code></a></p>
<ul>
<li><p><a class="reference internal" href="#ptrauth-key" id="id10"><code class="docutils literal notranslate"><span class="pre">ptrauth_key</span></code></a></p></li>
<li><p><a class="reference internal" href="#ptrauth-extra-data-t" id="id11"><code class="docutils literal notranslate"><span class="pre">ptrauth_extra_data_t</span></code></a></p></li>
<li><p><a class="reference internal" href="#ptrauth-blend-discriminator" id="id12"><code class="docutils literal notranslate"><span class="pre">ptrauth_blend_discriminator</span></code></a></p></li>
<li><p><a class="reference internal" href="#ptrauth-string-discriminator" id="id13"><code class="docutils literal notranslate"><span class="pre">ptrauth_string_discriminator</span></code></a></p></li>
<li><p><a class="reference internal" href="#ptrauth-strip" id="id14"><code class="docutils literal notranslate"><span class="pre">ptrauth_strip</span></code></a></p></li>
<li><p><a class="reference internal" href="#ptrauth-sign-constant" id="id15"><code class="docutils literal notranslate"><span class="pre">ptrauth_sign_constant</span></code></a></p></li>
<li><p><a class="reference internal" href="#ptrauth-sign-unauthenticated" id="id16"><code class="docutils literal notranslate"><span class="pre">ptrauth_sign_unauthenticated</span></code></a></p></li>
<li><p><a class="reference internal" href="#ptrauth-auth-and-resign" id="id17"><code class="docutils literal notranslate"><span class="pre">ptrauth_auth_and_resign</span></code></a></p></li>
<li><p><a class="reference internal" href="#ptrauth-auth-data" id="id18"><code class="docutils literal notranslate"><span class="pre">ptrauth_auth_data</span></code></a></p></li>
<li><p><a class="reference internal" href="#ptrauth-sign-generic-data" id="id19"><code class="docutils literal notranslate"><span class="pre">ptrauth_sign_generic_data</span></code></a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#alternative-implementations" id="id20">Alternative Implementations</a></p>
<ul>
<li><p><a class="reference internal" href="#signature-storage" id="id21">Signature Storage</a></p></li>
<li><p><a class="reference internal" href="#hashing-vs-encrypting-pointers" id="id22">Hashing vs. Encrypting Pointers</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>Pointer authentication is a technology which offers strong probabilistic
protection against exploiting a broad class of memory bugs to take control of
program execution.  When adopted consistently in a language ABI, it provides
a form of relatively fine-grained control flow integrity (CFI) check that
resists both return-oriented programming (ROP) and jump-oriented programming
(JOP) attacks.</p>
<p>While pointer authentication can be implemented purely in software, direct
hardware support (e.g. as provided by Armv8.3 PAuth) can dramatically improve
performance and code size.  Similarly, while pointer authentication
can be implemented on any architecture, taking advantage of the (typically)
excess addressing range of a target with 64-bit pointers minimizes the impact
on memory performance and can allow interoperation with existing code (by
disabling pointer authentication dynamically).  This document will generally
attempt to present the pointer authentication feature independent of any
hardware implementation or ABI.  Considerations that are
implementation-specific are clearly identified throughout.</p>
<p>Note that there are several different terms in use:</p>
<ul class="simple">
<li><p><strong>Pointer authentication</strong> is a target-independent language technology.</p></li>
<li><p><strong>PAuth</strong> (sometimes referred to as <strong>PAC</strong>, for Pointer Authentication
Codes) is an AArch64 architecture extension that provides hardware support
for pointer authentication.  Additional extensions either modify some of the
PAuth instruction behavior (notably FPAC), or provide new instruction
variants (PAuth_LR).</p></li>
<li><p><strong>Armv8.3</strong> is an AArch64 architecture revision that makes PAuth mandatory.</p></li>
<li><p><strong>arm64e</strong> is a specific ABI (not yet fully stable) for implementing pointer
authentication using PAuth on certain Apple operating systems.</p></li>
</ul>
<p>This document serves four purposes:</p>
<ul class="simple">
<li><p>It describes the basic ideas of pointer authentication.</p></li>
<li><p>It documents several language extensions that are useful on targets using
pointer authentication.</p></li>
<li><p>It will eventually present a theory of operation for the security mitigation,
describing the basic requirements for correctness, various weaknesses in the
mechanism, and ways in which programmers can strengthen its protections
(including recommendations for language implementors).</p></li>
<li><p>It will eventually document the language ABIs currently used for C, C++,
Objective-C, and Swift on arm64e, although these are not yet stable on any
target.</p></li>
</ul>
</section>
<section id="basic-concepts">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">Basic Concepts</a><a class="headerlink" href="#basic-concepts" title="Link to this heading">¶</a></h2>
<p>The simple address of an object or function is a <strong>raw pointer</strong>.  A raw
pointer can be <strong>signed</strong> to produce a <strong>signed pointer</strong>.  A signed pointer
can be then <strong>authenticated</strong> in order to verify that it was <strong>validly signed</strong>
and extract the original raw pointer.  These terms reflect the most likely
implementation technique: computing and storing a cryptographic signature along
with the pointer.</p>
<p>An <strong>abstract signing key</strong> is a name which refers to a secret key which is
used to sign and authenticate pointers.  The concrete key value for a
particular name is consistent throughout a process.</p>
<p>A <strong>discriminator</strong> is an arbitrary value used to <strong>diversify</strong> signed pointers
so that one validly-signed pointer cannot simply be copied over another.
A discriminator is simply opaque data of some implementation-defined size that
is included in the signature as a salt (see <a class="reference internal" href="#discriminators">Discriminators</a> for details.)</p>
<p>Nearly all aspects of pointer authentication use just these two primary
operations:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sign(raw_pointer,</span> <span class="pre">key,</span> <span class="pre">discriminator)</span></code> produces a signed pointer given
a raw pointer, an abstract signing key, and a discriminator.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">auth(signed_pointer,</span> <span class="pre">key,</span> <span class="pre">discriminator)</span></code> produces a raw pointer given
a signed pointer, an abstract signing key, and a discriminator.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">auth(sign(raw_pointer,</span> <span class="pre">key,</span> <span class="pre">discriminator),</span> <span class="pre">key,</span> <span class="pre">discriminator)</span></code> must
succeed and produce <code class="docutils literal notranslate"><span class="pre">raw_pointer</span></code>.  <code class="docutils literal notranslate"><span class="pre">auth</span></code> applied to a value that was
ultimately produced in any other way is expected to fail, which halts the
program either:</p>
<ul class="simple">
<li><p>immediately, on implementations that enforce <code class="docutils literal notranslate"><span class="pre">auth</span></code> success (e.g., when
using compiler-generated <code class="docutils literal notranslate"><span class="pre">auth</span></code> failure checks, or Armv8.3 with the FPAC
extension), or</p></li>
<li><p>when the resulting pointer value is used, on implementations that don’t.</p></li>
</ul>
<p>However, regardless of the implementation’s handling of <code class="docutils literal notranslate"><span class="pre">auth</span></code> failures, it
is permitted for <code class="docutils literal notranslate"><span class="pre">auth</span></code> to fail to detect that a signed pointer was not
produced in this way, in which case it may return anything; this is what makes
pointer authentication a probabilistic mitigation rather than a perfect one.</p>
<p>There are two secondary operations which are required only to implement certain
intrinsics in <code class="docutils literal notranslate"><span class="pre">&lt;ptrauth.h&gt;</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">strip(signed_pointer,</span> <span class="pre">key)</span></code> produces a raw pointer given a signed pointer
and a key without verifying its validity, unlike <code class="docutils literal notranslate"><span class="pre">auth</span></code>.  This is useful
for certain kinds of tooling, such as crash backtraces; it should generally
not be used in the basic language ABI except in very careful ways.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sign_generic(value)</span></code> produces a cryptographic signature for arbitrary
data, not necessarily a pointer.  This is useful for efficiently verifying
that non-pointer data has not been tampered with.</p></li>
</ul>
<p>Whenever any of these operations is called for, the key value must be known
statically.  This is because the layout of a signed pointer may vary according
to the signing key.  (For example, in Armv8.3, the layout of a signed pointer
depends on whether Top Byte Ignore (TBI) is enabled, which can be set
independently for I and D keys.)</p>
<div class="admonition-note-for-api-designers-and-language-implementors admonition">
<p class="admonition-title">Note for API designers and language implementors</p>
<p>These are the <em>primitive</em> operations of pointer authentication, provided for
clarity of description.  They are not suitable either as high-level
interfaces or as primitives in a compiler IR because they expose raw
pointers.  Raw pointers require special attention in the language
implementation to avoid the accidental creation of exploitable code
sequences.</p>
</div>
<p>The following details are all implementation-defined:</p>
<ul class="simple">
<li><p>the nature of a signed pointer</p></li>
<li><p>the size of a discriminator</p></li>
<li><p>the number and nature of the signing keys</p></li>
<li><p>the implementation of the <code class="docutils literal notranslate"><span class="pre">sign</span></code>, <code class="docutils literal notranslate"><span class="pre">auth</span></code>, <code class="docutils literal notranslate"><span class="pre">strip</span></code>, and <code class="docutils literal notranslate"><span class="pre">sign_generic</span></code>
operations</p></li>
</ul>
<p>While the use of the terms “sign” and “signed pointer” suggest the use of
a cryptographic signature, other implementations may be possible.  See
<a class="reference internal" href="#alternative-implementations">Alternative implementations</a> for an exploration of implementation options.</p>
<div class="admonition-implementation-example-armv8-3 admonition">
<p class="admonition-title">Implementation example: Armv8.3</p>
<p>Readers may find it helpful to know how these terms map to Armv8.3 PAuth:</p>
<ul class="simple">
<li><p>A signed pointer is a pointer with a signature stored in the
otherwise-unused high bits.  The kernel configures the address width based
on the system’s addressing needs, and enables TBI for I or D keys as
needed.  The bits above the address bits and below the TBI bits (if
enabled) are unused.  The signature width then depends on this addressing
configuration.</p></li>
<li><p>A discriminator is a 64-bit integer.  Constant discriminators are 16-bit
integers.  Blending a constant discriminator into an address consists of
replacing the top 16 bits of the pointer containing the address with the
constant.  Pointers used for blending purposes should only have address
bits, since higher bits will be at least partially overwritten with the
constant discriminator.</p></li>
<li><p>There are five 128-bit signing-key registers, each of which can only be
directly read or set by privileged code.  Of these, four are used for
signing pointers, and the fifth is used only for <code class="docutils literal notranslate"><span class="pre">sign_generic</span></code>.  The key
data is simply a pepper added to the hash, not an encryption key, and so
can be initialized using random data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sign</span></code> computes a cryptographic hash of the pointer, discriminator, and
signing key, and stores it in the high bits as the signature. <code class="docutils literal notranslate"><span class="pre">auth</span></code>
removes the signature, computes the same hash, and compares the result with
the stored signature.  <code class="docutils literal notranslate"><span class="pre">strip</span></code> removes the signature without
authenticating it.  While <code class="docutils literal notranslate"><span class="pre">aut*</span></code> instructions do not themselves trap on
failure in Armv8.3 PAuth, they do with the later optional FPAC extension.
An implementation can also choose to emulate this trapping behavior by
emitting additional instructions around <code class="docutils literal notranslate"><span class="pre">aut*</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sign_generic</span></code> corresponds to the <code class="docutils literal notranslate"><span class="pre">pacga</span></code> instruction, which takes two
64-bit values and produces a 64-bit cryptographic hash. Implementations of
this instruction are not required to produce meaningful data in all bits of
the result.</p></li>
</ul>
</div>
<section id="discriminators">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">Discriminators</a><a class="headerlink" href="#discriminators" title="Link to this heading">¶</a></h3>
<p>A discriminator is arbitrary extra data which alters the signature calculated
for a pointer.  When two pointers are signed differently — either with
different keys or with different discriminators — an attacker cannot simply
replace one pointer with the other.</p>
<p>To use standard cryptographic terminology, a discriminator acts as a
<a class="reference external" href="https://en.wikipedia.org/wiki/Salt_(cryptography)">salt</a> in the signing of a
pointer, and the key data acts as a
<a class="reference external" href="https://en.wikipedia.org/wiki/Pepper_(cryptography)">pepper</a>.  That is,
both the discriminator and key data are ultimately just added as inputs to the
signing algorithm along with the pointer, but they serve significantly
different roles.  The key data is a common secret added to every signature,
whereas the discriminator is a value that can be derived from
the context in which a specific pointer is signed.  However, unlike a password
salt, it’s important that discriminators be <em>independently</em> derived from the
circumstances of the signing; they should never simply be stored alongside
a pointer.  Discriminators are then re-derived in authentication operations.</p>
<p>The intrinsic interface in <code class="docutils literal notranslate"><span class="pre">&lt;ptrauth.h&gt;</span></code> allows an arbitrary discriminator
value to be provided, but can only be used when running normal code.  The
discriminators used by language ABIs must be restricted to make it feasible for
the loader to sign pointers stored in global memory without needing excessive
amounts of metadata.  Under these restrictions, a discriminator may consist of
either or both of the following:</p>
<ul class="simple">
<li><p>The address at which the pointer is stored in memory.  A pointer signed with
a discriminator which incorporates its storage address is said to have
<strong>address diversity</strong>.  In general, using address diversity means that
a pointer cannot be reliably copied by an attacker to or from a different
memory location.  However, an attacker may still be able to attack a larger
call sequence if they can alter the address through which the pointer is
accessed.  Furthermore, some situations cannot use address diversity because
of language or other restrictions.</p></li>
<li><p>A constant integer, called a <strong>constant discriminator</strong>. A pointer signed
with a non-zero constant discriminator is said to have <strong>constant
diversity</strong>.  If the discriminator is specific to a single declaration, it is
said to have <strong>declaration diversity</strong>; if the discriminator is specific to
a type of value, it is said to have <strong>type diversity</strong>.  For example, C++
v-tables on arm64e sign their component functions using a hash of their
method names and signatures, which provides declaration diversity; similarly,
C++ member function pointers sign their invocation functions using a hash of
the member pointer type, which provides type diversity.</p></li>
</ul>
<p>The implementation may need to restrict constant discriminators to be
significantly smaller than the full size of a discriminator.  For example, on
arm64e, constant discriminators are only 16-bit values.  This is believed to
not significantly weaken the mitigation, since collisions remain uncommon.</p>
<p>The algorithm for blending a constant discriminator with a storage address is
implementation-defined.</p>
</section>
<section id="signing-schemas">
<span id="id1"></span><h3><a class="toc-backref" href="#id5" role="doc-backlink">Signing Schemas</a><a class="headerlink" href="#signing-schemas" title="Link to this heading">¶</a></h3>
<p>Correct use of pointer authentication requires the signing code and the
authenticating code to agree about the <strong>signing schema</strong> for the pointer:</p>
<ul class="simple">
<li><p>the abstract signing key with which the pointer should be signed and</p></li>
<li><p>an algorithm for computing the discriminator.</p></li>
</ul>
<p>As described in the section above on <a class="reference internal" href="#discriminators">Discriminators</a>, in most situations, the
discriminator is produced by taking a constant discriminator and optionally
blending it with the storage address of the pointer.  In these situations, the
signing schema breaks down even more simply:</p>
<ul class="simple">
<li><p>the abstract signing key,</p></li>
<li><p>a constant discriminator, and</p></li>
<li><p>whether to use address diversity.</p></li>
</ul>
<p>It is important that the signing schema be independently derived at all signing
and authentication sites.  Preferably, the schema should be hard-coded
everywhere it is needed, but at the very least, it must not be derived by
inspecting information stored along with the pointer.</p>
</section>
</section>
<section id="language-features">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">Language Features</a><a class="headerlink" href="#language-features" title="Link to this heading">¶</a></h2>
<p>There is currently one main pointer authentication language feature:</p>
<ul class="simple">
<li><p>The language provides the <code class="docutils literal notranslate"><span class="pre">&lt;ptrauth.h&gt;</span></code> intrinsic interface for manually
signing and authenticating pointers in code.  These can be used in
circumstances where very specific behavior is required.</p></li>
</ul>
<section id="language-extensions">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Language Extensions</a><a class="headerlink" href="#language-extensions" title="Link to this heading">¶</a></h3>
<section id="feature-testing">
<h4><a class="toc-backref" href="#id8" role="doc-backlink">Feature Testing</a><a class="headerlink" href="#feature-testing" title="Link to this heading">¶</a></h4>
<p>Whether the current target uses pointer authentication can be tested for with
a number of different tests.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__has_feature(ptrauth_intrinsics)</span></code> is true if <code class="docutils literal notranslate"><span class="pre">&lt;ptrauth.h&gt;</span></code> provides its
normal interface.  This may be true even on targets where pointer
authentication is not enabled by default.</p></li>
</ul>
</section>
</section>
<section id="ptrauth-h">
<h3><a class="toc-backref" href="#id9" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">&lt;ptrauth.h&gt;</span></code></a><a class="headerlink" href="#ptrauth-h" title="Link to this heading">¶</a></h3>
<p>This header defines the following types and operations:</p>
<section id="ptrauth-key">
<h4><a class="toc-backref" href="#id10" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">ptrauth_key</span></code></a><a class="headerlink" href="#ptrauth-key" title="Link to this heading">¶</a></h4>
<p>This <code class="docutils literal notranslate"><span class="pre">enum</span></code> is the type of abstract signing keys.  In addition to defining
the set of implementation-specific signing keys (for example, Armv8.3 defines
<code class="docutils literal notranslate"><span class="pre">ptrauth_key_asia</span></code>), it also defines some portable aliases for those keys.
For example, <code class="docutils literal notranslate"><span class="pre">ptrauth_key_function_pointer</span></code> is the key generally used for
C function pointers, which will generally be suitable for other
function-signing schemas.</p>
<p>In all the operation descriptions below, key values must be constant values
corresponding to one of the implementation-specific abstract signing keys from
this <code class="docutils literal notranslate"><span class="pre">enum</span></code>.</p>
</section>
<section id="ptrauth-extra-data-t">
<h4><a class="toc-backref" href="#id11" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">ptrauth_extra_data_t</span></code></a><a class="headerlink" href="#ptrauth-extra-data-t" title="Link to this heading">¶</a></h4>
<p>This is a <code class="docutils literal notranslate"><span class="pre">typedef</span></code> of a standard integer type of the correct size to hold
a discriminator value.</p>
<p>In the signing and authentication operation descriptions below, discriminator
values must have either pointer type or integer type. If the discriminator is
an integer, it will be coerced to <code class="docutils literal notranslate"><span class="pre">ptrauth_extra_data_t</span></code>.</p>
</section>
<section id="ptrauth-blend-discriminator">
<h4><a class="toc-backref" href="#id12" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">ptrauth_blend_discriminator</span></code></a><a class="headerlink" href="#ptrauth-blend-discriminator" title="Link to this heading">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ptrauth_blend_discriminator</span><span class="p">(</span><span class="n">pointer</span><span class="p">,</span><span class="w"> </span><span class="n">integer</span><span class="p">)</span>
</pre></div>
</div>
<p>Produce a discriminator value which blends information from the given pointer
and the given integer.</p>
<p>Implementations may ignore some bits from each value, which is to say, the
blending algorithm may be chosen for speed and convenience over theoretical
strength as a hash-combining algorithm.  For example, arm64e simply overwrites
the high 16 bits of the pointer with the low 16 bits of the integer, which can
be done in a single instruction with an immediate integer.</p>
<p><code class="docutils literal notranslate"><span class="pre">pointer</span></code> must have pointer type, and <code class="docutils literal notranslate"><span class="pre">integer</span></code> must have integer type. The
result has type <code class="docutils literal notranslate"><span class="pre">ptrauth_extra_data_t</span></code>.</p>
</section>
<section id="ptrauth-string-discriminator">
<h4><a class="toc-backref" href="#id13" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">ptrauth_string_discriminator</span></code></a><a class="headerlink" href="#ptrauth-string-discriminator" title="Link to this heading">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ptrauth_string_discriminator</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute a constant discriminator from the given string.</p>
<p><code class="docutils literal notranslate"><span class="pre">string</span></code> must be a string literal of <code class="docutils literal notranslate"><span class="pre">char</span></code> character type.  The result has
type <code class="docutils literal notranslate"><span class="pre">ptrauth_extra_data_t</span></code>.</p>
<p>The result value is never zero and always within range for both the
<code class="docutils literal notranslate"><span class="pre">__ptrauth</span></code> qualifier and <code class="docutils literal notranslate"><span class="pre">ptrauth_blend_discriminator</span></code>.</p>
<p>This can be used in constant expressions.</p>
</section>
<section id="ptrauth-strip">
<h4><a class="toc-backref" href="#id14" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">ptrauth_strip</span></code></a><a class="headerlink" href="#ptrauth-strip" title="Link to this heading">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ptrauth_strip</span><span class="p">(</span><span class="n">signedPointer</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">)</span>
</pre></div>
</div>
<p>Given that <code class="docutils literal notranslate"><span class="pre">signedPointer</span></code> matches the layout for signed pointers signed with
the given key, extract the raw pointer from it.  This operation does not trap
and cannot fail, even if the pointer is not validly signed.</p>
</section>
<section id="ptrauth-sign-constant">
<h4><a class="toc-backref" href="#id15" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">ptrauth_sign_constant</span></code></a><a class="headerlink" href="#ptrauth-sign-constant" title="Link to this heading">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ptrauth_sign_constant</span><span class="p">(</span><span class="n">pointer</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">discriminator</span><span class="p">)</span>
</pre></div>
</div>
<p>Return a signed pointer for a constant address in a manner which guarantees
a non-attackable sequence.</p>
<p><code class="docutils literal notranslate"><span class="pre">pointer</span></code> must be a constant expression of pointer type which evaluates to
a non-null pointer.
<code class="docutils literal notranslate"><span class="pre">key</span></code>  must be a constant expression of type <code class="docutils literal notranslate"><span class="pre">ptrauth_key</span></code>.
<code class="docutils literal notranslate"><span class="pre">discriminator</span></code> must be a constant expression of pointer or integer type;
if an integer, it will be coerced to <code class="docutils literal notranslate"><span class="pre">ptrauth_extra_data_t</span></code>.
The result will have the same type as <code class="docutils literal notranslate"><span class="pre">pointer</span></code>.</p>
<p>This can be used in constant expressions.</p>
</section>
<section id="ptrauth-sign-unauthenticated">
<h4><a class="toc-backref" href="#id16" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">ptrauth_sign_unauthenticated</span></code></a><a class="headerlink" href="#ptrauth-sign-unauthenticated" title="Link to this heading">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ptrauth_sign_unauthenticated</span><span class="p">(</span><span class="n">pointer</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">discriminator</span><span class="p">)</span>
</pre></div>
</div>
<p>Produce a signed pointer for the given raw pointer without applying any
authentication or extra treatment.  This operation is not required to have the
same behavior on a null pointer that the language implementation would.</p>
<p>This is a treacherous operation that can easily result in signing oracles.
Programs should use it seldom and carefully.</p>
</section>
<section id="ptrauth-auth-and-resign">
<h4><a class="toc-backref" href="#id17" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">ptrauth_auth_and_resign</span></code></a><a class="headerlink" href="#ptrauth-auth-and-resign" title="Link to this heading">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ptrauth_auth_and_resign</span><span class="p">(</span><span class="n">pointer</span><span class="p">,</span><span class="w"> </span><span class="n">oldKey</span><span class="p">,</span><span class="w"> </span><span class="n">oldDiscriminator</span><span class="p">,</span><span class="w"> </span><span class="n">newKey</span><span class="p">,</span><span class="w"> </span><span class="n">newDiscriminator</span><span class="p">)</span>
</pre></div>
</div>
<p>Authenticate that <code class="docutils literal notranslate"><span class="pre">pointer</span></code> is signed with <code class="docutils literal notranslate"><span class="pre">oldKey</span></code> and
<code class="docutils literal notranslate"><span class="pre">oldDiscriminator</span></code> and then resign the raw-pointer result of that
authentication with <code class="docutils literal notranslate"><span class="pre">newKey</span></code> and <code class="docutils literal notranslate"><span class="pre">newDiscriminator</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">pointer</span></code> must have pointer type.  The result will have the same type as
<code class="docutils literal notranslate"><span class="pre">pointer</span></code>.  This operation is not required to have the same behavior on
a null pointer that the language implementation would.</p>
<p>The code sequence produced for this operation must not be directly attackable.
However, if the discriminator values are not constant integers, their
computations may still be attackable.  In the future, Clang should be enhanced
to guaranteed non-attackability if these expressions are safely-derived.</p>
</section>
<section id="ptrauth-auth-data">
<h4><a class="toc-backref" href="#id18" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">ptrauth_auth_data</span></code></a><a class="headerlink" href="#ptrauth-auth-data" title="Link to this heading">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ptrauth_auth_data</span><span class="p">(</span><span class="n">pointer</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">discriminator</span><span class="p">)</span>
</pre></div>
</div>
<p>Authenticate that <code class="docutils literal notranslate"><span class="pre">pointer</span></code> is signed with <code class="docutils literal notranslate"><span class="pre">key</span></code> and <code class="docutils literal notranslate"><span class="pre">discriminator</span></code> and
remove the signature.</p>
<p><code class="docutils literal notranslate"><span class="pre">pointer</span></code> must have object pointer type.  The result will have the same type
as <code class="docutils literal notranslate"><span class="pre">pointer</span></code>.  This operation is not required to have the same behavior on
a null pointer that the language implementation would.</p>
<p>In the future when Clang makes safe derivation guarantees, the result of
this operation should be considered safely-derived.</p>
</section>
<section id="ptrauth-sign-generic-data">
<h4><a class="toc-backref" href="#id19" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">ptrauth_sign_generic_data</span></code></a><a class="headerlink" href="#ptrauth-sign-generic-data" title="Link to this heading">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ptrauth_sign_generic_data</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span><span class="w"> </span><span class="n">value2</span><span class="p">)</span>
</pre></div>
</div>
<p>Computes a signature for the given pair of values, incorporating a secret
signing key.</p>
<p>This operation can be used to verify that arbitrary data has not been tampered
with by computing a signature for the data, storing that signature, and then
repeating this process and verifying that it yields the same result.  This can
be reasonably done in any number of ways; for example, a library could compute
an ordinary checksum of the data and just sign the result in order to get the
tamper-resistance advantages of the secret signing key (since otherwise an
attacker could reliably overwrite both the data and the checksum).</p>
<p><code class="docutils literal notranslate"><span class="pre">value1</span></code> and <code class="docutils literal notranslate"><span class="pre">value2</span></code> must be either pointers or integers.  If the integers
are larger than <code class="docutils literal notranslate"><span class="pre">uintptr_t</span></code> then data not representable in <code class="docutils literal notranslate"><span class="pre">uintptr_t</span></code> may
be discarded.</p>
<p>The result will have type <code class="docutils literal notranslate"><span class="pre">ptrauth_generic_signature_t</span></code>, which is an integer
type.  Implementations are not required to make all bits of the result equally
significant; in particular, some implementations are known to not leave
meaningful data in the low bits.</p>
</section>
</section>
</section>
<section id="alternative-implementations">
<h2><a class="toc-backref" href="#id20" role="doc-backlink">Alternative Implementations</a><a class="headerlink" href="#alternative-implementations" title="Link to this heading">¶</a></h2>
<section id="signature-storage">
<h3><a class="toc-backref" href="#id21" role="doc-backlink">Signature Storage</a><a class="headerlink" href="#signature-storage" title="Link to this heading">¶</a></h3>
<p>It is not critical for the security of pointer authentication that the
signature be stored “together” with the pointer, as it is in Armv8.3. An
implementation could just as well store the signature in a separate word, so
that the <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> a signed pointer would be larger than the <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> a raw
pointer.</p>
<p>Storing the signature in the high bits, as Armv8.3 does, has several trade-offs:</p>
<ul class="simple">
<li><p>Disadvantage: there are substantially fewer bits available for the signature,
weakening the mitigation by making it much easier for an attacker to simply
guess the correct signature.</p></li>
<li><p>Disadvantage: future growth of the address space will necessarily further
weaken the mitigation.</p></li>
<li><p>Advantage: memory layouts don’t change, so it’s possible for
pointer-authentication-enabled code (for example, in a system library) to
efficiently interoperate with existing code, as long as pointer
authentication can be disabled dynamically.</p></li>
<li><p>Advantage: the size of a signed pointer doesn’t grow, which might
significantly increase memory requirements, code size, and register pressure.</p></li>
<li><p>Advantage: the size of a signed pointer is the same as a raw pointer, so
generic APIs which work in types like <cite>void *</cite> (such as <cite>dlsym</cite>) can still
return signed pointers.  This means that clients of these APIs will not
require insecure code in order to correctly receive a function pointer.</p></li>
</ul>
</section>
<section id="hashing-vs-encrypting-pointers">
<h3><a class="toc-backref" href="#id22" role="doc-backlink">Hashing vs. Encrypting Pointers</a><a class="headerlink" href="#hashing-vs-encrypting-pointers" title="Link to this heading">¶</a></h3>
<p>Armv8.3 implements <code class="docutils literal notranslate"><span class="pre">sign</span></code> by computing a cryptographic hash and storing that
in the spare bits of the pointer.  This means that there are relatively few
possible values for the valid signed pointer, since the bits corresponding to
the raw pointer are known.  Together with an <code class="docutils literal notranslate"><span class="pre">auth</span></code> oracle, this can make it
computationally feasible to discover the correct signature with brute force.
(The implementation should of course endeavor not to introduce <code class="docutils literal notranslate"><span class="pre">auth</span></code>
oracles, but this can be difficult, and attackers can be devious.)</p>
<p>If the implementation can instead <em>encrypt</em> the pointer during <code class="docutils literal notranslate"><span class="pre">sign</span></code> and
<em>decrypt</em> it during <code class="docutils literal notranslate"><span class="pre">auth</span></code>, this brute-force attack becomes far less
feasible, even with an <code class="docutils literal notranslate"><span class="pre">auth</span></code> oracle.  However, there are several problems
with this idea:</p>
<ul class="simple">
<li><p>It’s unclear whether this kind of encryption is even possible without
increasing the storage size of a signed pointer.  If the storage size can be
increased, brute-force atacks can be equally well mitigated by simply storing
a larger signature.</p></li>
<li><p>It would likely be impossible to implement a <code class="docutils literal notranslate"><span class="pre">strip</span></code> operation, which might
make debuggers and other out-of-process tools far more difficult to write, as
well as generally making primitive debugging more challenging.</p></li>
<li><p>Implementations can benefit from being able to extract the raw pointer
immediately from a signed pointer.  An Armv8.3 processor executing an
<code class="docutils literal notranslate"><span class="pre">auth</span></code>-and-load instruction can perform the load and <code class="docutils literal notranslate"><span class="pre">auth</span></code> in parallel;
a processor which instead encrypted the pointer would be forced to perform
these operations serially.</p></li>
</ul>
</section>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="AutomaticReferenceCounting.html">Objective-C Automatic Reference Counting (ARC)</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="MatrixTypes.html">Matrix Types</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2007-2025, The Clang Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>