
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Source Level Debugging with LLVM &#8212; LLVM 20.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/llvm-theme.css?v=96924833" />
    <script src="_static/documentation_options.js?v=383a7952"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Debug Info Assignment Tracking" href="AssignmentTracking.html" />
    <link rel="prev" title="RISC-V Vector Extension" href="RISCV/RISCVVectorExtension.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="AssignmentTracking.html" title="Debug Info Assignment Tracking"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="RISCV/RISCVVectorExtension.html" title="RISC-V Vector Extension"
             accesskey="P">previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" accesskey="U">User Guides</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Source Level Debugging with LLVM</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="https://llvm.org/docs/UserGuides.html">User Guides</a></li>
    <li><a href="https://llvm.org/docs/Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/Contributing.html">Contributing to LLVM</a></li>
    <li><a href="https://llvm.org/docs/HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#discord">Discord</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/FAQ.html">FAQ</a></li>
    <li><a href="https://llvm.org/docs/Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project/">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/SourceLevelDebugging.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="source-level-debugging-with-llvm">
<h1>Source Level Debugging with LLVM<a class="headerlink" href="#source-level-debugging-with-llvm" title="Link to this heading">Â¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id11">Introduction</a></p>
<ul>
<li><p><a class="reference internal" href="#philosophy-behind-llvm-debugging-information" id="id12">Philosophy behind LLVM debugging information</a></p></li>
<li><p><a class="reference internal" href="#debug-information-consumers" id="id13">Debug information consumers</a></p></li>
<li><p><a class="reference internal" href="#debug-information-and-optimizations" id="id14">Debug information and optimizations</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#debugging-information-format" id="id15">Debugging information format</a></p>
<ul>
<li><p><a class="reference internal" href="#debug-records" id="id16">Debug Records</a></p>
<ul>
<li><p><a class="reference internal" href="#dbg-declare" id="id17"><code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code></a></p></li>
<li><p><a class="reference internal" href="#dbg-value" id="id18"><code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code></a></p></li>
<li><p><a class="reference internal" href="#dbg-assign" id="id19"><code class="docutils literal notranslate"><span class="pre">#dbg_assign</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#debugger-intrinsic-functions" id="id20">Debugger intrinsic functions</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-dbg-declare" id="id21"><code class="docutils literal notranslate"><span class="pre">llvm.dbg.declare</span></code></a></p></li>
<li><p><a class="reference internal" href="#llvm-dbg-value" id="id22"><code class="docutils literal notranslate"><span class="pre">llvm.dbg.value</span></code></a></p></li>
<li><p><a class="reference internal" href="#llvm-dbg-assign" id="id23"><code class="docutils literal notranslate"><span class="pre">llvm.dbg.assign</span></code></a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#object-lifetimes-and-scoping" id="id24">Object lifetimes and scoping</a></p></li>
<li><p><a class="reference internal" href="#object-lifetime-in-optimized-code" id="id25">Object lifetime in optimized code</a></p></li>
<li><p><a class="reference internal" href="#how-variable-location-metadata-is-transformed-during-codegen" id="id26">How variable location metadata is transformed during CodeGen</a></p>
<ul>
<li><p><a class="reference internal" href="#variable-locations-in-instruction-selection-and-mir" id="id27">Variable locations in Instruction Selection and MIR</a></p></li>
<li><p><a class="reference internal" href="#instruction-scheduling" id="id28">Instruction Scheduling</a></p></li>
<li><p><a class="reference internal" href="#variable-locations-during-register-allocation" id="id29">Variable locations during Register Allocation</a></p></li>
<li><p><a class="reference internal" href="#livedebugvalues-expansion-of-variable-locations" id="id30">LiveDebugValues expansion of variable locations</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#c-c-front-end-specific-debug-information" id="id31">C/C++ front-end specific debug information</a></p>
<ul>
<li><p><a class="reference internal" href="#c-c-source-file-information" id="id32">C/C++ source file information</a></p></li>
<li><p><a class="reference internal" href="#c-c-global-variable-information" id="id33">C/C++ global variable information</a></p></li>
<li><p><a class="reference internal" href="#c-c-function-information" id="id34">C/C++ function information</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#c-specific-debug-information" id="id35">C++ specific debug information</a></p>
<ul>
<li><p><a class="reference internal" href="#c-special-member-functions-information" id="id36">C++ special member functions information</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#fortran-specific-debug-information" id="id37">Fortran specific debug information</a></p>
<ul>
<li><p><a class="reference internal" href="#fortran-function-information" id="id38">Fortran function information</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id7" id="id39">Debugging information format</a></p>
<ul>
<li><p><a class="reference internal" href="#debugging-information-extension-for-objective-c-properties" id="id40">Debugging Information Extension for Objective C Properties</a></p>
<ul>
<li><p><a class="reference internal" href="#id8" id="id41">Introduction</a></p></li>
<li><p><a class="reference internal" href="#proposal" id="id42">Proposal</a></p></li>
<li><p><a class="reference internal" href="#new-dwarf-tags" id="id43">New DWARF Tags</a></p></li>
<li><p><a class="reference internal" href="#new-dwarf-attributes" id="id44">New DWARF Attributes</a></p></li>
<li><p><a class="reference internal" href="#new-dwarf-constants" id="id45">New DWARF Constants</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#name-accelerator-tables" id="id46">Name Accelerator Tables</a></p>
<ul>
<li><p><a class="reference internal" href="#id9" id="id47">Introduction</a></p></li>
<li><p><a class="reference internal" href="#hash-tables" id="id48">Hash Tables</a></p>
<ul>
<li><p><a class="reference internal" href="#standard-hash-tables" id="id49">Standard Hash Tables</a></p></li>
<li><p><a class="reference internal" href="#name-hash-tables" id="id50">Name Hash Tables</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#details" id="id51">Details</a></p>
<ul>
<li><p><a class="reference internal" href="#header-layout" id="id52">Header Layout</a></p></li>
<li><p><a class="reference internal" href="#fixed-lookup" id="id53">Fixed Lookup</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id10" id="id54">Contents</a></p></li>
<li><p><a class="reference internal" href="#language-extensions-and-file-format-changes" id="id55">Language Extensions and File Format Changes</a></p>
<ul>
<li><p><a class="reference internal" href="#objective-c-extensions" id="id56">Objective-C Extensions</a></p></li>
<li><p><a class="reference internal" href="#mach-o-changes" id="id57">Mach-O Changes</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#codeview-debug-info-format" id="id58">CodeView Debug Info Format</a></p>
<ul>
<li><p><a class="reference internal" href="#format-background" id="id59">Format Background</a></p></li>
<li><p><a class="reference internal" href="#working-with-codeview" id="id60">Working with CodeView</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">Â¶</a></h2>
<p>This document is the central repository for all information pertaining to debug
information in LLVM.  It describes the <a class="reference internal" href="#format"><span class="std std-ref">actual format that the LLVM debug
information takes</span></a>, which is useful for those interested in creating
front-ends or dealing directly with the information.  Further, this document
provides specific examples of what debug information for C/C++ looks like.</p>
<section id="philosophy-behind-llvm-debugging-information">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Philosophy behind LLVM debugging information</a><a class="headerlink" href="#philosophy-behind-llvm-debugging-information" title="Link to this heading">Â¶</a></h3>
<p>The idea of the LLVM debugging information is to capture how the important
pieces of the source-languageâs Abstract Syntax Tree map onto LLVM code.
Several design aspects have shaped the solution that appears here.  The
important ones are:</p>
<ul class="simple">
<li><p>Debugging information should have very little impact on the rest of the
compiler.  No transformations, analyses, or code generators should need to
be modified because of debugging information.</p></li>
<li><p>LLVM optimizations should interact in <a class="reference internal" href="#intro-debugopt"><span class="std std-ref">well-defined and easily described
ways</span></a> with the debugging information.</p></li>
<li><p>Because LLVM is designed to support arbitrary programming languages,
LLVM-to-LLVM tools should not need to know anything about the semantics of
the source-level-language.</p></li>
<li><p>Source-level languages are often <strong>widely</strong> different from one another.
LLVM should not put any restrictions of the flavor of the source-language,
and the debugging information should work with any language.</p></li>
<li><p>With code generator support, it should be possible to use an LLVM compiler
to compile a program to native machine code and standard debugging
formats.  This allows compatibility with traditional machine-code level
debuggers, like GDB or DBX.</p></li>
</ul>
<p>The approach used by the LLVM implementation is to use a small set of
<a class="reference internal" href="#debug-records"><span class="std std-ref">debug records</span></a> to define a mapping
between LLVM program objects and the source-level objects.  The description of
the source-level program is maintained in LLVM metadata in an
<a class="reference internal" href="#ccxx-frontend"><span class="std std-ref">implementation-defined format</span></a> (the C/C++ front-end
currently uses working draft 7 of the <a class="reference external" href="http://www.eagercon.com/dwarf/dwarf3std.htm">DWARF 3 standard</a>).</p>
<p>When a program is being debugged, a debugger interacts with the user and turns
the stored debug information into source-language specific information.  As
such, a debugger must be aware of the source-language, and is thus tied to a
specific language or family of languages.</p>
</section>
<section id="debug-information-consumers">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Debug information consumers</a><a class="headerlink" href="#debug-information-consumers" title="Link to this heading">Â¶</a></h3>
<p>The role of debug information is to provide meta information normally stripped
away during the compilation process.  This meta information provides an LLVM
user a relationship between generated code and the original program source
code.</p>
<p>Currently, there are two backend consumers of debug info: DwarfDebug and
CodeViewDebug. DwarfDebug produces DWARF suitable for use with GDB, LLDB, and
other DWARF-based debuggers. <a class="reference internal" href="#codeview"><span class="std std-ref">CodeViewDebug</span></a> produces CodeView,
the Microsoft debug info format, which is usable with Microsoft debuggers such
as Visual Studio and WinDBG. LLVMâs debug information format is mostly derived
from and inspired by DWARF, but it is feasible to translate into other target
debug info formats such as STABS.</p>
<p>It would also be reasonable to use debug information to feed profiling tools
for analysis of generated code, or, tools for reconstructing the original
source from generated code.</p>
</section>
<section id="debug-information-and-optimizations">
<span id="intro-debugopt"></span><h3><a class="toc-backref" href="#id14" role="doc-backlink">Debug information and optimizations</a><a class="headerlink" href="#debug-information-and-optimizations" title="Link to this heading">Â¶</a></h3>
<p>An extremely high priority of LLVM debugging information is to make it interact
well with optimizations and analysis.  In particular, the LLVM debug
information provides the following guarantees:</p>
<ul class="simple">
<li><p>LLVM debug information <strong>always provides information to accurately read
the source-level state of the program</strong>, regardless of which LLVM
optimizations have been run. <a class="reference internal" href="HowToUpdateDebugInfo.html"><span class="doc">How to Update Debug Info: A Guide for LLVM Pass Authors</span></a> specifies how debug
info should be updated in various kinds of code transformations to avoid
breaking this guarantee, and how to preserve as much useful debug info as
possible.  Note that some optimizations may impact the ability to modify the
current state of the program with a debugger, such as setting program
variables, or calling functions that have been deleted.</p></li>
<li><p>As desired, LLVM optimizations can be upgraded to be aware of debugging
information, allowing them to update the debugging information as they
perform aggressive optimizations.  This means that, with effort, the LLVM
optimizers could optimize debug code just as well as non-debug code.</p></li>
<li><p>LLVM debug information does not prevent optimizations from
happening (for example inlining, basic block reordering/merging/cleanup,
tail duplication, etc).</p></li>
<li><p>LLVM debug information is automatically optimized along with the rest of
the program, using existing facilities.  For example, duplicate
information is automatically merged by the linker, and unused information
is automatically removed.</p></li>
</ul>
<p>Basically, the debug information allows you to compile a program with
â<code class="docutils literal notranslate"><span class="pre">-O0</span> <span class="pre">-g</span></code>â and get full debug information, allowing you to arbitrarily modify
the program as it executes from a debugger.  Compiling a program with
â<code class="docutils literal notranslate"><span class="pre">-O3</span> <span class="pre">-g</span></code>â gives you full debug information that is always available and
accurate for reading (e.g., you get accurate stack traces despite tail call
elimination and inlining), but you might lose the ability to modify the program
and call functions which were optimized out of the program, or inlined away
completely.</p>
<p>The <a class="reference internal" href="TestSuiteMakefileGuide.html"><span class="doc">LLVM test-suite</span></a> provides a framework to
test the optimizerâs handling of debugging information.  It can be run like
this:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>%<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>llvm/projects/test-suite/MultiSource/Benchmarks<span class="w">  </span><span class="c1"># or some other level</span>
%<span class="w"> </span>make<span class="w"> </span><span class="nv">TEST</span><span class="o">=</span>dbgopt
</pre></div>
</div>
<p>This will test impact of debugging information on optimization passes.  If
debugging information influences optimization passes then it will be reported
as a failure.  See <a class="reference internal" href="TestingGuide.html"><span class="doc">LLVM Testing Infrastructure Guide</span></a> for more information on LLVM test
infrastructure and how to run various tests.</p>
</section>
</section>
<section id="debugging-information-format">
<span id="format"></span><h2><a class="toc-backref" href="#id15" role="doc-backlink">Debugging information format</a><a class="headerlink" href="#debugging-information-format" title="Link to this heading">Â¶</a></h2>
<p>LLVM debugging information has been carefully designed to make it possible for
the optimizer to optimize the program and debugging information without
necessarily having to know anything about debugging information.  In
particular, the use of metadata avoids duplicated debugging information from
the beginning, and the global dead code elimination pass automatically deletes
debugging information for a function if it decides to delete the function.</p>
<p>To do this, most of the debugging information (descriptors for types,
variables, functions, source files, etc) is inserted by the language front-end
in the form of LLVM metadata.</p>
<p>Debug information is designed to be agnostic about the target debugger and
debugging information representation (e.g. DWARF/Stabs/etc).  It uses a generic
pass to decode the information that represents variables, types, functions,
namespaces, etc: this allows for arbitrary source-language semantics and
type-systems to be used, as long as there is a module written for the target
debugger to interpret the information.</p>
<p>To provide basic functionality, the LLVM debugger does have to make some
assumptions about the source-level language being debugged, though it keeps
these to a minimum.  The only common features that the LLVM debugger assumes
exist are <a class="reference external" href="LangRef.html#difile">source files</a>, and <a class="reference external" href="LangRef.html#diglobalvariable">program objects</a>.  These abstract objects are used by a
debugger to form stack traces, show information about local variables, etc.</p>
<p>This section of the documentation first describes the representation aspects
common to any source-language.  <a class="reference internal" href="#ccxx-frontend"><span class="std std-ref">C/C++ front-end specific debug information</span></a> describes the data layout
conventions used by the C and C++ front-ends.</p>
<p>Debug information descriptors are <a class="reference external" href="LangRef.html#specialized-metadata">specialized metadata nodes</a>, first-class subclasses of <code class="docutils literal notranslate"><span class="pre">Metadata</span></code>.</p>
<p>There are two models for defining the values of source variables at different
states of the program and tracking these values through optimization and code
generation: <a class="reference internal" href="#debug-records"><span class="std std-ref">debug records</span></a>, the current default, and
<a class="reference internal" href="#format-common-intrinsics"><span class="std std-ref">intrinsic function calls</span></a>, which are
non-default but currently supported for backwards compatibility - though these
two models must never be mixed within an IR module. For an explanation of why
we changed to the new model, how it works, and guidance on how to update old
code or IR to use debug records, see the <a class="reference external" href="RemoveDIsDebugInfo.html">RemoveDIs</a>
document.</p>
<section id="debug-records">
<span id="id1"></span><h3><a class="toc-backref" href="#id16" role="doc-backlink">Debug Records</a><a class="headerlink" href="#debug-records" title="Link to this heading">Â¶</a></h3>
<p>Debug records define the value that a source variable has during execution of
the program; they appear interleaved with instructions, although they are not
instructions themselves and have no effect on the code generated by the
compiler.</p>
<p>LLVM uses several types of debug records to define source variables. The
common syntax for these records is:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="err">#dbg_</span><span class="p">&lt;</span><span class="k">kind</span><span class="p">&gt;([&lt;</span><span class="err">arg</span><span class="p">&gt;,</span><span class="w"> </span><span class="p">]*</span><span class="w"> </span><span class="p">&lt;</span><span class="err">DILocation</span><span class="p">&gt;)</span>
<span class="c">; Using the intrinsic model, the above is equivalent to:</span>
<span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="err">llvm</span><span class="p">.</span><span class="err">dbg</span><span class="p">.&lt;</span><span class="k">kind</span><span class="p">&gt;([</span><span class="k">metadata</span><span class="w"> </span><span class="p">&lt;</span><span class="err">arg</span><span class="p">&gt;,</span><span class="w"> </span><span class="p">]*),</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="p">&lt;</span><span class="err">DILocation</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Debug records are always printed with an extra level of indentation compared
to instructions, and always have the prefix <cite>#dbg_</cite> and a list of
comma-separated arguments in parentheses, as with a <cite>call</cite>.</p>
<section id="dbg-declare">
<h4><a class="toc-backref" href="#id17" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code></a><a class="headerlink" href="#dbg-declare" title="Link to this heading">Â¶</a></h4>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="err">#dbg_</span><span class="k">declare</span><span class="p">([</span><span class="err">Value|MDNode</span><span class="p">],</span><span class="w"> </span><span class="err">DILocalVariable</span><span class="p">,</span><span class="w"> </span><span class="err">DIExpression</span><span class="p">,</span><span class="w"> </span><span class="err">DILocation</span><span class="p">)</span>
</pre></div>
</div>
<p>This record provides information about a local element (e.g., variable).
The first argument is an SSA value corresponding to a variable address, and is
typically a static alloca in the function entry block.  The second argument is a
<a class="reference external" href="LangRef.html#dilocalvariable">local variable</a> containing a description of
the variable.  The third argument is a <a class="reference external" href="LangRef.html#diexpression">complex expression</a>. The fourth argument is a <a class="reference external" href="LangRef.html#dilocation">source location</a>. A <code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code> record describes the
<em>address</em> of a source variable.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv">%i.addr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
<span class="w">  </span><span class="err">#dbg_</span><span class="k">declare</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%i.addr</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!2</span><span class="p">)</span>
<span class="c">; ...</span>
<span class="nv nv-Anonymous">!1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nv">!DILocalVariable</span><span class="p">(</span><span class="nl">name:</span><span class="w"> </span><span class="s">&quot;i&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="c">; int i</span>
<span class="nv nv-Anonymous">!2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nv">!DILocation</span><span class="p">(...)</span>
<span class="c">; ...</span>
<span class="nv">%buffer</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="p">[</span><span class="m">256</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i8</span><span class="p">],</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">8</span>
<span class="c">; The address of i is buffer+64.</span>
<span class="w">  </span><span class="err">#dbg_</span><span class="k">declare</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%buffer</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(</span><span class="err">DW_OP_plus</span><span class="p">,</span><span class="w"> </span><span class="m">64</span><span class="p">),</span><span class="w"> </span><span class="nv nv-Anonymous">!4</span><span class="p">)</span>
<span class="c">; ...</span>
<span class="nv nv-Anonymous">!3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nv">!DILocalVariable</span><span class="p">(</span><span class="nl">name:</span><span class="w"> </span><span class="s">&quot;i&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="c">; int i</span>
<span class="nv nv-Anonymous">!4</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nv">!DILocation</span><span class="p">(...)</span>
</pre></div>
</div>
<p>A frontend should generate exactly one <code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code> record at the point
of declaration of a source variable. Optimization passes that fully promote the
variable from memory to SSA values will replace this record with possibly
multiple <code class="docutils literal notranslate"><span class="pre">#dbg_value`</span></code> records. Passes that delete stores are effectively
partial promotion, and they will insert a mix of <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> records to
track the source variable value when it is available. After optimization, there
may be multiple <code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code> records describing the program points where
the variables lives in memory. All calls for the same concrete source variable
must agree on the memory location.</p>
</section>
<section id="dbg-value">
<h4><a class="toc-backref" href="#id18" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code></a><a class="headerlink" href="#dbg-value" title="Link to this heading">Â¶</a></h4>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="err">#dbg_value</span><span class="p">([</span><span class="err">Value|DIArgList|MDNode</span><span class="p">],</span><span class="w"> </span><span class="err">DILocalVariable</span><span class="p">,</span><span class="w"> </span><span class="err">DIExpression</span><span class="p">,</span><span class="w"> </span><span class="err">DILocation</span><span class="p">)</span>
</pre></div>
</div>
<p>This record provides information when a user source variable is set to a new
value.  The first argument is the new value. The second argument is a <a class="reference external" href="LangRef.html#dilocalvariable">local
variable</a> containing a description of the
variable.  The third argument is a <a class="reference external" href="LangRef.html#diexpression">complex expression</a>. The fourth argument is a <a class="reference external" href="LangRef.html#dilocation">source location</a>.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> record describes the <em>value</em> of a source variable
directly, not its address.  Note that the value operand of this intrinsic may
be indirect (i.e, a pointer to the source variable), provided that interpreting
the complex expression derives the direct value.</p>
</section>
<section id="dbg-assign">
<h4><a class="toc-backref" href="#id19" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">#dbg_assign</span></code></a><a class="headerlink" href="#dbg-assign" title="Link to this heading">Â¶</a></h4>
<div class="toctree-wrapper compound">
</div>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="err">#dbg_assign</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="err">Value|DIArgList|MDNode</span><span class="p">]</span><span class="w"> </span><span class="err">Value</span><span class="p">,</span>
<span class="w">             </span><span class="err">DILocalVariable</span><span class="w"> </span><span class="err">Variable</span><span class="p">,</span>
<span class="w">             </span><span class="err">DIExpression</span><span class="w"> </span><span class="err">ValueExpression</span><span class="p">,</span>
<span class="w">             </span><span class="err">DIAssignID</span><span class="w"> </span><span class="err">ID</span><span class="p">,</span>
<span class="w">             </span><span class="p">[</span><span class="err">Value|MDNode</span><span class="p">]</span><span class="w"> </span><span class="err">Address</span><span class="p">,</span>
<span class="w">             </span><span class="err">DIExpression</span><span class="w"> </span><span class="err">AddressExpression</span><span class="p">,</span>
<span class="w">             </span><span class="err">DILocation</span><span class="w"> </span><span class="err">SourceLocation</span><span class="w"> </span><span class="p">)</span>
</pre></div>
</div>
<p>This record marks the position in IR where a source assignment occurred. It
encodes the value of the variable. It references the store, if any, that
performs the assignment, and the destination address.</p>
<p>The first three arguments are the same as for a <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code>. The fourth
argument is a <code class="docutils literal notranslate"><span class="pre">DIAssignID</span></code> used to reference a store. The fifth is the
destination of the store, the sixth is a <a class="reference external" href="LangRef.html#diexpression">complex
expression</a> that modfies it, and the seventh is a
<a class="reference external" href="LangRef.html#dilocation">source location</a>.</p>
<p>See <a class="reference internal" href="AssignmentTracking.html"><span class="doc">Debug Info Assignment Tracking</span></a> for more info.</p>
</section>
</section>
<section id="debugger-intrinsic-functions">
<h3><a class="toc-backref" href="#id20" role="doc-backlink">Debugger intrinsic functions</a><a class="headerlink" href="#debugger-intrinsic-functions" title="Link to this heading">Â¶</a></h3>
<p id="format-common-intrinsics">In intrinsic-mode, LLVM uses several intrinsic functions (name prefixed with â<code class="docutils literal notranslate"><span class="pre">llvm.dbg</span></code>â) to
track source local variables through optimization and code generation. These
intrinsic functions each correspond to one of the debug records above, with a
few syntactic differences: each argument to a debugger intrinsic must be wrapped
as metadata, meaning it must be prefixed with <code class="docutils literal notranslate"><span class="pre">metadata</span></code>, and the
<code class="docutils literal notranslate"><span class="pre">DILocation</span></code> argument in each record must be a metadata attachment to the
call instruction, meaning it appears after the argument list with the prefix
<code class="docutils literal notranslate"><span class="pre">!dbg</span></code>.</p>
<section id="llvm-dbg-declare">
<h4><a class="toc-backref" href="#id21" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">llvm.dbg.declare</span></code></a><a class="headerlink" href="#llvm-dbg-declare" title="Link to this heading">Â¶</a></h4>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.dbg.declare</span><span class="p">(</span><span class="k">metadata</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="p">)</span>
</pre></div>
</div>
<p>This intrinsic is equivalent to <code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code>:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="err">#dbg_</span><span class="k">declare</span><span class="p">(</span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%i.addr</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!2</span><span class="p">)</span>
<span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.dbg.declare</span><span class="p">(</span><span class="k">metadata</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%i.addr</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span>
<span class="w">                            </span><span class="k">metadata</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">()),</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!2</span>
</pre></div>
</div>
</section>
<section id="llvm-dbg-value">
<h4><a class="toc-backref" href="#id22" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">llvm.dbg.value</span></code></a><a class="headerlink" href="#llvm-dbg-value" title="Link to this heading">Â¶</a></h4>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.dbg.value</span><span class="p">(</span><span class="k">metadata</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="p">)</span>
</pre></div>
</div>
<p>This intrinsic is equivalent to <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code>:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!2</span><span class="p">)</span>
<span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.dbg.value</span><span class="p">(</span><span class="k">metadata</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span>
<span class="w">                          </span><span class="k">metadata</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">()),</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!2</span>
</pre></div>
</div>
</section>
<section id="llvm-dbg-assign">
<h4><a class="toc-backref" href="#id23" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">llvm.dbg.assign</span></code></a><a class="headerlink" href="#llvm-dbg-assign" title="Link to this heading">Â¶</a></h4>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.dbg.assign</span><span class="p">(</span><span class="k">metadata</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="p">)</span>
</pre></div>
</div>
<p>This intrinsic is equivalent to <code class="docutils literal notranslate"><span class="pre">#dbg_assign</span></code>:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="err">#dbg_assign</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!2</span><span class="p">,</span>
<span class="w">              </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%i.addr</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="p">)</span>
<span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.dbg.assign</span><span class="p">(</span>
<span class="w">  </span><span class="k">metadata</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="k">metadata</span><span class="w"> </span><span class="nv nv-Anonymous">!2</span><span class="p">,</span>
<span class="w">  </span><span class="k">metadata</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%i.addr</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="k">metadata</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="p">),</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="object-lifetimes-and-scoping">
<h2><a class="toc-backref" href="#id24" role="doc-backlink">Object lifetimes and scoping</a><a class="headerlink" href="#object-lifetimes-and-scoping" title="Link to this heading">Â¶</a></h2>
<p>In many languages, the local variables in functions can have their lifetimes or
scopes limited to a subset of a function.  In the C family of languages, for
example, variables are only live (readable and writable) within the source
block that they are defined in.  In functional languages, values are only
readable after they have been defined.  Though this is a very obvious concept,
it is non-trivial to model in LLVM, because it has no notion of scoping in this
sense, and does not want to be tied to a languageâs scoping rules.</p>
<p>In order to handle this, the LLVM debug format uses the metadata attached to
llvm instructions to encode line number and scoping information.  Consider the
following C fragment, for example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="mf">2.</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">21</span><span class="p">;</span>
<span class="mf">3.</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">22</span><span class="p">;</span>
<span class="mf">4.</span><span class="w">    </span><span class="p">{</span>
<span class="mf">5.</span><span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">Z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">23</span><span class="p">;</span>
<span class="mf">6.</span><span class="w">      </span><span class="n">Z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="p">;</span>
<span class="mf">7.</span><span class="w">    </span><span class="p">}</span>
<span class="mf">8.</span><span class="w">    </span><span class="n">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Y</span><span class="p">;</span>
<span class="mf">9.</span><span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>Compiled to LLVM, this function would be represented like this:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>; Function Attrs: nounwind ssp uwtable
define void @foo() #0 !dbg !4 {
entry:
  %X = alloca i32, align 4
  %Y = alloca i32, align 4
  %Z = alloca i32, align 4
    #dbg_declare(ptr %X, !11, !DIExpression(), !13)
  store i32 21, i32* %X, align 4, !dbg !13
    #dbg_declare(ptr %Y, !14, !DIExpression(), !15)
  store i32 22, i32* %Y, align 4, !dbg !15
    #dbg_declare(ptr %Z, !16, !DIExpression(), !18)
  store i32 23, i32* %Z, align 4, !dbg !18
  %0 = load i32, i32* %X, align 4, !dbg !20
  store i32 %0, i32* %Z, align 4, !dbg !21
  %1 = load i32, i32* %Y, align 4, !dbg !22
  store i32 %1, i32* %X, align 4, !dbg !23
  ret void, !dbg !24
}

attributes #0 = { nounwind ssp uwtable &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;frame-pointer&quot;=&quot;all&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; }
attributes #1 = { nounwind readnone }

!llvm.dbg.cu = !{!0}
!llvm.module.flags = !{!7, !8, !9}
!llvm.ident = !{!10}

!0 = !DICompileUnit(language: DW_LANG_C99, file: !1, producer: &quot;clang version 3.7.0 (trunk 231150) (llvm/trunk 231154)&quot;, isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, retainedTypes: !2, subprograms: !3, globals: !2, imports: !2)
!1 = !DIFile(filename: &quot;/dev/stdin&quot;, directory: &quot;/Users/dexonsmith/data/llvm/debug-info&quot;)
!2 = !{}
!3 = !{!4}
!4 = distinct !DISubprogram(name: &quot;foo&quot;, scope: !1, file: !1, line: 1, type: !5, isLocal: false, isDefinition: true, scopeLine: 1, isOptimized: false, retainedNodes: !2)
!5 = !DISubroutineType(types: !6)
!6 = !{null}
!7 = !{i32 2, !&quot;Dwarf Version&quot;, i32 2}
!8 = !{i32 2, !&quot;Debug Info Version&quot;, i32 3}
!9 = !{i32 1, !&quot;PIC Level&quot;, i32 2}
!10 = !{!&quot;clang version 3.7.0 (trunk 231150) (llvm/trunk 231154)&quot;}
!11 = !DILocalVariable(name: &quot;X&quot;, scope: !4, file: !1, line: 2, type: !12)
!12 = !DIBasicType(name: &quot;int&quot;, size: 32, align: 32, encoding: DW_ATE_signed)
!13 = !DILocation(line: 2, column: 9, scope: !4)
!14 = !DILocalVariable(name: &quot;Y&quot;, scope: !4, file: !1, line: 3, type: !12)
!15 = !DILocation(line: 3, column: 9, scope: !4)
!16 = !DILocalVariable(name: &quot;Z&quot;, scope: !18, file: !1, line: 5, type: !12)
!17 = distinct !DILexicalBlock(scope: !4, file: !1, line: 4, column: 5)
!18 = !DILocation(line: 5, column: 11, scope: !17)
!29 = !DILocation(line: 6, column: 11, scope: !17)
!20 = !DILocation(line: 6, column: 9, scope: !17)
!21 = !DILocation(line: 8, column: 9, scope: !4)
!22 = !DILocation(line: 8, column: 7, scope: !4)
!23 = !DILocation(line: 9, column: 3, scope: !4)
</pre></div>
</div>
<p>This example illustrates a few important details about LLVM debugging
information.  In particular, it shows how the <code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code> record and
location information, which are attached to an instruction, are applied
together to allow a debugger to analyze the relationship between statements,
variable definitions, and the code used to implement the function.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="err">#dbg_</span><span class="k">declare</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%X</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!11</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!13</span><span class="p">)</span>
<span class="c">; [debug line = 2:9] [debug variable = X]</span>
</pre></div>
</div>
<p>The first record <code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code> encodes debugging information for the
variable <code class="docutils literal notranslate"><span class="pre">X</span></code>.  The location <code class="docutils literal notranslate"><span class="pre">!13</span></code> at the end of the record provides
scope information for the variable <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>!13 = !DILocation(line: 2, column: 9, scope: !4)
!4 = distinct !DISubprogram(name: &quot;foo&quot;, scope: !1, file: !1, line: 1, type: !5,
                            isLocal: false, isDefinition: true, scopeLine: 1,
                            isOptimized: false, retainedNodes: !2)
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">!13</span></code> is metadata providing <a class="reference external" href="LangRef.html#dilocation">location information</a>.  In this example, scope is encoded by <code class="docutils literal notranslate"><span class="pre">!4</span></code>, a
<a class="reference external" href="LangRef.html#disubprogram">subprogram descriptor</a>.  This way the location
information parameter to the records indicates that the variable <code class="docutils literal notranslate"><span class="pre">X</span></code> is
declared at line number 2 at a function level scope in function <code class="docutils literal notranslate"><span class="pre">foo</span></code>.</p>
<p>Now lets take another example.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="err">#dbg_</span><span class="k">declare</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%Z</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!16</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!18</span><span class="p">)</span>
<span class="c">; [debug line = 5:11] [debug variable = Z]</span>
</pre></div>
</div>
<p>The third record <code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code> encodes debugging information for
variable <code class="docutils literal notranslate"><span class="pre">Z</span></code>.  The metadata <code class="docutils literal notranslate"><span class="pre">!18</span></code> at the end of the record provides
scope information for the variable <code class="docutils literal notranslate"><span class="pre">Z</span></code>.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>!17 = distinct !DILexicalBlock(scope: !4, file: !1, line: 4, column: 5)
!18 = !DILocation(line: 5, column: 11, scope: !17)
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">!18</span></code> indicates that <code class="docutils literal notranslate"><span class="pre">Z</span></code> is declared at line number 5 and column
number 11 inside of lexical scope <code class="docutils literal notranslate"><span class="pre">!17</span></code>.  The lexical scope itself resides
inside of subprogram <code class="docutils literal notranslate"><span class="pre">!4</span></code> described above.</p>
<p>The scope information attached with each instruction provides a straightforward
way to find instructions covered by a scope.</p>
</section>
<section id="object-lifetime-in-optimized-code">
<h2><a class="toc-backref" href="#id25" role="doc-backlink">Object lifetime in optimized code</a><a class="headerlink" href="#object-lifetime-in-optimized-code" title="Link to this heading">Â¶</a></h2>
<p>In the example above, every variable assignment uniquely corresponds to a
memory store to the variableâs position on the stack. However in heavily
optimized code LLVM promotes most variables into SSA values, which can
eventually be placed in physical registers or memory locations. To track SSA
values through compilation, when objects are promoted to SSA values a
<code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> record is created for each assignment, recording the
variableâs new location. Compared with the <code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code> record:</p>
<ul class="simple">
<li><p>A #dbg_value terminates the effect of any preceding #dbg_values for (any
overlapping fragments of) the specified variable.</p></li>
<li><p>The #dbg_valueâs position in the IR defines where in the instruction stream
the variableâs value changes.</p></li>
<li><p>Operands can be constants, indicating the variable is assigned a
constant value.</p></li>
</ul>
<p>Care must be taken to update <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> records when optimization
passes alter or move instructions and blocks â the developer could observe such
changes reflected in the value of variables when debugging the program. For any
execution of the optimized program, the set of variable values presented to the
developer by the debugger should not show a state that would never have existed
in the execution of the unoptimized program, given the same input. Doing so
risks misleading the developer by reporting a state that does not exist,
damaging their understanding of the optimized program and undermining their
trust in the debugger.</p>
<p>Sometimes perfectly preserving variable locations is not possible, often when a
redundant calculation is optimized out. In such cases, a <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code>
with operand <code class="docutils literal notranslate"><span class="pre">poison</span></code> should be used, to terminate earlier variable locations
and let the debugger present <code class="docutils literal notranslate"><span class="pre">optimized</span> <span class="pre">out</span></code> to the developer. Withholding
these potentially stale variable values from the developer diminishes the
amount of available debug information, but increases the reliability of the
remaining information.</p>
<p>To illustrate some potential issues, consider the following example:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@foo</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!4</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cond</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%truebr</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%falsebr</span>
<span class="nl">truebr:</span>
<span class="w">  </span><span class="nv">%tval</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar</span><span class="p">,</span><span class="w"> </span><span class="m">1</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%tval</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!4</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%g1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@gazonk</span><span class="p">()</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%exit</span>
<span class="nl">falsebr:</span>
<span class="w">  </span><span class="nv">%fval</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar</span><span class="p">,</span><span class="w"> </span><span class="m">2</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%fval</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!4</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%g2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@gazonk</span><span class="p">()</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%exit</span>
<span class="nl">exit:</span>
<span class="w">  </span><span class="nv">%merge</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%tval</span><span class="p">,</span><span class="w"> </span><span class="nv">%truebr</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%fval</span><span class="p">,</span><span class="w"> </span><span class="nv">%falsebr</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="nv">%g</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%g1</span><span class="p">,</span><span class="w"> </span><span class="nv">%truebr</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%g2</span><span class="p">,</span><span class="w"> </span><span class="nv">%falsebr</span><span class="w"> </span><span class="p">]</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%merge</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!4</span><span class="p">)</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%g</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!4</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%plusten</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%merge</span><span class="p">,</span><span class="w"> </span><span class="m">10</span>
<span class="w">  </span><span class="nv">%toret</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%plusten</span><span class="p">,</span><span class="w"> </span><span class="nv">%g</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%toret</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!4</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%toret</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Containing two source-level variables in <code class="docutils literal notranslate"><span class="pre">!1</span></code> and <code class="docutils literal notranslate"><span class="pre">!3</span></code>. The function could,
perhaps, be optimized into the following code:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@foo</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%g</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@gazonk</span><span class="p">()</span>
<span class="w">  </span><span class="nv">%addoper</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cond</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">11</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">12</span>
<span class="w">  </span><span class="nv">%plusten</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar</span><span class="p">,</span><span class="w"> </span><span class="nv">%addoper</span>
<span class="w">  </span><span class="nv">%toret</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%plusten</span><span class="p">,</span><span class="w"> </span><span class="nv">%g</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%toret</span>
<span class="p">}</span>
</pre></div>
</div>
<p>What <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> records should be placed to represent the original variable
locations in this code? Unfortunately the second, third and fourth
#dbg_values for <code class="docutils literal notranslate"><span class="pre">!1</span></code> in the source function have had their operands
(%tval, %fval, %merge) optimized out. Assuming we cannot recover them, we
might consider this placement of #dbg_values:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@foo</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!4</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%g</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@gazonk</span><span class="p">()</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%g</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!4</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%addoper</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cond</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">11</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">12</span>
<span class="w">  </span><span class="nv">%plusten</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar</span><span class="p">,</span><span class="w"> </span><span class="nv">%addoper</span>
<span class="w">  </span><span class="nv">%toret</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%plusten</span><span class="p">,</span><span class="w"> </span><span class="nv">%g</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%toret</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!4</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%toret</span>
<span class="p">}</span>
</pre></div>
</div>
<p>However, this will cause <code class="docutils literal notranslate"><span class="pre">!3</span></code> to have the return value of <code class="docutils literal notranslate"><span class="pre">&#64;gazonk()</span></code> at
the same time as <code class="docutils literal notranslate"><span class="pre">!1</span></code> has the constant value zero â a pair of assignments
that never occurred in the unoptimized program. To avoid this, we must terminate
the range that <code class="docutils literal notranslate"><span class="pre">!1</span></code> has the constant value assignment by inserting an poison
#dbg_value before the #dbg_value for <code class="docutils literal notranslate"><span class="pre">!3</span></code>:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@foo</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!2</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%g</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@gazonk</span><span class="p">()</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="k">poison</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!2</span><span class="p">)</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%g</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!2</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%addoper</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cond</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">11</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">12</span>
<span class="w">  </span><span class="nv">%plusten</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar</span><span class="p">,</span><span class="w"> </span><span class="nv">%addoper</span>
<span class="w">  </span><span class="nv">%toret</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%plusten</span><span class="p">,</span><span class="w"> </span><span class="nv">%g</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%toret</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!2</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%toret</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There are a few other #dbg_value configurations that mean it terminates
dominating location definitions without adding a new location. The complete
list is:</p>
<ul class="simple">
<li><p>Any location operand is <code class="docutils literal notranslate"><span class="pre">poison</span></code> (or <code class="docutils literal notranslate"><span class="pre">undef</span></code>).</p></li>
<li><p>Any location operand is an empty metadata tuple (<code class="docutils literal notranslate"><span class="pre">!{}</span></code>) (which cannot
occur in a <code class="docutils literal notranslate"><span class="pre">!DIArgList</span></code>).</p></li>
<li><p>There are no location operands (empty <code class="docutils literal notranslate"><span class="pre">DIArgList</span></code>) and the <code class="docutils literal notranslate"><span class="pre">DIExpression</span></code>
is empty.</p></li>
</ul>
<p>This class of #dbg_value that kills variable locations is called a âkill
#dbg_valueâ or âkill locationâ, and for legacy reasons the term âundef
#dbg_valueâ may be used in existing code. The <code class="docutils literal notranslate"><span class="pre">DbgVariableIntrinsic</span></code> methods
<code class="docutils literal notranslate"><span class="pre">isKillLocation</span></code> and <code class="docutils literal notranslate"><span class="pre">setKillLocation</span></code> should be used where possible rather
than inspecting location operands directly to check or set whether a #dbg_value
is a kill location.</p>
<p>In general, if any #dbg_value has its operand optimized out and cannot be
recovered, then a kill #dbg_value is necessary to terminate earlier variable
locations. Additional kill #dbg_values may be necessary when the debugger can
observe re-ordering of assignments.</p>
</section>
<section id="how-variable-location-metadata-is-transformed-during-codegen">
<h2><a class="toc-backref" href="#id26" role="doc-backlink">How variable location metadata is transformed during CodeGen</a><a class="headerlink" href="#how-variable-location-metadata-is-transformed-during-codegen" title="Link to this heading">Â¶</a></h2>
<p>LLVM preserves debug information throughout mid-level and backend passes,
ultimately producing a mapping between source-level information and
instruction ranges. This
is relatively straightforwards for line number information, as mapping
instructions to line numbers is a simple association. For variable locations
however the story is more complex. As each <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> record
represents a source-level assignment of a value to a source variable, the
debug records effectively embed a small imperative program
within the LLVM IR. By the end of CodeGen, this becomes a mapping from each
variable to their machine locations over ranges of instructions.
From IR to object emission, the major transformations which affect variable
location fidelity are:</p>
<ol class="arabic simple">
<li><p>Instruction Selection</p></li>
<li><p>Register allocation</p></li>
<li><p>Block layout</p></li>
</ol>
<p>each of which are discussed below. In addition, instruction scheduling can
significantly change the ordering of the program, and occurs in a number of
different passes.</p>
<p>Some variable locations are not transformed during CodeGen. Stack locations
specified by <code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code> are valid and unchanging for the entire
duration of the function, and are recorded in a simple MachineFunction table.
Location changes in the prologue and epilogue of a function are also ignored:
frame setup and destruction may take several instructions, require a
disproportionate amount of debugging information in the output binary to
describe, and should be stepped over by debuggers anyway.</p>
<section id="variable-locations-in-instruction-selection-and-mir">
<h3><a class="toc-backref" href="#id27" role="doc-backlink">Variable locations in Instruction Selection and MIR</a><a class="headerlink" href="#variable-locations-in-instruction-selection-and-mir" title="Link to this heading">Â¶</a></h3>
<p>Instruction selection creates a MIR function from an IR function, and just as
it transforms <code class="docutils literal notranslate"><span class="pre">intermediate</span></code> instructions into machine instructions, so must
<code class="docutils literal notranslate"><span class="pre">intermediate</span></code> variable locations become machine variable locations.
Within IR, variable locations are always identified by a Value, but in MIR
there can be different types of variable locations. In addition, some IR
locations become unavailable, for example if the operation of multiple IR
instructions are combined into one machine instruction (such as
multiply-and-accumulate) then intermediate Values are lost. To track variable
locations through instruction selection, they are first separated into
locations that do not depend on code generation (constants, stack locations,
allocated virtual registers) and those that do. For those that do, debug
metadata is attached to SDNodes in SelectionDAGs. After instruction selection
has occurred and a MIR function is created, if the SDNode associated with debug
metadata is allocated a virtual register, that virtual register is used as the
variable location. If the SDNode is folded into a machine instruction or
otherwise transformed into a non-register, the variable location becomes
unavailable.</p>
<p>Locations that are unavailable are treated as if they have been optimized out:
in IR the location would be assigned <code class="docutils literal notranslate"><span class="pre">undef</span></code> by a debug record, and in MIR
the equivalent location is used.</p>
<p>After MIR locations are assigned to each variable, machine pseudo-instructions
corresponding to each <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> record are inserted. There are two
forms of this type of instruction.</p>
<p>The first form, <code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code>, appears thus:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DBG_VALUE %1, $noreg, !123, !DIExpression()
</pre></div>
</div>
<dl class="simple">
<dt>And has the following operands:</dt><dd><ul class="simple">
<li><p>The first operand can record the variable location as a register,
a frame index, an immediate, or the base address register if the original
debug record referred to memory. <code class="docutils literal notranslate"><span class="pre">$noreg</span></code> indicates the variable
location is undefined, equivalent to an <code class="docutils literal notranslate"><span class="pre">undef</span></code> #dbg_value operand.</p></li>
<li><p>The type of the second operand indicates whether the variable location is
directly referred to by the DBG_VALUE, or whether it is indirect. The
<code class="docutils literal notranslate"><span class="pre">$noreg</span></code> register signifies the former, an immediate operand (0) the
latter.</p></li>
<li><p>Operand 3 is the Variable field of the original debug record.</p></li>
<li><p>Operand 4 is the Expression field of the original debug record.</p></li>
</ul>
</dd>
</dl>
<p>The second form, <code class="docutils literal notranslate"><span class="pre">DBG_VALUE_LIST</span></code>, appears thus:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DBG_VALUE_LIST !123, !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_plus), %1, %2
</pre></div>
</div>
<dl class="simple">
<dt>And has the following operands:</dt><dd><ul class="simple">
<li><p>The first operand is the Variable field of the original debug record.</p></li>
<li><p>The second operand is the Expression field of the original debug record.</p></li>
<li><p>Any number of operands, from the 3rd onwards, record a sequence of variable
location operands, which may take any of the same values as the first
operand of the <code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code> instruction above. These variable location
operands are inserted into the final DWARF Expression in positions indicated
by the DW_OP_LLVM_arg operator in the <a class="reference external" href="LangRef.html#diexpression">DIExpression</a>.</p></li>
</ul>
</dd>
</dl>
<p>The position at which the DBG_VALUEs are inserted should correspond to the
positions of their matching <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> records in the IR block.  As
with optimization, LLVM aims to preserve the order in which variable
assignments occurred in the source program. However SelectionDAG performs some
instruction scheduling, which can reorder assignments (discussed below).
Function parameter locations are moved to the beginning of the function if
theyâre not already, to ensure theyâre immediately available on function entry.</p>
<p>To demonstrate variable locations during instruction selection, consider
the following example:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@foo</span><span class="p">(</span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%addr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%bb1</span><span class="p">,</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span>

<span class="nl">bb1:</span><span class="w">                                              </span><span class="c">; preds = %bb1, %entry</span>
<span class="w">  </span><span class="nv">%bar.0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nv">%entry</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%add</span><span class="p">,</span><span class="w"> </span><span class="nv">%bb1</span><span class="w"> </span><span class="p">]</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar.0</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%addr1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">*</span><span class="nv">%addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="p">*</span><span class="nv">%addr1</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%loaded1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%addr1</span><span class="p">,</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span>
<span class="w">  </span><span class="nv">%addr2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">*</span><span class="nv">%addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar.0</span><span class="p">,</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="p">*</span><span class="nv">%addr2</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%loaded2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%addr2</span><span class="p">,</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span>
<span class="w">  </span><span class="nv">%add</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar.0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%add</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%added</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%loaded1</span><span class="p">,</span><span class="w"> </span><span class="nv">%loaded2</span>
<span class="w">  </span><span class="nv">%cond</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">ult</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%added</span><span class="p">,</span><span class="w"> </span><span class="nv">%bar.0</span><span class="p">,</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cond</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%bb1</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%bb2</span><span class="p">,</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span>

<span class="nl">bb2:</span><span class="w">                                              </span><span class="c">; preds = %bb1</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If one compiles this IR with <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-o</span> <span class="pre">-</span> <span class="pre">-start-after=codegen-prepare</span> <span class="pre">-stop-after=expand-isel-pseudos</span> <span class="pre">-mtriple=x86_64--</span></code>, the following MIR is produced:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>bb.0.entry:
  successors: %bb.1(0x80000000)
  liveins: $rdi

  %2:gr64 = COPY $rdi
  %3:gr32 = MOV32r0 implicit-def dead $eflags
  DBG_VALUE 0, $noreg, !3, !DIExpression(), debug-location !5

bb.1.bb1:
  successors: %bb.1(0x7c000000), %bb.2(0x04000000)

  %0:gr32 = PHI %3, %bb.0, %1, %bb.1
  DBG_VALUE %0, $noreg, !3, !DIExpression(), debug-location !5
  DBG_VALUE %2, $noreg, !3, !DIExpression(DW_OP_plus_uconst, 4, DW_OP_stack_value), debug-location !5
  %4:gr32 = MOV32rm %2, 1, $noreg, 4, $noreg, debug-location !5 :: (load 4 from %ir.addr1)
  %5:gr64_nosp = MOVSX64rr32 %0, debug-location !5
  DBG_VALUE $noreg, $noreg, !3, !DIExpression(), debug-location !5
  %1:gr32 = INC32r %0, implicit-def dead $eflags, debug-location !5
  DBG_VALUE %1, $noreg, !3, !DIExpression(), debug-location !5
  %6:gr32 = ADD32rm %4, %2, 4, killed %5, 0, $noreg, implicit-def dead $eflags :: (load 4 from %ir.addr2)
  %7:gr32 = SUB32rr %6, %0, implicit-def $eflags, debug-location !5
  JB_1 %bb.1, implicit $eflags, debug-location !5
  JMP_1 %bb.2, debug-location !5

bb.2.bb2:
  %8:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %8, debug-location !5
  RET 0, $eax, debug-location !5
</pre></div>
</div>
<p>Observe first that there is a DBG_VALUE instruction for every <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code>
record in the source IR, ensuring no source level assignments go missing.
Then consider the different ways in which variable locations have been recorded:</p>
<ul class="simple">
<li><p>For the first #dbg_value an immediate operand is used to record a zero value.</p></li>
<li><p>The #dbg_value of the PHI instruction leads to a DBG_VALUE of virtual register
<code class="docutils literal notranslate"><span class="pre">%0</span></code>.</p></li>
<li><p>The first GEP has its effect folded into the first load instruction
(as a 4-byte offset), but the variable location is salvaged by folding
the GEPs effect into the DIExpression.</p></li>
<li><p>The second GEP is also folded into the corresponding load. However, it is
insufficiently simple to be salvaged, and is emitted as a <code class="docutils literal notranslate"><span class="pre">$noreg</span></code>
DBG_VALUE, indicating that the variable takes on an undefined location.</p></li>
<li><p>The final #dbg_value has its Value placed in virtual register <code class="docutils literal notranslate"><span class="pre">%1</span></code>.</p></li>
</ul>
</section>
<section id="instruction-scheduling">
<h3><a class="toc-backref" href="#id28" role="doc-backlink">Instruction Scheduling</a><a class="headerlink" href="#instruction-scheduling" title="Link to this heading">Â¶</a></h3>
<p>A number of passes can reschedule instructions, notably instruction selection
and the pre-and-post RA machine schedulers. Instruction scheduling can
significantly change the nature of the program â in the (very unlikely) worst
case the instruction sequence could be completely reversed. In such
circumstances LLVM follows the principle applied to optimizations, that it is
better for the debugger not to display any state than a misleading state.
Thus, whenever instructions are advanced in order of execution, any
corresponding DBG_VALUE is kept in its original position, and if an instruction
is delayed then the variable is given an undefined location for the duration
of the delay. To illustrate, consider this pseudo-MIR:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>%1:gr32 = MOV32rm %0, 1, $noreg, 4, $noreg, debug-location !5 :: (load 4 from %ir.addr1)
DBG_VALUE %1, $noreg, !1, !2
%4:gr32 = ADD32rr %3, %2, implicit-def dead $eflags
DBG_VALUE %4, $noreg, !3, !4
%7:gr32 = SUB32rr %6, %5, implicit-def dead $eflags
DBG_VALUE %7, $noreg, !5, !6
</pre></div>
</div>
<p>Imagine that the SUB32rr were moved forward to give us the following MIR:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>%7:gr32 = SUB32rr %6, %5, implicit-def dead $eflags
%1:gr32 = MOV32rm %0, 1, $noreg, 4, $noreg, debug-location !5 :: (load 4 from %ir.addr1)
DBG_VALUE %1, $noreg, !1, !2
%4:gr32 = ADD32rr %3, %2, implicit-def dead $eflags
DBG_VALUE %4, $noreg, !3, !4
DBG_VALUE %7, $noreg, !5, !6
</pre></div>
</div>
<p>In this circumstance LLVM would leave the MIR as shown above. Were we to move
the DBG_VALUE of virtual register %7 upwards with the SUB32rr, we would re-order
assignments and introduce a new state of the program. Whereas with the solution
above, the debugger will see one fewer combination of variable values, because
<code class="docutils literal notranslate"><span class="pre">!3</span></code> and <code class="docutils literal notranslate"><span class="pre">!5</span></code> will change value at the same time. This is preferred over
misrepresenting the original program.</p>
<p>In comparison, if one sunk the MOV32rm, LLVM would produce the following:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DBG_VALUE $noreg, $noreg, !1, !2
%4:gr32 = ADD32rr %3, %2, implicit-def dead $eflags
DBG_VALUE %4, $noreg, !3, !4
%7:gr32 = SUB32rr %6, %5, implicit-def dead $eflags
DBG_VALUE %7, $noreg, !5, !6
%1:gr32 = MOV32rm %0, 1, $noreg, 4, $noreg, debug-location !5 :: (load 4 from %ir.addr1)
DBG_VALUE %1, $noreg, !1, !2
</pre></div>
</div>
<p>Here, to avoid presenting a state in which the first assignment to <code class="docutils literal notranslate"><span class="pre">!1</span></code>
disappears, the DBG_VALUE at the top of the block assigns the variable the
undefined location, until its value is available at the end of the block where
an additional DBG_VALUE is added. Were any other DBG_VALUE for <code class="docutils literal notranslate"><span class="pre">!1</span></code> to occur
in the instructions that the MOV32rm was sunk past, the DBG_VALUE for <code class="docutils literal notranslate"><span class="pre">%1</span></code>
would be dropped and the debugger would never observe it in the variable. This
accurately reflects that the value is not available during the corresponding
portion of the original program.</p>
</section>
<section id="variable-locations-during-register-allocation">
<h3><a class="toc-backref" href="#id29" role="doc-backlink">Variable locations during Register Allocation</a><a class="headerlink" href="#variable-locations-during-register-allocation" title="Link to this heading">Â¶</a></h3>
<p>To avoid debug instructions interfering with the register allocator, the
LiveDebugVariables pass extracts variable locations from a MIR function and
deletes the corresponding DBG_VALUE instructions. Some localized copy
propagation is performed within blocks. After register allocation, the
VirtRegRewriter pass re-inserts DBG_VALUE instructions in their original
positions, translating virtual register references into their physical
machine locations. To avoid encoding incorrect variable locations, in this
pass any DBG_VALUE of a virtual register that is not live, is replaced by
the undefined location. The LiveDebugVariables may insert redundant DBG_VALUEs
because of virtual register rewriting. These will be subsequently removed by
the RemoveRedundantDebugValues pass.</p>
</section>
<section id="livedebugvalues-expansion-of-variable-locations">
<h3><a class="toc-backref" href="#id30" role="doc-backlink">LiveDebugValues expansion of variable locations</a><a class="headerlink" href="#livedebugvalues-expansion-of-variable-locations" title="Link to this heading">Â¶</a></h3>
<p>After all optimizations have run and shortly before emission, the
LiveDebugValues pass runs to achieve two aims:</p>
<ul class="simple">
<li><p>To propagate the location of variables through copies and register spills,</p></li>
<li><p>For every block, to record every valid variable location in that block.</p></li>
</ul>
<p>After this pass the DBG_VALUE instruction changes meaning: rather than
corresponding to a source-level assignment where the variable may change value,
it asserts the location of a variable in a block, and loses effect outside the
block. Propagating variable locations through copies and spills is
straightforwards: determining the variable location in every basic block
requires the consideration of control flow. Consider the following IR, which
presents several difficulties:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>define dso_local i32 @foo(i1 %cond, i32 %input) !dbg !12 {
entry:
  br i1 %cond, label %truebr, label %falsebr

bb1:
  %value = phi i32 [ %value1, %truebr ], [ %value2, %falsebr ]
  br label %exit, !dbg !26

truebr:
    #dbg_value(i32 %input, !30, !DIExpression(), !24)
    #dbg_value(i32 1, !23, !DIExpression(), !24)
  %value1 = add i32 %input, 1
  br label %bb1

falsebr:
    #dbg_value(i32 %input, !30, !DIExpression(), !24)
    #dbg_value(i32 2, !23, !DIExpression(), !24)
  %value2 = add i32 %input, 2
  br label %bb1

exit:
  ret i32 %value, !dbg !30
}
</pre></div>
</div>
<p>Here the difficulties are:</p>
<ul class="simple">
<li><p>The control flow is roughly the opposite of basic block order</p></li>
<li><p>The value of the <code class="docutils literal notranslate"><span class="pre">!23</span></code> variable merges into <code class="docutils literal notranslate"><span class="pre">%bb1</span></code>, but there is no PHI
node</p></li>
</ul>
<p>As mentioned above, the <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> records essentially form an
imperative program embedded in the IR, with each record defining a variable
location. This <em>could</em> be converted to an SSA form by mem2reg, in the same way
that it uses use-def chains to identify control flow merges and insert phi
nodes for IR Values. However, because debug variable locations are defined for
every machine instruction, in effect every IR instruction uses every variable
location, which would lead to a large number of debugging records being
generated.</p>
<p>Examining the example above, variable <code class="docutils literal notranslate"><span class="pre">!30</span></code> is assigned <code class="docutils literal notranslate"><span class="pre">%input</span></code> on both
conditional paths through the function, while <code class="docutils literal notranslate"><span class="pre">!23</span></code> is assigned differing
constant values on either path. Where control flow merges in <code class="docutils literal notranslate"><span class="pre">%bb1</span></code> we would
want <code class="docutils literal notranslate"><span class="pre">!30</span></code> to keep its location (<code class="docutils literal notranslate"><span class="pre">%input</span></code>), but <code class="docutils literal notranslate"><span class="pre">!23</span></code> to become undefined
as we cannot determine at runtime what value it should have in %bb1 without
inserting a PHI node. mem2reg does not insert the PHI node to avoid changing
codegen when debugging is enabled, and does not insert the other #dbg_values
to avoid adding very large numbers of records.</p>
<p>Instead, LiveDebugValues determines variable locations when control
flow merges. A dataflow analysis is used to propagate locations between blocks:
when control flow merges, if a variable has the same location in all
predecessors then that location is propagated into the successor. If the
predecessor locations disagree, the location becomes undefined.</p>
<p>Once LiveDebugValues has run, every block should have all valid variable
locations described by DBG_VALUE instructions within the block. Very little
effort is then required by supporting classes (such as
DbgEntityHistoryCalculator) to build a map of each instruction to every
valid variable location, without the need to consider control flow. From
the example above, it is otherwise difficult to determine that the location
of variable <code class="docutils literal notranslate"><span class="pre">!30</span></code> should flow âupâ into block <code class="docutils literal notranslate"><span class="pre">%bb1</span></code>, but that the location
of variable <code class="docutils literal notranslate"><span class="pre">!23</span></code> should not flow âdownâ into the <code class="docutils literal notranslate"><span class="pre">%exit</span></code> block.</p>
</section>
</section>
<section id="c-c-front-end-specific-debug-information">
<span id="ccxx-frontend"></span><h2><a class="toc-backref" href="#id31" role="doc-backlink">C/C++ front-end specific debug information</a><a class="headerlink" href="#c-c-front-end-specific-debug-information" title="Link to this heading">Â¶</a></h2>
<p>The C and C++ front-ends represent information about the program in a
format that is effectively identical to <a class="reference external" href="http://www.dwarfstd.org/">DWARF</a>
in terms of information content.  This allows code generators to
trivially support native debuggers by generating standard dwarf
information, and contains enough information for non-dwarf targets to
translate it as needed.</p>
<p>This section describes the forms used to represent C and C++ programs.  Other
languages could pattern themselves after this (which itself is tuned to
representing programs in the same way that DWARF does), or they could choose
to provide completely different forms if they donât fit into the DWARF model.
As support for debugging information gets added to the various LLVM
source-language front-ends, the information used should be documented here.</p>
<p>The following sections provide examples of a few C/C++ constructs and
the debug information that would best describe those constructs.  The
canonical references are the <code class="docutils literal notranslate"><span class="pre">DINode</span></code> classes defined in
<code class="docutils literal notranslate"><span class="pre">include/llvm/IR/DebugInfoMetadata.h</span></code> and the implementations of the
helper functions in <code class="docutils literal notranslate"><span class="pre">lib/IR/DIBuilder.cpp</span></code>.</p>
<section id="c-c-source-file-information">
<h3><a class="toc-backref" href="#id32" role="doc-backlink">C/C++ source file information</a><a class="headerlink" href="#c-c-source-file-information" title="Link to this heading">Â¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">llvm::Instruction</span></code> provides easy access to metadata attached with an
instruction.  One can extract line number information encoded in LLVM IR using
<code class="docutils literal notranslate"><span class="pre">Instruction::getDebugLoc()</span></code> and <code class="docutils literal notranslate"><span class="pre">DILocation::getLine()</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">DILocation</span><span class="w"> </span><span class="o">*</span><span class="n">Loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I</span><span class="o">-&gt;</span><span class="n">getDebugLoc</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Here I is an LLVM instruction</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">Line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Loc</span><span class="o">-&gt;</span><span class="n">getLine</span><span class="p">();</span>
<span class="w">  </span><span class="n">StringRef</span><span class="w"> </span><span class="n">File</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Loc</span><span class="o">-&gt;</span><span class="n">getFilename</span><span class="p">();</span>
<span class="w">  </span><span class="n">StringRef</span><span class="w"> </span><span class="n">Dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Loc</span><span class="o">-&gt;</span><span class="n">getDirectory</span><span class="p">();</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">ImplicitCode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Loc</span><span class="o">-&gt;</span><span class="n">isImplicitCode</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When the flag ImplicitCode is true then it means that the Instruction has been
added by the front-end but doesnât correspond to source code written by the user. For example</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">MyBoolean</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MyObject</span><span class="w"> </span><span class="n">MO</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>At the end of the scope the MyObjectâs destructor is called but it isnât written
explicitly. This information is useful to avoid to have counters on brackets when
making code coverage.</p>
</section>
<section id="c-c-global-variable-information">
<h3><a class="toc-backref" href="#id33" role="doc-backlink">C/C++ global variable information</a><a class="headerlink" href="#c-c-global-variable-information" title="Link to this heading">Â¶</a></h3>
<p>Given an integer global variable declared as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">_Alignas</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">MyGlobal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
</pre></div>
</div>
<p>a C/C++ front-end would generate the following descriptors:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>;;
;; Define the global itself.
;;
@MyGlobal = global i32 100, align 8, !dbg !0

;;
;; List of debug info of globals
;;
!llvm.dbg.cu = !{!1}

;; Some unrelated metadata.
!llvm.module.flags = !{!6, !7}
!llvm.ident = !{!8}

;; Define the global variable itself
!0 = distinct !DIGlobalVariable(name: &quot;MyGlobal&quot;, scope: !1, file: !2, line: 1, type: !5, isLocal: false, isDefinition: true, align: 64)

;; Define the compile unit.
!1 = distinct !DICompileUnit(language: DW_LANG_C99, file: !2,
                             producer: &quot;clang version 4.0.0&quot;,
                             isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug,
                             enums: !3, globals: !4)

;;
;; Define the file
;;
!2 = !DIFile(filename: &quot;/dev/stdin&quot;,
             directory: &quot;/Users/dexonsmith/data/llvm/debug-info&quot;)

;; An empty array.
!3 = !{}

;; The Array of Global Variables
!4 = !{!0}

;;
;; Define the type
;;
!5 = !DIBasicType(name: &quot;int&quot;, size: 32, encoding: DW_ATE_signed)

;; Dwarf version to output.
!6 = !{i32 2, !&quot;Dwarf Version&quot;, i32 4}

;; Debug info schema version.
!7 = !{i32 2, !&quot;Debug Info Version&quot;, i32 3}

;; Compiler identification
!8 = !{!&quot;clang version 4.0.0&quot;}
</pre></div>
</div>
<p>The align value in DIGlobalVariable description specifies variable alignment in
case it was forced by C11 _Alignas(), C++11 alignas() keywords or compiler
attribute __attribute__((aligned ())). In other case (when this field is missing)
alignment is considered default. This is used when producing DWARF output
for DW_AT_alignment value.</p>
</section>
<section id="c-c-function-information">
<h3><a class="toc-backref" href="#id34" role="doc-backlink">C/C++ function information</a><a class="headerlink" href="#c-c-function-information" title="Link to this heading">Â¶</a></h3>
<p>Given a function declared as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>a C/C++ front-end would generate the following descriptors:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>;;
;; Define the anchor for subprograms.
;;
!4 = !DISubprogram(name: &quot;main&quot;, scope: !1, file: !1, line: 1, type: !5,
                   isLocal: false, isDefinition: true, scopeLine: 1,
                   flags: DIFlagPrototyped, isOptimized: false,
                   retainedNodes: !2)

;;
;; Define the subprogram itself.
;;
define i32 @main(i32 %argc, i8** %argv) !dbg !4 {
...
}
</pre></div>
</div>
</section>
</section>
<section id="c-specific-debug-information">
<h2><a class="toc-backref" href="#id35" role="doc-backlink">C++ specific debug information</a><a class="headerlink" href="#c-specific-debug-information" title="Link to this heading">Â¶</a></h2>
<section id="c-special-member-functions-information">
<h3><a class="toc-backref" href="#id36" role="doc-backlink">C++ special member functions information</a><a class="headerlink" href="#c-special-member-functions-information" title="Link to this heading">Â¶</a></h3>
<p>DWARF v5 introduces attributes defined to enhance debugging information of C++ programs. LLVM can generate (or omit) these appropriate DWARF attributes. In C++ a special member function Ctors, Dtors, Copy/Move Ctors, assignment operators can be declared with C++11 keyword deleted. This is represented in LLVM using spFlags value DISPFlagDeleted.</p>
<p>Given a class declaration with copy constructor declared as deleted:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">class</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="n">public</span><span class="o">:</span>
<span class="w">   </span><span class="n">foo</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">foo</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">deleted</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>A C++ frontend would generate following:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>!17 = !DISubprogram(name: &quot;foo&quot;, scope: !11, file: !1, line: 5, type: !18, scopeLine: 5, flags: DIFlagPublic | DIFlagPrototyped, spFlags: DISPFlagDeleted)
</pre></div>
</div>
<p>and this will produce an additional DWARF attribute as:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DW_TAG_subprogram [7] *
  DW_AT_name [DW_FORM_strx1]    (indexed (00000006) string = &quot;foo&quot;)
  DW_AT_decl_line [DW_FORM_data1]       (5)
  ...
  DW_AT_deleted [DW_FORM_flag_present]  (true)
</pre></div>
</div>
</section>
</section>
<section id="fortran-specific-debug-information">
<h2><a class="toc-backref" href="#id37" role="doc-backlink">Fortran specific debug information</a><a class="headerlink" href="#fortran-specific-debug-information" title="Link to this heading">Â¶</a></h2>
<section id="fortran-function-information">
<h3><a class="toc-backref" href="#id38" role="doc-backlink">Fortran function information</a><a class="headerlink" href="#fortran-function-information" title="Link to this heading">Â¶</a></h3>
<p>There are a few DWARF attributes defined to support client debugging of Fortran programs.  LLVM can generate (or omit) the appropriate DWARF attributes for the prefix-specs of ELEMENTAL, PURE, IMPURE, RECURSIVE, and NON_RECURSIVE.  This is done by using the spFlags values: DISPFlagElemental, DISPFlagPure, and DISPFlagRecursive.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">elemental function </span><span class="n">elem_func</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>a Fortran front-end would generate the following descriptors:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>!11 = distinct !DISubprogram(name: &quot;subroutine2&quot;, scope: !1, file: !1,
        line: 5, type: !8, scopeLine: 6,
        spFlags: DISPFlagDefinition | DISPFlagElemental, unit: !0,
        retainedNodes: !2)
</pre></div>
</div>
<p>and this will materialize an additional DWARF attribute as:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DW_TAG_subprogram [3]
   DW_AT_low_pc [DW_FORM_addr]     (0x0000000000000010 &quot;.text&quot;)
   DW_AT_high_pc [DW_FORM_data4]   (0x00000001)
   ...
   DW_AT_elemental [DW_FORM_flag_present]  (true)
</pre></div>
</div>
<p>There are a few DWARF tags defined to represent Fortran specific constructs i.e DW_TAG_string_type for representing Fortran character(n). In LLVM this is represented as DIStringType.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="kt">character</span><span class="p">(</span><span class="nb">len</span><span class="o">=*</span><span class="p">),</span><span class="w"> </span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">string</span>
</pre></div>
</div>
<p>a Fortran front-end would generate the following descriptors:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>!DILocalVariable(name: &quot;string&quot;, arg: 1, scope: !10, file: !3, line: 4, type: !15)
!DIStringType(name: &quot;character(*)!2&quot;, stringLength: !16, stringLengthExpression: !DIExpression(), size: 32)
</pre></div>
</div>
<p>A fortran deferred-length character can also contain the information of raw storage of the characters in addition to the length of the string. This information is encoded in the  stringLocationExpression field. Based on this information, DW_AT_data_location attribute is emitted in a DW_TAG_string_type debug info.</p>
<blockquote>
<div><p>!DIStringType(name: âcharacter(*)!2â, stringLengthExpression: !DIExpression(), stringLocationExpression: !DIExpression(DW_OP_push_object_address, DW_OP_deref), size: 32)</p>
</div></blockquote>
<p>and this will materialize in DWARF tags as:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DW_TAG_string_type
             DW_AT_name      (&quot;character(*)!2&quot;)
             DW_AT_string_length     (0x00000064)
0x00000064:    DW_TAG_variable
               DW_AT_location      (DW_OP_fbreg +16)
               DW_AT_type  (0x00000083 &quot;integer*8&quot;)
               DW_AT_data_location (DW_OP_push_object_address, DW_OP_deref)
               ...
               DW_AT_artificial    (true)
</pre></div>
</div>
<p>A Fortran front-end may need to generate a <em>trampoline</em> function to call a
function defined in a different compilation unit. In this case, the front-end
can emit the following descriptor for the trampoline function:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>!DISubprogram(name: &quot;sub1_.t0p&quot;, linkageName: &quot;sub1_.t0p&quot;, scope: !4, file: !4, type: !5, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !7, retainedNodes: !24, targetFuncName: &quot;sub1_&quot;)
</pre></div>
</div>
<p>The targetFuncName field is the name of the function that the trampoline
calls. This descriptor results in the following DWARF tag:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DW_TAG_subprogram
  ...
  DW_AT_linkage_name  (&quot;sub1_.t0p&quot;)
  DW_AT_name  (&quot;sub1_.t0p&quot;)
  DW_AT_trampoline    (&quot;sub1_&quot;)
</pre></div>
</div>
</section>
</section>
<section id="id7">
<h2><a class="toc-backref" href="#id39" role="doc-backlink">Debugging information format</a><a class="headerlink" href="#id7" title="Link to this heading">Â¶</a></h2>
<section id="debugging-information-extension-for-objective-c-properties">
<h3><a class="toc-backref" href="#id40" role="doc-backlink">Debugging Information Extension for Objective C Properties</a><a class="headerlink" href="#debugging-information-extension-for-objective-c-properties" title="Link to this heading">Â¶</a></h3>
<section id="id8">
<h4><a class="toc-backref" href="#id41" role="doc-backlink">Introduction</a><a class="headerlink" href="#id8" title="Link to this heading">Â¶</a></h4>
<p>Objective C provides a simpler way to declare and define accessor methods using
declared properties.  The language provides features to declare a property and
to let compiler synthesize accessor methods.</p>
<p>The debugger lets developer inspect Objective C interfaces and their instance
variables and class variables.  However, the debugger does not know anything
about the properties defined in Objective C interfaces.  The debugger consumes
information generated by compiler in DWARF format.  The format does not support
encoding of Objective C properties.  This proposal describes DWARF extensions to
encode Objective C properties, which the debugger can use to let developers
inspect Objective C properties.</p>
</section>
<section id="proposal">
<h4><a class="toc-backref" href="#id42" role="doc-backlink">Proposal</a><a class="headerlink" href="#proposal" title="Link to this heading">Â¶</a></h4>
<p>Objective C properties exist separately from class members.  A property can be
defined only by âsetterâ and âgetterâ selectors, and be calculated anew on each
access.  Or a property can just be a direct access to some declared ivar.
Finally it can have an ivar âautomatically synthesizedâ for it by the compiler,
in which case the property can be referred to in user code directly using the
standard C dereference syntax as well as through the property âdotâ syntax, but
there is no entry in the <code class="docutils literal notranslate"><span class="pre">&#64;interface</span></code> declaration corresponding to this ivar.</p>
<p>To facilitate debugging, these properties we will add a new DWARF TAG into the
<code class="docutils literal notranslate"><span class="pre">DW_TAG_structure_type</span></code> definition for the class to hold the description of a
given property, and a set of DWARF attributes that provide said description.
The property tag will also contain the name and declared type of the property.</p>
<p>If there is a related ivar, there will also be a DWARF property attribute placed
in the <code class="docutils literal notranslate"><span class="pre">DW_TAG_member</span></code> DIE for that ivar referring back to the property TAG
for that property.  And in the case where the compiler synthesizes the ivar
directly, the compiler is expected to generate a <code class="docutils literal notranslate"><span class="pre">DW_TAG_member</span></code> for that
ivar (with the <code class="docutils literal notranslate"><span class="pre">DW_AT_artificial</span></code> set to 1), whose name will be the name used
to access this ivar directly in code, and with the property attribute pointing
back to the property it is backing.</p>
<p>The following examples will serve as illustration for our discussion:</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="nc">I1</span> <span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">n2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">@property</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p1</span><span class="p">;</span>
<span class="k">@property</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p2</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">I1</span>
<span class="k">@synthesize</span><span class="w"> </span><span class="n">p1</span><span class="p">;</span>
<span class="k">@synthesize</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n2</span><span class="p">;</span>
<span class="k">@end</span>
</pre></div>
</div>
<p>This produces the following DWARF (this is a âpseudo dwarfdumpâ output):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x00000100:  TAG_structure_type [7] *
               AT_APPLE_runtime_class( 0x10 )
               AT_name( &quot;I1&quot; )
               AT_decl_file( &quot;Objc_Property.m&quot; )
               AT_decl_line( 3 )

0x00000110    TAG_APPLE_property
                AT_name ( &quot;p1&quot; )
                AT_type ( {0x00000150} ( int ) )

0x00000120:   TAG_APPLE_property
                AT_name ( &quot;p2&quot; )
                AT_type ( {0x00000150} ( int ) )

0x00000130:   TAG_member [8]
                AT_name( &quot;_p1&quot; )
                AT_APPLE_property ( {0x00000110} &quot;p1&quot; )
                AT_type( {0x00000150} ( int ) )
                AT_artificial ( 0x1 )

0x00000140:    TAG_member [8]
                 AT_name( &quot;n2&quot; )
                 AT_APPLE_property ( {0x00000120} &quot;p2&quot; )
                 AT_type( {0x00000150} ( int ) )

0x00000150:  AT_type( ( int ) )
</pre></div>
</div>
<p>Note, the current convention is that the name of the ivar for an
auto-synthesized property is the name of the property from which it derives
with an underscore prepended, as is shown in the example.  But we actually
donât need to know this convention, since we are given the name of the ivar
directly.</p>
<p>Also, it is common practice in ObjC to have different property declarations in
the &#64;interface and &#64;implementation - e.g. to provide a read-only property in
the interface, and a read-write interface in the implementation.  In that case,
the compiler should emit whichever property declaration will be in force in the
current translation unit.</p>
<p>Developers can decorate a property with attributes which are encoded using
<code class="docutils literal notranslate"><span class="pre">DW_AT_APPLE_property_attribute</span></code>.</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="k">@property</span><span class="w"> </span><span class="p">(</span><span class="k">readonly</span><span class="p">,</span><span class="w"> </span><span class="k">nonatomic</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pr</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>TAG_APPLE_property [8]
  AT_name( &quot;pr&quot; )
  AT_type ( {0x00000147} (int) )
  AT_APPLE_property_attribute (DW_APPLE_PROPERTY_readonly, DW_APPLE_PROPERTY_nonatomic)
</pre></div>
</div>
<p>The setter and getter method names are attached to the property using
<code class="docutils literal notranslate"><span class="pre">DW_AT_APPLE_property_setter</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_AT_APPLE_property_getter</span></code> attributes.</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="nc">I1</span>
<span class="k">@property</span><span class="w"> </span><span class="p">(</span><span class="k">setter</span><span class="o">=</span><span class="n">myOwnP3Setter</span><span class="o">:</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p3</span><span class="p">;</span>
<span class="p">-(</span><span class="kt">void</span><span class="p">)</span><span class="nf">myOwnP3Setter:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">a</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">I1</span>
<span class="k">@synthesize</span><span class="w"> </span><span class="n">p3</span><span class="p">;</span>
<span class="p">-(</span><span class="kt">void</span><span class="p">)</span><span class="nf">myOwnP3Setter:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">a</span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="k">@end</span>
</pre></div>
</div>
<p>The DWARF for this would be:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x000003bd: TAG_structure_type [7] *
              AT_APPLE_runtime_class( 0x10 )
              AT_name( &quot;I1&quot; )
              AT_decl_file( &quot;Objc_Property.m&quot; )
              AT_decl_line( 3 )

0x000003cd      TAG_APPLE_property
                  AT_name ( &quot;p3&quot; )
                  AT_APPLE_property_setter ( &quot;myOwnP3Setter:&quot; )
                  AT_type( {0x00000147} ( int ) )

0x000003f3:     TAG_member [8]
                  AT_name( &quot;_p3&quot; )
                  AT_type ( {0x00000147} ( int ) )
                  AT_APPLE_property ( {0x000003cd} )
                  AT_artificial ( 0x1 )
</pre></div>
</div>
</section>
<section id="new-dwarf-tags">
<h4><a class="toc-backref" href="#id43" role="doc-backlink">New DWARF Tags</a><a class="headerlink" href="#new-dwarf-tags" title="Link to this heading">Â¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>TAG</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>DW_TAG_APPLE_property</p></td>
<td><p>0x4200</p></td>
</tr>
</tbody>
</table>
</section>
<section id="new-dwarf-attributes">
<h4><a class="toc-backref" href="#id44" role="doc-backlink">New DWARF Attributes</a><a class="headerlink" href="#new-dwarf-attributes" title="Link to this heading">Â¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Attribute</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Classes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>DW_AT_APPLE_property</p></td>
<td><p>0x3fed</p></td>
<td><p>Reference</p></td>
</tr>
<tr class="row-odd"><td><p>DW_AT_APPLE_property_getter</p></td>
<td><p>0x3fe9</p></td>
<td><p>String</p></td>
</tr>
<tr class="row-even"><td><p>DW_AT_APPLE_property_setter</p></td>
<td><p>0x3fea</p></td>
<td><p>String</p></td>
</tr>
<tr class="row-odd"><td><p>DW_AT_APPLE_property_attribute</p></td>
<td><p>0x3feb</p></td>
<td><p>Constant</p></td>
</tr>
</tbody>
</table>
</section>
<section id="new-dwarf-constants">
<h4><a class="toc-backref" href="#id45" role="doc-backlink">New DWARF Constants</a><a class="headerlink" href="#new-dwarf-constants" title="Link to this heading">Â¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>DW_APPLE_PROPERTY_readonly</p></td>
<td><p>0x01</p></td>
</tr>
<tr class="row-odd"><td><p>DW_APPLE_PROPERTY_getter</p></td>
<td><p>0x02</p></td>
</tr>
<tr class="row-even"><td><p>DW_APPLE_PROPERTY_assign</p></td>
<td><p>0x04</p></td>
</tr>
<tr class="row-odd"><td><p>DW_APPLE_PROPERTY_readwrite</p></td>
<td><p>0x08</p></td>
</tr>
<tr class="row-even"><td><p>DW_APPLE_PROPERTY_retain</p></td>
<td><p>0x10</p></td>
</tr>
<tr class="row-odd"><td><p>DW_APPLE_PROPERTY_copy</p></td>
<td><p>0x20</p></td>
</tr>
<tr class="row-even"><td><p>DW_APPLE_PROPERTY_nonatomic</p></td>
<td><p>0x40</p></td>
</tr>
<tr class="row-odd"><td><p>DW_APPLE_PROPERTY_setter</p></td>
<td><p>0x80</p></td>
</tr>
<tr class="row-even"><td><p>DW_APPLE_PROPERTY_atomic</p></td>
<td><p>0x100</p></td>
</tr>
<tr class="row-odd"><td><p>DW_APPLE_PROPERTY_weak</p></td>
<td><p>0x200</p></td>
</tr>
<tr class="row-even"><td><p>DW_APPLE_PROPERTY_strong</p></td>
<td><p>0x400</p></td>
</tr>
<tr class="row-odd"><td><p>DW_APPLE_PROPERTY_unsafe_unretained</p></td>
<td><p>0x800</p></td>
</tr>
<tr class="row-even"><td><p>DW_APPLE_PROPERTY_nullability</p></td>
<td><p>0x1000</p></td>
</tr>
<tr class="row-odd"><td><p>DW_APPLE_PROPERTY_null_resettable</p></td>
<td><p>0x2000</p></td>
</tr>
<tr class="row-even"><td><p>DW_APPLE_PROPERTY_class</p></td>
<td><p>0x4000</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="name-accelerator-tables">
<h3><a class="toc-backref" href="#id46" role="doc-backlink">Name Accelerator Tables</a><a class="headerlink" href="#name-accelerator-tables" title="Link to this heading">Â¶</a></h3>
<section id="id9">
<h4><a class="toc-backref" href="#id47" role="doc-backlink">Introduction</a><a class="headerlink" href="#id9" title="Link to this heading">Â¶</a></h4>
<p>The â<code class="docutils literal notranslate"><span class="pre">.debug_pubnames</span></code>â and â<code class="docutils literal notranslate"><span class="pre">.debug_pubtypes</span></code>â formats are not what a
debugger needs.  The â<code class="docutils literal notranslate"><span class="pre">pub</span></code>â in the section name indicates that the entries
in the table are publicly visible names only.  This means no static or hidden
functions show up in the â<code class="docutils literal notranslate"><span class="pre">.debug_pubnames</span></code>â.  No static variables or private
class variables are in the â<code class="docutils literal notranslate"><span class="pre">.debug_pubtypes</span></code>â.  Many compilers add different
things to these tables, so we canât rely upon the contents between gcc, icc, or
clang.</p>
<p>The typical query given by users tends not to match up with the contents of
these tables.  For example, the DWARF spec states that âIn the case of the name
of a function member or static data member of a C++ structure, class or union,
the name presented in the â<code class="docutils literal notranslate"><span class="pre">.debug_pubnames</span></code>â section is not the simple name
given by the <code class="docutils literal notranslate"><span class="pre">DW_AT_name</span> <span class="pre">attribute</span></code> of the referenced debugging information
entry, but rather the fully qualified name of the data or function member.â
So the only names in these tables for complex C++ entries is a fully
qualified name.  Debugger users tend not to enter their search strings as
â<code class="docutils literal notranslate"><span class="pre">a::b::c(int,const</span> <span class="pre">Foo&amp;)</span> <span class="pre">const</span></code>â, but rather as â<code class="docutils literal notranslate"><span class="pre">c</span></code>â, â<code class="docutils literal notranslate"><span class="pre">b::c</span></code>â , or
â<code class="docutils literal notranslate"><span class="pre">a::b::c</span></code>â.  So the name entered in the name table must be demangled in
order to chop it up appropriately and additional names must be manually entered
into the table to make it effective as a name lookup table for debuggers to
use.</p>
<p>All debuggers currently ignore the â<code class="docutils literal notranslate"><span class="pre">.debug_pubnames</span></code>â table as a result of
its inconsistent and useless public-only name content making it a waste of
space in the object file.  These tables, when they are written to disk, are not
sorted in any way, leaving every debugger to do its own parsing and sorting.
These tables also include an inlined copy of the string values in the table
itself making the tables much larger than they need to be on disk, especially
for large C++ programs.</p>
<p>Canât we just fix the sections by adding all of the names we need to this
table? No, because that is not what the tables are defined to contain and we
wonât know the difference between the old bad tables and the new good tables.
At best we could make our own renamed sections that contain all of the data we
need.</p>
<p>These tables are also insufficient for what a debugger like LLDB needs.  LLDB
uses clang for its expression parsing where LLDB acts as a PCH.  LLDB is then
often asked to look for type â<code class="docutils literal notranslate"><span class="pre">foo</span></code>â or namespace â<code class="docutils literal notranslate"><span class="pre">bar</span></code>â, or list items in
namespace â<code class="docutils literal notranslate"><span class="pre">baz</span></code>â.  Namespaces are not included in the pubnames or pubtypes
tables.  Since clang asks a lot of questions when it is parsing an expression,
we need to be very fast when looking up names, as it happens a lot.  Having new
accelerator tables that are optimized for very quick lookups will benefit this
type of debugging experience greatly.</p>
<p>We would like to generate name lookup tables that can be mapped into memory
from disk, and used as is, with little or no up-front parsing.  We would also
be able to control the exact content of these different tables so they contain
exactly what we need.  The Name Accelerator Tables were designed to fix these
issues.  In order to solve these issues we need to:</p>
<ul class="simple">
<li><p>Have a format that can be mapped into memory from disk and used as is</p></li>
<li><p>Lookups should be very fast</p></li>
<li><p>Extensible table format so these tables can be made by many producers</p></li>
<li><p>Contain all of the names needed for typical lookups out of the box</p></li>
<li><p>Strict rules for the contents of tables</p></li>
</ul>
<p>Table size is important and the accelerator table format should allow the reuse
of strings from common string tables so the strings for the names are not
duplicated.  We also want to make sure the table is ready to be used as-is by
simply mapping the table into memory with minimal header parsing.</p>
<p>The name lookups need to be fast and optimized for the kinds of lookups that
debuggers tend to do.  Optimally we would like to touch as few parts of the
mapped table as possible when doing a name lookup and be able to quickly find
the name entry we are looking for, or discover there are no matches.  In the
case of debuggers we optimized for lookups that fail most of the time.</p>
<p>Each table that is defined should have strict rules on exactly what is in the
accelerator tables and documented so clients can rely on the content.</p>
</section>
<section id="hash-tables">
<h4><a class="toc-backref" href="#id48" role="doc-backlink">Hash Tables</a><a class="headerlink" href="#hash-tables" title="Link to this heading">Â¶</a></h4>
<section id="standard-hash-tables">
<h5><a class="toc-backref" href="#id49" role="doc-backlink">Standard Hash Tables</a><a class="headerlink" href="#standard-hash-tables" title="Link to this heading">Â¶</a></h5>
<p>Typical hash tables have a header, buckets, and each bucket points to the
bucket contents:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.------------.
|  HEADER    |
|------------|
|  BUCKETS   |
|------------|
|  DATA      |
`------------&#39;
</pre></div>
</div>
<p>The BUCKETS are an array of offsets to DATA for each hash:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.------------.
| 0x00001000 | BUCKETS[0]
| 0x00002000 | BUCKETS[1]
| 0x00002200 | BUCKETS[2]
| 0x000034f0 | BUCKETS[3]
|            | ...
| 0xXXXXXXXX | BUCKETS[n_buckets]
&#39;------------&#39;
</pre></div>
</div>
<p>So for <code class="docutils literal notranslate"><span class="pre">bucket[3]</span></code> in the example above, we have an offset into the table
0x000034f0 which points to a chain of entries for the bucket.  Each bucket must
contain a next pointer, full 32 bit hash value, the string itself, and the data
for the current string value.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>            .------------.
0x000034f0: | 0x00003500 | next pointer
            | 0x12345678 | 32 bit hash
            | &quot;erase&quot;    | string value
            | data[n]    | HashData for this bucket
            |------------|
0x00003500: | 0x00003550 | next pointer
            | 0x29273623 | 32 bit hash
            | &quot;dump&quot;     | string value
            | data[n]    | HashData for this bucket
            |------------|
0x00003550: | 0x00000000 | next pointer
            | 0x82638293 | 32 bit hash
            | &quot;main&quot;     | string value
            | data[n]    | HashData for this bucket
            `------------&#39;
</pre></div>
</div>
<p>The problem with this layout for debuggers is that we need to optimize for the
negative lookup case where the symbol weâre searching for is not present.  So
if we were to lookup â<code class="docutils literal notranslate"><span class="pre">printf</span></code>â in the table above, we would make a 32-bit
hash for â<code class="docutils literal notranslate"><span class="pre">printf</span></code>â, it might match <code class="docutils literal notranslate"><span class="pre">bucket[3]</span></code>.  We would need to go to
the offset 0x000034f0 and start looking to see if our 32 bit hash matches.  To
do so, we need to read the next pointer, then read the hash, compare it, and
skip to the next bucket.  Each time we are skipping many bytes in memory and
touching new pages just to do the compare on the full 32 bit hash.  All of
these accesses then tell us that we didnât have a match.</p>
</section>
<section id="name-hash-tables">
<h5><a class="toc-backref" href="#id50" role="doc-backlink">Name Hash Tables</a><a class="headerlink" href="#name-hash-tables" title="Link to this heading">Â¶</a></h5>
<p>To solve the issues mentioned above we have structured the hash tables a bit
differently: a header, buckets, an array of all unique 32 bit hash values,
followed by an array of hash value data offsets, one for each hash value, then
the data for all hash values:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.-------------.
|  HEADER     |
|-------------|
|  BUCKETS    |
|-------------|
|  HASHES     |
|-------------|
|  OFFSETS    |
|-------------|
|  DATA       |
`-------------&#39;
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">BUCKETS</span></code> in the name tables are an index into the <code class="docutils literal notranslate"><span class="pre">HASHES</span></code> array.  By
making all of the full 32 bit hash values contiguous in memory, we allow
ourselves to efficiently check for a match while touching as little memory as
possible.  Most often checking the 32 bit hash values is as far as the lookup
goes.  If it does match, it usually is a match with no collisions.  So for a
table with â<code class="docutils literal notranslate"><span class="pre">n_buckets</span></code>â buckets, and â<code class="docutils literal notranslate"><span class="pre">n_hashes</span></code>â unique 32 bit hash
values, we can clarify the contents of the <code class="docutils literal notranslate"><span class="pre">BUCKETS</span></code>, <code class="docutils literal notranslate"><span class="pre">HASHES</span></code> and
<code class="docutils literal notranslate"><span class="pre">OFFSETS</span></code> as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.-------------------------.
|  HEADER.magic           | uint32_t
|  HEADER.version         | uint16_t
|  HEADER.hash_function   | uint16_t
|  HEADER.bucket_count    | uint32_t
|  HEADER.hashes_count    | uint32_t
|  HEADER.header_data_len | uint32_t
|  HEADER_DATA            | HeaderData
|-------------------------|
|  BUCKETS                | uint32_t[n_buckets] // 32 bit hash indexes
|-------------------------|
|  HASHES                 | uint32_t[n_hashes] // 32 bit hash values
|-------------------------|
|  OFFSETS                | uint32_t[n_hashes] // 32 bit offsets to hash value data
|-------------------------|
|  ALL HASH DATA          |
`-------------------------&#39;
</pre></div>
</div>
<p>So taking the exact same data from the standard hash example above we end up
with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>            .------------.
            | HEADER     |
            |------------|
            |          0 | BUCKETS[0]
            |          2 | BUCKETS[1]
            |          5 | BUCKETS[2]
            |          6 | BUCKETS[3]
            |            | ...
            |        ... | BUCKETS[n_buckets]
            |------------|
            | 0x........ | HASHES[0]
            | 0x........ | HASHES[1]
            | 0x........ | HASHES[2]
            | 0x........ | HASHES[3]
            | 0x........ | HASHES[4]
            | 0x........ | HASHES[5]
            | 0x12345678 | HASHES[6]    hash for BUCKETS[3]
            | 0x29273623 | HASHES[7]    hash for BUCKETS[3]
            | 0x82638293 | HASHES[8]    hash for BUCKETS[3]
            | 0x........ | HASHES[9]
            | 0x........ | HASHES[10]
            | 0x........ | HASHES[11]
            | 0x........ | HASHES[12]
            | 0x........ | HASHES[13]
            | 0x........ | HASHES[n_hashes]
            |------------|
            | 0x........ | OFFSETS[0]
            | 0x........ | OFFSETS[1]
            | 0x........ | OFFSETS[2]
            | 0x........ | OFFSETS[3]
            | 0x........ | OFFSETS[4]
            | 0x........ | OFFSETS[5]
            | 0x000034f0 | OFFSETS[6]   offset for BUCKETS[3]
            | 0x00003500 | OFFSETS[7]   offset for BUCKETS[3]
            | 0x00003550 | OFFSETS[8]   offset for BUCKETS[3]
            | 0x........ | OFFSETS[9]
            | 0x........ | OFFSETS[10]
            | 0x........ | OFFSETS[11]
            | 0x........ | OFFSETS[12]
            | 0x........ | OFFSETS[13]
            | 0x........ | OFFSETS[n_hashes]
            |------------|
            |            |
            |            |
            |            |
            |            |
            |            |
            |------------|
0x000034f0: | 0x00001203 | .debug_str (&quot;erase&quot;)
            | 0x00000004 | A 32 bit array count - number of HashData with name &quot;erase&quot;
            | 0x........ | HashData[0]
            | 0x........ | HashData[1]
            | 0x........ | HashData[2]
            | 0x........ | HashData[3]
            | 0x00000000 | String offset into .debug_str (terminate data for hash)
            |------------|
0x00003500: | 0x00001203 | String offset into .debug_str (&quot;collision&quot;)
            | 0x00000002 | A 32 bit array count - number of HashData with name &quot;collision&quot;
            | 0x........ | HashData[0]
            | 0x........ | HashData[1]
            | 0x00001203 | String offset into .debug_str (&quot;dump&quot;)
            | 0x00000003 | A 32 bit array count - number of HashData with name &quot;dump&quot;
            | 0x........ | HashData[0]
            | 0x........ | HashData[1]
            | 0x........ | HashData[2]
            | 0x00000000 | String offset into .debug_str (terminate data for hash)
            |------------|
0x00003550: | 0x00001203 | String offset into .debug_str (&quot;main&quot;)
            | 0x00000009 | A 32 bit array count - number of HashData with name &quot;main&quot;
            | 0x........ | HashData[0]
            | 0x........ | HashData[1]
            | 0x........ | HashData[2]
            | 0x........ | HashData[3]
            | 0x........ | HashData[4]
            | 0x........ | HashData[5]
            | 0x........ | HashData[6]
            | 0x........ | HashData[7]
            | 0x........ | HashData[8]
            | 0x00000000 | String offset into .debug_str (terminate data for hash)
            `------------&#39;
</pre></div>
</div>
<p>So we still have all of the same data, we just organize it more efficiently for
debugger lookup.  If we repeat the same â<code class="docutils literal notranslate"><span class="pre">printf</span></code>â lookup from above, we
would hash â<code class="docutils literal notranslate"><span class="pre">printf</span></code>â and find it matches <code class="docutils literal notranslate"><span class="pre">BUCKETS[3]</span></code> by taking the 32 bit
hash value and modulo it by <code class="docutils literal notranslate"><span class="pre">n_buckets</span></code>.  <code class="docutils literal notranslate"><span class="pre">BUCKETS[3]</span></code> contains â6â which
is the index into the <code class="docutils literal notranslate"><span class="pre">HASHES</span></code> table.  We would then compare any consecutive
32 bit hashes values in the <code class="docutils literal notranslate"><span class="pre">HASHES</span></code> array as long as the hashes would be in
<code class="docutils literal notranslate"><span class="pre">BUCKETS[3]</span></code>.  We do this by verifying that each subsequent hash value modulo
<code class="docutils literal notranslate"><span class="pre">n_buckets</span></code> is still 3.  In the case of a failed lookup we would access the
memory for <code class="docutils literal notranslate"><span class="pre">BUCKETS[3]</span></code>, and then compare a few consecutive 32 bit hashes
before we know that we have no match.  We donât end up marching through
multiple words of memory and we really keep the number of processor data cache
lines being accessed as small as possible.</p>
<p>The string hash that is used for these lookup tables is the Daniel J.
Bernstein hash which is also used in the ELF <code class="docutils literal notranslate"><span class="pre">GNU_HASH</span></code> sections.  It is a
very good hash for all kinds of names in programs with very few hash
collisions.</p>
<p>Empty buckets are designated by using an invalid hash index of <code class="docutils literal notranslate"><span class="pre">UINT32_MAX</span></code>.</p>
</section>
</section>
<section id="details">
<h4><a class="toc-backref" href="#id51" role="doc-backlink">Details</a><a class="headerlink" href="#details" title="Link to this heading">Â¶</a></h4>
<p>These name hash tables are designed to be generic where specializations of the
table get to define additional data that goes into the header (â<code class="docutils literal notranslate"><span class="pre">HeaderData</span></code>â),
how the string value is stored (â<code class="docutils literal notranslate"><span class="pre">KeyType</span></code>â) and the content of the data for each
hash value.</p>
<section id="header-layout">
<h5><a class="toc-backref" href="#id52" role="doc-backlink">Header Layout</a><a class="headerlink" href="#header-layout" title="Link to this heading">Â¶</a></h5>
<p>The header has a fixed part, and the specialized part.  The exact format of the
header is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Header</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w">   </span><span class="n">magic</span><span class="p">;</span><span class="w">           </span><span class="c1">// &#39;HASH&#39; magic value to allow endian detection</span>
<span class="w">  </span><span class="kt">uint16_t</span><span class="w">   </span><span class="n">version</span><span class="p">;</span><span class="w">         </span><span class="c1">// Version number</span>
<span class="w">  </span><span class="kt">uint16_t</span><span class="w">   </span><span class="n">hash_function</span><span class="p">;</span><span class="w">   </span><span class="c1">// The hash function enumeration that was used</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w">   </span><span class="n">bucket_count</span><span class="p">;</span><span class="w">    </span><span class="c1">// The number of buckets in this hash table</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w">   </span><span class="n">hashes_count</span><span class="p">;</span><span class="w">    </span><span class="c1">// The total number of unique hash values and hash data offsets in this table</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w">   </span><span class="n">header_data_len</span><span class="p">;</span><span class="w"> </span><span class="c1">// The bytes to skip to get to the hash indexes (buckets) for correct alignment</span>
<span class="w">                              </span><span class="c1">// Specifically the length of the following HeaderData field - this does not</span>
<span class="w">                              </span><span class="c1">// include the size of the preceding fields</span>
<span class="w">  </span><span class="n">HeaderData</span><span class="w"> </span><span class="n">header_data</span><span class="p">;</span><span class="w">     </span><span class="c1">// Implementation specific header data</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The header starts with a 32 bit â<code class="docutils literal notranslate"><span class="pre">magic</span></code>â value which must be <code class="docutils literal notranslate"><span class="pre">'HASH'</span></code>
encoded as an ASCII integer.  This allows the detection of the start of the
hash table and also allows the tableâs byte order to be determined so the table
can be correctly extracted.  The â<code class="docutils literal notranslate"><span class="pre">magic</span></code>â value is followed by a 16 bit
<code class="docutils literal notranslate"><span class="pre">version</span></code> number which allows the table to be revised and modified in the
future.  The current version number is 1. <code class="docutils literal notranslate"><span class="pre">hash_function</span></code> is a <code class="docutils literal notranslate"><span class="pre">uint16_t</span></code>
enumeration that specifies which hash function was used to produce this table.
The current values for the hash function enumerations include:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="n">HashFunctionType</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">eHashFunctionDJB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0u</span><span class="p">,</span><span class="w"> </span><span class="c1">// Daniel J Bernstein hash function</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">bucket_count</span></code> is a 32 bit unsigned integer that represents how many buckets
are in the <code class="docutils literal notranslate"><span class="pre">BUCKETS</span></code> array.  <code class="docutils literal notranslate"><span class="pre">hashes_count</span></code> is the number of unique 32 bit
hash values that are in the <code class="docutils literal notranslate"><span class="pre">HASHES</span></code> array, and is the same number of offsets
are contained in the <code class="docutils literal notranslate"><span class="pre">OFFSETS</span></code> array.  <code class="docutils literal notranslate"><span class="pre">header_data_len</span></code> specifies the size
in bytes of the <code class="docutils literal notranslate"><span class="pre">HeaderData</span></code> that is filled in by specialized versions of
this table.</p>
</section>
<section id="fixed-lookup">
<h5><a class="toc-backref" href="#id53" role="doc-backlink">Fixed Lookup</a><a class="headerlink" href="#fixed-lookup" title="Link to this heading">Â¶</a></h5>
<p>The header is followed by the buckets, hashes, offsets, and hash value data.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">FixedTable</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">buckets</span><span class="p">[</span><span class="n">Header</span><span class="p">.</span><span class="n">bucket_count</span><span class="p">];</span><span class="w">  </span><span class="c1">// An array of hash indexes into the &quot;hashes[]&quot; array below</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">hashes</span><span class="w"> </span><span class="p">[</span><span class="n">Header</span><span class="p">.</span><span class="n">hashes_count</span><span class="p">];</span><span class="w">  </span><span class="c1">// Every unique 32 bit hash for the entire table is in this table</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">offsets</span><span class="p">[</span><span class="n">Header</span><span class="p">.</span><span class="n">hashes_count</span><span class="p">];</span><span class="w">  </span><span class="c1">// An offset that corresponds to each item in the &quot;hashes[]&quot; array above</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">buckets</span></code> is an array of 32 bit indexes into the <code class="docutils literal notranslate"><span class="pre">hashes</span></code> array.  The
<code class="docutils literal notranslate"><span class="pre">hashes</span></code> array contains all of the 32 bit hash values for all names in the
hash table.  Each hash in the <code class="docutils literal notranslate"><span class="pre">hashes</span></code> table has an offset in the <code class="docutils literal notranslate"><span class="pre">offsets</span></code>
array that points to the data for the hash value.</p>
<p>This table setup makes it very easy to repurpose these tables to contain
different data, while keeping the lookup mechanism the same for all tables.
This layout also makes it possible to save the table to disk and map it in
later and do very efficient name lookups with little or no parsing.</p>
<p>DWARF lookup tables can be implemented in a variety of ways and can store a lot
of information for each name.  We want to make the DWARF tables extensible and
able to store the data efficiently so we have used some of the DWARF features
that enable efficient data storage to define exactly what kind of data we store
for each name.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">HeaderData</span></code> contains a definition of the contents of each HashData chunk.
We might want to store an offset to all of the debug information entries (DIEs)
for each name.  To keep things extensible, we create a list of items, or
Atoms, that are contained in the data for each name.  First comes the type of
the data in each atom:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="n">AtomType</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">eAtomTypeNULL</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="mi">0u</span><span class="p">,</span>
<span class="w">  </span><span class="n">eAtomTypeDIEOffset</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">1u</span><span class="p">,</span><span class="w">   </span><span class="c1">// DIE offset, check form for encoding</span>
<span class="w">  </span><span class="n">eAtomTypeCUOffset</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mi">2u</span><span class="p">,</span><span class="w">   </span><span class="c1">// DIE offset of the compiler unit header that contains the item in question</span>
<span class="w">  </span><span class="n">eAtomTypeTag</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="mi">3u</span><span class="p">,</span><span class="w">   </span><span class="c1">// DW_TAG_xxx value, should be encoded as DW_FORM_data1 (if no tags exceed 255) or DW_FORM_data2</span>
<span class="w">  </span><span class="n">eAtomTypeNameFlags</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">4u</span><span class="p">,</span><span class="w">   </span><span class="c1">// Flags from enum NameFlags</span>
<span class="w">  </span><span class="n">eAtomTypeTypeFlags</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">5u</span><span class="p">,</span><span class="w">   </span><span class="c1">// Flags from enum TypeFlags</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The enumeration values and their meanings are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>eAtomTypeNULL       - a termination atom that specifies the end of the atom list
eAtomTypeDIEOffset  - an offset into the .debug_info section for the DWARF DIE for this name
eAtomTypeCUOffset   - an offset into the .debug_info section for the CU that contains the DIE
eAtomTypeDIETag     - The DW_TAG_XXX enumeration value so you don&#39;t have to parse the DWARF to see what it is
eAtomTypeNameFlags  - Flags for functions and global variables (isFunction, isInlined, isExternal...)
eAtomTypeTypeFlags  - Flags for types (isCXXClass, isObjCClass, ...)
</pre></div>
</div>
<p>Then we allow each atom type to define the atom type and how the data for each
atom type data is encoded:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Atom</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">type</span><span class="p">;</span><span class="w">  </span><span class="c1">// AtomType enum value</span>
<span class="w">  </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">form</span><span class="p">;</span><span class="w">  </span><span class="c1">// DWARF DW_FORM_XXX defines</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">form</span></code> type above is from the DWARF specification and defines the exact
encoding of the data for the Atom type.  See the DWARF specification for the
<code class="docutils literal notranslate"><span class="pre">DW_FORM_</span></code> definitions.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">HeaderData</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">die_offset_base</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">atom_count</span><span class="p">;</span>
<span class="w">  </span><span class="n">Atoms</span><span class="w">    </span><span class="n">atoms</span><span class="p">[</span><span class="n">atom_count0</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">HeaderData</span></code> defines the base DIE offset that should be added to any atoms
that are encoded using the <code class="docutils literal notranslate"><span class="pre">DW_FORM_ref1</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_FORM_ref2</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_FORM_ref4</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_FORM_ref8</span></code> or <code class="docutils literal notranslate"><span class="pre">DW_FORM_ref_udata</span></code>.  It also defines
what is contained in each <code class="docutils literal notranslate"><span class="pre">HashData</span></code> object â <code class="docutils literal notranslate"><span class="pre">Atom.form</span></code> tells us how large
each field will be in the <code class="docutils literal notranslate"><span class="pre">HashData</span></code> and the <code class="docutils literal notranslate"><span class="pre">Atom.type</span></code> tells us how this data
should be interpreted.</p>
<p>For the current implementations of the â<code class="docutils literal notranslate"><span class="pre">.apple_names</span></code>â (all functions +
globals), the â<code class="docutils literal notranslate"><span class="pre">.apple_types</span></code>â (names of all types that are defined), and
the â<code class="docutils literal notranslate"><span class="pre">.apple_namespaces</span></code>â (all namespaces), we currently set the <code class="docutils literal notranslate"><span class="pre">Atom</span></code>
array to be:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">HeaderData</span><span class="p">.</span><span class="n">atom_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">HeaderData</span><span class="p">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eAtomTypeDIEOffset</span><span class="p">;</span>
<span class="n">HeaderData</span><span class="p">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">form</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DW_FORM_data4</span><span class="p">;</span>
</pre></div>
</div>
<p>This defines the contents to be the DIE offset (eAtomTypeDIEOffset) that is
encoded as a 32 bit value (DW_FORM_data4).  This allows a single name to have
multiple matching DIEs in a single file, which could come up with an inlined
function for instance.  Future tables could include more information about the
DIE such as flags indicating if the DIE is a function, method, block,
or inlined.</p>
<p>The KeyType for the DWARF table is a 32 bit string table offset into the
â.debug_strâ table.  The â.debug_strâ is the string table for the DWARF which
may already contain copies of all of the strings.  This helps make sure, with
help from the compiler, that we reuse the strings between all of the DWARF
sections and keeps the hash table size down.  Another benefit to having the
compiler generate all strings as DW_FORM_strp in the debug info, is that
DWARF parsing can be made much faster.</p>
<p>After a lookup is made, we get an offset into the hash data.  The hash data
needs to be able to deal with 32 bit hash collisions, so the chunk of data
at the offset in the hash data consists of a triple:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">str_offset</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">hash_data_count</span>
<span class="n">HashData</span><span class="p">[</span><span class="n">hash_data_count</span><span class="p">]</span>
</pre></div>
</div>
<p>If âstr_offsetâ is zero, then the bucket contents are done. 99.9% of the
hash data chunks contain a single item (no 32 bit hash collision):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.------------.
| 0x00001023 | uint32_t KeyType (.debug_str[0x0001023] =&gt; &quot;main&quot;)
| 0x00000004 | uint32_t HashData count
| 0x........ | uint32_t HashData[0] DIE offset
| 0x........ | uint32_t HashData[1] DIE offset
| 0x........ | uint32_t HashData[2] DIE offset
| 0x........ | uint32_t HashData[3] DIE offset
| 0x00000000 | uint32_t KeyType (end of hash chain)
`------------&#39;
</pre></div>
</div>
<p>If there are collisions, you will have multiple valid string offsets:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.------------.
| 0x00001023 | uint32_t KeyType (.debug_str[0x0001023] =&gt; &quot;main&quot;)
| 0x00000004 | uint32_t HashData count
| 0x........ | uint32_t HashData[0] DIE offset
| 0x........ | uint32_t HashData[1] DIE offset
| 0x........ | uint32_t HashData[2] DIE offset
| 0x........ | uint32_t HashData[3] DIE offset
| 0x00002023 | uint32_t KeyType (.debug_str[0x0002023] =&gt; &quot;print&quot;)
| 0x00000002 | uint32_t HashData count
| 0x........ | uint32_t HashData[0] DIE offset
| 0x........ | uint32_t HashData[1] DIE offset
| 0x00000000 | uint32_t KeyType (end of hash chain)
`------------&#39;
</pre></div>
</div>
<p>Current testing with real world C++ binaries has shown that there is around 1
32 bit hash collision per 100,000 name entries.</p>
</section>
</section>
<section id="id10">
<h4><a class="toc-backref" href="#id54" role="doc-backlink">Contents</a><a class="headerlink" href="#id10" title="Link to this heading">Â¶</a></h4>
<p>As we said, we want to strictly define exactly what is included in the
different tables.  For DWARF, we have 3 tables: â<code class="docutils literal notranslate"><span class="pre">.apple_names</span></code>â,
â<code class="docutils literal notranslate"><span class="pre">.apple_types</span></code>â, and â<code class="docutils literal notranslate"><span class="pre">.apple_namespaces</span></code>â.</p>
<p>â<code class="docutils literal notranslate"><span class="pre">.apple_names</span></code>â sections should contain an entry for each DWARF DIE whose
<code class="docutils literal notranslate"><span class="pre">DW_TAG</span></code> is a <code class="docutils literal notranslate"><span class="pre">DW_TAG_label</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_TAG_inlined_subroutine</span></code>, or
<code class="docutils literal notranslate"><span class="pre">DW_TAG_subprogram</span></code> that has address attributes: <code class="docutils literal notranslate"><span class="pre">DW_AT_low_pc</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_AT_high_pc</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_AT_ranges</span></code> or <code class="docutils literal notranslate"><span class="pre">DW_AT_entry_pc</span></code>.  It also contains
<code class="docutils literal notranslate"><span class="pre">DW_TAG_variable</span></code> DIEs that have a <code class="docutils literal notranslate"><span class="pre">DW_OP_addr</span></code> in the location (global and
static variables).  All global and static variables should be included,
including those scoped within functions and classes.  For example using the
following code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="w"> </span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Both of the static <code class="docutils literal notranslate"><span class="pre">var</span></code> variables would be included in the table.  All
functions should emit both their full names and their basenames.  For C or C++,
the full name is the mangled name (if available) which is usually in the
<code class="docutils literal notranslate"><span class="pre">DW_AT_MIPS_linkage_name</span></code> attribute, and the <code class="docutils literal notranslate"><span class="pre">DW_AT_name</span></code> contains the
function basename.  If global or static variables have a mangled name in a
<code class="docutils literal notranslate"><span class="pre">DW_AT_MIPS_linkage_name</span></code> attribute, this should be emitted along with the
simple name found in the <code class="docutils literal notranslate"><span class="pre">DW_AT_name</span></code> attribute.</p>
<p>â<code class="docutils literal notranslate"><span class="pre">.apple_types</span></code>â sections should contain an entry for each DWARF DIE whose
tag is one of:</p>
<ul class="simple">
<li><p>DW_TAG_array_type</p></li>
<li><p>DW_TAG_class_type</p></li>
<li><p>DW_TAG_enumeration_type</p></li>
<li><p>DW_TAG_pointer_type</p></li>
<li><p>DW_TAG_reference_type</p></li>
<li><p>DW_TAG_string_type</p></li>
<li><p>DW_TAG_structure_type</p></li>
<li><p>DW_TAG_subroutine_type</p></li>
<li><p>DW_TAG_typedef</p></li>
<li><p>DW_TAG_union_type</p></li>
<li><p>DW_TAG_ptr_to_member_type</p></li>
<li><p>DW_TAG_set_type</p></li>
<li><p>DW_TAG_subrange_type</p></li>
<li><p>DW_TAG_base_type</p></li>
<li><p>DW_TAG_const_type</p></li>
<li><p>DW_TAG_immutable_type</p></li>
<li><p>DW_TAG_file_type</p></li>
<li><p>DW_TAG_namelist</p></li>
<li><p>DW_TAG_packed_type</p></li>
<li><p>DW_TAG_volatile_type</p></li>
<li><p>DW_TAG_restrict_type</p></li>
<li><p>DW_TAG_atomic_type</p></li>
<li><p>DW_TAG_interface_type</p></li>
<li><p>DW_TAG_unspecified_type</p></li>
<li><p>DW_TAG_shared_type</p></li>
</ul>
<p>Only entries with a <code class="docutils literal notranslate"><span class="pre">DW_AT_name</span></code> attribute are included, and the entry must
not be a forward declaration (<code class="docutils literal notranslate"><span class="pre">DW_AT_declaration</span></code> attribute with a non-zero
value).  For example, using the following code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We get a few type DIEs:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x00000067:     TAG_base_type [5]
                AT_encoding( DW_ATE_signed )
                AT_name( &quot;int&quot; )
                AT_byte_size( 0x04 )

0x0000006e:     TAG_pointer_type [6]
                AT_type( {0x00000067} ( int ) )
                AT_byte_size( 0x08 )
</pre></div>
</div>
<p>The DW_TAG_pointer_type is not included because it does not have a <code class="docutils literal notranslate"><span class="pre">DW_AT_name</span></code>.</p>
<p>â<code class="docutils literal notranslate"><span class="pre">.apple_namespaces</span></code>â section should contain all <code class="docutils literal notranslate"><span class="pre">DW_TAG_namespace</span></code> DIEs.
If we run into a namespace that has no name this is an anonymous namespace, and
the name should be output as â<code class="docutils literal notranslate"><span class="pre">(anonymous</span> <span class="pre">namespace)</span></code>â (without the quotes).
Why?  This matches the output of the <code class="docutils literal notranslate"><span class="pre">abi::cxa_demangle()</span></code> that is in the
standard C++ library that demangles mangled names.</p>
</section>
<section id="language-extensions-and-file-format-changes">
<h4><a class="toc-backref" href="#id55" role="doc-backlink">Language Extensions and File Format Changes</a><a class="headerlink" href="#language-extensions-and-file-format-changes" title="Link to this heading">Â¶</a></h4>
<section id="objective-c-extensions">
<h5><a class="toc-backref" href="#id56" role="doc-backlink">Objective-C Extensions</a><a class="headerlink" href="#objective-c-extensions" title="Link to this heading">Â¶</a></h5>
<p>â<code class="docutils literal notranslate"><span class="pre">.apple_objc</span></code>â section should contain all <code class="docutils literal notranslate"><span class="pre">DW_TAG_subprogram</span></code> DIEs for an
Objective-C class.  The name used in the hash table is the name of the
Objective-C class itself.  If the Objective-C class has a category, then an
entry is made for both the class name without the category, and for the class
name with the category.  So if we have a DIE at offset 0x1234 with a name of
method â<code class="docutils literal notranslate"><span class="pre">-[NSString(my_additions)</span> <span class="pre">stringWithSpecialString:]</span></code>â, we would add
an entry for â<code class="docutils literal notranslate"><span class="pre">NSString</span></code>â that points to DIE 0x1234, and an entry for
â<code class="docutils literal notranslate"><span class="pre">NSString(my_additions)</span></code>â that points to 0x1234.  This allows us to quickly
track down all Objective-C methods for an Objective-C class when doing
expressions.  It is needed because of the dynamic nature of Objective-C where
anyone can add methods to a class.  The DWARF for Objective-C methods is also
emitted differently from C++ classes where the methods are not usually
contained in the class definition, they are scattered about across one or more
compile units.  Categories can also be defined in different shared libraries.
So we need to be able to quickly find all of the methods and class functions
given the Objective-C class name, or quickly find all methods and class
functions for a class + category name.  This table does not contain any
selector names, it just maps Objective-C class names (or class names +
category) to all of the methods and class functions.  The selectors are added
as function basenames in the â<code class="docutils literal notranslate"><span class="pre">.debug_names</span></code>â section.</p>
<p>In the â<code class="docutils literal notranslate"><span class="pre">.apple_names</span></code>â section for Objective-C functions, the full name is
the entire function name with the brackets (â<code class="docutils literal notranslate"><span class="pre">-[NSString</span>
<span class="pre">stringWithCString:]</span></code>â) and the basename is the selector only
(â<code class="docutils literal notranslate"><span class="pre">stringWithCString:</span></code>â).</p>
</section>
<section id="mach-o-changes">
<h5><a class="toc-backref" href="#id57" role="doc-backlink">Mach-O Changes</a><a class="headerlink" href="#mach-o-changes" title="Link to this heading">Â¶</a></h5>
<p>The sections names for the apple hash tables are for non-mach-o files.  For
mach-o files, the sections should be contained in the <code class="docutils literal notranslate"><span class="pre">__DWARF</span></code> segment with
names as follows:</p>
<ul class="simple">
<li><p>â<code class="docutils literal notranslate"><span class="pre">.apple_names</span></code>â -&gt; â<code class="docutils literal notranslate"><span class="pre">__apple_names</span></code>â</p></li>
<li><p>â<code class="docutils literal notranslate"><span class="pre">.apple_types</span></code>â -&gt; â<code class="docutils literal notranslate"><span class="pre">__apple_types</span></code>â</p></li>
<li><p>â<code class="docutils literal notranslate"><span class="pre">.apple_namespaces</span></code>â -&gt; â<code class="docutils literal notranslate"><span class="pre">__apple_namespac</span></code>â (16 character limit)</p></li>
<li><p>â<code class="docutils literal notranslate"><span class="pre">.apple_objc</span></code>â -&gt; â<code class="docutils literal notranslate"><span class="pre">__apple_objc</span></code>â</p></li>
</ul>
</section>
</section>
</section>
</section>
<section id="codeview-debug-info-format">
<span id="codeview"></span><h2><a class="toc-backref" href="#id58" role="doc-backlink">CodeView Debug Info Format</a><a class="headerlink" href="#codeview-debug-info-format" title="Link to this heading">Â¶</a></h2>
<p>LLVM supports emitting CodeView, the Microsoft debug info format, and this
section describes the design and implementation of that support.</p>
<section id="format-background">
<h3><a class="toc-backref" href="#id59" role="doc-backlink">Format Background</a><a class="headerlink" href="#format-background" title="Link to this heading">Â¶</a></h3>
<p>CodeView as a format is clearly oriented around C++ debugging, and in C++, the
majority of debug information tends to be type information. Therefore, the
overriding design constraint of CodeView is the separation of type information
from other âsymbolâ information so that type information can be efficiently
merged across translation units. Both type information and symbol information is
generally stored as a sequence of records, where each record begins with a
16-bit record size and a 16-bit record kind.</p>
<p>Type information is usually stored in the <code class="docutils literal notranslate"><span class="pre">.debug$T</span></code> section of the object
file.  All other debug info, such as line info, string table, symbol info, and
inlinee info, is stored in one or more <code class="docutils literal notranslate"><span class="pre">.debug$S</span></code> sections. There may only be
one <code class="docutils literal notranslate"><span class="pre">.debug$T</span></code> section per object file, since all other debug info refers to
it. If a PDB (enabled by the <code class="docutils literal notranslate"><span class="pre">/Zi</span></code> MSVC option) was used during compilation,
the <code class="docutils literal notranslate"><span class="pre">.debug$T</span></code> section will contain only an <code class="docutils literal notranslate"><span class="pre">LF_TYPESERVER2</span></code> record pointing
to the PDB. When using PDBs, symbol information appears to remain in the object
file <code class="docutils literal notranslate"><span class="pre">.debug$S</span></code> sections.</p>
<p>Type records are referred to by their index, which is the number of records in
the stream before a given record plus <code class="docutils literal notranslate"><span class="pre">0x1000</span></code>. Many common basic types, such
as the basic integral types and unqualified pointers to them, are represented
using type indices less than <code class="docutils literal notranslate"><span class="pre">0x1000</span></code>. Such basic types are built in to
CodeView consumers and do not require type records.</p>
<p>Each type record may only contain type indices that are less than its own type
index. This ensures that the graph of type stream references is acyclic. While
the source-level type graph may contain cycles through pointer types (consider a
linked list struct), these cycles are removed from the type stream by always
referring to the forward declaration record of user-defined record types. Only
âsymbolâ records in the <code class="docutils literal notranslate"><span class="pre">.debug$S</span></code> streams may refer to complete,
non-forward-declaration type records.</p>
</section>
<section id="working-with-codeview">
<h3><a class="toc-backref" href="#id60" role="doc-backlink">Working with CodeView</a><a class="headerlink" href="#working-with-codeview" title="Link to this heading">Â¶</a></h3>
<p>These are instructions for some common tasks for developers working to improve
LLVMâs CodeView support. Most of them revolve around using the CodeView dumper
embedded in <code class="docutils literal notranslate"><span class="pre">llvm-readobj</span></code>.</p>
<ul>
<li><p>Testing MSVCâs output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cl -c -Z7 foo.cpp # Use /Z7 to keep types in the object file
$ llvm-readobj --codeview foo.obj
</pre></div>
</div>
</li>
<li><p>Getting LLVM IR debug info out of Clang:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ clang -g -gcodeview --target=x86_64-windows-msvc foo.cpp -S -emit-llvm
</pre></div>
</div>
<p>Use this to generate LLVM IR for LLVM test cases.</p>
</li>
<li><p>Generate and dump CodeView from LLVM IR metadata:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ llc foo.ll -filetype=obj -o foo.obj
$ llvm-readobj --codeview foo.obj &gt; foo.txt
</pre></div>
</div>
<p>Use this pattern in lit test cases and FileCheck the output of llvm-readobj</p>
</li>
</ul>
<p>Improving LLVMâs CodeView support is a process of finding interesting type
records, constructing a C++ test case that makes MSVC emit those records,
dumping the records, understanding them, and then generating equivalent records
in LLVMâs backend.</p>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="AssignmentTracking.html" title="Debug Info Assignment Tracking"
             >next</a> |</li>
        <li class="right" >
          <a href="RISCV/RISCVVectorExtension.html" title="RISC-V Vector Extension"
             >previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" >User Guides</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Source Level Debugging with LLVM</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2003-2025, LLVM Project.
      Last updated on 2025-03-04.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>