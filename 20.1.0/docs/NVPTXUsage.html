
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>User Guide for NVPTX Back-end &#8212; LLVM 20.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/llvm-theme.css?v=96924833" />
    <script src="_static/documentation_options.js?v=383a7952"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="LLVM’s Analysis and Transform Passes" href="Passes.html" />
    <link rel="prev" title="Using the New Pass Manager" href="NewPassManager.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="Passes.html" title="LLVM’s Analysis and Transform Passes"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="NewPassManager.html" title="Using the New Pass Manager"
             accesskey="P">previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" accesskey="U">User Guides</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">User Guide for NVPTX Back-end</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="https://llvm.org/docs/UserGuides.html">User Guides</a></li>
    <li><a href="https://llvm.org/docs/Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/Contributing.html">Contributing to LLVM</a></li>
    <li><a href="https://llvm.org/docs/HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#discord">Discord</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/FAQ.html">FAQ</a></li>
    <li><a href="https://llvm.org/docs/Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project/">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/NVPTXUsage.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="user-guide-for-nvptx-back-end">
<h1>User Guide for NVPTX Back-end<a class="headerlink" href="#user-guide-for-nvptx-back-end" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id69">Introduction</a></p></li>
<li><p><a class="reference internal" href="#conventions" id="id70">Conventions</a></p>
<ul>
<li><p><a class="reference internal" href="#marking-functions-as-kernels" id="id71">Marking Functions as Kernels</a></p></li>
<li><p><a class="reference internal" href="#address-spaces" id="id72">Address Spaces</a></p></li>
<li><p><a class="reference internal" href="#triples" id="id73">Triples</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#nvptx-intrinsics" id="id74">NVPTX Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#reading-ptx-special-registers" id="id75">Reading PTX Special Registers</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-nvvm-read-ptx-sreg" id="id76">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.read.ptx.sreg.*</span></code>’</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#barriers" id="id77">Barriers</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-nvvm-barrier0" id="id78">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.barrier0</span></code>’</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#electing-a-thread" id="id79">Electing a thread</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-nvvm-elect-sync" id="id80">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.elect.sync</span></code>’</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#membar-fences" id="id81">Membar/Fences</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-nvvm-fence-proxy-tensormap-generic" id="id82">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fence.proxy.tensormap_generic.*</span></code>’</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#address-space-intrinsics" id="id83">Address Space Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-nvvm-isspacep-intrinsics" id="id84">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.isspacep.*</span></code>’ Intrinsics</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#arithmetic-intrinsics" id="id85">Arithmetic Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-nvvm-idp2a-us-us-intrinsics" id="id86">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp2a.[us].[us]</span></code>’ Intrinsics</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-idp4a-us-us-intrinsics" id="id87">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp4a.[us].[us]</span></code>’ Intrinsics</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#bit-manipulation-intrinsics" id="id88">Bit Manipulation Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-nvvm-fshl-clamp-intrinsic" id="id89">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fshl.clamp.*</span></code>’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-fshr-clamp-intrinsic" id="id90">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fshr.clamp.*</span></code>’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-flo-u-intrinsic" id="id91">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.flo.u.*</span></code>’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-flo-s-intrinsic" id="id92">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.flo.s.*</span></code>’ Intrinsic</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#tma-family-of-intrinsics" id="id93">TMA family of Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-global-to-shared-cluster" id="id94">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.global.to.shared.cluster</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-shared-cta-to-global" id="id95">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.shared.cta.to.global</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-shared-cta-to-cluster" id="id96">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.shared.cta.to.cluster</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-prefetch-l2" id="id97">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.prefetch.L2</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-tensor-g2s-tile-1-5-d" id="id98">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.g2s.tile.[1-5]d</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-tensor-g2s-im2col-3-5-d" id="id99">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.g2s.im2col.[3-5]d</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-tensor-s2g-tile-1-5-d" id="id100">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.s2g.tile.[1-5]d</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-tensor-s2g-im2col-3-5-d" id="id101">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.s2g.im2col.[3-5]d</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-tensor-prefetch-tile-1-5-d" id="id102">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.prefetch.tile.[1-5]d</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-tensor-prefetch-im2col-3-5-d" id="id103">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.prefetch.im2col.[3-5]d</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-tensor-reduce-red-op-tile-1-5-d" id="id104">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.reduce.[red_op].tile.[1-5]d</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-tensor-reduce-red-op-im2col-3-5-d" id="id105">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.reduce.[red_op].im2col.[3-5]d</span></code>’</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#warp-group-intrinsics" id="id106">Warp Group Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-nvvm-wgmma-fence-sync-aligned" id="id107">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.wgmma.fence.sync.aligned</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-wgmma-commit-group-sync-aligned" id="id108">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.wgmma.commit_group.sync.aligned</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-wgmma-wait-group-sync-aligned" id="id109">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.wgmma.wait_group.sync.aligned</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-griddepcontrol" id="id110">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.griddepcontrol.*</span></code>’</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#other-intrinsics" id="id111">Other Intrinsics</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#linking-with-libdevice" id="id112">Linking with Libdevice</a></p>
<ul>
<li><p><a class="reference internal" href="#reflection-parameters" id="id113">Reflection Parameters</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#executing-ptx" id="id114">Executing PTX</a></p></li>
<li><p><a class="reference internal" href="#common-issues" id="id115">Common Issues</a></p>
<ul>
<li><p><a class="reference internal" href="#ptxas-complains-of-undefined-function-nvvm-reflect" id="id116">ptxas complains of undefined function: __nvvm_reflect</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#tutorial-a-simple-compute-kernel" id="id117">Tutorial: A Simple Compute Kernel</a></p>
<ul>
<li><p><a class="reference internal" href="#the-kernel" id="id118">The Kernel</a></p></li>
<li><p><a class="reference internal" href="#dissecting-the-kernel" id="id119">Dissecting the Kernel</a></p>
<ul>
<li><p><a class="reference internal" href="#data-layout" id="id120">Data Layout</a></p></li>
<li><p><a class="reference internal" href="#target-intrinsics" id="id121">Target Intrinsics</a></p></li>
<li><p><a class="reference internal" href="#id68" id="id122">Address Spaces</a></p></li>
<li><p><a class="reference internal" href="#kernel-metadata" id="id123">Kernel Metadata</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#running-the-kernel" id="id124">Running the Kernel</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#tutorial-linking-with-libdevice" id="id125">Tutorial: Linking with Libdevice</a></p></li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id69" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>To support GPU programming, the NVPTX back-end supports a subset of LLVM IR
along with a defined set of conventions used to represent GPU programming
concepts. This document provides an overview of the general usage of the back-
end, including a description of the conventions used and the set of accepted
LLVM IR.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This document assumes a basic familiarity with CUDA and the PTX
assembly language. Information about the CUDA Driver API and the PTX assembly
language can be found in the <a class="reference external" href="http://docs.nvidia.com/cuda/index.html">CUDA documentation</a>.</p>
</div>
</section>
<section id="conventions">
<h2><a class="toc-backref" href="#id70" role="doc-backlink">Conventions</a><a class="headerlink" href="#conventions" title="Link to this heading">¶</a></h2>
<section id="marking-functions-as-kernels">
<h3><a class="toc-backref" href="#id71" role="doc-backlink">Marking Functions as Kernels</a><a class="headerlink" href="#marking-functions-as-kernels" title="Link to this heading">¶</a></h3>
<p>In PTX, there are two types of functions: <em>device functions</em>, which are only
callable by device code, and <em>kernel functions</em>, which are callable by host
code. By default, the back-end will emit device functions. Metadata is used to
declare a function as a kernel function. This metadata is attached to the
<code class="docutils literal notranslate"><span class="pre">nvvm.annotations</span></code> named metadata object, and has the following format:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>!0 = !{&lt;function-ref&gt;, metadata !&quot;kernel&quot;, i32 1}
</pre></div>
</div>
<p>The first parameter is a reference to the kernel function. The following
example shows a kernel function calling a device function in LLVM IR. The
function <code class="docutils literal notranslate"><span class="pre">&#64;my_kernel</span></code> is callable from host code, but <code class="docutils literal notranslate"><span class="pre">&#64;my_fmad</span></code> is not.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="vg">@my_fmad</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%z</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%mul</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">fmul</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="nv">%y</span>
<span class="w">  </span><span class="nv">%add</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">fadd</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%mul</span><span class="p">,</span><span class="w"> </span><span class="nv">%z</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%add</span>
<span class="p">}</span>

<span class="k">define</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@my_kernel</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%val</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%ptr</span>
<span class="w">  </span><span class="nv">%ret</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="vg">@my_fmad</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="nv">%val</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%val</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%val</span><span class="p">)</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%ret</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%ptr</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="k">void</span>
<span class="p">}</span>

<span class="nv">!nvvm.annotations</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="nv nv-Anonymous">!1</span><span class="p">}</span>
<span class="nv nv-Anonymous">!1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@my_kernel</span><span class="p">,</span><span class="w"> </span><span class="nv">!&quot;kernel&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">1</span><span class="p">}</span>
</pre></div>
</div>
<p>When compiled, the PTX kernel functions are callable by host-side code.</p>
</section>
<section id="address-spaces">
<span id="id1"></span><h3><a class="toc-backref" href="#id72" role="doc-backlink">Address Spaces</a><a class="headerlink" href="#address-spaces" title="Link to this heading">¶</a></h3>
<p>The NVPTX back-end uses the following address space mapping:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Address Space</p></th>
<th class="head"><p>Memory Space</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>Generic</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>Global</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>Internal Use</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>Shared</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>Constant</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>Local</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Every global variable and pointer type is assigned to one of these address
spaces, with 0 being the default address space. Intrinsics are provided which
can be used to convert pointers between the generic and non-generic address
spaces.</p>
<p>As an example, the following IR will define an array <code class="docutils literal notranslate"><span class="pre">&#64;g</span></code> that resides in
global device memory.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="vg">@g</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">internal</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="k">global</span><span class="w"> </span><span class="p">[</span><span class="m">4</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i32</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="p">]</span>
</pre></div>
</div>
<p>LLVM IR functions can read and write to this array, and host-side code can
copy data to it by name with the CUDA Driver API.</p>
<p>Note that since address space 0 is the generic space, it is illegal to have
global variables in address space 0.  Address space 0 is the default address
space in LLVM, so the <code class="docutils literal notranslate"><span class="pre">addrspace(N)</span></code> annotation is <em>required</em> for global
variables.</p>
</section>
<section id="triples">
<h3><a class="toc-backref" href="#id73" role="doc-backlink">Triples</a><a class="headerlink" href="#triples" title="Link to this heading">¶</a></h3>
<p>The NVPTX target uses the module triple to select between 32/64-bit code
generation and the driver-compiler interface to use. The triple architecture
can be one of <code class="docutils literal notranslate"><span class="pre">nvptx</span></code> (32-bit PTX) or <code class="docutils literal notranslate"><span class="pre">nvptx64</span></code> (64-bit PTX). The
operating system should be one of <code class="docutils literal notranslate"><span class="pre">cuda</span></code> or <code class="docutils literal notranslate"><span class="pre">nvcl</span></code>, which determines the
interface used by the generated code to communicate with the driver.  Most
users will want to use <code class="docutils literal notranslate"><span class="pre">cuda</span></code> as the operating system, which makes the
generated PTX compatible with the CUDA Driver API.</p>
<p>Example: 32-bit PTX for CUDA Driver API: <code class="docutils literal notranslate"><span class="pre">nvptx-nvidia-cuda</span></code></p>
<p>Example: 64-bit PTX for CUDA Driver API: <code class="docutils literal notranslate"><span class="pre">nvptx64-nvidia-cuda</span></code></p>
</section>
</section>
<section id="nvptx-intrinsics">
<span id="id2"></span><h2><a class="toc-backref" href="#id74" role="doc-backlink">NVPTX Intrinsics</a><a class="headerlink" href="#nvptx-intrinsics" title="Link to this heading">¶</a></h2>
<section id="reading-ptx-special-registers">
<h3><a class="toc-backref" href="#id75" role="doc-backlink">Reading PTX Special Registers</a><a class="headerlink" href="#reading-ptx-special-registers" title="Link to this heading">¶</a></h3>
<section id="llvm-nvvm-read-ptx-sreg">
<h4><a class="toc-backref" href="#id76" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.read.ptx.sreg.*</span></code>’</a><a class="headerlink" href="#llvm-nvvm-read-ptx-sreg" title="Link to this heading">¶</a></h4>
<section id="syntax">
<h5>Syntax:<a class="headerlink" href="#syntax" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.tid.x</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.tid.y</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.tid.z</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.ntid.x</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.ntid.y</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.ntid.z</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.ctaid.x</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.ctaid.y</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.ctaid.z</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.nctaid.x</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.nctaid.y</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.nctaid.z</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.warpsize</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="overview">
<h5>Overview:<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.read.ptx.sreg.*</span></code>’ intrinsics provide access to the PTX
special registers, in particular the kernel launch bounds.  These registers
map in the following way to CUDA builtins:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>CUDA Builtin</p></th>
<th class="head"><p>PTX Special Register Intrinsic</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">threadId</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.read.ptx.sreg.tid.*</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">blockIdx</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.read.ptx.sreg.ctaid.*</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">blockDim</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.read.ptx.sreg.ntid.*</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">gridDim</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.read.ptx.sreg.nctaid.*</span></code></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</section>
</section>
</section>
<section id="barriers">
<h3><a class="toc-backref" href="#id77" role="doc-backlink">Barriers</a><a class="headerlink" href="#barriers" title="Link to this heading">¶</a></h3>
<section id="llvm-nvvm-barrier0">
<h4><a class="toc-backref" href="#id78" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.barrier0</span></code>’</a><a class="headerlink" href="#llvm-nvvm-barrier0" title="Link to this heading">¶</a></h4>
<section id="id3">
<h5>Syntax:<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.barrier0</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="id4">
<h5>Overview:<a class="headerlink" href="#id4" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.barrier0()</span></code>’ intrinsic emits a PTX <code class="docutils literal notranslate"><span class="pre">bar.sync</span> <span class="pre">0</span></code>
instruction, equivalent to the <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> call in CUDA.</p>
</section>
</section>
</section>
<section id="electing-a-thread">
<h3><a class="toc-backref" href="#id79" role="doc-backlink">Electing a thread</a><a class="headerlink" href="#electing-a-thread" title="Link to this heading">¶</a></h3>
<section id="llvm-nvvm-elect-sync">
<h4><a class="toc-backref" href="#id80" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.elect.sync</span></code>’</a><a class="headerlink" href="#llvm-nvvm-elect-sync" title="Link to this heading">¶</a></h4>
<section id="id5">
<h5>Syntax:<a class="headerlink" href="#id5" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="p">{</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="p">}</span><span class="w"> </span><span class="vg">@llvm.nvvm.elect.sync</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%membermask</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id6">
<h5>Overview:<a class="headerlink" href="#id6" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.elect.sync</span></code>’ intrinsic generates the <code class="docutils literal notranslate"><span class="pre">elect.sync</span></code>
PTX instruction, which elects one predicated active leader thread from
a set of threads specified by <code class="docutils literal notranslate"><span class="pre">membermask</span></code>. The behavior is undefined
if the executing thread is not in <code class="docutils literal notranslate"><span class="pre">membermask</span></code>. The laneid of the
elected thread is captured in the i32 return value. The i1 return
value is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> for the leader thread and <code class="docutils literal notranslate"><span class="pre">False</span></code> for all
the other threads. Election of a leader thread happens deterministically,
i.e. the same leader thread is elected for the same <code class="docutils literal notranslate"><span class="pre">membermask</span></code>
every time. For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-elect-sync">https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-elect-sync</a>.</p>
</section>
</section>
</section>
<section id="membar-fences">
<h3><a class="toc-backref" href="#id81" role="doc-backlink">Membar/Fences</a><a class="headerlink" href="#membar-fences" title="Link to this heading">¶</a></h3>
<section id="llvm-nvvm-fence-proxy-tensormap-generic">
<h4><a class="toc-backref" href="#id82" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fence.proxy.tensormap_generic.*</span></code>’</a><a class="headerlink" href="#llvm-nvvm-fence-proxy-tensormap-generic" title="Link to this heading">¶</a></h4>
<section id="id7">
<h5>Syntax:<a class="headerlink" href="#id7" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.fence.proxy.tensormap_generic.release.cta</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.fence.proxy.tensormap_generic.release.cluster</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.fence.proxy.tensormap_generic.release.gpu</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.fence.proxy.tensormap_generic.release.sys</span><span class="p">()</span>

<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.fence.proxy.tensormap_generic.acquire.cta</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%size</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.fence.proxy.tensormap_generic.acquire.cluster</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%size</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.fence.proxy.tensormap_generic.acquire.gpu</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%size</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.fence.proxy.tensormap_generic.acquire.sys</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%size</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id8">
<h5>Overview:<a class="headerlink" href="#id8" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.fence.proxy.tensormap_generic.*</span></code> is a uni-directional fence used to establish ordering between a prior memory access performed via the generic <cite>proxy&lt;https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#proxies&gt;_</cite> and a subsequent memory access performed via the tensormap proxy. <code class="docutils literal notranslate"><span class="pre">nvvm.fence.proxy.tensormap_generic.release</span></code> can form a release sequence that synchronizes with an acquire sequence that contains the <code class="docutils literal notranslate"><span class="pre">nvvm.fence.proxy.tensormap_generic.acquire</span></code> proxy fence. The following table describes the mapping between LLVM Intrinsic and the PTX instruction:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>NVVM Intrinsic</p></th>
<th class="head"><p>PTX Instruction</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.fence.proxy.tensormap_generic.release.*</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fence.proxy.tensormap::generic.release.*</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.fence.proxy.tensormap_generic.acquire.*</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fence.proxy.tensormap::generic.acquire.*</span> <span class="pre">[addr],</span> <span class="pre">size</span></code></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The address operand <code class="docutils literal notranslate"><span class="pre">addr</span></code> and the operand <code class="docutils literal notranslate"><span class="pre">size</span></code> together specify the memory range <code class="docutils literal notranslate"><span class="pre">[addr,</span> <span class="pre">addr+size)</span></code> on which the ordering guarantees on the memory accesses across the proxies is to be provided. The only supported value for the <code class="docutils literal notranslate"><span class="pre">size</span></code> operand is <code class="docutils literal notranslate"><span class="pre">128</span></code> and must be an immediate. Generic Addressing is used unconditionally, and the address specified by the operand addr must fall within the <code class="docutils literal notranslate"><span class="pre">.global</span></code> state space. Otherwise, the behavior is undefined. For more information, see <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-membar">PTX ISA</a>.</p>
</section>
</section>
</section>
<section id="address-space-intrinsics">
<h3><a class="toc-backref" href="#id83" role="doc-backlink">Address Space Intrinsics</a><a class="headerlink" href="#address-space-intrinsics" title="Link to this heading">¶</a></h3>
<section id="llvm-nvvm-isspacep-intrinsics">
<h4><a class="toc-backref" href="#id84" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.isspacep.*</span></code>’ Intrinsics</a><a class="headerlink" href="#llvm-nvvm-isspacep-intrinsics" title="Link to this heading">¶</a></h4>
<section id="id9">
<h5>Syntax:<a class="headerlink" href="#id9" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.nvvm.isspacep.const</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.nvvm.isspacep.global</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.nvvm.isspacep.local</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.nvvm.isspacep.shared</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.nvvm.isspacep.shared.cluster</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id10">
<h5>Overview:<a class="headerlink" href="#id10" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.isspacep.*</span></code>’ intrinsics determine whether the provided generic
pointer references memory which falls within a particular address space.</p>
</section>
<section id="semantics">
<h5>Semantics:<a class="headerlink" href="#semantics" title="Link to this heading">¶</a></h5>
<p>If the given pointer in the generic address space refers to memory which falls
within the state space of the intrinsic (and therefore could be safely address
space casted to this space), 1 is returned, otherwise 0 is returned.</p>
</section>
</section>
</section>
<section id="arithmetic-intrinsics">
<h3><a class="toc-backref" href="#id85" role="doc-backlink">Arithmetic Intrinsics</a><a class="headerlink" href="#arithmetic-intrinsics" title="Link to this heading">¶</a></h3>
<section id="llvm-nvvm-idp2a-us-us-intrinsics">
<h4><a class="toc-backref" href="#id86" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp2a.[us].[us]</span></code>’ Intrinsics</a><a class="headerlink" href="#llvm-nvvm-idp2a-us-us-intrinsics" title="Link to this heading">¶</a></h4>
<section id="id11">
<h5>Syntax:<a class="headerlink" href="#id11" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.idp2a.s.s</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">immarg</span><span class="w"> </span><span class="nv">%is.hi</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%c</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.idp2a.s.u</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">immarg</span><span class="w"> </span><span class="nv">%is.hi</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%c</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.idp2a.u.s</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">immarg</span><span class="w"> </span><span class="nv">%is.hi</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%c</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.idp2a.u.u</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">immarg</span><span class="w"> </span><span class="nv">%is.hi</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%c</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id12">
<h5>Overview:<a class="headerlink" href="#id12" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp2a.[us].[us]</span></code>’ intrinsics performs a 2-element vector dot
product followed by addition. They corresponds directly to the <code class="docutils literal notranslate"><span class="pre">dp2a</span></code> PTX
instruction.</p>
</section>
<section id="id13">
<h5>Semantics:<a class="headerlink" href="#id13" title="Link to this heading">¶</a></h5>
<p>The 32-bit value in <code class="docutils literal notranslate"><span class="pre">%a</span></code> is broken into 2 16-bit values which are extended to
32 bits. For the ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp2a.u.[us]</span></code>’ variants zero-extension is used,
while for the ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp2a.s.[us]</span></code>’ sign-extension is used. Two bytes are
selected from <code class="docutils literal notranslate"><span class="pre">%b</span></code>, if <code class="docutils literal notranslate"><span class="pre">%is.hi</span></code> is true, the most significant bytes are
selected, otherwise the least significant bytes are selected. These bytes are
then extended to 32-bits. For the ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp2a.[us].u</span></code>’ variants
zero-extension is used, while for the ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp2a.[us].s</span></code>’
sign-extension is used. The dot product of these 2-element vectors is added to
<code class="docutils literal notranslate"><span class="pre">%c</span></code> to produce the return.</p>
</section>
</section>
<section id="llvm-nvvm-idp4a-us-us-intrinsics">
<h4><a class="toc-backref" href="#id87" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp4a.[us].[us]</span></code>’ Intrinsics</a><a class="headerlink" href="#llvm-nvvm-idp4a-us-us-intrinsics" title="Link to this heading">¶</a></h4>
<section id="id14">
<h5>Syntax:<a class="headerlink" href="#id14" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.idp4a.s.s</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%c</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.idp4a.s.u</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%c</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.idp4a.u.s</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%c</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.idp4a.u.u</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%c</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id15">
<h5>Overview:<a class="headerlink" href="#id15" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp4a.[us].[us]</span></code>’ intrinsics perform a 4-element vector dot
product followed by addition. They corresponds directly to the <code class="docutils literal notranslate"><span class="pre">dp4a</span></code> PTX
instruction.</p>
</section>
<section id="id16">
<h5>Semantics:<a class="headerlink" href="#id16" title="Link to this heading">¶</a></h5>
<p>Each of the 4 bytes in both <code class="docutils literal notranslate"><span class="pre">%a</span></code> and <code class="docutils literal notranslate"><span class="pre">%b</span></code> are extended to 32-bit integers
forming 2 <code class="docutils literal notranslate"><span class="pre">&lt;4</span> <span class="pre">x</span> <span class="pre">i32&gt;</span></code>. For <code class="docutils literal notranslate"><span class="pre">%a</span></code>, zero-extension is used in the
‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp4a.u.[us]</span></code>’ variants, while sign-extension is used with
‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp4a.s.[us]</span></code>’ variants. Similarly, for <code class="docutils literal notranslate"><span class="pre">%b</span></code>, zero-extension is
used in the ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp4a.[us].u</span></code>’ variants, while sign-extension is used
with ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp4a.[us].s</span></code>’ variants. The dot product of these 4-element
vectors is added to <code class="docutils literal notranslate"><span class="pre">%c</span></code> to produce the return.</p>
</section>
</section>
</section>
<section id="bit-manipulation-intrinsics">
<h3><a class="toc-backref" href="#id88" role="doc-backlink">Bit Manipulation Intrinsics</a><a class="headerlink" href="#bit-manipulation-intrinsics" title="Link to this heading">¶</a></h3>
<section id="llvm-nvvm-fshl-clamp-intrinsic">
<h4><a class="toc-backref" href="#id89" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fshl.clamp.*</span></code>’ Intrinsic</a><a class="headerlink" href="#llvm-nvvm-fshl-clamp-intrinsic" title="Link to this heading">¶</a></h4>
<section id="id17">
<h5>Syntax:<a class="headerlink" href="#id17" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.fshl.clamp.i32</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%hi</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%lo</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id18">
<h5>Overview:<a class="headerlink" href="#id18" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fshl.clamp</span></code>’ family of intrinsics performs a clamped funnel
shift left. These intrinsics are very similar to ‘<code class="docutils literal notranslate"><span class="pre">llvm.fshl</span></code>’, except the
shift ammont is clamped at the integer width (instead of modulo it). Currently,
only <code class="docutils literal notranslate"><span class="pre">i32</span></code> is supported.</p>
</section>
<section id="id19">
<h5>Semantics:<a class="headerlink" href="#id19" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fshl.clamp</span></code>’ family of intrinsic functions performs a clamped
funnel shift left: the first two values are concatenated as { %hi : %lo } (%hi
is the most significant bits of the wide value), the combined value is shifted
left, and the most significant bits are extracted to produce a result that is
the same size as the original arguments. The shift amount is the minimum of the
value of %n and the bit width of the integer type.</p>
</section>
</section>
<section id="llvm-nvvm-fshr-clamp-intrinsic">
<h4><a class="toc-backref" href="#id90" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fshr.clamp.*</span></code>’ Intrinsic</a><a class="headerlink" href="#llvm-nvvm-fshr-clamp-intrinsic" title="Link to this heading">¶</a></h4>
<section id="id20">
<h5>Syntax:<a class="headerlink" href="#id20" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.fshr.clamp.i32</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%hi</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%lo</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id21">
<h5>Overview:<a class="headerlink" href="#id21" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fshr.clamp</span></code>’ family of intrinsics perform a clamped funnel
shift right. These intrinsics are very similar to ‘<code class="docutils literal notranslate"><span class="pre">llvm.fshr</span></code>’, except the
shift ammont is clamped at the integer width (instead of modulo it). Currently,
only <code class="docutils literal notranslate"><span class="pre">i32</span></code> is supported.</p>
</section>
<section id="id22">
<h5>Semantics:<a class="headerlink" href="#id22" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fshr.clamp</span></code>’ family of intrinsic functions performs a clamped
funnel shift right: the first two values are concatenated as { %hi : %lo } (%hi
is the most significant bits of the wide value), the combined value is shifted
right, and the least significant bits are extracted to produce a result that is
the same size as the original arguments. The shift amount is the minimum of the
value of %n and the bit width of the integer type.</p>
</section>
</section>
<section id="llvm-nvvm-flo-u-intrinsic">
<h4><a class="toc-backref" href="#id91" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.flo.u.*</span></code>’ Intrinsic</a><a class="headerlink" href="#llvm-nvvm-flo-u-intrinsic" title="Link to this heading">¶</a></h4>
<section id="id23">
<h5>Syntax:<a class="headerlink" href="#id23" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.flo.u.i32</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%shiftamt</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.flo.u.i64</span><span class="p">(</span><span class="kt">i64</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%shiftamt</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id24">
<h5>Overview:<a class="headerlink" href="#id24" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.flo.u</span></code>’ family of intrinsics identifies the bit position of the
leading one, returning either it’s offset from the most or least significant bit.</p>
</section>
<section id="id25">
<h5>Semantics:<a class="headerlink" href="#id25" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.flo.u</span></code>’ family of intrinsics returns the bit position of the
most significant 1. If %shiftamt is true, The result is the shift amount needed
to left-shift the found bit into the most-significant bit position, otherwise
the result is the shift amount needed to right-shift the found bit into the
least-significant bit position. 0xffffffff is returned if no 1 bit is found.</p>
</section>
</section>
<section id="llvm-nvvm-flo-s-intrinsic">
<h4><a class="toc-backref" href="#id92" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.flo.s.*</span></code>’ Intrinsic</a><a class="headerlink" href="#llvm-nvvm-flo-s-intrinsic" title="Link to this heading">¶</a></h4>
<section id="id26">
<h5>Syntax:<a class="headerlink" href="#id26" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.flo.s.i32</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%shiftamt</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.flo.s.i64</span><span class="p">(</span><span class="kt">i64</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%shiftamt</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id27">
<h5>Overview:<a class="headerlink" href="#id27" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.flo.s</span></code>’ family of intrinsics identifies the bit position of the
leading non-sign bit, returning either it’s offset from the most or least
significant bit.</p>
</section>
<section id="id28">
<h5>Semantics:<a class="headerlink" href="#id28" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.flo.s</span></code>’ family of intrinsics returns the bit position of the
most significant 0 for negative inputs and the most significant 1 for
non-negative inputs. If %shiftamt is true, The result is the shift amount needed
to left-shift the found bit into the most-significant bit position, otherwise
the result is the shift amount needed to right-shift the found bit into the
least-significant bit position. 0xffffffff is returned if no 1 bit is found.</p>
</section>
</section>
</section>
<section id="tma-family-of-intrinsics">
<h3><a class="toc-backref" href="#id93" role="doc-backlink">TMA family of Intrinsics</a><a class="headerlink" href="#tma-family-of-intrinsics" title="Link to this heading">¶</a></h3>
<section id="llvm-nvvm-cp-async-bulk-global-to-shared-cluster">
<h4><a class="toc-backref" href="#id94" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.global.to.shared.cluster</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-global-to-shared-cluster" title="Link to this heading">¶</a></h4>
<section id="id29">
<h5>Syntax:<a class="headerlink" href="#id29" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.global.to.shared.cluster</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%dst</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%mbar</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%size</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%mc</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_mc</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id30">
<h5>Overview:<a class="headerlink" href="#id30" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.global.to.shared.cluster</span></code>’ intrinsic
corresponds to the <code class="docutils literal notranslate"><span class="pre">cp.async.bulk.shared::cluster.global.*</span></code> family
of PTX instructions. These instructions initiate an asynchronous
copy of bulk data from global memory to shared::cluster memory.
The 32-bit operand <code class="docutils literal notranslate"><span class="pre">%size</span></code> specifies the amount of memory to be
copied and it must be a multiple of 16.</p>
<ul class="simple">
<li><p>The last two arguments to these intrinsics are boolean flags
indicating support for cache_hint and/or multicast modifiers.
These flag arguments must be compile-time constants. The backend
looks through these flags and lowers the intrinsics appropriately.</p></li>
<li><p>The Nth argument (denoted by <code class="docutils literal notranslate"><span class="pre">i1</span> <span class="pre">%flag_ch</span></code>) when set, indicates
a valid cache_hint (<code class="docutils literal notranslate"><span class="pre">i64</span> <span class="pre">%ch</span></code>) and generates the <code class="docutils literal notranslate"><span class="pre">.L2::cache_hint</span></code>
variant of the PTX instruction.</p></li>
<li><p>The [N-1]th argument (denoted by <code class="docutils literal notranslate"><span class="pre">i1</span> <span class="pre">%flag_mc</span></code>) when set, indicates
the presence of a multicast mask (<code class="docutils literal notranslate"><span class="pre">i16</span> <span class="pre">%mc</span></code>) and generates the PTX
instruction with the <code class="docutils literal notranslate"><span class="pre">.multicast::cluster</span></code> modifier.</p></li>
</ul>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk">https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk</a>.</p>
</section>
</section>
<section id="llvm-nvvm-cp-async-bulk-shared-cta-to-global">
<h4><a class="toc-backref" href="#id95" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.shared.cta.to.global</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-shared-cta-to-global" title="Link to this heading">¶</a></h4>
<section id="id31">
<h5>Syntax:<a class="headerlink" href="#id31" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.shared.cta.to.global</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%dst</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%size</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id32">
<h5>Overview:<a class="headerlink" href="#id32" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.shared.cta.to.global</span></code>’ intrinsic
corresponds to the <code class="docutils literal notranslate"><span class="pre">cp.async.bulk.global.shared::cta.*</span></code> set of PTX
instructions. These instructions initiate an asynchronous copy from
shared::cta to global memory. The 32-bit operand <code class="docutils literal notranslate"><span class="pre">%size</span></code> specifies
the amount of memory to be copied and it must be a multiple of 16.</p>
<ul class="simple">
<li><p>The last argument to these intrinsics is a boolean flag
indicating support for cache_hint. This flag argument must
be a compile-time constant. When set, it indicates a valid
cache_hint (<code class="docutils literal notranslate"><span class="pre">i64</span> <span class="pre">%ch</span></code>) and generates the <code class="docutils literal notranslate"><span class="pre">.L2::cache_hint</span></code>
variant of the PTX instruction.</p></li>
</ul>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk">https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk</a>.</p>
</section>
</section>
<section id="llvm-nvvm-cp-async-bulk-shared-cta-to-cluster">
<h4><a class="toc-backref" href="#id96" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.shared.cta.to.cluster</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-shared-cta-to-cluster" title="Link to this heading">¶</a></h4>
<section id="id34">
<h5>Syntax:<a class="headerlink" href="#id34" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.shared.cta.to.cluster</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%dst</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%mbar</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%size</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id35">
<h5>Overview:<a class="headerlink" href="#id35" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.shared.cta.to.cluster</span></code>’ intrinsic
corresponds to the <code class="docutils literal notranslate"><span class="pre">cp.async.bulk.shared::cluster.shared::cta.*</span></code>
PTX instruction. This instruction initiates an asynchronous copy from
shared::cta to shared::cluster memory. The destination has to be in
the shared memory of a different CTA within the cluster. The 32-bit
operand <code class="docutils literal notranslate"><span class="pre">%size</span></code> specifies the amount of memory to be copied and
it must be a multiple of 16.</p>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk">https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk</a>.</p>
</section>
</section>
<section id="llvm-nvvm-cp-async-bulk-prefetch-l2">
<h4><a class="toc-backref" href="#id97" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.prefetch.L2</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-prefetch-l2" title="Link to this heading">¶</a></h4>
<section id="id37">
<h5>Syntax:<a class="headerlink" href="#id37" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.prefetch.L2</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%size</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id38">
<h5>Overview:<a class="headerlink" href="#id38" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.prefetch.L2</span></code>’ intrinsic
corresponds to the <code class="docutils literal notranslate"><span class="pre">cp.async.bulk.prefetch.L2.*</span></code> family
of PTX instructions. These instructions initiate an asynchronous
prefetch of bulk data from global memory to the L2 cache.
The 32-bit operand <code class="docutils literal notranslate"><span class="pre">%size</span></code> specifies the amount of memory to be
prefetched in terms of bytes and it must be a multiple of 16.</p>
<ul class="simple">
<li><p>The last argument to these intrinsics is boolean flag indicating
support for cache_hint. These flag argument must be compile-time
constant. When set, it indicates a valid cache_hint (<code class="docutils literal notranslate"><span class="pre">i64</span> <span class="pre">%ch</span></code>)
and generates the <code class="docutils literal notranslate"><span class="pre">.L2::cache_hint</span></code> variant of the PTX instruction.</p></li>
</ul>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-prefetch">https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-prefetch</a>.</p>
</section>
</section>
<section id="llvm-nvvm-cp-async-bulk-tensor-g2s-tile-1-5-d">
<h4><a class="toc-backref" href="#id98" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.g2s.tile.[1-5]d</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-tensor-g2s-tile-1-5-d" title="Link to this heading">¶</a></h4>
<section id="id39">
<h5>Syntax:<a class="headerlink" href="#id39" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.g2s.tile.1d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%dst</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%bar</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%mc</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_mc</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.g2s.tile.2d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.g2s.tile.3d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.g2s.tile.4d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.g2s.tile.5d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d4</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
</pre></div>
</div>
</section>
<section id="id40">
<h5>Overview:<a class="headerlink" href="#id40" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.tensor.g2s.tile.[1-5]d</span></code>’ intrinsics
correspond to the <code class="docutils literal notranslate"><span class="pre">cp.async.bulk.tensor.[1-5]d.*</span></code> set of PTX instructions.
These instructions initiate an asynchronous copy of tensor data from
global memory to shared::cluster memory (indicated by the <code class="docutils literal notranslate"><span class="pre">g2s</span></code> prefix)
in <code class="docutils literal notranslate"><span class="pre">tile</span></code> mode. In tile mode, the multi-dimensional layout of the
source tensor is preserved at the destination. The dimension of the
tensor data ranges from 1d to 5d with the coordinates specified
by the <code class="docutils literal notranslate"><span class="pre">i32</span> <span class="pre">%d0</span> <span class="pre">...</span> <span class="pre">i32</span> <span class="pre">%d4</span></code> arguments.</p>
<ul class="simple">
<li><p>The last two arguments to these intrinsics are boolean flags
indicating support for cache_hint and/or multicast modifiers.
These flag arguments must be compile-time constants. The backend
looks through these flags and lowers the intrinsics appropriately.</p></li>
<li><p>The Nth argument (denoted by <code class="docutils literal notranslate"><span class="pre">i1</span> <span class="pre">flag_ch</span></code>) when set, indicates
a valid cache_hint (<code class="docutils literal notranslate"><span class="pre">i64</span> <span class="pre">%ch</span></code>) and generates the <code class="docutils literal notranslate"><span class="pre">.L2::cache_hint</span></code>
variant of the PTX instruction.</p></li>
<li><p>The [N-1]th argument (denoted by <code class="docutils literal notranslate"><span class="pre">i1</span> <span class="pre">flag_mc</span></code>) when set, indicates
the presence of a multicast mask (<code class="docutils literal notranslate"><span class="pre">i16</span> <span class="pre">%mc</span></code>) and generates the PTX
instruction with the <code class="docutils literal notranslate"><span class="pre">.multicast::cluster</span></code> modifier.</p></li>
</ul>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor">https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor</a>.</p>
</section>
</section>
<section id="llvm-nvvm-cp-async-bulk-tensor-g2s-im2col-3-5-d">
<h4><a class="toc-backref" href="#id99" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.g2s.im2col.[3-5]d</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-tensor-g2s-im2col-3-5-d" title="Link to this heading">¶</a></h4>
<section id="id41">
<h5>Syntax:<a class="headerlink" href="#id41" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.g2s.im2col.3d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%dst</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%bar</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col0</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%mc</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_mc</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.g2s.im2col.4d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col0</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col1</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.g2s.im2col.5d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d4</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col0</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col1</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col2</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
</pre></div>
</div>
</section>
<section id="id42">
<h5>Overview:<a class="headerlink" href="#id42" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.tensor.g2s.im2col.[3-5]d</span></code>’ intrinsics
correspond to the <code class="docutils literal notranslate"><span class="pre">cp.async.bulk.tensor.[1-5]d.*</span></code> set of PTX instructions.
These instructions initiate an asynchronous copy of tensor data from
global memory to shared::cluster memory (indicated by the <code class="docutils literal notranslate"><span class="pre">g2s</span></code> prefix)
in <code class="docutils literal notranslate"><span class="pre">im2col</span></code> mode. In im2col mode, some dimensions of the source tensor
are unrolled into a single dimensional column at the destination. In this
mode, the tensor has to be at least three-dimensional. Along with the tensor
coordinates, im2col offsets are also specified (denoted by
<code class="docutils literal notranslate"><span class="pre">i16</span> <span class="pre">im2col0...i16</span> <span class="pre">%im2col2</span></code>). The number of im2col offsets is two less
than the number of dimensions of the tensor operation. The last two arguments
to these intrinsics are boolean flags, with the same functionality as described
in the <code class="docutils literal notranslate"><span class="pre">tile</span></code> mode intrinsics above.</p>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor">https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor</a>.</p>
</section>
</section>
<section id="llvm-nvvm-cp-async-bulk-tensor-s2g-tile-1-5-d">
<h4><a class="toc-backref" href="#id100" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.s2g.tile.[1-5]d</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-tensor-s2g-tile-1-5-d" title="Link to this heading">¶</a></h4>
<section id="id44">
<h5>Syntax:<a class="headerlink" href="#id44" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.s2g.tile.1d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.s2g.tile.2d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.s2g.tile.3d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.s2g.tile.4d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.s2g.tile.5d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d4</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
</pre></div>
</div>
</section>
<section id="id45">
<h5>Overview:<a class="headerlink" href="#id45" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.tensor.s2g.tile.[1-5]d</span></code>’ intrinsics
correspond to the <code class="docutils literal notranslate"><span class="pre">cp.async.bulk.tensor.[1-5]d.*</span></code> set of PTX instructions.
These instructions initiate an asynchronous copy of tensor data from
shared::cta to global memory (indicated by the <code class="docutils literal notranslate"><span class="pre">s2g</span></code> prefix)
in <code class="docutils literal notranslate"><span class="pre">tile</span></code> mode. The dimension of the tensor data ranges from 1d to 5d
with the coordinates specified by the <code class="docutils literal notranslate"><span class="pre">i32</span> <span class="pre">%d0</span> <span class="pre">...</span> <span class="pre">i32</span> <span class="pre">%d4</span></code> arguments.</p>
<ul class="simple">
<li><p>The last argument to these intrinsics is a boolean flag
indicating support for cache_hint. This flag argument must
be a compile-time constant. When set, it indicates a valid
cache_hint (<code class="docutils literal notranslate"><span class="pre">i64</span> <span class="pre">%ch</span></code>) and generates the <code class="docutils literal notranslate"><span class="pre">.L2::cache_hint</span></code>
variant of the PTX instruction.</p></li>
</ul>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor">https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor</a>.</p>
</section>
</section>
<section id="llvm-nvvm-cp-async-bulk-tensor-s2g-im2col-3-5-d">
<h4><a class="toc-backref" href="#id101" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.s2g.im2col.[3-5]d</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-tensor-s2g-im2col-3-5-d" title="Link to this heading">¶</a></h4>
<section id="id47">
<h5>Syntax:<a class="headerlink" href="#id47" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.s2g.im2col.3d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.s2g.im2col.4d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.s2g.im2col.5d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d4</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
</pre></div>
</div>
</section>
<section id="id48">
<h5>Overview:<a class="headerlink" href="#id48" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.tensor.s2g.im2col.[1-5]d</span></code>’ intrinsics
correspond to the <code class="docutils literal notranslate"><span class="pre">cp.async.bulk.tensor.[1-5]d.*</span></code> set of PTX instructions.
These instructions initiate an asynchronous copy of tensor data from
shared::cta to global memory (indicated by the <code class="docutils literal notranslate"><span class="pre">s2g</span></code> prefix)
in <code class="docutils literal notranslate"><span class="pre">im2col</span></code> mode. In this mode, the tensor has to be at least
three-dimensional. Unlike the <code class="docutils literal notranslate"><span class="pre">g2s</span></code> variants, there are no
im2col_offsets for these intrinsics. The last argument to these
intrinsics is a boolean flag, with the same functionality as
described in the <code class="docutils literal notranslate"><span class="pre">s2g.tile</span></code> mode intrinsics above.</p>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor">https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor</a>.</p>
</section>
</section>
<section id="llvm-nvvm-cp-async-bulk-tensor-prefetch-tile-1-5-d">
<h4><a class="toc-backref" href="#id102" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.prefetch.tile.[1-5]d</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-tensor-prefetch-tile-1-5-d" title="Link to this heading">¶</a></h4>
<section id="id50">
<h5>Syntax:<a class="headerlink" href="#id50" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.prefetch.tile.1d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.prefetch.tile.2d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.prefetch.tile.3d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.prefetch.tile.4d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.prefetch.tile.5d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d4</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
</pre></div>
</div>
</section>
<section id="id51">
<h5>Overview:<a class="headerlink" href="#id51" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.tensor.prefetch.tile.[1-5]d</span></code>’ intrinsics
correspond to the <code class="docutils literal notranslate"><span class="pre">cp.async.bulk.prefetch.tensor.[1-5]d.L2.global*</span></code> set
of PTX instructions. These instructions initiate an asynchronous prefetch
of tensor data from global memory to the L2 cache. In tile mode, the
multi-dimensional layout of the source tensor is preserved at the destination.
The dimension of the tensor data ranges from 1d to 5d with the coordinates
specified by the <code class="docutils literal notranslate"><span class="pre">i32</span> <span class="pre">%d0</span> <span class="pre">...</span> <span class="pre">i32</span> <span class="pre">%d4</span></code> arguments.</p>
<ul class="simple">
<li><p>The last argument to these intrinsics is a boolean flag
indicating support for cache_hint. This flag argument must
be a compile-time constant. When set, it indicates a valid
cache_hint (<code class="docutils literal notranslate"><span class="pre">i64</span> <span class="pre">%ch</span></code>) and generates the <code class="docutils literal notranslate"><span class="pre">.L2::cache_hint</span></code>
variant of the PTX instruction.</p></li>
</ul>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-prefetch-tensor">https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-prefetch-tensor</a>.</p>
</section>
</section>
<section id="llvm-nvvm-cp-async-bulk-tensor-prefetch-im2col-3-5-d">
<h4><a class="toc-backref" href="#id103" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.prefetch.im2col.[3-5]d</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-tensor-prefetch-im2col-3-5-d" title="Link to this heading">¶</a></h4>
<section id="id52">
<h5>Syntax:<a class="headerlink" href="#id52" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.prefetch.im2col.3d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.prefetch.im2col.4d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col0</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col1</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.prefetch.im2col.5d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d4</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col0</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col1</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col2</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
</pre></div>
</div>
</section>
<section id="id53">
<h5>Overview:<a class="headerlink" href="#id53" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.tensor.prefetch.im2col.[3-5]d</span></code>’ intrinsics
correspond to the <code class="docutils literal notranslate"><span class="pre">cp.async.bulk.prefetch.tensor.[1-5]d.L2.global*</span></code> set
of PTX instructions. These instructions initiate an asynchronous prefetch
of tensor data from global memory to the L2 cache. In im2col mode, some
dimensions of the source tensor are unrolled into a single dimensional
column at the destination. In this mode, the tensor has to be at least
three-dimensional. Along with the tensor coordinates, im2col offsets are
also specified (denoted by <code class="docutils literal notranslate"><span class="pre">i16</span> <span class="pre">im2col0...i16</span> <span class="pre">%im2col2</span></code>). The number
of im2col offsets is two less than the number of dimensions of the tensor
operation. The last argument to these intrinsics is a boolean flag, with
the same functionality as described in the <code class="docutils literal notranslate"><span class="pre">tile</span></code> mode intrinsics above.</p>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-prefetch-tensor">https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-prefetch-tensor</a>.</p>
</section>
</section>
<section id="llvm-nvvm-cp-async-bulk-tensor-reduce-red-op-tile-1-5-d">
<h4><a class="toc-backref" href="#id104" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.reduce.[red_op].tile.[1-5]d</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-tensor-reduce-red-op-tile-1-5-d" title="Link to this heading">¶</a></h4>
<section id="id55">
<h5>Syntax:<a class="headerlink" href="#id55" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.add.tile.1d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.min.tile.1d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.max.tile.1d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.inc.tile.1d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.dec.tile.1d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.and.tile.1d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.or.tile.1d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.xor.tile.1d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>

<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.</span><span class="p">&lt;</span><span class="err">red_op</span><span class="p">&gt;.</span><span class="err">tile</span><span class="p">.</span><span class="m">2</span><span class="err">d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.</span><span class="p">&lt;</span><span class="err">red_op</span><span class="p">&gt;.</span><span class="err">tile</span><span class="p">.</span><span class="m">3</span><span class="err">d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.</span><span class="p">&lt;</span><span class="err">red_op</span><span class="p">&gt;.</span><span class="err">tile</span><span class="p">.</span><span class="m">4</span><span class="err">d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.</span><span class="p">&lt;</span><span class="err">red_op</span><span class="p">&gt;.</span><span class="err">tile</span><span class="p">.</span><span class="m">5</span><span class="err">d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d4</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
</pre></div>
</div>
</section>
<section id="id56">
<h5>Overview:<a class="headerlink" href="#id56" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.tensor.reduce.&lt;red_op&gt;.tile.[1-5]d</span></code>’ intrinsics
correspond to the <code class="docutils literal notranslate"><span class="pre">cp.reduce.async.bulk.tensor.[1-5]d.*</span></code> set of PTX instructions.
These instructions initiate an asynchronous reduction operation of tensor data
in global memory with the tensor data in shared{::cta} memory, using <code class="docutils literal notranslate"><span class="pre">tile</span></code> mode.
The dimension of the tensor data ranges from 1d to 5d with the coordinates
specified by the <code class="docutils literal notranslate"><span class="pre">i32</span> <span class="pre">%d0</span> <span class="pre">...</span> <span class="pre">i32</span> <span class="pre">%d4</span></code> arguments. The supported reduction
operations are {add, min, max, inc, dec, and, or, xor} as described in the
<code class="docutils literal notranslate"><span class="pre">tile.1d</span></code> intrinsics.</p>
<ul class="simple">
<li><p>The last argument to these intrinsics is a boolean flag
indicating support for cache_hint. This flag argument must
be a compile-time constant. When set, it indicates a valid
cache_hint (<code class="docutils literal notranslate"><span class="pre">i64</span> <span class="pre">%ch</span></code>) and generates the <code class="docutils literal notranslate"><span class="pre">.L2::cache_hint</span></code>
variant of the PTX instruction.</p></li>
</ul>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-reduce-async-bulk-tensor">https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-reduce-async-bulk-tensor</a>.</p>
</section>
</section>
<section id="llvm-nvvm-cp-async-bulk-tensor-reduce-red-op-im2col-3-5-d">
<h4><a class="toc-backref" href="#id105" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.reduce.[red_op].im2col.[3-5]d</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-tensor-reduce-red-op-im2col-3-5-d" title="Link to this heading">¶</a></h4>
<section id="id57">
<h5>Syntax:<a class="headerlink" href="#id57" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.</span><span class="p">&lt;</span><span class="err">red_op</span><span class="p">&gt;.</span><span class="err">im</span><span class="m">2</span><span class="err">col</span><span class="p">.</span><span class="m">3</span><span class="err">d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.</span><span class="p">&lt;</span><span class="err">red_op</span><span class="p">&gt;.</span><span class="err">im</span><span class="m">2</span><span class="err">col</span><span class="p">.</span><span class="m">4</span><span class="err">d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.</span><span class="p">&lt;</span><span class="err">red_op</span><span class="p">&gt;.</span><span class="err">im</span><span class="m">2</span><span class="err">col</span><span class="p">.</span><span class="m">5</span><span class="err">d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d4</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
</pre></div>
</div>
</section>
<section id="id58">
<h5>Overview:<a class="headerlink" href="#id58" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.tensor.reduce.&lt;red_op&gt;.im2col.[3-5]d</span></code>’ intrinsics
correspond to the <code class="docutils literal notranslate"><span class="pre">cp.reduce.async.bulk.tensor.[3-5]d.*</span></code> set of PTX instructions.
These instructions initiate an asynchronous reduction operation of tensor data
in global memory with the tensor data in shared{::cta} memory, using <code class="docutils literal notranslate"><span class="pre">im2col</span></code> mode.
In this mode, the tensor has to be at least three-dimensional. The supported reduction
operations supported are the same as the ones in the tile mode. The last argument to
these intrinsics is a boolean flag, with the same functionality as described in the
<code class="docutils literal notranslate"><span class="pre">tile</span></code> mode intrinsics above.</p>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-reduce-async-bulk-tensor">https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-reduce-async-bulk-tensor</a>.</p>
</section>
</section>
</section>
<section id="warp-group-intrinsics">
<h3><a class="toc-backref" href="#id106" role="doc-backlink">Warp Group Intrinsics</a><a class="headerlink" href="#warp-group-intrinsics" title="Link to this heading">¶</a></h3>
<section id="llvm-nvvm-wgmma-fence-sync-aligned">
<h4><a class="toc-backref" href="#id107" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.wgmma.fence.sync.aligned</span></code>’</a><a class="headerlink" href="#llvm-nvvm-wgmma-fence-sync-aligned" title="Link to this heading">¶</a></h4>
<section id="id60">
<h5>Syntax:<a class="headerlink" href="#id60" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.wgmma.fence.sync.aligned</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="id61">
<h5>Overview:<a class="headerlink" href="#id61" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.wgmma.fence.sync.aligned</span></code>’ intrinsic generates the
<code class="docutils literal notranslate"><span class="pre">wgmma.fence.sync.aligned</span></code> PTX instruction, which establishes an ordering
between prior accesses to any warpgroup registers and subsequent accesses to
the same registers by a <code class="docutils literal notranslate"><span class="pre">wgmma.mma_async</span></code> instruction.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">wgmma.fence</span></code> instruction must be issued by all warps of the warpgroup in
the following locations:</p>
<ul class="simple">
<li><p>Before the first <code class="docutils literal notranslate"><span class="pre">wgmma.mma_async</span></code> operation in a warpgroup.</p></li>
<li><p>Between a register access by a thread in the warpgroup and any
<code class="docutils literal notranslate"><span class="pre">wgmma.mma_async</span></code> instruction that accesses the same registers, except when
these are accumulator register accesses across multiple <code class="docutils literal notranslate"><span class="pre">wgmma.mma_async</span></code>
instructions of the same shape in which case an ordering guarantee is
provided by default.</p></li>
</ul>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-instructions-wgmma-fence">https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-instructions-wgmma-fence</a>.</p>
</section>
</section>
<section id="llvm-nvvm-wgmma-commit-group-sync-aligned">
<h4><a class="toc-backref" href="#id108" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.wgmma.commit_group.sync.aligned</span></code>’</a><a class="headerlink" href="#llvm-nvvm-wgmma-commit-group-sync-aligned" title="Link to this heading">¶</a></h4>
<section id="id62">
<h5>Syntax:<a class="headerlink" href="#id62" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.wgmma.commit_group.sync.aligned</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="id63">
<h5>Overview:<a class="headerlink" href="#id63" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.wgmma.commit_group.sync.aligned</span></code>’ intrinsic generates the
<code class="docutils literal notranslate"><span class="pre">wgmma.commit_group.sync.aligned</span></code> PTX instruction, which creates a new
wgmma-group per warpgroup and batches all prior <code class="docutils literal notranslate"><span class="pre">wgmma.mma_async</span></code>
instructions initiated by the executing warp but not committed to any
wgmma-group into the new wgmma-group. If there are no uncommitted <code class="docutils literal notranslate"><span class="pre">wgmma</span>
<span class="pre">mma_async</span></code> instructions then, <code class="docutils literal notranslate"><span class="pre">wgmma.commit_group</span></code> results in an empty
wgmma-group.</p>
<p>An executing thread can wait for the completion of all <code class="docutils literal notranslate"><span class="pre">wgmma.mma_async</span></code>
operations in a wgmma-group by using <code class="docutils literal notranslate"><span class="pre">wgmma.wait_group</span></code>.</p>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-instructions-wgmma-commit-group">https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-instructions-wgmma-commit-group</a>.</p>
</section>
</section>
<section id="llvm-nvvm-wgmma-wait-group-sync-aligned">
<h4><a class="toc-backref" href="#id109" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.wgmma.wait_group.sync.aligned</span></code>’</a><a class="headerlink" href="#llvm-nvvm-wgmma-wait-group-sync-aligned" title="Link to this heading">¶</a></h4>
<section id="id64">
<h5>Syntax:<a class="headerlink" href="#id64" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.wgmma.wait_group.sync.aligned</span><span class="p">(</span><span class="kt">i64</span><span class="w"> </span><span class="k">immarg</span><span class="w"> </span><span class="err">N</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id65">
<h5>Overview:<a class="headerlink" href="#id65" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.wgmma.wait_group.sync.aligned</span></code>’ intrinsic generates the
<code class="docutils literal notranslate"><span class="pre">wgmma.commit_group.sync.aligned</span> <span class="pre">N</span></code> PTX instruction, which will cause the
executing thread to wait until only <code class="docutils literal notranslate"><span class="pre">N</span></code> or fewer of the most recent
wgmma-groups are pending and all the prior wgmma-groups committed by the
executing threads are complete. For example, when <code class="docutils literal notranslate"><span class="pre">N</span></code> is 0, the executing
thread waits on all the prior wgmma-groups to complete. Operand <code class="docutils literal notranslate"><span class="pre">N</span></code> is an
integer constant.</p>
<p>Accessing the accumulator register or the input register containing the
fragments of matrix A of a <code class="docutils literal notranslate"><span class="pre">wgmma.mma_async</span></code> instruction without first
performing a <code class="docutils literal notranslate"><span class="pre">wgmma.wait_group</span></code> instruction that waits on a wgmma-group
including that <code class="docutils literal notranslate"><span class="pre">wgmma.mma_async</span></code> instruction is undefined behavior.</p>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-instructions-wgmma-wait-group">https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-instructions-wgmma-wait-group</a>.</p>
</section>
</section>
<section id="llvm-nvvm-griddepcontrol">
<h4><a class="toc-backref" href="#id110" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.griddepcontrol.*</span></code>’</a><a class="headerlink" href="#llvm-nvvm-griddepcontrol" title="Link to this heading">¶</a></h4>
<section id="id66">
<h5>Syntax:<a class="headerlink" href="#id66" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.griddepcontrol.launch_dependents</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.griddepcontrol.wait</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="id67">
<h5>Overview:<a class="headerlink" href="#id67" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">griddepcontrol</span></code> intrinsics allows the dependent grids and prerequisite grids as defined by the runtime, to control execution in the following way:</p>
<p><code class="docutils literal notranslate"><span class="pre">griddepcontrol.launch_dependents</span></code> intrinsic signals that the dependents can be scheduled, before the current grid completes. The intrinsic can be invoked by multiple threads in the current CTA and repeated invocations of the intrinsic will have no additional side effects past that of the first invocation.</p>
<p><code class="docutils literal notranslate"><span class="pre">griddepcontrol.wait</span></code> intrinsic causes the executing thread to wait until all prerequisite grids in flight have completed and all the memory operations from the prerequisite grids are performed and made visible to the current grid.</p>
<p>For more information, refer
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-griddepcontrol">PTX ISA</a>.</p>
</section>
</section>
</section>
<section id="other-intrinsics">
<h3><a class="toc-backref" href="#id111" role="doc-backlink">Other Intrinsics</a><a class="headerlink" href="#other-intrinsics" title="Link to this heading">¶</a></h3>
<p>For the full set of NVPTX intrinsics, please see the
<code class="docutils literal notranslate"><span class="pre">include/llvm/IR/IntrinsicsNVVM.td</span></code> file in the LLVM source tree.</p>
</section>
</section>
<section id="linking-with-libdevice">
<span id="libdevice"></span><h2><a class="toc-backref" href="#id112" role="doc-backlink">Linking with Libdevice</a><a class="headerlink" href="#linking-with-libdevice" title="Link to this heading">¶</a></h2>
<p>The CUDA Toolkit comes with an LLVM bitcode library called <code class="docutils literal notranslate"><span class="pre">libdevice</span></code> that
implements many common mathematical functions. This library can be used as a
high-performance math library for any compilers using the LLVM NVPTX target.
The library can be found under <code class="docutils literal notranslate"><span class="pre">nvvm/libdevice/</span></code> in the CUDA Toolkit and
there is a separate version for each compute architecture.</p>
<p>For a list of all math functions implemented in libdevice, see
<a class="reference external" href="http://docs.nvidia.com/cuda/libdevice-users-guide/index.html">libdevice Users Guide</a>.</p>
<p>To accommodate various math-related compiler flags that can affect code
generation of libdevice code, the library code depends on a special LLVM IR
pass (<code class="docutils literal notranslate"><span class="pre">NVVMReflect</span></code>) to handle conditional compilation within LLVM IR. This
pass looks for calls to the <code class="docutils literal notranslate"><span class="pre">&#64;__nvvm_reflect</span></code> function and replaces them
with constants based on the defined reflection parameters. Such conditional
code often follows a pattern:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="nf">my_function</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__nvvm_reflect</span><span class="p">(</span><span class="s">&quot;FASTMATH&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">my_function_fast</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">  </span><span class="k">else</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">my_function_precise</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The default value for all unspecified reflection parameters is zero.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">NVVMReflect</span></code> pass should be executed early in the optimization
pipeline, immediately after the link stage. The <code class="docutils literal notranslate"><span class="pre">internalize</span></code> pass is also
recommended to remove unused math functions from the resulting PTX. For an
input IR module <code class="docutils literal notranslate"><span class="pre">module.bc</span></code>, the following compilation flow is recommended:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">NVVMReflect</span></code> pass will attempt to remove dead code even without
optimizations. This allows potentially incompatible instructions to be avoided
at all optimizations levels by using the <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH</span></code> argument.</p>
<ol class="arabic simple">
<li><p>Save list of external functions in <code class="docutils literal notranslate"><span class="pre">module.bc</span></code></p></li>
<li><p>Link <code class="docutils literal notranslate"><span class="pre">module.bc</span></code> with <code class="docutils literal notranslate"><span class="pre">libdevice.compute_XX.YY.bc</span></code></p></li>
<li><p>Internalize all functions not in list from (1)</p></li>
<li><p>Eliminate all unused internal functions</p></li>
<li><p>Run <code class="docutils literal notranslate"><span class="pre">NVVMReflect</span></code> pass</p></li>
<li><p>Run standard optimization pipeline</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">linkonce</span></code> and <code class="docutils literal notranslate"><span class="pre">linkonce_odr</span></code> linkage types are not suitable for the
libdevice functions. It is possible to link two IR modules that have been
linked against libdevice using different reflection variables.</p>
</div>
<p>Since the <code class="docutils literal notranslate"><span class="pre">NVVMReflect</span></code> pass replaces conditionals with constants, it will
often leave behind dead code of the form:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nl">entry:</span>
<span class="w">  </span><span class="p">..</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">true</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%foo</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%bar</span>
<span class="nl">foo:</span>
<span class="w">  </span><span class="p">..</span>
<span class="nl">bar:</span>
<span class="w">  </span><span class="c">; Dead code</span>
<span class="w">  </span><span class="p">..</span>
</pre></div>
</div>
<p>Therefore, it is recommended that <code class="docutils literal notranslate"><span class="pre">NVVMReflect</span></code> is executed early in the
optimization pipeline before dead-code elimination.</p>
<p>The NVPTX TargetMachine knows how to schedule <code class="docutils literal notranslate"><span class="pre">NVVMReflect</span></code> at the beginning
of your pass manager; just use the following code when setting up your pass
manager and the PassBuilder will use <code class="docutils literal notranslate"><span class="pre">registerPassBuilderCallbacks</span></code> to let
NVPTXTargetMachine::registerPassBuilderCallbacks add the pass to the
pass manager:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TargetMachine</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="n">PassBuilder</span><span class="w"> </span><span class="nf">PB</span><span class="p">(</span><span class="n">TM</span><span class="p">);</span>
<span class="n">ModulePassManager</span><span class="w"> </span><span class="n">MPM</span><span class="p">;</span>
<span class="n">PB</span><span class="p">.</span><span class="n">parsePassPipeline</span><span class="p">(</span><span class="n">MPM</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>
</pre></div>
</div>
<section id="reflection-parameters">
<h3><a class="toc-backref" href="#id113" role="doc-backlink">Reflection Parameters</a><a class="headerlink" href="#reflection-parameters" title="Link to this heading">¶</a></h3>
<p>The libdevice library currently uses the following reflection parameters to
control code generation:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Flag</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__CUDA_FTZ=[0,1]</span></code></p></td>
<td><p>Use optimized code paths that flush subnormals to zero</p></td>
</tr>
</tbody>
</table>
<p>The value of this flag is determined by the “nvvm-reflect-ftz” module flag.
The following sets the ftz flag to 1.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv">!llvm.module.flags</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="nv nv-Anonymous">!0</span><span class="p">}</span>
<span class="nv nv-Anonymous">!0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="kt">i32</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="nv">!&quot;nvvm-reflect-ftz&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">1</span><span class="p">}</span>
</pre></div>
</div>
<p>(<code class="docutils literal notranslate"><span class="pre">i32</span> <span class="pre">4</span></code> indicates that the value set here overrides the value in another
module we link with.  See the <cite>LangRef &lt;LangRef.html#module-flags-metadata&gt;</cite>
for details.)</p>
</section>
</section>
<section id="executing-ptx">
<h2><a class="toc-backref" href="#id114" role="doc-backlink">Executing PTX</a><a class="headerlink" href="#executing-ptx" title="Link to this heading">¶</a></h2>
<p>The most common way to execute PTX assembly on a GPU device is to use the CUDA
Driver API. This API is a low-level interface to the GPU driver and allows for
JIT compilation of PTX code to native GPU machine code.</p>
<p>Initializing the Driver API:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CUdevice</span><span class="w"> </span><span class="n">device</span><span class="p">;</span>
<span class="n">CUcontext</span><span class="w"> </span><span class="n">context</span><span class="p">;</span>

<span class="c1">// Initialize the driver API</span>
<span class="n">cuInit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">// Get a handle to the first compute device</span>
<span class="n">cuDeviceGet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="c1">// Create a compute device context</span>
<span class="n">cuCtxCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">);</span>
</pre></div>
</div>
<p>JIT compiling a PTX string to a device binary:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CUmodule</span><span class="w"> </span><span class="k">module</span><span class="p">;</span>
<span class="n">CUfunction</span><span class="w"> </span><span class="n">function</span><span class="p">;</span>

<span class="c1">// JIT compile a null-terminated PTX string</span>
<span class="n">cuModuleLoadData</span><span class="p">(</span><span class="o">&amp;</span><span class="k">module</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">PTXString</span><span class="p">);</span>

<span class="c1">// Get a handle to the &quot;myfunction&quot; kernel function</span>
<span class="n">cuModuleGetFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">function</span><span class="p">,</span><span class="w"> </span><span class="k">module</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;myfunction&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>For full examples of executing PTX assembly, please see the <a class="reference external" href="https://developer.nvidia.com/cuda-downloads">CUDA Samples</a> distribution.</p>
</section>
<section id="common-issues">
<h2><a class="toc-backref" href="#id115" role="doc-backlink">Common Issues</a><a class="headerlink" href="#common-issues" title="Link to this heading">¶</a></h2>
<section id="ptxas-complains-of-undefined-function-nvvm-reflect">
<h3><a class="toc-backref" href="#id116" role="doc-backlink">ptxas complains of undefined function: __nvvm_reflect</a><a class="headerlink" href="#ptxas-complains-of-undefined-function-nvvm-reflect" title="Link to this heading">¶</a></h3>
<p>When linking with libdevice, the <code class="docutils literal notranslate"><span class="pre">NVVMReflect</span></code> pass must be used. See
<a class="reference internal" href="#libdevice"><span class="std std-ref">Linking with Libdevice</span></a> for more information.</p>
</section>
</section>
<section id="tutorial-a-simple-compute-kernel">
<h2><a class="toc-backref" href="#id117" role="doc-backlink">Tutorial: A Simple Compute Kernel</a><a class="headerlink" href="#tutorial-a-simple-compute-kernel" title="Link to this heading">¶</a></h2>
<p>To start, let us take a look at a simple compute kernel written directly in
LLVM IR. The kernel implements vector addition, where each thread computes one
element of the output vector C from the input vectors A and B.  To make this
easier, we also assume that only a single CTA (thread block) will be launched,
and that it will be one dimensional.</p>
<section id="the-kernel">
<h3><a class="toc-backref" href="#id118" role="doc-backlink">The Kernel</a><a class="headerlink" href="#the-kernel" title="Link to this heading">¶</a></h3>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">target</span><span class="w"> </span><span class="k">datalayout</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v16:16:16-v32:32:32-v64:64:64-v128:128:128-n16:32:64&quot;</span>
<span class="k">target</span><span class="w"> </span><span class="k">triple</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;nvptx64-nvidia-cuda&quot;</span>

<span class="c">; Intrinsic to read X component of thread ID</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.tid.x</span><span class="p">()</span><span class="w"> </span><span class="k">readnone</span><span class="w"> </span><span class="k">nounwind</span>

<span class="k">define</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@kernel</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%A</span><span class="p">,</span>
<span class="w">                    </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%B</span><span class="p">,</span>
<span class="w">                    </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%C</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="c">; What is my ID?</span>
<span class="w">  </span><span class="nv">%id</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.tid.x</span><span class="p">()</span><span class="w"> </span><span class="k">readnone</span><span class="w"> </span><span class="k">nounwind</span>

<span class="w">  </span><span class="c">; Compute pointers into A, B, and C</span>
<span class="w">  </span><span class="nv">%ptrA</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%A</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%id</span>
<span class="w">  </span><span class="nv">%ptrB</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%B</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%id</span>
<span class="w">  </span><span class="nv">%ptrC</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%C</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%id</span>

<span class="w">  </span><span class="c">; Read A, B</span>
<span class="w">  </span><span class="nv">%valA</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%ptrA</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
<span class="w">  </span><span class="nv">%valB</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%ptrB</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>

<span class="w">  </span><span class="c">; Compute C = A + B</span>
<span class="w">  </span><span class="nv">%valC</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">fadd</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%valA</span><span class="p">,</span><span class="w"> </span><span class="nv">%valB</span>

<span class="w">  </span><span class="c">; Store back to C</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%valC</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%ptrC</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>

<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="k">void</span>
<span class="p">}</span>

<span class="nv">!nvvm.annotations</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="nv nv-Anonymous">!0</span><span class="p">}</span>
<span class="nv nv-Anonymous">!0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@kernel</span><span class="p">,</span><span class="w"> </span><span class="nv">!&quot;kernel&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">1</span><span class="p">}</span>
</pre></div>
</div>
<p>We can use the LLVM <code class="docutils literal notranslate"><span class="pre">llc</span></code> tool to directly run the NVPTX code generator:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># llc -mcpu=sm_20 kernel.ll -o kernel.ptx
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you want to generate 32-bit code, change <code class="docutils literal notranslate"><span class="pre">p:64:64:64</span></code> to <code class="docutils literal notranslate"><span class="pre">p:32:32:32</span></code>
in the module data layout string and use <code class="docutils literal notranslate"><span class="pre">nvptx-nvidia-cuda</span></code> as the
target triple.</p>
</div>
<p>The output we get from <code class="docutils literal notranslate"><span class="pre">llc</span></code> (as of LLVM 3.4):</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>//
// Generated by LLVM NVPTX Back-End
//

.version 3.1
.target sm_20
.address_size 64

  // .globl kernel
                                        // @kernel
.visible .entry kernel(
  .param .u64 kernel_param_0,
  .param .u64 kernel_param_1,
  .param .u64 kernel_param_2
)
{
  .reg .f32   %f&lt;4&gt;;
  .reg .s32   %r&lt;2&gt;;
  .reg .s64   %rl&lt;8&gt;;

// %bb.0:                                // %entry
  ld.param.u64    %rl1, [kernel_param_0];
  mov.u32         %r1, %tid.x;
  mul.wide.s32    %rl2, %r1, 4;
  add.s64         %rl3, %rl1, %rl2;
  ld.param.u64    %rl4, [kernel_param_1];
  add.s64         %rl5, %rl4, %rl2;
  ld.param.u64    %rl6, [kernel_param_2];
  add.s64         %rl7, %rl6, %rl2;
  ld.global.f32   %f1, [%rl3];
  ld.global.f32   %f2, [%rl5];
  add.f32         %f3, %f1, %f2;
  st.global.f32   [%rl7], %f3;
  ret;
}
</pre></div>
</div>
</section>
<section id="dissecting-the-kernel">
<h3><a class="toc-backref" href="#id119" role="doc-backlink">Dissecting the Kernel</a><a class="headerlink" href="#dissecting-the-kernel" title="Link to this heading">¶</a></h3>
<p>Now let us dissect the LLVM IR that makes up this kernel.</p>
<section id="data-layout">
<h4><a class="toc-backref" href="#id120" role="doc-backlink">Data Layout</a><a class="headerlink" href="#data-layout" title="Link to this heading">¶</a></h4>
<p>The data layout string determines the size in bits of common data types, their
ABI alignment, and their storage size.  For NVPTX, you should use one of the
following:</p>
<p>32-bit PTX:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">target</span><span class="w"> </span><span class="k">datalayout</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v16:16:16-v32:32:32-v64:64:64-v128:128:128-n16:32:64&quot;</span>
</pre></div>
</div>
<p>64-bit PTX:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">target</span><span class="w"> </span><span class="k">datalayout</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v16:16:16-v32:32:32-v64:64:64-v128:128:128-n16:32:64&quot;</span>
</pre></div>
</div>
</section>
<section id="target-intrinsics">
<h4><a class="toc-backref" href="#id121" role="doc-backlink">Target Intrinsics</a><a class="headerlink" href="#target-intrinsics" title="Link to this heading">¶</a></h4>
<p>In this example, we use the <code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.read.ptx.sreg.tid.x</span></code> intrinsic to
read the X component of the current thread’s ID, which corresponds to a read
of register <code class="docutils literal notranslate"><span class="pre">%tid.x</span></code> in PTX. The NVPTX back-end supports a large set of
intrinsics.  A short list is shown below; please see
<code class="docutils literal notranslate"><span class="pre">include/llvm/IR/IntrinsicsNVVM.td</span></code> for the full list.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Intrinsic</p></th>
<th class="head"><p>CUDA Equivalent</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">i32</span> <span class="pre">&#64;llvm.nvvm.read.ptx.sreg.tid.{x,y,z}</span></code></p></td>
<td><p>threadIdx.{x,y,z}</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">i32</span> <span class="pre">&#64;llvm.nvvm.read.ptx.sreg.ctaid.{x,y,z}</span></code></p></td>
<td><p>blockIdx.{x,y,z}</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">i32</span> <span class="pre">&#64;llvm.nvvm.read.ptx.sreg.ntid.{x,y,z}</span></code></p></td>
<td><p>blockDim.{x,y,z}</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">i32</span> <span class="pre">&#64;llvm.nvvm.read.ptx.sreg.nctaid.{x,y,z}</span></code></p></td>
<td><p>gridDim.{x,y,z}</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">&#64;llvm.nvvm.barrier0()</span></code></p></td>
<td><p>__syncthreads()</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id68">
<h4><a class="toc-backref" href="#id122" role="doc-backlink">Address Spaces</a><a class="headerlink" href="#id68" title="Link to this heading">¶</a></h4>
<p>You may have noticed that all of the pointer types in the LLVM IR example had
an explicit address space specifier. What is address space 1? NVIDIA GPU
devices (generally) have four types of memory:</p>
<ul class="simple">
<li><p>Global: Large, off-chip memory</p></li>
<li><p>Shared: Small, on-chip memory shared among all threads in a CTA</p></li>
<li><p>Local: Per-thread, private memory</p></li>
<li><p>Constant: Read-only memory shared across all threads</p></li>
</ul>
<p>These different types of memory are represented in LLVM IR as address spaces.
There is also a fifth address space used by the NVPTX code generator that
corresponds to the “generic” address space.  This address space can represent
addresses in any other address space (with a few exceptions).  This allows
users to write IR functions that can load/store memory using the same
instructions. Intrinsics are provided to convert pointers between the generic
and non-generic address spaces.</p>
<p>See <a class="reference internal" href="#address-spaces"><span class="std std-ref">Address Spaces</span></a> and <a class="reference internal" href="#nvptx-intrinsics"><span class="std std-ref">NVPTX Intrinsics</span></a> for more information.</p>
</section>
<section id="kernel-metadata">
<h4><a class="toc-backref" href="#id123" role="doc-backlink">Kernel Metadata</a><a class="headerlink" href="#kernel-metadata" title="Link to this heading">¶</a></h4>
<p>In PTX, a function can be either a <cite>kernel</cite> function (callable from the host
program), or a <cite>device</cite> function (callable only from GPU code). You can think
of <cite>kernel</cite> functions as entry-points in the GPU program. To mark an LLVM IR
function as a <cite>kernel</cite> function, we make use of special LLVM metadata. The
NVPTX back-end will look for a named metadata node called
<code class="docutils literal notranslate"><span class="pre">nvvm.annotations</span></code>. This named metadata must contain a list of metadata that
describe the IR. For our purposes, we need to declare a metadata node that
assigns the “kernel” attribute to the LLVM IR function that should be emitted
as a PTX <cite>kernel</cite> function. These metadata nodes take the form:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>!{&lt;function ref&gt;, metadata !&quot;kernel&quot;, i32 1}
</pre></div>
</div>
<p>For the previous example, we have:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv">!nvvm.annotations</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="nv nv-Anonymous">!0</span><span class="p">}</span>
<span class="nv nv-Anonymous">!0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@kernel</span><span class="p">,</span><span class="w"> </span><span class="nv">!&quot;kernel&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">1</span><span class="p">}</span>
</pre></div>
</div>
<p>Here, we have a single metadata declaration in <code class="docutils literal notranslate"><span class="pre">nvvm.annotations</span></code>. This
metadata annotates our <code class="docutils literal notranslate"><span class="pre">&#64;kernel</span></code> function with the <code class="docutils literal notranslate"><span class="pre">kernel</span></code> attribute.</p>
</section>
</section>
<section id="running-the-kernel">
<h3><a class="toc-backref" href="#id124" role="doc-backlink">Running the Kernel</a><a class="headerlink" href="#running-the-kernel" title="Link to this heading">¶</a></h3>
<p>Generating PTX from LLVM IR is all well and good, but how do we execute it on
a real GPU device? The CUDA Driver API provides a convenient mechanism for
loading and JIT compiling PTX to a native GPU device, and launching a kernel.
The API is similar to OpenCL.  A simple example showing how to load and
execute our vector addition code is shown below. Note that for brevity this
code does not perform much error checking!</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You can also use the <code class="docutils literal notranslate"><span class="pre">ptxas</span></code> tool provided by the CUDA Toolkit to offline
compile PTX to machine code (SASS) for a specific GPU architecture. Such
binaries can be loaded by the CUDA Driver API in the same way as PTX. This
can be useful for reducing startup time by precompiling the PTX kernels.</p>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;fstream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cassert&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;cuda.h&quot;</span>


<span class="kt">void</span><span class="w"> </span><span class="nf">checkCudaErrors</span><span class="p">(</span><span class="n">CUresult</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">CUDA_SUCCESS</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// main - Program entry point</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">CUdevice</span><span class="w">    </span><span class="n">device</span><span class="p">;</span>
<span class="w">  </span><span class="n">CUmodule</span><span class="w">    </span><span class="n">cudaModule</span><span class="p">;</span>
<span class="w">  </span><span class="n">CUcontext</span><span class="w">   </span><span class="n">context</span><span class="p">;</span>
<span class="w">  </span><span class="n">CUfunction</span><span class="w">  </span><span class="n">function</span><span class="p">;</span>
<span class="w">  </span><span class="n">CUlinkState</span><span class="w"> </span><span class="n">linker</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w">         </span><span class="n">devCount</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// CUDA initialization</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuInit</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuDeviceGetCount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devCount</span><span class="p">));</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuDeviceGet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>

<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">name</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuDeviceGetName</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">));</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Using CUDA Device [0]: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">devMajor</span><span class="p">,</span><span class="w"> </span><span class="n">devMinor</span><span class="p">;</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuDeviceComputeCapability</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devMajor</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">devMinor</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">));</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Device Compute Capability: &quot;</span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">devMajor</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">devMinor</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">devMajor</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;ERROR: Device 0 is not SM 2.0 or greater</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="s">&quot;kernel.ptx&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;kernel.ptx not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="p">((</span><span class="n">std</span><span class="o">::</span><span class="n">istreambuf_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span>
<span class="w">                    </span><span class="n">std</span><span class="o">::</span><span class="n">istreambuf_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">());</span>

<span class="w">  </span><span class="c1">// Create driver context</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuCtxCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Create module for object</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuModuleLoadDataEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cudaModule</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Get kernel function</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuModuleGetFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">function</span><span class="p">,</span><span class="w"> </span><span class="n">cudaModule</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;kernel&quot;</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Device data</span>
<span class="w">  </span><span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">devBufferA</span><span class="p">;</span>
<span class="w">  </span><span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">devBufferB</span><span class="p">;</span>
<span class="w">  </span><span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">devBufferC</span><span class="p">;</span>

<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devBufferA</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="mi">16</span><span class="p">));</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devBufferB</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="mi">16</span><span class="p">));</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devBufferC</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="mi">16</span><span class="p">));</span>

<span class="w">  </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">hostA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="w">  </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">hostB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="w">  </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">hostC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

<span class="w">  </span><span class="c1">// Populate input</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">hostA</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="n">hostB</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="n">hostC</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">devBufferA</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hostA</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="mi">16</span><span class="p">));</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">devBufferB</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hostB</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="mi">16</span><span class="p">));</span>


<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">blockSizeX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">blockSizeY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">blockSizeZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">gridSizeX</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">gridSizeY</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">gridSizeZ</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Kernel parameters</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">KernelParams</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="n">devBufferA</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">devBufferB</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">devBufferC</span><span class="w"> </span><span class="p">};</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Launching kernel</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Kernel launch</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuLaunchKernel</span><span class="p">(</span><span class="n">function</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeX</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeY</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeZ</span><span class="p">,</span>
<span class="w">                                 </span><span class="n">blockSizeX</span><span class="p">,</span><span class="w"> </span><span class="n">blockSizeY</span><span class="p">,</span><span class="w"> </span><span class="n">blockSizeZ</span><span class="p">,</span>
<span class="w">                                 </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">KernelParams</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Retrieve device data</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuMemcpyDtoH</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hostC</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">devBufferC</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="mi">16</span><span class="p">));</span>


<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Results:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">hostA</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; + &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">hostB</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">hostC</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>


<span class="w">  </span><span class="c1">// Clean up after ourselves</span>
<span class="w">  </span><span class="k">delete</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">hostA</span><span class="p">;</span>
<span class="w">  </span><span class="k">delete</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">hostB</span><span class="p">;</span>
<span class="w">  </span><span class="k">delete</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">hostC</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Clean-up</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">devBufferA</span><span class="p">));</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">devBufferB</span><span class="p">));</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">devBufferC</span><span class="p">));</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuModuleUnload</span><span class="p">(</span><span class="n">cudaModule</span><span class="p">));</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuCtxDestroy</span><span class="p">(</span><span class="n">context</span><span class="p">));</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You will need to link with the CUDA driver and specify the path to cuda.h.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># clang++ sample.cpp -o sample -O2 -g -I/usr/local/cuda-5.5/include -lcuda
</pre></div>
</div>
<p>We don’t need to specify a path to <code class="docutils literal notranslate"><span class="pre">libcuda.so</span></code> since this is installed in a
system location by the driver, not the CUDA toolkit.</p>
<p>If everything goes as planned, you should see the following output when
running the compiled program:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Using CUDA Device [0]: GeForce GTX 680
Device Compute Capability: 3.0
Launching kernel
Results:
0 + 0 = 0
1 + 2 = 3
2 + 4 = 6
3 + 6 = 9
4 + 8 = 12
5 + 10 = 15
6 + 12 = 18
7 + 14 = 21
8 + 16 = 24
9 + 18 = 27
10 + 20 = 30
11 + 22 = 33
12 + 24 = 36
13 + 26 = 39
14 + 28 = 42
15 + 30 = 45
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You will likely see a different device identifier based on your hardware</p>
</div>
</section>
</section>
<section id="tutorial-linking-with-libdevice">
<h2><a class="toc-backref" href="#id125" role="doc-backlink">Tutorial: Linking with Libdevice</a><a class="headerlink" href="#tutorial-linking-with-libdevice" title="Link to this heading">¶</a></h2>
<p>In this tutorial, we show a simple example of linking LLVM IR with the
libdevice library. We will use the same kernel as the previous tutorial,
except that we will compute <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">pow(A,</span> <span class="pre">B)</span></code> instead of <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">A</span> <span class="pre">+</span> <span class="pre">B</span></code>.
Libdevice provides an <code class="docutils literal notranslate"><span class="pre">__nv_powf</span></code> function that we will use.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">target</span><span class="w"> </span><span class="k">datalayout</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v16:16:16-v32:32:32-v64:64:64-v128:128:128-n16:32:64&quot;</span>
<span class="k">target</span><span class="w"> </span><span class="k">triple</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;nvptx64-nvidia-cuda&quot;</span>

<span class="c">; Intrinsic to read X component of thread ID</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.tid.x</span><span class="p">()</span><span class="w"> </span><span class="k">readnone</span><span class="w"> </span><span class="k">nounwind</span>
<span class="c">; libdevice function</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="vg">@__nv_powf</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="p">)</span>

<span class="k">define</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@kernel</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%A</span><span class="p">,</span>
<span class="w">                    </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%B</span><span class="p">,</span>
<span class="w">                    </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%C</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="c">; What is my ID?</span>
<span class="w">  </span><span class="nv">%id</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.tid.x</span><span class="p">()</span><span class="w"> </span><span class="k">readnone</span><span class="w"> </span><span class="k">nounwind</span>

<span class="w">  </span><span class="c">; Compute pointers into A, B, and C</span>
<span class="w">  </span><span class="nv">%ptrA</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%A</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%id</span>
<span class="w">  </span><span class="nv">%ptrB</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%B</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%id</span>
<span class="w">  </span><span class="nv">%ptrC</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%C</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%id</span>

<span class="w">  </span><span class="c">; Read A, B</span>
<span class="w">  </span><span class="nv">%valA</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%ptrA</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
<span class="w">  </span><span class="nv">%valB</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%ptrB</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>

<span class="w">  </span><span class="c">; Compute C = pow(A, B)</span>
<span class="w">  </span><span class="nv">%valC</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="vg">@__nv_powf</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="nv">%valA</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%valB</span><span class="p">)</span>

<span class="w">  </span><span class="c">; Store back to C</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%valC</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%ptrC</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>

<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="k">void</span>
<span class="p">}</span>

<span class="nv">!nvvm.annotations</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="nv nv-Anonymous">!0</span><span class="p">}</span>
<span class="nv nv-Anonymous">!0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@kernel</span><span class="p">,</span><span class="w"> </span><span class="nv">!&quot;kernel&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">1</span><span class="p">}</span>
</pre></div>
</div>
<p>To compile this kernel, we perform the following steps:</p>
<ol class="arabic simple">
<li><p>Link with libdevice</p></li>
<li><p>Internalize all but the public kernel function</p></li>
<li><p>Run <code class="docutils literal notranslate"><span class="pre">NVVMReflect</span></code> and set <code class="docutils literal notranslate"><span class="pre">__CUDA_FTZ</span></code> to 0</p></li>
<li><p>Optimize the linked module</p></li>
<li><p>Codegen the module</p></li>
</ol>
<p>These steps can be performed by the LLVM <code class="docutils literal notranslate"><span class="pre">llvm-link</span></code>, <code class="docutils literal notranslate"><span class="pre">opt</span></code>, and <code class="docutils literal notranslate"><span class="pre">llc</span></code>
tools. In a complete compiler, these steps can also be performed entirely
programmatically by setting up an appropriate pass configuration (see
<a class="reference internal" href="#libdevice"><span class="std std-ref">Linking with Libdevice</span></a>).</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># llvm-link t2.bc libdevice.compute_20.10.bc -o t2.linked.bc
# opt -internalize -internalize-public-api-list=kernel -nvvm-reflect-list=__CUDA_FTZ=0 -nvvm-reflect -O3 t2.linked.bc -o t2.opt.bc
# llc -mcpu=sm_20 t2.opt.bc -o t2.ptx
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">-nvvm-reflect-list=_CUDA_FTZ=0</span></code> is not strictly required, as any
undefined variables will default to zero. It is shown here for evaluation
purposes.</p>
</div>
<p>This gives us the following PTX (excerpt):</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>//
// Generated by LLVM NVPTX Back-End
//

.version 3.1
.target sm_20
.address_size 64

  // .globl kernel
                                        // @kernel
.visible .entry kernel(
  .param .u64 kernel_param_0,
  .param .u64 kernel_param_1,
  .param .u64 kernel_param_2
)
{
  .reg .pred  %p&lt;30&gt;;
  .reg .f32   %f&lt;111&gt;;
  .reg .s32   %r&lt;21&gt;;
  .reg .s64   %rl&lt;8&gt;;

// %bb.0:                                // %entry
  ld.param.u64  %rl2, [kernel_param_0];
  mov.u32   %r3, %tid.x;
  ld.param.u64  %rl3, [kernel_param_1];
  mul.wide.s32  %rl4, %r3, 4;
  add.s64   %rl5, %rl2, %rl4;
  ld.param.u64  %rl6, [kernel_param_2];
  add.s64   %rl7, %rl3, %rl4;
  add.s64   %rl1, %rl6, %rl4;
  ld.global.f32   %f1, [%rl5];
  ld.global.f32   %f2, [%rl7];
  setp.eq.f32 %p1, %f1, 0f3F800000;
  setp.eq.f32 %p2, %f2, 0f00000000;
  or.pred   %p3, %p1, %p2;
  @%p3 bra  BB0_1;
  bra.uni   BB0_2;
BB0_1:
  mov.f32   %f110, 0f3F800000;
  st.global.f32   [%rl1], %f110;
  ret;
BB0_2:                                  // %__nv_isnanf.exit.i
  abs.f32   %f4, %f1;
  setp.gtu.f32  %p4, %f4, 0f7F800000;
  @%p4 bra  BB0_4;
// %bb.3:                                // %__nv_isnanf.exit5.i
  abs.f32   %f5, %f2;
  setp.le.f32 %p5, %f5, 0f7F800000;
  @%p5 bra  BB0_5;
BB0_4:                                  // %.critedge1.i
  add.f32   %f110, %f1, %f2;
  st.global.f32   [%rl1], %f110;
  ret;
BB0_5:                                  // %__nv_isinff.exit.i

  ...

BB0_26:                                 // %__nv_truncf.exit.i.i.i.i.i
  mul.f32   %f90, %f107, 0f3FB8AA3B;
  cvt.rzi.f32.f32 %f91, %f90;
  mov.f32   %f92, 0fBF317200;
  fma.rn.f32  %f93, %f91, %f92, %f107;
  mov.f32   %f94, 0fB5BFBE8E;
  fma.rn.f32  %f95, %f91, %f94, %f93;
  mul.f32   %f89, %f95, 0f3FB8AA3B;
  // inline asm
  ex2.approx.ftz.f32 %f88,%f89;
  // inline asm
  add.f32   %f96, %f91, 0f00000000;
  ex2.approx.f32  %f97, %f96;
  mul.f32   %f98, %f88, %f97;
  setp.lt.f32 %p15, %f107, 0fC2D20000;
  selp.f32  %f99, 0f00000000, %f98, %p15;
  setp.gt.f32 %p16, %f107, 0f42D20000;
  selp.f32  %f110, 0f7F800000, %f99, %p16;
  setp.eq.f32 %p17, %f110, 0f7F800000;
  @%p17 bra   BB0_28;
// %bb.27:
  fma.rn.f32  %f110, %f110, %f108, %f110;
BB0_28:                                 // %__internal_accurate_powf.exit.i
  setp.lt.f32 %p18, %f1, 0f00000000;
  setp.eq.f32 %p19, %f3, 0f3F800000;
  and.pred    %p20, %p18, %p19;
  @!%p20 bra  BB0_30;
  bra.uni   BB0_29;
BB0_29:
  mov.b32    %r9, %f110;
  xor.b32   %r10, %r9, -2147483648;
  mov.b32    %f110, %r10;
BB0_30:                                 // %__nv_powf.exit
  st.global.f32   [%rl1], %f110;
  ret;
}
</pre></div>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="Passes.html" title="LLVM’s Analysis and Transform Passes"
             >next</a> |</li>
        <li class="right" >
          <a href="NewPassManager.html" title="Using the New Pass Manager"
             >previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" >User Guides</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">User Guide for NVPTX Back-end</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2003-2025, LLVM Project.
      Last updated on 2025-03-04.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>