
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>LLVM IR Undefined Behavior (UB) Manual &#8212; LLVM 20.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/llvm-theme.css?v=96924833" />
    <script src="_static/documentation_options.js?v=383a7952"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="XRay Instrumentation" href="XRay.html" />
    <link rel="prev" title="Type Metadata" href="TypeMetadata.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="XRay.html" title="XRay Instrumentation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="TypeMetadata.html" title="Type Metadata"
             accesskey="P">previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="Reference.html" accesskey="U">Reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">LLVM IR Undefined Behavior (UB) Manual</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="https://llvm.org/docs/UserGuides.html">User Guides</a></li>
    <li><a href="https://llvm.org/docs/Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/Contributing.html">Contributing to LLVM</a></li>
    <li><a href="https://llvm.org/docs/HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#discord">Discord</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/FAQ.html">FAQ</a></li>
    <li><a href="https://llvm.org/docs/Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project/">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/UndefinedBehavior.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="llvm-ir-undefined-behavior-ub-manual">
<h1>LLVM IR Undefined Behavior (UB) Manual<a class="headerlink" href="#llvm-ir-undefined-behavior-ub-manual" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#abstract" id="id1">Abstract</a></p></li>
<li><p><a class="reference internal" href="#introduction" id="id2">Introduction</a></p></li>
<li><p><a class="reference internal" href="#immediate-ub" id="id3">Immediate UB</a></p>
<ul>
<li><p><a class="reference internal" href="#time-travel" id="id4">Time Travel</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#deferred-ub" id="id5">Deferred UB</a></p>
<ul>
<li><p><a class="reference internal" href="#undef-values" id="id6">Undef Values</a></p></li>
<li><p><a class="reference internal" href="#poison-values" id="id7">Poison Values</a></p></li>
<li><p><a class="reference internal" href="#propagation-of-poison-through-select" id="id8">Propagation of Poison Through Select</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-freeze-instruction" id="id9">The Freeze Instruction</a></p></li>
<li><p><a class="reference internal" href="#writing-tests-without-undefined-behavior" id="id10">Writing Tests Without Undefined Behavior</a></p></li>
<li><p><a class="reference internal" href="#summary" id="id11">Summary</a></p></li>
</ul>
</nav>
<section id="abstract">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">Abstract</a><a class="headerlink" href="#abstract" title="Link to this heading">¶</a></h2>
<p>This document describes the undefined behavior (UB) in LLVM’s IR, including
undef and poison values, as well as the <code class="docutils literal notranslate"><span class="pre">freeze</span></code> instruction.
We also provide guidelines on when to use each form of UB.</p>
</section>
<section id="introduction">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>Undefined behavior (UB) is used to specify the behavior of corner cases for
which we don’t wish to specify the concrete results. UB is also used to provide
additional constraints to the optimizers (e.g., assumptions that the frontend
guarantees through the language type system or the runtime).
For example, we could specify the result of division by zero as zero, but
since we are not really interested in the result, we say it is UB.</p>
<p>There exist two forms of undefined behavior in LLVM: immediate UB and deferred
UB. The latter comes in two flavors: undef and poison values.
There is also a <code class="docutils literal notranslate"><span class="pre">freeze</span></code> instruction to tame the propagation of deferred UB.
The lattice of values in LLVM is:
immediate UB &gt; poison &gt; undef &gt; freeze(poison) &gt; concrete value.</p>
<p>We explain each of the concepts in detail below.</p>
</section>
<section id="immediate-ub">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">Immediate UB</a><a class="headerlink" href="#immediate-ub" title="Link to this heading">¶</a></h2>
<p>Immediate UB is the most severe form of UB. It should be avoided whenever
possible.
Immediate UB should be used only for operations that trap in most CPUs supported
by LLVM.
Examples include division by zero, dereferencing a null pointer, etc.</p>
<p>The reason that immediate UB should be avoided is that it makes optimizations
such as hoisting a lot harder.
Consider the following example:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@f</span><span class="p">(</span><span class="kt">i1</span><span class="w"> </span><span class="nv">%c</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%c</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%then</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%else</span>

<span class="nl">then:</span>
<span class="w">  </span><span class="nv">%div</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">udiv</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="nv">%v</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%ret</span>

<span class="nl">else:</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%ret</span>

<span class="nl">ret:</span>
<span class="w">  </span><span class="nv">%r</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%div</span><span class="p">,</span><span class="w"> </span><span class="nv">%then</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nv">%else</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%r</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We might be tempted to simplify this function by removing the branching and
executing the division speculatively because <code class="docutils literal notranslate"><span class="pre">%c</span></code> is true most of times.
We would obtain the following IR:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@f</span><span class="p">(</span><span class="kt">i1</span><span class="w"> </span><span class="nv">%c</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%div</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">udiv</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="nv">%v</span>
<span class="w">  </span><span class="nv">%r</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%c</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%div</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%r</span>
<span class="p">}</span>
</pre></div>
</div>
<p>However, this transformation is not correct! Since division triggers UB
when the divisor is zero, we can only execute speculatively if we are sure we
don’t hit that condition.
The function above, when called as <code class="docutils literal notranslate"><span class="pre">f(false,</span> <span class="pre">0)</span></code>, would return 0 before the
optimization, and triggers UB after being optimized.</p>
<p>This example highlights why we minimize the cases that trigger immediate UB
as much as possible.
As a rule of thumb, use immediate UB only for the cases that trap the CPU for
most of the supported architectures.</p>
<section id="time-travel">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">Time Travel</a><a class="headerlink" href="#time-travel" title="Link to this heading">¶</a></h3>
<p>Immediate UB in LLVM IR allows the so-called time travelling. What this means
is that if a program triggers UB, then we are not required to preserve any of
its observable behavior, including I/O.
For example, the following function triggers UB after calling <code class="docutils literal notranslate"><span class="pre">printf</span></code>:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@fn</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@printf</span><span class="p">(...)</span><span class="w"> </span><span class="k">willreturn</span>
<span class="w">  </span><span class="k">unreachable</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since we know that <code class="docutils literal notranslate"><span class="pre">printf</span></code> will always return, and because LLVM’s UB can
time-travel, it is legal to remove the call to <code class="docutils literal notranslate"><span class="pre">printf</span></code> altogether and
optimize the function to simply:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@fn</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">unreachable</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="deferred-ub">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">Deferred UB</a><a class="headerlink" href="#deferred-ub" title="Link to this heading">¶</a></h2>
<p>Deferred UB is a lighter form of UB. It enables instructions to be executed
speculatively while marking some corner cases as having erroneous values.
Deferred UB should be used for cases where the semantics offered by common
CPUs differ, but the CPU does not trap.</p>
<p>As an example, consider the shift instructions. The x86 and ARM architectures
offer different semantics when the shift amount is equal to or greater than
the bitwidth.
We could solve this tension in one of two ways: 1) pick one of the x86/ARM
semantics for LLVM, which would make the code emitted for the other architecture
slower; 2) define that case as yielding <code class="docutils literal notranslate"><span class="pre">poison</span></code>.
LLVM chose the latter option. For frontends for languages like C or C++
(e.g., clang), they can map shifts in the source program directly to a shift in
LLVM IR, since the semantics of C and C++ define such shifts as UB.
For languages that offer strong semantics, they must use the value of the shift
conditionally, e.g.:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@x86_shift</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%mask</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="m">31</span>
<span class="w">  </span><span class="nv">%shift</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">shl</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="nv">%mask</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%shift</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There are two deferred UB values in LLVM: <code class="docutils literal notranslate"><span class="pre">undef</span></code> and <code class="docutils literal notranslate"><span class="pre">poison</span></code>, which we
describe next.</p>
<section id="undef-values">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">Undef Values</a><a class="headerlink" href="#undef-values" title="Link to this heading">¶</a></h3>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Undef values are deprecated and should be used only when strictly necessary.
Uses of undef values should be restricted to representing loads of
uninitialized memory. This is the only part of the IR semantics that cannot
be replaced with alternatives yet (work in ongoing).</p>
</div>
<p>An undef value represents any value of a given type. Moreover, each use of
an instruction that depends on undef can observe a different value.
For example:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@fn</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%add</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="k">undef</span><span class="p">,</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="nv">%ret</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%add</span><span class="p">,</span><span class="w"> </span><span class="nv">%add</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%ret</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Unsurprisingly, the first addition yields <code class="docutils literal notranslate"><span class="pre">undef</span></code>.
However, the result of the second addition is more subtle. We might be tempted
to think that it yields an even number. But it might not be!
Since each (transitive) use of <code class="docutils literal notranslate"><span class="pre">undef</span></code> can observe a different value,
the second addition is equivalent to <code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">i32</span> <span class="pre">undef,</span> <span class="pre">undef</span></code>, which is
equivalent to <code class="docutils literal notranslate"><span class="pre">undef</span></code>.
Hence, the function above is equivalent to:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@fn</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="k">undef</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Each call to this function may observe a different value, namely any 32-bit
number (even and odd).</p>
<p>Because each use of undef can observe a different value, some optimizations
are wrong if we are not sure a value is not undef.
Consider a function that multiplies a number by 2:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@fn</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%mul2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">mul</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%v</span><span class="p">,</span><span class="w"> </span><span class="m">2</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%mul2</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This function is guaranteed to return an even number, even if <code class="docutils literal notranslate"><span class="pre">%v</span></code> is
undef.
However, as we’ve seen above, the following function does not:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@fn</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%mul2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%v</span><span class="p">,</span><span class="w"> </span><span class="nv">%v</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%mul2</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This optimization is wrong just because undef values exist, even if they are
not used in this part of the program as LLVM has no way to tell if <code class="docutils literal notranslate"><span class="pre">%v</span></code> is
undef or not.</p>
<p>Looking at the value lattice, <code class="docutils literal notranslate"><span class="pre">undef</span></code> values can only be replaced with either
a <code class="docutils literal notranslate"><span class="pre">freeze</span></code> instruction or a concrete value.
A consequence is that giving undef as an operand to an instruction that triggers
UB for some values of that operand makes the program UB. For example,
<code class="docutils literal notranslate"><span class="pre">udiv</span> <span class="pre">%x,</span> <span class="pre">undef</span></code> is UB since we replace undef with 0 (<code class="docutils literal notranslate"><span class="pre">udiv</span> <span class="pre">%x,</span> <span class="pre">0</span></code>),
becoming obvious that it is UB.</p>
</section>
<section id="poison-values">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Poison Values</a><a class="headerlink" href="#poison-values" title="Link to this heading">¶</a></h3>
<p>Poison values are a stronger form of deferred UB than undef. They still
allow instructions to be executed speculatively, but they taint the whole
expression DAG (with some exceptions), akin to floating point NaN values.</p>
<p>Example:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@fn</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%add</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="k">nsw</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="nv">%b</span>
<span class="w">  </span><span class="nv">%ret</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="k">nsw</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%add</span><span class="p">,</span><span class="w"> </span><span class="nv">%c</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%ret</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">nsw</span></code> attribute in the additions indicates that the operation yields
poison if there is a signed overflow.
If the first addition overflows, <code class="docutils literal notranslate"><span class="pre">%add</span></code> is poison and thus <code class="docutils literal notranslate"><span class="pre">%ret</span></code> is also
poison since it taints the whole expression DAG.</p>
<p>Poison values can be replaced with any value of type (undef, concrete values,
or a <code class="docutils literal notranslate"><span class="pre">freeze</span></code> instruction).</p>
</section>
<section id="propagation-of-poison-through-select">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Propagation of Poison Through Select</a><a class="headerlink" href="#propagation-of-poison-through-select" title="Link to this heading">¶</a></h3>
<p>Most instructions return poison if any of their inputs is poison.
A notable exception is the <code class="docutils literal notranslate"><span class="pre">select</span></code> instruction, which is poison if and
only if the condition is poison or the selected value is poison.
This means that <code class="docutils literal notranslate"><span class="pre">select</span></code> acts as a barrier for poison propagation, which
impacts which optimizations can be performed.</p>
<p>For example, consider the following function:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@fn</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%cmp1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">ne</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="nv">%cmp2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">ugt</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="nv">%y</span>
<span class="w">  </span><span class="nv">%and</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp1</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp2</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%and</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It is not correct to optimize the <code class="docutils literal notranslate"><span class="pre">select</span></code> into an <code class="docutils literal notranslate"><span class="pre">and</span></code> because when
<code class="docutils literal notranslate"><span class="pre">%cmp1</span></code> is false, the <code class="docutils literal notranslate"><span class="pre">select</span></code> is only poison if <code class="docutils literal notranslate"><span class="pre">%x</span></code> is poison, while
the <code class="docutils literal notranslate"><span class="pre">and</span></code> below is poison if either <code class="docutils literal notranslate"><span class="pre">%x</span></code> or <code class="docutils literal notranslate"><span class="pre">%y</span></code> are poison.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@fn</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%cmp1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">ne</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="nv">%cmp2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">ugt</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="nv">%y</span>
<span class="w">  </span><span class="nv">%and</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp1</span><span class="p">,</span><span class="w"> </span><span class="nv">%cmp2</span><span class="w">     </span><span class="c">;; poison if %x or %y are poison</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%and</span>
<span class="p">}</span>
</pre></div>
</div>
<p>However, the optimization is possible if all operands of the values are used in
the condition (notice the flipped operands in the <code class="docutils literal notranslate"><span class="pre">select</span></code>):</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@fn</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%cmp1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">ne</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="nv">%cmp2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">ugt</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="nv">%y</span>
<span class="w">  </span><span class="nv">%and</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp2</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp1</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span>
<span class="w">  </span><span class="c">; ok to replace with:</span>
<span class="w">  </span><span class="nv">%and</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp1</span><span class="p">,</span><span class="w"> </span><span class="nv">%cmp2</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%and</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="the-freeze-instruction">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">The Freeze Instruction</a><a class="headerlink" href="#the-freeze-instruction" title="Link to this heading">¶</a></h2>
<p>Both undef and poison values sometimes propagate too much down an expression
DAG. Undef values because each transitive use can observe a different value,
and poison values because they make the whole DAG poison.
There are some cases where it is important to stop such propagation.
This is where the <code class="docutils literal notranslate"><span class="pre">freeze</span></code> instruction comes in.</p>
<p>Take the following example function:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@fn</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="nl">entry:</span>
<span class="w">   </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%loop</span>

<span class="nl">loop:</span>
<span class="w">   </span><span class="nv">%i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nv">%entry</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%i2</span><span class="p">,</span><span class="w"> </span><span class="nv">%loop.end</span><span class="w"> </span><span class="p">]</span>
<span class="w">   </span><span class="nv">%cond</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">ule</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="nv">%n</span>
<span class="w">   </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cond</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%loop.cont</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%exit</span>

<span class="nl">loop.cont:</span>
<span class="w">   </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%c</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%then</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%else</span>

<span class="w"> </span><span class="nl">then:</span>
<span class="w">   </span><span class="p">...</span>
<span class="w">   </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%loop.end</span>

<span class="w"> </span><span class="nl">else:</span>
<span class="w">   </span><span class="p">...</span>
<span class="w">   </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%loop.end</span>

<span class="w"> </span><span class="nl">loop.end:</span>
<span class="w">   </span><span class="nv">%i2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="m">1</span>
<span class="w">   </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%loop</span>

<span class="w"> </span><span class="nl">exit:</span>
<span class="w">   </span><span class="p">...</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Imagine we want to perform loop unswitching on the loop above since the branch
condition inside the loop is loop invariant.
We would obtain the following IR:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@fn</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="nl">entry:</span>
<span class="w">   </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%c</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%then</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%else</span>

<span class="nl">then:</span>
<span class="w">   </span><span class="nv">%i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nv">%entry</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%i2</span><span class="p">,</span><span class="w"> </span><span class="nv">%then.cont</span><span class="w"> </span><span class="p">]</span>
<span class="w">   </span><span class="nv">%cond</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">ule</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="nv">%n</span>
<span class="w">   </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cond</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%then.cont</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%exit</span>

<span class="nl">then.cont:</span>
<span class="w">   </span><span class="p">...</span>
<span class="w">   </span><span class="nv">%i2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="m">1</span>
<span class="w">   </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%then</span>

<span class="nl">else:</span>
<span class="w">   </span><span class="nv">%i3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nv">%entry</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%i4</span><span class="p">,</span><span class="w"> </span><span class="nv">%else.cont</span><span class="w"> </span><span class="p">]</span>
<span class="w">   </span><span class="nv">%cond</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">ule</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i3</span><span class="p">,</span><span class="w"> </span><span class="nv">%n</span>
<span class="w">   </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cond</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%else.cont</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%exit</span>

<span class="nl">else.cont:</span>
<span class="w">   </span><span class="p">...</span>
<span class="w">   </span><span class="nv">%i4</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i3</span><span class="p">,</span><span class="w"> </span><span class="m">1</span>
<span class="w">   </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%else</span>

<span class="w"> </span><span class="nl">exit:</span>
<span class="w">   </span><span class="p">...</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>There is a subtle catch: when the function is called with <code class="docutils literal notranslate"><span class="pre">%n</span></code> being zero,
the original function did not branch on <code class="docutils literal notranslate"><span class="pre">%c</span></code>, while the optimized one does.
Branching on a deferred UB value is immediate UB, hence the transformation is
wrong in general because <code class="docutils literal notranslate"><span class="pre">%c</span></code> may be undef or poison.</p>
<p>Cases like this need a way to tame deferred UB values. This is exactly what the
<code class="docutils literal notranslate"><span class="pre">freeze</span></code> instruction is for!
When given a concrete value as argument, <code class="docutils literal notranslate"><span class="pre">freeze</span></code> is a no-op, returning the
argument as-is. When given an undef or poison value, <code class="docutils literal notranslate"><span class="pre">freeze</span></code> returns a
non-deterministic value of the type.
This is not the same as undef: the value returned by <code class="docutils literal notranslate"><span class="pre">freeze</span></code> is the same
for all users.</p>
<p>Branching on a value returned by <code class="docutils literal notranslate"><span class="pre">freeze</span></code> is always safe since it either
evaluates to true or false consistently.
We can make the loop unswitching optimization above correct as follows:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@fn</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%c2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">freeze</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%c</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%c2</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%then</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%else</span>
</pre></div>
</div>
</section>
<section id="writing-tests-without-undefined-behavior">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">Writing Tests Without Undefined Behavior</a><a class="headerlink" href="#writing-tests-without-undefined-behavior" title="Link to this heading">¶</a></h2>
<p>When writing tests, it is important to ensure that they don’t trigger UB
unnecessarily. Some automated test reduces sometimes use undef or poison
values as dummy values, but this is considered a bad practice if this leads
to triggering UB.</p>
<p>For example, imagine that we want to write a test and we don’t care about the
particular divisor value because our optimization kicks in regardless:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@fn</span><span class="p">(</span><span class="kt">i8</span><span class="w"> </span><span class="nv">%a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="nv">%div</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">udiv</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="k">poison</span>
<span class="w">   </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The issue with this test is that it triggers immediate UB. This prevents
verification tools like Alive from validating the correctness of the
optimization. Hence, it is considered a bad practice to have tests with
unnecessary immediate UB (unless that is exactly what the test is for).
The test above should use a dummy function argument instead of using poison:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@fn</span><span class="p">(</span><span class="kt">i8</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%dummy</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="nv">%div</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">udiv</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="nv">%dummy</span>
<span class="w">   </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Common sources of immediate UB in tests include branching on undef/poison
conditions and dereferencing undef/poison/null pointers.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you need a placeholder value to pass as an argument to an instruction
that may trigger UB, add a new argument to the function rather than using
undef or poison.</p>
</div>
</section>
<section id="summary">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Summary</a><a class="headerlink" href="#summary" title="Link to this heading">¶</a></h2>
<p>Undefined behavior (UB) in LLVM IR consists of two well-defined concepts:
immediate and deferred UB (undef and poison values).
Passing deferred UB values to certain operations leads to immediate UB.
This can be avoided in some cases through the use of the <code class="docutils literal notranslate"><span class="pre">freeze</span></code>
instruction.</p>
<p>The lattice of values in LLVM is:
immediate UB &gt; poison &gt; undef &gt; freeze(poison) &gt; concrete value.
It is only valid to transform values from the left to the right (e.g., a poison
value can be replaced with a concrete value, but not the other way around).</p>
<p>Undef is now deprecated and should be used only to represent loads of
uninitialized memory.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="XRay.html" title="XRay Instrumentation"
             >next</a> |</li>
        <li class="right" >
          <a href="TypeMetadata.html" title="Type Metadata"
             >previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="Reference.html" >Reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">LLVM IR Undefined Behavior (UB) Manual</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2003-2025, LLVM Project.
      Last updated on 2025-03-04.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>