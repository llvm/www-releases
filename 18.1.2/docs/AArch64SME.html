
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Support for AArch64 Scalable Matrix Extension in LLVM &#8212; LLVM 18.1.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/llvm-theme.css?v=be84393e" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=2f6c9c8e"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="How To Add A Constrained Floating-Point Intrinsic" href="AddingConstrainedIntrinsics.html" />
    <link rel="prev" title="User Guides" href="UserGuides.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="AddingConstrainedIntrinsics.html" title="How To Add A Constrained Floating-Point Intrinsic"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="UserGuides.html" title="User Guides"
             accesskey="P">previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" accesskey="U">User Guides</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Support for AArch64 Scalable Matrix Extension in LLVM</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="https://llvm.org/docs/UserGuides.html">User Guides</a></li>
    <li><a href="https://llvm.org/docs/Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/Contributing.html">Contributing to LLVM</a></li>
    <li><a href="https://llvm.org/docs/HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#irc">IRC</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/FAQ.html">FAQ</a></li>
    <li><a href="https://llvm.org/docs/Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project/">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/AArch64SME.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="support-for-aarch64-scalable-matrix-extension-in-llvm">
<h1>Support for AArch64 Scalable Matrix Extension in LLVM<a class="headerlink" href="#support-for-aarch64-scalable-matrix-extension-in-llvm" title="Permalink to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id2">1. Introduction</a></p></li>
<li><p><a class="reference internal" href="#handling-pstate-sm" id="id3">2. Handling PSTATE.SM</a></p>
<ul>
<li><p><a class="reference internal" href="#restrictions-on-attributes" id="id4">Restrictions on attributes</a></p></li>
<li><p><a class="reference internal" href="#compiler-inserted-streaming-mode-changes" id="id5">Compiler inserted streaming-mode changes</a></p></li>
<li><p><a class="reference internal" href="#example-of-preserving-state" id="id6">Example of preserving state</a></p></li>
<li><p><a class="reference internal" href="#instruction-selection-nodes" id="id7">Instruction Selection Nodes</a></p></li>
<li><p><a class="reference internal" href="#unchained-function-calls" id="id8">Unchained Function calls</a></p></li>
<li><p><a class="reference internal" href="#functions-with-attribute-arm-locally-streaming" id="id9">Functions with __attribute__((arm_locally_streaming))</a></p></li>
<li><p><a class="reference internal" href="#preventing-the-use-of-illegal-instructions-in-streaming-mode" id="id10">Preventing the use of illegal instructions in Streaming Mode</a></p></li>
<li><p><a class="reference internal" href="#other-things-to-consider" id="id11">Other things to consider</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#handling-pstate-za" id="id12">3. Handling PSTATE.ZA</a></p>
<ul>
<li><p><a class="reference internal" href="#setting-up-a-lazy-save" id="id13">Setting up a lazy-save</a></p></li>
<li><p><a class="reference internal" href="#committing-a-lazy-save" id="id14">Committing a lazy-save</a></p></li>
<li><p><a class="reference internal" href="#exception-handling-and-za" id="id15">Exception handling and ZA</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#types" id="id16">4. Types</a></p>
<ul>
<li><p><a class="reference internal" href="#aarch64-predicate-as-counter-type" id="id17">AArch64 Predicate-as-Counter Type</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#references" id="id18">5. References</a></p></li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">1. Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this heading">¶</a></h2>
<p>The <a class="reference internal" href="#aarch64-sme-acle"><span class="std std-ref">AArch64 SME ACLE</span></a> provides a number of
attributes for users to control PSTATE.SM and PSTATE.ZA.
The <a class="reference internal" href="#aarch64-sme-abi"><span class="std std-ref">AArch64 SME ABI</span></a> describes the requirements for
calls between functions when at least one of those functions uses PSTATE.SM or
PSTATE.ZA.</p>
<p>This document describes how the SME ACLE attributes map to LLVM IR
attributes and how LLVM lowers these attributes to implement the rules and
requirements of the ABI.</p>
<p>Below we describe the LLVM IR attributes and their relation to the C/C++
level ACLE attributes:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">aarch64_pstate_sm_enabled</span></code></dt><dd><p>is used for functions with <code class="docutils literal notranslate"><span class="pre">__attribute__((arm_streaming))</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aarch64_pstate_sm_compatible</span></code></dt><dd><p>is used for functions with <code class="docutils literal notranslate"><span class="pre">__attribute__((arm_streaming_compatible))</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aarch64_pstate_sm_body</span></code></dt><dd><p>is used for functions with <code class="docutils literal notranslate"><span class="pre">__attribute__((arm_locally_streaming))</span></code> and is
only valid on function definitions (not declarations)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aarch64_pstate_za_new</span></code></dt><dd><p>is used for functions with <code class="docutils literal notranslate"><span class="pre">__attribute__((arm_new_za))</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aarch64_pstate_za_shared</span></code></dt><dd><p>is used for functions with <code class="docutils literal notranslate"><span class="pre">__attribute__((arm_shared_za))</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aarch64_pstate_za_preserved</span></code></dt><dd><p>is used for functions with <code class="docutils literal notranslate"><span class="pre">__attribute__((arm_preserves_za))</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">aarch64_expanded_pstate_za</span></code></dt><dd><p>is used for functions with <code class="docutils literal notranslate"><span class="pre">__attribute__((arm_new_za))</span></code></p>
</dd>
</dl>
<p>Clang must ensure that the above attributes are added both to the
function’s declaration/definition as well as to their call-sites. This is
important for calls to attributed function pointers, where there is no
definition or declaration available.</p>
</section>
<section id="handling-pstate-sm">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">2. Handling PSTATE.SM</a><a class="headerlink" href="#handling-pstate-sm" title="Permalink to this heading">¶</a></h2>
<p>When changing PSTATE.SM the execution of FP/vector operations may be transferred
to another processing element. This has three important implications:</p>
<ul class="simple">
<li><p>The runtime SVE vector length may change.</p></li>
<li><p>The contents of FP/AdvSIMD/SVE registers are zeroed.</p></li>
<li><p>The set of allowable instructions changes.</p></li>
</ul>
<p>This leads to certain restrictions on IR and optimizations. For example, it
is undefined behaviour to share vector-length dependent state between functions
that may operate with different values for PSTATE.SM. Front-ends must honour
these restrictions when generating LLVM IR.</p>
<p>Even though the runtime SVE vector length may change, for the purpose of LLVM IR
and almost all parts of CodeGen we can assume that the runtime value for
<code class="docutils literal notranslate"><span class="pre">vscale</span></code> does not. If we let the compiler insert the appropriate <code class="docutils literal notranslate"><span class="pre">smstart</span></code>
and <code class="docutils literal notranslate"><span class="pre">smstop</span></code> instructions around call boundaries, then the effects on SVE
state can be mitigated. By limiting the state changes to a very brief window
around the call we can control how the operations are scheduled and how live
values remain preserved between state transitions.</p>
<p>In order to control PSTATE.SM at this level of granularity, we use function and
callsite attributes rather than intrinsics.</p>
<section id="restrictions-on-attributes">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">Restrictions on attributes</a><a class="headerlink" href="#restrictions-on-attributes" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>It is undefined behaviour to pass or return (pointers to) scalable vector
objects to/from functions which may use a different SVE vector length.
This includes functions with a non-streaming interface, but marked with
<code class="docutils literal notranslate"><span class="pre">aarch64_pstate_sm_body</span></code>.</p></li>
<li><p>It is not allowed for a function to be decorated with both
<code class="docutils literal notranslate"><span class="pre">aarch64_pstate_sm_compatible</span></code> and <code class="docutils literal notranslate"><span class="pre">aarch64_pstate_sm_enabled</span></code>.</p></li>
<li><p>It is not allowed for a function to be decorated with both
<code class="docutils literal notranslate"><span class="pre">aarch64_pstate_za_new</span></code> and <code class="docutils literal notranslate"><span class="pre">aarch64_pstate_za_preserved</span></code>.</p></li>
<li><p>It is not allowed for a function to be decorated with both
<code class="docutils literal notranslate"><span class="pre">aarch64_pstate_za_new</span></code> and <code class="docutils literal notranslate"><span class="pre">aarch64_pstate_za_shared</span></code>.</p></li>
</ul>
<p>These restrictions also apply in the higher level SME ACLE, which means we can
emit diagnostics in Clang to signal users about incorrect behaviour.</p>
</section>
<section id="compiler-inserted-streaming-mode-changes">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">Compiler inserted streaming-mode changes</a><a class="headerlink" href="#compiler-inserted-streaming-mode-changes" title="Permalink to this heading">¶</a></h3>
<p>The table below describes the transitions in PSTATE.SM the compiler has to
account for when doing calls between functions with different attributes.
In this table, we use the following abbreviations:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">N</span></code></dt><dd><p>functions with a normal interface (PSTATE.SM=0 on entry, PSTATE.SM=0 on
return)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">S</span></code></dt><dd><p>functions with a Streaming interface (PSTATE.SM=1 on entry, PSTATE.SM=1
on return)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SC</span></code></dt><dd><p>functions with a Streaming-Compatible interface (PSTATE.SM can be
either 0 or 1 on entry, and is unchanged on return).</p>
</dd>
</dl>
<p>Functions with <code class="docutils literal notranslate"><span class="pre">__attribute__((arm_locally_streaming))</span></code> are excluded from this
table because for the caller the attribute is synonymous to ‘streaming’, and
for the callee it is merely an implementation detail that is explicitly not
exposed to the caller.</p>
<table class="docutils align-default" id="id1">
<caption><span class="caption-text">Combinations of calls for functions with different attributes</span><a class="headerlink" href="#id1" title="Permalink to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>From</p></th>
<th class="head"><p>To</p></th>
<th class="head"><p>Before call</p></th>
<th class="head"><p>After call</p></th>
<th class="head"><p>After exception</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>N</p></td>
<td><p>N</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>N</p></td>
<td><p>S</p></td>
<td><p>SMSTART</p></td>
<td><p>SMSTOP</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>N</p></td>
<td><p>SC</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>S</p></td>
<td><p>N</p></td>
<td><p>SMSTOP</p></td>
<td><p>SMSTART</p></td>
<td><p>SMSTART</p></td>
</tr>
<tr class="row-even"><td><p>S</p></td>
<td><p>S</p></td>
<td></td>
<td></td>
<td><p>SMSTART</p></td>
</tr>
<tr class="row-odd"><td><p>S</p></td>
<td><p>SC</p></td>
<td></td>
<td></td>
<td><p>SMSTART</p></td>
</tr>
<tr class="row-even"><td><p>SC</p></td>
<td><p>N</p></td>
<td><p>If PSTATE.SM before call is 1,
then SMSTOP</p></td>
<td><p>If PSTATE.SM before call is 1,
then SMSTART</p></td>
<td><p>If PSTATE.SM before call is 1,
then SMSTART</p></td>
</tr>
<tr class="row-odd"><td><p>SC</p></td>
<td><p>S</p></td>
<td><p>If PSTATE.SM before call is 0,
then SMSTART</p></td>
<td><p>If PSTATE.SM before call is 0,
then SMSTOP</p></td>
<td><p>If PSTATE.SM before call is 1,
then SMSTART</p></td>
</tr>
<tr class="row-even"><td><p>SC</p></td>
<td><p>SC</p></td>
<td></td>
<td></td>
<td><p>If PSTATE.SM before call is 1,
then SMSTART</p></td>
</tr>
</tbody>
</table>
<p>Because changing PSTATE.SM zeroes the FP/vector registers, it is best to emit
the <code class="docutils literal notranslate"><span class="pre">smstart</span></code> and <code class="docutils literal notranslate"><span class="pre">smstop</span></code> instructions before register allocation, so that
the register allocator can spill/reload registers around the mode change.</p>
<p>The compiler should also have sufficient information on which operations are
part of the call/function’s arguments/result and which operations are part of
the function’s body, so that it can place the mode changes in exactly the right
position. The suitable place to do this seems to be SelectionDAG, where it lowers
the call’s arguments/return values to implement the specified calling convention.
SelectionDAG provides Chains and Glue to specify the order of operations and give
preliminary control over the instruction’s scheduling.</p>
</section>
<section id="example-of-preserving-state">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">Example of preserving state</a><a class="headerlink" href="#example-of-preserving-state" title="Permalink to this heading">¶</a></h3>
<p>When passing and returning a <code class="docutils literal notranslate"><span class="pre">float</span></code> value to/from a function
that has a streaming interface from a function that has a normal interface, the
call-site will need to ensure that the argument/result registers are preserved
and that no other code is scheduled in between the <code class="docutils literal notranslate"><span class="pre">smstart/smstop</span></code> and the call.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="vg">@foo</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="nv">%f</span><span class="p">)</span><span class="w"> </span><span class="k">nounwind</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%res</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="vg">@bar</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="nv">%f</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;aarch64_pstate_sm_enabled&quot;</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%res</span>
<span class="p">}</span>

<span class="k">declare</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="vg">@bar</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;aarch64_pstate_sm_enabled&quot;</span>
</pre></div>
</div>
<p>The program needs to preserve the value of the floating point argument and
return value in register <code class="docutils literal notranslate"><span class="pre">s0</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>foo:                                    // @foo
// %bb.0:
        stp     d15, d14, [sp, #-80]!           // 16-byte Folded Spill
        stp     d13, d12, [sp, #16]             // 16-byte Folded Spill
        stp     d11, d10, [sp, #32]             // 16-byte Folded Spill
        stp     d9, d8, [sp, #48]               // 16-byte Folded Spill
        str     x30, [sp, #64]                  // 8-byte Folded Spill
        str     s0, [sp, #76]                   // 4-byte Folded Spill
        smstart sm
        ldr     s0, [sp, #76]                   // 4-byte Folded Reload
        bl      bar
        str     s0, [sp, #76]                   // 4-byte Folded Spill
        smstop  sm
        ldp     d9, d8, [sp, #48]               // 16-byte Folded Reload
        ldp     d11, d10, [sp, #32]             // 16-byte Folded Reload
        ldp     d13, d12, [sp, #16]             // 16-byte Folded Reload
        ldr     s0, [sp, #76]                   // 4-byte Folded Reload
        ldr     x30, [sp, #64]                  // 8-byte Folded Reload
        ldp     d15, d14, [sp], #80             // 16-byte Folded Reload
        ret
</pre></div>
</div>
<p>Setting the correct register masks on the ISD nodes and inserting the
<code class="docutils literal notranslate"><span class="pre">smstart/smstop</span></code> in the right places should ensure this is done correctly.</p>
</section>
<section id="instruction-selection-nodes">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Instruction Selection Nodes</a><a class="headerlink" href="#instruction-selection-nodes" title="Permalink to this heading">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>AArch64ISD::SMSTART Chain, [SM|ZA|Both], CurrentState, ExpectedState[, RegMask]
AArch64ISD::SMSTOP  Chain, [SM|ZA|Both], CurrentState, ExpectedState[, RegMask]
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">SMSTART/SMSTOP</span></code> nodes take <code class="docutils literal notranslate"><span class="pre">CurrentState</span></code> and <code class="docutils literal notranslate"><span class="pre">ExpectedState</span></code> operand for
the case of a conditional SMSTART/SMSTOP. The instruction will only be executed
if CurrentState != ExpectedState.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">CurrentState</span></code> and <code class="docutils literal notranslate"><span class="pre">ExpectedState</span></code> can be evaluated at compile-time
(i.e. they are both constants) then an unconditional <code class="docutils literal notranslate"><span class="pre">smstart/smstop</span></code>
instruction is emitted. Otherwise the node is matched to a Pseudo instruction
which expands to a compare/branch and a <code class="docutils literal notranslate"><span class="pre">smstart/smstop</span></code>. This is necessary to
implement transitions from <code class="docutils literal notranslate"><span class="pre">SC</span> <span class="pre">-&gt;</span> <span class="pre">N</span></code> and <code class="docutils literal notranslate"><span class="pre">SC</span> <span class="pre">-&gt;</span> <span class="pre">S</span></code>.</p>
</section>
<section id="unchained-function-calls">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Unchained Function calls</a><a class="headerlink" href="#unchained-function-calls" title="Permalink to this heading">¶</a></h3>
<p>When a function with “<code class="docutils literal notranslate"><span class="pre">aarch64_pstate_sm_enabled</span></code>” calls a function that is not
streaming compatible, the compiler has to insert a SMSTOP before the call and
insert a SMSTOP after the call.</p>
<p>If the function that is called is an intrinsic with no side-effects which in
turn is lowered to a function call (e.g. <code class="docutils literal notranslate"><span class="pre">&#64;llvm.cos()</span></code>), then the call to
<code class="docutils literal notranslate"><span class="pre">&#64;llvm.cos()</span></code> is not part of any Chain; it can be scheduled freely.</p>
<p>Lowering of a Callsite creates a small chain of nodes which:</p>
<ul class="simple">
<li><p>starts a call sequence</p></li>
<li><p>copies input values from virtual registers to physical registers specified by
the ABI</p></li>
<li><p>executes a branch-and-link</p></li>
<li><p>stops the call sequence</p></li>
<li><p>copies the output values from their physical registers to virtual registers</p></li>
</ul>
<p>When the callsite’s Chain is not used, only the result value from the chained
sequence is used, but the Chain itself is discarded.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">SMSTART</span></code> and <code class="docutils literal notranslate"><span class="pre">SMSTOP</span></code> ISD nodes return a Chain, but no real
values, so when the <code class="docutils literal notranslate"><span class="pre">SMSTART/SMSTOP</span></code> nodes are part of a Chain that isn’t
used, these nodes are not considered for scheduling and are
removed from the DAG.  In order to prevent these nodes
from being removed, we need a way to ensure the results from the
<code class="docutils literal notranslate"><span class="pre">CopyFromReg</span></code> can only be <strong>used after</strong> the <code class="docutils literal notranslate"><span class="pre">SMSTART/SMSTOP</span></code> has been
executed.</p>
<p>We can use a CopyToReg -&gt; CopyFromReg sequence for this, which moves the
value to/from a virtual register and chains these nodes with the
SMSTART/SMSTOP to make them part of the expression that calculates
the result value. The resulting COPY nodes are removed by the register
allocator.</p>
<p>The example below shows how this is used in a DAG that does not link
together the result by a Chain, but rather by a value:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>            t0: ch,glue = AArch64ISD::SMSTOP ...
          t1: ch,glue = ISD::CALL ....
        t2: res,ch,glue = CopyFromReg t1, ...
      t3: ch,glue = AArch64ISD::SMSTART t2:1, ....   &lt;- this is now part of the expression that returns the result value.
    t4: ch = CopyToReg t3, Register:f64 %vreg, t2
  t5: res,ch = CopyFromReg t4, Register:f64 %vreg
t6: res = FADD t5, t9
</pre></div>
</div>
<p>We also need this for locally streaming functions, where an <code class="docutils literal notranslate"><span class="pre">SMSTART</span></code> needs to
be inserted into the DAG at the start of the function.</p>
</section>
<section id="functions-with-attribute-arm-locally-streaming">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">Functions with __attribute__((arm_locally_streaming))</a><a class="headerlink" href="#functions-with-attribute-arm-locally-streaming" title="Permalink to this heading">¶</a></h3>
<p>If a function is marked as <code class="docutils literal notranslate"><span class="pre">arm_locally_streaming</span></code>, then the runtime SVE
vector length in the prologue/epilogue may be different from the vector length
in the function’s body. This happens because we invoke smstart after setting up
the stack-frame and similarly invoke smstop before deallocating the stack-frame.</p>
<p>To ensure we use the correct SVE vector length to allocate the locals with, we
can use the streaming vector-length to allocate the stack-slots through the
<code class="docutils literal notranslate"><span class="pre">ADDSVL</span></code> instruction, even when the CPU is not yet in streaming mode.</p>
<p>This only works for locals and not callee-save slots, since LLVM doesn’t support
mixing two different scalable vector lengths in one stack frame. That means that the
case where a function is marked <code class="docutils literal notranslate"><span class="pre">arm_locally_streaming</span></code> and needs to spill SVE
callee-saves in the prologue is currently unsupported.  However, it is unlikely
for this to happen without user intervention, because <code class="docutils literal notranslate"><span class="pre">arm_locally_streaming</span></code>
functions cannot take or return vector-length-dependent values. This would otherwise
require forcing both the SVE PCS using ‘<code class="docutils literal notranslate"><span class="pre">aarch64_sve_pcs</span></code>’ combined with using
<code class="docutils literal notranslate"><span class="pre">arm_locally_streaming</span></code> in order to encounter this problem. This combination
can be prevented in Clang through emitting a diagnostic.</p>
<p>An example of how the prologue/epilogue would look for a function that is
attributed with <code class="docutils literal notranslate"><span class="pre">arm_locally_streaming</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define N 64</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">__attribute__</span><span class="p">((</span><span class="n">arm_streaming_compatible</span><span class="p">))</span><span class="w"> </span><span class="n">some_use</span><span class="p">(</span><span class="n">svfloat32_t</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>

<span class="c1">// Use a float argument type, to check the value isn&#39;t clobbered by smstart.</span>
<span class="c1">// Use a float return type to check the value isn&#39;t clobbered by smstop.</span>
<span class="kt">float</span><span class="w"> </span><span class="nf">__attribute__</span><span class="p">((</span><span class="n">noinline</span><span class="p">,</span><span class="w"> </span><span class="n">arm_locally_streaming</span><span class="p">))</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Create local for SVE vector to check local is created with correct</span>
<span class="w">  </span><span class="c1">// size when not yet in streaming mode (ADDSVL).</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="w">  </span><span class="n">svfloat32_t</span><span class="w"> </span><span class="n">vector</span><span class="p">;</span>

<span class="w">  </span><span class="n">some_use</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vector</span><span class="p">);</span>
<span class="w">  </span><span class="n">svst1_f32</span><span class="p">(</span><span class="n">svptrue_b32</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">vector</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="n">N</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">arg</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>should use ADDSVL for allocating the stack space and should avoid clobbering
the return/argument values.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>_Z3foof:                                // @_Z3foof
// %bb.0:                               // %entry
        stp     d15, d14, [sp, #-96]!           // 16-byte Folded Spill
        stp     d13, d12, [sp, #16]             // 16-byte Folded Spill
        stp     d11, d10, [sp, #32]             // 16-byte Folded Spill
        stp     d9, d8, [sp, #48]               // 16-byte Folded Spill
        stp     x29, x30, [sp, #64]             // 16-byte Folded Spill
        add     x29, sp, #64
        str     x28, [sp, #80]                  // 8-byte Folded Spill
        addsvl  sp, sp, #-1
        sub     sp, sp, #256
        str     s0, [x29, #28]                  // 4-byte Folded Spill
        smstart sm
        sub     x0, x29, #64
        addsvl  x0, x0, #-1
        bl      _Z10some_usePu13__SVFloat32_t
        sub     x8, x29, #64
        ptrue   p0.s
        ld1w    { z0.s }, p0/z, [x8, #-1, mul vl]
        ldr     s1, [x29, #28]                  // 4-byte Folded Reload
        st1w    { z0.s }, p0, [sp]
        ldr     s0, [sp, #252]
        fadd    s0, s0, s1
        str     s0, [x29, #28]                  // 4-byte Folded Spill
        smstop  sm
        ldr     s0, [x29, #28]                  // 4-byte Folded Reload
        addsvl  sp, sp, #1
        add     sp, sp, #256
        ldp     x29, x30, [sp, #64]             // 16-byte Folded Reload
        ldp     d9, d8, [sp, #48]               // 16-byte Folded Reload
        ldp     d11, d10, [sp, #32]             // 16-byte Folded Reload
        ldp     d13, d12, [sp, #16]             // 16-byte Folded Reload
        ldr     x28, [sp, #80]                  // 8-byte Folded Reload
        ldp     d15, d14, [sp], #96             // 16-byte Folded Reload
        ret
</pre></div>
</div>
</section>
<section id="preventing-the-use-of-illegal-instructions-in-streaming-mode">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Preventing the use of illegal instructions in Streaming Mode</a><a class="headerlink" href="#preventing-the-use-of-illegal-instructions-in-streaming-mode" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>When executing a program in streaming-mode (PSTATE.SM=1) a subset of SVE/SVE2
instructions and most AdvSIMD/NEON instructions are invalid.</p></li>
<li><p>When executing a program in normal mode (PSTATE.SM=0), a subset of SME
instructions are invalid.</p></li>
<li><p>Streaming-compatible functions must only use instructions that are valid when
either PSTATE.SM=0 or PSTATE.SM=1.</p></li>
</ul>
<p>The value of PSTATE.SM is not controlled by the feature flags, but rather by the
function attributes. This means that we can compile for ‘<code class="docutils literal notranslate"><span class="pre">+sme</span></code>’ and the compiler
will code-generate any instructions, even if they are not legal under the requested
streaming mode. The compiler needs to use the function attributes to ensure the
compiler doesn’t do transformations under the assumption that certain operations
are available at runtime.</p>
<p>We made a conscious choice not to model this with feature flags, because we
still want to support inline-asm in either mode (with the user placing
smstart/smstop manually), and this became rather complicated to implement at the
individual instruction level (see <a class="reference external" href="https://reviews.llvm.org/D120261">D120261</a>
and <a class="reference external" href="https://reviews.llvm.org/D121208">D121208</a>) because of limitations in
TableGen.</p>
<p>As a first step, this means we’ll disable vectorization (LoopVectorize/SLP)
entirely when the a function has either of the <code class="docutils literal notranslate"><span class="pre">aarch64_pstate_sm_enabled</span></code>,
<code class="docutils literal notranslate"><span class="pre">aarch64_pstate_sm_body</span></code> or <code class="docutils literal notranslate"><span class="pre">aarch64_pstate_sm_compatible</span></code> attributes,
in order to avoid the use of vector instructions.</p>
<p>Later on we’ll aim to relax these restrictions to enable scalable
auto-vectorization with a subset of streaming-compatible instructions, but that
requires changes to the CostModel, Legalization and SelectionDAG lowering.</p>
<p>We will also emit diagnostics in Clang to prevent the use of
non-streaming(-compatible) operations, e.g. through ACLE intrinsics, when a
function is decorated with the streaming mode attributes.</p>
</section>
<section id="other-things-to-consider">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Other things to consider</a><a class="headerlink" href="#other-things-to-consider" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>Inlining must be disabled when the call-site needs to toggle PSTATE.SM or
when the callee’s function body is executed in a different streaming mode than
its caller. This is needed because function calls are the boundaries for
streaming mode changes.</p></li>
<li><p>Tail call optimization must be disabled when the call-site needs to toggle
PSTATE.SM, such that the caller can restore the original value of PSTATE.SM.</p></li>
</ul>
</section>
</section>
<section id="handling-pstate-za">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">3. Handling PSTATE.ZA</a><a class="headerlink" href="#handling-pstate-za" title="Permalink to this heading">¶</a></h2>
<p>In contrast to PSTATE.SM, enabling PSTATE.ZA does not affect the SVE vector
length and also doesn’t clobber FP/AdvSIMD/SVE registers. This means it is safe
to toggle PSTATE.ZA using intrinsics. This also makes it simpler to setup a
lazy-save mechanism for calls to private-ZA functions (i.e. functions that may
either directly or indirectly clobber ZA state).</p>
<p>For the purpose of handling functions marked with <code class="docutils literal notranslate"><span class="pre">aarch64_pstate_za_new</span></code>,
we have introduced a new LLVM IR pass (SMEABIPass) that is run just before
SelectionDAG. Any such functions dealt with by this pass are marked with
<code class="docutils literal notranslate"><span class="pre">aarch64_expanded_pstate_za</span></code>.</p>
<section id="setting-up-a-lazy-save">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Setting up a lazy-save</a><a class="headerlink" href="#setting-up-a-lazy-save" title="Permalink to this heading">¶</a></h3>
</section>
<section id="committing-a-lazy-save">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Committing a lazy-save</a><a class="headerlink" href="#committing-a-lazy-save" title="Permalink to this heading">¶</a></h3>
</section>
<section id="exception-handling-and-za">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">Exception handling and ZA</a><a class="headerlink" href="#exception-handling-and-za" title="Permalink to this heading">¶</a></h3>
</section>
</section>
<section id="types">
<h2><a class="toc-backref" href="#id16" role="doc-backlink">4. Types</a><a class="headerlink" href="#types" title="Permalink to this heading">¶</a></h2>
<section id="aarch64-predicate-as-counter-type">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">AArch64 Predicate-as-Counter Type</a><a class="headerlink" href="#aarch64-predicate-as-counter-type" title="Permalink to this heading">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">Overview<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
<p>The predicate-as-counter type represents the type of a predicate-as-counter
value held in a AArch64 SVE predicate register. Such a value contains
information about the number of active lanes, the element width and a bit that
tells whether the generated mask should be inverted. ACLE intrinsics should be
used to move the predicate-as-counter value to/from a predicate vector.</p>
<p>There are certain limitations on the type:</p>
<ul class="simple">
<li><p>The type can be used for function parameters and return values.</p></li>
<li><p>The supported LLVM operations on this type are limited to <code class="docutils literal notranslate"><span class="pre">load</span></code>, <code class="docutils literal notranslate"><span class="pre">store</span></code>,
<code class="docutils literal notranslate"><span class="pre">phi</span></code>, <code class="docutils literal notranslate"><span class="pre">select</span></code> and <code class="docutils literal notranslate"><span class="pre">alloca</span></code> instructions.</p></li>
</ul>
<p>The predicate-as-counter type is a scalable type.</p>
<dl class="field-list simple">
<dt class="field-odd">Syntax<span class="colon">:</span></dt>
<dd class="field-odd"><p></p></dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">target</span><span class="p">(</span><span class="s2">&quot;aarch64.svcount&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="references">
<h2><a class="toc-backref" href="#id18" role="doc-backlink">5. References</a><a class="headerlink" href="#references" title="Permalink to this heading">¶</a></h2>
<blockquote>
<div></div></blockquote>
<ol class="arabic simple" id="aarch64-sme-acle">
<li><p><a class="reference external" href="https://github.com/ARM-software/acle/pull/188">SME ACLE Pull-request</a></p>
</li>
<li id="aarch64-sme-abi"><p><a class="reference external" href="https://github.com/ARM-software/abi-aa/pull/123">SME ABI Pull-request</a></p></li>
</ol>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="AddingConstrainedIntrinsics.html" title="How To Add A Constrained Floating-Point Intrinsic"
             >next</a> |</li>
        <li class="right" >
          <a href="UserGuides.html" title="User Guides"
             >previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" >User Guides</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Support for AArch64 Scalable Matrix Extension in LLVM</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2003-2024, LLVM Project.
      Last updated on 2024-03-22.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.1.2.
    </div>
  </body>
</html>