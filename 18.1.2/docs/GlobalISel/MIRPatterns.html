
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>MIR Patterns in TableGen &#8212; LLVM 18.1.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="../_static/llvm-theme.css?v=be84393e" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=2f6c9c8e"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Core Pipeline" href="Pipeline.html" />
    <link rel="prev" title="Generic Opcodes" href="GenericOpcode.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="../index.html">
    <img src="../_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="Pipeline.html" title="Core Pipeline"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="GenericOpcode.html" title="Generic Opcodes"
             accesskey="P">previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="../index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="../Reference.html" >Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">Global Instruction Selection</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">MIR Patterns in TableGen</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="https://llvm.org/docs/UserGuides.html">User Guides</a></li>
    <li><a href="https://llvm.org/docs/Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/Contributing.html">Contributing to LLVM</a></li>
    <li><a href="https://llvm.org/docs/HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#irc">IRC</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/FAQ.html">FAQ</a></li>
    <li><a href="https://llvm.org/docs/Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project/">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/GlobalISel/MIRPatterns.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="mir-patterns-in-tablegen">
<span id="tblgen-mirpats"></span><h1>MIR Patterns in TableGen<a class="headerlink" href="#mir-patterns-in-tablegen" title="Permalink to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#user-s-guide" id="id17">User’s Guide</a></p>
<ul>
<li><p><a class="reference internal" href="#use-cases" id="id18">Use Cases</a></p></li>
<li><p><a class="reference internal" href="#syntax" id="id19">Syntax</a></p></li>
<li><p><a class="reference internal" href="#types" id="id20">Types</a></p>
<ul>
<li><p><a class="reference internal" href="#valuetype" id="id21">ValueType</a></p></li>
<li><p><a class="reference internal" href="#gitypeof" id="id22">GITypeOf</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#builtin-operations" id="id23">Builtin Operations</a></p>
<ul>
<li><p><a class="reference internal" href="#gireplacereg" id="id24">GIReplaceReg</a></p></li>
<li><p><a class="reference internal" href="#gieraseroot" id="id25">GIEraseRoot</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#instruction-flags" id="id26">Instruction Flags</a></p></li>
<li><p><a class="reference internal" href="#limitations" id="id27">Limitations</a></p></li>
<li><p><a class="reference internal" href="#gicombinerule" id="id28">GICombineRule</a></p>
<ul>
<li><p><a class="reference internal" href="#common-pattern-1-replace-a-register-with-another" id="id29">Common Pattern #1: Replace a Register with Another</a></p></li>
<li><p><a class="reference internal" href="#common-pattern-2-erasing-a-def-less-root" id="id30">Common Pattern #2: Erasing a Def-less Root</a></p></li>
<li><p><a class="reference internal" href="#common-pattern-3-emitting-a-constant-value" id="id31">Common Pattern #3: Emitting a Constant Value</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#gicombinepatfrag" id="id32">GICombinePatFrag</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="user-s-guide">
<h2><a class="toc-backref" href="#id17" role="doc-backlink">User’s Guide</a><a class="headerlink" href="#user-s-guide" title="Permalink to this heading">¶</a></h2>
<p>This section is intended for developers who want to use MIR patterns in their
TableGen files.</p>
<p><code class="docutils literal notranslate"><span class="pre">NOTE</span></code>:
This feature is still in active development. This document may become outdated
over time. If you see something that’s incorrect, please update it.</p>
<section id="use-cases">
<h3><a class="toc-backref" href="#id18" role="doc-backlink">Use Cases</a><a class="headerlink" href="#use-cases" title="Permalink to this heading">¶</a></h3>
<p>MIR patterns are supported in the following places:</p>
<ul class="simple">
<li><p>GlobalISel <code class="docutils literal notranslate"><span class="pre">GICombineRule</span></code></p></li>
<li><p>GlobalISel <code class="docutils literal notranslate"><span class="pre">GICombinePatFrag</span></code></p></li>
</ul>
</section>
<section id="syntax">
<h3><a class="toc-backref" href="#id19" role="doc-backlink">Syntax</a><a class="headerlink" href="#syntax" title="Permalink to this heading">¶</a></h3>
<p>MIR patterns use the DAG datatype in TableGen.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(inst operand0, operand1, ...)
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">inst</span></code> must be a def which inherits from <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">G_FADD</span></code>)
or <code class="docutils literal notranslate"><span class="pre">GICombinePatFrag</span></code>.</p>
<p>Operands essentially fall into one of two categories:</p>
<ul class="simple">
<li><p>immediates</p>
<ul>
<li><p>untyped, unnamed: <code class="docutils literal notranslate"><span class="pre">0</span></code></p></li>
<li><p>untyped, named: <code class="docutils literal notranslate"><span class="pre">0:$y</span></code></p></li>
<li><p>typed, unnamed: <code class="docutils literal notranslate"><span class="pre">(i32</span> <span class="pre">0)</span></code></p></li>
<li><p>typed, named: <code class="docutils literal notranslate"><span class="pre">(i32</span> <span class="pre">0):$y</span></code></p></li>
</ul>
</li>
<li><p>machine operands</p>
<ul>
<li><p>untyped: <code class="docutils literal notranslate"><span class="pre">$x</span></code></p></li>
<li><p>typed: <code class="docutils literal notranslate"><span class="pre">i32:$x</span></code></p></li>
</ul>
</li>
</ul>
<p>Semantics:</p>
<ul class="simple">
<li><p>A typed operand always adds an operand type check to the matcher.</p></li>
<li><p>There is a trivial type inference system to propagate types.</p>
<ul>
<li><p>e.g. You only need to use <code class="docutils literal notranslate"><span class="pre">i32:$x</span></code> once in any pattern of a
<code class="docutils literal notranslate"><span class="pre">GICombinePatFrag</span></code> alternative or <code class="docutils literal notranslate"><span class="pre">GICombineRule</span></code>, then all
other patterns in that rule/alternative can simply use <code class="docutils literal notranslate"><span class="pre">$x</span></code>
(<code class="docutils literal notranslate"><span class="pre">i32:$x</span></code> is redundant).</p></li>
</ul>
</li>
<li><p>A named operand’s behavior depends on whether the name has been seen before.</p>
<ul>
<li><p>For match patterns, reusing an operand name checks that the operands
are identical (see example 2 below).</p></li>
<li><p>For apply patterns, reusing an operand name simply copies that operand into
the new instruction (see example 2 below).</p></li>
</ul>
</li>
</ul>
<p>Operands are ordered just like they would be in a MachineInstr: the defs (outs)
come first, then the uses (ins).</p>
<p>Patterns are generally grouped into another DAG datatype with a dummy operator
such as <code class="docutils literal notranslate"><span class="pre">match</span></code>, <code class="docutils literal notranslate"><span class="pre">apply</span></code> or <code class="docutils literal notranslate"><span class="pre">pattern</span></code>.</p>
<p>Finally, any DAG datatype in TableGen can be named. This also holds for
patterns. e.g. the following is valid: <code class="docutils literal notranslate"><span class="pre">(G_FOO</span> <span class="pre">$root,</span> <span class="pre">(i32</span> <span class="pre">0):$cst):$mypat</span></code>.
This may also be helpful to debug issues. Patterns are <em>always</em> named, and if
they don’t have a name, an “anonymous” one is given to them. If you’re trying
to debug an error related to a MIR pattern, but the error mentions an anonymous
pattern, you can try naming your patterns to see exactly where the issue is.</p>
<div class="literal-block-wrapper docutils container" id="id1">
<div class="code-block-caption"><span class="caption-text">Pattern Example 1</span><a class="headerlink" href="#id1" title="Permalink to this code">¶</a></div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>// Match
//    %imp = G_IMPLICIT_DEF
//    %root = G_MUL %x, %imp
(match (G_IMPLICIT_DEF $imp),
       (G_MUL $root, $x, $imp))
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id2">
<div class="code-block-caption"><span class="caption-text">Pattern Example 2</span><a class="headerlink" href="#id2" title="Permalink to this code">¶</a></div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>// using $x twice here checks that the operand 1 and 2 of the G_AND are
// identical.
(match (G_AND $root, $x, $x))
// using $x again here copies operand 1 from G_AND into the new inst.
(apply (COPY $root, $x))
</pre></div>
</div>
</div>
</section>
<section id="types">
<h3><a class="toc-backref" href="#id20" role="doc-backlink">Types</a><a class="headerlink" href="#types" title="Permalink to this heading">¶</a></h3>
<section id="valuetype">
<h4><a class="toc-backref" href="#id21" role="doc-backlink">ValueType</a><a class="headerlink" href="#valuetype" title="Permalink to this heading">¶</a></h4>
<p>Subclasses of <code class="docutils literal notranslate"><span class="pre">ValueType</span></code> are valid types, e.g. <code class="docutils literal notranslate"><span class="pre">i32</span></code>.</p>
</section>
<section id="gitypeof">
<h4><a class="toc-backref" href="#id22" role="doc-backlink">GITypeOf</a><a class="headerlink" href="#gitypeof" title="Permalink to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">GITypeOf&lt;&quot;$x&quot;&gt;</span></code> is a <code class="docutils literal notranslate"><span class="pre">GISpecialType</span></code> that allows for the creation of a
register or immediate with the same type as another (register) operand.</p>
<p>Operand:</p>
<ul class="simple">
<li><p>An operand name as a string, prefixed by <code class="docutils literal notranslate"><span class="pre">$</span></code>.</p></li>
</ul>
<p>Semantics:</p>
<ul class="simple">
<li><p>Can only appear in an ‘apply’ pattern.</p></li>
<li><p>The operand name used must appear in the ‘match’ pattern of the
same <code class="docutils literal notranslate"><span class="pre">GICombineRule</span></code>.</p></li>
</ul>
<div class="literal-block-wrapper docutils container" id="id3">
<div class="code-block-caption"><span class="caption-text">Example: Immediate</span><a class="headerlink" href="#id3" title="Permalink to this code">¶</a></div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def mul_by_neg_one: GICombineRule &lt;
  (defs root:$root),
  (match (G_MUL $dst, $x, -1)),
  (apply (G_SUB $dst, (GITypeOf&lt;&quot;$x&quot;&gt; 0), $x))
&gt;;
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id4">
<div class="code-block-caption"><span class="caption-text">Example: Temp Reg</span><a class="headerlink" href="#id4" title="Permalink to this code">¶</a></div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def Test0 : GICombineRule&lt;
  (defs root:$dst),
  (match (G_FMUL $dst, $src, -1)),
  (apply (G_FSUB $dst, $src, $tmp),
         (G_FNEG GITypeOf&lt;&quot;$dst&quot;&gt;:$tmp, $src))&gt;;
</pre></div>
</div>
</div>
</section>
</section>
<section id="builtin-operations">
<h3><a class="toc-backref" href="#id23" role="doc-backlink">Builtin Operations</a><a class="headerlink" href="#builtin-operations" title="Permalink to this heading">¶</a></h3>
<p>MIR Patterns also offer builtin operations, also called “builtin instructions”.
They offer some powerful features that would otherwise require use of C++ code.</p>
<section id="gireplacereg">
<h4><a class="toc-backref" href="#id24" role="doc-backlink">GIReplaceReg</a><a class="headerlink" href="#gireplacereg" title="Permalink to this heading">¶</a></h4>
<div class="literal-block-wrapper docutils container" id="id5">
<div class="code-block-caption"><span class="caption-text">Usage</span><a class="headerlink" href="#id5" title="Permalink to this code">¶</a></div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(apply (GIReplaceReg $old, $new))
</pre></div>
</div>
</div>
<p>Operands:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">$old</span></code> (out) register defined by a matched instruction</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">$new</span></code> (in)  register</p></li>
</ul>
<p>Semantics:</p>
<ul class="simple">
<li><p>Can only appear in an ‘apply’ pattern.</p></li>
<li><p>If both old/new are operands of matched instructions,
<code class="docutils literal notranslate"><span class="pre">canReplaceReg</span></code> is checked before applying the rule.</p></li>
</ul>
</section>
<section id="gieraseroot">
<h4><a class="toc-backref" href="#id25" role="doc-backlink">GIEraseRoot</a><a class="headerlink" href="#gieraseroot" title="Permalink to this heading">¶</a></h4>
<div class="literal-block-wrapper docutils container" id="id6">
<div class="code-block-caption"><span class="caption-text">Usage</span><a class="headerlink" href="#id6" title="Permalink to this code">¶</a></div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(apply (GIEraseRoot))
</pre></div>
</div>
</div>
<p>Semantics:</p>
<ul class="simple">
<li><p>Can only appear as the only pattern of an ‘apply’ pattern list.</p></li>
<li><p>The root cannot have any output operands.</p></li>
<li><p>The root must be a CodeGenInstruction</p></li>
</ul>
</section>
</section>
<section id="instruction-flags">
<h3><a class="toc-backref" href="#id26" role="doc-backlink">Instruction Flags</a><a class="headerlink" href="#instruction-flags" title="Permalink to this heading">¶</a></h3>
<p>MIR Patterns support both matching &amp; writing <code class="docutils literal notranslate"><span class="pre">MIFlags</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="id7">
<div class="code-block-caption"><span class="caption-text">Example</span><a class="headerlink" href="#id7" title="Permalink to this code">¶</a></div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def Test : GICombineRule&lt;
  (defs root:$dst),
  (match (G_FOO $dst, $src, (MIFlags FmNoNans, FmNoInfs))),
  (apply (G_BAR $dst, $src, (MIFlags FmReassoc)))&gt;;
</pre></div>
</div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">apply</span></code> patterns, we also support referring to a matched instruction to
“take” its MIFlags.</p>
<div class="literal-block-wrapper docutils container" id="id8">
<div class="code-block-caption"><span class="caption-text">Example</span><a class="headerlink" href="#id8" title="Permalink to this code">¶</a></div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>; We match NoNans/NoInfs, but $zext may have more flags.
; Copy them all into the output instruction, and set Reassoc on the output inst.
def TestCpyFlags : GICombineRule&lt;
  (defs root:$dst),
  (match (G_FOO $dst, $src, (MIFlags FmNoNans, FmNoInfs)):$zext),
  (apply (G_BAR $dst, $src, (MIFlags $zext, FmReassoc)))&gt;;
</pre></div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">not</span></code> operator can be used to check that a flag is NOT present
on a matched instruction, and to remove a flag from a generated instruction.</p>
<div class="literal-block-wrapper docutils container" id="id9">
<div class="code-block-caption"><span class="caption-text">Example</span><a class="headerlink" href="#id9" title="Permalink to this code">¶</a></div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>; We match NoInfs but we don&#39;t want NoNans/Reassoc to be set. $zext may have more flags.
; Copy them all into the output instruction but remove NoInfs on the output inst.
def TestNot : GICombineRule&lt;
  (defs root:$dst),
  (match (G_FOO $dst, $src, (MIFlags FmNoInfs, (not FmNoNans, FmReassoc))):$zext),
  (apply (G_BAR $dst, $src, (MIFlags $zext, (not FmNoInfs))))&gt;;
</pre></div>
</div>
</div>
</section>
<section id="limitations">
<h3><a class="toc-backref" href="#id27" role="doc-backlink">Limitations</a><a class="headerlink" href="#limitations" title="Permalink to this heading">¶</a></h3>
<p>This a non-exhaustive list of known issues with MIR patterns at this time.</p>
<ul class="simple">
<li><p>Matching intrinsics is not yet possible.</p></li>
<li><p>Using <code class="docutils literal notranslate"><span class="pre">GICombinePatFrag</span></code> within another <code class="docutils literal notranslate"><span class="pre">GICombinePatFrag</span></code> is not
supported.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GICombinePatFrag</span></code> can only have a single root.</p></li>
<li><p>Instructions with multiple defs cannot be the root of a <code class="docutils literal notranslate"><span class="pre">GICombinePatFrag</span></code>.</p></li>
<li><p>Using <code class="docutils literal notranslate"><span class="pre">GICombinePatFrag</span></code> in the <code class="docutils literal notranslate"><span class="pre">apply</span></code> pattern of a <code class="docutils literal notranslate"><span class="pre">GICombineRule</span></code>
is not supported.</p></li>
<li><p>We cannot rewrite a matched instruction other than the root.</p></li>
<li><p>Matching/creating a (CImm) immediate &gt;64 bits is not supported
(see comment in <code class="docutils literal notranslate"><span class="pre">GIM_CheckConstantInt</span></code>)</p></li>
<li><p>There is currently no way to constrain two register/immediate types to
match. e.g. if a pattern needs to work on both i32 and i64, you either
need to leave it untyped and check the type in C++, or duplicate the
pattern.</p></li>
</ul>
</section>
<section id="gicombinerule">
<h3><a class="toc-backref" href="#id28" role="doc-backlink">GICombineRule</a><a class="headerlink" href="#gicombinerule" title="Permalink to this heading">¶</a></h3>
<p>MIR patterns can appear in the <code class="docutils literal notranslate"><span class="pre">match</span></code> or <code class="docutils literal notranslate"><span class="pre">apply</span></code> patterns of a
<code class="docutils literal notranslate"><span class="pre">GICombineRule</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">root</span></code> of the rule can either be a def of an instruction, or a
named pattern. The latter is helpful when the instruction you want
to match has no defs. The former is generally preferred because
it’s less verbose.</p>
<div class="literal-block-wrapper docutils container" id="id10">
<div class="code-block-caption"><span class="caption-text">Combine Rule root is a def</span><a class="headerlink" href="#id10" title="Permalink to this code">¶</a></div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>// Fold x op 1 -&gt; x
def right_identity_one: GICombineRule&lt;
  (defs root:$dst),
  (match (G_MUL $dst, $x, 1)),
  // Note: Patterns always need to create something, we can&#39;t just replace $dst with $x, so we need a COPY.
  (apply (COPY $dst, $x))
&gt;;
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id11">
<div class="code-block-caption"><span class="caption-text">Combine Rule root is a named pattern</span><a class="headerlink" href="#id11" title="Permalink to this code">¶</a></div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def Foo : GICombineRule&lt;
  (defs root:$root),
  (match (G_ZEXT $tmp, (i32 0)),
         (G_STORE $tmp, $ptr):$root),
  (apply (G_STORE (i32 0), $ptr):$root)&gt;;
</pre></div>
</div>
</div>
<p>Combine Rules also allow mixing C++ code with MIR patterns, so that you
may perform additional checks when matching, or run additional code after
rewriting a pattern.</p>
<p>The following expansions are available for MIR patterns:</p>
<ul class="simple">
<li><p>operand names (<code class="docutils literal notranslate"><span class="pre">MachineOperand</span> <span class="pre">&amp;</span></code>)</p></li>
<li><p>pattern names (<code class="docutils literal notranslate"><span class="pre">MachineInstr</span> <span class="pre">*</span></code> for <code class="docutils literal notranslate"><span class="pre">match</span></code>,
<code class="docutils literal notranslate"><span class="pre">MachineInstrBuilder</span> <span class="pre">&amp;</span></code> for apply)</p></li>
</ul>
<div class="literal-block-wrapper docutils container" id="id12">
<div class="code-block-caption"><span class="caption-text">Example C++ Expansions</span><a class="headerlink" href="#id12" title="Permalink to this code">¶</a></div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def Foo : GICombineRule&lt;
  (defs root:$root),
  (match (G_ZEXT $root, $src):$mi),
  (apply &quot;foobar(${root}.getReg(), ${src}.getReg(), ${mi}-&gt;hasImplicitDef())&quot;)&gt;;
</pre></div>
</div>
</div>
<section id="common-pattern-1-replace-a-register-with-another">
<h4><a class="toc-backref" href="#id29" role="doc-backlink">Common Pattern #1: Replace a Register with Another</a><a class="headerlink" href="#common-pattern-1-replace-a-register-with-another" title="Permalink to this heading">¶</a></h4>
<p>The ‘apply’ pattern must always redefine all operands defined by the match root.
Sometimes, we do not need to create instructions, simply replace a def with
another matched register. The <code class="docutils literal notranslate"><span class="pre">GIReplaceReg</span></code> builtin can do just that.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def Foo : GICombineRule&lt;
  (defs root:$dst),
  (match (G_FNEG $tmp, $src), (G_FNEG $dst, $tmp)),
  (apply (GIReplaceReg $dst, $src))&gt;;
</pre></div>
</div>
<p>This also works if the replacement register is a temporary register from the
<code class="docutils literal notranslate"><span class="pre">apply</span></code> pattern.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def ReplaceTemp : GICombineRule&lt;
  (defs root:$a),
  (match    (G_BUILD_VECTOR $tmp, $x, $y),
            (G_UNMERGE_VALUES $a, $b, $tmp)),
  (apply  (G_UNMERGE_VALUES $a, i32:$new, $y),
          (GIReplaceReg $b, $new))&gt;
</pre></div>
</div>
</section>
<section id="common-pattern-2-erasing-a-def-less-root">
<h4><a class="toc-backref" href="#id30" role="doc-backlink">Common Pattern #2: Erasing a Def-less Root</a><a class="headerlink" href="#common-pattern-2-erasing-a-def-less-root" title="Permalink to this heading">¶</a></h4>
<p>If we simply want to erase a def-less match root, we can use the
<code class="docutils literal notranslate"><span class="pre">GIEraseRoot</span></code> builtin.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def Foo : GICombineRule&lt;
  (defs root:$mi),
  (match (G_STORE $a, $b):$mi),
  (apply (GIEraseRoot))&gt;;
</pre></div>
</div>
</section>
<section id="common-pattern-3-emitting-a-constant-value">
<h4><a class="toc-backref" href="#id31" role="doc-backlink">Common Pattern #3: Emitting a Constant Value</a><a class="headerlink" href="#common-pattern-3-emitting-a-constant-value" title="Permalink to this heading">¶</a></h4>
<p>When an immediate operand appears in an ‘apply’ pattern, the behavior
depends on whether it’s typed or not.</p>
<ul class="simple">
<li><p>If the immediate is typed, <code class="docutils literal notranslate"><span class="pre">MachineIRBuilder::buildConstant</span></code> is used
to create a <code class="docutils literal notranslate"><span class="pre">G_CONSTANT</span></code>. A <code class="docutils literal notranslate"><span class="pre">G_BUILD_VECTOR</span></code> will be used for vectors.</p></li>
<li><p>If the immediate is untyped, a simple immediate is added
(<code class="docutils literal notranslate"><span class="pre">MachineInstrBuilder::addImm</span></code>).</p></li>
</ul>
<p>There is of course a special case for <code class="docutils literal notranslate"><span class="pre">G_CONSTANT</span></code>. Immediates for
<code class="docutils literal notranslate"><span class="pre">G_CONSTANT</span></code> must always be typed, and a CImm is added
(<code class="docutils literal notranslate"><span class="pre">MachineInstrBuilder::addCImm</span></code>).</p>
<div class="literal-block-wrapper docutils container" id="id13">
<div class="code-block-caption"><span class="caption-text">Constant Emission Examples:</span><a class="headerlink" href="#id13" title="Permalink to this code">¶</a></div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>// Example output:
//    %0 = G_CONSTANT i32 0
//    %dst = COPY %0
def Foo : GICombineRule&lt;
  (defs root:$dst),
  (match (G_FOO $dst, $src)),
  (apply (COPY $dst, (i32 0)))&gt;;

// Example output:
//    %dst = COPY 0
// Note that this would be ill-formed because COPY
// expects a register operand!
def Bar : GICombineRule&lt;
  (defs root:$dst),
  (match (G_FOO $dst, $src)),
  (apply (COPY $dst, (i32 0)))&gt;;

// Example output:
//    %dst = G_CONSTANT i32 0
def Bux : GICombineRule&lt;
  (defs root:$dst),
  (match (G_FOO $dst, $src)),
  (apply (G_CONSTANT $dst, (i32 0)))&gt;;
</pre></div>
</div>
</div>
</section>
</section>
<section id="gicombinepatfrag">
<h3><a class="toc-backref" href="#id32" role="doc-backlink">GICombinePatFrag</a><a class="headerlink" href="#gicombinepatfrag" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">GICombinePatFrag</span></code> is an equivalent of <code class="docutils literal notranslate"><span class="pre">PatFrags</span></code> for MIR patterns.
They have two main usecases:</p>
<ul class="simple">
<li><p>Reduce repetition by creating a <code class="docutils literal notranslate"><span class="pre">GICombinePatFrag</span></code> for common
patterns (see example 1).</p></li>
<li><p>Implicitly duplicate a CombineRule for multiple variants of a
pattern (see example 2).</p></li>
</ul>
<p>A <code class="docutils literal notranslate"><span class="pre">GICombinePatFrag</span></code> is composed of three elements:</p>
<ul class="simple">
<li><p>zero or more <code class="docutils literal notranslate"><span class="pre">in</span></code> (def) parameter</p></li>
<li><p>zero or more <code class="docutils literal notranslate"><span class="pre">out</span></code> parameter</p></li>
<li><p>A list of MIR patterns that can match.</p>
<ul>
<li><p>When a <code class="docutils literal notranslate"><span class="pre">GICombinePatFrag</span></code> is used within a pattern, the pattern is
cloned once for each alternative that can match.</p></li>
</ul>
</li>
</ul>
<p>Parameters can have the following types:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">gi_mo</span></code>, which is the implicit default (no type = <code class="docutils literal notranslate"><span class="pre">gi_mo</span></code>).</p>
<ul>
<li><p>Refers to any operand of an instruction (register, BB ref, imm, etc.).</p></li>
<li><p>Can be used in both <code class="docutils literal notranslate"><span class="pre">in</span></code> and <code class="docutils literal notranslate"><span class="pre">out</span></code> parameters.</p></li>
<li><p>Users of the PatFrag can only use an operand name for this
parameter (e.g. <code class="docutils literal notranslate"><span class="pre">(my_pat_frag</span> <span class="pre">$foo)</span></code>).</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">root</span></code></p>
<ul>
<li><p>This is identical to <code class="docutils literal notranslate"><span class="pre">gi_mo</span></code>.</p></li>
<li><p>Can only be used in <code class="docutils literal notranslate"><span class="pre">out</span></code> parameters to declare the root of the
pattern.</p></li>
<li><p>Non-empty <code class="docutils literal notranslate"><span class="pre">out</span></code> parameter lists must always have exactly one <code class="docutils literal notranslate"><span class="pre">root</span></code>.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">gi_imm</span></code></p>
<ul>
<li><p>Refers to an (potentially typed) immediate.</p></li>
<li><p>Can only be used in <code class="docutils literal notranslate"><span class="pre">in</span></code> parameters.</p></li>
<li><p>Users of the PatFrag can only use an immediate for this parameter
(e.g. <code class="docutils literal notranslate"><span class="pre">(my_pat_frag</span> <span class="pre">0)</span></code> or <code class="docutils literal notranslate"><span class="pre">(my_pat_frag</span> <span class="pre">(i32</span> <span class="pre">0))</span></code>)</p></li>
</ul>
</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">out</span></code> operands can only be empty if the <code class="docutils literal notranslate"><span class="pre">GICombinePatFrag</span></code> only contains
C++ code. If the fragment contains instruction patterns, it has to have at
least one <code class="docutils literal notranslate"><span class="pre">out</span></code> operand of type <code class="docutils literal notranslate"><span class="pre">root</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">in</span></code> operands are less restricted, but there is one important concept to
remember: you can pass “unbound” operand names, but only if the
<code class="docutils literal notranslate"><span class="pre">GICombinePatFrag</span></code> binds it. See example 3 below.</p>
<p><code class="docutils literal notranslate"><span class="pre">GICombinePatFrag</span></code> are used just like any other instructions.
Note that the <code class="docutils literal notranslate"><span class="pre">out</span></code> operands are defs, so they come first in the list
of operands.</p>
<div class="literal-block-wrapper docutils container" id="id14">
<div class="code-block-caption"><span class="caption-text">Example 1: Reduce Repetition</span><a class="headerlink" href="#id14" title="Permalink to this code">¶</a></div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def zext_cst : GICombinePatFrag&lt;(outs root:$dst, $cst), (ins gi_imm:$val),
  [(pattern (G_CONSTANT $cst, $val),
            (G_ZEXT $dst, $cst))]
&gt;;

def foo_to_impdef : GICombineRule&lt;
 (defs root:$dst),
 (match (zext_cst $y, $cst, (i32 0))
        (G_FOO $dst, $y)),
 (apply (G_IMPLICIT_DEF $dst))&gt;;

def store_ext_zero : GICombineRule&lt;
 (defs root:$root),
 (match (zext_cst $y, $cst, (i32 0))
        (G_STORE $y, $ptr):$root),
 (apply (G_STORE $cst, $ptr):$root)&gt;;
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id15">
<div class="code-block-caption"><span class="caption-text">Example 2: Generate Multiple Rules at Once</span><a class="headerlink" href="#id15" title="Permalink to this code">¶</a></div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>// Fold (freeze (freeze x)) -&gt; (freeze x).
// Fold (fabs (fabs x)) -&gt; (fabs x).
// Fold (fcanonicalize (fcanonicalize x)) -&gt; (fcanonicalize x).
def idempotent_prop_frags : GICombinePatFrag&lt;(outs root:$dst, $src), (ins),
  [
    (pattern (G_FREEZE $dst, $src), (G_FREEZE $src, $x)),
    (pattern (G_FABS $dst, $src), (G_FABS $src, $x)),
    (pattern (G_FCANONICALIZE $dst, $src), (G_FCANONICALIZE $src, $x))
  ]
&gt;;

def idempotent_prop : GICombineRule&lt;
  (defs root:$dst),
  (match (idempotent_prop_frags $dst, $src)),
  (apply (COPY $dst, $src))&gt;;
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id16">
<div class="code-block-caption"><span class="caption-text">Example 3: Unbound Operand Names</span><a class="headerlink" href="#id16" title="Permalink to this code">¶</a></div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>// This fragment binds $x to an operand in all of its
// alternative patterns.
def always_binds : GICombinePatFrag&lt;
  (outs root:$dst), (ins $x),
  [
    (pattern (G_FREEZE $dst, $x)),
    (pattern (G_FABS $dst, $x)),
  ]
&gt;;

// This fragment does not bind $x to an operand in any
// of its alternative patterns.
def does_not_bind : GICombinePatFrag&lt;
  (outs root:$dst), (ins $x),
  [
    (pattern (G_FREEZE $dst, $x)), // binds $x
    (pattern (G_FOO $dst (i32 0))), // does not bind $x
    (pattern &quot;return myCheck(${x}.getReg())&quot;), // does not bind $x
  ]
&gt;;

// Here we pass $x, which is unbound, to always_binds.
// This works because if $x is unbound, always_binds will bind it for us.
def test0 : GICombineRule&lt;
  (defs root:$dst),
  (match (always_binds $dst, $x)),
  (apply (COPY $dst, $x))&gt;;

// Here we pass $x, which is unbound, to does_not_bind.
// This cannot work because $x may not have been initialized in &#39;apply&#39;.
// error: operand &#39;x&#39; (for parameter &#39;src&#39; of &#39;does_not_bind&#39;) cannot be unbound
def test1 : GICombineRule&lt;
  (defs root:$dst),
  (match (does_not_bind $dst, $x)),
  (apply (COPY $dst, $x))&gt;;

// Here we pass $x, which is bound, to does_not_bind.
// This is fine because $x will always be bound when emitting does_not_bind
def test2 : GICombineRule&lt;
  (defs root:$dst),
  (match (does_not_bind $tmp, $x)
         (G_MUL $dst, $x, $tmp)),
  (apply (COPY $dst, $x))&gt;;
</pre></div>
</div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="Pipeline.html" title="Core Pipeline"
             >next</a> |</li>
        <li class="right" >
          <a href="GenericOpcode.html" title="Generic Opcodes"
             >previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="../index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="../Reference.html" >Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >Global Instruction Selection</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">MIR Patterns in TableGen</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2003-2024, LLVM Project.
      Last updated on 2024-03-22.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.1.2.
    </div>
  </body>
</html>