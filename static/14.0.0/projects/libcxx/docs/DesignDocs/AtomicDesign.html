
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>&lt;atomic&gt; Design &#8212; libc++  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/haiku.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Capturing configuration information during installation" href="CapturingConfigInfo.html" />
    <link rel="prev" title="Libc++ ABI stability" href="ABIVersioning.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../index.html">
          <span>libc++  documentation</span></a></h1>
        <h2 class="heading"><span>&lt;atomic&gt; Design</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="ABIVersioning.html">Libc++ ABI stability</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="CapturingConfigInfo.html">Capturing configuration information during installation</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <div class="section" id="atomic-design">
<h1><code class="docutils literal notranslate"><span class="pre">&lt;atomic&gt;</span></code> Design<a class="headerlink" href="#atomic-design" title="Permalink to this headline">¶</a></h1>
<p>There were originally 3 designs under consideration. They differ in where most
of the implementation work is done. The functionality exposed to the customer
should be identical (and conforming) for all three designs.</p>
<div class="section" id="design-a-minimal-work-for-the-library">
<h2>Design A: Minimal work for the library<a class="headerlink" href="#design-a-minimal-work-for-the-library" title="Permalink to this headline">¶</a></h2>
<p>The compiler supplies all of the intrinsics as described below. This list of
intrinsics roughly parallels the requirements of the C and C++ atomics proposals.
The C and C++ library implementations simply drop through to these intrinsics.
Anything the platform does not support in hardware, the compiler
arranges for a (compiler-rt) library call to be made which will do the job with
a mutex, and in this case ignoring the memory ordering parameter (effectively
implementing <code class="docutils literal notranslate"><span class="pre">memory_order_seq_cst</span></code>).</p>
<p>Ultimate efficiency is preferred over run time error checking. Undefined
behavior is acceptable when the inputs do not conform as defined below.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// In every intrinsic signature below, type* atomic_obj may be a pointer to a</span>
<span class="c1">// volatile-qualified type. Memory ordering values map to the following meanings:</span>
<span class="c1">//  memory_order_relaxed == 0</span>
<span class="c1">//  memory_order_consume == 1</span>
<span class="c1">//  memory_order_acquire == 2</span>
<span class="c1">//  memory_order_release == 3</span>
<span class="c1">//  memory_order_acq_rel == 4</span>
<span class="c1">//  memory_order_seq_cst == 5</span>

<span class="c1">// type must be trivially copyable</span>
<span class="c1">// type represents a &quot;type argument&quot;</span>
<span class="kt">bool</span> <span class="nf">__atomic_is_lock_free</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>

<span class="c1">// type must be trivially copyable</span>
<span class="c1">// Behavior is defined for mem_ord = 0, 1, 2, 5</span>
<span class="n">type</span> <span class="nf">__atomic_load</span><span class="p">(</span><span class="k">const</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mem_ord</span><span class="p">);</span>

<span class="c1">// type must be trivially copyable</span>
<span class="c1">// Behavior is defined for mem_ord = 0, 3, 5</span>
<span class="kt">void</span> <span class="nf">__atomic_store</span><span class="p">(</span><span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">desired</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mem_ord</span><span class="p">);</span>

<span class="c1">// type must be trivially copyable</span>
<span class="c1">// Behavior is defined for mem_ord = [0 ... 5]</span>
<span class="n">type</span> <span class="nf">__atomic_exchange</span><span class="p">(</span><span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">desired</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mem_ord</span><span class="p">);</span>

<span class="c1">// type must be trivially copyable</span>
<span class="c1">// Behavior is defined for mem_success = [0 ... 5],</span>
<span class="c1">//   mem_failure &lt;= mem_success</span>
<span class="c1">//   mem_failure != 3</span>
<span class="c1">//   mem_failure != 4</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_strong</span><span class="p">(</span><span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span> <span class="n">type</span> <span class="n">desired</span><span class="p">,</span>
                                    <span class="kt">int</span> <span class="n">mem_success</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mem_failure</span><span class="p">);</span>

<span class="c1">// type must be trivially copyable</span>
<span class="c1">// Behavior is defined for mem_success = [0 ... 5],</span>
<span class="c1">//   mem_failure &lt;= mem_success</span>
<span class="c1">//   mem_failure != 3</span>
<span class="c1">//   mem_failure != 4</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_weak</span><span class="p">(</span><span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span> <span class="n">type</span> <span class="n">desired</span><span class="p">,</span>
                                    <span class="kt">int</span> <span class="n">mem_success</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mem_failure</span><span class="p">);</span>

<span class="c1">// type is one of: char, signed char, unsigned char, short, unsigned short, int,</span>
<span class="c1">//      unsigned int, long, unsigned long, long long, unsigned long long,</span>
<span class="c1">//      char16_t, char32_t, wchar_t</span>
<span class="c1">// Behavior is defined for mem_ord = [0 ... 5]</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_add</span><span class="p">(</span><span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mem_ord</span><span class="p">);</span>

<span class="c1">// type is one of: char, signed char, unsigned char, short, unsigned short, int,</span>
<span class="c1">//      unsigned int, long, unsigned long, long long, unsigned long long,</span>
<span class="c1">//      char16_t, char32_t, wchar_t</span>
<span class="c1">// Behavior is defined for mem_ord = [0 ... 5]</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_sub</span><span class="p">(</span><span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mem_ord</span><span class="p">);</span>

<span class="c1">// type is one of: char, signed char, unsigned char, short, unsigned short, int,</span>
<span class="c1">//      unsigned int, long, unsigned long, long long, unsigned long long,</span>
<span class="c1">//      char16_t, char32_t, wchar_t</span>
<span class="c1">// Behavior is defined for mem_ord = [0 ... 5]</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_and</span><span class="p">(</span><span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mem_ord</span><span class="p">);</span>

<span class="c1">// type is one of: char, signed char, unsigned char, short, unsigned short, int,</span>
<span class="c1">//      unsigned int, long, unsigned long, long long, unsigned long long,</span>
<span class="c1">//      char16_t, char32_t, wchar_t</span>
<span class="c1">// Behavior is defined for mem_ord = [0 ... 5]</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_or</span><span class="p">(</span><span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mem_ord</span><span class="p">);</span>

<span class="c1">// type is one of: char, signed char, unsigned char, short, unsigned short, int,</span>
<span class="c1">//      unsigned int, long, unsigned long, long long, unsigned long long,</span>
<span class="c1">//      char16_t, char32_t, wchar_t</span>
<span class="c1">// Behavior is defined for mem_ord = [0 ... 5]</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_xor</span><span class="p">(</span><span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mem_ord</span><span class="p">);</span>

<span class="c1">// Behavior is defined for mem_ord = [0 ... 5]</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">__atomic_fetch_add</span><span class="p">(</span><span class="kt">void</span><span class="o">**</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">operand</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mem_ord</span><span class="p">);</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">__atomic_fetch_sub</span><span class="p">(</span><span class="kt">void</span><span class="o">**</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">operand</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mem_ord</span><span class="p">);</span>

<span class="c1">// Behavior is defined for mem_ord = [0 ... 5]</span>
<span class="kt">void</span> <span class="nf">__atomic_thread_fence</span><span class="p">(</span><span class="kt">int</span> <span class="n">mem_ord</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">__atomic_signal_fence</span><span class="p">(</span><span class="kt">int</span> <span class="n">mem_ord</span><span class="p">);</span>
</pre></div>
</div>
<p>If desired the intrinsics taking a single <code class="docutils literal notranslate"><span class="pre">mem_ord</span></code> parameter can default
this argument to 5.</p>
<p>If desired the intrinsics taking two ordering parameters can default <code class="docutils literal notranslate"><span class="pre">mem_success</span></code>
to 5, and <code class="docutils literal notranslate"><span class="pre">mem_failure</span></code> to <code class="docutils literal notranslate"><span class="pre">translate_memory_order(mem_success)</span></code> where
<code class="docutils literal notranslate"><span class="pre">translate_memory_order(mem_success)</span></code> is defined as:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">translate_memory_order</span><span class="p">(</span><span class="kt">int</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">4</span><span class="o">:</span>
        <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Below are representative C++ implementations of all of the operations. Their
purpose is to document the desired semantics of each operation, assuming
<code class="docutils literal notranslate"><span class="pre">memory_order_seq_cst</span></code>. This is essentially the code that will be called
if the front end calls out to compiler-rt.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">__atomic_load</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">__atomic_store</span><span class="p">(</span><span class="n">T</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">T</span> <span class="n">desr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">desr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">__atomic_exchange</span><span class="p">(</span><span class="n">T</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">T</span> <span class="n">desr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="n">T</span> <span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
    <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">desr</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">__atomic_compare_exchange_strong</span><span class="p">(</span><span class="n">T</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">exp</span><span class="p">,</span> <span class="n">T</span> <span class="n">desr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memcmp</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">exp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// if (*obj == *exp)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">desr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span> <span class="c1">// *obj = desr;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span> <span class="c1">// *exp = *obj;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// May spuriously return false (even if *obj == *exp)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">__atomic_compare_exchange_weak</span><span class="p">(</span><span class="n">T</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">exp</span><span class="p">,</span> <span class="n">T</span> <span class="n">desr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memcmp</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">exp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// if (*obj == *exp)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">desr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span> <span class="c1">// *obj = desr;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span> <span class="c1">// *exp = *obj;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">__atomic_fetch_add</span><span class="p">(</span><span class="n">T</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">T</span> <span class="n">operand</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="n">T</span> <span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
    <span class="o">*</span><span class="n">obj</span> <span class="o">+=</span> <span class="n">operand</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">__atomic_fetch_sub</span><span class="p">(</span><span class="n">T</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">T</span> <span class="n">operand</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="n">T</span> <span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
    <span class="o">*</span><span class="n">obj</span> <span class="o">-=</span> <span class="n">operand</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">__atomic_fetch_and</span><span class="p">(</span><span class="n">T</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">T</span> <span class="n">operand</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="n">T</span> <span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
    <span class="o">*</span><span class="n">obj</span> <span class="o">&amp;=</span> <span class="n">operand</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">__atomic_fetch_or</span><span class="p">(</span><span class="n">T</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">T</span> <span class="n">operand</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="n">T</span> <span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
    <span class="o">*</span><span class="n">obj</span> <span class="o">|=</span> <span class="n">operand</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">__atomic_fetch_xor</span><span class="p">(</span><span class="n">T</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">T</span> <span class="n">operand</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="n">T</span> <span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
    <span class="o">*</span><span class="n">obj</span> <span class="o">^=</span> <span class="n">operand</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span> <span class="n">__atomic_fetch_add</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">operand</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
    <span class="p">(</span><span class="kt">char</span><span class="o">*&amp;</span><span class="p">)(</span><span class="o">*</span><span class="n">obj</span><span class="p">)</span> <span class="o">+=</span> <span class="n">operand</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span> <span class="n">__atomic_fetch_sub</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">operand</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
    <span class="p">(</span><span class="kt">char</span><span class="o">*&amp;</span><span class="p">)(</span><span class="o">*</span><span class="n">obj</span><span class="p">)</span> <span class="o">-=</span> <span class="n">operand</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__atomic_thread_fence</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__atomic_signal_fence</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="design-b-something-in-between">
<h2>Design B: Something in between<a class="headerlink" href="#design-b-something-in-between" title="Permalink to this headline">¶</a></h2>
<p>This is a variation of design A which puts the burden on the library to arrange
for the correct manipulation of the run time memory ordering arguments, and only
calls the compiler for well-defined memory orderings. I think of this design as
the worst of A and C, instead of the best of A and C. But I offer it as an
option in the spirit of completeness.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// type must be trivially copyable</span>
<span class="kt">bool</span> <span class="nf">__atomic_is_lock_free</span><span class="p">(</span><span class="k">const</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">);</span>

<span class="c1">// type must be trivially copyable</span>
<span class="n">type</span> <span class="nf">__atomic_load_relaxed</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_load_consume</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_load_acquire</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_load_seq_cst</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">);</span>

<span class="c1">// type must be trivially copyable</span>
<span class="n">type</span> <span class="nf">__atomic_store_relaxed</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_store_release</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_store_seq_cst</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>

<span class="c1">// type must be trivially copyable</span>
<span class="n">type</span> <span class="nf">__atomic_exchange_relaxed</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_exchange_consume</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_exchange_acquire</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_exchange_release</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_exchange_acq_rel</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_exchange_seq_cst</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>

<span class="c1">// type must be trivially copyable</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_strong_relaxed_relaxed</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_strong_consume_relaxed</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_strong_consume_consume</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_strong_acquire_relaxed</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_strong_acquire_consume</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_strong_acquire_acquire</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_strong_release_relaxed</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_strong_release_consume</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_strong_release_acquire</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_strong_acq_rel_relaxed</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_strong_acq_rel_consume</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_strong_acq_rel_acquire</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_strong_seq_cst_relaxed</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_strong_seq_cst_consume</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_strong_seq_cst_acquire</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_strong_seq_cst_seq_cst</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>

<span class="c1">// type must be trivially copyable</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_weak_relaxed_relaxed</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_weak_consume_relaxed</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_weak_consume_consume</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_weak_acquire_relaxed</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_weak_acquire_consume</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_weak_acquire_acquire</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_weak_release_relaxed</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_weak_release_consume</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_weak_release_acquire</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_weak_acq_rel_relaxed</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_weak_acq_rel_consume</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_weak_acq_rel_acquire</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_weak_seq_cst_relaxed</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_weak_seq_cst_consume</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_weak_seq_cst_acquire</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">__atomic_compare_exchange_weak_seq_cst_seq_cst</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span>
                                                    <span class="n">type</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span>
                                                    <span class="n">type</span> <span class="n">desired</span><span class="p">);</span>

<span class="c1">// type is one of: char, signed char, unsigned char, short, unsigned short, int,</span>
<span class="c1">//      unsigned int, long, unsigned long, long long, unsigned long long,</span>
<span class="c1">//      char16_t, char32_t, wchar_t</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_add_relaxed</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_add_consume</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_add_acquire</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_add_release</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_add_acq_rel</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_add_seq_cst</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>

<span class="c1">// type is one of: char, signed char, unsigned char, short, unsigned short, int,</span>
<span class="c1">//      unsigned int, long, unsigned long, long long, unsigned long long,</span>
<span class="c1">//      char16_t, char32_t, wchar_t</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_sub_relaxed</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_sub_consume</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_sub_acquire</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_sub_release</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_sub_acq_rel</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_sub_seq_cst</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>

<span class="c1">// type is one of: char, signed char, unsigned char, short, unsigned short, int,</span>
<span class="c1">//      unsigned int, long, unsigned long, long long, unsigned long long,</span>
<span class="c1">//      char16_t, char32_t, wchar_t</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_and_relaxed</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_and_consume</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_and_acquire</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_and_release</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_and_acq_rel</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_and_seq_cst</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>

<span class="c1">// type is one of: char, signed char, unsigned char, short, unsigned short, int,</span>
<span class="c1">//      unsigned int, long, unsigned long, long long, unsigned long long,</span>
<span class="c1">//      char16_t, char32_t, wchar_t</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_or_relaxed</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_or_consume</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_or_acquire</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_or_release</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_or_acq_rel</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_or_seq_cst</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>

<span class="c1">// type is one of: char, signed char, unsigned char, short, unsigned short, int,</span>
<span class="c1">//      unsigned int, long, unsigned long, long long, unsigned long long,</span>
<span class="c1">//      char16_t, char32_t, wchar_t</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_xor_relaxed</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_xor_consume</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_xor_acquire</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_xor_release</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_xor_acq_rel</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>
<span class="n">type</span> <span class="nf">__atomic_fetch_xor_seq_cst</span><span class="p">(</span><span class="k">volatile</span> <span class="n">type</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="n">type</span> <span class="n">operand</span><span class="p">);</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">__atomic_fetch_add_relaxed</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">operand</span><span class="p">);</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">__atomic_fetch_add_consume</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">operand</span><span class="p">);</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">__atomic_fetch_add_acquire</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">operand</span><span class="p">);</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">__atomic_fetch_add_release</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">operand</span><span class="p">);</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">__atomic_fetch_add_acq_rel</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">operand</span><span class="p">);</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">__atomic_fetch_add_seq_cst</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">operand</span><span class="p">);</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">__atomic_fetch_sub_relaxed</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">operand</span><span class="p">);</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">__atomic_fetch_sub_consume</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">operand</span><span class="p">);</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">__atomic_fetch_sub_acquire</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">operand</span><span class="p">);</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">__atomic_fetch_sub_release</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">operand</span><span class="p">);</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">__atomic_fetch_sub_acq_rel</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">operand</span><span class="p">);</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">__atomic_fetch_sub_seq_cst</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">atomic_obj</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">operand</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">__atomic_thread_fence_relaxed</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">__atomic_thread_fence_consume</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">__atomic_thread_fence_acquire</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">__atomic_thread_fence_release</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">__atomic_thread_fence_acq_rel</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">__atomic_thread_fence_seq_cst</span><span class="p">();</span>

<span class="kt">void</span> <span class="nf">__atomic_signal_fence_relaxed</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">__atomic_signal_fence_consume</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">__atomic_signal_fence_acquire</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">__atomic_signal_fence_release</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">__atomic_signal_fence_acq_rel</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">__atomic_signal_fence_seq_cst</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="design-c-minimal-work-for-the-front-end">
<h2>Design C: Minimal work for the front end<a class="headerlink" href="#design-c-minimal-work-for-the-front-end" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">&lt;atomic&gt;</span></code> header is one of the most closely coupled headers to the compiler.
Ideally when you invoke any function from <code class="docutils literal notranslate"><span class="pre">&lt;atomic&gt;</span></code>, it should result in highly
optimized assembly being inserted directly into your application – assembly that
is not otherwise representable by higher level C or C++ expressions. The design of
the libc++ <code class="docutils literal notranslate"><span class="pre">&lt;atomic&gt;</span></code> header started with this goal in mind. A secondary, but
still very important goal is that the compiler should have to do minimal work to
facilitate the implementation of <code class="docutils literal notranslate"><span class="pre">&lt;atomic&gt;</span></code>.  Without this second goal, then
practically speaking, the libc++ <code class="docutils literal notranslate"><span class="pre">&lt;atomic&gt;</span></code> header would be doomed to be a
barely supported, second class citizen on almost every platform.</p>
<p>Goals:</p>
<ul class="simple">
<li><p>Optimal code generation for atomic operations</p></li>
<li><p>Minimal effort for the compiler to achieve goal 1 on any given platform</p></li>
<li><p>Conformance to the C++0X draft standard</p></li>
</ul>
<p>The purpose of this document is to inform compiler writers what they need to do
to enable a high performance libc++ <code class="docutils literal notranslate"><span class="pre">&lt;atomic&gt;</span></code> with minimal effort.</p>
<div class="section" id="the-minimal-work-that-must-be-done-for-a-conforming-atomic">
<h3>The minimal work that must be done for a conforming <code class="docutils literal notranslate"><span class="pre">&lt;atomic&gt;</span></code><a class="headerlink" href="#the-minimal-work-that-must-be-done-for-a-conforming-atomic" title="Permalink to this headline">¶</a></h3>
<p>The only “atomic” operations that must actually be lock free in
<code class="docutils literal notranslate"><span class="pre">&lt;atomic&gt;</span></code> are represented by the following compiler intrinsics:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">__atomic_flag__</span> <span class="nf">__atomic_exchange_seq_cst</span><span class="p">(</span><span class="n">__atomic_flag__</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">__atomic_flag__</span> <span class="n">desr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="n">__atomic_flag__</span> <span class="n">result</span> <span class="o">=</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
    <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">desr</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__atomic_store_seq_cst</span><span class="p">(</span><span class="n">__atomic_flag__</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">__atomic_flag__</span> <span class="n">desr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">desr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Where:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">__has_feature(__atomic_flag)</span></code> evaluates to 1 in the preprocessor then
the compiler must define <code class="docutils literal notranslate"><span class="pre">__atomic_flag__</span></code> (e.g. as a typedef to <code class="docutils literal notranslate"><span class="pre">int</span></code>).</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">__has_feature(__atomic_flag)</span></code> evaluates to 0 in the preprocessor then
the library defines <code class="docutils literal notranslate"><span class="pre">__atomic_flag__</span></code> as a typedef to <code class="docutils literal notranslate"><span class="pre">bool</span></code>.</p></li>
<li><p>To communicate that the above intrinsics are available, the compiler must
arrange for <code class="docutils literal notranslate"><span class="pre">__has_feature</span></code> to return 1 when fed the intrinsic name
appended with an ‘_’ and the mangled type name of <code class="docutils literal notranslate"><span class="pre">__atomic_flag__</span></code>.</p></li>
</ul>
<p>For example if <code class="docutils literal notranslate"><span class="pre">__atomic_flag__</span></code> is <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// __has_feature(__atomic_flag) == 1</span>
<span class="c1">// __has_feature(__atomic_exchange_seq_cst_j) == 1</span>
<span class="c1">// __has_feature(__atomic_store_seq_cst_j) == 1</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__atomic_flag__</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__atomic_exchange_seq_cst</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="k">volatile</span><span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__atomic_store_seq_cst</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="k">volatile</span><span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>That’s it! Compiler writers do the above and you’ve got a fully conforming
(though sub-par performance) <code class="docutils literal notranslate"><span class="pre">&lt;atomic&gt;</span></code> header!</p>
</div>
<div class="section" id="recommended-work-for-a-higher-performance-atomic">
<h3>Recommended work for a higher performance <code class="docutils literal notranslate"><span class="pre">&lt;atomic&gt;</span></code><a class="headerlink" href="#recommended-work-for-a-higher-performance-atomic" title="Permalink to this headline">¶</a></h3>
<p>It would be good if the above intrinsics worked with all integral types plus
<code class="docutils literal notranslate"><span class="pre">void*</span></code>. Because this may not be possible to do in a lock-free manner for
all integral types on all platforms, a compiler must communicate each type that
an intrinsic works with. For example, if <code class="docutils literal notranslate"><span class="pre">__atomic_exchange_seq_cst</span></code> works
for all types except for <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code> and <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code> then:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">__has_feature</span><span class="p">(</span><span class="n">__atomic_exchange_seq_cst_b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1">// bool</span>
<span class="n">__has_feature</span><span class="p">(</span><span class="n">__atomic_exchange_seq_cst_c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1">// char</span>
<span class="n">__has_feature</span><span class="p">(</span><span class="n">__atomic_exchange_seq_cst_a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1">// signed char</span>
<span class="n">__has_feature</span><span class="p">(</span><span class="n">__atomic_exchange_seq_cst_h</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1">// unsigned char</span>
<span class="n">__has_feature</span><span class="p">(</span><span class="n">__atomic_exchange_seq_cst_Ds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="c1">// char16_t</span>
<span class="n">__has_feature</span><span class="p">(</span><span class="n">__atomic_exchange_seq_cst_Di</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="c1">// char32_t</span>
<span class="n">__has_feature</span><span class="p">(</span><span class="n">__atomic_exchange_seq_cst_w</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1">// wchar_t</span>
<span class="n">__has_feature</span><span class="p">(</span><span class="n">__atomic_exchange_seq_cst_s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1">// short</span>
<span class="n">__has_feature</span><span class="p">(</span><span class="n">__atomic_exchange_seq_cst_t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1">// unsigned short</span>
<span class="n">__has_feature</span><span class="p">(</span><span class="n">__atomic_exchange_seq_cst_i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1">// int</span>
<span class="n">__has_feature</span><span class="p">(</span><span class="n">__atomic_exchange_seq_cst_j</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1">// unsigned int</span>
<span class="n">__has_feature</span><span class="p">(</span><span class="n">__atomic_exchange_seq_cst_l</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1">// long</span>
<span class="n">__has_feature</span><span class="p">(</span><span class="n">__atomic_exchange_seq_cst_m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1">// unsigned long</span>
<span class="n">__has_feature</span><span class="p">(</span><span class="n">__atomic_exchange_seq_cst_Pv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="c1">// void*</span>
</pre></div>
</div>
<p>Note that only the <code class="docutils literal notranslate"><span class="pre">__has_feature</span></code> flag is decorated with the argument
type. The name of the compiler intrinsic is not decorated, but instead works
like a C++ overloaded function.</p>
<p>Additionally, there are other intrinsics besides <code class="docutils literal notranslate"><span class="pre">__atomic_exchange_seq_cst</span></code>
and <code class="docutils literal notranslate"><span class="pre">__atomic_store_seq_cst</span></code>. They are optional. But if the compiler can
generate faster code than provided by the library, then clients will benefit
from the compiler writer’s expertise and knowledge of the targeted platform.</p>
<p>Below is the complete list of <em>sequentially consistent</em> intrinsics, and
their library implementations. Template syntax is used to indicate the desired
overloading for integral and <code class="docutils literal notranslate"><span class="pre">void*</span></code> types. The template does not represent a
requirement that the intrinsic operate on <strong>any</strong> type!</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// T is one of:</span>
<span class="c1">// bool, char, signed char, unsigned char, short, unsigned short,</span>
<span class="c1">// int, unsigned int, long, unsigned long,</span>
<span class="c1">// long long, unsigned long long, char16_t, char32_t, wchar_t, void*</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">__atomic_load_seq_cst</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">__atomic_store_seq_cst</span><span class="p">(</span><span class="n">T</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">T</span> <span class="n">desr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">desr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">__atomic_exchange_seq_cst</span><span class="p">(</span><span class="n">T</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">T</span> <span class="n">desr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="n">T</span> <span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
    <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">desr</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">__atomic_compare_exchange_strong_seq_cst_seq_cst</span><span class="p">(</span><span class="n">T</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">exp</span><span class="p">,</span> <span class="n">T</span> <span class="n">desr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memcmp</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">exp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">desr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">__atomic_compare_exchange_weak_seq_cst_seq_cst</span><span class="p">(</span><span class="n">T</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">exp</span><span class="p">,</span> <span class="n">T</span> <span class="n">desr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memcmp</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">exp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">desr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// T is one of:</span>
<span class="c1">// char, signed char, unsigned char, short, unsigned short,</span>
<span class="c1">// int, unsigned int, long, unsigned long,</span>
<span class="c1">// long long, unsigned long long, char16_t, char32_t, wchar_t</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">__atomic_fetch_add_seq_cst</span><span class="p">(</span><span class="n">T</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">T</span> <span class="n">operand</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="n">T</span> <span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
    <span class="o">*</span><span class="n">obj</span> <span class="o">+=</span> <span class="n">operand</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">__atomic_fetch_sub_seq_cst</span><span class="p">(</span><span class="n">T</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">T</span> <span class="n">operand</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="n">T</span> <span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
    <span class="o">*</span><span class="n">obj</span> <span class="o">-=</span> <span class="n">operand</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">__atomic_fetch_and_seq_cst</span><span class="p">(</span><span class="n">T</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">T</span> <span class="n">operand</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="n">T</span> <span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
    <span class="o">*</span><span class="n">obj</span> <span class="o">&amp;=</span> <span class="n">operand</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">__atomic_fetch_or_seq_cst</span><span class="p">(</span><span class="n">T</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">T</span> <span class="n">operand</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="n">T</span> <span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
    <span class="o">*</span><span class="n">obj</span> <span class="o">|=</span> <span class="n">operand</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">__atomic_fetch_xor_seq_cst</span><span class="p">(</span><span class="n">T</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">T</span> <span class="n">operand</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="n">T</span> <span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
    <span class="o">*</span><span class="n">obj</span> <span class="o">^=</span> <span class="n">operand</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span> <span class="n">__atomic_fetch_add_seq_cst</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">operand</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
    <span class="p">(</span><span class="kt">char</span><span class="o">*&amp;</span><span class="p">)(</span><span class="o">*</span><span class="n">obj</span><span class="p">)</span> <span class="o">+=</span> <span class="n">operand</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span> <span class="n">__atomic_fetch_sub_seq_cst</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">operand</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
    <span class="p">(</span><span class="kt">char</span><span class="o">*&amp;</span><span class="p">)(</span><span class="o">*</span><span class="n">obj</span><span class="p">)</span> <span class="o">-=</span> <span class="n">operand</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__atomic_thread_fence_seq_cst</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__atomic_signal_fence_seq_cst</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_</span><span class="p">(</span><span class="n">some_mutex</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>One should consult the (currently draft) <a class="reference external" href="https://wg21.link/n3126">C++ Standard</a>
for the details of the definitions for these operations. For example,
<code class="docutils literal notranslate"><span class="pre">__atomic_compare_exchange_weak_seq_cst_seq_cst</span></code> is allowed to fail
spuriously while <code class="docutils literal notranslate"><span class="pre">__atomic_compare_exchange_strong_seq_cst_seq_cst</span></code> is not.</p>
<p>If on your platform the lock-free definition of <code class="docutils literal notranslate"><span class="pre">__atomic_compare_exchange_weak_seq_cst_seq_cst</span></code>
would be the same as <code class="docutils literal notranslate"><span class="pre">__atomic_compare_exchange_strong_seq_cst_seq_cst</span></code>, you may omit the
<code class="docutils literal notranslate"><span class="pre">__atomic_compare_exchange_weak_seq_cst_seq_cst</span></code> intrinsic without a performance cost. The
library will prefer your implementation of <code class="docutils literal notranslate"><span class="pre">__atomic_compare_exchange_strong_seq_cst_seq_cst</span></code>
over its own definition for implementing <code class="docutils literal notranslate"><span class="pre">__atomic_compare_exchange_weak_seq_cst_seq_cst</span></code>.
That is, the library will arrange for <code class="docutils literal notranslate"><span class="pre">__atomic_compare_exchange_weak_seq_cst_seq_cst</span></code> to call
<code class="docutils literal notranslate"><span class="pre">__atomic_compare_exchange_strong_seq_cst_seq_cst</span></code> if you supply an intrinsic for the strong
version but not the weak.</p>
</div>
<div class="section" id="taking-advantage-of-weaker-memory-synchronization">
<h3>Taking advantage of weaker memory synchronization<a class="headerlink" href="#taking-advantage-of-weaker-memory-synchronization" title="Permalink to this headline">¶</a></h3>
<p>So far, all of the intrinsics presented require a <strong>sequentially consistent</strong> memory ordering.
That is, no loads or stores can move across the operation (just as if the library had locked
that internal mutex). But <code class="docutils literal notranslate"><span class="pre">&lt;atomic&gt;</span></code> supports weaker memory ordering operations. In all,
there are six memory orderings (listed here from strongest to weakest):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">memory_order_seq_cst</span>
<span class="n">memory_order_acq_rel</span>
<span class="n">memory_order_release</span>
<span class="n">memory_order_acquire</span>
<span class="n">memory_order_consume</span>
<span class="n">memory_order_relaxed</span>
</pre></div>
</div>
<p>(See the <a class="reference external" href="https://wg21.link/n3126">C++ Standard</a> for the detailed definitions of each of these orderings).</p>
<p>On some platforms, the compiler vendor can offer some or even all of the above
intrinsics at one or more weaker levels of memory synchronization. This might
lead for example to not issuing an <code class="docutils literal notranslate"><span class="pre">mfence</span></code> instruction on the x86.</p>
<p>If the compiler does not offer any given operation, at any given memory ordering
level, the library will automatically attempt to call the next highest memory
ordering operation. This continues up to <code class="docutils literal notranslate"><span class="pre">seq_cst</span></code>, and if that doesn’t
exist, then the library takes over and does the job with a <code class="docutils literal notranslate"><span class="pre">mutex</span></code>. This
is a compile-time search and selection operation. At run time, the application
will only see the few inlined assembly instructions for the selected intrinsic.</p>
<p>Each intrinsic is appended with the 7-letter name of the memory ordering it
addresses. For example a <code class="docutils literal notranslate"><span class="pre">load</span></code> with <code class="docutils literal notranslate"><span class="pre">relaxed</span></code> ordering is defined by:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="nf">__atomic_load_relaxed</span><span class="p">(</span><span class="k">const</span> <span class="k">volatile</span> <span class="n">T</span><span class="o">*</span> <span class="n">obj</span><span class="p">);</span>
</pre></div>
</div>
<p>And announced with:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">__has_feature</span><span class="p">(</span><span class="n">__atomic_load_relaxed_b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1">// bool</span>
<span class="n">__has_feature</span><span class="p">(</span><span class="n">__atomic_load_relaxed_c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1">// char</span>
<span class="n">__has_feature</span><span class="p">(</span><span class="n">__atomic_load_relaxed_a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1">// signed char</span>
<span class="p">...</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">__atomic_compare_exchange_strong(weak)</span></code> intrinsics are parameterized
on two memory orderings. The first ordering applies when the operation returns
<code class="docutils literal notranslate"><span class="pre">true</span></code> and the second ordering applies when the operation returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p>Not every memory ordering is appropriate for every operation. <code class="docutils literal notranslate"><span class="pre">exchange</span></code>
and the <code class="docutils literal notranslate"><span class="pre">fetch_XXX</span></code> operations support all 6. But <code class="docutils literal notranslate"><span class="pre">load</span></code> only supports
<code class="docutils literal notranslate"><span class="pre">relaxed</span></code>, <code class="docutils literal notranslate"><span class="pre">consume</span></code>, <code class="docutils literal notranslate"><span class="pre">acquire</span></code> and <code class="docutils literal notranslate"><span class="pre">seq_cst</span></code>. <code class="docutils literal notranslate"><span class="pre">store</span></code> only supports
<code class="docutils literal notranslate"><span class="pre">relaxed</span></code>, <code class="docutils literal notranslate"><span class="pre">release</span></code>, and <code class="docutils literal notranslate"><span class="pre">seq_cst</span></code>. The <code class="docutils literal notranslate"><span class="pre">compare_exchange</span></code> operations
support the following 16 combinations out of the possible 36:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">relaxed_relaxed</span>
<span class="n">consume_relaxed</span>
<span class="n">consume_consume</span>
<span class="n">acquire_relaxed</span>
<span class="n">acquire_consume</span>
<span class="n">acquire_acquire</span>
<span class="n">release_relaxed</span>
<span class="n">release_consume</span>
<span class="n">release_acquire</span>
<span class="n">acq_rel_relaxed</span>
<span class="n">acq_rel_consume</span>
<span class="n">acq_rel_acquire</span>
<span class="n">seq_cst_relaxed</span>
<span class="n">seq_cst_consume</span>
<span class="n">seq_cst_acquire</span>
<span class="n">seq_cst_seq_cst</span>
</pre></div>
</div>
<p>Again, the compiler supplies intrinsics only for the strongest orderings where
it can make a difference. The library takes care of calling the weakest
supplied intrinsic that is as strong or stronger than the customer asked for.</p>
</div>
</div>
<div class="section" id="note-about-abi">
<h2>Note about ABI<a class="headerlink" href="#note-about-abi" title="Permalink to this headline">¶</a></h2>
<p>With any design, the (back end) compiler writer should note that the decision to
implement lock-free operations on any given type (or not) is an ABI-binding decision.
One can not change from treating a type as not lock free, to lock free (or vice-versa)
without breaking your ABI.</p>
<p>For example:</p>
<p><strong>TU1.cpp</strong>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="n">atomic</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">A</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span> <span class="p">}</span>
</pre></div>
</div>
<p><strong>TU2.cpp</strong>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="n">atomic</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">A</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span> <span class="p">}</span>
</pre></div>
</div>
<p>If only <strong>one</strong> of these calls to <code class="docutils literal notranslate"><span class="pre">compare_exchange_strong</span></code> is implemented with
mutex-locked code, then that mutex-locked code will not be executed mutually
exclusively of the one implemented in a lock-free manner.</p>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="ABIVersioning.html">Libc++ ABI stability</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="CapturingConfigInfo.html">Capturing configuration information during installation</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2011-2022, LLVM Project.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.1.2.
    </div>
  </body>
</html>