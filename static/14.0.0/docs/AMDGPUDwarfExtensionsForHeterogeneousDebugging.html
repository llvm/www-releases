

<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DWARF Extensions For Heterogeneous Debugging &#8212; LLVM 14.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/llvm-theme.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Allow Location Descriptions on the DWARF Expression Stack" href="AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack/AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack.html" />
    <link rel="prev" title="AMDGPU Instructions Notation" href="AMDGPUInstructionNotation.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack/AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack.html" title="Allow Location Descriptions on the DWARF Expression Stack"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="AMDGPUInstructionNotation.html" title="AMDGPU Instructions Notation"
             accesskey="P">previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" >User Guides</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="AMDGPUUsage.html" accesskey="U">User Guide for AMDGPU Backend</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">DWARF Extensions For Heterogeneous Debugging</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="https://llvm.org/docs/UserGuides.html">User Guides</a></li>
    <li><a href="https://llvm.org/docs/Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/Contributing.html">Contributing to LLVM</a></li>
    <li><a href="https://llvm.org/docs/HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#irc">IRC</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/FAQ.html">FAQ</a></li>
    <li><a href="https://llvm.org/docs/Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project//">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="dwarf-extensions-for-heterogeneous-debugging">
<span id="amdgpu-dwarf-extensions-for-heterogeneous-debugging"></span><h1>DWARF Extensions For Heterogeneous Debugging<a class="headerlink" href="#dwarf-extensions-for-heterogeneous-debugging" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id1">1. Introduction</a></p></li>
<li><p><a class="reference internal" href="#extensions" id="id2">1. Extensions</a></p>
<ul>
<li><p><a class="reference internal" href="#allow-location-description-on-the-dwarf-expression-stack" id="id3">2.1 Allow Location Description on the DWARF Expression Stack</a></p></li>
<li><p><a class="reference internal" href="#generalize-cfi-to-allow-any-location-description-kind" id="id4">2.2 Generalize CFI to Allow Any Location Description Kind</a></p></li>
<li><p><a class="reference internal" href="#generalize-dwarf-operation-expressions-to-support-multiple-places" id="id5">2.3 Generalize DWARF Operation Expressions to Support Multiple Places</a></p></li>
<li><p><a class="reference internal" href="#generalize-offsetting-of-location-descriptions" id="id6">2.4 Generalize Offsetting of Location Descriptions</a></p></li>
<li><p><a class="reference internal" href="#generalize-creation-of-undefined-location-descriptions" id="id7">2.5 Generalize Creation of Undefined Location Descriptions</a></p></li>
<li><p><a class="reference internal" href="#generalize-creation-of-composite-location-descriptions" id="id8">2.6 Generalize Creation of Composite Location Descriptions</a></p></li>
<li><p><a class="reference internal" href="#generalize-dwarf-base-objects-to-allow-any-location-description-kind" id="id9">2.7 Generalize DWARF Base Objects to Allow Any Location Description Kind</a></p></li>
<li><p><a class="reference internal" href="#general-support-for-address-spaces" id="id10">2.8 General Support for Address Spaces</a></p></li>
<li><p><a class="reference internal" href="#support-for-vector-base-types" id="id11">2.9 Support for Vector Base Types</a></p></li>
<li><p><a class="reference internal" href="#dwarf-operations-to-create-vector-composite-location-descriptions" id="id12">2.10 DWARF Operations to Create Vector Composite Location Descriptions</a></p></li>
<li><p><a class="reference internal" href="#dwarf-operation-to-access-call-frame-entry-registers" id="id13">2.11 DWARF Operation to Access Call Frame Entry Registers</a></p></li>
<li><p><a class="reference internal" href="#support-for-source-languages-mapped-to-simt-hardware" id="id14">2.12 Support for Source Languages Mapped to SIMT Hardware</a></p></li>
<li><p><a class="reference internal" href="#support-for-divergent-control-flow-of-simt-hardware" id="id15">2.13 Support for Divergent Control Flow of SIMT Hardware</a></p></li>
<li><p><a class="reference internal" href="#define-source-language-address-classes" id="id16">2.14 Define Source Language Address Classes</a></p></li>
<li><p><a class="reference internal" href="#define-augmentation-strings-to-support-multiple-extensions" id="id17">2.15 Define Augmentation Strings to Support Multiple Extensions</a></p></li>
<li><p><a class="reference internal" href="#support-embedding-source-text-for-online-compilation" id="id18">2.16 Support Embedding Source Text for Online Compilation</a></p></li>
<li><p><a class="reference internal" href="#allow-md5-checksums-to-be-optionally-present" id="id19">2.17 Allow MD5 Checksums to be Optionally Present</a></p></li>
<li><p><a class="reference internal" href="#add-the-hip-programing-language" id="id20">2.18 Add the HIP Programing Language</a></p></li>
<li><p><a class="reference internal" href="#support-for-source-language-optimizations-that-result-in-concurrent-iteration-execution" id="id21">2.19 Support for Source Language Optimizations that Result in Concurrent Iteration Execution</a></p></li>
<li><p><a class="reference internal" href="#dwarf-operation-to-create-runtime-overlay-composite-location-description" id="id22">2.20 DWARF Operation to Create Runtime Overlay Composite Location Description</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#a-changes-relative-to-dwarf-version-5" id="id23">A. Changes Relative to DWARF Version 5</a></p>
<ul>
<li><p><a class="reference internal" href="#a-2-general-description" id="id24">A.2 General Description</a></p>
<ul>
<li><p><a class="reference internal" href="#a-2-2-attribute-types" id="id25">A.2.2 Attribute Types</a></p></li>
<li><p><a class="reference internal" href="#a-2-5-dwarf-expressions" id="id26">A.2.5 DWARF Expressions</a></p>
<ul>
<li><p><a class="reference internal" href="#a-2-5-1-dwarf-expression-evaluation-context" id="id27">A.2.5.1 DWARF Expression Evaluation Context</a></p></li>
<li><p><a class="reference internal" href="#a-2-5-2-dwarf-expression-value" id="id28">A.2.5.2 DWARF Expression Value</a></p></li>
<li><p><a class="reference internal" href="#a-2-5-3-dwarf-location-description" id="id29">A.2.5.3 DWARF Location Description</a></p></li>
<li><p><a class="reference internal" href="#a-2-5-4-dwarf-operation-expressions" id="id30">A.2.5.4 DWARF Operation Expressions</a></p>
<ul>
<li><p><a class="reference internal" href="#a-2-5-4-1-stack-operations" id="id31">A.2.5.4.1 Stack Operations</a></p></li>
<li><p><a class="reference internal" href="#a-2-5-4-2-control-flow-operations" id="id32">A.2.5.4.2 Control Flow Operations</a></p></li>
<li><p><a class="reference internal" href="#a-2-5-4-3-value-operations" id="id33">A.2.5.4.3 Value Operations</a></p>
<ul>
<li><p><a class="reference internal" href="#a-2-5-4-3-1-literal-operations" id="id34">A.2.5.4.3.1 Literal Operations</a></p></li>
<li><p><a class="reference internal" href="#a-2-5-4-3-2-arithmetic-and-logical-operations" id="id35">A.2.5.4.3.2 Arithmetic and Logical Operations</a></p></li>
<li><p><a class="reference internal" href="#a-2-5-4-3-3-type-conversion-operations" id="id36">A.2.5.4.3.3 Type Conversion Operations</a></p></li>
<li><p><a class="reference internal" href="#a-2-5-4-3-4-special-value-operations" id="id37">A.2.5.4.3.4 Special Value Operations</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#a-2-5-4-4-location-description-operations" id="id38">A.2.5.4.4 Location Description Operations</a></p>
<ul>
<li><p><a class="reference internal" href="#a-2-5-4-4-1-general-location-description-operations" id="id39">A.2.5.4.4.1 General Location Description Operations</a></p></li>
<li><p><a class="reference internal" href="#a-2-5-4-4-2-undefined-location-description-operations" id="id40">A.2.5.4.4.2 Undefined Location Description Operations</a></p></li>
<li><p><a class="reference internal" href="#a-2-5-4-4-3-memory-location-description-operations" id="id41">A.2.5.4.4.3 Memory Location Description Operations</a></p></li>
<li><p><a class="reference internal" href="#a-2-5-4-4-4-register-location-description-operations" id="id42">A.2.5.4.4.4 Register Location Description Operations</a></p></li>
<li><p><a class="reference internal" href="#a-2-5-4-4-5-implicit-location-description-operations" id="id43">A.2.5.4.4.5 Implicit Location Description Operations</a></p></li>
<li><p><a class="reference internal" href="#a-2-5-4-4-6-composite-location-description-operations" id="id44">A.2.5.4.4.6 Composite Location Description Operations</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#a-2-5-5-dwarf-location-list-expressions" id="id45">A.2.5.5 DWARF Location List Expressions</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#a-2-12-segmented-addresses" id="id46">A.2.12 Segmented Addresses</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#a-3-program-scope-entries" id="id47">A.3 Program Scope Entries</a></p>
<ul>
<li><p><a class="reference internal" href="#a-3-1-unit-entries" id="id48">A.3.1 Unit Entries</a></p>
<ul>
<li><p><a class="reference internal" href="#a-3-1-1-full-and-partial-compilation-unit-entries" id="id49">A.3.1.1 Full and Partial Compilation Unit Entries</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#a-3-3-subroutine-and-entry-point-entries" id="id50">A.3.3 Subroutine and Entry Point Entries</a></p>
<ul>
<li><p><a class="reference internal" href="#a-3-3-5-low-level-information" id="id51">A.3.3.5 Low-Level Information</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#a-3-4-call-site-entries-and-parameters" id="id52">A.3.4 Call Site Entries and Parameters</a></p>
<ul>
<li><p><a class="reference internal" href="#a-3-4-2-call-site-parameters" id="id53">A.3.4.2 Call Site Parameters</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#a-3-5-lexical-block-entries" id="id54">A.3.5 Lexical Block Entries</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#a-4-data-object-and-object-list-entries" id="id55">A.4 Data Object and Object List Entries</a></p>
<ul>
<li><p><a class="reference internal" href="#a-4-1-data-object-entries" id="id56">A.4.1 Data Object Entries</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#a-5-type-entries" id="id57">A.5 Type Entries</a></p>
<ul>
<li><p><a class="reference internal" href="#a-5-1-base-type-entries" id="id58">A.5.1 Base Type Entries</a></p></li>
<li><p><a class="reference internal" href="#a-5-7-structure-union-class-and-interface-type-entries" id="id59">A.5.7 Structure, Union, Class and Interface Type Entries</a></p>
<ul>
<li><p><a class="reference internal" href="#a-5-7-3-derived-or-extended-structures-classes-and-interfaces" id="id60">A.5.7.3 Derived or Extended Structures, Classes and Interfaces</a></p></li>
<li><p><a class="reference internal" href="#a-5-7-8-member-function-entries" id="id61">A.5.7.8 Member Function Entries</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#a-5-14-pointer-to-member-type-entries" id="id62">A.5.14 Pointer to Member Type Entries</a></p></li>
<li><p><a class="reference internal" href="#a-5-16-dynamic-type-entries" id="id63">A.5.16 Dynamic Type Entries</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#a-6-other-debugging-information" id="id64">A.6 Other Debugging Information</a></p>
<ul>
<li><p><a class="reference internal" href="#a-6-1-accelerated-access" id="id65">A.6.1 Accelerated Access</a></p>
<ul>
<li><p><a class="reference internal" href="#a-6-1-1-lookup-by-name" id="id66">A.6.1.1 Lookup By Name</a></p>
<ul>
<li><p><a class="reference internal" href="#a-6-1-1-1-contents-of-the-name-index" id="id67">A.6.1.1.1 Contents of the Name Index</a></p></li>
<li><p><a class="reference internal" href="#a-6-1-1-4-data-representation-of-the-name-index" id="id68">A.6.1.1.4 Data Representation of the Name Index</a></p>
<ul>
<li><p><a class="reference internal" href="#a-6-1-1-4-1-section-header" id="id69">A.6.1.1.4.1 Section Header</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#a-6-2-line-number-information" id="id70">A.6.2 Line Number Information</a></p>
<ul>
<li><p><a class="reference internal" href="#a-6-2-4-the-line-number-program-header" id="id71">A.6.2.4 The Line Number Program Header</a></p>
<ul>
<li><p><a class="reference internal" href="#a-6-2-4-1-standard-content-descriptions" id="id72">A.6.2.4.1 Standard Content Descriptions</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#a-6-4-call-frame-information" id="id73">A.6.4 Call Frame Information</a></p>
<ul>
<li><p><a class="reference internal" href="#a-6-4-1-structure-of-call-frame-information" id="id74">A.6.4.1 Structure of Call Frame Information</a></p></li>
<li><p><a class="reference internal" href="#a-6-4-2-call-frame-instructions" id="id75">A.6.4.2 Call Frame Instructions</a></p>
<ul>
<li><p><a class="reference internal" href="#a-6-4-2-1-row-creation-instructions" id="id76">A.6.4.2.1 Row Creation Instructions</a></p></li>
<li><p><a class="reference internal" href="#a-6-4-2-2-cfa-definition-instructions" id="id77">A.6.4.2.2 CFA Definition Instructions</a></p></li>
<li><p><a class="reference internal" href="#a-6-4-2-3-register-rule-instructions" id="id78">A.6.4.2.3 Register Rule Instructions</a></p></li>
<li><p><a class="reference internal" href="#a-6-4-2-4-row-state-instructions" id="id79">A.6.4.2.4 Row State Instructions</a></p></li>
<li><p><a class="reference internal" href="#a-6-4-2-5-padding-instruction" id="id80">A.6.4.2.5 Padding Instruction</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#a-6-4-3-call-frame-instruction-usage" id="id81">A.6.4.3 Call Frame Instruction Usage</a></p></li>
<li><p><a class="reference internal" href="#a-6-4-4-call-frame-calling-address" id="id82">A.6.4.4 Call Frame Calling Address</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#a-7-data-representation" id="id83">A.7 Data Representation</a></p>
<ul>
<li><p><a class="reference internal" href="#a-7-4-32-bit-and-64-bit-dwarf-formats" id="id84">A.7.4 32-Bit and 64-Bit DWARF Formats</a></p></li>
<li><p><a class="reference internal" href="#a-7-5-format-of-debugging-information" id="id85">A.7.5 Format of Debugging Information</a></p>
<ul>
<li><p><a class="reference internal" href="#a-7-5-4-attribute-encodings" id="id86">A.7.5.4 Attribute Encodings</a></p></li>
<li><p><a class="reference internal" href="#a-7-5-5-classes-and-forms" id="id87">A.7.5.5 Classes and Forms</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#a-7-7-dwarf-expressions" id="id88">A.7.7 DWARF Expressions</a></p>
<ul>
<li><p><a class="reference internal" href="#a-7-7-1-operation-expressions" id="id89">A.7.7.1 Operation Expressions</a></p></li>
<li><p><a class="reference internal" href="#a-7-7-3-location-list-expressions" id="id90">A.7.7.3 Location List Expressions</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#a-7-12-source-languages" id="id91">A.7.12 Source Languages</a></p></li>
<li><p><a class="reference internal" href="#a-7-13-address-class-and-address-space-encodings" id="id92">A.7.13 Address Class and Address Space Encodings</a></p></li>
<li><p><a class="reference internal" href="#a-7-22-line-number-information" id="id93">A.7.22 Line Number Information</a></p></li>
<li><p><a class="reference internal" href="#a-7-24-call-frame-information" id="id94">A.7.24 Call Frame Information</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#a-attributes-by-tag-value-informative" id="id95">A. Attributes by Tag Value (Informative)</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#b-examples" id="id96">B. Examples</a></p></li>
<li><p><a class="reference internal" href="#c-references" id="id97">C. References</a></p></li>
</ul>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This document describes <strong>provisional extensions</strong> to DWARF Version 5
[<a class="reference internal" href="#amdgpu-dwarf-dwarf"><span class="std std-ref">DWARF</span></a>] to support heterogeneous debugging. It is
not currently fully implemented and is subject to change.</p>
</div>
<div class="section" id="introduction">
<span id="amdgpu-dwarf-introduction"></span><h2><a class="toc-backref" href="#id1">1. Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>AMD [<a class="reference internal" href="#amdgpu-dwarf-amd"><span class="std std-ref">AMD</span></a>] has been working on supporting heterogeneous
computing. A heterogeneous computing program can be written in a high level
language such as C++ or Fortran with OpenMP pragmas, OpenCL, or HIP (a portable
C++ programming environment for heterogeneous computing [<a class="reference internal" href="#amdgpu-dwarf-hip"><span class="std std-ref">HIP</span></a>]). A heterogeneous compiler and runtime allows a program to
execute on multiple devices within the same native process. Devices could
include CPUs, GPUs, DSPs, FPGAs, or other special purpose accelerators.
Currently HIP programs execute on systems with CPUs and GPUs.</p>
<p>The AMD [<a class="reference internal" href="#amdgpu-dwarf-amd"><span class="std std-ref">AMD</span></a>] ROCm platform [<a class="reference internal" href="#amdgpu-dwarf-amd-rocm"><span class="std std-ref">AMD-ROCm</span></a>] is an implementation of the industry standard for
heterogeneous computing devices defined by the Heterogeneous System Architecture
(HSA) Foundation [<a class="reference internal" href="#amdgpu-dwarf-hsa"><span class="std std-ref">HSA</span></a>]. It is open sourced and
includes contributions to open source projects such as LLVM [<a class="reference internal" href="#amdgpu-dwarf-llvm"><span class="std std-ref">LLVM</span></a>] for compilation and GDB for debugging [<a class="reference internal" href="#amdgpu-dwarf-gdb"><span class="std std-ref">GDB</span></a>].</p>
<p>The LLVM compiler has upstream support for commercially available AMD GPU
hardware (AMDGPU) [<a class="reference internal" href="#amdgpu-dwarf-amdgpu-llvm"><span class="std std-ref">AMDGPU-LLVM</span></a>]. The open
source ROCgdb [<a class="reference internal" href="#amdgpu-dwarf-amd-rocgdb"><span class="std std-ref">AMD-ROCgdb</span></a>] GDB based debugger
also has support for AMDGPU which is being upstreamed. Support for AMDGPU is
also being added by third parties to the GCC [<a class="reference internal" href="#amdgpu-dwarf-gcc"><span class="std std-ref">GCC</span></a>]
compiler and the Perforce TotalView HPC Debugger [<a class="reference internal" href="#amdgpu-dwarf-perforce-totalview"><span class="std std-ref">Perforce-TotalView</span></a>].</p>
<p>To support debugging heterogeneous programs several features that are not
provided by current DWARF Version 5 [<a class="reference internal" href="#amdgpu-dwarf-dwarf"><span class="std std-ref">DWARF</span></a>] have
been identified. The <a class="reference internal" href="#amdgpu-dwarf-extensions"><span class="std std-ref">1. Extensions</span></a> section gives an overview of
the extensions devised to address the missing features. The extensions seek to
be general in nature and backwards compatible with DWARF Version 5. Their goal
is to be applicable to meeting the needs of any heterogeneous system and not be
vendor or architecture specific. That is followed by appendix
<a class="reference internal" href="#amdgpu-dwarf-changes-relative-to-dwarf-version-5"><span class="std std-ref">A. Changes Relative to DWARF Version 5</span></a> which contains the
textual changes for the extensions relative to the DWARF Version 5 standard.
There are a number of notes included that raise open questions, or provide
alternative approaches that may be worth considering. Then appendix
<a class="reference internal" href="#amdgpu-dwarf-examples"><span class="std std-ref">B. Examples</span></a> links to the AMD GPU specific usage of the
extensions that includes an example. Finally, appendix
<a class="reference internal" href="#amdgpu-dwarf-references"><span class="std std-ref">C. References</span></a> provides references to further information.</p>
</div>
<div class="section" id="extensions">
<span id="amdgpu-dwarf-extensions"></span><h2><a class="toc-backref" href="#id2">1. Extensions</a><a class="headerlink" href="#extensions" title="Permalink to this headline">¶</a></h2>
<p>The extensions continue to evolve through collaboration with many individuals and
active prototyping within the GDB debugger and LLVM compiler. Input has also
been very much appreciated from the developers working on the Perforce TotalView
HPC Debugger and GCC compiler.</p>
<p>The inputs provided and insights gained so far have been incorporated into this
current version. The plan is to participate in upstreaming the work and
addressing any feedback. If there is general interest then some or all of these
extensions could be submitted as future DWARF standard proposals.</p>
<p>The general principles in designing the extensions have been:</p>
<ol class="arabic simple">
<li><p>Be backwards compatible with the DWARF Version 5 [<a class="reference internal" href="#amdgpu-dwarf-dwarf"><span class="std std-ref">DWARF</span></a>] standard.</p></li>
<li><p>Be vendor and architecture neutral. They are intended to apply to other
heterogeneous hardware devices including GPUs, DSPs, FPGAs, and other
specialized hardware. These collectively include similar characteristics and
requirements as AMDGPU devices.</p></li>
<li><p>Provide improved optimization support for non-GPU code. For example, some
extensions apply to traditional CPU hardware that supports large vector
registers. Compilers can map source languages, and source language
extensions, that describe large scale parallel execution, onto the lanes of
the vector registers. This is common in programming languages used in ML and
HPC.</p></li>
<li><p>Fully define well-formed DWARF in a consistent style based on the DWARF
Version 5 specification.</p></li>
</ol>
<p>It is possible that some of the generalizations may also benefit other DWARF
issues that have been raised.</p>
<p>The remainder of this section enumerates the extensions and provides motivation
for each in terms of heterogeneous debugging.</p>
<div class="section" id="allow-location-description-on-the-dwarf-expression-stack">
<span id="amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack"></span><h3><a class="toc-backref" href="#id3">2.1 Allow Location Description on the DWARF Expression Stack</a><a class="headerlink" href="#allow-location-description-on-the-dwarf-expression-stack" title="Permalink to this headline">¶</a></h3>
<p>DWARF Version 5 does not allow location descriptions to be entries on the DWARF
expression stack. They can only be the final result of the evaluation of a DWARF
expression. However, by allowing a location description to be a first-class
entry on the DWARF expression stack it becomes possible to compose expressions
containing both values and location descriptions naturally. It allows objects to
be located in any kind of memory address space, in registers, be implicit
values, be undefined, or a composite of any of these.</p>
<p>By extending DWARF carefully, all existing DWARF expressions can retain their
current semantic meaning. DWARF has implicit conversions that convert from a
value that represents an address in the default address space to a memory
location description. This can be extended to allow a default address space
memory location description to be implicitly converted back to its address
value. This allows all DWARF Version 5 expressions to retain their same meaning,
while enabling the ability to explicitly create memory location descriptions in
non-default address spaces and generalizing the power of composite location
descriptions to any kind of location description.</p>
<p>For those familiar with the definition of location descriptions in DWARF Version
5, the definitions in these extensions are presented differently, but does in
fact define the same concept with the same fundamental semantics. However, it
does so in a way that allows the concept to extend to support address spaces,
bit addressing, the ability for composite location descriptions to be composed
of any kind of location description, and the ability to support objects located
at multiple places. Collectively these changes expand the set of architectures
that can be supported and improves support for optimized code.</p>
<p>Several approaches were considered, and the one presented, together with the
extensions it enables, appears to be the simplest and cleanest one that offers
the greatest improvement of DWARF’s ability to support debugging optimized GPU
and non-GPU code. Examining the GDB debugger and LLVM compiler, it appears only
to require modest changes as they both already have to support general use of
location descriptions. It is anticipated that will also be the case for other
debuggers and compilers.</p>
<p>GDB has been modified to evaluate DWARF Version 5 expressions with location
descriptions as stack entries and with implicit conversions. All GDB tests have
passed, except one that turned out to be an invalid test case by DWARF Version 5
rules. The code in GDB actually became simpler as all evaluation is done on a
single stack and there was no longer a need to maintain a separate structure for
the location description results. This gives confidence in backwards
compatibility.</p>
<p>See <a class="reference internal" href="#amdgpu-dwarf-expressions"><span class="std std-ref">A.2.5 DWARF Expressions</span></a> and nested sections.</p>
<p>This extension is separately described at <em>Allow Location Descriptions on the
DWARF Expression Stack</em> [<a class="reference internal" href="#amdgpu-dwarf-amdgpu-dwarf-loc"><span class="std std-ref">AMDGPU-DWARF-LOC</span></a>].</p>
</div>
<div class="section" id="generalize-cfi-to-allow-any-location-description-kind">
<h3><a class="toc-backref" href="#id4">2.2 Generalize CFI to Allow Any Location Description Kind</a><a class="headerlink" href="#generalize-cfi-to-allow-any-location-description-kind" title="Permalink to this headline">¶</a></h3>
<p>CFI describes restoring callee saved registers that are spilled. Currently CFI
only allows a location description that is a register, memory address, or
implicit location description. AMDGPU optimized code may spill scalar registers
into portions of vector registers. This requires extending CFI to allow any
location description kind to be supported.</p>
<p>See <a class="reference internal" href="#amdgpu-dwarf-call-frame-information"><span class="std std-ref">A.6.4 Call Frame Information</span></a>.</p>
</div>
<div class="section" id="generalize-dwarf-operation-expressions-to-support-multiple-places">
<h3><a class="toc-backref" href="#id5">2.3 Generalize DWARF Operation Expressions to Support Multiple Places</a><a class="headerlink" href="#generalize-dwarf-operation-expressions-to-support-multiple-places" title="Permalink to this headline">¶</a></h3>
<p>In DWARF Version 5 a location description is defined as a single location
description or a location list. A location list is defined as either
effectively an undefined location description or as one or more single
location descriptions to describe an object with multiple places.</p>
<p>With
<a class="reference internal" href="#amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack"><span class="std std-ref">2.1 Allow Location Description on the DWARF Expression Stack</span></a>,
the <code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> operations can put a
location description on the stack. Furthermore, debugger information entry
attributes such as <code class="docutils literal notranslate"><span class="pre">DW_AT_data_member_location</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_AT_use_location</span></code>, and
<code class="docutils literal notranslate"><span class="pre">DW_AT_vtable_elem_location</span></code> are defined as pushing a location description on
the expression stack before evaluating the expression.</p>
<p>DWARF Version 5 only allows the stack to contain values and so only a single
memory address can be on the stack. This makes these operations and attributes
incapable of handling location descriptions with multiple places, or places
other than memory.</p>
<p>Since
<a class="reference internal" href="#amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack"><span class="std std-ref">2.1 Allow Location Description on the DWARF Expression Stack</span></a>
allows the stack to contain location descriptions, the operations are
generalized to support location descriptions that can have multiple places. This
is backwards compatible with DWARF Version 5 and allows objects with multiple
places to be supported. For example, the expression that describes how to access
the field of an object can be evaluated with a location description that has
multiple places and will result in a location description with multiple places.</p>
<p>With this change, the separate DWARF Version 5 sections that described DWARF
expressions and location lists are unified into a single section that describes
DWARF expressions in general. This unification is a natural consequence of, and
a necessity of, allowing location descriptions to be part of the evaluation
stack.</p>
<p>See <a class="reference internal" href="#amdgpu-dwarf-location-description"><span class="std std-ref">A.2.5.3 DWARF Location Description</span></a>.</p>
</div>
<div class="section" id="generalize-offsetting-of-location-descriptions">
<h3><a class="toc-backref" href="#id6">2.4 Generalize Offsetting of Location Descriptions</a><a class="headerlink" href="#generalize-offsetting-of-location-descriptions" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_OP_plus</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_OP_minus</span></code> operations can be defined to operate on a
memory location description in the default target architecture specific address
space and a generic type value to produce an updated memory location
description. This allows them to continue to be used to offset an address.</p>
<p>To generalize offsetting to any location description, including location
descriptions that describe when bytes are in registers, are implicit, or a
composite of these, the <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset_uconst</span></code>, and
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_bit_offset</span></code> offset operations are added.</p>
<p>The offset operations can operate on location storage of any size. For example,
implicit location storage could be any number of bits in size. It is simpler to
define offsets that exceed the size of the location storage as being an
evaluation error, than having to force an implementation to support potentially
infinite precision offsets to allow it to correctly track a series of positive
and negative offsets that may transiently overflow or underflow, but end up in
range. This is simple for the arithmetic operations as they are defined in terms
of two’s compliment arithmetic on a base type of a fixed size. Therefore, the
offset operation define that integer overflow is ill-formed. This is in contrast
to the <code class="docutils literal notranslate"><span class="pre">DW_OP_plus</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_plus_uconst</span></code>, and <code class="docutils literal notranslate"><span class="pre">DW_OP_minus</span></code> arithmetic
operations which define that it causes wrap-around.</p>
<p>Having the offset operations allows <code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code> to push a
location description that may be in a register, or be an implicit value. The
DWARF expression of <code class="docutils literal notranslate"><span class="pre">DW_TAG_ptr_to_member_type</span></code> can use the offset operations
without regard to what kind of location description was pushed.</p>
<p>Since
<a class="reference internal" href="#amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack"><span class="std std-ref">2.1 Allow Location Description on the DWARF Expression Stack</span></a> has
generalized location storage to be bit indexable, <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_bit_offset</span></code>
generalizes DWARF to work with bit fields. This is generally not possible in
DWARF Version 5.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_OP_*piece</span></code> operations only allow literal indices. A way to use a
computed offset of an arbitrary location description (such as a vector register)
is required. The offset operations provide this ability since they can be used
to compute a location description on the stack.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset_uconst</span></code>, and
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_bit_offset</span></code> in
<a class="reference internal" href="#amdgpu-dwarf-general-location-description-operations"><span class="std std-ref">A.2.5.4.4.1 General Location Description Operations</span></a>.</p>
</div>
<div class="section" id="generalize-creation-of-undefined-location-descriptions">
<h3><a class="toc-backref" href="#id7">2.5 Generalize Creation of Undefined Location Descriptions</a><a class="headerlink" href="#generalize-creation-of-undefined-location-descriptions" title="Permalink to this headline">¶</a></h3>
<p>Current DWARF uses an empty expression to indicate an undefined location
description. Since
<a class="reference internal" href="#amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack"><span class="std std-ref">2.1 Allow Location Description on the DWARF Expression Stack</span></a>
allows location descriptions to be created on the stack, it is necessary to have
an explicit way to specify an undefined location description.</p>
<p>For example, the <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_select_bit_piece</span></code> (see
<a class="reference internal" href="#amdgpu-dwarf-support-for-divergent-control-flow-of-simt-hardware"><span class="std std-ref">2.13 Support for Divergent Control Flow of SIMT Hardware</span></a>)
operation takes more than one location description on the stack. Without this
ability, it is not possible to specify that a particular one of the input
location descriptions is undefined.</p>
<p>See the <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_undefined</span></code> operation in
<a class="reference internal" href="#amdgpu-dwarf-undefined-location-description-operations"><span class="std std-ref">A.2.5.4.4.2 Undefined Location Description Operations</span></a>.</p>
</div>
<div class="section" id="generalize-creation-of-composite-location-descriptions">
<h3><a class="toc-backref" href="#id8">2.6 Generalize Creation of Composite Location Descriptions</a><a class="headerlink" href="#generalize-creation-of-composite-location-descriptions" title="Permalink to this headline">¶</a></h3>
<p>To allow composition of composite location descriptions, an explicit operation
that indicates the end of the definition of a composite location description is
required. This can be implied if the end of a DWARF expression is reached,
allowing current DWARF expressions to remain legal.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_piece_end</span></code> in
<a class="reference internal" href="#amdgpu-dwarf-composite-location-description-operations"><span class="std std-ref">A.2.5.4.4.6 Composite Location Description Operations</span></a>.</p>
</div>
<div class="section" id="generalize-dwarf-base-objects-to-allow-any-location-description-kind">
<h3><a class="toc-backref" href="#id9">2.7 Generalize DWARF Base Objects to Allow Any Location Description Kind</a><a class="headerlink" href="#generalize-dwarf-base-objects-to-allow-any-location-description-kind" title="Permalink to this headline">¶</a></h3>
<p>The number of registers and the cost of memory operations is much higher for
AMDGPU than a typical CPU. The compiler attempts to optimize whole variables and
arrays into registers.</p>
<p>Currently DWARF only allows <code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code> and related operations
to work with a global memory location. To support AMDGPU optimized code it is
required to generalize DWARF to allow any location description to be used. This
allows registers, or composite location descriptions that may be a mixture of
memory, registers, or even implicit values.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code> in
<a class="reference internal" href="#amdgpu-dwarf-general-location-description-operations"><span class="std std-ref">A.2.5.4.4.1 General Location Description Operations</span></a>.</p>
</div>
<div class="section" id="general-support-for-address-spaces">
<h3><a class="toc-backref" href="#id10">2.8 General Support for Address Spaces</a><a class="headerlink" href="#general-support-for-address-spaces" title="Permalink to this headline">¶</a></h3>
<p>AMDGPU needs to be able to describe addresses that are in different kinds of
memory. Optimized code may need to describe a variable that resides in pieces
that are in different kinds of storage which may include parts of registers,
memory that is in a mixture of memory kinds, implicit values, or be undefined.</p>
<p>DWARF has the concept of segment addresses. However, the segment cannot be
specified within a DWARF expression, which is only able to specify the offset
portion of a segment address. The segment index is only provided by the entity
that specifies the DWARF expression. Therefore, the segment index is a property
that can only be put on complete objects, such as a variable. That makes it only
suitable for describing an entity (such as variable or subprogram code) that is
in a single kind of memory.</p>
<p>Therefore, AMDGPU uses the DWARF concept of address spaces. For example, a
variable may be allocated in a register that is partially spilled to the call
stack which is in the private address space, and partially spilled to the local
address space.</p>
<p>DWARF uses the concept of an address in many expression operations but does not
define how it relates to address spaces. For example,
<code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code> pushes the address of an object. Other contexts
implicitly push an address on the stack before evaluating an expression. For
example, the <code class="docutils literal notranslate"><span class="pre">DW_AT_use_location</span></code> attribute of the
<code class="docutils literal notranslate"><span class="pre">DW_TAG_ptr_to_member_type</span></code>. The expression belongs to a source language type
which may apply to objects allocated in different kinds of storage. Therefore,
it is desirable that the expression that uses the address can do so without
regard to what kind of storage it specifies, including the address space of a
memory location description. For example, a pointer to member value may want to
be applied to an object that may reside in any address space.</p>
<p>The DWARF <code class="docutils literal notranslate"><span class="pre">DW_OP_xderef*</span></code> operations allow a value to be converted into an
address of a specified address space which is then read. But it provides no
way to create a memory location description for an address in the non-default
address space. For example, AMDGPU variables can be allocated in the local
address space at a fixed address.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code> (see
<a class="reference internal" href="#amdgpu-dwarf-memory-location-description-operations"><span class="std std-ref">A.2.5.4.4.3 Memory Location Description Operations</span></a>) operation is defined
to create a memory location description from an address and address space. If
can be used to specify the location of a variable that is allocated in a
specific address space. This allows the size of addresses in an address space to
be larger than the generic type. It also allows a consumer great implementation
freedom. It allows the implicit conversion back to a value to be limited only to
the default address space to maintain compatibility with DWARF Version 5. For
other address spaces the producer can use the new operations that explicitly
specify the address space.</p>
<p>In contrast, if the <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code> operation had been
defined to produce a value, and an implicit conversion to a memory location
description was defined, then it would be limited to the size of the generic
type (which matches the size of the default address space). An implementation
would likely have to use <em>reserved ranges</em> of value to represent different
address spaces. Such a value would likely not match any address value in the
actual hardware. That would require the consumer to have special treatment for
such values.</p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_breg*</span></code> treats the register as containing an address in the default
address space. A <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_bregx</span></code> (see
<a class="reference internal" href="#amdgpu-dwarf-memory-location-description-operations"><span class="std std-ref">A.2.5.4.4.3 Memory Location Description Operations</span></a>) operation is added
to allow the address space of the address held in a register to be specified.</p>
<p>Similarly, <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> treats its implicit pointer value as being
in the default address space. A <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code>
(<a class="reference internal" href="#amdgpu-dwarf-implicit-location-description-operations"><span class="std std-ref">A.2.5.4.4.5 Implicit Location Description Operations</span></a>) operation is
added to allow the address space to be specified.</p>
<p>Almost all uses of addresses in DWARF are limited to defining location
descriptions, or to be dereferenced to read memory. The exception is
<code class="docutils literal notranslate"><span class="pre">DW_CFA_val_offset</span></code> which uses the address to set the value of a register. In
order to support address spaces, the CFA DWARF expression is defined to be a
memory location description. This allows it to specify an address space which is
used to convert the offset address back to an address in that address space. See
<a class="reference internal" href="#amdgpu-dwarf-call-frame-information"><span class="std std-ref">A.6.4 Call Frame Information</span></a>.</p>
<p>This approach of extending memory location descriptions to support address
spaces, allows all existing DWARF Version 5 expressions to have the identical
semantics. It allows the compiler to explicitly specify the address space it is
using. For example, a compiler could choose to access private memory in a
swizzled manner when mapping a source language thread to the lane of a wavefront
in a SIMT manner. Or a compiler could choose to access it in an unswizzled
manner if mapping the same language with the wavefront being the thread.</p>
<p>It also allows the compiler to mix the address space it uses to access private
memory. For example, for SIMT it can still spill entire vector registers in an
unswizzled manner, while using a swizzled private memory for SIMT variable
access.</p>
<p>This approach also allows memory location descriptions for different address
spaces to be combined using the regular <code class="docutils literal notranslate"><span class="pre">DW_OP_*piece</span></code> operations.</p>
<p>Location descriptions are an abstraction of storage. They give freedom to the
consumer on how to implement them. They allow the address space to encode lane
information so they can be used to read memory with only the memory location
description and no extra information. The same set of operations can operate on
locations independent of their kind of storage. The <code class="docutils literal notranslate"><span class="pre">DW_OP_deref*</span></code> therefore
can be used on any storage kind, including memory location descriptions of
different address spaces. Therefore, the <code class="docutils literal notranslate"><span class="pre">DW_OP_xderef*</span></code> operations are
unnecessary, except to become a more compact way to encode a non-default address
space address followed by dereferencing it. See
<a class="reference internal" href="#amdgpu-dwarf-general-operations"><span class="std std-ref">A.2.5.4.3.4 Special Value Operations</span></a>.</p>
</div>
<div class="section" id="support-for-vector-base-types">
<h3><a class="toc-backref" href="#id11">2.9 Support for Vector Base Types</a><a class="headerlink" href="#support-for-vector-base-types" title="Permalink to this headline">¶</a></h3>
<p>The vector registers of the AMDGPU are represented as their full wavefront
size, meaning the wavefront size times the dword size. This reflects the
actual hardware and allows the compiler to generate DWARF for languages that
map a thread to the complete wavefront. It also allows more efficient DWARF to
be generated to describe the CFI as only a single expression is required for
the whole vector register, rather than a separate expression for each lane’s
dword of the vector register. It also allows the compiler to produce DWARF
that indexes the vector register if it spills scalar registers into portions
of a vector register.</p>
<p>Since DWARF stack value entries have a base type and AMDGPU registers are a
vector of dwords, the ability to specify that a base type is a vector is
required.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_vector_size</span></code> in <a class="reference internal" href="#amdgpu-dwarf-literal-operations"><span class="std std-ref">A.2.5.4.3.1 Literal Operations</span></a>.</p>
</div>
<div class="section" id="dwarf-operations-to-create-vector-composite-location-descriptions">
<span id="amdgpu-dwarf-operation-to-create-vector-composite-location-descriptions"></span><h3><a class="toc-backref" href="#id12">2.10 DWARF Operations to Create Vector Composite Location Descriptions</a><a class="headerlink" href="#dwarf-operations-to-create-vector-composite-location-descriptions" title="Permalink to this headline">¶</a></h3>
<p>AMDGPU optimized code may spill vector registers to non-global address space
memory, and this spilling may be done only for SIMT lanes that are active on
entry to the subprogram.</p>
<p>To support this, a composite location description that can be created as a
masked select is required. In addition, an operation that creates a composite
location description that is a vector on another location description is needed.</p>
<p>An example that uses these operations is referenced in the
<a class="reference internal" href="#amdgpu-dwarf-examples"><span class="std std-ref">B. Examples</span></a> appendix.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_select_bit_piece</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_extend</span></code> in
<a class="reference internal" href="#amdgpu-dwarf-composite-location-description-operations"><span class="std std-ref">A.2.5.4.4.6 Composite Location Description Operations</span></a>.</p>
</div>
<div class="section" id="dwarf-operation-to-access-call-frame-entry-registers">
<h3><a class="toc-backref" href="#id13">2.11 DWARF Operation to Access Call Frame Entry Registers</a><a class="headerlink" href="#dwarf-operation-to-access-call-frame-entry-registers" title="Permalink to this headline">¶</a></h3>
<p>As described in
<a class="reference internal" href="#amdgpu-dwarf-operation-to-create-vector-composite-location-descriptions"><span class="std std-ref">2.10 DWARF Operations to Create Vector Composite Location Descriptions</span></a>,
a DWARF expression involving the set of SIMT lanes active on entry to a
subprogram is required. The SIMT active lane mask may be held in a register that
is modified as the subprogram executes. However, its value may be saved on entry
to the subprogram.</p>
<p>The  Call Frame Information (CFI) already encodes such register saving, so it is
more efficient to provide an operation to return the location of a saved
register than have to generate a loclist to describe the same information. This
is now possible since
<a class="reference internal" href="#amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack"><span class="std std-ref">2.1 Allow Location Description on the DWARF Expression Stack</span></a>
allows location descriptions on the stack.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_call_frame_entry_reg</span></code> in
<a class="reference internal" href="#amdgpu-dwarf-general-location-description-operations"><span class="std std-ref">A.2.5.4.4.1 General Location Description Operations</span></a> and
<a class="reference internal" href="#amdgpu-dwarf-call-frame-information"><span class="std std-ref">A.6.4 Call Frame Information</span></a>.</p>
</div>
<div class="section" id="support-for-source-languages-mapped-to-simt-hardware">
<h3><a class="toc-backref" href="#id14">2.12 Support for Source Languages Mapped to SIMT Hardware</a><a class="headerlink" href="#support-for-source-languages-mapped-to-simt-hardware" title="Permalink to this headline">¶</a></h3>
<p>If the source language is mapped onto the AMDGPU wavefronts in a SIMT manner,
then the variable DWARF location expressions must compute the location for a
single lane of the wavefront. Therefore, a DWARF operation is required to denote
the current lane, much like <code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code> denotes the current
object. See <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_push_lane</span></code> in <a class="reference internal" href="#amdgpu-dwarf-literal-operations"><span class="std std-ref">A.2.5.4.3.1 Literal Operations</span></a>.</p>
<p>In addition, a way is needed for the compiler to communicate how many source
language threads of execution are mapped to a target architecture thread’s SIMT
lanes. See <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lanes</span></code> in <a class="reference internal" href="#amdgpu-dwarf-low-level-information"><span class="std std-ref">A.3.3.5 Low-Level Information</span></a>.</p>
</div>
<div class="section" id="support-for-divergent-control-flow-of-simt-hardware">
<span id="amdgpu-dwarf-support-for-divergent-control-flow-of-simt-hardware"></span><h3><a class="toc-backref" href="#id15">2.13 Support for Divergent Control Flow of SIMT Hardware</a><a class="headerlink" href="#support-for-divergent-control-flow-of-simt-hardware" title="Permalink to this headline">¶</a></h3>
<p>If the source language is mapped onto the AMDGPU wavefronts in a SIMT manner the
compiler can use the AMDGPU execution mask register to control which lanes are
active. To describe the conceptual location of non-active lanes requires an
attribute that has an expression that computes the source location PC for each
lane.</p>
<p>For efficiency, the expression calculates the source location the wavefront as a
whole. This can be done using the <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_select_bit_piece</span></code> (see
<a class="reference internal" href="#amdgpu-dwarf-operation-to-create-vector-composite-location-descriptions"><span class="std std-ref">2.10 DWARF Operations to Create Vector Composite Location Descriptions</span></a>)
operation.</p>
<p>The AMDGPU may update the execution mask to perform whole wavefront operations.
Therefore, there is a need for an attribute that computes the current active
lane mask. This can have an expression that may evaluate to the SIMT active lane
mask register or to a saved mask when in whole wavefront execution mode.</p>
<p>An example that uses these attributes is referenced in the
<a class="reference internal" href="#amdgpu-dwarf-examples"><span class="std std-ref">B. Examples</span></a> appendix.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_active_lane</span></code> in
<a class="reference internal" href="#amdgpu-dwarf-composite-location-description-operations"><span class="std std-ref">A.2.5.4.4.6 Composite Location Description Operations</span></a>.</p>
</div>
<div class="section" id="define-source-language-address-classes">
<h3><a class="toc-backref" href="#id16">2.14 Define Source Language Address Classes</a><a class="headerlink" href="#define-source-language-address-classes" title="Permalink to this headline">¶</a></h3>
<p>AMDGPU supports languages, such as OpenCL [<a class="reference internal" href="#amdgpu-dwarf-opencl"><span class="std std-ref">OpenCL</span></a>],
that define source language address classes. Support is added to define language
specific address classes so they can be used in a consistent way by consumers.</p>
<p>It would also be desirable to add support for using address classes in defining
source language types. DWARF Version 5 only supports using target architecture
specific address spaces.</p>
<p>See <a class="reference internal" href="#amdgpu-dwarf-segment-addresses"><span class="std std-ref">A.2.12 Segmented Addresses</span></a>.</p>
</div>
<div class="section" id="define-augmentation-strings-to-support-multiple-extensions">
<h3><a class="toc-backref" href="#id17">2.15 Define Augmentation Strings to Support Multiple Extensions</a><a class="headerlink" href="#define-augmentation-strings-to-support-multiple-extensions" title="Permalink to this headline">¶</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_augmentation</span></code> attribute is added to a compilation unit debugger
information entry to indicate that there is additional target architecture
specific information in the debugging information entries of that compilation
unit. This allows a consumer to know what extensions are present in the debugger
information entries as is possible with the augmentation string of other
sections. See .</p>
<p>The format that should be used for an augmentation string is also recommended.
This allows a consumer to parse the string when it contains information from
multiple vendors. Augmentation strings occur in the <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_augmentation</span></code>
attribute, in the lookup by name table, and in the CFI Common Information Entry
(CIE).</p>
<p>See <a class="reference internal" href="#amdgpu-dwarf-full-and-partial-compilation-unit-entries"><span class="std std-ref">A.3.1.1 Full and Partial Compilation Unit Entries</span></a>,
<a class="reference internal" href="#amdgpu-dwarf-name-index-section-header"><span class="std std-ref">A.6.1.1.4.1 Section Header</span></a>, and
<a class="reference internal" href="#amdgpu-dwarf-structure-of-call-frame-information"><span class="std std-ref">A.6.4.1 Structure of Call Frame Information</span></a>.</p>
</div>
<div class="section" id="support-embedding-source-text-for-online-compilation">
<h3><a class="toc-backref" href="#id18">2.16 Support Embedding Source Text for Online Compilation</a><a class="headerlink" href="#support-embedding-source-text-for-online-compilation" title="Permalink to this headline">¶</a></h3>
<p>AMDGPU supports programming languages that include online compilation where the
source text may be created at runtime. For example, the OpenCL and HIP language
runtimes support online compilation. To support is, a way to embed the source
text in the debug information is provided.</p>
<p>See <a class="reference internal" href="#amdgpu-dwarf-line-number-information"><span class="std std-ref">A.6.2 Line Number Information</span></a>.</p>
</div>
<div class="section" id="allow-md5-checksums-to-be-optionally-present">
<h3><a class="toc-backref" href="#id19">2.17 Allow MD5 Checksums to be Optionally Present</a><a class="headerlink" href="#allow-md5-checksums-to-be-optionally-present" title="Permalink to this headline">¶</a></h3>
<p>In DWARF Version 5 the file timestamp and file size can be optional, but if the
MD5 checksum is present it must be valid for all files. This is a problem if
using link time optimization to combine compilation units where some have MD5
checksums and some do not. Therefore, sSupport to allow MD5 checksums to be
optionally present in the line table is added.</p>
<p>See <a class="reference internal" href="#amdgpu-dwarf-line-number-information"><span class="std std-ref">A.6.2 Line Number Information</span></a>.</p>
</div>
<div class="section" id="add-the-hip-programing-language">
<h3><a class="toc-backref" href="#id20">2.18 Add the HIP Programing Language</a><a class="headerlink" href="#add-the-hip-programing-language" title="Permalink to this headline">¶</a></h3>
<p>The HIP programming language [<a class="reference internal" href="#amdgpu-dwarf-hip"><span class="std std-ref">HIP</span></a>], which is supported
by the AMDGPU, is added.</p>
<p>See <a class="reference internal" href="#amdgpu-dwarf-language-names-table"><span class="std std-ref">Language Names</span></a>.</p>
</div>
<div class="section" id="support-for-source-language-optimizations-that-result-in-concurrent-iteration-execution">
<h3><a class="toc-backref" href="#id21">2.19 Support for Source Language Optimizations that Result in Concurrent Iteration Execution</a><a class="headerlink" href="#support-for-source-language-optimizations-that-result-in-concurrent-iteration-execution" title="Permalink to this headline">¶</a></h3>
<p>A compiler can perform loop optimizations that result in the generated code
executing multiple iterations concurrently. For example, software pipelining
schedules multiple iterations in an interleaved fashion to allow the
instructions of one iteration to hide the latencies of the instructions of
another iteration. Another example is vectorization that can exploit SIMD
hardware to allow a single instruction to execute multiple iterations using
vector registers.</p>
<p>Note that although this is similar to SIMT execution, the way a client debugger
uses the information is fundamentally different. In SIMT execution the debugger
needs to present the concurrent execution as distinct source language threads
that the user can list and switch focus between. With iteration concurrency
optimizations, such as software pipelining and vectorized SIMD, the debugger
must not present the concurrency as distinct source language threads. Instead,
it must inform the user that multiple loop iterations are executing in parallel
and allow the user to select between them.</p>
<p>In general, SIMT execution fixes the number of concurrent executions per target
architecture thread. However, both software pipelining and SIMD vectorization
may vary the number of concurrent iterations for different loops executed by a
single source language thread.</p>
<p>It is possible for the compiler to use both SIMT concurrency and iteration
concurrency techniques in the code of a single source language thread.</p>
<p>Therefore, a DWARF operation is required to denote the current concurrent
iteration instance, much like <code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code> denotes the current
object. See <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_push_iteration</span></code> in
<a class="reference internal" href="#amdgpu-dwarf-literal-operations"><span class="std std-ref">A.2.5.4.3.1 Literal Operations</span></a>.</p>
<p>In addition, a way is needed for the compiler to communicate how many source
language loop iterations are executing concurrently. See
<code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_iterations</span></code> in <a class="reference internal" href="#amdgpu-dwarf-low-level-information"><span class="std std-ref">A.3.3.5 Low-Level Information</span></a>.</p>
</div>
<div class="section" id="dwarf-operation-to-create-runtime-overlay-composite-location-description">
<h3><a class="toc-backref" href="#id22">2.20 DWARF Operation to Create Runtime Overlay Composite Location Description</a><a class="headerlink" href="#dwarf-operation-to-create-runtime-overlay-composite-location-description" title="Permalink to this headline">¶</a></h3>
<p>It is common in SIMD vectorization for the compiler to generate code that
promotes portions of an array into vector registers. For example, if the
hardware has vector registers with 8 elements, and 8 wide SIMD instructions, the
compiler may vectorize a loop so that is executes 8 iterations concurrently for
each vectorized loop iteration.</p>
<p>On the first iteration of the generated vectorized loop, iterations 0 to 7 of
the source language loop will be executed using SIMD instructions. Then on the
next iteration of the generated vectorized loop, iteration 8 to 15 will be
executed, and so on.</p>
<p>If the source language loop accesses an array element based on the loop
iteration index, the compiler may read the element into a register for the
duration of that iteration. Next iteration it will read the next element into
the register, and so on. With SIMD, this generalizes to the compiler reading
array elements 0 to 7 into a vector register on the first vectorized loop
iteration, then array elements 8 to 15 on the next iteration, and so on.</p>
<p>The DWARF location description for the array needs to express that all elements
are in memory, except the slice that has been promoted to the vector register.
The starting position of the slice is a runtime value based on the iteration
index modulo the vectorization size. This cannot be expressed by <code class="docutils literal notranslate"><span class="pre">DW_OP_piece</span></code>
and <code class="docutils literal notranslate"><span class="pre">DW_OP_bit_piece</span></code> which only allow constant offsets to be expressed.</p>
<p>Therefore, a new operator is defined that takes two location descriptions, an
offset and a size, and creates a composite that effectively uses the second
location description as an overlay of the first, positioned according to the
offset and size. See <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_overlay</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_bit_overlay</span></code> in
<a class="reference internal" href="#amdgpu-dwarf-composite-location-description-operations"><span class="std std-ref">A.2.5.4.4.6 Composite Location Description Operations</span></a>.</p>
</div>
</div>
<div class="section" id="a-changes-relative-to-dwarf-version-5">
<span id="amdgpu-dwarf-changes-relative-to-dwarf-version-5"></span><h2><a class="toc-backref" href="#id23">A. Changes Relative to DWARF Version 5</a><a class="headerlink" href="#a-changes-relative-to-dwarf-version-5" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This appendix provides changes relative to DWARF Version 5. It has been
defined such that it is backwards compatible with DWARF Version 5.
Non-normative text is shown in <em>italics</em>. The section numbers generally
correspond to those in the DWARF Version 5 standard unless specified
otherwise. Definitions are given for the additional operations, as well as
clarifying how existing expression operations, CFI operations, and attributes
behave with respect to generalized location descriptions that support address
spaces and multiple places.</p>
<p>The names for the new operations, attributes, and constants include “<code class="docutils literal notranslate"><span class="pre">LLVM</span></code>” and are encoded with vendor specific codes so these extensions can
be implemented as an LLVM vendor extension to DWARF Version 5.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Notes are included to describe how the changes are to be applied to the
DWARF Version 5 standard. They also describe rational and issues that may
need further consideration.</p>
</div>
</div>
<div class="section" id="a-2-general-description">
<h3><a class="toc-backref" href="#id24">A.2 General Description</a><a class="headerlink" href="#a-2-general-description" title="Permalink to this headline">¶</a></h3>
<div class="section" id="a-2-2-attribute-types">
<h4><a class="toc-backref" href="#id25">A.2.2 Attribute Types</a><a class="headerlink" href="#a-2-2-attribute-types" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This augments DWARF Version 5 section 2.2 and Table 2.2.</p>
</div>
<p>The following table provides the additional attributes.</p>
<table class="docutils align-default" id="amdgpu-dwarf-attribute-names-table">
<caption><span class="caption-text">Attribute names</span><a class="headerlink" href="#amdgpu-dwarf-attribute-names-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Attribute</p></th>
<th class="head"><p>Usage</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_active_lane</span></code></p></td>
<td><p>SIMT active lanes (see <a class="reference internal" href="#amdgpu-dwarf-low-level-information"><span class="std std-ref">A.3.3.5 Low-Level Information</span></a>)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_augmentation</span></code></p></td>
<td><p>Compilation unit augmentation string (see <a class="reference internal" href="#amdgpu-dwarf-full-and-partial-compilation-unit-entries"><span class="std std-ref">A.3.1.1 Full and Partial Compilation Unit Entries</span></a>)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code></p></td>
<td><p>SIMT lane program location (see <a class="reference internal" href="#amdgpu-dwarf-low-level-information"><span class="std std-ref">A.3.3.5 Low-Level Information</span></a>)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lanes</span></code></p></td>
<td><p>SIMT lane count (see <a class="reference internal" href="#amdgpu-dwarf-low-level-information"><span class="std std-ref">A.3.3.5 Low-Level Information</span></a>)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_iterations</span></code></p></td>
<td><p>Concurrent iteration count (see <a class="reference internal" href="#amdgpu-dwarf-low-level-information"><span class="std std-ref">A.3.3.5 Low-Level Information</span></a>)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_vector_size</span></code></p></td>
<td><p>Base type vector size (see <a class="reference internal" href="#amdgpu-dwarf-base-type-entries"><span class="std std-ref">A.5.1 Base Type Entries</span></a>)</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="a-2-5-dwarf-expressions">
<span id="amdgpu-dwarf-expressions"></span><h4><a class="toc-backref" href="#id26">A.2.5 DWARF Expressions</a><a class="headerlink" href="#a-2-5-dwarf-expressions" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section, and its nested sections, replaces DWARF Version 5 section 2.5
and section 2.6. The new DWARF expression operation extensions are defined as
well as clarifying the extensions to already existing DWARF Version 5
operations. It is based on the text of the existing DWARF Version 5 standard.</p>
</div>
<p>DWARF expressions describe how to compute a value or specify a location.</p>
<p><em>The evaluation of a DWARF expression can provide the location of an object, the
value of an array bound, the length of a dynamic string, the desired value
itself, and so on.</em></p>
<p>If the evaluation of a DWARF expression does not encounter an error, then it can
either result in a value (see <a class="reference internal" href="#amdgpu-dwarf-expression-value"><span class="std std-ref">A.2.5.2 DWARF Expression Value</span></a>) or a
location description (see <a class="reference internal" href="#amdgpu-dwarf-location-description"><span class="std std-ref">A.2.5.3 DWARF Location Description</span></a>). When a
DWARF expression is evaluated, it may be specified whether a value or location
description is required as the result kind.</p>
<p>If a result kind is specified, and the result of the evaluation does not match
the specified result kind, then the implicit conversions described in
<a class="reference internal" href="#amdgpu-dwarf-memory-location-description-operations"><span class="std std-ref">A.2.5.4.4.3 Memory Location Description Operations</span></a> are performed if
valid. Otherwise, the DWARF expression is ill-formed.</p>
<p>If the evaluation of a DWARF expression encounters an evaluation error, then the
result is an evaluation error.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Decided to define the concept of an evaluation error. An alternative is to
introduce an undefined value base type in a similar way to location
descriptions having an undefined location description. Then operations that
encounter an evaluation error can return the undefined location description or
value with an undefined base type.</p>
<p>All operations that act on values would return an undefined entity if given an
undefined value. The expression would then always evaluate to completion, and
can be tested to determine if it is an undefined entity.</p>
<p>However, this would add considerable additional complexity and does not match
that GDB throws an exception when these evaluation errors occur.</p>
</div>
<p>If a DWARF expression is ill-formed, then the result is undefined.</p>
<p>The following sections detail the rules for when a DWARF expression is
ill-formed or results in an evaluation error.</p>
<p>A DWARF expression can either be encoded as an operation expression (see
<a class="reference internal" href="#amdgpu-dwarf-operation-expressions"><span class="std std-ref">A.2.5.4 DWARF Operation Expressions</span></a>), or as a location list expression
(see <a class="reference internal" href="#amdgpu-dwarf-location-list-expressions"><span class="std std-ref">A.2.5.5 DWARF Location List Expressions</span></a>).</p>
<div class="section" id="a-2-5-1-dwarf-expression-evaluation-context">
<span id="amdgpu-dwarf-expression-evaluation-context"></span><h5><a class="toc-backref" href="#id27">A.2.5.1 DWARF Expression Evaluation Context</a><a class="headerlink" href="#a-2-5-1-dwarf-expression-evaluation-context" title="Permalink to this headline">¶</a></h5>
<p>A DWARF expression is evaluated in a context that can include a number of
context elements.  If multiple context elements are specified then they must be
self consistent or the result of the evaluation is undefined. The context
elements that can be specified are:</p>
<p><em>A current result kind</em></p>
<blockquote>
<div><p>The kind of result required by the DWARF expression evaluation. If specified
it can be a location description or a value.</p>
</div></blockquote>
<p><em>A current thread</em></p>
<blockquote>
<div><p>The target architecture thread identifier. For source languages that are not
implemented using a SIMT execution model, this corresponds to the source
program thread of execution for which a user presented expression is currently
being evaluated. For source languages that are implemented using a SIMT
execution model, this together with the current lane corresponds to the source
program thread of execution for which a user presented expression is currently
being evaluated.</p>
<p>It is required for operations that are related to target architecture threads.</p>
<p><em>For example, the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_regval_type</span></code> <em>operation, or the</em>
<code class="docutils literal notranslate"><span class="pre">DW_OP_form_tls_address</span></code> <em>and</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code>
<em>operations when given an address space that is target architecture thread
specific.</em></p>
</div></blockquote>
<p><em>A current lane</em></p>
<blockquote>
<div><p>The 0 based SIMT lane identifier to be used in evaluating a user presented
expression. This applies to source languages that are implemented for a target
architecture using a SIMT execution model. These implementations map source
language threads of execution to lanes of the target architecture threads.</p>
<p>It is required for operations that are related to SIMT lanes.</p>
<p><em>For example, the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_push_lane</span></code> <em>operation and</em>
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code> <em>operation when given an address space that
is SIMT lane specific.</em></p>
<p>If specified, it must be consistent with the value of the <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lanes</span></code>
attribute of the subprogram corresponding to context’s frame and program
location. It is consistent if the value is greater than or equal to 0 and less
than the, possibly default, value of the <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lanes</span></code> attribute.
Otherwise the result is undefined.</p>
</div></blockquote>
<p><em>A current iteration</em></p>
<blockquote>
<div><p>The 0 based source language iteration instance to be used in evaluating a user
presented expression. This applies to target architectures that support
optimizations that result in executing multiple source language loop iterations
concurrently.</p>
<p><em>For example, software pipelining and SIMD vectorization.</em></p>
<p>It is required for operations that are related to source language loop
iterations.</p>
<p><em>For example, the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_push_iteration</span></code> <em>operation.</em></p>
<p>If specified, it must be consistent with the value of the
<code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_iterations</span></code> attribute of the subprogram corresponding to
context’s frame and program location. It is consistent if the value is greater
than or equal to 0 and less than the, possibly default, value of the
<code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_iterations</span></code> attribute. Otherwise the result is undefined.</p>
</div></blockquote>
<p><em>A current call frame</em></p>
<blockquote>
<div><p>The target architecture call frame identifier. It identifies a call frame that
corresponds to an active invocation of a subprogram in the current thread. It
is identified by its address on the call stack. The address is referred to as
the Canonical Frame Address (CFA). The call frame information is used to
determine the CFA for the call frames of the current thread’s call stack (see
<a class="reference internal" href="#amdgpu-dwarf-call-frame-information"><span class="std std-ref">A.6.4 Call Frame Information</span></a>).</p>
<p>It is required for operations that specify target architecture registers to
support virtual unwinding of the call stack.</p>
<p><em>For example, the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_*reg*</span></code> <em>operations.</em></p>
<p>If specified, it must be an active call frame in the current thread. If the
current lane is specified, then that lane must have been active on entry to
the call frame (see the <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code> attribute). Otherwise the
result is undefined.</p>
<p>If it is the currently executing call frame, then it is termed the top call
frame.</p>
</div></blockquote>
<p><em>A current program location</em></p>
<blockquote>
<div><p>The target architecture program location corresponding to the current call
frame of the current thread.</p>
<p>The program location of the top call frame is the target architecture program
counter for the current thread. The call frame information is used to obtain
the value of the return address register to determine the program location of
the other call frames (see <a class="reference internal" href="#amdgpu-dwarf-call-frame-information"><span class="std std-ref">A.6.4 Call Frame Information</span></a>).</p>
<p>It is required for the evaluation of location list expressions to select
amongst multiple program location ranges. It is required for operations that
specify target architecture registers to support virtual unwinding of the call
stack (see <a class="reference internal" href="#amdgpu-dwarf-call-frame-information"><span class="std std-ref">A.6.4 Call Frame Information</span></a>).</p>
<p>If specified:</p>
<ul class="simple">
<li><p>If the current lane is not specified:</p>
<ul>
<li><p>If the current call frame is the top call frame, it must be the current
target architecture program location.</p></li>
<li><p>If the current call frame F is not the top call frame, it must be the
program location associated with the call site in the current caller frame
F that invoked the callee frame.</p></li>
</ul>
</li>
<li><p>If the current lane is specified and the architecture program location LPC
computed by the <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code> attribute for the current lane is not
the undefined location description (indicating the lane was not active on
entry to the call frame), it must be LPC.</p></li>
<li><p>Otherwise the result is undefined.</p></li>
</ul>
</div></blockquote>
<p><em>A current compilation unit</em></p>
<blockquote>
<div><p>The compilation unit debug information entry that contains the DWARF expression
being evaluated.</p>
<p>It is required for operations that reference debug information associated with
the same compilation unit, including indicating if such references use the
32-bit or 64-bit DWARF format. It can also provide the default address space
address size if no current target architecture is specified.</p>
<p><em>For example, the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_constx</span></code> <em>and</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_addrx</span></code> <em>operations.</em></p>
<p><em>Note that this compilation unit may not be the same as the compilation unit
determined from the loaded code object corresponding to the current program
location. For example, the evaluation of the expression E associated with a</em>
<code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> <em>attribute of the debug information entry operand of the</em>
<code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> <em>operations is evaluated with the compilation unit that
contains E and not the one that contains the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> <em>operation
expression.</em></p>
</div></blockquote>
<p><em>A current target architecture</em></p>
<blockquote>
<div><p>The target architecture.</p>
<p>It is required for operations that specify target architecture specific
entities.</p>
<p><em>For example, target architecture specific entities include DWARF register
identifiers, DWARF lane identifiers, DWARF address space identifiers, the
default address space, and the address space address sizes.</em></p>
<p>If specified:</p>
<ul class="simple">
<li><p>If the current thread is specified, then the current target architecture
must be the same as the target architecture of the current thread.</p></li>
<li><p>If the current compilation unit is specified, then the current target
architecture default address space address size must be the same as the
<code class="docutils literal notranslate"><span class="pre">address_size</span></code> field in the header of the current compilation unit and any
associated entry in the <code class="docutils literal notranslate"><span class="pre">.debug_aranges</span></code> section.</p></li>
<li><p>If the current program location is specified, then the current target
architecture must be the same as the target architecture of any line number
information entry (see <a class="reference internal" href="#amdgpu-dwarf-line-number-information"><span class="std std-ref">A.6.2 Line Number Information</span></a>)
corresponding to the current program location.</p></li>
<li><p>If the current program location is specified, then the current target
architecture default address space address size must be the same as the
<code class="docutils literal notranslate"><span class="pre">address_size</span></code> field in the header of any entry corresponding to the
current program location in the <code class="docutils literal notranslate"><span class="pre">.debug_addr</span></code>, <code class="docutils literal notranslate"><span class="pre">.debug_line</span></code>,
<code class="docutils literal notranslate"><span class="pre">.debug_rnglists</span></code>, <code class="docutils literal notranslate"><span class="pre">.debug_rnglists.dwo</span></code>, <code class="docutils literal notranslate"><span class="pre">.debug_loclists</span></code>, and
<code class="docutils literal notranslate"><span class="pre">.debug_loclists.dwo</span></code> sections.</p></li>
<li><p>Otherwise the result is undefined.</p></li>
</ul>
</div></blockquote>
<p><em>A current object</em></p>
<blockquote>
<div><p>The location description of a program object.</p>
<p>It is required for the <code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code> operation.</p>
<p><em>For example, the</em> <code class="docutils literal notranslate"><span class="pre">DW_AT_data_location</span></code> <em>attribute on type debug
information entries specifies the program object corresponding to a runtime
descriptor as the current object when it evaluates its associated expression.</em></p>
<p>The result is undefined if the location descriptor is invalid (see
<a class="reference internal" href="#amdgpu-dwarf-location-description"><span class="std std-ref">A.2.5.3 DWARF Location Description</span></a>).</p>
</div></blockquote>
<p><em>An initial stack</em></p>
<blockquote>
<div><p>This is a list of values or location descriptions that will be pushed on the
operation expression evaluation stack in the order provided before evaluation
of an operation expression starts.</p>
<p>Some debugger information entries have attributes that evaluate their DWARF
expression value with initial stack entries. In all other cases the initial
stack is empty.</p>
<p>The result is undefined if any location descriptors are invalid (see
<a class="reference internal" href="#amdgpu-dwarf-location-description"><span class="std std-ref">A.2.5.3 DWARF Location Description</span></a>).</p>
</div></blockquote>
<p>If the evaluation requires a context element that is not specified, then the
result of the evaluation is an error.</p>
<p><em>A DWARF expression for a location description may be able to be evaluated
without a thread, lane, call frame, program location, or architecture context.
For example, the location of a global variable may be able to be evaluated
without such context. If the expression evaluates with an error then it may
indicate the variable has been optimized and so requires more context.</em></p>
<p><em>The DWARF expression for call frame information (see
:ref:`amdgpu-dwarf-call-frame-information`) operations are restricted to those
that do not require the compilation unit context to be specified.</em></p>
<p>The DWARF is ill-formed if all the <code class="docutils literal notranslate"><span class="pre">address_size</span></code> fields in the headers of all
the entries in the <code class="docutils literal notranslate"><span class="pre">.debug_info</span></code>, <code class="docutils literal notranslate"><span class="pre">.debug_addr</span></code>, <code class="docutils literal notranslate"><span class="pre">.debug_line</span></code>,
<code class="docutils literal notranslate"><span class="pre">.debug_rnglists</span></code>, <code class="docutils literal notranslate"><span class="pre">.debug_rnglists.dwo</span></code>, <code class="docutils literal notranslate"><span class="pre">.debug_loclists</span></code>, and
<code class="docutils literal notranslate"><span class="pre">.debug_loclists.dwo</span></code> sections corresponding to any given program location do
not match.</p>
</div>
<div class="section" id="a-2-5-2-dwarf-expression-value">
<span id="amdgpu-dwarf-expression-value"></span><h5><a class="toc-backref" href="#id28">A.2.5.2 DWARF Expression Value</a><a class="headerlink" href="#a-2-5-2-dwarf-expression-value" title="Permalink to this headline">¶</a></h5>
<p>A value has a type and a literal value. It can represent a literal value of any
supported base type of the target architecture. The base type specifies the
size, encoding, and endianity of the literal value.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It may be desirable to add an implicit pointer base type encoding. It would be
used for the type of the value that is produced when the <code class="docutils literal notranslate"><span class="pre">DW_OP_deref*</span></code>
operation retrieves the full contents of an implicit pointer location storage
created by the <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> or
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code> operations. The literal value would
record the debugging information entry and byte displacement specified by the
associated <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> or
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code> operations.</p>
</div>
<p>There is a distinguished base type termed the generic type, which is an integral
type that has the size of an address in the target architecture default address
space, a target architecture defined endianity, and unspecified signedness.</p>
<p><em>The generic type is the same as the unspecified type used for stack operations
defined in DWARF Version 4 and before.</em></p>
<p>An integral type is a base type that has an encoding of <code class="docutils literal notranslate"><span class="pre">DW_ATE_signed</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_ATE_signed_char</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_ATE_unsigned</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_ATE_unsigned_char</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_ATE_boolean</span></code>, or any target architecture defined integral encoding in the
inclusive range <code class="docutils literal notranslate"><span class="pre">DW_ATE_lo_user</span></code> to <code class="docutils literal notranslate"><span class="pre">DW_ATE_hi_user</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is unclear if <code class="docutils literal notranslate"><span class="pre">DW_ATE_address</span></code> is an integral type. GDB does not seem to
consider it as integral.</p>
</div>
</div>
<div class="section" id="a-2-5-3-dwarf-location-description">
<span id="amdgpu-dwarf-location-description"></span><h5><a class="toc-backref" href="#id29">A.2.5.3 DWARF Location Description</a><a class="headerlink" href="#a-2-5-3-dwarf-location-description" title="Permalink to this headline">¶</a></h5>
<p><em>Debugging information must provide consumers a way to find the location of
program variables, determine the bounds of dynamic arrays and strings, and
possibly to find the base address of a subprogram’s call frame or the return
address of a subprogram. Furthermore, to meet the needs of recent computer
architectures and optimization techniques, debugging information must be able to
describe the location of an object whose location changes over the object’s
lifetime, and may reside at multiple locations simultaneously during parts of an
object’s lifetime.</em></p>
<p>Information about the location of program objects is provided by location
descriptions.</p>
<p>Location descriptions can consist of one or more single location descriptions.</p>
<p>A single location description specifies the location storage that holds a
program object and a position within the location storage where the program
object starts. The position within the location storage is expressed as a bit
offset relative to the start of the location storage.</p>
<p>A location storage is a linear stream of bits that can hold values. Each
location storage has a size in bits and can be accessed using a zero-based bit
offset. The ordering of bits within a location storage uses the bit numbering
and direction conventions that are appropriate to the current language on the
target architecture.</p>
<p>There are five kinds of location storage:</p>
<dl class="simple">
<dt><em>memory location storage</em></dt><dd><p>Corresponds to the target architecture memory address spaces.</p>
</dd>
<dt><em>register location storage</em></dt><dd><p>Corresponds to the target architecture registers.</p>
</dd>
<dt><em>implicit location storage</em></dt><dd><p>Corresponds to fixed values that can only be read.</p>
</dd>
<dt><em>undefined location storage</em></dt><dd><p>Indicates no value is available and therefore cannot be read or written.</p>
</dd>
<dt><em>composite location storage</em></dt><dd><p>Allows a mixture of these where some bits come from one location storage and
some from another location storage, or from disjoint parts of the same
location storage.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It may be better to add an implicit pointer location storage kind used by the
<code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code>
operations. It would specify the debugger information entry and byte offset
provided by the operations.</p>
</div>
<p><em>Location descriptions are a language independent representation of addressing
rules.</em></p>
<ul class="simple">
<li><p><em>They can be the result of evaluating a debugger information entry attribute
that specifies an operation expression of arbitrary complexity. In this usage
they can describe the location of an object as long as its lifetime is either
static or the same as the lexical block (see
:ref:`amdgpu-dwarf-lexical-block-entries`) that owns it, and it does not move
during its lifetime.</em></p></li>
<li><p><em>They can be the result of evaluating a debugger information entry attribute
that specifies a location list expression. In this usage they can describe the
location of an object that has a limited lifetime, changes its location during
its lifetime, or has multiple locations over part or all of its lifetime.</em></p></li>
</ul>
<p>If a location description has more than one single location description, the
DWARF expression is ill-formed if the object value held in each single location
description’s position within the associated location storage is not the same
value, except for the parts of the value that are uninitialized.</p>
<p><em>A location description that has more than one single location description can
only be created by a location list expression that has overlapping program
location ranges, or certain expression operations that act on a location
description that has more than one single location description. There are no
operation expression operations that can directly create a location description
with more than one single location description.</em></p>
<p><em>A location description with more than one single location description can be
used to describe objects that reside in more than one piece of storage at the
same time. An object may have more than one location as a result of
optimization. For example, a value that is only read may be promoted from memory
to a register for some region of code, but later code may revert to reading the
value from memory as the register may be used for other purposes. For the code
region where the value is in a register, any change to the object value must be
made in both the register and the memory so both regions of code will read the
updated value.</em></p>
<p><em>A consumer of a location description with more than one single location
description can read the object’s value from any of the single location
descriptions (since they all refer to location storage that has the same value),
but must write any changed value to all the single location descriptions.</em></p>
<p>The evaluation of an expression may require context elements to create a
location description. If such a location description is accessed, the storage it
denotes is that associated with the context element values specified when the
location description was created, which may differ from the context at the time
it is accessed.</p>
<p><em>For example, creating a register location description requires the thread
context: the location storage is for the specified register of that thread.
Creating a memory location description for an address space may required a
thread and a lane context: the location storage is the memory associated with
that thread and lane.</em></p>
<p>If any of the context elements required to create a location description change,
the location description becomes invalid and accessing it is undefined.</p>
<p><em>Examples of context that can invalidate a location description are:</em></p>
<ul class="simple">
<li><p><em>The thread context is required and execution causes the thread to terminate.</em></p></li>
<li><p><em>The call frame context is required and further execution causes the call
frame to return to the calling frame.</em></p></li>
<li><p><em>The program location is required and further execution of the thread occurs.
That could change the location list entry or call frame information entry that
applies.</em></p></li>
<li><p><em>An operation uses call frame information:</em></p>
<ul>
<li><p><em>Any of the frames used in the virtual call frame unwinding return.</em></p></li>
<li><p><em>The top call frame is used, the program location is used to select the call
frame information entry, and further execution of the thread occurs.</em></p></li>
</ul>
</li>
</ul>
<p><em>A DWARF expression can be used to compute a location description for an object.
A subsequent DWARF expression evaluation can be given the object location
description as the object context or initial stack context to compute a
component of the object. The final result is undefined if the object location
description becomes invalid between the two expression evaluations.</em></p>
<p>A change of a thread’s program location may not make a location description
invalid, yet may still render it as no longer meaningful. Accessing such a
location description, or using it as the object context or initial stack context
of an expression evaluation, may produce an undefined result.</p>
<p><em>For example, a location description may specify a register that no longer holds
the intended program object after a program location change. One way to avoid
such problems is to recompute location descriptions associated with threads when
their program locations change.</em></p>
</div>
<div class="section" id="a-2-5-4-dwarf-operation-expressions">
<span id="amdgpu-dwarf-operation-expressions"></span><h5><a class="toc-backref" href="#id30">A.2.5.4 DWARF Operation Expressions</a><a class="headerlink" href="#a-2-5-4-dwarf-operation-expressions" title="Permalink to this headline">¶</a></h5>
<p>An operation expression is comprised of a stream of operations, each consisting
of an opcode followed by zero or more operands. The number of operands is
implied by the opcode.</p>
<p>Operations represent a postfix operation on a simple stack machine. Each stack
entry can hold either a value or a location description. Operations can act on
entries on the stack, including adding entries and removing entries. If the kind
of a stack entry does not match the kind required by the operation and is not
implicitly convertible to the required kind (see
<a class="reference internal" href="#amdgpu-dwarf-memory-location-description-operations"><span class="std std-ref">A.2.5.4.4.3 Memory Location Description Operations</span></a>), then the DWARF
operation expression is ill-formed.</p>
<p>Evaluation of an operation expression starts with an empty stack on which the
entries from the initial stack provided by the context are pushed in the order
provided. Then the operations are evaluated, starting with the first operation
of the stream. Evaluation continues until either an operation has an evaluation
error, or until one past the last operation of the stream is reached.</p>
<p>The result of the evaluation is:</p>
<ul>
<li><p>If an operation has an evaluation error, or an operation evaluates an
expression that has an evaluation error, then the result is an evaluation
error.</p></li>
<li><p>If the current result kind specifies a location description, then:</p>
<ul>
<li><p>If the stack is empty, the result is a location description with one
undefined location description.</p>
<p><em>This rule is for backwards compatibility with DWARF Version 5 which has no
explicit operation to create an undefined location description, and uses an
empty operation expression for this purpose.</em></p>
</li>
<li><p>If the top stack entry is a location description, or can be converted
to one (see <a class="reference internal" href="#amdgpu-dwarf-memory-location-description-operations"><span class="std std-ref">A.2.5.4.4.3 Memory Location Description Operations</span></a>),
then the result is that, possibly converted, location description. Any other
entries on the stack are discarded.</p></li>
<li><p>Otherwise the DWARF expression is ill-formed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Could define this case as returning an implicit location description as
if the <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit</span></code> operation is performed.</p>
</div>
</li>
</ul>
</li>
<li><p>If the current result kind specifies a value, then:</p>
<ul class="simple">
<li><p>If the top stack entry is a value, or can be converted to one (see
<a class="reference internal" href="#amdgpu-dwarf-memory-location-description-operations"><span class="std std-ref">A.2.5.4.4.3 Memory Location Description Operations</span></a>), then the result
is that, possibly converted, value. Any other entries on the stack are
discarded.</p></li>
<li><p>Otherwise the DWARF expression is ill-formed.</p></li>
</ul>
</li>
<li><p>If the current result kind is not specified, then:</p>
<ul>
<li><p>If the stack is empty, the result is a location description with one
undefined location description.</p>
<p><em>This rule is for backwards compatibility with DWARF Version 5 which has no
explicit operation to create an undefined location description, and uses an
empty operation expression for this purpose.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This rule is consistent with the rule above for when a location
description is requested. However, GDB appears to report this as an error
and no GDB tests appear to cause an empty stack for this case.</p>
</div>
</li>
<li><p>Otherwise, the top stack entry is returned. Any other entries on the stack
are discarded.</p></li>
</ul>
</li>
</ul>
<p>An operation expression is encoded as a byte block with some form of prefix that
specifies the byte count. It can be used:</p>
<ul class="simple">
<li><p>as the value of a debugging information entry attribute that is encoded using
class <code class="docutils literal notranslate"><span class="pre">exprloc</span></code> (see <a class="reference internal" href="#amdgpu-dwarf-classes-and-forms"><span class="std std-ref">A.7.5.5 Classes and Forms</span></a>),</p></li>
<li><p>as the operand to certain operation expression operations,</p></li>
<li><p>as the operand to certain call frame information operations (see
<a class="reference internal" href="#amdgpu-dwarf-call-frame-information"><span class="std std-ref">A.6.4 Call Frame Information</span></a>),</p></li>
<li><p>and in location list entries (see
<a class="reference internal" href="#amdgpu-dwarf-location-list-expressions"><span class="std std-ref">A.2.5.5 DWARF Location List Expressions</span></a>).</p></li>
</ul>
<div class="section" id="a-2-5-4-1-stack-operations">
<span id="amdgpu-dwarf-stack-operations"></span><h6><a class="toc-backref" href="#id31">A.2.5.4.1 Stack Operations</a><a class="headerlink" href="#a-2-5-4-1-stack-operations" title="Permalink to this headline">¶</a></h6>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section replaces DWARF Version 5 section 2.5.1.3.</p>
</div>
<p>The following operations manipulate the DWARF stack. Operations that index the
stack assume that the top of the stack (most recently added entry) has index 0.
They allow the stack entries to be either a value or location description.</p>
<p>If any stack entry accessed by a stack operation is an incomplete composite
location description (see
<a class="reference internal" href="#amdgpu-dwarf-composite-location-description-operations"><span class="std std-ref">A.2.5.4.4.6 Composite Location Description Operations</span></a>), then the DWARF
expression is ill-formed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These operations now support stack entries that are values and location
descriptions.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If it is desired to also make them work with incomplete composite location
descriptions, then would need to define that the composite location storage
specified by the incomplete composite location description is also replicated
when a copy is pushed. This ensures that each copy of the incomplete composite
location description can update the composite location storage they specify
independently.</p>
</div>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_dup</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_dup</span></code> duplicates the stack entry at the top of the stack.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_drop</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_drop</span></code> pops the stack entry at the top of the stack and discards it.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_pick</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_pick</span></code> has a single unsigned 1-byte operand that represents an index
I. A copy of the stack entry with index I is pushed onto the stack.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_over</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_over</span></code> pushes a copy of the entry with index 1.</p>
<p><em>This is equivalent to a</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_pick</span> <span class="pre">1</span></code> <em>operation.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_swap</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_swap</span></code> swaps the top two stack entries. The entry at the top of the
stack becomes the second stack entry, and the second stack entry becomes the
top of the stack.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_rot</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_rot</span></code> rotates the first three stack entries. The entry at the top of
the stack becomes the third stack entry, the second entry becomes the top of
the stack, and the third entry becomes the second entry.</p>
</li>
</ol>
</div>
<div class="section" id="a-2-5-4-2-control-flow-operations">
<span id="amdgpu-dwarf-control-flow-operations"></span><h6><a class="toc-backref" href="#id32">A.2.5.4.2 Control Flow Operations</a><a class="headerlink" href="#a-2-5-4-2-control-flow-operations" title="Permalink to this headline">¶</a></h6>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section replaces DWARF Version 5 section 2.5.1.5.</p>
</div>
<p>The following operations provide simple control of the flow of a DWARF operation
expression.</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_nop</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_nop</span></code> is a place holder. It has no effect on the DWARF stack
entries.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_le</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_ge</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_eq</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_lt</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_gt</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_OP_ne</span></code></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The same as in DWARF Version 5 section 2.5.1.5.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_skip</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_skip</span></code> is an unconditional branch. Its single operand is a 2-byte
signed integer constant. The 2-byte constant is the number of bytes of the
DWARF expression to skip forward or backward from the current operation,
beginning after the 2-byte constant.</p>
<p>If the updated position is at one past the end of the last operation, then
the operation expression evaluation is complete.</p>
<p>Otherwise, the DWARF expression is ill-formed if the updated operation
position is not in the range of the first to last operation inclusive, or
not at the start of an operation.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_bra</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_bra</span></code> is a conditional branch. Its single operand is a 2-byte signed
integer constant. This operation pops the top of stack. If the value popped
is not the constant 0, the 2-byte constant operand is the number of bytes of
the DWARF operation expression to skip forward or backward from the current
operation, beginning after the 2-byte constant.</p>
<p>If the updated position is at one past the end of the last operation, then
the operation expression evaluation is complete.</p>
<p>Otherwise, the DWARF expression is ill-formed if the updated operation
position is not in the range of the first to last operation inclusive, or
not at the start of an operation.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_call2,</span> <span class="pre">DW_OP_call4,</span> <span class="pre">DW_OP_call_ref</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_call2</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_call4</span></code>, and <code class="docutils literal notranslate"><span class="pre">DW_OP_call_ref</span></code> perform DWARF
procedure calls during evaluation of a DWARF expression.</p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_call2</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_OP_call4</span></code>, have one operand that is, respectively,
a 2-byte or 4-byte unsigned offset DR that represents the byte offset of a
debugging information entry D relative to the beginning of the current
compilation unit.</p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_call_ref</span></code> has one operand that is a 4-byte unsigned value in the
32-bit DWARF format, or an 8-byte unsigned value in the 64-bit DWARF format,
that represents the byte offset DR of a debugging information entry D
relative to the beginning of the <code class="docutils literal notranslate"><span class="pre">.debug_info</span></code> section that contains the
current compilation unit. D may not be in the current compilation unit.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>DWARF Version 5 states that DR can be an offset in a <code class="docutils literal notranslate"><span class="pre">.debug_info</span></code>
section other than the one that contains the current compilation unit. It
states that relocation of references from one executable or shared object
file to another must be performed by the consumer. But given that DR is
defined as an offset in a <code class="docutils literal notranslate"><span class="pre">.debug_info</span></code> section this seems impossible.
If DR was defined as an implementation defined value, then the consumer
could choose to interpret the value in an implementation defined manner to
reference a debug information in another executable or shared object.</p>
<p>In ELF the <code class="docutils literal notranslate"><span class="pre">.debug_info</span></code> section is in a non-<code class="docutils literal notranslate"><span class="pre">PT_LOAD</span></code> segment so
standard dynamic relocations cannot be used. But even if they were loaded
segments and dynamic relocations were used, DR would need to be the
address of D, not an offset in a <code class="docutils literal notranslate"><span class="pre">.debug_info</span></code> section. That would also
need DR to be the size of a global address. So it would not be possible to
use the 32-bit DWARF format in a 64-bit global address space. In addition,
the consumer would need to determine what executable or shared object the
relocated address was in so it could determine the containing compilation
unit.</p>
<p>GDB only interprets DR as an offset in the <code class="docutils literal notranslate"><span class="pre">.debug_info</span></code> section that
contains the current compilation unit.</p>
<p>This comment also applies to <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> and
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code>.</p>
</div>
<p><em>Operand interpretation of</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_call2</span></code><em>,</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_call4</span></code><em>, and</em>
<code class="docutils literal notranslate"><span class="pre">DW_OP_call_ref</span></code> <em>is exactly like that for</em> <code class="docutils literal notranslate"><span class="pre">DW_FORM_ref2</span></code><em>,
``DW_FORM_ref4``*, and</em> <code class="docutils literal notranslate"><span class="pre">DW_FORM_ref_addr</span></code><em>, respectively.</em></p>
<p>The call operation is evaluated by:</p>
<ul>
<li><p>If D has a <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> attribute that is encoded as a <code class="docutils literal notranslate"><span class="pre">exprloc</span></code>
that specifies an operation expression E, then execution of the current
operation expression continues from the first operation of E. Execution
continues until one past the last operation of E is reached, at which
point execution continues with the operation following the call operation.
The operations of E are evaluated with the same current context, except
current compilation unit is the one that contains D and the stack is the
same as that being used by the call operation. After the call operation
has been evaluated, the stack is therefore as it is left by the evaluation
of the operations of E. Since E is evaluated on the same stack as the call
operation, E can use, and/or remove entries already on the stack, and can
add new entries to the stack.</p>
<p><em>Values on the stack at the time of the call may be used as parameters by
the called expression and values left on the stack by the called expression
may be used as return values by prior agreement between the calling and
called expressions.</em></p>
</li>
<li><p>If D has a <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> attribute that is encoded as a <code class="docutils literal notranslate"><span class="pre">loclist</span></code> or
<code class="docutils literal notranslate"><span class="pre">loclistsptr</span></code>, then the specified location list expression E is
evaluated. The evaluation of E uses the current context, except the result
kind is a location description, the compilation unit is the one that
contains D, and the initial stack is empty. The location description
result is pushed on the stack.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This rule avoids having to define how to execute a matched location list
entry operation expression on the same stack as the call when there are
multiple matches. But it allows the call to obtain the location
description for a variable or formal parameter which may use a location
list expression.</p>
<p>An alternative is to treat the case when D has a <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code>
attribute that is encoded as a <code class="docutils literal notranslate"><span class="pre">loclist</span></code> or <code class="docutils literal notranslate"><span class="pre">loclistsptr</span></code>, and the
specified location list expression E’ matches a single location list
entry with operation expression E, the same as the <code class="docutils literal notranslate"><span class="pre">exprloc</span></code> case and
evaluate on the same stack.</p>
<p>But this is not attractive as if the attribute is for a variable that
happens to end with a non-singleton stack, it will not simply put a
location description on the stack. Presumably the intent of using
<code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> on a variable or formal parameter debugger information
entry is to push just one location description on the stack. That
location description may have more than one single location description.</p>
<p>The previous rule for <code class="docutils literal notranslate"><span class="pre">exprloc</span></code> also has the same problem, as normally
a variable or formal parameter location expression may leave multiple
entries on the stack and only return the top entry.</p>
<p>GDB implements <code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> by always executing E on the same stack.
If the location list has multiple matching entries, it simply picks the
first one and ignores the rest. This seems fundamentally at odds with
the desire to support multiple places for variables.</p>
<p>So, it feels like <code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> should both support pushing a location
description on the stack for a variable or formal parameter, and also
support being able to execute an operation expression on the same stack.
Being able to specify a different operation expression for different
program locations seems a desirable feature to retain.</p>
<p>A solution to that is to have a distinct <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_proc</span></code> attribute
for the <code class="docutils literal notranslate"><span class="pre">DW_TAG_dwarf_procedure</span></code> debugging information entry. Then the
<code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> attribute expression is always executed separately
and pushes a location description (that may have multiple single
location descriptions), and the <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_proc</span></code> attribute expression
is always executed on the same stack and can leave anything on the
stack.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_proc</span></code> attribute could have the new classes
<code class="docutils literal notranslate"><span class="pre">exprproc</span></code>, <code class="docutils literal notranslate"><span class="pre">loclistproc</span></code>, and <code class="docutils literal notranslate"><span class="pre">loclistsptrproc</span></code> to indicate that
the expression is executed on the same stack. <code class="docutils literal notranslate"><span class="pre">exprproc</span></code> is the same
encoding as <code class="docutils literal notranslate"><span class="pre">exprloc</span></code>. <code class="docutils literal notranslate"><span class="pre">loclistproc</span></code> and <code class="docutils literal notranslate"><span class="pre">loclistsptrproc</span></code> are the
same encoding as their non-<code class="docutils literal notranslate"><span class="pre">proc</span></code> counterparts, except the DWARF is
ill-formed if the location list does not match exactly one location list
entry and a default entry is required. These forms indicate explicitly
that the matched single operation expression must be executed on the
same stack. This is better than ad hoc special rules for <code class="docutils literal notranslate"><span class="pre">loclistproc</span></code>
and <code class="docutils literal notranslate"><span class="pre">loclistsptrproc</span></code> which are currently clearly defined to always
return a location description. The producer then explicitly indicates
the intent through the attribute classes.</p>
<p>Such a change would be a breaking change for how GDB implements
<code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code>. However, are the breaking cases actually occurring in
practice? GDB could implement the current approach for DWARF Version 5,
and the new semantics for DWARF Version 6 which has been done for some
other features.</p>
<p>Another option is to limit the execution to be on the same stack only to
the evaluation of an expression E that is the value of a
<code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> attribute of a <code class="docutils literal notranslate"><span class="pre">DW_TAG_dwarf_procedure</span></code> debugging
information entry. The DWARF would be ill-formed if E is a location list
expression that does not match exactly one location list entry. In all
other cases the evaluation of an expression E that is the value of a
<code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> attribute would evaluate E with the current context,
except the result kind is a location description, the compilation unit
is the one that contains D, and the initial stack is empty. The location
description result is pushed on the stack.</p>
</div>
</li>
<li><p>If D has a <code class="docutils literal notranslate"><span class="pre">DW_AT_const_value</span></code> attribute with a value V, then it is as
if a <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_value</span> <span class="pre">V</span></code> operation was executed.</p>
<p><em>This allows a call operation to be used to compute the location
description for any variable or formal parameter regardless of whether the
producer has optimized it to a constant. This is consistent with the</em>
<code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> <em>operation.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Alternatively, could deprecate using <code class="docutils literal notranslate"><span class="pre">DW_AT_const_value</span></code> for
<code class="docutils literal notranslate"><span class="pre">DW_TAG_variable</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_TAG_formal_parameter</span></code> debugger information
entries that are constants and instead use <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> with an
operation expression that results in a location description with one
implicit location description. Then this rule would not be required.</p>
</div>
</li>
<li><p>Otherwise, there is no effect and no changes are made to the stack.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In DWARF Version 5, if D does not have a <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> then
<code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> is defined to have no effect. It is unclear that this is
the right definition as a producer should be able to rely on using
<code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> to get a location description for any non-<code class="docutils literal notranslate"><span class="pre">DW_TAG_dwarf_procedure</span></code> debugging information entries. Also, the
producer should not be creating DWARF with <code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> to a
<code class="docutils literal notranslate"><span class="pre">DW_TAG_dwarf_procedure</span></code> that does not have a <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code>
attribute. So, should this case be defined as an ill-formed DWARF
expression?</p>
</div>
</li>
</ul>
<p><em>The</em> <code class="docutils literal notranslate"><span class="pre">DW_TAG_dwarf_procedure</span></code> <em>debugging information entry can be used to
define DWARF procedures that can be called.</em></p>
</li>
</ol>
</div>
<div class="section" id="a-2-5-4-3-value-operations">
<span id="amdgpu-dwarf-value-operations"></span><h6><a class="toc-backref" href="#id33">A.2.5.4.3 Value Operations</a><a class="headerlink" href="#a-2-5-4-3-value-operations" title="Permalink to this headline">¶</a></h6>
<p>This section describes the operations that push values on the stack.</p>
<p>Each value stack entry has a type and a literal value. It can represent a
literal value of any supported base type of the target architecture. The base
type specifies the size, encoding, and endianity of the literal value.</p>
<p>The base type of value stack entries can be the distinguished generic type.</p>
<div class="section" id="a-2-5-4-3-1-literal-operations">
<span id="amdgpu-dwarf-literal-operations"></span><h7><a class="toc-backref" href="#id34">A.2.5.4.3.1 Literal Operations</a><a class="headerlink" href="#a-2-5-4-3-1-literal-operations" title="Permalink to this headline">¶</a></h7>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section replaces DWARF Version 5 section 2.5.1.1.</p>
</div>
<p>The following operations all push a literal value onto the DWARF stack.</p>
<p>Operations other than <code class="docutils literal notranslate"><span class="pre">DW_OP_const_type</span></code> push a value V with the generic type.
If V is larger than the generic type, then V is truncated to the generic type
size and the low-order bits used.</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_lit0</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_lit1</span></code>, …, <code class="docutils literal notranslate"><span class="pre">DW_OP_lit31</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_lit&lt;N&gt;</span></code> operations encode an unsigned literal value N from 0
through 31, inclusive. They push the value N with the generic type.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_const1u</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_const2u</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_const4u</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_const8u</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_const&lt;N&gt;u</span></code> operations have a single operand that is a 1, 2, 4, or
8-byte unsigned integer constant U, respectively. They push the value U with
the generic type.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_const1s</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_const2s</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_const4s</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_const8s</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_const&lt;N&gt;s</span></code> operations have a single operand that is a 1, 2, 4, or
8-byte signed integer constant S, respectively. They push the value S with
the generic type.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span></code> has a single unsigned LEB128 integer operand N. It pushes
the value N with the generic type.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_consts</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_consts</span></code> has a single signed LEB128 integer operand N. It pushes the
value N with the generic type.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_constx</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_constx</span></code> has a single unsigned LEB128 integer operand that
represents a zero-based index into the <code class="docutils literal notranslate"><span class="pre">.debug_addr</span></code> section relative to
the value of the <code class="docutils literal notranslate"><span class="pre">DW_AT_addr_base</span></code> attribute of the associated compilation
unit. The value N in the <code class="docutils literal notranslate"><span class="pre">.debug_addr</span></code> section has the size of the generic
type. It pushes the value N with the generic type.</p>
<p><em>The</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_constx</span></code> <em>operation is provided for constants that require
link-time relocation but should not be interpreted by the consumer as a
relocatable address (for example, offsets to thread-local storage).</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_const_type</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_const_type</span></code> has three operands. The first is an unsigned LEB128
integer DR that represents the byte offset of a debugging information entry
D relative to the beginning of the current compilation unit, that provides
the type T of the constant value. The second is a 1-byte unsigned integral
constant S. The third is a block of bytes B, with a length equal to S.</p>
<p>TS is the bit size of the type T. The least significant TS bits of B are
interpreted as a value V of the type D. It pushes the value V with the type
D.</p>
<p>The DWARF is ill-formed if D is not a <code class="docutils literal notranslate"><span class="pre">DW_TAG_base_type</span></code> debugging
information entry in the current compilation unit, or if TS divided by 8
(the byte size) and rounded up to a whole number is not equal to S.</p>
<p><em>While the size of the byte block B can be inferred from the type D
definition, it is encoded explicitly into the operation so that the
operation can be parsed easily without reference to the</em> <code class="docutils literal notranslate"><span class="pre">.debug_info</span></code>
<em>section.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_push_lane</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_push_lane</span></code> pushes the current lane as a value with the generic
type.</p>
<p><em>For source languages that are implemented using a SIMT execution model,
this is the zero-based lane number that corresponds to the source language
thread of execution upon which the user is focused.</em></p>
<p>The value must be greater than or equal to 0 and less than the value of the
<code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lanes</span></code> attribute, otherwise the DWARF expression is
ill-formed. See <a class="reference internal" href="#amdgpu-dwarf-low-level-information"><span class="std std-ref">A.3.3.5 Low-Level Information</span></a>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_push_iteration</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_push_iteration</span></code> pushes the current iteration as a value with
the generic type.</p>
<p><em>For source language implementations with optimizations that cause multiple
loop iterations to execute concurrently, this is the zero-based iteration
number that corresponds to the source language concurrent loop iteration
upon which the user is focused.</em></p>
<p>The value must be greater than or equal to 0 and less than the value of the
<code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_iterations</span></code> attribute, otherwise the DWARF expression is
ill-formed. See <a class="reference internal" href="#amdgpu-dwarf-low-level-information"><span class="std std-ref">A.3.3.5 Low-Level Information</span></a>.</p>
</li>
</ol>
</div>
<div class="section" id="a-2-5-4-3-2-arithmetic-and-logical-operations">
<span id="amdgpu-dwarf-arithmetic-logical-operations"></span><h7><a class="toc-backref" href="#id35">A.2.5.4.3.2 Arithmetic and Logical Operations</a><a class="headerlink" href="#a-2-5-4-3-2-arithmetic-and-logical-operations" title="Permalink to this headline">¶</a></h7>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section is the same as DWARF Version 5 section 2.5.1.4.</p>
</div>
</div>
<div class="section" id="a-2-5-4-3-3-type-conversion-operations">
<span id="amdgpu-dwarf-type-conversions-operations"></span><h7><a class="toc-backref" href="#id36">A.2.5.4.3.3 Type Conversion Operations</a><a class="headerlink" href="#a-2-5-4-3-3-type-conversion-operations" title="Permalink to this headline">¶</a></h7>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section is the same as DWARF Version 5 section 2.5.1.6.</p>
</div>
</div>
<div class="section" id="a-2-5-4-3-4-special-value-operations">
<span id="amdgpu-dwarf-general-operations"></span><h7><a class="toc-backref" href="#id37">A.2.5.4.3.4 Special Value Operations</a><a class="headerlink" href="#a-2-5-4-3-4-special-value-operations" title="Permalink to this headline">¶</a></h7>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section replaces parts of DWARF Version 5 sections 2.5.1.2, 2.5.1.3, and
2.5.1.7.</p>
</div>
<p>There are these special value operations currently defined:</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_regval_type</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_regval_type</span></code> has two operands. The first is an unsigned LEB128
integer that represents a register number R. The second is an unsigned
LEB128 integer DR that represents the byte offset of a debugging information
entry D relative to the beginning of the current compilation unit, that
provides the type T of the register value.</p>
<p>The operation is equivalent to performing <code class="docutils literal notranslate"><span class="pre">DW_OP_regx</span> <span class="pre">R;</span> <span class="pre">DW_OP_deref_type</span>
<span class="pre">DR</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Should DWARF allow the type T to be a larger size than the size of the
register R? Restricting a larger bit size avoids any issue of conversion
as the, possibly truncated, bit contents of the register is simply
interpreted as a value of T. If a conversion is wanted it can be done
explicitly using a <code class="docutils literal notranslate"><span class="pre">DW_OP_convert</span></code> operation.</p>
<p>GDB has a per register hook that allows a target specific conversion on a
register by register basis. It defaults to truncation of bigger registers.
Removing use of the target hook does not cause any test failures in common
architectures. If the compiler for a target architecture did want some
form of conversion, including a larger result type, it could always
explicitly used the <code class="docutils literal notranslate"><span class="pre">DW_OP_convert</span></code> operation.</p>
<p>If T is a larger type than the register size, then the default GDB
register hook reads bytes from the next register (or reads out of bounds
for the last register!). Removing use of the target hook does not cause
any test failures in common architectures (except an illegal hand written
assembly test). If a target architecture requires this behavior, these
extensions allow a composite location description to be used to combine
multiple registers.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_deref</span></code></p>
<p>S is the bit size of the generic type divided by 8 (the byte size) and
rounded up to a whole number. DR is the offset of a hypothetical debug
information entry D in the current compilation unit for a base type of the
generic type.</p>
<p>The operation is equivalent to performing <code class="docutils literal notranslate"><span class="pre">DW_OP_deref_type</span> <span class="pre">S,</span> <span class="pre">DR</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_deref_size</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_deref_size</span></code> has a single 1-byte unsigned integral constant that
represents a byte result size S.</p>
<p>TS is the smaller of the generic type bit size and S scaled by 8 (the byte
size). If TS is smaller than the generic type bit size then T is an unsigned
integral type of bit size TS, otherwise T is the generic type. DR is the
offset of a hypothetical debug information entry D in the current
compilation unit for a base type T.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Truncating the value when S is larger than the generic type matches what
GDB does. This allows the generic type size to not be an integral byte
size. It does allow S to be arbitrarily large. Should S be restricted to
the size of the generic type rounded up to a multiple of 8?</p>
</div>
<p>The operation is equivalent to performing <code class="docutils literal notranslate"><span class="pre">DW_OP_deref_type</span> <span class="pre">S,</span> <span class="pre">DR</span></code>, except
if T is not the generic type, the value V pushed is zero-extended to the
generic type bit size and its type changed to the generic type.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_deref_type</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_deref_type</span></code> has two operands. The first is a 1-byte unsigned
integral constant S. The second is an unsigned LEB128 integer DR that
represents the byte offset of a debugging information entry D relative to
the beginning of the current compilation unit, that provides the type T of
the result value.</p>
<p>TS is the bit size of the type T.</p>
<p><em>While the size of the pushed value V can be inferred from the type T, it is
encoded explicitly as the operand S so that the operation can be parsed
easily without reference to the</em> <code class="docutils literal notranslate"><span class="pre">.debug_info</span></code> <em>section.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is unclear why the operand S is needed. Unlike <code class="docutils literal notranslate"><span class="pre">DW_OP_const_type</span></code>,
the size is not needed for parsing. Any evaluation needs to get the base
type T to push with the value to know its encoding and bit size.</p>
</div>
<p>It pops one stack entry that must be a location description L.</p>
<p>A value V of TS bits is retrieved from the location storage LS specified by
one of the single location descriptions SL of L.</p>
<p><em>If L, or the location description of any composite location description
part that is a subcomponent of L, has more than one single location
description, then any one of them can be selected as they are required to
all have the same value. For any single location description SL, bits are
retrieved from the associated storage location starting at the bit offset
specified by SL. For a composite location description, the retrieved bits
are the concatenation of the N bits from each composite location part PL,
where N is limited to the size of PL.</em></p>
<p>V is pushed on the stack with the type T.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This definition makes it an evaluation error if L is a register location
description that has less than TS bits remaining in the register storage.
Particularly since these extensions extend location descriptions to have
a bit offset, it would be odd to define this as performing sign extension
based on the type, or be target architecture dependent, as the number of
remaining bits could be any number. This matches the GDB implementation
for <code class="docutils literal notranslate"><span class="pre">DW_OP_deref_type</span></code>.</p>
<p>These extensions define <code class="docutils literal notranslate"><span class="pre">DW_OP_*breg*</span></code> in terms of
<code class="docutils literal notranslate"><span class="pre">DW_OP_regval_type</span></code>. <code class="docutils literal notranslate"><span class="pre">DW_OP_regval_type</span></code> is defined in terms of
<code class="docutils literal notranslate"><span class="pre">DW_OP_regx</span></code>, which uses a 0 bit offset, and <code class="docutils literal notranslate"><span class="pre">DW_OP_deref_type</span></code>.
Therefore, it requires the register size to be greater or equal to the
address size of the address space. This matches the GDB implementation for
<code class="docutils literal notranslate"><span class="pre">DW_OP_*breg*</span></code>.</p>
</div>
<p>The DWARF is ill-formed if D is not in the current compilation unit, D is
not a <code class="docutils literal notranslate"><span class="pre">DW_TAG_base_type</span></code> debugging information entry, or if TS divided by
8 (the byte size) and rounded up to a whole number is not equal to S.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This definition allows the base type to be a bit size since there seems no
reason to restrict it.</p>
</div>
<p>It is an evaluation error if any bit of the value is retrieved from the
undefined location storage or the offset of any bit exceeds the size of the
location storage LS specified by any single location description SL of L.</p>
<p>See <a class="reference internal" href="#amdgpu-dwarf-implicit-location-description-operations"><span class="std std-ref">A.2.5.4.4.5 Implicit Location Description Operations</span></a> for special
rules concerning implicit location descriptions created by the
<code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_implicit_aspace_pointer</span></code>
operations.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_xderef</span></code> <em>Deprecated</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_xderef</span></code> pops two stack entries. The first must be an integral type
value that represents an address A. The second must be an integral type
value that represents a target architecture specific address space
identifier AS.</p>
<p>The operation is equivalent to performing <code class="docutils literal notranslate"><span class="pre">DW_OP_swap;</span>
<span class="pre">DW_OP_LLVM_form_aspace_address;</span> <span class="pre">DW_OP_deref</span></code>. The value V retrieved is left
on the stack with the generic type.</p>
<p><em>This operation is deprecated as the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code>
<em>operation can be used and provides greater expressiveness.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_xderef_size</span></code> <em>Deprecated</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_xderef_size</span></code> has a single 1-byte unsigned integral constant that
represents a byte result size S.</p>
<p>It pops two stack entries. The first must be an integral type value that
represents an address A. The second must be an integral type value that
represents a target architecture specific address space identifier AS.</p>
<p>The operation is equivalent to performing <code class="docutils literal notranslate"><span class="pre">DW_OP_swap;</span>
<span class="pre">DW_OP_LLVM_form_aspace_address;</span> <span class="pre">DW_OP_deref_size</span> <span class="pre">S</span></code>. The zero-extended
value V retrieved is left on the stack with the generic type.</p>
<p><em>This operation is deprecated as the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code>
<em>operation can be used and provides greater expressiveness.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_xderef_type</span></code> <em>Deprecated</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_xderef_type</span></code> has two operands. The first is a 1-byte unsigned
integral constant S. The second operand is an unsigned LEB128 integer DR
that represents the byte offset of a debugging information entry D relative
to the beginning of the current compilation unit, that provides the type T
of the result value.</p>
<p>It pops two stack entries. The first must be an integral type value that
represents an address A. The second must be an integral type value that
represents a target architecture specific address space identifier AS.</p>
<p>The operation is equivalent to performing <code class="docutils literal notranslate"><span class="pre">DW_OP_swap;</span>
<span class="pre">DW_OP_LLVM_form_aspace_address;</span> <span class="pre">DW_OP_deref_type</span> <span class="pre">S</span> <span class="pre">DR</span></code>. The value V
retrieved is left on the stack with the type T.</p>
<p><em>This operation is deprecated as the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code>
<em>operation can be used and provides greater expressiveness.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_entry_value</span></code> <em>Deprecated</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_entry_value</span></code> pushes the value of an expression that is evaluated in
the context of the calling frame.</p>
<p><em>It may be used to determine the value of arguments on entry to the current
call frame provided they are not clobbered.</em></p>
<p>It has two operands. The first is an unsigned LEB128 integer S. The second
is a block of bytes, with a length equal S, interpreted as a DWARF
operation expression E.</p>
<p>E is evaluated with the current context, except the result kind is
unspecified, the call frame is the one that called the current frame, the
program location is the call site in the calling frame, the object is
unspecified, and the initial stack is empty. The calling frame information
is obtained by virtually unwinding the current call frame using the call
frame information (see <a class="reference internal" href="#amdgpu-dwarf-call-frame-information"><span class="std std-ref">A.6.4 Call Frame Information</span></a>).</p>
<p>If the result of E is a location description L (see
<a class="reference internal" href="#amdgpu-dwarf-register-location-description-operations"><span class="std std-ref">A.2.5.4.4.4 Register Location Description Operations</span></a>), and the last
operation executed by E is a <code class="docutils literal notranslate"><span class="pre">DW_OP_reg*</span></code> for register R with a target
architecture specific base type of T, then the contents of the register are
retrieved as if a <code class="docutils literal notranslate"><span class="pre">DW_OP_deref_type</span> <span class="pre">DR</span></code> operation was performed where DR
is the offset of a hypothetical debug information entry in the current
compilation unit for T. The resulting value V s pushed on the stack.</p>
<p><em>Using</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_reg*</span></code> <em>provides a more compact form for the case where the
value was in a register on entry to the subprogram.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is unclear how this provides a more compact expression, as
<code class="docutils literal notranslate"><span class="pre">DW_OP_regval_type</span></code> could be used which is marginally larger.</p>
</div>
<p>If the result of E is a value V, then V is pushed on the stack.</p>
<p>Otherwise, the DWARF expression is ill-formed.</p>
<p><em>The</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_entry_value</span></code> <em>operation is deprecated as its main usage is
provided by other means. DWARF Version 5 added the</em>
<code class="docutils literal notranslate"><span class="pre">DW_TAG_call_site_parameter</span></code> <em>debugger information entry for call sites
that has</em> <code class="docutils literal notranslate"><span class="pre">DW_AT_call_value</span></code><em>,</em> <code class="docutils literal notranslate"><span class="pre">DW_AT_call_data_location</span></code><em>, and</em>
<code class="docutils literal notranslate"><span class="pre">DW_AT_call_data_value</span></code> <em>attributes that provide DWARF expressions to
compute actual parameter values at the time of the call, and requires the
producer to ensure the expressions are valid to evaluate even when virtually
unwound. The</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_call_frame_entry_reg</span></code> <em>operation provides access
to registers in the virtually unwound calling frame.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>GDB only implements <code class="docutils literal notranslate"><span class="pre">DW_OP_entry_value</span></code> when E is exactly
<code class="docutils literal notranslate"><span class="pre">DW_OP_reg*</span></code> or <code class="docutils literal notranslate"><span class="pre">DW_OP_breg*;</span> <span class="pre">DW_OP_deref*</span></code>.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="section" id="a-2-5-4-4-location-description-operations">
<span id="amdgpu-dwarf-location-description-operations"></span><h6><a class="toc-backref" href="#id38">A.2.5.4.4 Location Description Operations</a><a class="headerlink" href="#a-2-5-4-4-location-description-operations" title="Permalink to this headline">¶</a></h6>
<p>This section describes the operations that push location descriptions on the
stack.</p>
<div class="section" id="a-2-5-4-4-1-general-location-description-operations">
<span id="amdgpu-dwarf-general-location-description-operations"></span><h7><a class="toc-backref" href="#id39">A.2.5.4.4.1 General Location Description Operations</a><a class="headerlink" href="#a-2-5-4-4-1-general-location-description-operations" title="Permalink to this headline">¶</a></h7>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section replaces part of DWARF Version 5 section 2.5.1.3.</p>
</div>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset</span></code> pops two stack entries. The first must be an integral
type value that represents a byte displacement B. The second must be a
location description L.</p>
<p>It adds the value of B scaled by 8 (the byte size) to the bit offset of each
single location description SL of L, and pushes the updated L.</p>
<p>It is an evaluation error if the updated bit offset of any SL is less than 0
or greater than or equal to the size of the location storage specified by
SL.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset_uconst</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset_uconst</span></code> has a single unsigned LEB128 integer operand
that represents a byte displacement B.</p>
<p>The operation is equivalent to performing <code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span> <span class="pre">B;</span>
<span class="pre">DW_OP_LLVM_offset</span></code>.</p>
<p><em>This operation is supplied specifically to be able to encode more field
displacements in two bytes than can be done with</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_lit*;</span>
<span class="pre">DW_OP_LLVM_offset</span></code><em>.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Should this be named <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset_uconst</span></code> to match
<code class="docutils literal notranslate"><span class="pre">DW_OP_plus_uconst</span></code>, or <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset_constu</span></code> to match
<code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span></code>?</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_bit_offset</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_bit_offset</span></code> pops two stack entries. The first must be an
integral type value that represents a bit displacement B. The second must be
a location description L.</p>
<p>It adds the value of B to the bit offset of each single location description
SL of L, and pushes the updated L.</p>
<p>It is an evaluation error if the updated bit offset of any SL is less than 0
or greater than or equal to the size of the location storage specified by
SL.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code> pushes the location description L of the
current object.</p>
<p><em>This object may correspond to an independent variable that is part of a
user presented expression that is being evaluated. The object location
description may be determined from the variable’s own debugging information
entry or it may be a component of an array, structure, or class whose
address has been dynamically determined by an earlier step during user
expression evaluation.</em></p>
<p><em>This operation provides explicit functionality (especially for arrays
involving descriptors) that is analogous to the implicit push of the base
location description of a structure prior to evaluation of a</em>
<code class="docutils literal notranslate"><span class="pre">DW_AT_data_member_location</span></code> <em>to access a data member of a structure.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This operation could be removed and the object location description
specified as the initial stack as for <code class="docutils literal notranslate"><span class="pre">DW_AT_data_member_location</span></code>.</p>
<p>Or this operation could be used instead of needing to specify an initial
stack. The latter approach is more composable as access to the object may
be needed at any point of the expression, and passing it as the initial
stack requires the entire expression to be aware where on the stack it is.
If this were done, <code class="docutils literal notranslate"><span class="pre">DW_AT_use_location</span></code> would require a
<code class="docutils literal notranslate"><span class="pre">DW_OP_push_object2_address</span></code> operation for the second object.</p>
<p>Or a more general way to pass an arbitrary number of arguments in and an
operation to get the Nth one such as <code class="docutils literal notranslate"><span class="pre">DW_OP_arg</span> <span class="pre">N</span></code>. A vector of
arguments would then be passed in the expression context rather than an
initial stack. This could also resolve the issues with <code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> by
allowing a specific number of arguments passed in and returned to be
specified. The <code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> operation could then always execute on a
separate stack: the number of arguments would be specified in a new call
operation and taken from the callers stack, and similarly the number of
return results specified and copied from the called stack back to the
callee stack when the called expression was complete.</p>
<p>The only attribute that specifies a current object is
<code class="docutils literal notranslate"><span class="pre">DW_AT_data_location</span></code> so the non-normative text seems to overstate how
this is being used. Or are there other attributes that need to state they
pass an object?</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_call_frame_entry_reg</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_call_frame_entry_reg</span></code> has a single unsigned LEB128 integer
operand that represents a target architecture register number R.</p>
<p>It pushes a location description L that holds the value of register R on
entry to the current subprogram as defined by the call frame information
(see <a class="reference internal" href="#amdgpu-dwarf-call-frame-information"><span class="std std-ref">A.6.4 Call Frame Information</span></a>).</p>
<p><em>If there is no call frame information defined, then the default rules for
the target architecture are used. If the register rule is</em> undefined<em>, then
the undefined location description is pushed. If the register rule is</em> same
value<em>, then a register location description for R is pushed.</em></p>
</li>
</ol>
</div>
<div class="section" id="a-2-5-4-4-2-undefined-location-description-operations">
<span id="amdgpu-dwarf-undefined-location-description-operations"></span><h7><a class="toc-backref" href="#id40">A.2.5.4.4.2 Undefined Location Description Operations</a><a class="headerlink" href="#a-2-5-4-4-2-undefined-location-description-operations" title="Permalink to this headline">¶</a></h7>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section replaces DWARF Version 5 section 2.6.1.1.1.</p>
</div>
<p><em>The undefined location storage represents a piece or all of an object that is
present in the source but not in the object code (perhaps due to optimization).
Neither reading nor writing to the undefined location storage is meaningful.</em></p>
<p>An undefined location description specifies the undefined location storage.
There is no concept of the size of the undefined location storage, nor of a bit
offset for an undefined location description. The <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_*offset</span></code>
operations leave an undefined location description unchanged. The
<code class="docutils literal notranslate"><span class="pre">DW_OP_*piece</span></code> operations can explicitly or implicitly specify an undefined
location description, allowing any size and offset to be specified, and results
in a part with all undefined bits.</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_undefined</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_undefined</span></code> pushes a location description L that comprises one
undefined location description SL.</p>
</li>
</ol>
</div>
<div class="section" id="a-2-5-4-4-3-memory-location-description-operations">
<span id="amdgpu-dwarf-memory-location-description-operations"></span><h7><a class="toc-backref" href="#id41">A.2.5.4.4.3 Memory Location Description Operations</a><a class="headerlink" href="#a-2-5-4-4-3-memory-location-description-operations" title="Permalink to this headline">¶</a></h7>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section replaces parts of DWARF Version 5 section 2.5.1.1, 2.5.1.2,
2.5.1.3, and 2.6.1.1.2.</p>
</div>
<p>Each of the target architecture specific address spaces has a corresponding
memory location storage that denotes the linear addressable memory of that
address space. The size of each memory location storage corresponds to the range
of the addresses in the corresponding address space.</p>
<p><em>It is target architecture defined how address space location storage maps to
target architecture physical memory. For example, they may be independent
memory, or more than one location storage may alias the same physical memory
possibly at different offsets and with different interleaving. The mapping may
also be dictated by the source language address classes.</em></p>
<p>A memory location description specifies a memory location storage. The bit
offset corresponds to a bit position within a byte of the memory. Bits accessed
using a memory location description, access the corresponding target
architecture memory starting at the bit position within the byte specified by
the bit offset.</p>
<p>A memory location description that has a bit offset that is a multiple of 8 (the
byte size) is defined to be a byte address memory location description. It has a
memory byte address A that is equal to the bit offset divided by 8.</p>
<p>A memory location description that does not have a bit offset that is a multiple
of 8 (the byte size) is defined to be a bit field memory location description.
It has a bit position B equal to the bit offset modulo 8, and a memory byte
address A equal to the bit offset minus B that is then divided by 8.</p>
<p>The address space AS of a memory location description is defined to be the
address space that corresponds to the memory location storage associated with
the memory location description.</p>
<p>A location description that is comprised of one byte address memory location
description SL is defined to be a memory byte address location description. It
has a byte address equal to A and an address space equal to AS of the
corresponding SL.</p>
<p><code class="docutils literal notranslate"><span class="pre">DW_ASPACE_none</span></code> is defined as the target architecture default address space.</p>
<p>If a stack entry is required to be a location description, but it is a value V
with the generic type, then it is implicitly converted to a location description
L with one memory location description SL. SL specifies the memory location
storage that corresponds to the target architecture default address space with a
bit offset equal to V scaled by 8 (the byte size).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If it is wanted to allow any integral type value to be implicitly converted to
a memory location description in the target architecture default address
space:</p>
<blockquote>
<div><p>If a stack entry is required to be a location description, but is a value V
with an integral type, then it is implicitly converted to a location
description L with a one memory location description SL. If the type size of
V is less than the generic type size, then the value V is zero extended to
the size of the generic type. The least significant generic type size bits
are treated as an unsigned value to be used as an address A. SL specifies
memory location storage corresponding to the target architecture default
address space with a bit offset equal to A scaled by 8 (the byte size).</p>
</div></blockquote>
<p>The implicit conversion could also be defined as target architecture specific.
For example, GDB checks if V is an integral type. If it is not it gives an
error. Otherwise, GDB zero-extends V to 64 bits. If the GDB target defines a
hook function, then it is called. The target specific hook function can modify
the 64-bit value, possibly sign extending based on the original value type.
Finally, GDB treats the 64-bit value V as a memory location address.</p>
</div>
<p>If a stack entry is required to be a location description, but it is an implicit
pointer value IPV with the target architecture default address space, then it is
implicitly converted to a location description with one single location
description specified by IPV. See
<a class="reference internal" href="#amdgpu-dwarf-implicit-location-description-operations"><span class="std std-ref">A.2.5.4.4.5 Implicit Location Description Operations</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Is this rule required for DWARF Version 5 backwards compatibility? If not, it
can be eliminated, and the producer can use
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code>.</p>
</div>
<p>If a stack entry is required to be a value, but it is a location description L
with one memory location description SL in the target architecture default
address space with a bit offset B that is a multiple of 8, then it is implicitly
converted to a value equal to B divided by 8 (the byte size) with the generic
type.</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_addr</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_addr</span></code> has a single byte constant value operand, which has the size
of the generic type, that represents an address A.</p>
<p>It pushes a location description L with one memory location description SL
on the stack. SL specifies the memory location storage corresponding to the
target architecture default address space with a bit offset equal to A
scaled by 8 (the byte size).</p>
<p><em>If the DWARF is part of a code object, then A may need to be relocated. For
example, in the ELF code object format, A must be adjusted by the difference
between the ELF segment virtual address and the virtual address at which the
segment is loaded.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_addrx</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_addrx</span></code> has a single unsigned LEB128 integer operand that represents
a zero-based index into the <code class="docutils literal notranslate"><span class="pre">.debug_addr</span></code> section relative to the value of
the <code class="docutils literal notranslate"><span class="pre">DW_AT_addr_base</span></code> attribute of the associated compilation unit. The
address value A in the <code class="docutils literal notranslate"><span class="pre">.debug_addr</span></code> section has the size of the generic
type.</p>
<p>It pushes a location description L with one memory location description SL
on the stack. SL specifies the memory location storage corresponding to the
target architecture default address space with a bit offset equal to A
scaled by 8 (the byte size).</p>
<p><em>If the DWARF is part of a code object, then A may need to be relocated. For
example, in the ELF code object format, A must be adjusted by the difference
between the ELF segment virtual address and the virtual address at which the
segment is loaded.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code> pops top two stack entries. The first
must be an integral type value that represents a target architecture
specific address space identifier AS. The second must be an integral type
value that represents an address A.</p>
<p>The address size S is defined as the address bit size of the target
architecture specific address space that corresponds to AS.</p>
<p>A is adjusted to S bits by zero extending if necessary, and then treating
the least significant S bits as an unsigned value A’.</p>
<p>It pushes a location description L with one memory location description SL
on the stack. SL specifies the memory location storage LS that corresponds
to AS with a bit offset equal to A’ scaled by 8 (the byte size).</p>
<p>If AS is an address space that is specific to context elements, then LS
corresponds to the location storage associated with the current context.</p>
<p><em>For example, if AS is for per thread storage then LS is the location
storage for the current thread. For languages that are implemented using a
SIMT execution model, then if AS is for per lane storage then LS is the
location storage for the current lane of the current thread. Therefore, if L
is accessed by an operation, the location storage selected when the location
description was created is accessed, and not the location storage associated
with the current context of the access operation.</em></p>
<p>The DWARF expression is ill-formed if AS is not one of the values defined by
the target architecture specific <code class="docutils literal notranslate"><span class="pre">DW_ASPACE_*</span></code> values.</p>
<p>See <a class="reference internal" href="#amdgpu-dwarf-implicit-location-description-operations"><span class="std std-ref">A.2.5.4.4.5 Implicit Location Description Operations</span></a> for special
rules concerning implicit pointer values produced by dereferencing implicit
location descriptions created by the <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> and
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_implicit_aspace_pointer</span></code> operations.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_form_tls_address</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_form_tls_address</span></code> pops one stack entry that must be an integral
type value and treats it as a thread-local storage address TA.</p>
<p>It pushes a location description L with one memory location description SL
on the stack. SL is the target architecture specific memory location
description that corresponds to the thread-local storage address TA.</p>
<p>The meaning of the thread-local storage address TA is defined by the
run-time environment. If the run-time environment supports multiple
thread-local storage blocks for a single thread, then the block
corresponding to the executable or shared library containing this DWARF
expression is used.</p>
<p><em>Some implementations of C, C++, Fortran, and other languages support a
thread-local storage class. Variables with this storage class have distinct
values and addresses in distinct threads, much as automatic variables have
distinct values and addresses in each subprogram invocation. Typically,
there is a single block of storage containing all thread-local variables
declared in the main executable, and a separate block for the variables
declared in each shared library. Each thread-local variable can then be
accessed in its block using an identifier. This identifier is typically a
byte offset into the block and pushed onto the DWARF stack by one of the</em>
<code class="docutils literal notranslate"><span class="pre">DW_OP_const*</span></code> <em>operations prior to the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_form_tls_address</span></code>
<em>operation. Computing the address of the appropriate block can be complex
(in some cases, the compiler emits a function call to do it), and difficult
to describe using ordinary DWARF location descriptions. Instead of forcing
complex thread-local storage calculations into the DWARF expressions, the</em>
<code class="docutils literal notranslate"><span class="pre">DW_OP_form_tls_address</span></code> <em>allows the consumer to perform the computation
based on the target architecture specific run-time environment.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_call_frame_cfa</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_call_frame_cfa</span></code> pushes the location description L of the Canonical
Frame Address (CFA) of the current subprogram, obtained from the call frame
information on the stack. See <a class="reference internal" href="#amdgpu-dwarf-call-frame-information"><span class="std std-ref">A.6.4 Call Frame Information</span></a>.</p>
<p><em>Although the value of the</em> <code class="docutils literal notranslate"><span class="pre">DW_AT_frame_base</span></code> <em>attribute of the debugger
information entry corresponding to the current subprogram can be computed
using a location list expression, in some cases this would require an
extensive location list because the values of the registers used in
computing the CFA change during a subprogram execution. If the call frame
information is present, then it already encodes such changes, and it is
space efficient to reference that using the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_call_frame_cfa</span></code>
<em>operation.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_fbreg</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_fbreg</span></code> has a single signed LEB128 integer operand that represents a
byte displacement B.</p>
<p>The location description L for the <em>frame base</em> of the current subprogram is
obtained from the <code class="docutils literal notranslate"><span class="pre">DW_AT_frame_base</span></code> attribute of the debugger information
entry corresponding to the current subprogram as described in
<a class="reference internal" href="#amdgpu-dwarf-low-level-information"><span class="std std-ref">A.3.3.5 Low-Level Information</span></a>.</p>
<p>The location description L is updated as if the <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset_uconst</span>
<span class="pre">B</span></code> operation was applied. The updated L is pushed on the stack.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_breg0</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_breg1</span></code>, …, <code class="docutils literal notranslate"><span class="pre">DW_OP_breg31</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_OP_breg&lt;N&gt;</span></code> operations encode the numbers of up to 32 registers,
numbered from 0 through 31, inclusive. The register number R corresponds to
the N in the operation name.</p>
<p>They have a single signed LEB128 integer operand that represents a byte
displacement B.</p>
<p>The address space identifier AS is defined as the one corresponding to the
target architecture specific default address space.</p>
<p>The address size S is defined as the address bit size of the target
architecture specific address space corresponding to AS.</p>
<p>The contents of the register specified by R are retrieved as if a
<code class="docutils literal notranslate"><span class="pre">DW_OP_regval_type</span> <span class="pre">R,</span> <span class="pre">DR</span></code> operation was performed where DR is the offset
of a hypothetical debug information entry in the current compilation unit
for an unsigned integral base type of size S bits. B is added and the least
significant S bits are treated as an unsigned value to be used as an address
A.</p>
<p>They push a location description L comprising one memory location
description LS on the stack. LS specifies the memory location storage that
corresponds to AS with a bit offset equal to A scaled by 8 (the byte size).</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_bregx</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_bregx</span></code> has two operands. The first is an unsigned LEB128 integer
that represents a register number R. The second is a signed LEB128
integer that represents a byte displacement B.</p>
<p>The action is the same as for <code class="docutils literal notranslate"><span class="pre">DW_OP_breg&lt;N&gt;</span></code>, except that R is used as
the register number and B is used as the byte displacement.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_bregx</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_bregx</span></code> has two operands. The first is an unsigned
LEB128 integer that represents a register number R. The second is a signed
LEB128 integer that represents a byte displacement B. It pops one stack
entry that is required to be an integral type value that represents a target
architecture specific address space identifier AS.</p>
<p>The action is the same as for <code class="docutils literal notranslate"><span class="pre">DW_OP_breg&lt;N&gt;</span></code>, except that R is used as
the register number, B is used as the byte displacement, and AS is used as
the address space identifier.</p>
<p>The DWARF expression is ill-formed if AS is not one of the values defined by
the target architecture specific <code class="docutils literal notranslate"><span class="pre">DW_ASPACE_*</span></code> values.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Could also consider adding <code class="docutils literal notranslate"><span class="pre">DW_OP_aspace_breg0,</span> <span class="pre">DW_OP_aspace_breg1,</span> <span class="pre">...,</span>
<span class="pre">DW_OP_aspace_bref31</span></code> which would save encoding size.</p>
</div>
</li>
</ol>
</div>
<div class="section" id="a-2-5-4-4-4-register-location-description-operations">
<span id="amdgpu-dwarf-register-location-description-operations"></span><h7><a class="toc-backref" href="#id42">A.2.5.4.4.4 Register Location Description Operations</a><a class="headerlink" href="#a-2-5-4-4-4-register-location-description-operations" title="Permalink to this headline">¶</a></h7>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section replaces DWARF Version 5 section 2.6.1.1.3.</p>
</div>
<p>There is a register location storage that corresponds to each of the target
architecture registers. The size of each register location storage corresponds
to the size of the corresponding target architecture register.</p>
<p>A register location description specifies a register location storage. The bit
offset corresponds to a bit position within the register. Bits accessed using a
register location description access the corresponding target architecture
register starting at the specified bit offset.</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_reg0</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_reg1</span></code>, …, <code class="docutils literal notranslate"><span class="pre">DW_OP_reg31</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_reg&lt;N&gt;</span></code> operations encode the numbers of up to 32 registers,
numbered from 0 through 31, inclusive. The target architecture register
number R corresponds to the N in the operation name.</p>
<p>The operation is equivalent to performing <code class="docutils literal notranslate"><span class="pre">DW_OP_regx</span> <span class="pre">R</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_regx</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_regx</span></code> has a single unsigned LEB128 integer operand that represents
a target architecture register number R.</p>
<p>If the current call frame is the top call frame, it pushes a location
description L that specifies one register location description SL on the
stack. SL specifies the register location storage that corresponds to R with
a bit offset of 0 for the current thread.</p>
<p>If the current call frame is not the top call frame, call frame information
(see <a class="reference internal" href="#amdgpu-dwarf-call-frame-information"><span class="std std-ref">A.6.4 Call Frame Information</span></a>) is used to determine the
location description that holds the register for the current call frame and
current program location of the current thread. The resulting location
description L is pushed.</p>
<p><em>Note that if call frame information is used, the resulting location
description may be register, memory, or undefined.</em></p>
<p><em>An implementation may evaluate the call frame information immediately, or
may defer evaluation until L is accessed by an operation. If evaluation is
deferred, R and the current context can be recorded in L. When accessed, the
recorded context is used to evaluate the call frame information, not the
current context of the access operation.</em></p>
</li>
</ol>
<p><em>These operations obtain a register location. To fetch the contents of a
register, it is necessary to use</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_regval_type</span></code><em>, use one of the</em>
<code class="docutils literal notranslate"><span class="pre">DW_OP_breg*</span></code> <em>register-based addressing operations, or use</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_deref*</span></code>
<em>on a register location description.</em></p>
</div>
<div class="section" id="a-2-5-4-4-5-implicit-location-description-operations">
<span id="amdgpu-dwarf-implicit-location-description-operations"></span><h7><a class="toc-backref" href="#id43">A.2.5.4.4.5 Implicit Location Description Operations</a><a class="headerlink" href="#a-2-5-4-4-5-implicit-location-description-operations" title="Permalink to this headline">¶</a></h7>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section replaces DWARF Version 5 section 2.6.1.1.4.</p>
</div>
<p>Implicit location storage represents a piece or all of an object which has no
actual location in the program but whose contents are nonetheless known, either
as a constant or can be computed from other locations and values in the program.</p>
<p>An implicit location description specifies an implicit location storage. The bit
offset corresponds to a bit position within the implicit location storage. Bits
accessed using an implicit location description, access the corresponding
implicit storage value starting at the bit offset.</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_value</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_value</span></code> has two operands. The first is an unsigned LEB128
integer that represents a byte size S. The second is a block of bytes with a
length equal to S treated as a literal value V.</p>
<p>An implicit location storage LS is created with the literal value V and a
size of S.</p>
<p>It pushes location description L with one implicit location description SL
on the stack. SL specifies LS with a bit offset of 0.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_stack_value</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_stack_value</span></code> pops one stack entry that must be a value V.</p>
<p>An implicit location storage LS is created with the literal value V using
the size, encoding, and enianity specified by V’s base type.</p>
<p>It pushes a location description L with one implicit location description SL
on the stack. SL specifies LS with a bit offset of 0.</p>
<p><em>The</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_stack_value</span></code> <em>operation specifies that the object does not
exist in memory, but its value is nonetheless known. In this form, the
location description specifies the actual value of the object, rather than
specifying the memory or register storage that holds the value.</em></p>
<p>See <a class="reference internal" href="#amdgpu-dwarf-implicit-location-description-operations"><span class="std std-ref">A.2.5.4.4.5 Implicit Location Description Operations</span></a> for special
rules concerning implicit pointer values produced by dereferencing implicit
location descriptions created by the <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> and
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_implicit_aspace_pointer</span></code> operations.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since location descriptions are allowed on the stack, the
<code class="docutils literal notranslate"><span class="pre">DW_OP_stack_value</span></code> operation no longer terminates the DWARF operation
expression execution as in DWARF Version 5.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code></p>
<p><em>An optimizing compiler may eliminate a pointer, while still retaining the
value that the pointer addressed.</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> <em>allows a
producer to describe this value.</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> <em>specifies an object is a pointer to the target
architecture default address space that cannot be represented as a real
pointer, even though the value it would point to can be described. In this
form, the location description specifies a debugging information entry that
represents the actual location description of the object to which the
pointer would point. Thus, a consumer of the debug information would be able
to access the dereferenced pointer, even when it cannot access the pointer
itself.</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> has two operands. The first operand is a 4-byte
unsigned value in the 32-bit DWARF format, or an 8-byte unsigned value in
the 64-bit DWARF format, that represents the byte offset DR of a debugging
information entry D relative to the beginning of the <code class="docutils literal notranslate"><span class="pre">.debug_info</span></code> section
that contains the current compilation unit. The second operand is a signed
LEB128 integer that represents a byte displacement B.</p>
<p><em>Note that D may not be in the current compilation unit.</em></p>
<p><em>The first operand interpretation is exactly like that for</em>
<code class="docutils literal notranslate"><span class="pre">DW_FORM_ref_addr</span></code><em>.</em></p>
<p>The address space identifier AS is defined as the one corresponding to the
target architecture specific default address space.</p>
<p>The address size S is defined as the address bit size of the target
architecture specific address space corresponding to AS.</p>
<p>An implicit location storage LS is created with the debugging information
entry D, address space AS, and size of S.</p>
<p>It pushes a location description L that comprises one implicit location
description SL on the stack. SL specifies LS with a bit offset of 0.</p>
<p>It is an evaluation error if a <code class="docutils literal notranslate"><span class="pre">DW_OP_deref*</span></code> operation pops a location
description L’, and retrieves S bits, such that any retrieved bits come from
an implicit location storage that is the same as LS, unless both the
following conditions are met:</p>
<ol class="arabic">
<li><p>All retrieved bits come from an implicit location description that
refers to an implicit location storage that is the same as LS.</p>
<p><em>Note that all bits do not have to come from the same implicit location
description, as L’ may involve composite location descriptors.</em></p>
</li>
<li><p>The bits come from consecutive ascending offsets within their respective
implicit location storage.</p></li>
</ol>
<p><em>These rules are equivalent to retrieving the complete contents of LS.</em></p>
<p>If both the above conditions are met, then the value V pushed by the
<code class="docutils literal notranslate"><span class="pre">DW_OP_deref*</span></code> operation is an implicit pointer value IPV with a target
architecture specific address space of AS, a debugging information entry of
D, and a base type of T. If AS is the target architecture default address
space, then T is the generic type. Otherwise, T is a target architecture
specific integral type with a bit size equal to S.</p>
<p>If IPV is either implicitly converted to a location description (only done
if AS is the target architecture default address space) or used by
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code> (only done if the address space popped by
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code> is AS), then the resulting location
description RL is:</p>
<ul>
<li><p>If D has a <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> attribute, the DWARF expression E from the
<code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> attribute is evaluated with the current context, except
that the result kind is a location description, the compilation unit is
the one that contains D, the object is unspecified, and the initial stack
is empty. RL is the expression result.</p>
<p><em>Note that E is evaluated with the context of the expression accessing
IPV, and not the context of the expression that contained the</em>
<code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> <em>or</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code>
<em>operation that created L.</em></p>
</li>
<li><p>If D has a <code class="docutils literal notranslate"><span class="pre">DW_AT_const_value</span></code> attribute, then an implicit location
storage RLS is created from the <code class="docutils literal notranslate"><span class="pre">DW_AT_const_value</span></code> attribute’s value
with a size matching the size of the <code class="docutils literal notranslate"><span class="pre">DW_AT_const_value</span></code> attribute’s
value. RL comprises one implicit location description SRL. SRL specifies
RLS with a bit offset of 0.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If using <code class="docutils literal notranslate"><span class="pre">DW_AT_const_value</span></code> for variables and formal parameters is
deprecated and instead <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> is used with an implicit
location description, then this rule would not be required.</p>
</div>
</li>
<li><p>Otherwise, it is an evaluation error.</p></li>
</ul>
<p>The bit offset of RL is updated as if the <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset_uconst</span> <span class="pre">B</span></code>
operation was applied.</p>
<p>If a <code class="docutils literal notranslate"><span class="pre">DW_OP_stack_value</span></code> operation pops a value that is the same as IPV,
then it pushes a location description that is the same as L.</p>
<p>It is an evaluation error if LS or IPV is accessed in any other manner.</p>
<p><em>The restrictions on how an implicit pointer location description created
by</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> <em>and</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code>
<em>can be used are to simplify the DWARF consumer. Similarly, for an implicit
pointer value created by</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_deref*</span></code> <em>and</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_stack_value</span></code><em>.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code> has two operands that are the same as
for <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code>.</p>
<p>It pops one stack entry that must be an integral type value that represents
a target architecture specific address space identifier AS.</p>
<p>The location description L that is pushed on the stack is the same as for
<code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code>, except that the address space identifier used is
AS.</p>
<p>The DWARF expression is ill-formed if AS is not one of the values defined by
the target architecture specific <code class="docutils literal notranslate"><span class="pre">DW_ASPACE_*</span></code> values.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This definition of <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code> may change when
full support for address classes is added as required for languages such
as OpenCL/SyCL.</p>
</div>
</li>
</ol>
<p><em>Typically a</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> <em>or</em>
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code> <em>operation is used in a DWARF expression
E</em><sub>1</sub> <em>of a</em> <code class="docutils literal notranslate"><span class="pre">DW_TAG_variable</span></code> <em>or</em> <code class="docutils literal notranslate"><span class="pre">DW_TAG_formal_parameter</span></code>
<em>debugging information entry D</em><sub>1</sub><em>‘s</em> <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> <em>attribute.
The debugging information entry referenced by the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code>
<em>or</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code> <em>operations is typically itself a</em>
<code class="docutils literal notranslate"><span class="pre">DW_TAG_variable</span></code> <em>or</em> <code class="docutils literal notranslate"><span class="pre">DW_TAG_formal_parameter</span></code> <em>debugging information
entry D</em><sub>2</sub> <em>whose</em> <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> <em>attribute gives a second DWARF
expression E</em><sub>2</sub><em>.</em></p>
<p><em>D</em><sub>1</sub> <em>and E</em><sub>1</sub> <em>are describing the location of a pointer type
object. D</em><sub>2</sub> <em>and E</em><sub>2</sub> <em>are describing the location of the
object pointed to by that pointer object.</em></p>
<p><em>However, D</em><sub>2</sub> <em>may be any debugging information entry that contains a</em>
<code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> <em>or</em> <code class="docutils literal notranslate"><span class="pre">DW_AT_const_value</span></code> <em>attribute (for example,</em>
<code class="docutils literal notranslate"><span class="pre">DW_TAG_dwarf_procedure</span></code><em>). By using E</em><sub>2</sub><em>, a consumer can
reconstruct the value of the object when asked to dereference the pointer
described by E</em><sub>1</sub> <em>which contains the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> <em>or</em>
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code> <em>operation.</em></p>
</div>
<div class="section" id="a-2-5-4-4-6-composite-location-description-operations">
<span id="amdgpu-dwarf-composite-location-description-operations"></span><h7><a class="toc-backref" href="#id44">A.2.5.4.4.6 Composite Location Description Operations</a><a class="headerlink" href="#a-2-5-4-4-6-composite-location-description-operations" title="Permalink to this headline">¶</a></h7>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section replaces DWARF Version 5 section 2.6.1.2.</p>
</div>
<p>A composite location storage represents an object or value which may be
contained in part of another location storage or contained in parts of more
than one location storage.</p>
<p>Each part has a part location description L and a part bit size S. L can have
one or more single location descriptions SL. If there are more than one SL then
that indicates that part is located in more than one place. The bits of each
place of the part comprise S contiguous bits from the location storage LS
specified by SL starting at the bit offset specified by SL. All the bits must
be within the size of LS or the DWARF expression is ill-formed.</p>
<p>A composite location storage can have zero or more parts. The parts are
contiguous such that the zero-based location storage bit index will range over
each part with no gaps between them. Therefore, the size of a composite location
storage is the sum of the size of its parts. The DWARF expression is ill-formed
if the size of the contiguous location storage is larger than the size of the
memory location storage corresponding to the largest target architecture
specific address space.</p>
<p>A composite location description specifies a composite location storage. The bit
offset corresponds to a bit position within the composite location storage.</p>
<p>There are operations that create a composite location storage.</p>
<p>There are other operations that allow a composite location storage to be
incrementally created. Each part is created by a separate operation. There may
be one or more operations to create the final composite location storage. A
series of such operations describes the parts of the composite location storage
that are in the order that the associated part operations are executed.</p>
<p>To support incremental creation, a composite location storage can be in an
incomplete state. When an incremental operation operates on an incomplete
composite location storage, it adds a new part, otherwise it creates a new
composite location storage. The <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_piece_end</span></code> operation explicitly
makes an incomplete composite location storage complete.</p>
<p>A composite location description that specifies a composite location storage
that is incomplete is termed an incomplete composite location description. A
composite location description that specifies a composite location storage that
is complete is termed a complete composite location description.</p>
<p>If the top stack entry is a location description that has one incomplete
composite location description SL after the execution of an operation expression
has completed, SL is converted to a complete composite location description.</p>
<p><em>Note that this conversion does not happen after the completion of an operation
expression that is evaluated on the same stack by the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code>
<em>operations. Such executions are not a separate evaluation of an operation
expression, but rather the continued evaluation of the same operation expression
that contains the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> <em>operation.</em></p>
<p>If a stack entry is required to be a location description L, but L has an
incomplete composite location description, then the DWARF expression is
ill-formed. The exception is for the operations involved in incrementally
creating a composite location description as described below.</p>
<p><em>Note that a DWARF operation expression may arbitrarily compose composite
location descriptions from any other location description, including those that
have multiple single location descriptions, and those that have composite
location descriptions.</em></p>
<p><em>The incremental composite location description operations are defined to be
compatible with the definitions in DWARF Version 5.</em></p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_piece</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_piece</span></code> has a single unsigned LEB128 integer that represents a byte
size S.</p>
<p>The action is based on the context:</p>
<ul>
<li><p>If the stack is empty, then a location description L comprised of one
incomplete composite location description SL is pushed on the stack.</p>
<p>An incomplete composite location storage LS is created with a single part
P. P specifies a location description PL and has a bit size of S scaled by
8 (the byte size). PL is comprised of one undefined location description
PSL.</p>
<p>SL specifies LS with a bit offset of 0.</p>
</li>
<li><p>Otherwise, if the top stack entry is a location description L comprised of
one incomplete composite location description SL, then the incomplete
composite location storage LS that SL specifies is updated to append a new
part P. P specifies a location description PL and has a bit size of S
scaled by 8 (the byte size). PL is comprised of one undefined location
description PSL. L is left on the stack.</p></li>
<li><p>Otherwise, if the top stack entry is a location description or can be
converted to one, then it is popped and treated as a part location
description PL. Then:</p>
<ul>
<li><p>If the top stack entry (after popping PL) is a location description L
comprised of one incomplete composite location description SL, then the
incomplete composite location storage LS that SL specifies is updated to
append a new part P. P specifies the location description PL and has a
bit size of S scaled by 8 (the byte size). L is left on the stack.</p></li>
<li><p>Otherwise, a location description L comprised of one incomplete
composite location description SL is pushed on the stack.</p>
<p>An incomplete composite location storage LS is created with a single
part P. P specifies the location description PL and has a bit size of S
scaled by 8 (the byte size).</p>
<p>SL specifies LS with a bit offset of 0.</p>
</li>
</ul>
</li>
<li><p>Otherwise, the DWARF expression is ill-formed</p></li>
</ul>
<p><em>Many compilers store a single variable in sets of registers or store a
variable partially in memory and partially in registers.</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_piece</span></code>
<em>provides a way of describing where a part of a variable is located.</em></p>
<p><em>If a non-0 byte displacement is required, the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset</span></code>
<em>operation can be used to update the location description before using it as
the part location description of a</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_piece</span></code> <em>operation.</em></p>
<p><em>The evaluation rules for the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_piece</span></code> <em>operation allow it to be
compatible with the DWARF Version 5 definition.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since these extensions allow location descriptions to be entries on the
stack, a simpler operation to create composite location descriptions could
be defined. For example, just one operation that specifies how many parts,
and pops pairs of stack entries for the part size and location
description. Not only would this be a simpler operation and avoid the
complexities of incomplete composite location descriptions, but it may
also have a smaller encoding in practice. However, the desire for
compatibility with DWARF Version 5 is likely a stronger consideration.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_bit_piece</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_bit_piece</span></code> has two operands. The first is an unsigned LEB128
integer that represents the part bit size S. The second is an unsigned
LEB128 integer that represents a bit displacement B.</p>
<p>The action is the same as for <code class="docutils literal notranslate"><span class="pre">DW_OP_piece</span></code>, except that any part created
has the bit size S, and the location description PL of any created part is
updated as if the <code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span> <span class="pre">B;</span> <span class="pre">DW_OP_LLVM_bit_offset</span></code> operations were
applied.</p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_bit_piece</span></code> <em>is used instead of</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_piece</span></code> <em>when the piece to
be assembled is not byte-sized or is not at the start of the part location
description.</em></p>
<p><em>If a computed bit displacement is required, the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_bit_offset</span></code>
<em>operation can be used to update the location description before using it as
the part location description of a</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_bit_piece</span></code> <em>operation.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The bit offset operand is not needed as <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_bit_offset</span></code> can be
used on the part’s location description.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_piece_end</span></code> <em>New</em></p>
<p>If the top stack entry is not a location description L comprised of one
incomplete composite location description SL, then the DWARF expression is
ill-formed.</p>
<p>Otherwise, the incomplete composite location storage LS specified by SL is
updated to be a complete composite location description with the same parts.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_extend</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_extend</span></code> has two operands. The first is an unsigned LEB128
integer that represents the element bit size S. The second is an unsigned
LEB128 integer that represents a count C.</p>
<p>It pops one stack entry that must be a location description and is treated
as the part location description PL.</p>
<p>A location description L comprised of one complete composite location
description SL is pushed on the stack.</p>
<p>A complete composite location storage LS is created with C identical parts
P. Each P specifies PL and has a bit size of S.</p>
<p>SL specifies LS with a bit offset of 0.</p>
<p>The DWARF expression is ill-formed if the element bit size or count are 0.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_select_bit_piece</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_select_bit_piece</span></code> has two operands. The first is an unsigned
LEB128 integer that represents the element bit size S. The second is an
unsigned LEB128 integer that represents a count C.</p>
<p>It pops three stack entries. The first must be an integral type value that
represents a bit mask value M. The second must be a location description
that represents the one-location description L1. The third must be a
location description that represents the zero-location description L0.</p>
<p>A complete composite location storage LS is created with C parts P<sub>N</sub>
ordered in ascending N from 0 to C-1 inclusive. Each P<sub>N</sub> specifies
location description PL<sub>N</sub> and has a bit size of S.</p>
<p>PL<sub>N</sub> is as if the <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_bit_offset</span> <span class="pre">N*S</span></code> operation was
applied to PLX<sub>N</sub>.</p>
<p>PLX<sub>N</sub> is the same as L0 if the N<sup>th</sup> least significant bit of
M is a zero, otherwise it is the same as L1.</p>
<p>A location description L comprised of one complete composite location
description SL is pushed on the stack. SL specifies LS with a bit offset of
0.</p>
<p>The DWARF expression is ill-formed if S or C are 0, or if the bit size of M
is less than C.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_overlay</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_overlay</span></code> pops four stack entries. The first must be an
integral type value that represents the overlay byte size value S. The
second must be an integral type value that represents the overlay byte
offset value O. The third must be a location description that represents the
overlay location description OL. The fourth must be a location description
that represents the base location description BL.</p>
<p>The action is the same as for <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_bit_overlay</span></code>, except that the
overlay bit size BS and overlay bit offset BO used are S and O respectively
scaled by 8 (the byte size).</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_bit_overlay</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_bit_overlay</span></code> pops four stack entries. The first must be an
integral type value that represents the overlay bit size value BS. The
second must be an integral type value that represents the overlay bit offset
value BO. The third must be a location description that represents the
overlay location description OL. The fourth must be a location description
that represents the base location description BL.</p>
<p>The DWARF expression is ill-formed if BS or BO are negative values.</p>
<p><em>rbss(L)</em> is the minimum remaining bit storage size of L which is defined as
follows. LS is the location storage and LO is the location bit offset
specified by a single location descriptions SL of L. The remaining bit
storage size RBSS of SL is the bit size of LS minus LO. <em>rbss(L)</em> is the
minimum RBSS of each single location description SL of L.</p>
<p>The DWARF expression is ill-formed if <em>rbss(BL)</em> is less than BO plus BS.</p>
<p>If BS is 0, then the operation pushes BL.</p>
<p>If BO is 0 and BS equals <em>rbss(BL)</em>, then the operation pushes OL.</p>
<p>Otherwise, the operation is equivalent to performing the following steps to
push a composite location description.</p>
<p><em>The composite location description is conceptually the base location
description BL with the overlay location description OL positioned as an
overlay starting at the overlay offset BO and covering overlay bit size BS.</em></p>
<ol class="arabic simple">
<li><p>If BO is not 0 then push BL followed by performing the <code class="docutils literal notranslate"><span class="pre">DW_OP_bit_piece</span>
<span class="pre">BO</span></code> operation.</p></li>
<li><p>Push OL followed by performing the <code class="docutils literal notranslate"><span class="pre">DW_OP_bit_piece</span> <span class="pre">BS</span></code> operation.</p></li>
<li><p>If <em>rbss(BL)</em> is greater than BO plus BS, push BL followed by performing
the <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_bit_offset</span> <span class="pre">(BO</span> <span class="pre">+</span> <span class="pre">BS);</span> <span class="pre">DW_OP_bit_piece</span> <span class="pre">(rbss(BL)</span> <span class="pre">-</span> <span class="pre">BO</span> <span class="pre">-</span>
<span class="pre">BS)</span></code> operations.</p></li>
<li><p>Perform the <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_piece_end</span></code> operation.</p></li>
</ol>
</li>
</ol>
</div>
</div>
</div>
<div class="section" id="a-2-5-5-dwarf-location-list-expressions">
<span id="amdgpu-dwarf-location-list-expressions"></span><h5><a class="toc-backref" href="#id45">A.2.5.5 DWARF Location List Expressions</a><a class="headerlink" href="#a-2-5-5-dwarf-location-list-expressions" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section replaces DWARF Version 5 section 2.6.2.</p>
</div>
<p><em>To meet the needs of recent computer architectures and optimization techniques,
debugging information must be able to describe the location of an object whose
location changes over the object’s lifetime, and may reside at multiple
locations during parts of an object’s lifetime. Location list expressions are
used in place of operation expressions whenever the object whose location is
being described has these requirements.</em></p>
<p>A location list expression consists of a series of location list entries. Each
location list entry is one of the following kinds:</p>
<p><em>Bounded location description</em></p>
<blockquote>
<div><p>This kind of location list entry provides an operation expression that
evaluates to the location description of an object that is valid over a
lifetime bounded by a starting and ending address. The starting address is the
lowest address of the address range over which the location is valid. The
ending address is the address of the first location past the highest address
of the address range.</p>
<p>The location list entry matches when the current program location is within
the given range.</p>
<p>There are several kinds of bounded location description entries which differ
in the way that they specify the starting and ending addresses.</p>
</div></blockquote>
<p><em>Default location description</em></p>
<blockquote>
<div><p>This kind of location list entry provides an operation expression that
evaluates to the location description of an object that is valid when no
bounded location description entry applies.</p>
<p>The location list entry matches when the current program location is not
within the range of any bounded location description entry.</p>
</div></blockquote>
<p><em>Base address</em></p>
<blockquote>
<div><p>This kind of location list entry provides an address to be used as the base
address for beginning and ending address offsets given in certain kinds of
bounded location description entries. The applicable base address of a bounded
location description entry is the address specified by the closest preceding
base address entry in the same location list. If there is no preceding base
address entry, then the applicable base address defaults to the base address
of the compilation unit (see DWARF Version 5 section 3.1.1).</p>
<p>In the case of a compilation unit where all of the machine code is contained
in a single contiguous section, no base address entry is needed.</p>
</div></blockquote>
<p><em>End-of-list</em></p>
<blockquote>
<div><p>This kind of location list entry marks the end of the location list
expression.</p>
</div></blockquote>
<p>The address ranges defined by the bounded location description entries of a
location list expression may overlap. When they do, they describe a situation in
which an object exists simultaneously in more than one place.</p>
<p>If all of the address ranges in a given location list expression do not
collectively cover the entire range over which the object in question is
defined, and there is no following default location description entry, it is
assumed that the object is not available for the portion of the range that is
not covered.</p>
<p>The result of the evaluation of a DWARF location list expression is:</p>
<ul>
<li><p>If the current program location is not specified, then it is an evaluation
error.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the location list only has a single default entry, should that be
considered a match if there is no program location? If there are non-default
entries then it seems it has to be an evaluation error when there is no
program location as that indicates the location depends on the program
location which is not known.</p>
</div>
</li>
<li><p>If there are no matching location list entries, then the result is a location
description that comprises one undefined location description.</p></li>
<li><p>Otherwise, the operation expression E of each matching location list entry is
evaluated with the current context, except that the result kind is a location
description, the object is unspecified, and the initial stack is empty. The
location list entry result is the location description returned by the
evaluation of E.</p>
<p>The result is a location description that is comprised of the union of the
single location descriptions of the location description result of each
matching location list entry.</p>
</li>
</ul>
<p>A location list expression can only be used as the value of a debugger
information entry attribute that is encoded using class <code class="docutils literal notranslate"><span class="pre">loclist</span></code> or
<code class="docutils literal notranslate"><span class="pre">loclistsptr</span></code> (see <a class="reference internal" href="#amdgpu-dwarf-classes-and-forms"><span class="std std-ref">A.7.5.5 Classes and Forms</span></a>). The value of the
attribute provides an index into a separate object file section called
<code class="docutils literal notranslate"><span class="pre">.debug_loclists</span></code> or <code class="docutils literal notranslate"><span class="pre">.debug_loclists.dwo</span></code> (for split DWARF object files)
that contains the location list entries.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> operation can be used to
specify a debugger information entry attribute that has a location list
expression. Several debugger information entry attributes allow DWARF
expressions that are evaluated with an initial stack that includes a location
description that may originate from the evaluation of a location list
expression.</p>
<p><em>This location list representation, the</em> <code class="docutils literal notranslate"><span class="pre">loclist</span></code> <em>and</em> <code class="docutils literal notranslate"><span class="pre">loclistsptr</span></code>
<em>class, and the related</em> <code class="docutils literal notranslate"><span class="pre">DW_AT_loclists_base</span></code> <em>attribute are new in DWARF
Version 5. Together they eliminate most, or all of the code object relocations
previously needed for location list expressions.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The rest of this section is the same as DWARF Version 5 section 2.6.2.</p>
</div>
</div>
</div>
<div class="section" id="a-2-12-segmented-addresses">
<span id="amdgpu-dwarf-segment-addresses"></span><h4><a class="toc-backref" href="#id46">A.2.12 Segmented Addresses</a><a class="headerlink" href="#a-2-12-segmented-addresses" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This augments DWARF Version 5 section 2.12.</p>
</div>
<p>DWARF address classes are used for source languages that have the concept of
memory spaces. They are used in the <code class="docutils literal notranslate"><span class="pre">DW_AT_address_class</span></code> attribute for
pointer type, reference type, subprogram, and subprogram type debugger
information entries.</p>
<p>Each DWARF address class is conceptually a separate source language memory space
with its own lifetime and aliasing rules. DWARF address classes are used to
specify the source language memory spaces that pointer type and reference type
values refer, and to specify the source language memory space in which variables
are allocated.</p>
<p>The set of currently defined source language DWARF address classes, together
with source language mappings, is given in
<a class="reference internal" href="#amdgpu-dwarf-address-class-table"><span class="std std-ref">Address class</span></a>.</p>
<p>Vendor defined source language address classes may be defined using codes in the
range <code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_lo_user</span></code> to <code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_hi_user</span></code>.</p>
<table class="docutils align-default" id="amdgpu-dwarf-address-class-table">
<caption><span class="caption-text">Address class</span><a class="headerlink" href="#amdgpu-dwarf-address-class-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 39%" />
<col style="width: 19%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Address Class Name</p></th>
<th class="head"><p>Meaning</p></th>
<th class="head"><p>C/C++</p></th>
<th class="head"><p>OpenCL</p></th>
<th class="head"><p>CUDA/HIP</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_none</span></code></p></td>
<td><p>generic</p></td>
<td><p><em>default</em></p></td>
<td><p>generic</p></td>
<td><p><em>default</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_global</span></code></p></td>
<td><p>global</p></td>
<td></td>
<td><p>global</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_constant</span></code></p></td>
<td><p>constant</p></td>
<td></td>
<td><p>constant</p></td>
<td><p>constant</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_group</span></code></p></td>
<td><p>thread-group</p></td>
<td></td>
<td><p>local</p></td>
<td><p>shared</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_private</span></code></p></td>
<td><p>thread</p></td>
<td></td>
<td><p>private</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_lo_user</span></code></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_hi_user</span></code></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>DWARF address spaces correspond to target architecture specific linear
addressable memory areas. They are used in DWARF expression location
descriptions to describe in which target architecture specific memory area data
resides.</p>
<p><em>Target architecture specific DWARF address spaces may correspond to hardware
supported facilities such as memory utilizing base address registers, scratchpad
memory, and memory with special interleaving. The size of addresses in these
address spaces may vary. Their access and allocation may be hardware managed
with each thread or group of threads having access to independent storage. For
these reasons they may have properties that do not allow them to be viewed as
part of the unified global virtual address space accessible by all threads.</em></p>
<p><em>It is target architecture specific whether multiple DWARF address spaces are
supported and how source language DWARF address classes map to target
architecture specific DWARF address spaces. A target architecture may map
multiple source language DWARF address classes to the same target architecture
specific DWARF address class. Optimization may determine that variable lifetime
and access pattern allows them to be allocated in faster scratchpad memory
represented by a different DWARF address space.</em></p>
<p>Although DWARF address space identifiers are target architecture specific,
<code class="docutils literal notranslate"><span class="pre">DW_ASPACE_none</span></code> is a common address space supported by all target
architectures.</p>
<p>DWARF address space identifiers are used by:</p>
<ul class="simple">
<li><p>The DWARF expression operations: <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_bregx</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_implicit_aspace_pointer</span></code>,
and <code class="docutils literal notranslate"><span class="pre">DW_OP_xderef*</span></code>.</p></li>
<li><p>The CFI instructions: <code class="docutils literal notranslate"><span class="pre">DW_CFA_LLVM_def_aspace_cfa</span></code> and
<code class="docutils literal notranslate"><span class="pre">DW_CFA_LLVM_def_aspace_cfa_sf</span></code>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>With the definition of DWARF address classes and DWARF address spaces in these
extensions, DWARF Version 5 table 2.7 needs to be updated. It seems it is an
example of DWARF address spaces and not DWARF address classes.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>With the expanded support for DWARF address spaces in these extensions, it may
be worth examining if DWARF segments can be eliminated and DWARF address
spaces used instead.</p>
<p>That may involve extending DWARF address spaces to also be used to specify
code locations. In target architectures that use different memory areas for
code and data this would seem a natural use for DWARF address spaces. This
would allow DWARF expression location descriptions to be used to describe the
location of subprograms and entry points that are used in expressions
involving subprogram pointer type values.</p>
<p>Currently, DWARF expressions assume data and code resides in the same default
DWARF address space, and only the address ranges in DWARF location list
entries and in the <code class="docutils literal notranslate"><span class="pre">.debug_aranges</span></code> section for accelerated access for
addresses allow DWARF segments to be used to distinguish.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, DWARF defines address class values as being target architecture
specific. It is unclear how language specific memory spaces are intended to be
represented in DWARF using these.</p>
<p>For example, OpenCL defines memory spaces (called address spaces in OpenCL)
for <code class="docutils literal notranslate"><span class="pre">global</span></code>, <code class="docutils literal notranslate"><span class="pre">local</span></code>, <code class="docutils literal notranslate"><span class="pre">constant</span></code>, and <code class="docutils literal notranslate"><span class="pre">private</span></code>. These are part of
the type system and are modifiers to pointer types. In addition, OpenCL
defines <code class="docutils literal notranslate"><span class="pre">generic</span></code> pointers that can reference either the <code class="docutils literal notranslate"><span class="pre">global</span></code>,
<code class="docutils literal notranslate"><span class="pre">local</span></code>, or <code class="docutils literal notranslate"><span class="pre">private</span></code> memory spaces. To support the OpenCL language the
debugger would want to support casting pointers between the <code class="docutils literal notranslate"><span class="pre">generic</span></code> and
other memory spaces, querying what memory space a <code class="docutils literal notranslate"><span class="pre">generic</span></code> pointer value is
currently referencing, and possibly using pointer casting to form an address
for a specific memory space out of an integral value.</p>
<p>The method to use to dereference a pointer type or reference type value is
defined in DWARF expressions using <code class="docutils literal notranslate"><span class="pre">DW_OP_xderef*</span></code> which uses a target
architecture specific address space.</p>
<p>DWARF defines the <code class="docutils literal notranslate"><span class="pre">DW_AT_address_class</span></code> attribute on pointer type and
reference type debugger information entries. It specifies the method to use to
dereference them. Why is the value of this not the same as the address space
value used in <code class="docutils literal notranslate"><span class="pre">DW_OP_xderef*</span></code>? In both cases it is target architecture
specific and the architecture presumably will use the same set of methods to
dereference pointers in both cases.</p>
<p>Since <code class="docutils literal notranslate"><span class="pre">DW_AT_address_class</span></code> uses a target architecture specific value, it
cannot in general capture the source language memory space type modifier
concept. On some architectures all source language memory space modifiers may
actually use the same method for dereferencing pointers.</p>
<p>One possibility is for DWARF to add an <code class="docutils literal notranslate"><span class="pre">DW_TAG_LLVM_address_class_type</span></code>
debugger information entry type modifier that can be applied to a pointer type
and reference type. The <code class="docutils literal notranslate"><span class="pre">DW_AT_address_class</span></code> attribute could be re-defined
to not be target architecture specific and instead define generalized language
values (as presented above for DWARF address classes in the table
<a class="reference internal" href="#amdgpu-dwarf-address-class-table"><span class="std std-ref">Address class</span></a>) that will support OpenCL and other
languages using memory spaces. The <code class="docutils literal notranslate"><span class="pre">DW_AT_address_class</span></code> attribute could be
defined to not be applied to pointer types or reference types, but instead
only to the new <code class="docutils literal notranslate"><span class="pre">DW_TAG_LLVM_address_class_type</span></code> type modifier debugger
information entry.</p>
<p>If a pointer type or reference type is not modified by
<code class="docutils literal notranslate"><span class="pre">DW_TAG_LLVM_address_class_type</span></code> or if <code class="docutils literal notranslate"><span class="pre">DW_TAG_LLVM_address_class_type</span></code>
has no <code class="docutils literal notranslate"><span class="pre">DW_AT_address_class</span></code> attribute, then the pointer type or reference
type would be defined to use the <code class="docutils literal notranslate"><span class="pre">DW_ADDR_none</span></code> address class as currently.
Since modifiers can be chained, it would need to be defined if multiple
<code class="docutils literal notranslate"><span class="pre">DW_TAG_LLVM_address_class_type</span></code> modifiers were legal, and if so if the
outermost one is the one that takes precedence.</p>
<p>A target architecture implementation that supports multiple address spaces
would need to map <code class="docutils literal notranslate"><span class="pre">DW_ADDR_none</span></code> appropriately to support CUDA-like
languages that have no address classes in the type system but do support
variable allocation in address classes. Such variable allocation would result
in the variable’s location description needing an address space.</p>
<p>The approach presented in <a class="reference internal" href="#amdgpu-dwarf-address-class-table"><span class="std std-ref">Address class</span></a> is to define
the default <code class="docutils literal notranslate"><span class="pre">DW_ADDR_none</span></code> to be the generic address class and not the
global address class. This matches how CLANG and LLVM have added support for
CUDA-like languages on top of existing C++ language support. This allows all
addresses to be generic by default which matches CUDA-like languages.</p>
<p>An alternative approach is to define <code class="docutils literal notranslate"><span class="pre">DW_ADDR_none</span></code> as being the global
address class and then change <code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_global</span></code> to
<code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_generic</span></code>. This would match the reality that languages that do
not support multiple memory spaces only have one default global memory space.
Generally, in these languages if they expose that the target architecture
supports multiple address spaces, the default one is still the global memory
space. Then a language that does support multiple memory spaces has to
explicitly indicate which pointers have the added ability to reference more
than the global memory space. However, compilers generating DWARF for
CUDA-like languages would then have to define every CUDA-like language pointer
type or reference type using <code class="docutils literal notranslate"><span class="pre">DW_TAG_LLVM_address_class_type</span></code> with a
<code class="docutils literal notranslate"><span class="pre">DW_AT_address_class</span></code> attribute of <code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_generic</span></code> to match the
language semantics.</p>
<p>A new <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_address_space</span></code> attribute could be defined that can be
applied to pointer type, reference type, subprogram, and subprogram type to
describe how objects having the given type are dereferenced or called (the
role that <code class="docutils literal notranslate"><span class="pre">DW_AT_address_class</span></code> currently provides). The values of
<code class="docutils literal notranslate"><span class="pre">DW_AT_address_space</span></code> would be target architecture specific and the same as
used in <code class="docutils literal notranslate"><span class="pre">DW_OP_xderef*</span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Some additional changes will be made to support languages such as OpenCL/SyCL
that allow address class pointer casting and queries.</p>
<p>This requires the compiler to provide the mapping from address space to
address class which may be runtime and not target architecture dependent. Some
implementations may have a one-to-one mapping from source language address
class to target architecture address space, and some may have a many-to-one
mapping which requires knowledge of the address class when determining if
pointer address class casts are allowed.</p>
<p>The changes will likely add an attribute that has an expression provided by
the compiler to map from address class to address space. The
<code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code>
operations may be changed as the current IPV definition may not provide enough
information when used to cast between address classes. Other attributes and
operations may be needed. The legal casts between address classes may need to
be defined on a per language address class basis.</p>
</div>
</div>
</div>
<div class="section" id="a-3-program-scope-entries">
<h3><a class="toc-backref" href="#id47">A.3 Program Scope Entries</a><a class="headerlink" href="#a-3-program-scope-entries" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section provides changes to existing debugger information entry
attributes. These would be incorporated into the corresponding DWARF Version 5
chapter 3 sections.</p>
</div>
<div class="section" id="a-3-1-unit-entries">
<h4><a class="toc-backref" href="#id48">A.3.1 Unit Entries</a><a class="headerlink" href="#a-3-1-unit-entries" title="Permalink to this headline">¶</a></h4>
<div class="section" id="a-3-1-1-full-and-partial-compilation-unit-entries">
<span id="amdgpu-dwarf-full-and-partial-compilation-unit-entries"></span><h5><a class="toc-backref" href="#id49">A.3.1.1 Full and Partial Compilation Unit Entries</a><a class="headerlink" href="#a-3-1-1-full-and-partial-compilation-unit-entries" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This augments DWARF Version 5 section 3.1.1 and Table 3.1.</p>
</div>
<p>Additional language codes defined for use with the <code class="docutils literal notranslate"><span class="pre">DW_AT_language</span></code> attribute
are defined in <a class="reference internal" href="#amdgpu-dwarf-language-names-table"><span class="std std-ref">Language Names</span></a>.</p>
<table class="docutils align-default" id="amdgpu-dwarf-language-names-table">
<caption><span class="caption-text">Language Names</span><a class="headerlink" href="#amdgpu-dwarf-language-names-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 41%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Language Name</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_LANG_LLVM_HIP</span></code></p></td>
<td><p>HIP Language.</p></td>
</tr>
</tbody>
</table>
<p>The HIP language [<a class="reference internal" href="#amdgpu-dwarf-hip"><span class="std std-ref">HIP</span></a>] can be supported by extending
the C++ language.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following new attribute is added.</p>
</div>
<ol class="arabic">
<li><p>A <code class="docutils literal notranslate"><span class="pre">DW_TAG_compile_unit</span></code> debugger information entry for a compilation unit
may have a <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_augmentation</span></code> attribute, whose value is an
augmentation string.</p>
<p><em>The augmentation string allows producers to indicate that there is
additional vendor or target specific information in the debugging
information entries. For example, this might be information about the
version of vendor specific extensions that are being used.</em></p>
<p>If not present, or if the string is empty, then the compilation unit has no
augmentation string.</p>
<p>The format for the augmentation string is:</p>
<blockquote>
<div><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">[</span></code><em>vendor</em><code class="docutils literal notranslate"><span class="pre">:v</span></code><em>X</em><code class="docutils literal notranslate"><span class="pre">.</span></code><em>Y</em>[<code class="docutils literal notranslate"><span class="pre">:</span></code><em>options</em>]<code class="docutils literal notranslate"><span class="pre">]</span></code>*</div>
</div>
</div></blockquote>
<p>Where <em>vendor</em> is the producer, <code class="docutils literal notranslate"><span class="pre">vX.Y</span></code> specifies the major X and minor Y
version number of the extensions used, and <em>options</em> is an optional string
providing additional information about the extensions. The version number
must conform to semantic versioning [<a class="reference internal" href="#amdgpu-dwarf-semver"><span class="std std-ref">SEMVER</span></a>].
The <em>options</em> string must not contain the “<code class="docutils literal notranslate"><span class="pre">]</span></code>” character.</p>
<p>For example:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">abc</span><span class="p">:</span><span class="n">v0</span><span class="mf">.0</span><span class="p">][</span><span class="n">def</span><span class="p">:</span><span class="n">v1</span><span class="mf">.2</span><span class="p">:</span><span class="n">feature</span><span class="o">-</span><span class="n">a</span><span class="o">=</span><span class="n">on</span><span class="p">,</span><span class="n">feature</span><span class="o">-</span><span class="n">b</span><span class="o">=</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ol>
</div>
</div>
<div class="section" id="a-3-3-subroutine-and-entry-point-entries">
<h4><a class="toc-backref" href="#id50">A.3.3 Subroutine and Entry Point Entries</a><a class="headerlink" href="#a-3-3-subroutine-and-entry-point-entries" title="Permalink to this headline">¶</a></h4>
<div class="section" id="a-3-3-5-low-level-information">
<span id="amdgpu-dwarf-low-level-information"></span><h5><a class="toc-backref" href="#id51">A.3.3.5 Low-Level Information</a><a class="headerlink" href="#a-3-3-5-low-level-information" title="Permalink to this headline">¶</a></h5>
<ol class="arabic">
<li><p>A <code class="docutils literal notranslate"><span class="pre">DW_TAG_subprogram</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_TAG_inlined_subroutine</span></code>, or
<code class="docutils literal notranslate"><span class="pre">DW_TAG_entry_point</span></code> debugger information entry may have a
<code class="docutils literal notranslate"><span class="pre">DW_AT_return_addr</span></code> attribute, whose value is a DWARF expression E.</p>
<p>The result of the attribute is obtained by evaluating E with a context that
has a result kind of a location description, an unspecified object, the
compilation unit that contains E, an empty initial stack, and other context
elements corresponding to the source language thread of execution upon which
the user is focused, if any. The result of the evaluation is the location
description L of the place where the return address for the current call
frame’s subprogram or entry point is stored.</p>
<p>The DWARF is ill-formed if L is not comprised of one memory location
description for one of the target architecture specific address spaces.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is unclear why <code class="docutils literal notranslate"><span class="pre">DW_TAG_inlined_subroutine</span></code> has a
<code class="docutils literal notranslate"><span class="pre">DW_AT_return_addr</span></code> attribute but not a <code class="docutils literal notranslate"><span class="pre">DW_AT_frame_base</span></code> or
<code class="docutils literal notranslate"><span class="pre">DW_AT_static_link</span></code> attribute. Seems it would either have all of them or
none. Since inlined subprograms do not have a call frame it seems they
would have none of these attributes.</p>
</div>
</li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">DW_TAG_subprogram</span></code> or <code class="docutils literal notranslate"><span class="pre">DW_TAG_entry_point</span></code> debugger information entry
may have a <code class="docutils literal notranslate"><span class="pre">DW_AT_frame_base</span></code> attribute, whose value is a DWARF expression
E.</p>
<p>The result of the attribute is obtained by evaluating E with a context that
has a result kind of a location description, an unspecified object, the
compilation unit that contains E, an empty initial stack, and other context
elements corresponding to the source language thread of execution upon which
the user is focused, if any.</p>
<p>The DWARF is ill-formed if E contains an <code class="docutils literal notranslate"><span class="pre">DW_OP_fbreg</span></code> operation, or the
resulting location description L is not comprised of one single location
description SL.</p>
<p>If SL is a register location description for register R, then L is replaced
with the result of evaluating a <code class="docutils literal notranslate"><span class="pre">DW_OP_bregx</span> <span class="pre">R,</span> <span class="pre">0</span></code> operation. This
computes the frame base memory location description in the target
architecture default address space.</p>
<p><em>This allows the more compact</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_reg*</span></code> <em>to be used instead of</em>
<code class="docutils literal notranslate"><span class="pre">DW_OP_breg*</span> <span class="pre">0</span></code><em>.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This rule could be removed and require the producer to create the required
location description directly using <code class="docutils literal notranslate"><span class="pre">DW_OP_call_frame_cfa</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_OP_breg*</span></code>, or <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_bregx</span></code>. This would also then
allow a target to implement the call frames within a large register.</p>
</div>
<p>Otherwise, the DWARF is ill-formed if SL is not a memory location
description in any of the target architecture specific address spaces.</p>
<p>The resulting L is the <em>frame base</em> for the subprogram or entry point.</p>
<p><em>Typically, E will use the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_call_frame_cfa</span></code> <em>operation or be a
stack pointer register plus or minus some offset.</em></p>
</li>
<li><p>If a <code class="docutils literal notranslate"><span class="pre">DW_TAG_subprogram</span></code> or <code class="docutils literal notranslate"><span class="pre">DW_TAG_entry_point</span></code> debugger information
entry is lexically nested, it may have a <code class="docutils literal notranslate"><span class="pre">DW_AT_static_link</span></code> attribute,
whose value is a DWARF expression E.</p>
<p>The result of the attribute is obtained by evaluating E with a context that
has a result kind of a location description, an unspecified object, the
compilation unit that contains E, an empty initial stack, and other context
elements corresponding to the source language thread of execution upon which
the user is focused, if any. The result of the evaluation is the location
description L of the <em>canonical frame address</em> (see
<a class="reference internal" href="#amdgpu-dwarf-call-frame-information"><span class="std std-ref">A.6.4 Call Frame Information</span></a>) of the relevant call frame of
the subprogram instance that immediately lexically encloses the current call
frame’s subprogram or entry point.</p>
<p>The DWARF is ill-formed if L is is not comprised of one memory location
description for one of the target architecture specific address spaces.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following new attributes are added.</p>
</div>
</li>
<li><p>For languages that are implemented using a SIMT execution model, a
<code class="docutils literal notranslate"><span class="pre">DW_TAG_subprogram</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_TAG_inlined_subroutine</span></code>, or
<code class="docutils literal notranslate"><span class="pre">DW_TAG_entry_point</span></code> debugger information entry may have a
<code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lanes</span></code> attribute whose value is an integer constant that is
the number of source language threads of execution per target architecture
thread.</p>
<p><em>For example, a compiler may map source language threads of execution onto
lanes of a target architecture thread using a SIMT execution model.</em></p>
<p>It is the static number of source language threads of execution per target
architecture thread. It is not the dynamic number of source language threads
of execution with which the target architecture thread was initiated, for
example, due to smaller or partial work-groups.</p>
<p>If not present, the default value of 1 is used.</p>
<p>The DWARF is ill-formed if the value is less than or equal to 0.</p>
</li>
<li><p>For source languages that are implemented using a SIMT execution model, a
<code class="docutils literal notranslate"><span class="pre">DW_TAG_subprogram</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_TAG_inlined_subroutine</span></code>, or
<code class="docutils literal notranslate"><span class="pre">DW_TAG_entry_point</span></code> debugging information entry may have a
<code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code> attribute whose value is a DWARF expression E.</p>
<p>The result of the attribute is obtained by evaluating E with a context that
has a result kind of a location description, an unspecified object, the
compilation unit that contains E, an empty initial stack, and other context
elements corresponding to the source language thread of execution upon which
the user is focused, if any.</p>
<p>The resulting location description L is for a lane count sized vector of
generic type elements. The lane count is the value of the
<code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lanes</span></code> attribute. Each element holds the conceptual program
location of the corresponding lane. If the lane was not active when the
current subprogram was called, its element is an undefined location
description.</p>
<p>The DWARF is ill-formed if L does not have exactly one single location
description.</p>
<p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code> <em>allows the compiler to indicate conceptually where
each SIMT lane of a target architecture thread is positioned even when it is
in divergent control flow that is not active.</em></p>
<p><em>Typically, the result is a location description with one composite location
description with each part being a location description with either one
undefined location description or one memory location description.</em></p>
<p>If not present, the target architecture thread is not being used in a SIMT
manner, and the thread’s current program location is used.</p>
</li>
<li><p>For languages that are implemented using a SIMT execution model, a
<code class="docutils literal notranslate"><span class="pre">DW_TAG_subprogram</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_TAG_inlined_subroutine</span></code>, or
<code class="docutils literal notranslate"><span class="pre">DW_TAG_entry_point</span></code> debugger information entry may have a
<code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_active_lane</span></code> attribute whose value is a DWARF expression E.</p>
<p>E is evaluated with a context that has a result kind of a location
description, an unspecified object, the compilation unit that contains E, an
empty initial stack, and other context elements corresponding to the source
language thread of execution upon which the user is focused, if any.</p>
<p>The DWARF is ill-formed if L does not have exactly one single location
description SL.</p>
<p>The active lane bit mask V for the current program location is obtained by
reading from SL using a target architecture specific integral base type T
that has a bit size equal to the value of the <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lanes</span></code> attribute
of the subprogram corresponding to context’s frame and program location. The
N<sup>th</sup> least significant bit of the mask corresponds to the N<sup>th</sup> lane. If the bit is 1 the lane is active, otherwise it is
inactive. The result of the attribute is the value V.</p>
<p><em>Some targets may update the target architecture execution mask for regions
of code that must execute with different sets of lanes than the current
active lanes. For example, some code must execute with all lanes made
temporarily active.</em> <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_active_lane</span></code> <em>allows the compiler to
provide the means to determine the source language active lanes at any
program location. Typically, this attribute will use a loclist to express
different locations of the active lane mask at different program locations.</em></p>
<p>If not present and <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lanes</span></code> is greater than 1, then the target
architecture execution mask is used.</p>
</li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">DW_TAG_subprogram</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_TAG_inlined_subroutine</span></code>, or
<code class="docutils literal notranslate"><span class="pre">DW_TAG_entry_point</span></code> debugger information entry may have a
<code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_iterations</span></code> attribute whose value is an integer constant or a
DWARF expression E. Its value is the number of source language loop
iterations executing concurrently by the target architecture for a single
source language thread of execution.</p>
<p><em>A compiler may generate code that executes more than one iteration of a
source language loop concurrently using optimization techniques such as
software pipelining or SIMD vectorization. The number of concurrent
iterations may vary for different loop nests in the same subprogram.
Typically, this attribute will use a loclist to express different values at
different program locations.</em></p>
<p>If the attribute is an integer constant, then the value is the constant. The
DWARF is ill-formed if the constant is less than or equal to 0.</p>
<p>Otherwise, E is evaluated with a context that has a result kind of a
location description, an unspecified object, the compilation unit that
contains E, an empty initial stack, and other context elements corresponding
to the source language thread of execution upon which the user is focused,
if any. The DWARF is ill-formed if the result is not a location description
comprised of one implicit location description, that when read as the
generic type, results in a value V that is less than or equal to 0. The
result of the attribute is the value V.</p>
<p>If not present, the default value of 1 is used.</p>
</li>
</ol>
</div>
</div>
<div class="section" id="a-3-4-call-site-entries-and-parameters">
<h4><a class="toc-backref" href="#id52">A.3.4 Call Site Entries and Parameters</a><a class="headerlink" href="#a-3-4-call-site-entries-and-parameters" title="Permalink to this headline">¶</a></h4>
<div class="section" id="a-3-4-2-call-site-parameters">
<h5><a class="toc-backref" href="#id53">A.3.4.2 Call Site Parameters</a><a class="headerlink" href="#a-3-4-2-call-site-parameters" title="Permalink to this headline">¶</a></h5>
<ol class="arabic">
<li><p>A <code class="docutils literal notranslate"><span class="pre">DW_TAG_call_site_parameter</span></code> debugger information entry may have a
<code class="docutils literal notranslate"><span class="pre">DW_AT_call_value</span></code> attribute, whose value is a DWARF operation expression
E<sub>1</sub>.</p>
<p>The result of the <code class="docutils literal notranslate"><span class="pre">DW_AT_call_value</span></code> attribute is obtained by evaluating
E<sub>1</sub> with a context that has a result kind of a value, an unspecified
object, the compilation unit that contains E, an empty initial stack, and
other context elements corresponding to the source language thread of
execution upon which the user is focused, if any. The resulting value V<sub>1</sub> is the value of the parameter at the time of the call made by the
call site.</p>
<p>For parameters passed by reference, where the code passes a pointer to a
location which contains the parameter, or for reference type parameters, the
<code class="docutils literal notranslate"><span class="pre">DW_TAG_call_site_parameter</span></code> debugger information entry may also have a
<code class="docutils literal notranslate"><span class="pre">DW_AT_call_data_location</span></code> attribute whose value is a DWARF operation
expression E<sub>2</sub>, and a <code class="docutils literal notranslate"><span class="pre">DW_AT_call_data_value</span></code> attribute whose
value is a DWARF operation expression E<sub>3</sub>.</p>
<p>The value of the <code class="docutils literal notranslate"><span class="pre">DW_AT_call_data_location</span></code> attribute is obtained by
evaluating E<sub>2</sub> with a context that has a result kind of a location
description, an unspecified object, the compilation unit that contains E, an
empty initial stack, and other context elements corresponding to the source
language thread of execution upon which the user is focused, if any. The
resulting location description L<sub>2</sub> is the location where the
referenced parameter lives during the call made by the call site. If E<sub>2</sub> would just be a <code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code>, then the
<code class="docutils literal notranslate"><span class="pre">DW_AT_call_data_location</span></code> attribute may be omitted.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The DWARF Version 5 implies that <cite>DW_OP_push_object_address</cite> may be used
but does not state what object must be specified in the context. Either
<cite>DW_OP_push_object_address</cite> cannot be used, or the object to be passed in
the context must be defined.</p>
</div>
<p>The value of the <code class="docutils literal notranslate"><span class="pre">DW_AT_call_data_value</span></code> attribute is obtained by
evaluating E<sub>3</sub> with a context that has a result kind of a value, an
unspecified object, the compilation unit that contains E, an empty initial
stack, and other context elements corresponding to the source language
thread of execution upon which the user is focused, if any. The resulting
value V<sub>3</sub> is the value in L<sub>2</sub> at the time of the call made
by the call site.</p>
<p>The result of these attributes is undefined if the current call frame is not
for the subprogram containing the <code class="docutils literal notranslate"><span class="pre">DW_TAG_call_site_parameter</span></code> debugger
information entry or the current program location is not for the call site
containing the <code class="docutils literal notranslate"><span class="pre">DW_TAG_call_site_parameter</span></code> debugger information entry in
the current call frame.</p>
<p><em>The consumer may have to virtually unwind to the call site (see</em>
<a class="reference internal" href="#amdgpu-dwarf-call-frame-information"><span class="std std-ref">A.6.4 Call Frame Information</span></a><em>) in order to evaluate these
attributes. This will ensure the source language thread of execution upon
which the user is focused corresponds to the call site needed to evaluate
the expression.</em></p>
<p>If it is not possible to avoid the expressions of these attributes from
accessing registers or memory locations that might be clobbered by the
subprogram being called by the call site, then the associated attribute
should not be provided.</p>
<p><em>The reason for the restriction is that the parameter may need to be
accessed during the execution of the callee. The consumer may virtually
unwind from the called subprogram back to the caller and then evaluate the
attribute expressions. The call frame information (see</em>
<a class="reference internal" href="#amdgpu-dwarf-call-frame-information"><span class="std std-ref">A.6.4 Call Frame Information</span></a><em>) will not be able to restore
registers that have been clobbered, and clobbered memory will no longer have
the value at the time of the call.</em></p>
</li>
</ol>
</div>
</div>
<div class="section" id="a-3-5-lexical-block-entries">
<span id="amdgpu-dwarf-lexical-block-entries"></span><h4><a class="toc-backref" href="#id54">A.3.5 Lexical Block Entries</a><a class="headerlink" href="#a-3-5-lexical-block-entries" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section is the same as DWARF Version 5 section 3.5.</p>
</div>
</div>
</div>
<div class="section" id="a-4-data-object-and-object-list-entries">
<h3><a class="toc-backref" href="#id55">A.4 Data Object and Object List Entries</a><a class="headerlink" href="#a-4-data-object-and-object-list-entries" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section provides changes to existing debugger information entry
attributes. These would be incorporated into the corresponding DWARF Version 5
chapter 4 sections.</p>
</div>
<div class="section" id="a-4-1-data-object-entries">
<h4><a class="toc-backref" href="#id56">A.4.1 Data Object Entries</a><a class="headerlink" href="#a-4-1-data-object-entries" title="Permalink to this headline">¶</a></h4>
<ol class="arabic">
<li><p>Any debugging information entry describing a data object (which includes
variables and parameters) or common blocks may have a <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code>
attribute, whose value is a DWARF expression E.</p>
<p>The result of the attribute is obtained by evaluating E with a context that
has a result kind of a location description, an unspecified object, the
compilation unit that contains E, an empty initial stack, and other context
elements corresponding to the source language thread of execution upon which
the user is focused, if any. The result of the evaluation is the location
description of the base of the data object.</p>
<p>See <a class="reference internal" href="#amdgpu-dwarf-control-flow-operations"><span class="std std-ref">A.2.5.4.2 Control Flow Operations</span></a> for special evaluation rules
used by the <code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> operations.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Delete the description of how the <code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> operations evaluate a
<code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> attribute as that is now described in the operations.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See the discussion about the <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> attribute in the
<code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> operation. Having each attribute only have a single
purpose and single execution semantics seems desirable. It makes it easier
for the consumer that no longer have to track the context. It makes it
easier for the producer as it can rely on a single semantics for each
attribute.</p>
<p>For that reason, limiting the <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> attribute to only
supporting evaluating the location description of an object, and using a
different attribute and encoding class for the evaluation of DWARF
expression <em>procedures</em> on the same operation expression stack seems
desirable.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_const_value</span></code></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Could deprecate using the <code class="docutils literal notranslate"><span class="pre">DW_AT_const_value</span></code> attribute for
<code class="docutils literal notranslate"><span class="pre">DW_TAG_variable</span></code> or <code class="docutils literal notranslate"><span class="pre">DW_TAG_formal_parameter</span></code> debugger information
entries that have been optimized to a constant. Instead,
<code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> could be used with a DWARF expression that produces an
implicit location description now that any location description can be
used within a DWARF expression. This allows the <code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> operations
to be used to push the location description of any variable regardless of
how it is optimized.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="section" id="a-5-type-entries">
<h3><a class="toc-backref" href="#id57">A.5 Type Entries</a><a class="headerlink" href="#a-5-type-entries" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section provides changes to existing debugger information entry
attributes. These would be incorporated into the corresponding DWARF Version 5
chapter 5 sections.</p>
</div>
<div class="section" id="a-5-1-base-type-entries">
<span id="amdgpu-dwarf-base-type-entries"></span><h4><a class="toc-backref" href="#id58">A.5.1 Base Type Entries</a><a class="headerlink" href="#a-5-1-base-type-entries" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following new attribute is added.</p>
</div>
<ol class="arabic">
<li><p>A <code class="docutils literal notranslate"><span class="pre">DW_TAG_base_type</span></code> debugger information entry for a base type T may have
a <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_vector_size</span></code> attribute whose value is an integer constant
that is the vector type size N.</p>
<p>The representation of a vector base type is as N contiguous elements, each
one having the representation of a base type T’ that is the same as T
without the <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_vector_size</span></code> attribute.</p>
<p>If a <code class="docutils literal notranslate"><span class="pre">DW_TAG_base_type</span></code> debugger information entry does not have a
<code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_vector_size</span></code> attribute, then the base type is not a vector
type.</p>
<p>The DWARF is ill-formed if N is not greater than 0.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>LLVM has mention of a non-upstreamed debugger information entry that is
intended to support vector types. However, that was not for a base type so
would not be suitable as the type of a stack value entry. But perhaps that
could be replaced by using this attribute.</p>
</div>
</li>
</ol>
</div>
<div class="section" id="a-5-7-structure-union-class-and-interface-type-entries">
<h4><a class="toc-backref" href="#id59">A.5.7 Structure, Union, Class and Interface Type Entries</a><a class="headerlink" href="#a-5-7-structure-union-class-and-interface-type-entries" title="Permalink to this headline">¶</a></h4>
<div class="section" id="a-5-7-3-derived-or-extended-structures-classes-and-interfaces">
<h5><a class="toc-backref" href="#id60">A.5.7.3 Derived or Extended Structures, Classes and Interfaces</a><a class="headerlink" href="#a-5-7-3-derived-or-extended-structures-classes-and-interfaces" title="Permalink to this headline">¶</a></h5>
<ol class="arabic">
<li><p>For a <code class="docutils literal notranslate"><span class="pre">DW_AT_data_member_location</span></code> attribute there are two cases:</p>
<ol class="arabic">
<li><p>If the attribute is an integer constant B, it provides the offset in
bytes from the beginning of the containing entity.</p>
<p>The result of the attribute is obtained by evaluating a
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset</span> <span class="pre">B</span></code> operation with an initial stack comprising the
location description of the beginning of the containing entity.  The
result of the evaluation is the location description of the base of the
member entry.</p>
<p><em>If the beginning of the containing entity is not byte aligned, then the
beginning of the member entry has the same bit displacement within a
byte.</em></p>
</li>
<li><p>Otherwise, the attribute must be a DWARF expression E which is evaluated
with a context that has a result kind of a location description, an
unspecified object, the compilation unit that contains E, an initial
stack comprising the location description of the beginning of the
containing entity, and other context elements corresponding to the
source language thread of execution upon which the user is focused, if
any. The result of the evaluation is the location description of the
base of the member entry.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The beginning of the containing entity can now be any location
description, including those with more than one single location
description, and those with single location descriptions that are of any
kind and have any bit offset.</p>
</div>
</li>
</ol>
</div>
<div class="section" id="a-5-7-8-member-function-entries">
<h5><a class="toc-backref" href="#id61">A.5.7.8 Member Function Entries</a><a class="headerlink" href="#a-5-7-8-member-function-entries" title="Permalink to this headline">¶</a></h5>
<ol class="arabic">
<li><p>An entry for a virtual function also has a <code class="docutils literal notranslate"><span class="pre">DW_AT_vtable_elem_location</span></code>
attribute whose value is a DWARF expression E.</p>
<p>The result of the attribute is obtained by evaluating E with a context that
has a result kind of a location description, an unspecified object, the
compilation unit that contains E, an initial stack comprising the location
description of the object of the enclosing type, and other context elements
corresponding to the source language thread of execution upon which the user
is focused, if any. The result of the evaluation is the location description
of the slot for the function within the virtual function table for the
enclosing class.</p>
</li>
</ol>
</div>
</div>
<div class="section" id="a-5-14-pointer-to-member-type-entries">
<h4><a class="toc-backref" href="#id62">A.5.14 Pointer to Member Type Entries</a><a class="headerlink" href="#a-5-14-pointer-to-member-type-entries" title="Permalink to this headline">¶</a></h4>
<ol class="arabic">
<li><p>The <code class="docutils literal notranslate"><span class="pre">DW_TAG_ptr_to_member_type</span></code> debugging information entry has a
<code class="docutils literal notranslate"><span class="pre">DW_AT_use_location</span></code> attribute whose value is a DWARF expression E. It is
used to compute the location description of the member of the class to which
the pointer to member entry points.</p>
<p><em>The method used to find the location description of a given member of a
class, structure, or union is common to any instance of that class,
structure, or union and to any instance of the pointer to member type. The
method is thus associated with the pointer to member type, rather than with
each object that has a pointer to member type.</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_AT_use_location</span></code> DWARF expression is used in conjunction with the
location description for a particular object of the given pointer to member
type and for a particular structure or class instance.</p>
<p>The result of the attribute is obtained by evaluating E with a context that
has a result kind of a location description, an unspecified object, the
compilation unit that contains E, an initial stack comprising two entries,
and other context elements corresponding to the source language thread of
execution upon which the user is focused, if any. The first stack entry is
the value of the pointer to member object itself. The second stack entry is
the location description of the base of the entire class, structure, or
union instance containing the member whose location is being calculated. The
result of the evaluation is the location description of the member of the
class to which the pointer to member entry points.</p>
</li>
</ol>
</div>
<div class="section" id="a-5-16-dynamic-type-entries">
<h4><a class="toc-backref" href="#id63">A.5.16 Dynamic Type Entries</a><a class="headerlink" href="#a-5-16-dynamic-type-entries" title="Permalink to this headline">¶</a></h4>
<ol class="arabic">
<li><p>The <code class="docutils literal notranslate"><span class="pre">DW_AT_data_location</span></code> attribute may be used with any type that
provides one or more levels of hidden indirection and/or run-time parameters
in its representation. Its value is a DWARF operation expression E which
computes the location description of the data for an object. When this
attribute is omitted, the location description of the data is the same as
the location description of the object.</p>
<p>The result of the attribute is obtained by evaluating E with a context that
has a result kind of a location description, an object that is the location
description of the data descriptor, the compilation unit that contains E, an
empty initial stack, and other context elements corresponding to the source
language thread of execution upon which the user is focused, if any. The
result of the evaluation is the location description of the base of the
member entry.</p>
<p><em>E will typically involve an operation expression that begins with a</em>
<code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code> <em>operation which loads the location
description of the object which can then serve as a descriptor in subsequent
calculation.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since <code class="docutils literal notranslate"><span class="pre">DW_AT_data_member_location</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_AT_use_location</span></code>, and
<code class="docutils literal notranslate"><span class="pre">DW_AT_vtable_elem_location</span></code> allow both operation expressions and
location list expressions, why does <code class="docutils literal notranslate"><span class="pre">DW_AT_data_location</span></code> not allow
both? In all cases they apply to data objects so less likely that
optimization would cause different operation expressions for different
program location ranges. But if supporting for some then should be for
all.</p>
<p>It seems odd this attribute is not the same as
<code class="docutils literal notranslate"><span class="pre">DW_AT_data_member_location</span></code> in having an initial stack with the
location description of the object since the expression has to need it.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="section" id="a-6-other-debugging-information">
<h3><a class="toc-backref" href="#id64">A.6 Other Debugging Information</a><a class="headerlink" href="#a-6-other-debugging-information" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section provides changes to existing debugger information entry
attributes. These would be incorporated into the corresponding DWARF Version 5
chapter 6 sections.</p>
</div>
<div class="section" id="a-6-1-accelerated-access">
<h4><a class="toc-backref" href="#id65">A.6.1 Accelerated Access</a><a class="headerlink" href="#a-6-1-accelerated-access" title="Permalink to this headline">¶</a></h4>
<div class="section" id="a-6-1-1-lookup-by-name">
<span id="amdgpu-dwarf-lookup-by-name"></span><h5><a class="toc-backref" href="#id66">A.6.1.1 Lookup By Name</a><a class="headerlink" href="#a-6-1-1-lookup-by-name" title="Permalink to this headline">¶</a></h5>
<div class="section" id="a-6-1-1-1-contents-of-the-name-index">
<h6><a class="toc-backref" href="#id67">A.6.1.1.1 Contents of the Name Index</a><a class="headerlink" href="#a-6-1-1-1-contents-of-the-name-index" title="Permalink to this headline">¶</a></h6>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following provides changes to DWARF Version 5 section 6.1.1.1.</p>
<p>The rule for debugger information entries included in the name index in the
optional <code class="docutils literal notranslate"><span class="pre">.debug_names</span></code> section is extended to also include named
<code class="docutils literal notranslate"><span class="pre">DW_TAG_variable</span></code> debugging information entries with a <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code>
attribute that includes a <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code> operation.</p>
</div>
<p>The name index must contain an entry for each debugging information entry that
defines a named subprogram, label, variable, type, or namespace, subject to the
following rules:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_TAG_variable</span></code> debugging information entries with a <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code>
attribute that includes a <code class="docutils literal notranslate"><span class="pre">DW_OP_addr</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code>,
or <code class="docutils literal notranslate"><span class="pre">DW_OP_form_tls_address</span></code> operation are included; otherwise, they are
excluded.</p></li>
</ul>
</div>
<div class="section" id="a-6-1-1-4-data-representation-of-the-name-index">
<h6><a class="toc-backref" href="#id68">A.6.1.1.4 Data Representation of the Name Index</a><a class="headerlink" href="#a-6-1-1-4-data-representation-of-the-name-index" title="Permalink to this headline">¶</a></h6>
<div class="section" id="a-6-1-1-4-1-section-header">
<span id="amdgpu-dwarf-name-index-section-header"></span><h7><a class="toc-backref" href="#id69">A.6.1.1.4.1 Section Header</a><a class="headerlink" href="#a-6-1-1-4-1-section-header" title="Permalink to this headline">¶</a></h7>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following provides an addition to DWARF Version 5 section 6.1.1.4.1 item
14 <code class="docutils literal notranslate"><span class="pre">augmentation_string</span></code>.</p>
</div>
<p>A null-terminated UTF-8 vendor specific augmentation string, which provides
additional information about the contents of this index. If provided, the
recommended format for augmentation string is:</p>
<blockquote>
<div><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">[</span></code><em>vendor</em><code class="docutils literal notranslate"><span class="pre">:v</span></code><em>X</em><code class="docutils literal notranslate"><span class="pre">.</span></code><em>Y</em>[<code class="docutils literal notranslate"><span class="pre">:</span></code><em>options</em>]<code class="docutils literal notranslate"><span class="pre">]</span></code>*</div>
</div>
</div></blockquote>
<p>Where <em>vendor</em> is the producer, <code class="docutils literal notranslate"><span class="pre">vX.Y</span></code> specifies the major X and minor Y
version number of the extensions used in the DWARF of the compilation unit, and
<em>options</em> is an optional string providing additional information about the
extensions. The version number must conform to semantic versioning [<a class="reference internal" href="#amdgpu-dwarf-semver"><span class="std std-ref">SEMVER</span></a>]. The <em>options</em> string must not contain the “<code class="docutils literal notranslate"><span class="pre">]</span></code>”
character.</p>
<p>For example:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">abc</span><span class="p">:</span><span class="n">v0</span><span class="mf">.0</span><span class="p">][</span><span class="n">def</span><span class="p">:</span><span class="n">v1</span><span class="mf">.2</span><span class="p">:</span><span class="n">feature</span><span class="o">-</span><span class="n">a</span><span class="o">=</span><span class="n">on</span><span class="p">,</span><span class="n">feature</span><span class="o">-</span><span class="n">b</span><span class="o">=</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is different to the definition in DWARF Version 5 but is consistent with
the other augmentation strings and allows multiple vendor extensions to be
supported.</p>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="a-6-2-line-number-information">
<span id="amdgpu-dwarf-line-number-information"></span><h4><a class="toc-backref" href="#id70">A.6.2 Line Number Information</a><a class="headerlink" href="#a-6-2-line-number-information" title="Permalink to this headline">¶</a></h4>
<div class="section" id="a-6-2-4-the-line-number-program-header">
<h5><a class="toc-backref" href="#id71">A.6.2.4 The Line Number Program Header</a><a class="headerlink" href="#a-6-2-4-the-line-number-program-header" title="Permalink to this headline">¶</a></h5>
<div class="section" id="a-6-2-4-1-standard-content-descriptions">
<h6><a class="toc-backref" href="#id72">A.6.2.4.1 Standard Content Descriptions</a><a class="headerlink" href="#a-6-2-4-1-standard-content-descriptions" title="Permalink to this headline">¶</a></h6>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This augments DWARF Version 5 section 6.2.4.1.</p>
</div>
<ol class="arabic" id="amdgpu-dwarf-line-number-information-dw-lnct-llvm-source">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_LNCT_LLVM_source</span></code></p>
<p>The component is a null-terminated UTF-8 source text string with “<code class="docutils literal notranslate"><span class="pre">\n</span></code>” line endings. This content code is paired with the same forms as
<code class="docutils literal notranslate"><span class="pre">DW_LNCT_path</span></code>. It can be used for file name entries.</p>
<p>The value is an empty null-terminated string if no source is available. If
the source is available but is an empty file then the value is a
null-terminated single “<code class="docutils literal notranslate"><span class="pre">\n</span></code>“.</p>
<p><em>When the source field is present, consumers can use the embedded source
instead of attempting to discover the source on disk using the file path
provided by the</em> <code class="docutils literal notranslate"><span class="pre">DW_LNCT_path</span></code> <em>field. When the source field is absent,
consumers can access the file to get the source text.</em></p>
<p><em>This is particularly useful for programming languages that support runtime
compilation and runtime generation of source text. In these cases, the
source text does not reside in any permanent file. For example, the OpenCL
language [:ref:`OpenCL &lt;amdgpu-dwarf-OpenCL&gt;`] supports online compilation.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_LNCT_LLVM_is_MD5</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_LNCT_LLVM_is_MD5</span></code> indicates if the <code class="docutils literal notranslate"><span class="pre">DW_LNCT_MD5</span></code> content kind, if
present, is valid: when 0 it is not valid and when 1 it is valid. If
<code class="docutils literal notranslate"><span class="pre">DW_LNCT_LLVM_is_MD5</span></code> content kind is not present, and <code class="docutils literal notranslate"><span class="pre">DW_LNCT_MD5</span></code>
content kind is present, then the MD5 checksum is valid.</p>
<p><code class="docutils literal notranslate"><span class="pre">DW_LNCT_LLVM_is_MD5</span></code> is always paired with the <code class="docutils literal notranslate"><span class="pre">DW_FORM_udata</span></code> form.</p>
<p><em>This allows a compilation unit to have a mixture of files with and without
MD5 checksums. This can happen when multiple relocatable files are linked
together.</em></p>
</li>
</ol>
</div>
</div>
</div>
<div class="section" id="a-6-4-call-frame-information">
<span id="amdgpu-dwarf-call-frame-information"></span><h4><a class="toc-backref" href="#id73">A.6.4 Call Frame Information</a><a class="headerlink" href="#a-6-4-call-frame-information" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section provides changes to existing call frame information and defines
instructions added by these extensions. Additional support is added for
address spaces. Register unwind DWARF expressions are generalized to allow any
location description, including those with composite and implicit location
descriptions.</p>
<p>These changes would be incorporated into the DWARF Version 5 section 6.4.</p>
</div>
<div class="section" id="a-6-4-1-structure-of-call-frame-information">
<span id="amdgpu-dwarf-structure-of-call-frame-information"></span><h5><a class="toc-backref" href="#id74">A.6.4.1 Structure of Call Frame Information</a><a class="headerlink" href="#a-6-4-1-structure-of-call-frame-information" title="Permalink to this headline">¶</a></h5>
<p>The register rules are:</p>
<dl>
<dt><em>undefined</em></dt><dd><p>A register that has this rule has no recoverable value in the previous frame.
The previous value of this register is the undefined location description (see
<a class="reference internal" href="#amdgpu-dwarf-undefined-location-description-operations"><span class="std std-ref">A.2.5.4.4.2 Undefined Location Description Operations</span></a>).</p>
<p><em>By convention, the register is not preserved by a callee.</em></p>
</dd>
<dt><em>same value</em></dt><dd><p>This register has not been modified from the previous caller frame.</p>
<p>If the current frame is the top frame, then the previous value of this
register is the location description L that specifies one register location
description SL. SL specifies the register location storage that corresponds to
the register with a bit offset of 0 for the current thread.</p>
<p>If the current frame is not the top frame, then the previous value of this
register is the location description obtained using the call frame information
for the callee frame and callee program location invoked by the current caller
frame for the same register.</p>
<p><em>By convention, the register is preserved by the callee, but the callee has
not modified it.</em></p>
</dd>
<dt><em>offset(N)</em></dt><dd><p>N is a signed byte offset. The previous value of this register is saved at the
location description computed as if the DWARF operation expression
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset</span> <span class="pre">N</span></code> is evaluated with the current context, except the
result kind is a location description, the compilation unit is unspecified,
the object is unspecified, and an initial stack comprising the location
description of the current CFA (see
<a class="reference internal" href="#amdgpu-dwarf-operation-expressions"><span class="std std-ref">A.2.5.4 DWARF Operation Expressions</span></a>).</p>
</dd>
<dt><em>val_offset(N)</em></dt><dd><p>N is a signed byte offset. The previous value of this register is the memory
byte address of the location description computed as if the DWARF operation
expression <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset</span> <span class="pre">N</span></code> is evaluated with the current context,
except the result kind is a location description, the compilation unit is
unspecified, the object is unspecified, and an initial stack comprising the
location description of the current CFA (see
<a class="reference internal" href="#amdgpu-dwarf-operation-expressions"><span class="std std-ref">A.2.5.4 DWARF Operation Expressions</span></a>).</p>
<p>The DWARF is ill-formed if the CFA location description is not a memory byte
address location description, or if the register size does not match the size
of an address in the address space of the current CFA location description.</p>
<p><em>Since the CFA location description is required to be a memory byte address
location description, the value of val_offset(N) will also be a memory byte
address location description since it is offsetting the CFA location
description by N bytes. Furthermore, the value of val_offset(N) will be a
memory byte address in the same address space as the CFA location
description.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Should DWARF allow the address size to be a different size to the size of
the register? Requiring them to be the same bit size avoids any issue of
conversion as the bit contents of the register is simply interpreted as a
value of the address.</p>
<p>GDB has a per register hook that allows a target specific conversion on a
register by register basis. It defaults to truncation of bigger registers,
and to actually reading bytes from the next register (or reads out of bounds
for the last register) for smaller registers. There are no GDB tests that
read a register out of bounds (except an illegal hand written assembly
test).</p>
</div>
</dd>
<dt><em>register(R)</em></dt><dd><p>This register has been stored in another register numbered R.</p>
<p>The previous value of this register is the location description obtained using
the call frame information for the current frame and current program location
for register R.</p>
<p>The DWARF is ill-formed if the size of this register does not match the size
of register R or if there is a cyclic dependency in the call frame
information.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Should this also allow R to be larger than this register? If so is the value
stored in the low order bits and it is undefined what is stored in the
extra upper bits?</p>
</div>
</dd>
<dt><em>expression(E)</em></dt><dd><p>The previous value of this register is located at the location description
produced by evaluating the DWARF operation expression E (see
<a class="reference internal" href="#amdgpu-dwarf-operation-expressions"><span class="std std-ref">A.2.5.4 DWARF Operation Expressions</span></a>).</p>
<p>E is evaluated with the current context, except the result kind is a location
description, the compilation unit is unspecified, the object is unspecified,
and an initial stack comprising the location description of the current CFA
(see <a class="reference internal" href="#amdgpu-dwarf-operation-expressions"><span class="std std-ref">A.2.5.4 DWARF Operation Expressions</span></a>).</p>
</dd>
<dt><em>val_expression(E)</em></dt><dd><p>The previous value of this register is the value produced by evaluating the
DWARF operation expression E (see <a class="reference internal" href="#amdgpu-dwarf-operation-expressions"><span class="std std-ref">A.2.5.4 DWARF Operation Expressions</span></a>).</p>
<p>E is evaluated with the current context, except the result kind is a value,
the compilation unit is unspecified, the object is unspecified, and an initial
stack comprising the location description of the current CFA (see
<a class="reference internal" href="#amdgpu-dwarf-operation-expressions"><span class="std std-ref">A.2.5.4 DWARF Operation Expressions</span></a>).</p>
<p>The DWARF is ill-formed if the resulting value type size does not match the
register size.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This has limited usefulness as the DWARF expression E can only produce
values up to the size of the generic type. This is due to not allowing any
operations that specify a type in a CFI operation expression. This makes it
unusable for registers that are larger than the generic type. However,
<em>expression(E)</em> can be used to create an implicit location description of
any size.</p>
</div>
</dd>
<dt><em>architectural</em></dt><dd><p>The rule is defined externally to this specification by the augmenter.</p>
</dd>
</dl>
<p>A Common Information Entry (CIE) holds information that is shared among many
Frame Description Entries (FDE). There is at least one CIE in every non-empty
<code class="docutils literal notranslate"><span class="pre">.debug_frame</span></code> section. A CIE contains the following fields, in order:</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">length</span></code> (initial length)</p>
<p>A constant that gives the number of bytes of the CIE structure, not
including the length field itself. The size of the length field plus the
value of length must be an integral multiple of the address size specified
in the <code class="docutils literal notranslate"><span class="pre">address_size</span></code> field.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">CIE_id</span></code> (4 or 8 bytes, see
<a class="reference internal" href="#amdgpu-dwarf-32-bit-and-64-bit-dwarf-formats"><span class="std std-ref">A.7.4 32-Bit and 64-Bit DWARF Formats</span></a>)</p>
<p>A constant that is used to distinguish CIEs from FDEs.</p>
<p>In the 32-bit DWARF format, the value of the CIE id in the CIE header is
0xffffffff; in the 64-bit DWARF format, the value is 0xffffffffffffffff.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">version</span></code> (ubyte)</p>
<p>A version number. This number is specific to the call frame information and
is independent of the DWARF version number.</p>
<p>The value of the CIE version number is 4.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Would this be increased to 5 to reflect the changes in these extensions?</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">augmentation</span></code> (sequence of UTF-8 characters)</p>
<p>A null-terminated UTF-8 string that identifies the augmentation to this CIE
or to the FDEs that use it. If a reader encounters an augmentation string
that is unexpected, then only the following fields can be read:</p>
<ul class="simple">
<li><p>CIE: length, CIE_id, version, augmentation</p></li>
<li><p>FDE: length, CIE_pointer, initial_location, address_range</p></li>
</ul>
<p>If there is no augmentation, this value is a zero byte.</p>
<p><em>The augmentation string allows users to indicate that there is additional
vendor and target architecture specific information in the CIE or FDE which
is needed to virtually unwind a stack frame. For example, this might be
information about dynamically allocated data which needs to be freed on exit
from the routine.</em></p>
<p><em>Because the</em> <code class="docutils literal notranslate"><span class="pre">.debug_frame</span></code> <em>section is useful independently of any</em>
<code class="docutils literal notranslate"><span class="pre">.debug_info</span></code> <em>section, the augmentation string always uses UTF-8
encoding.</em></p>
<p>The recommended format for the augmentation string is:</p>
<blockquote>
<div><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">[</span></code><em>vendor</em><code class="docutils literal notranslate"><span class="pre">:v</span></code><em>X</em><code class="docutils literal notranslate"><span class="pre">.</span></code><em>Y</em>[<code class="docutils literal notranslate"><span class="pre">:</span></code><em>options</em>]<code class="docutils literal notranslate"><span class="pre">]</span></code>*</div>
</div>
</div></blockquote>
<p>Where <em>vendor</em> is the producer, <code class="docutils literal notranslate"><span class="pre">vX.Y</span></code> specifies the major X and minor Y
version number of the extensions used, and <em>options</em> is an optional string
providing additional information about the extensions. The version number
must conform to semantic versioning [<a class="reference internal" href="#amdgpu-dwarf-semver"><span class="std std-ref">SEMVER</span></a>].
The <em>options</em> string must not contain the “<code class="docutils literal notranslate"><span class="pre">]</span></code>” character.</p>
<p>For example:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">abc</span><span class="p">:</span><span class="n">v0</span><span class="mf">.0</span><span class="p">][</span><span class="n">def</span><span class="p">:</span><span class="n">v1</span><span class="mf">.2</span><span class="p">:</span><span class="n">feature</span><span class="o">-</span><span class="n">a</span><span class="o">=</span><span class="n">on</span><span class="p">,</span><span class="n">feature</span><span class="o">-</span><span class="n">b</span><span class="o">=</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">address_size</span></code> (ubyte)</p>
<p>The size of a target address in this CIE and any FDEs that use it, in bytes.
If a compilation unit exists for this frame, its address size must match the
address size here.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">segment_selector_size</span></code> (ubyte)</p>
<p>The size of a segment selector in this CIE and any FDEs that use it, in
bytes.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">code_alignment_factor</span></code> (unsigned LEB128)</p>
<p>A constant that is factored out of all advance location instructions (see
<a class="reference internal" href="#amdgpu-dwarf-row-creation-instructions"><span class="std std-ref">A.6.4.2.1 Row Creation Instructions</span></a>). The resulting value is
<code class="docutils literal notranslate"><span class="pre">(operand</span> <span class="pre">*</span> <span class="pre">code_alignment_factor)</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">data_alignment_factor</span></code> (signed LEB128)</p>
<p>A constant that is factored out of certain offset instructions (see
<a class="reference internal" href="#amdgpu-dwarf-cfa-definition-instructions"><span class="std std-ref">A.6.4.2.2 CFA Definition Instructions</span></a> and
<a class="reference internal" href="#amdgpu-dwarf-register-rule-instructions"><span class="std std-ref">A.6.4.2.3 Register Rule Instructions</span></a>). The resulting value is
<code class="docutils literal notranslate"><span class="pre">(operand</span> <span class="pre">*</span> <span class="pre">data_alignment_factor)</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">return_address_register</span></code> (unsigned LEB128)</p>
<p>An unsigned LEB128 constant that indicates which column in the rule table
represents the return address of the subprogram. Note that this column might
not correspond to an actual machine register.</p>
<p>The value of the return address register is used to determine the program
location of the caller frame. The program location of the top frame is the
target architecture program counter value of the current thread.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_instructions</span></code> (array of ubyte)</p>
<p>A sequence of rules that are interpreted to create the initial setting of
each column in the table.</p>
<p>The default rule for all columns before interpretation of the initial
instructions is the undefined rule. However, an ABI authoring body or a
compilation system authoring body may specify an alternate default value for
any or all columns.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">padding</span></code> (array of ubyte)</p>
<p>Enough <code class="docutils literal notranslate"><span class="pre">DW_CFA_nop</span></code> instructions to make the size of this entry match the
length value above.</p>
</li>
</ol>
<p>An FDE contains the following fields, in order:</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">length</span></code> (initial length)</p>
<p>A constant that gives the number of bytes of the header and instruction
stream for this subprogram, not including the length field itself. The size
of the length field plus the value of length must be an integral multiple of
the address size.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">CIE_pointer</span></code> (4 or 8 bytes, see
<a class="reference internal" href="#amdgpu-dwarf-32-bit-and-64-bit-dwarf-formats"><span class="std std-ref">A.7.4 32-Bit and 64-Bit DWARF Formats</span></a>)</p>
<p>A constant offset into the <code class="docutils literal notranslate"><span class="pre">.debug_frame</span></code> section that denotes the CIE
that is associated with this FDE.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_location</span></code> (segment selector and target address)</p>
<p>The address of the first location associated with this table entry. If the
segment_selector_size field of this FDE’s CIE is non-zero, the initial
location is preceded by a segment selector of the given length.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">address_range</span></code> (target address)</p>
<p>The number of bytes of program instructions described by this entry.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">instructions</span></code> (array of ubyte)</p>
<p>A sequence of table defining instructions that are described in
<a class="reference internal" href="#amdgpu-dwarf-call-frame-instructions"><span class="std std-ref">A.6.4.2 Call Frame Instructions</span></a>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">padding</span></code> (array of ubyte)</p>
<p>Enough <code class="docutils literal notranslate"><span class="pre">DW_CFA_nop</span></code> instructions to make the size of this entry match the
length value above.</p>
</li>
</ol>
</div>
<div class="section" id="a-6-4-2-call-frame-instructions">
<span id="amdgpu-dwarf-call-frame-instructions"></span><h5><a class="toc-backref" href="#id75">A.6.4.2 Call Frame Instructions</a><a class="headerlink" href="#a-6-4-2-call-frame-instructions" title="Permalink to this headline">¶</a></h5>
<p>Some call frame instructions have operands that are encoded as DWARF operation
expressions E (see <a class="reference internal" href="#amdgpu-dwarf-operation-expressions"><span class="std std-ref">A.2.5.4 DWARF Operation Expressions</span></a>). The DWARF
operations that can be used in E have the following restrictions:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_addrx</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_call2</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_call4</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_call_ref</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_OP_const_type</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_constx</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_convert</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_OP_deref_type</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_fbreg</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_OP_regval_type</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_reinterpret</span></code>, and <code class="docutils literal notranslate"><span class="pre">DW_OP_xderef_type</span></code>
operations are not allowed because the call frame information must not depend
on other debug sections.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code> is not allowed because there is no object
context to provide a value to push.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_push_lane</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_push_iteration</span></code> are not allowed
because the call frame instructions describe the actions for the whole target
architecture thread, not the lanes or iterations independently.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_call_frame_cfa</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_OP_entry_value</span></code> are not allowed because
their use would be circular.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_call_frame_entry_reg</span></code> is not allowed if evaluating E causes a
circular dependency between <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_call_frame_entry_reg</span></code> operations.</p>
<p><em>For example, if a register R1 has a</em> <code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_expression</span></code>
<em>instruction that evaluates a</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_call_frame_entry_reg</span></code> <em>operation
that specifies register R2, and register R2 has a</em>
<code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_expression</span></code> <em>instruction that that evaluates a</em>
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_call_frame_entry_reg</span></code> <em>operation that specifies register R1.</em></p>
</li>
</ul>
<p><em>Call frame instructions to which these restrictions apply include</em>
<code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_expression</span></code><em>,</em> <code class="docutils literal notranslate"><span class="pre">DW_CFA_expression</span></code><em>, and</em>
<code class="docutils literal notranslate"><span class="pre">DW_CFA_val_expression</span></code><em>.</em></p>
<div class="section" id="a-6-4-2-1-row-creation-instructions">
<span id="amdgpu-dwarf-row-creation-instructions"></span><h6><a class="toc-backref" href="#id76">A.6.4.2.1 Row Creation Instructions</a><a class="headerlink" href="#a-6-4-2-1-row-creation-instructions" title="Permalink to this headline">¶</a></h6>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These instructions are the same as in DWARF Version 5 section 6.4.2.1.</p>
</div>
</div>
<div class="section" id="a-6-4-2-2-cfa-definition-instructions">
<span id="amdgpu-dwarf-cfa-definition-instructions"></span><h6><a class="toc-backref" href="#id77">A.6.4.2.2 CFA Definition Instructions</a><a class="headerlink" href="#a-6-4-2-2-cfa-definition-instructions" title="Permalink to this headline">¶</a></h6>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa</span></code> instruction takes two unsigned LEB128 operands
representing a register number R and a (non-factored) byte displacement B.
AS is set to the target architecture default address space identifier. The
required action is to define the current CFA rule to be the result of
evaluating the DWARF operation expression <code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span> <span class="pre">AS;</span>
<span class="pre">DW_OP_aspace_bregx</span> <span class="pre">R,</span> <span class="pre">B</span></code> as a location description.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_sf</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_sf</span></code> instruction takes two operands: an unsigned LEB128
value representing a register number R and a signed LEB128 factored byte
displacement B. AS is set to the target architecture default address space
identifier. The required action is to define the current CFA rule to be the
result of evaluating the DWARF operation expression <code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span> <span class="pre">AS;</span>
<span class="pre">DW_OP_aspace_bregx</span> <span class="pre">R,</span> <span class="pre">B</span> <span class="pre">*</span> <span class="pre">data_alignment_factor</span></code> as a location description.</p>
<p><em>The action is the same as</em> <code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa</span></code><em>, except that the second
operand is signed and factored.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_LLVM_def_aspace_cfa</span></code> <em>New</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_LLVM_def_aspace_cfa</span></code> instruction takes three unsigned LEB128
operands representing a register number R, a (non-factored) byte
displacement B, and a target architecture specific address space identifier
AS. The required action is to define the current CFA rule to be the result
of evaluating the DWARF operation expression <code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span> <span class="pre">AS;</span>
<span class="pre">DW_OP_aspace_bregx</span> <span class="pre">R,</span> <span class="pre">B</span></code> as a location description.</p>
<p>If AS is not one of the values defined by the target architecture specific
<code class="docutils literal notranslate"><span class="pre">DW_ASPACE_*</span></code> values then the DWARF expression is ill-formed.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_LLVM_def_aspace_cfa_sf</span></code> <em>New</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_sf</span></code> instruction takes three operands: an unsigned
LEB128 value representing a register number R, a signed LEB128 factored byte
displacement B, and an unsigned LEB128 value representing a target
architecture specific address space identifier AS. The required action is to
define the current CFA rule to be the result of evaluating the DWARF
operation expression <code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span> <span class="pre">AS;</span> <span class="pre">DW_OP_aspace_bregx</span> <span class="pre">R,</span>
<span class="pre">B</span> <span class="pre">*</span> <span class="pre">data_alignment_factor</span></code> as a location description.</p>
<p>If AS is not one of the values defined by the target architecture specific
<code class="docutils literal notranslate"><span class="pre">DW_ASPACE_*</span></code> values, then the DWARF expression is ill-formed.</p>
<p><em>The action is the same as</em> <code class="docutils literal notranslate"><span class="pre">DW_CFA_aspace_def_cfa</span></code><em>, except that the
second operand is signed and factored.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_register</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_register</span></code> instruction takes a single unsigned LEB128
operand representing a register number R. The required action is to define
the current CFA rule to be the result of evaluating the DWARF operation
expression <code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span> <span class="pre">AS;</span> <span class="pre">DW_OP_aspace_bregx</span> <span class="pre">R,</span> <span class="pre">B</span></code> as a location
description. B and AS are the old CFA byte displacement and address space
respectively.</p>
<p>If the subprogram has no current CFA rule, or the rule was defined by a
<code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_expression</span></code> instruction, then the DWARF is ill-formed.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_offset</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_offset</span></code> instruction takes a single unsigned LEB128
operand representing a (non-factored) byte displacement B. The required
action is to define the current CFA rule to be the result of evaluating the
DWARF operation expression <code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span> <span class="pre">AS;</span> <span class="pre">DW_OP_aspace_bregx</span> <span class="pre">R,</span> <span class="pre">B</span></code> as a
location description. R and AS are the old CFA register number and address
space respectively.</p>
<p>If the subprogram has no current CFA rule, or the rule was defined by a
<code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_expression</span></code> instruction, then the DWARF is ill-formed.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_offset_sf</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_offset_sf</span></code> instruction takes a signed LEB128 operand
representing a factored byte displacement B. The required action is to
define the current CFA rule to be the result of evaluating the DWARF
operation expression <code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span> <span class="pre">AS;</span> <span class="pre">DW_OP_aspace_bregx</span> <span class="pre">R,</span> <span class="pre">B</span> <span class="pre">*</span>
<span class="pre">data_alignment_factor</span></code> as a location description. R and AS are the old CFA
register number and address space respectively.</p>
<p>If the subprogram has no current CFA rule, or the rule was defined by a
<code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_expression</span></code> instruction, then the DWARF is ill-formed.</p>
<p><em>The action is the same as</em> <code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_offset</span></code><em>, except that the
operand is signed and factored.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_expression</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_expression</span></code> instruction takes a single operand encoded
as a <code class="docutils literal notranslate"><span class="pre">DW_FORM_exprloc</span></code> value representing a DWARF operation expression E.
The required action is to define the current CFA rule to be the result of
evaluating E with the current context, except the result kind is a location
description, the compilation unit is unspecified, the object is unspecified,
and an empty initial stack.</p>
<p><em>See</em> <a class="reference internal" href="#amdgpu-dwarf-call-frame-instructions"><span class="std std-ref">A.6.4.2 Call Frame Instructions</span></a> <em>regarding restrictions on
the DWARF expression operations that can be used in E.</em></p>
<p>The DWARF is ill-formed if the result of evaluating E is not a memory byte
address location description.</p>
</li>
</ol>
</div>
<div class="section" id="a-6-4-2-3-register-rule-instructions">
<span id="amdgpu-dwarf-register-rule-instructions"></span><h6><a class="toc-backref" href="#id78">A.6.4.2.3 Register Rule Instructions</a><a class="headerlink" href="#a-6-4-2-3-register-rule-instructions" title="Permalink to this headline">¶</a></h6>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_undefined</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_undefined</span></code> instruction takes a single unsigned LEB128 operand
that represents a register number R. The required action is to set the rule
for the register specified by R to <code class="docutils literal notranslate"><span class="pre">undefined</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_same_value</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_same_value</span></code> instruction takes a single unsigned LEB128 operand
that represents a register number R. The required action is to set the rule
for the register specified by R to <code class="docutils literal notranslate"><span class="pre">same</span> <span class="pre">value</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_offset</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_offset</span></code> instruction takes two operands: a register number R
(encoded with the opcode) and an unsigned LEB128 constant representing a
factored displacement B. The required action is to change the rule for the
register specified by R to be an <em>offset(B * data_alignment_factor)</em> rule.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Seems this should be named <code class="docutils literal notranslate"><span class="pre">DW_CFA_offset_uf</span></code> since the offset is
unsigned factored.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_offset_extended</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_offset_extended</span></code> instruction takes two unsigned LEB128
operands representing a register number R and a factored displacement B.
This instruction is identical to <code class="docutils literal notranslate"><span class="pre">DW_CFA_offset</span></code>, except for the encoding
and size of the register operand.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Seems this should be named <code class="docutils literal notranslate"><span class="pre">DW_CFA_offset_extended_uf</span></code> since the
displacement is unsigned factored.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_offset_extended_sf</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_offset_extended_sf</span></code> instruction takes two operands: an
unsigned LEB128 value representing a register number R and a signed LEB128
factored displacement B. This instruction is identical to
<code class="docutils literal notranslate"><span class="pre">DW_CFA_offset_extended</span></code>, except that B is signed.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_val_offset</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_val_offset</span></code> instruction takes two unsigned LEB128 operands
representing a register number R and a factored displacement B. The required
action is to change the rule for the register indicated by R to be a
<em>val_offset(B * data_alignment_factor)</em> rule.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Seems this should be named <code class="docutils literal notranslate"><span class="pre">DW_CFA_val_offset_uf</span></code> since the displacement
is unsigned factored.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An alternative is to define <code class="docutils literal notranslate"><span class="pre">DW_CFA_val_offset</span></code> to implicitly use the
target architecture default address space, and add another operation that
specifies the address space.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_val_offset_sf</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_val_offset_sf</span></code> instruction takes two operands: an unsigned
LEB128 value representing a register number R and a signed LEB128 factored
displacement B. This instruction is identical to <code class="docutils literal notranslate"><span class="pre">DW_CFA_val_offset</span></code>,
except that B is signed.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_register</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_register</span></code> instruction takes two unsigned LEB128 operands
representing register numbers R1 and R2 respectively. The required action is
to set the rule for the register specified by R1 to be a <em>register(R2)</em> rule.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_expression</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_expression</span></code> instruction takes two operands: an unsigned LEB128
value representing a register number R, and a <code class="docutils literal notranslate"><span class="pre">DW_FORM_block</span></code> value
representing a DWARF operation expression E. The required action is to
change the rule for the register specified by R to be an <em>expression(E)</em>
rule.</p>
<p><em>That is, E computes the location description where the register value can
be retrieved.</em></p>
<p><em>See</em> <a class="reference internal" href="#amdgpu-dwarf-call-frame-instructions"><span class="std std-ref">A.6.4.2 Call Frame Instructions</span></a> <em>regarding restrictions on
the DWARF expression operations that can be used in E.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_val_expression</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_val_expression</span></code> instruction takes two operands: an unsigned
LEB128 value representing a register number R, and a <code class="docutils literal notranslate"><span class="pre">DW_FORM_block</span></code> value
representing a DWARF operation expression E. The required action is to
change the rule for the register specified by R to be a <em>val_expression(E)</em>
rule.</p>
<p><em>That is, E computes the value of register R.</em></p>
<p><em>See</em> <a class="reference internal" href="#amdgpu-dwarf-call-frame-instructions"><span class="std std-ref">A.6.4.2 Call Frame Instructions</span></a> <em>regarding restrictions on
the DWARF expression operations that can be used in E.</em></p>
<p>If the result of evaluating E is not a value with a base type size that
matches the register size, then the DWARF is ill-formed.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_restore</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_restore</span></code> instruction takes a single operand (encoded with the
opcode) that represents a register number R. The required action is to
change the rule for the register specified by R to the rule assigned it by
the <code class="docutils literal notranslate"><span class="pre">initial_instructions</span></code> in the CIE.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_restore_extended</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_restore_extended</span></code> instruction takes a single unsigned LEB128
operand that represents a register number R. This instruction is identical
to <code class="docutils literal notranslate"><span class="pre">DW_CFA_restore</span></code>, except for the encoding and size of the register
operand.</p>
</li>
</ol>
</div>
<div class="section" id="a-6-4-2-4-row-state-instructions">
<h6><a class="toc-backref" href="#id79">A.6.4.2.4 Row State Instructions</a><a class="headerlink" href="#a-6-4-2-4-row-state-instructions" title="Permalink to this headline">¶</a></h6>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These instructions are the same as in DWARF Version 5 section 6.4.2.4.</p>
</div>
</div>
<div class="section" id="a-6-4-2-5-padding-instruction">
<h6><a class="toc-backref" href="#id80">A.6.4.2.5 Padding Instruction</a><a class="headerlink" href="#a-6-4-2-5-padding-instruction" title="Permalink to this headline">¶</a></h6>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These instructions are the same as in DWARF Version 5 section 6.4.2.5.</p>
</div>
</div>
</div>
<div class="section" id="a-6-4-3-call-frame-instruction-usage">
<h5><a class="toc-backref" href="#id81">A.6.4.3 Call Frame Instruction Usage</a><a class="headerlink" href="#a-6-4-3-call-frame-instruction-usage" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The same as in DWARF Version 5 section 6.4.3.</p>
</div>
</div>
<div class="section" id="a-6-4-4-call-frame-calling-address">
<span id="amdgpu-dwarf-call-frame-calling-address"></span><h5><a class="toc-backref" href="#id82">A.6.4.4 Call Frame Calling Address</a><a class="headerlink" href="#a-6-4-4-call-frame-calling-address" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The same as in DWARF Version 5 section 6.4.4.</p>
</div>
</div>
</div>
</div>
<div class="section" id="a-7-data-representation">
<h3><a class="toc-backref" href="#id83">A.7 Data Representation</a><a class="headerlink" href="#a-7-data-representation" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section provides changes to existing debugger information entry
attributes. These would be incorporated into the corresponding DWARF Version 5
chapter 7 sections.</p>
</div>
<div class="section" id="a-7-4-32-bit-and-64-bit-dwarf-formats">
<span id="amdgpu-dwarf-32-bit-and-64-bit-dwarf-formats"></span><h4><a class="toc-backref" href="#id84">A.7.4 32-Bit and 64-Bit DWARF Formats</a><a class="headerlink" href="#a-7-4-32-bit-and-64-bit-dwarf-formats" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This augments DWARF Version 5 section 7.4 list item 3’s table.</p>
</div>
<table class="docutils align-default" id="amdgpu-dwarf-debug-info-section-attribute-form-roles-table">
<caption><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">.debug_info</span></code> section attribute form roles</span><a class="headerlink" href="#amdgpu-dwarf-debug-info-section-attribute-form-roles-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 49%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Form</p></th>
<th class="head"><p>Role</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>DW_OP_LLVM_aspace_implicit_pointer</p></td>
<td><p>offset in <code class="docutils literal notranslate"><span class="pre">.debug_info</span></code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="a-7-5-format-of-debugging-information">
<h4><a class="toc-backref" href="#id85">A.7.5 Format of Debugging Information</a><a class="headerlink" href="#a-7-5-format-of-debugging-information" title="Permalink to this headline">¶</a></h4>
<div class="section" id="a-7-5-4-attribute-encodings">
<h5><a class="toc-backref" href="#id86">A.7.5.4 Attribute Encodings</a><a class="headerlink" href="#a-7-5-4-attribute-encodings" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This augments DWARF Version 5 section 7.5.4 and Table 7.5.</p>
</div>
<p>The following table gives the encoding of the additional debugging information
entry attributes.</p>
<table class="docutils align-default" id="amdgpu-dwarf-attribute-encodings-table">
<caption><span class="caption-text">Attribute encodings</span><a class="headerlink" href="#amdgpu-dwarf-attribute-encodings-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 45%" />
<col style="width: 8%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Attribute Name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Classes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>DW_AT_LLVM_active_lane</p></td>
<td><p>0x3e08</p></td>
<td><p>exprloc, loclist</p></td>
</tr>
<tr class="row-odd"><td><p>DW_AT_LLVM_augmentation</p></td>
<td><p>0x3e09</p></td>
<td><p>string</p></td>
</tr>
<tr class="row-even"><td><p>DW_AT_LLVM_lanes</p></td>
<td><p>0x3e0a</p></td>
<td><p>constant</p></td>
</tr>
<tr class="row-odd"><td><p>DW_AT_LLVM_lane_pc</p></td>
<td><p>0x3e0b</p></td>
<td><p>exprloc, loclist</p></td>
</tr>
<tr class="row-even"><td><p>DW_AT_LLVM_vector_size</p></td>
<td><p>0x3e0c</p></td>
<td><p>constant</p></td>
</tr>
<tr class="row-odd"><td><p>DW_AT_LLVM_iterations</p></td>
<td><p>0x3e0a</p></td>
<td><p>constant, exprloc, loclist</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="a-7-5-5-classes-and-forms">
<span id="amdgpu-dwarf-classes-and-forms"></span><h5><a class="toc-backref" href="#id87">A.7.5.5 Classes and Forms</a><a class="headerlink" href="#a-7-5-5-classes-and-forms" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The same as in DWARF Version 5 section 7.5.5.</p>
</div>
</div>
</div>
<div class="section" id="a-7-7-dwarf-expressions">
<h4><a class="toc-backref" href="#id88">A.7.7 DWARF Expressions</a><a class="headerlink" href="#a-7-7-dwarf-expressions" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Rename DWARF Version 5 section 7.7 to reflect the unification of location
descriptions into DWARF expressions.</p>
</div>
<div class="section" id="a-7-7-1-operation-expressions">
<h5><a class="toc-backref" href="#id89">A.7.7.1 Operation Expressions</a><a class="headerlink" href="#a-7-7-1-operation-expressions" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Rename DWARF Version 5 section 7.7.1 and delete section 7.7.2 to reflect the
unification of location descriptions into DWARF expressions.</p>
<p>This augments DWARF Version 5 section 7.7.1 and Table 7.9.</p>
</div>
<p>The following table gives the encoding of the additional DWARF expression
operations.</p>
<table class="docutils align-default" id="amdgpu-dwarf-operation-encodings-table">
<caption><span class="caption-text">DWARF Operation Encodings</span><a class="headerlink" href="#amdgpu-dwarf-operation-encodings-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 44%" />
<col style="width: 6%" />
<col style="width: 10%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operation</p></th>
<th class="head"><p>Code</p></th>
<th class="head"><p>Number
of
Operands</p></th>
<th class="head"><p>Notes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>DW_OP_LLVM_form_aspace_address</p></td>
<td><p>0xe1</p></td>
<td><p>0</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>DW_OP_LLVM_push_lane</p></td>
<td><p>0xe2</p></td>
<td><p>0</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>DW_OP_LLVM_offset</p></td>
<td><p>0xe3</p></td>
<td><p>0</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>DW_OP_LLVM_offset_uconst</p></td>
<td><p>0xe4</p></td>
<td><p>1</p></td>
<td><p>ULEB128 byte displacement</p></td>
</tr>
<tr class="row-even"><td><p>DW_OP_LLVM_bit_offset</p></td>
<td><p>0xe5</p></td>
<td><p>0</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>DW_OP_LLVM_call_frame_entry_reg</p></td>
<td><p>0xe6</p></td>
<td><p>1</p></td>
<td><p>ULEB128 register number</p></td>
</tr>
<tr class="row-even"><td><p>DW_OP_LLVM_undefined</p></td>
<td><p>0xe7</p></td>
<td><p>0</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>DW_OP_LLVM_aspace_bregx</p></td>
<td><p>0xe8</p></td>
<td><p>2</p></td>
<td><p>ULEB128 register number,
ULEB128 byte displacement</p></td>
</tr>
<tr class="row-even"><td><p>DW_OP_LLVM_aspace_implicit_pointer</p></td>
<td><p>0xe9</p></td>
<td><p>2</p></td>
<td><p>4-byte or 8-byte offset of DIE,
SLEB128 byte displacement</p></td>
</tr>
<tr class="row-odd"><td><p>DW_OP_LLVM_piece_end</p></td>
<td><p>0xea</p></td>
<td><p>0</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>DW_OP_LLVM_extend</p></td>
<td><p>0xeb</p></td>
<td><p>2</p></td>
<td><p>ULEB128 bit size,
ULEB128 count</p></td>
</tr>
<tr class="row-odd"><td><p>DW_OP_LLVM_select_bit_piece</p></td>
<td><p>0xec</p></td>
<td><p>2</p></td>
<td><p>ULEB128 bit size,
ULEB128 count</p></td>
</tr>
<tr class="row-even"><td><p>DW_OP_LLVM_push_iteration</p></td>
<td><p>TBA</p></td>
<td><p>0</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>DW_OP_LLVM_overlay</p></td>
<td><p>TBA</p></td>
<td><p>0</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>DW_OP_LLVM_bit_overlay</p></td>
<td><p>TBA</p></td>
<td><p>0</p></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="a-7-7-3-location-list-expressions">
<h5><a class="toc-backref" href="#id90">A.7.7.3 Location List Expressions</a><a class="headerlink" href="#a-7-7-3-location-list-expressions" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Rename DWARF Version 5 section 7.7.3 to reflect that location lists are a kind
of DWARF expression.</p>
</div>
</div>
</div>
<div class="section" id="a-7-12-source-languages">
<h4><a class="toc-backref" href="#id91">A.7.12 Source Languages</a><a class="headerlink" href="#a-7-12-source-languages" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This augments DWARF Version 5 section 7.12 and Table 7.17.</p>
</div>
<p>The following table gives the encoding of the additional DWARF languages.</p>
<table class="docutils align-default" id="amdgpu-dwarf-language-encodings-table">
<caption><span class="caption-text">Language encodings</span><a class="headerlink" href="#amdgpu-dwarf-language-encodings-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 44%" />
<col style="width: 13%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Language Name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Default Lower Bound</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_LANG_LLVM_HIP</span></code></p></td>
<td><p>0x8100</p></td>
<td><p>0</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="a-7-13-address-class-and-address-space-encodings">
<h4><a class="toc-backref" href="#id92">A.7.13 Address Class and Address Space Encodings</a><a class="headerlink" href="#a-7-13-address-class-and-address-space-encodings" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This replaces DWARF Version 5 section 7.13.</p>
</div>
<p>The encodings of the constants used for the currently defined address classes
are given in <a class="reference internal" href="#amdgpu-dwarf-address-class-encodings-table"><span class="std std-ref">Address class encodings</span></a>.</p>
<table class="docutils align-default" id="amdgpu-dwarf-address-class-encodings-table">
<caption><span class="caption-text">Address class encodings</span><a class="headerlink" href="#amdgpu-dwarf-address-class-encodings-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 81%" />
<col style="width: 19%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Address Class Name</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_none</span></code></p></td>
<td><p>0x0000</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_global</span></code></p></td>
<td><p>0x0001</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_constant</span></code></p></td>
<td><p>0x0002</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_group</span></code></p></td>
<td><p>0x0003</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_private</span></code></p></td>
<td><p>0x0004</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_lo_user</span></code></p></td>
<td><p>0x8000</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_hi_user</span></code></p></td>
<td><p>0xffff</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="a-7-22-line-number-information">
<h4><a class="toc-backref" href="#id93">A.7.22 Line Number Information</a><a class="headerlink" href="#a-7-22-line-number-information" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This augments DWARF Version 5 section 7.22 and Table 7.27.</p>
</div>
<p>The following table gives the encoding of the additional line number header
entry formats.</p>
<table class="docutils align-default" id="amdgpu-dwarf-line-number-header-entry-format-encodings-table">
<caption><span class="caption-text">Line number header entry format encodings</span><a class="headerlink" href="#amdgpu-dwarf-line-number-header-entry-format-encodings-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 64%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Line number header entry format name</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_LNCT_LLVM_source</span></code></p></td>
<td><p>0x2001</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_LNCT_LLVM_is_MD5</span></code></p></td>
<td><p>0x2002</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="a-7-24-call-frame-information">
<h4><a class="toc-backref" href="#id94">A.7.24 Call Frame Information</a><a class="headerlink" href="#a-7-24-call-frame-information" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This augments DWARF Version 5 section 7.24 and Table 7.29.</p>
</div>
<p>The following table gives the encoding of the additional call frame information
instructions.</p>
<table class="docutils align-default" id="amdgpu-dwarf-call-frame-instruction-encodings-table">
<caption><span class="caption-text">Call frame instruction encodings</span><a class="headerlink" href="#amdgpu-dwarf-call-frame-instruction-encodings-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 31%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Instruction</p></th>
<th class="head"><p>High 2
Bits</p></th>
<th class="head"><p>Low 6
Bits</p></th>
<th class="head"><p>Operand 1</p></th>
<th class="head"><p>Operand 2</p></th>
<th class="head"><p>Operand 3</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>DW_CFA_LLVM_def_aspace_cfa</p></td>
<td><p>0</p></td>
<td><p>0x30</p></td>
<td><p>ULEB128 register</p></td>
<td><p>ULEB128 offset</p></td>
<td><p>ULEB128 address space</p></td>
</tr>
<tr class="row-odd"><td><p>DW_CFA_LLVM_def_aspace_cfa_sf</p></td>
<td><p>0</p></td>
<td><p>0x31</p></td>
<td><p>ULEB128 register</p></td>
<td><p>SLEB128 offset</p></td>
<td><p>ULEB128 address space</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="a-attributes-by-tag-value-informative">
<h3><a class="toc-backref" href="#id95">A. Attributes by Tag Value (Informative)</a><a class="headerlink" href="#a-attributes-by-tag-value-informative" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This augments DWARF Version 5 Appendix A and Table A.1.</p>
</div>
<p>The following table provides the additional attributes that are applicable to
debugger information entries.</p>
<table class="docutils align-default" id="amdgpu-dwarf-attributes-by-tag-value-table">
<caption><span class="caption-text">Attributes by tag value</span><a class="headerlink" href="#amdgpu-dwarf-attributes-by-tag-value-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Tag Name</p></th>
<th class="head"><p>Applicable Attributes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_TAG_base_type</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_vector_size</span></code></p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_TAG_compile_unit</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_augmentation</span></code></p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_TAG_entry_point</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_active_lane</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lanes</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_iterations</span></code></p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_TAG_inlined_subroutine</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_active_lane</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lanes</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_iterations</span></code></p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_TAG_subprogram</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_active_lane</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lanes</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_iterations</span></code></p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="b-examples">
<span id="amdgpu-dwarf-examples"></span><h2><a class="toc-backref" href="#id96">B. Examples</a><a class="headerlink" href="#b-examples" title="Permalink to this headline">¶</a></h2>
<p>The AMD GPU specific usage of the features in these extensions, including
examples, is available at <em>User Guide for AMDGPU Backend</em> section
<a class="reference internal" href="AMDGPUUsage.html#amdgpu-dwarf-debug-information"><span class="std std-ref">DWARF Debug Information</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Change examples to use <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset</span></code> instead of <code class="docutils literal notranslate"><span class="pre">DW_OP_add</span></code> when
acting on a location description.</p>
<p>Need to provide examples of new features.</p>
</div>
</div>
<div class="section" id="c-references">
<span id="amdgpu-dwarf-references"></span><h2><a class="toc-backref" href="#id97">C. References</a><a class="headerlink" href="#c-references" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div></div></blockquote>
<ol class="arabic simple" id="amdgpu-dwarf-amd">
<li><p>[AMD] <a class="reference external" href="https://www.amd.com/">Advanced Micro Devices</a></p>
</li>
<li id="amdgpu-dwarf-amd-rocgdb"><p>[AMD-ROCgdb] <a class="reference external" href="https://github.com/ROCm-Developer-Tools/ROCgdb">AMD ROCm Debugger (ROCgdb)</a></p>
</li>
<li id="amdgpu-dwarf-amd-rocm"><p>[AMD-ROCm] <a class="reference external" href="https://rocm-documentation.readthedocs.io">AMD ROCm Platform</a></p>
</li>
<li id="amdgpu-dwarf-amdgpu-dwarf-loc"><p>[AMDGPU-DWARF-LOC] <a class="reference external" href="https://llvm.org/docs/AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack/AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack.html">Allow Location Descriptions on the DWARF Expression Stack</a></p>
</li>
<li id="amdgpu-dwarf-amdgpu-llvm"><p>[AMDGPU-LLVM] <a class="reference external" href="https://llvm.org/docs/AMDGPUUsage.html">User Guide for AMDGPU LLVM Backend</a></p>
</li>
<li id="amdgpu-dwarf-cuda"><p>[CUDA] <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/">Nvidia CUDA Language</a></p>
</li>
<li id="amdgpu-dwarf-dwarf"><p>[DWARF] <a class="reference external" href="http://dwarfstd.org/">DWARF Debugging Information Format</a></p>
</li>
<li id="amdgpu-dwarf-elf"><p>[ELF] <a class="reference external" href="http://www.sco.com/developers/gabi/">Executable and Linkable Format (ELF)</a></p>
</li>
<li id="amdgpu-dwarf-gcc"><p>[GCC] <a class="reference external" href="https://www.gnu.org/software/gcc/">GCC: The GNU Compiler Collection</a></p>
</li>
<li id="amdgpu-dwarf-gdb"><p>[GDB] <a class="reference external" href="https://www.gnu.org/software/gdb/">GDB: The GNU Project Debugger</a></p>
</li>
<li id="amdgpu-dwarf-hip"><p>[HIP] <a class="reference external" href="https://rocm-documentation.readthedocs.io/en/latest/Programming_Guides/Programming-Guides.html#hip-programing-guide">HIP Programming Guide</a></p>
</li>
<li id="amdgpu-dwarf-hsa"><p>[HSA] <a class="reference external" href="http://www.hsafoundation.com/">Heterogeneous System Architecture (HSA) Foundation</a></p>
</li>
<li id="amdgpu-dwarf-llvm"><p>[LLVM] <a class="reference external" href="https://llvm.org/">The LLVM Compiler Infrastructure</a></p>
</li>
<li id="amdgpu-dwarf-opencl"><p>[OpenCL] <a class="reference external" href="http://www.khronos.org/registry/cl/specs/opencl-2.0.pdf">The OpenCL Specification Version 2.0</a></p>
</li>
<li id="amdgpu-dwarf-perforce-totalview"><p>[Perforce-TotalView] <a class="reference external" href="https://totalview.io/products/totalview">Perforce TotalView HPC Debugging Software</a></p>
</li>
<li id="amdgpu-dwarf-semver"><p>[SEMVER] <a class="reference external" href="https://semver.org/">Semantic Versioning</a></p></li>
</ol>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack/AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack.html" title="Allow Location Descriptions on the DWARF Expression Stack"
             >next</a> |</li>
        <li class="right" >
          <a href="AMDGPUInstructionNotation.html" title="AMDGPU Instructions Notation"
             >previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" >User Guides</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="AMDGPUUsage.html" >User Guide for AMDGPU Backend</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">DWARF Extensions For Heterogeneous Debugging</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2003-2022, LLVM Project.
      Last updated on 2022-03-25.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.1.2.
    </div>
  </body>
</html>