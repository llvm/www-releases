
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>OpenCL Support &#8212; Clang 13 documentation</title>
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="OpenMP Support" href="OpenMPSupport.html" />
    <link rel="prev" title="MSVC compatibility" href="MSVCCompatibility.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Clang 13 documentation</span></a></h1>
        <h2 class="heading"><span>OpenCL Support</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="MSVCCompatibility.html">MSVC compatibility</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="OpenMPSupport.html">OpenMP Support</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <style type="text/css">
  .none { background-color: #FFCCCC }
  .part { background-color: #FFFF99 }
  .good { background-color: #CCFF99 }
</style><div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#opencl-support" id="id2">OpenCL Support</a></p>
<ul>
<li><p><a class="reference internal" href="#internals-manual" id="id3">Internals Manual</a></p>
<ul>
<li><p><a class="reference internal" href="#opencl-metadata" id="id4">OpenCL Metadata</a></p></li>
<li><p><a class="reference internal" href="#opencl-specific-options" id="id5">OpenCL Specific Options</a></p></li>
<li><p><a class="reference internal" href="#opencl-builtins" id="id6">OpenCL builtins</a></p></li>
<li><p><a class="reference internal" href="#opencl-extensions-and-features" id="id7">OpenCL Extensions and Features</a></p>
<ul>
<li><p><a class="reference internal" href="#implementation-guidelines" id="id8">Implementation guidelines</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#address-spaces-attribute" id="id9">Address spaces attribute</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#c-for-opencl-implementation-status" id="id10">C++ for OpenCL Implementation Status</a></p>
<ul>
<li><p><a class="reference internal" href="#missing-features-or-with-limited-support" id="id11">Missing features or with limited support</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#opencl-c-3-0-usage" id="id12">OpenCL C 3.0 Usage</a></p>
<ul>
<li><p><a class="reference internal" href="#opencl-c-3-0-implementation-status" id="id13">OpenCL C 3.0 Implementation Status</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#experimental-features" id="id14">Experimental features</a></p>
<ul>
<li><p><a class="reference internal" href="#c-libraries-for-opencl" id="id15">C++ libraries for OpenCL</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="opencl-support">
<h1><a class="toc-backref" href="#id2">OpenCL Support</a><a class="headerlink" href="#opencl-support" title="Permalink to this headline">¶</a></h1>
<p>Clang has complete support of OpenCL C versions from 1.0 to 2.0.</p>
<p>Clang also supports <a class="reference internal" href="#cxx-for-opencl-impl"><span class="std std-ref">the C++ for OpenCL kernel language</span></a>.</p>
<p>There is an ongoing work to support <a class="reference internal" href="#opencl-300"><span class="std std-ref">OpenCL 3.0</span></a>.</p>
<p>There are also other <a class="reference internal" href="#opencl-experimenal"><span class="std std-ref">new and experimental features</span></a> available.</p>
<p>For general issues and bugs with OpenCL in clang refer to <a class="reference external" href="https://bugs.llvm.org/buglist.cgi?component=OpenCL&amp;list_id=172679&amp;product=clang&amp;resolution=---">Bugzilla</a>.</p>
<div class="section" id="internals-manual">
<h2><a class="toc-backref" href="#id3">Internals Manual</a><a class="headerlink" href="#internals-manual" title="Permalink to this headline">¶</a></h2>
<p>This section acts as internal documentation for OpenCL features design
as well as some important implementation aspects. It is primarily targeted
at the advanced users and the toolchain developers integrating frontend
functionality as a component.</p>
<div class="section" id="opencl-metadata">
<h3><a class="toc-backref" href="#id4">OpenCL Metadata</a><a class="headerlink" href="#opencl-metadata" title="Permalink to this headline">¶</a></h3>
<p>Clang uses metadata to provide additional OpenCL semantics in IR needed for
backends and OpenCL runtime.</p>
<p>Each kernel will have function metadata attached to it, specifying the arguments.
Kernel argument metadata is used to provide source level information for querying
at runtime, for example using the <a class="reference external" href="https://www.khronos.org/registry/OpenCL/specs/opencl-1.2.pdf#167">clGetKernelArgInfo</a>
call.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">-cl-kernel-arg-info</span></code> enables more information about the original
kernel code to be added e.g. kernel parameter names will appear in the OpenCL
metadata along with other information.</p>
<p>The IDs used to encode the OpenCL’s logical address spaces in the argument info
metadata follows the SPIR address space mapping as defined in the SPIR
specification <a class="reference external" href="https://www.khronos.org/registry/spir/specs/spir_spec-2.0.pdf#18">section 2.2</a></p>
</div>
<div class="section" id="opencl-specific-options">
<h3><a class="toc-backref" href="#id5">OpenCL Specific Options</a><a class="headerlink" href="#opencl-specific-options" title="Permalink to this headline">¶</a></h3>
<p>In addition to the options described in <a class="reference internal" href="UsersManual.html"><span class="doc">Clang Compiler User’s Manual</span></a> there are the
following options specific to the OpenCL frontend.</p>
<p>All the options in this section are frontend-only and therefore if used
with regular clang driver they require frontend forwarding, e.g. <code class="docutils literal notranslate"><span class="pre">-cc1</span></code>
or <code class="docutils literal notranslate"><span class="pre">-Xclang</span></code>.</p>
<span class="target" id="opencl-cl-ext"></span><dl class="option">
<dt id="cmdoption-cl-ext">
<code class="sig-name descname">-cl-ext</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-cl-ext" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Disables support of OpenCL extensions. All OpenCL targets provide a list
of extensions that they support. Clang allows to amend this using the <code class="docutils literal notranslate"><span class="pre">-cl-ext</span></code>
flag with a comma-separated list of extensions prefixed with <code class="docutils literal notranslate"><span class="pre">'+'</span></code> or <code class="docutils literal notranslate"><span class="pre">'-'</span></code>.
The syntax: <code class="docutils literal notranslate"><span class="pre">-cl-ext=&lt;(['-'|'+']&lt;extension&gt;[,])+&gt;</span></code>,  where extensions
can be either one of <a class="reference external" href="https://www.khronos.org/registry/OpenCL">the OpenCL published extensions</a>
or any vendor extension. Alternatively, <code class="docutils literal notranslate"><span class="pre">'all'</span></code> can be used to enable
or disable all known extensions.</p>
<p>Example disabling double support for the 64-bit SPIR target:</p>
<blockquote>
<div><div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang -cc1 -triple spir64-unknown-unknown -cl-ext<span class="o">=</span>-cl_khr_fp64 test.cl
</pre></div>
</div>
</div></blockquote>
<p>Enabling all extensions except double support in R600 AMD GPU can be done using:</p>
<blockquote>
<div><div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang -cc1 -triple r600-unknown-unknown -cl-ext<span class="o">=</span>-all,+cl_khr_fp16 test.cl
</pre></div>
</div>
</div></blockquote>
<span class="target" id="opencl-finclude-default-header"></span><dl class="option">
<dt id="cmdoption-finclude-default-header">
<code class="sig-name descname">-finclude-default-header</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-finclude-default-header" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Adds most of builtin types and function declarations during compilations. By
default the OpenCL headers are not loaded by the frontend and therefore certain
builtin types and most of builtin functions are not declared. To load them
automatically this flag can be passed to the frontend (see also <a class="reference internal" href="UsersManual.html#opencl-header"><span class="std std-ref">the
section on the OpenCL Header</span></a>):</p>
<blockquote>
<div><div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang -Xclang -finclude-default-header test.cl
</pre></div>
</div>
</div></blockquote>
<p>Alternatively the internal header <cite>opencl-c.h</cite> containing the declarations
can be included manually using <code class="docutils literal notranslate"><span class="pre">-include</span></code> or <code class="docutils literal notranslate"><span class="pre">-I</span></code> followed by the path
to the header location. The header can be found in the clang source tree or
installation directory.</p>
<blockquote>
<div><div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang -I&lt;path to clang sources&gt;/lib/Headers/opencl-c.h test.cl
<span class="gp">$</span> clang -I&lt;path to clang installation&gt;/lib/clang/&lt;llvm version&gt;/include/opencl-c.h/opencl-c.h test.cl
</pre></div>
</div>
</div></blockquote>
<p>In this example it is assumed that the kernel code contains
<code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;opencl-c.h&gt;</span></code> just as a regular C include.</p>
<p>Because the header is very large and long to parse, PCH (<a class="reference internal" href="PCHInternals.html"><span class="doc">Precompiled Header and Modules Internals</span></a>)
and modules (<a class="reference internal" href="Modules.html"><span class="doc">Modules</span></a>) can be used internally to improve the compilation
speed.</p>
<p>To enable modules for OpenCL:</p>
<blockquote>
<div><div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang -target spir-unknown-unknown -c -emit-llvm -Xclang -finclude-default-header -fmodules -fimplicit-module-maps -fm     odules-cache-path<span class="o">=</span>&lt;path to the generated module&gt; test.cl
</pre></div>
</div>
</div></blockquote>
<p>Another way to circumvent long parsing latency for the OpenCL builtin
declarations is to use mechanism enabled by <a class="reference internal" href="#opencl-fdeclare-opencl-builtins"><span class="std std-ref">-fdeclare-opencl-builtins</span></a> flag that is available as an alternative
feature.</p>
<span class="target" id="opencl-fdeclare-opencl-builtins"></span><dl class="option">
<dt id="cmdoption-fdeclare-opencl-builtins">
<code class="sig-name descname">-fdeclare-opencl-builtins</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-fdeclare-opencl-builtins" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>In addition to regular header includes with builtin types and functions using
<a class="reference internal" href="#opencl-finclude-default-header"><span class="std std-ref">-finclude-default-header</span></a>, clang
supports a fast mechanism to declare builtin functions with
<code class="docutils literal notranslate"><span class="pre">-fdeclare-opencl-builtins</span></code>. This does not declare the builtin types and
therefore it has to be used in combination with <code class="docutils literal notranslate"><span class="pre">-finclude-default-header</span></code>
if full functionality is required.</p>
<p><strong>Example of Use</strong>:</p>
<blockquote>
<div><div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang -Xclang -fdeclare-opencl-builtins test.cl
</pre></div>
</div>
</div></blockquote>
<span class="target" id="opencl-fake-address-space-map"></span><dl class="option">
<dt id="cmdoption-ffake-address-space-map">
<code class="sig-name descname">-ffake-address-space-map</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-ffake-address-space-map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Overrides the target address space map with a fake map.
This allows adding explicit address space IDs to the bitcode for non-segmented
memory architectures that do not have separate IDs for each of the OpenCL
logical address spaces by default. Passing <code class="docutils literal notranslate"><span class="pre">-ffake-address-space-map</span></code> will
add/override address spaces of the target compiled for with the following values:
<code class="docutils literal notranslate"><span class="pre">1-global</span></code>, <code class="docutils literal notranslate"><span class="pre">2-constant</span></code>, <code class="docutils literal notranslate"><span class="pre">3-local</span></code>, <code class="docutils literal notranslate"><span class="pre">4-generic</span></code>. The private address
space is represented by the absence of an address space attribute in the IR (see
also <a class="reference internal" href="#opencl-addrsp"><span class="std std-ref">the section on the address space attribute</span></a>).</p>
<blockquote>
<div><div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang -cc1 -ffake-address-space-map test.cl
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="opencl-builtins">
<span id="id1"></span><h3><a class="toc-backref" href="#id6">OpenCL builtins</a><a class="headerlink" href="#opencl-builtins" title="Permalink to this headline">¶</a></h3>
<p><strong>Clang builtins</strong></p>
<p>There are some standard OpenCL functions that are implemented as Clang builtins:</p>
<ul class="simple">
<li><p>All pipe functions from <a class="reference external" href="https://www.khronos.org/registry/cl/specs/opencl-2.0-openclc.pdf#160">section 6.13.16.2/6.13.16.3</a> of
the OpenCL v2.0 kernel language specification.</p></li>
<li><p>Address space qualifier conversion functions <code class="docutils literal notranslate"><span class="pre">to_global</span></code>/<code class="docutils literal notranslate"><span class="pre">to_local</span></code>/<code class="docutils literal notranslate"><span class="pre">to_private</span></code>
from <a class="reference external" href="https://www.khronos.org/registry/cl/specs/opencl-2.0-openclc.pdf#101">section 6.13.9</a>.</p></li>
<li><p>All the <code class="docutils literal notranslate"><span class="pre">enqueue_kernel</span></code> functions from <a class="reference external" href="https://www.khronos.org/registry/cl/specs/opencl-2.0-openclc.pdf#164">section 6.13.17.1</a> and
enqueue query functions from <a class="reference external" href="https://www.khronos.org/registry/cl/specs/opencl-2.0-openclc.pdf#171">section 6.13.17.5</a>.</p></li>
</ul>
<p><strong>Fast builtin function declarations</strong></p>
<p>The implementation of the fast builtin function declarations (available via the
<a class="reference internal" href="#opencl-fdeclare-opencl-builtins"><span class="std std-ref">-fdeclare-opencl-builtins option</span></a>) consists
of the following main components:</p>
<ul class="simple">
<li><p>A TableGen definitions file <code class="docutils literal notranslate"><span class="pre">OpenCLBuiltins.td</span></code>.  This contains a compact
representation of the supported builtin functions.  When adding new builtin
function declarations, this is normally the only file that needs modifying.</p></li>
<li><p>A Clang TableGen emitter defined in <code class="docutils literal notranslate"><span class="pre">ClangOpenCLBuiltinEmitter.cpp</span></code>.  During
Clang build time, the emitter reads the TableGen definition file and
generates <code class="docutils literal notranslate"><span class="pre">OpenCLBuiltins.inc</span></code>.  This generated file contains various tables
and functions that capture the builtin function data from the TableGen
definitions in a compact manner.</p></li>
<li><p>OpenCL specific code in <code class="docutils literal notranslate"><span class="pre">SemaLookup.cpp</span></code>.  When <code class="docutils literal notranslate"><span class="pre">Sema::LookupBuiltin</span></code>
encounters a potential builtin function, it will check if the name corresponds
to a valid OpenCL builtin function.  If so, all overloads of the function are
inserted using <code class="docutils literal notranslate"><span class="pre">InsertOCLBuiltinDeclarationsFromTable</span></code> and overload
resolution takes place.</p></li>
</ul>
</div>
<div class="section" id="opencl-extensions-and-features">
<h3><a class="toc-backref" href="#id7">OpenCL Extensions and Features</a><a class="headerlink" href="#opencl-extensions-and-features" title="Permalink to this headline">¶</a></h3>
<p>Clang implements various extensions to OpenCL kernel languages.</p>
<p>New functionality is accepted as soon as the documentation is detailed to the
level sufficient to be implemented. There should be an evidence that the
extension is designed with implementation feasibility in consideration and
assessment of complexity for C/C++ based compilers. Alternatively, the
documentation can be accepted in a format of a draft that can be further
refined during the implementation.</p>
<div class="section" id="implementation-guidelines">
<h4><a class="toc-backref" href="#id8">Implementation guidelines</a><a class="headerlink" href="#implementation-guidelines" title="Permalink to this headline">¶</a></h4>
<p>This section explains how to extend clang with the new functionality.</p>
<p><strong>Parsing functionality</strong></p>
<p>If an extension modifies the standard parsing it needs to be added to
the clang frontend source code. This also means that the associated macro
indicating the presence of the extension should be added to clang.</p>
<p>The default flow for adding a new extension into the frontend is to
modify <a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/OpenCLExtensions.def">OpenCLExtensions.def</a></p>
<p>This will add the macro automatically and also add a field in the target
options <code class="docutils literal notranslate"><span class="pre">clang::TargetOptions::OpenCLFeaturesMap</span></code> to control the exposure
of the new extension during the compilation.</p>
<p>Note that by default targets like <cite>SPIR</cite> or <cite>X86</cite> expose all the OpenCL
extensions. For all other targets the configuration has to be made explicitly.</p>
<p>Note that the target extension support performed by clang can be overridden
with <a class="reference internal" href="#opencl-cl-ext"><span class="std std-ref">-cl-ext</span></a> command-line flags.</p>
<p><strong>Library functionality</strong></p>
<p>If an extension adds functionality that does not modify standard language
parsing it should not require modifying anything other than header files or
<code class="docutils literal notranslate"><span class="pre">OpenCLBuiltins.td</span></code> detailed in <a class="reference internal" href="#opencl-builtins"><span class="std std-ref">OpenCL builtins</span></a>.
Most commonly such extensions add functionality via libraries (by adding
non-native types or functions) parsed regularly. Similar to other languages this
is the most common way to add new functionality.</p>
<p>Clang has standard headers where new types and functions are being added,
for more details refer to
<a class="reference internal" href="UsersManual.html#opencl-header"><span class="std std-ref">the section on the OpenCL Header</span></a>. The macros indicating
the presence of such extensions can be added in the standard header files
conditioned on target specific predefined macros or/and language version
predefined macros.</p>
<p><strong>Pragmas</strong></p>
<p>Some extensions alter standard parsing dynamically via pragmas.</p>
<p>Clang provides a mechanism to add the standard extension pragma
<code class="docutils literal notranslate"><span class="pre">OPENCL</span> <span class="pre">EXTENSION</span></code> by setting a dedicated flag in the extension list entry of
<code class="docutils literal notranslate"><span class="pre">OpenCLExtensions.def</span></code>. Note that there is no default behavior for the
standard extension pragmas as it is not specified (for the standards up to and
including version 3.0) in a sufficient level of detail and, therefore,
there is no default functionality provided by clang.</p>
<p>Pragmas without detailed information of their behavior (e.g. an explanation of
changes it triggers in the parsing) should not be added to clang. Moreover, the
pragmas should provide useful functionality to the user. For example, such
functionality should address a practical use case and not be redundant i.e.
cannot be achieved using existing features.</p>
<p>Note that some legacy extensions (published prior to OpenCL 3.0) still
provide some non-conformant functionality for pragmas e.g. add diagnostics on
the use of types or functions. This functionality is not guaranteed to remain in
future releases. However, any future changes should not affect backward
compatibility.</p>
</div>
</div>
<div class="section" id="address-spaces-attribute">
<span id="opencl-addrsp"></span><h3><a class="toc-backref" href="#id9">Address spaces attribute</a><a class="headerlink" href="#address-spaces-attribute" title="Permalink to this headline">¶</a></h3>
<p>Clang has arbitrary address space support using the <code class="docutils literal notranslate"><span class="pre">address_space(N)</span></code>
attribute, where <code class="docutils literal notranslate"><span class="pre">N</span></code> is an integer number in the range specified in the
Clang source code. This addresses spaces can be used along with the OpenCL
address spaces however when such addresses spaces converted to/from OpenCL
address spaces the behavior is not governed by OpenCL specification.</p>
<p>An OpenCL implementation provides a list of standard address spaces using
keywords: <code class="docutils literal notranslate"><span class="pre">private</span></code>, <code class="docutils literal notranslate"><span class="pre">local</span></code>, <code class="docutils literal notranslate"><span class="pre">global</span></code>, and <code class="docutils literal notranslate"><span class="pre">generic</span></code>. In the AST and
in the IR each of the address spaces will be represented by unique number
provided in the Clang source code. The specific IDs for an address space do not
have to match between the AST and the IR. Typically in the AST address space
numbers represent logical segments while in the IR they represent physical
segments.
Therefore, machines with flat memory segments can map all AST address space
numbers to the same physical segment ID or skip address space attribute
completely while generating the IR. However, if the address space information
is needed by the IR passes e.g. to improve alias analysis, it is recommended
to keep it and only lower to reflect physical memory segments in the late
machine passes. The mapping between logical and target address spaces is
specified in the Clang’s source code.</p>
</div>
</div>
<div class="section" id="c-for-opencl-implementation-status">
<span id="cxx-for-opencl-impl"></span><h2><a class="toc-backref" href="#id10">C++ for OpenCL Implementation Status</a><a class="headerlink" href="#c-for-opencl-implementation-status" title="Permalink to this headline">¶</a></h2>
<p>Clang implements language version 1.0 published in <a class="reference external" href="https://github.com/KhronosGroup/OpenCL-Docs/releases/tag/cxxforopencl-v1.0-r2">the official
release of C++ for OpenCL Documentation</a>.</p>
<p>Limited support of experimental C++ libraries is described in the <a class="reference internal" href="#opencl-experimenal"><span class="std std-ref">experimental features</span></a>.</p>
<p>Bugzilla bugs for this functionality are typically prefixed
with ‘[C++4OpenCL]’ - click <a class="reference external" href="https://bugs.llvm.org/buglist.cgi?component=OpenCL&amp;list_id=204139&amp;product=clang&amp;query_format=advanced&amp;resolution=---&amp;short_desc=%5BC%2B%2B4OpenCL%5D&amp;short_desc_type=allwordssubstr">here</a>
to view the full bug list.</p>
<div class="section" id="missing-features-or-with-limited-support">
<h3><a class="toc-backref" href="#id11">Missing features or with limited support</a><a class="headerlink" href="#missing-features-or-with-limited-support" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>IR generation for global destructors is incomplete (See:
<a class="reference external" href="https://llvm.org/PR48047">PR48047</a>).</p></li>
</ul>
</div>
</div>
<div class="section" id="opencl-c-3-0-usage">
<span id="opencl-300"></span><h2><a class="toc-backref" href="#id12">OpenCL C 3.0 Usage</a><a class="headerlink" href="#opencl-c-3-0-usage" title="Permalink to this headline">¶</a></h2>
<p>OpenCL C 3.0 language standard makes most OpenCL C 2.0 features optional. Optional
functionality in OpenCL C 3.0 is indicated with the presence of feature-test macros
(list of feature-test macros is <a class="reference external" href="https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_C.html#features">here</a>).
Command-line flag <a class="reference internal" href="#opencl-cl-ext"><span class="std std-ref">-cl-ext</span></a> can be used to override features supported by a target.</p>
<p>For cases when there is an associated extension for a specific feature (fp64 and 3d image writes)
user should specify both (extension and feature) in command-line flag:</p>
<blockquote>
<div><div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang -cc1 -cl-std<span class="o">=</span>CL3.0 -cl-ext<span class="o">=</span>+cl_khr_fp64,+__opencl_c_fp64 ...
<span class="gp">$</span> clang -cc1 -cl-std<span class="o">=</span>CL3.0 -cl-ext<span class="o">=</span>-cl_khr_fp64,-__opencl_c_fp64 ...
</pre></div>
</div>
</div></blockquote>
<div class="section" id="opencl-c-3-0-implementation-status">
<h3><a class="toc-backref" href="#id13">OpenCL C 3.0 Implementation Status</a><a class="headerlink" href="#opencl-c-3-0-implementation-status" title="Permalink to this headline">¶</a></h3>
<p>The following table provides an overview of features in OpenCL C 3.0 and their
implementation status.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 12%" />
<col style="width: 19%" />
<col style="width: 10%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Category</p></th>
<th class="head" colspan="2"><p>Feature</p></th>
<th class="head"><p>Status</p></th>
<th class="head"><p>Reviews</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Command line interface</p></td>
<td colspan="2"><p>New value for <code class="docutils literal notranslate"><span class="pre">-cl-std</span></code> flag</p></td>
<td><p><span class="good">done</span></p></td>
<td><p><a class="reference external" href="https://reviews.llvm.org/D88300">https://reviews.llvm.org/D88300</a></p></td>
</tr>
<tr class="row-odd"><td><p>Predefined macros</p></td>
<td colspan="2"><p>New version macro</p></td>
<td><p><span class="good">done</span></p></td>
<td><p><a class="reference external" href="https://reviews.llvm.org/D88300">https://reviews.llvm.org/D88300</a></p></td>
</tr>
<tr class="row-even"><td><p>Predefined macros</p></td>
<td colspan="2"><p>Feature macros</p></td>
<td><p><span class="good">done</span></p></td>
<td><p><a class="reference external" href="https://reviews.llvm.org/D95776">https://reviews.llvm.org/D95776</a></p></td>
</tr>
<tr class="row-odd"><td><p>Feature optionality</p></td>
<td colspan="2"><p>Generic address space</p></td>
<td><p><span class="good">done</span></p></td>
<td><p><a class="reference external" href="https://reviews.llvm.org/D95778">https://reviews.llvm.org/D95778</a> and <a class="reference external" href="https://reviews.llvm.org/D103401">https://reviews.llvm.org/D103401</a></p></td>
</tr>
<tr class="row-even"><td><p>Feature optionality</p></td>
<td colspan="2"><p>Builtin function overloads with generic address space</p></td>
<td><p><span class="good">done</span></p></td>
<td><p><a class="reference external" href="https://reviews.llvm.org/D105526">https://reviews.llvm.org/D105526</a></p></td>
</tr>
<tr class="row-odd"><td><p>Feature optionality</p></td>
<td colspan="2"><p>Program scope variables in global memory</p></td>
<td><p><span class="good">done</span></p></td>
<td><p><a class="reference external" href="https://reviews.llvm.org/D103191">https://reviews.llvm.org/D103191</a></p></td>
</tr>
<tr class="row-even"><td><p>Feature optionality</p></td>
<td colspan="2"><p>3D image writes including builtin functions</p></td>
<td><p><span class="part">worked on</span></p></td>
<td><p><a class="reference external" href="https://reviews.llvm.org/D106260">https://reviews.llvm.org/D106260</a> (frontend)</p></td>
</tr>
<tr class="row-odd"><td><p>Feature optionality</p></td>
<td colspan="2"><p>read_write images including builtin functions</p></td>
<td><p><span class="part">worked on</span></p></td>
<td><p><a class="reference external" href="https://reviews.llvm.org/D104915">https://reviews.llvm.org/D104915</a> (frontend) and <a class="reference external" href="https://reviews.llvm.org/D107539">https://reviews.llvm.org/D107539</a> (functions)</p></td>
</tr>
<tr class="row-even"><td><p>Feature optionality</p></td>
<td colspan="2"><p>C11 atomics memory scopes, ordering and builtin function</p></td>
<td><p><span class="good">done</span></p></td>
<td><p><a class="reference external" href="https://reviews.llvm.org/D106111">https://reviews.llvm.org/D106111</a></p></td>
</tr>
<tr class="row-odd"><td><p>Feature optionality</p></td>
<td colspan="2"><p>Blocks and Device-side kernel enqueue including builtin functions</p></td>
<td><p><span class="none">unclaimed</span></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Feature optionality</p></td>
<td colspan="2"><p>Pipes including builtin functions</p></td>
<td><p><span class="part">worked on</span></p></td>
<td><p><a class="reference external" href="https://reviews.llvm.org/D107154">https://reviews.llvm.org/D107154</a> (frontend) and <a class="reference external" href="https://reviews.llvm.org/D105858">https://reviews.llvm.org/D105858</a> (functions)</p></td>
</tr>
<tr class="row-odd"><td><p>Feature optionality</p></td>
<td colspan="2"><p>Work group collective builtin functions</p></td>
<td><p><span class="part">worked on</span></p></td>
<td><p><a class="reference external" href="https://reviews.llvm.org/D105858">https://reviews.llvm.org/D105858</a></p></td>
</tr>
<tr class="row-even"><td><p>Feature optionality</p></td>
<td colspan="2"><p>Image types and builtin functions</p></td>
<td><p><span class="good">done</span></p></td>
<td><p><a class="reference external" href="https://reviews.llvm.org/D103911">https://reviews.llvm.org/D103911</a> (frontend) and <a class="reference external" href="https://reviews.llvm.org/D107539">https://reviews.llvm.org/D107539</a> (functions)</p></td>
</tr>
<tr class="row-odd"><td><p>Feature optionality</p></td>
<td colspan="2"><p>Double precision floating point type</p></td>
<td><p><span class="good">done</span></p></td>
<td><p><a class="reference external" href="https://reviews.llvm.org/D96524">https://reviews.llvm.org/D96524</a></p></td>
</tr>
<tr class="row-even"><td><p>New functionality</p></td>
<td colspan="2"><p>RGBA vector components</p></td>
<td><p><span class="good">done</span></p></td>
<td><p><a class="reference external" href="https://reviews.llvm.org/D99969">https://reviews.llvm.org/D99969</a></p></td>
</tr>
<tr class="row-odd"><td><p>New functionality</p></td>
<td colspan="2"><p>Subgroup functions</p></td>
<td><p><span class="part">worked on</span></p></td>
<td><p><a class="reference external" href="https://reviews.llvm.org/D105858">https://reviews.llvm.org/D105858</a></p></td>
</tr>
<tr class="row-even"><td><p>New functionality</p></td>
<td colspan="2"><p>Atomic mem scopes: subgroup, all devices including functions</p></td>
<td><p><span class="part">worked on</span></p></td>
<td><p><a class="reference external" href="https://reviews.llvm.org/D103241">https://reviews.llvm.org/D103241</a></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="experimental-features">
<span id="opencl-experimenal"></span><h2><a class="toc-backref" href="#id14">Experimental features</a><a class="headerlink" href="#experimental-features" title="Permalink to this headline">¶</a></h2>
<p>Clang provides the following new WIP features for the developers to experiment
and provide early feedback or contribute with further improvements.
Feel free to contact us on <a class="reference external" href="https://lists.llvm.org/mailman/listinfo/cfe-dev">cfe-dev</a> or via <a class="reference external" href="https://bugs.llvm.org/">Bugzilla</a>.</p>
<div class="section" id="c-libraries-for-opencl">
<span id="opencl-experimental-cxxlibs"></span><h3><a class="toc-backref" href="#id15">C++ libraries for OpenCL</a><a class="headerlink" href="#c-libraries-for-opencl" title="Permalink to this headline">¶</a></h3>
<p>There is ongoing work to support C++ standard libraries from <a class="reference external" href="https://libcxx.llvm.org/">LLVM’s libcxx</a> in OpenCL kernel code using C++ for OpenCL mode.</p>
<p>It is currently possible to include <cite>type_traits</cite> from C++17 in the kernel
sources when the following clang extensions are enabled
<code class="docutils literal notranslate"><span class="pre">__cl_clang_function_pointers</span></code> and <code class="docutils literal notranslate"><span class="pre">__cl_clang_variadic_functions</span></code>,
see <a class="reference internal" href="LanguageExtensions.html"><span class="doc">Clang Language Extensions</span></a> for more details. The use of non-conformant
features enabled by the extensions does not expose non-conformant behavior
beyond the compilation i.e. does not get generated in IR or binary.
The extension only appear in metaprogramming
mechanism to identify or verify the properties of types. This allows to provide
the full C++ functionality without a loss of portability. To avoid unsafe use
of the extensions it is recommended that the extensions are disabled directly
after the header include.</p>
<p><strong>Example of Use</strong>:</p>
<p>The example of kernel code with <cite>type_traits</cite> is illustrated here.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma OPENCL EXTENSION __cl_clang_function_pointers : enable</span>
<span class="cp">#pragma OPENCL EXTENSION __cl_clang_variadic_functions : enable</span>
<span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>
<span class="cp">#pragma OPENCL EXTENSION __cl_clang_function_pointers : disable</span>
<span class="cp">#pragma OPENCL EXTENSION __cl_clang_variadic_functions : disable</span>

<span class="k">using</span> <span class="n">sint_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_signed</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>

<span class="n">__kernel</span> <span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">sint_type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The possible clang invocation to compile the example is as follows:</p>
<blockquote>
<div><div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang -I&lt;path to libcxx checkout or installation&gt;/include test.clcpp
</pre></div>
</div>
</div></blockquote>
<p>Note that <cite>type_traits</cite> is a header only library and therefore no extra
linking step against the standard libraries is required. See full example
in <a class="reference external" href="https://godbolt.org/z/5WbnTfb65">Compiler Explorer</a>.</p>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="MSVCCompatibility.html">MSVC compatibility</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="OpenMPSupport.html">OpenMP Support</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2007-2022, The Clang Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.2.
    </div>
  </body>
</html>