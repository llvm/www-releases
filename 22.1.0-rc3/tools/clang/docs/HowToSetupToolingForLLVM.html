<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>How To Setup Clang Tooling For LLVM &#8212; Clang 22.1.0-rc3 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=e491ac2d" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=eafc0fe6" />
    <script src="_static/documentation_options.js?v=b417f315"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="JSON Compilation Database Format Specification" href="JSONCompilationDatabase.html" />
    <link rel="prev" title="ASTImporter: Merging Clang ASTs" href="LibASTImporter.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Clang 22.1.0-rc3 documentation</span></a></h1>
        <h2 class="heading"><span>How To Setup Clang Tooling For LLVM</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="LibASTImporter.html">ASTImporter: Merging Clang ASTs</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="JSONCompilationDatabase.html">JSON Compilation Database Format Specification</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="how-to-setup-clang-tooling-for-llvm">
<h1>How To Setup Clang Tooling For LLVM<a class="headerlink" href="#how-to-setup-clang-tooling-for-llvm" title="Link to this heading">¶</a></h1>
<p>Clang Tooling provides infrastructure to write tools that need syntactic
and semantic information about a program. This term also relates to a set
of specific tools using this infrastructure (e.g. <code class="docutils literal notranslate"><span class="pre">clang-check</span></code>). This
document provides information on how to set up and use Clang Tooling for
the LLVM source code.</p>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>Clang Tooling needs a compilation database to figure out specific build
options for each file. Currently it can create a compilation database
from the <code class="docutils literal notranslate"><span class="pre">compile_commands.json</span></code> file, generated by CMake. When
invoking clang tools, you can either specify a path to a build directory
using a command line parameter <code class="docutils literal notranslate"><span class="pre">-p</span></code> or let Clang Tooling find this
file in your source tree. In either case you need to configure your
build using CMake to use clang tools.</p>
</section>
<section id="setup-clang-tooling-using-cmake-and-make">
<h2>Setup Clang Tooling Using CMake and Make<a class="headerlink" href="#setup-clang-tooling-using-cmake-and-make" title="Link to this heading">¶</a></h2>
<p>If you intend to use make to build LLVM, you should have CMake 2.8.6 or
later installed (can be found <a class="reference external" href="https://cmake.org">here</a>).</p>
<p>First, you need to generate Makefiles for LLVM with CMake. You need to
make a build directory and run CMake from it:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>mkdir<span class="w"> </span>your/build/directory
<span class="gp">$ </span><span class="nb">cd</span><span class="w"> </span>your/build/directory
<span class="gp">$ </span>cmake<span class="w"> </span>-DCMAKE_EXPORT_COMPILE_COMMANDS<span class="o">=</span>ON<span class="w"> </span>path/to/llvm/sources
</pre></div>
</div>
<p>If you want to use clang instead of GCC, you can add
<code class="docutils literal notranslate"><span class="pre">-DCMAKE_C_COMPILER=/path/to/clang</span> <span class="pre">-DCMAKE_CXX_COMPILER=/path/to/clang++</span></code>.
You can also use <code class="docutils literal notranslate"><span class="pre">ccmake</span></code>, which provides a curses interface to configure
CMake variables.</p>
<p>As a result, the new <code class="docutils literal notranslate"><span class="pre">compile_commands.json</span></code> file should appear in the
current directory. You should link it to the LLVM source tree so that
Clang Tooling is able to use it:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ln<span class="w"> </span>-s<span class="w"> </span><span class="nv">$PWD</span>/compile_commands.json<span class="w"> </span>path/to/llvm/source/
</pre></div>
</div>
<p>Now you are ready to build and test LLVM using make:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>make<span class="w"> </span>check-all
</pre></div>
</div>
</section>
<section id="setup-clang-tooling-using-cmake-on-windows">
<h2>Setup Clang Tooling Using CMake on Windows<a class="headerlink" href="#setup-clang-tooling-using-cmake-on-windows" title="Link to this heading">¶</a></h2>
<p>For Windows developers, the Visual Studio project generators in CMake do
not support <a class="reference external" href="https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html">CMAKE_EXPORT_COMPILE_COMMANDS</a>.
However, the Ninja generator does support this variable and can be used
on Windows to generate a suitable <code class="docutils literal notranslate"><span class="pre">compile_commands.json</span></code> that invokes
the MSVC compiler.</p>
<p>First, you will need to install <a class="reference external" href="https://ninja-build.org/">Ninja</a>.  Once installed, the Ninja
executable will need to be in your search path for CMake to locate it.</p>
<p>Next, assuming you already have Visual Studio installed on your machine, you
need to have the appropriate environment variables configured so that CMake
will locate the MSVC compiler for the Ninja generator.  The <a class="reference external" href="https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#path_and_environment">documentation</a>
describes the necessary environment variable settings, but the simplest thing
is to use a <a class="reference external" href="https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_prompt_shortcuts">developer command-prompt window</a>
or call a <a class="reference external" href="https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_file_locations">developer command file</a>
to set the environment variables appropriately.</p>
<p>Now you can run CMake with the Ninja generator to export a compilation
database:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">C:\&gt; mkdir build-ninja</span>
<span class="go">C:\&gt; cd build-ninja</span>
<span class="go">C:\build-ninja&gt; cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources</span>
</pre></div>
</div>
<p>It is best to keep your Visual Studio IDE build folder separate from the
Ninja build folder.  This prevents the two build systems from negatively
interacting with each other.</p>
<p>Once the <code class="docutils literal notranslate"><span class="pre">compile_commands.json</span></code> file has been created by Ninja, you can
use that compilation database with Clang Tooling.  One caveat is that because
there are indirect settings obtained through the environment variables,
you may need to run any Clang Tooling executables through a command prompt
window created for use with Visual Studio as described above.  An
alternative, e.g. for using the Visual Studio debugger on a Clang Tooling
executable, is to ensure that the environment variables are also visible
to the debugger settings.  This can be done locally in Visual Studio’s
debugger configuration locally or globally by launching the Visual Studio
IDE from a suitable command-prompt window.</p>
</section>
<section id="using-clang-tools">
<h2>Using Clang Tools<a class="headerlink" href="#using-clang-tools" title="Link to this heading">¶</a></h2>
<p>After you completed the previous steps, you are ready to run clang tools. If
you have a recent clang installed, you should have <code class="docutils literal notranslate"><span class="pre">clang-check</span></code> in
<code class="docutils literal notranslate"><span class="pre">$PATH</span></code>. Try to run it on any <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> file inside the LLVM source tree:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang-check<span class="w"> </span>tools/clang/lib/Tooling/CompilationDatabase.cpp
</pre></div>
</div>
<p>If you’re using vim, it’s convenient to have clang-check integrated. Put
this into your <code class="docutils literal notranslate"><span class="pre">.vimrc</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>function! ClangCheckImpl(cmd)
  if &amp;autowrite | wall | endif
  echo &quot;Running &quot; . a:cmd . &quot; ...&quot;
  let l:output = system(a:cmd)
  cexpr l:output
  cwindow
  let w:quickfix_title = a:cmd
  if v:shell_error != 0
    cc
  endif
  let g:clang_check_last_cmd = a:cmd
endfunction

function! ClangCheck()
  let l:filename = expand(&#39;%&#39;)
  if l:filename =~ &#39;\.\(cpp\|cxx\|cc\|c\)$&#39;
    call ClangCheckImpl(&quot;clang-check &quot; . l:filename)
  elseif exists(&quot;g:clang_check_last_cmd&quot;)
    call ClangCheckImpl(g:clang_check_last_cmd)
  else
    echo &quot;Can&#39;t detect file&#39;s compilation arguments and no previous clang-check invocation!&quot;
  endif
endfunction

nmap &lt;silent&gt; &lt;F5&gt; :call ClangCheck()&lt;CR&gt;&lt;CR&gt;
</pre></div>
</div>
<p>When editing a .cpp/.cxx/.cc/.c file, hit F5 to reparse the file. In
case the current file has a different extension (for example, .h), F5
will re-run the last clang-check invocation made from this vim instance
(if any). The output will go into the error window, which is opened
automatically when clang-check finds errors, and can be re-opened with
<code class="docutils literal notranslate"><span class="pre">:cope</span></code>.</p>
<p>Other <code class="docutils literal notranslate"><span class="pre">clang-check</span></code> options that can be useful when working with clang
AST:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-ast-print</span></code> — Build ASTs and then pretty-print them.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-ast-dump</span></code> — Build ASTs and then debug dump them.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-ast-dump-filter=&lt;string&gt;</span></code> — Use with <code class="docutils literal notranslate"><span class="pre">-ast-dump</span></code> or <code class="docutils literal notranslate"><span class="pre">-ast-print</span></code> to
dump/print only AST declaration nodes having a certain substring in a
qualified name. Use <code class="docutils literal notranslate"><span class="pre">-ast-list</span></code> to list all filterable declaration node
names.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-ast-list</span></code> — Build ASTs and print the list of declaration node qualified
names.</p></li>
</ul>
<p>Examples:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang-check<span class="w"> </span>tools/clang/tools/clang-check/ClangCheck.cpp<span class="w"> </span>-ast-dump<span class="w"> </span>-ast-dump-filter<span class="w"> </span>ActionFactory::newASTConsumer
<span class="go">Processing: tools/clang/tools/clang-check/ClangCheck.cpp.</span>
<span class="go">Dumping ::ActionFactory::newASTConsumer:</span>
<span class="go">clang::ASTConsumer *newASTConsumer() (CompoundStmt 0x44da290 &lt;/home/alexfh/local/llvm/tools/clang/tools/clang-check/ClangCheck.cpp:64:40, line:72:3&gt;</span>
<span class="go">  (IfStmt 0x44d97c8 &lt;line:65:5, line:66:45&gt;</span>
<span class="go">    &lt;&lt;&lt;NULL&gt;&gt;&gt;</span>
<span class="go">      (ImplicitCastExpr 0x44d96d0 &lt;line:65:9&gt; &#39;_Bool&#39; &lt;UserDefinedConversion&gt;</span>
<span class="go">...</span>
<span class="gp">$ </span>clang-check<span class="w"> </span>tools/clang/tools/clang-check/ClangCheck.cpp<span class="w"> </span>-ast-print<span class="w"> </span>-ast-dump-filter<span class="w"> </span>ActionFactory::newASTConsumer
<span class="go">Processing: tools/clang/tools/clang-check/ClangCheck.cpp.</span>
<span class="go">Printing &lt;anonymous namespace&gt;::ActionFactory::newASTConsumer:</span>
<span class="go">clang::ASTConsumer *newASTConsumer() {</span>
<span class="go">    if (this-&gt;ASTList.operator _Bool())</span>
<span class="go">        return clang::CreateASTDeclNodeLister();</span>
<span class="go">    if (this-&gt;ASTDump.operator _Bool())</span>
<span class="go">        return clang::CreateASTDumper(nullptr /*Dump to stdout.*/,</span>
<span class="go">                                      this-&gt;ASTDumpFilter);</span>
<span class="go">    if (this-&gt;ASTPrint.operator _Bool())</span>
<span class="go">        return clang::CreateASTPrinter(&amp;llvm::outs(), this-&gt;ASTDumpFilter);</span>
<span class="go">    return new clang::ASTConsumer();</span>
<span class="go">}</span>
</pre></div>
</div>
</section>
<section id="using-ninja-build-system">
<h2>Using Ninja Build System<a class="headerlink" href="#using-ninja-build-system" title="Link to this heading">¶</a></h2>
<p>Optionally you can use the <a class="reference external" href="https://ninja-build.org/">Ninja</a> build system instead of make. It is
aimed at making your builds faster.  Currently this step will require
building Ninja from sources.</p>
<p>To take advantage of using Clang Tools along with Ninja build you need
at least CMake 2.8.9.</p>
<p>Clone the Ninja git repository and build Ninja from sources:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>git<span class="w"> </span>clone<span class="w"> </span>git://github.com/martine/ninja.git
<span class="gp">$ </span><span class="nb">cd</span><span class="w"> </span>ninja/
<span class="gp">$ </span>./bootstrap.py
</pre></div>
</div>
<p>This will result in a single binary <code class="docutils literal notranslate"><span class="pre">ninja</span></code> in the current directory.
It doesn’t require installation and can just be copied to any location
inside <code class="docutils literal notranslate"><span class="pre">$PATH</span></code>, say <code class="docutils literal notranslate"><span class="pre">/usr/local/bin/</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>sudo<span class="w"> </span>cp<span class="w"> </span>ninja<span class="w"> </span>/usr/local/bin/
<span class="gp">$ </span>sudo<span class="w"> </span>chmod<span class="w"> </span>a+rx<span class="w"> </span>/usr/local/bin/ninja
</pre></div>
</div>
<p>After doing all of this, you’ll need to generate Ninja build files for
LLVM with CMake. You need to make a build directory and run CMake from
it:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>mkdir<span class="w"> </span>your/build/directory
<span class="gp">$ </span><span class="nb">cd</span><span class="w"> </span>your/build/directory
<span class="gp">$ </span>cmake<span class="w"> </span>-G<span class="w"> </span>Ninja<span class="w"> </span>-DCMAKE_EXPORT_COMPILE_COMMANDS<span class="o">=</span>ON<span class="w"> </span>path/to/llvm/sources
</pre></div>
</div>
<p>If you want to use clang instead of GCC, you can add
<code class="docutils literal notranslate"><span class="pre">-DCMAKE_C_COMPILER=/path/to/clang</span> <span class="pre">-DCMAKE_CXX_COMPILER=/path/to/clang++</span></code>.
You can also use <code class="docutils literal notranslate"><span class="pre">ccmake</span></code>, which provides a curses interface to configure
CMake variables in an interactive manner.</p>
<p>As a result, the new <code class="docutils literal notranslate"><span class="pre">compile_commands.json</span></code> file should appear in the
current directory. You should link it to the LLVM source tree so that
Clang Tooling is able to use it:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ln<span class="w"> </span>-s<span class="w"> </span><span class="nv">$PWD</span>/compile_commands.json<span class="w"> </span>path/to/llvm/source/
</pre></div>
</div>
<p>Now you are ready to build and test LLVM using Ninja:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ninja<span class="w"> </span>check-all
</pre></div>
</div>
<p>Other target names can be used in the same way as with make.</p>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="LibASTImporter.html">ASTImporter: Merging Clang ASTs</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="JSONCompilationDatabase.html">JSON Compilation Database Format Specification</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2007-2026, The Clang Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>