
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Source Level Debugging with LLVM &#8212; LLVM 22.1.0-rc3 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/llvm-theme.css?v=96924833" />
    <script src="_static/documentation_options.js?v=b417f315"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Debug Info Assignment Tracking" href="AssignmentTracking.html" />
    <link rel="prev" title="RISC-V Vector Extension" href="RISCV/RISCVVectorExtension.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="AssignmentTracking.html" title="Debug Info Assignment Tracking"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="RISCV/RISCVVectorExtension.html" title="RISC-V Vector Extension"
             accesskey="P">previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" accesskey="U">User Guides</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Source Level Debugging with LLVM</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="https://llvm.org/docs/UserGuides.html">User Guides</a></li>
    <li><a href="https://llvm.org/docs/Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/Contributing.html">Contributing to LLVM</a></li>
    <li><a href="https://llvm.org/docs/HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#discord">Discord</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/FAQ.html">FAQ</a></li>
    <li><a href="https://llvm.org/docs/Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project/">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/SourceLevelDebugging.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="source-level-debugging-with-llvm">
<h1>Source Level Debugging with LLVM<a class="headerlink" href="#source-level-debugging-with-llvm" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id11">Introduction</a></p>
<ul>
<li><p><a class="reference internal" href="#philosophy-behind-llvm-debugging-information" id="id12">Philosophy behind LLVM debugging information</a></p></li>
<li><p><a class="reference internal" href="#debug-information-consumers" id="id13">Debug information consumers</a></p></li>
<li><p><a class="reference internal" href="#debug-information-and-optimizations" id="id14">Debug information and optimizations</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#variables-and-variable-fragments" id="id15">Variables and Variable Fragments</a></p></li>
<li><p><a class="reference internal" href="#debugging-information-format" id="id16">Debugging information format</a></p>
<ul>
<li><p><a class="reference internal" href="#debug-records" id="id17">Debug Records</a></p>
<ul>
<li><p><a class="reference internal" href="#dbg-declare" id="id18"><code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code></a></p></li>
<li><p><a class="reference internal" href="#dbg-value" id="id19"><code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code></a></p></li>
<li><p><a class="reference internal" href="#dbg-declare-value" id="id20"><code class="docutils literal notranslate"><span class="pre">#dbg_declare_value</span></code></a></p></li>
<li><p><a class="reference internal" href="#dbg-assign" id="id21"><code class="docutils literal notranslate"><span class="pre">#dbg_assign</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#debugger-intrinsic-functions" id="id22">Debugger intrinsic functions</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-dbg-declare" id="id23"><code class="docutils literal notranslate"><span class="pre">llvm.dbg.declare</span></code></a></p></li>
<li><p><a class="reference internal" href="#llvm-dbg-value" id="id24"><code class="docutils literal notranslate"><span class="pre">llvm.dbg.value</span></code></a></p></li>
<li><p><a class="reference internal" href="#llvm-dbg-assign" id="id25"><code class="docutils literal notranslate"><span class="pre">llvm.dbg.assign</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#diexpression" id="id26">DIExpression</a></p>
<ul>
<li><p><a class="reference internal" href="#dwarf-opcodes" id="id27">DWARF Opcodes</a></p></li>
<li><p><a class="reference internal" href="#internal-opcodes" id="id28">Internal Opcodes</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#object-lifetimes-and-scoping" id="id29">Object lifetimes and scoping</a></p></li>
<li><p><a class="reference internal" href="#object-lifetime-in-optimized-code" id="id30">Object lifetime in optimized code</a></p></li>
<li><p><a class="reference internal" href="#how-variable-location-metadata-is-transformed-during-codegen" id="id31">How variable location metadata is transformed during CodeGen</a></p>
<ul>
<li><p><a class="reference internal" href="#variable-locations-in-instruction-selection-and-mir" id="id32">Variable locations in Instruction Selection and MIR</a></p></li>
<li><p><a class="reference internal" href="#instruction-scheduling" id="id33">Instruction Scheduling</a></p></li>
<li><p><a class="reference internal" href="#variable-locations-during-register-allocation" id="id34">Variable locations during Register Allocation</a></p></li>
<li><p><a class="reference internal" href="#livedebugvalues-expansion-of-variable-locations" id="id35"><code class="docutils literal notranslate"><span class="pre">LiveDebugValues</span></code> expansion of variable locations</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#c-c-front-end-specific-debug-information" id="id36">C/C++ front-end specific debug information</a></p>
<ul>
<li><p><a class="reference internal" href="#c-c-source-file-information" id="id37">C/C++ source file information</a></p></li>
<li><p><a class="reference internal" href="#c-c-global-variable-information" id="id38">C/C++ global variable information</a></p></li>
<li><p><a class="reference internal" href="#c-c-function-information" id="id39">C/C++ function information</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#c-specific-debug-information" id="id40">C++ specific debug information</a></p>
<ul>
<li><p><a class="reference internal" href="#c-special-member-functions-information" id="id41">C++ special member functions information</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#fortran-specific-debug-information" id="id42">Fortran specific debug information</a></p>
<ul>
<li><p><a class="reference internal" href="#fortran-function-information" id="id43">Fortran function information</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id7" id="id44">Debugging information format</a></p>
<ul>
<li><p><a class="reference internal" href="#debugging-information-extension-for-objective-c-properties" id="id45">Debugging Information Extension for Objective-C Properties</a></p>
<ul>
<li><p><a class="reference internal" href="#id8" id="id46">Introduction</a></p></li>
<li><p><a class="reference internal" href="#proposal" id="id47">Proposal</a></p></li>
<li><p><a class="reference internal" href="#new-dwarf-tags" id="id48">New DWARF Tags</a></p></li>
<li><p><a class="reference internal" href="#new-dwarf-attributes" id="id49">New DWARF Attributes</a></p></li>
<li><p><a class="reference internal" href="#new-dwarf-constants" id="id50">New DWARF Constants</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#name-accelerator-tables" id="id51">Name Accelerator Tables</a></p>
<ul>
<li><p><a class="reference internal" href="#id9" id="id52">Introduction</a></p></li>
<li><p><a class="reference internal" href="#hash-tables" id="id53">Hash Tables</a></p>
<ul>
<li><p><a class="reference internal" href="#standard-hash-tables" id="id54">Standard Hash Tables</a></p></li>
<li><p><a class="reference internal" href="#name-hash-tables" id="id55">Name Hash Tables</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#details" id="id56">Details</a></p>
<ul>
<li><p><a class="reference internal" href="#header-layout" id="id57">Header Layout</a></p></li>
<li><p><a class="reference internal" href="#fixed-lookup" id="id58">Fixed Lookup</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id10" id="id59">Contents</a></p></li>
<li><p><a class="reference internal" href="#language-extensions-and-file-format-changes" id="id60">Language Extensions and File Format Changes</a></p>
<ul>
<li><p><a class="reference internal" href="#objective-c-extensions" id="id61">Objective-C Extensions</a></p></li>
<li><p><a class="reference internal" href="#mach-o-changes" id="id62">Mach-O Changes</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#codeview-debug-info-format" id="id63">CodeView Debug Info Format</a></p>
<ul>
<li><p><a class="reference internal" href="#format-background" id="id64">Format Background</a></p></li>
<li><p><a class="reference internal" href="#working-with-codeview" id="id65">Working with CodeView</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>This document is the central repository for all information pertaining to debug
information in LLVM.  It describes the <a class="reference internal" href="#format"><span class="std std-ref">actual format that the LLVM debug
information takes</span></a>, which is useful for those interested in creating
front-ends or dealing directly with the information.  Further, this document
provides specific examples of what debug information for C/C++ looks like.</p>
<section id="philosophy-behind-llvm-debugging-information">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Philosophy behind LLVM debugging information</a><a class="headerlink" href="#philosophy-behind-llvm-debugging-information" title="Link to this heading">¶</a></h3>
<p>The idea of the LLVM debugging information is to capture how the important
pieces of the source-language’s Abstract Syntax Tree map onto LLVM code.
Several design aspects have shaped the solution that appears here.  The
important ones are:</p>
<ul class="simple">
<li><p>Debugging information should have very little impact on the rest of the
compiler.  No transformations, analyses, or code generators should need to
be modified because of debugging information.</p></li>
<li><p>LLVM optimizations should interact in <a class="reference internal" href="#intro-debugopt"><span class="std std-ref">well-defined and easily described
ways</span></a> with the debugging information.</p></li>
<li><p>Because LLVM is designed to support arbitrary programming languages,
LLVM-to-LLVM tools should not need to know anything about the semantics of
the source-level-language.</p></li>
<li><p>Source-level languages are often <strong>widely</strong> different from one another.
LLVM should not put any restrictions on the flavor of the source-language,
and the debugging information should work with any language.</p></li>
<li><p>With code generator support, it should be possible to use an LLVM compiler
to compile a program to native machine code and standard debugging
formats.  This allows compatibility with traditional machine-code level
debuggers, like GDB or DBX.</p></li>
</ul>
<p>The approach used by the LLVM implementation is to use a small set of
<a class="reference internal" href="#debug-records"><span class="std std-ref">debug records</span></a> to define a mapping
between LLVM program objects and the source-level objects.  The description of
the source-level program is maintained in LLVM metadata in an
<a class="reference internal" href="#ccxx-frontend"><span class="std std-ref">implementation-defined format</span></a> (the C/C++ front-end
currently uses working draft 7 of the <a class="reference external" href="http://www.eagercon.com/dwarf/dwarf3std.htm">DWARF 3 standard</a>).</p>
<p>When a program is being debugged, a debugger interacts with the user and turns
the stored debug information into source-language specific information.  As
such, a debugger must be aware of the source-language, and is thus tied to a
specific language or family of languages.</p>
</section>
<section id="debug-information-consumers">
<span id="intro-consumers"></span><h3><a class="toc-backref" href="#id13" role="doc-backlink">Debug information consumers</a><a class="headerlink" href="#debug-information-consumers" title="Link to this heading">¶</a></h3>
<p>The role of debug information is to provide meta information normally stripped
away during the compilation process.  This meta information provides an LLVM
user a relationship between generated code and the original program source
code.</p>
<p>Currently, there are two backend consumers of debug info: DwarfDebug and
CodeViewDebug. DwarfDebug produces DWARF suitable for use with GDB, LLDB, and
other DWARF-based debuggers. <a class="reference internal" href="#codeview"><span class="std std-ref">CodeViewDebug</span></a> produces CodeView,
the Microsoft debug info format, which is usable with Microsoft debuggers such
as Visual Studio and WinDBG. LLVM’s debug information format is mostly derived
from and inspired by DWARF, but it is feasible to translate into other target
debug info formats such as STABS.</p>
<p>SamplePGO (also known as <a class="reference external" href="https://gcc.gnu.org/wiki/AutoFDO">AutoFDO</a>)
is a variant of profile-guided optimizations which uses hardware sampling based
profilers to collect branch frequency data with low overhead in production
environments. It relies on debug information to associate profile information
with LLVM IR which is then used to guide optimization heuristics. Maintaining
deterministic and distinct source locations is necessary to maximize the
accuracy of mapping hardware sample counts to LLVM IR. For example, DWARF
<a class="reference external" href="https://wiki.dwarfstd.org/Path_Discriminators.md">discriminators</a> allow
SamplePGO to distinguish between multiple paths of execution which map to the
same source line.</p>
<p>It would also be reasonable to use debug information to feed profiling tools
for analysis of generated code, or, tools for reconstructing the original
source from generated code.</p>
</section>
<section id="debug-information-and-optimizations">
<span id="intro-debugopt"></span><h3><a class="toc-backref" href="#id14" role="doc-backlink">Debug information and optimizations</a><a class="headerlink" href="#debug-information-and-optimizations" title="Link to this heading">¶</a></h3>
<p>An extremely high priority of LLVM debugging information is to make it interact
well with optimizations and analysis.  In particular, the LLVM debug
information provides the following guarantees:</p>
<ul class="simple">
<li><p>LLVM debug information <strong>always provides information to accurately read
the source-level state of the program</strong>, regardless of which LLVM
optimizations have been run. <a class="reference internal" href="HowToUpdateDebugInfo.html"><span class="doc">How to Update Debug Info: A Guide for LLVM Pass Authors</span></a> specifies how debug
info should be updated in various kinds of code transformations to avoid
breaking this guarantee, and how to preserve as much useful debug info as
possible.  Note that some optimizations may impact the ability to modify the
current state of the program with a debugger, such as setting program
variables, or calling functions that have been deleted.</p></li>
<li><p>As desired, LLVM optimizations can be upgraded to be aware of debugging
information, allowing them to update the debugging information as they
perform aggressive optimizations.  This means that, with effort, the LLVM
optimizers could optimize debug code just as well as non-debug code.</p></li>
<li><p>LLVM debug information does not prevent optimizations from
happening (for example inlining, basic block reordering/merging/cleanup,
tail duplication, etc).</p></li>
<li><p>LLVM debug information is automatically optimized along with the rest of
the program, using existing facilities.  For example, duplicate
information is automatically merged by the linker, and unused information
is automatically removed.</p></li>
</ul>
<p>Basically, the debug information allows you to compile a program with
“<code class="docutils literal notranslate"><span class="pre">-O0</span> <span class="pre">-g</span></code>” and get full debug information, allowing you to arbitrarily modify
the program as it executes from a debugger.  Compiling a program with
“<code class="docutils literal notranslate"><span class="pre">-O3</span> <span class="pre">-g</span></code>” gives you full debug information that is always available and
accurate for reading (e.g., you get accurate stack traces despite tail call
elimination and inlining), but you might lose the ability to modify the program
and call functions which were optimized out of the program, or inlined away
completely.</p>
<p>The <a class="reference internal" href="TestSuiteMakefileGuide.html"><span class="doc">LLVM test-suite</span></a> provides a framework to
test the optimizer’s handling of debugging information.  It can be run like
this:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>%<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>llvm/projects/test-suite/MultiSource/Benchmarks<span class="w">  </span><span class="c1"># or some other level</span>
%<span class="w"> </span>make<span class="w"> </span><span class="nv">TEST</span><span class="o">=</span>dbgopt
</pre></div>
</div>
<p>This will test impact of debugging information on optimization passes.  If
debugging information influences optimization passes then it will be reported
as a failure.  See <a class="reference internal" href="TestingGuide.html"><span class="doc">LLVM Testing Infrastructure Guide</span></a> for more information on LLVM test
infrastructure and how to run various tests.</p>
</section>
</section>
<section id="variables-and-variable-fragments">
<span id="id1"></span><h2><a class="toc-backref" href="#id15" role="doc-backlink">Variables and Variable Fragments</a><a class="headerlink" href="#variables-and-variable-fragments" title="Link to this heading">¶</a></h2>
<p>In this document “variable” refers generally to any source language object
which can have a value, including at least:</p>
<ul class="simple">
<li><p>Variables</p></li>
<li><p>Constants</p></li>
<li><p>Formal parameters</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no special provision for “true” constants in LLVM today, and
they are instead treated as local or global variables.</p>
</div>
<p>A variable is represented by a <a class="reference internal" href="LangRef.html#dilocalvariable"><span class="std std-ref">local variable</span></a> or
<a class="reference internal" href="LangRef.html#diglobalvariable"><span class="std std-ref">global variable</span></a> metadata node.</p>
<p>A “variable fragment” (or just “fragment”) is a contiguous span of bits of a
variable.</p>
<p>A <a class="reference internal" href="#debug-records"><span class="std std-ref">debug record</span></a> which refers to a <a class="reference internal" href="#diexpression"><span class="std std-ref">DIExpression</span></a>
ending with a <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_fragment</span></code> operation describes a fragment of the
variable it refers to.</p>
<p>The operands of the <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_fragment</span></code> operation encode the bit offset of
the fragment relative to the start of the variable, and the size of the
fragment in bits, respectively.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_fragment</span></code> operation acts only to encode the fragment
information, and does not have an effect on the semantics of the expression.</p>
</div>
</section>
<section id="debugging-information-format">
<span id="format"></span><h2><a class="toc-backref" href="#id16" role="doc-backlink">Debugging information format</a><a class="headerlink" href="#debugging-information-format" title="Link to this heading">¶</a></h2>
<p>LLVM debugging information has been carefully designed to make it possible for
the optimizer to optimize the program and debugging information without
necessarily having to know anything about debugging information.  In
particular, the use of metadata avoids duplicated debugging information from
the beginning, and the global dead code elimination pass automatically deletes
debugging information for a function if it decides to delete the function.</p>
<p>To do this, most of the debugging information (descriptors for types,
variables, functions, source files, etc) is inserted by the language front-end
in the form of LLVM metadata.</p>
<p>Debug information is designed to be agnostic about the target debugger and
debugging information representation (e.g. DWARF/Stabs/etc).  It uses a generic
pass to decode the information that represents variables, types, functions,
namespaces, etc: this allows for arbitrary source-language semantics and
type-systems to be used, as long as there is a module written for the target
debugger to interpret the information.</p>
<p>To provide basic functionality, the LLVM debugger does have to make some
assumptions about the source-level language being debugged, though it keeps
these to a minimum.  The only common features that the LLVM debugger assumes
exist are <a class="reference internal" href="LangRef.html#difile"><span class="std std-ref">source files</span></a>, and <a class="reference internal" href="LangRef.html#diglobalvariable"><span class="std std-ref">program objects</span></a>.  These abstract objects are used by a debugger to form
stack traces, show information about local variables, etc.</p>
<p>This section of the documentation first describes the representation aspects
common to any source-language.  <a class="reference internal" href="#ccxx-frontend"><span class="std std-ref">C/C++ front-end specific debug information</span></a> describes the data layout
conventions used by the C and C++ front-ends.</p>
<p>Debug information descriptors are <a class="reference internal" href="LangRef.html#specialized-metadata"><span class="std std-ref">specialized metadata nodes</span></a>, first-class subclasses of <code class="docutils literal notranslate"><span class="pre">Metadata</span></code>.</p>
<p>There are two models for defining the values of source variables at different
states of the program and tracking these values through optimization and code
generation: <a class="reference internal" href="#debug-records"><span class="std std-ref">debug records</span></a>, the current default, and
<a class="reference internal" href="#format-common-intrinsics"><span class="std std-ref">intrinsic function calls</span></a>, which are
non-default but currently supported for backwards compatibility - though these
two models must never be mixed within an IR module. For an explanation of why
we changed to the new model, how it works, and guidance on how to update old
code or IR to use debug records, see the <a class="reference external" href="RemoveDIsDebugInfo.html">RemoveDIs</a>
document.</p>
<section id="debug-records">
<span id="id2"></span><h3><a class="toc-backref" href="#id17" role="doc-backlink">Debug Records</a><a class="headerlink" href="#debug-records" title="Link to this heading">¶</a></h3>
<p>Debug records define the value that a source variable has during execution of
the program; they appear interleaved with instructions, although they are not
instructions themselves and have no effect on the code generated by the
compiler.</p>
<p>LLVM uses several types of debug records to define source variables. The
common syntax for these records is:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="err">#dbg_</span><span class="p">&lt;</span><span class="k">kind</span><span class="p">&gt;([&lt;</span><span class="err">arg</span><span class="p">&gt;,</span><span class="w"> </span><span class="p">]*</span><span class="w"> </span><span class="p">&lt;</span><span class="err">DILocation</span><span class="p">&gt;)</span>
<span class="c">; Using the intrinsic model, the above is equivalent to:</span>
<span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="err">llvm</span><span class="p">.</span><span class="err">dbg</span><span class="p">.&lt;</span><span class="k">kind</span><span class="p">&gt;([</span><span class="k">metadata</span><span class="w"> </span><span class="p">&lt;</span><span class="err">arg</span><span class="p">&gt;,</span><span class="w"> </span><span class="p">]*),</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="p">&lt;</span><span class="err">DILocation</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Debug records are always printed with an extra level of indentation compared
to instructions, and always have the prefix <cite>#dbg_</cite> and a list of
comma-separated arguments in parentheses, as with a <cite>call</cite>.</p>
<section id="dbg-declare">
<h4><a class="toc-backref" href="#id18" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code></a><a class="headerlink" href="#dbg-declare" title="Link to this heading">¶</a></h4>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="err">#dbg_</span><span class="k">declare</span><span class="p">([</span><span class="err">Value|MDNode</span><span class="p">],</span><span class="w"> </span><span class="err">DILocalVariable</span><span class="p">,</span><span class="w"> </span><span class="err">DIExpression</span><span class="p">,</span><span class="w"> </span><span class="err">DILocation</span><span class="p">)</span>
</pre></div>
</div>
<p>This record provides information about a local element (e.g., variable). The
first argument is an SSA <code class="docutils literal notranslate"><span class="pre">ptr</span></code> value corresponding to a variable address, and
is typically a static <code class="docutils literal notranslate"><span class="pre">alloca</span></code> in the function entry block.  The second
argument is a <a class="reference internal" href="LangRef.html#dilocalvariable"><span class="std std-ref">local variable</span></a> containing a description
of the variable.  The third argument is a <a class="reference internal" href="#diexpression"><span class="std std-ref">complex expression</span></a>. The fourth argument is a <a class="reference internal" href="LangRef.html#dilocation"><span class="std std-ref">source location</span></a>.
A <code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code> record describes the <em>address</em> of a source variable.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv">%i.addr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
<span class="w">  </span><span class="err">#dbg_</span><span class="k">declare</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%i.addr</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!2</span><span class="p">)</span>
<span class="c">; ...</span>
<span class="nv nv-Anonymous">!1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nv">!DILocalVariable</span><span class="p">(</span><span class="nl">name:</span><span class="w"> </span><span class="s">&quot;i&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="c">; int i</span>
<span class="nv nv-Anonymous">!2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nv">!DILocation</span><span class="p">(...)</span>
<span class="c">; ...</span>
<span class="nv">%buffer</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="p">[</span><span class="m">256</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i8</span><span class="p">],</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">8</span>
<span class="c">; The address of i is buffer+64.</span>
<span class="w">  </span><span class="err">#dbg_</span><span class="k">declare</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%buffer</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(</span><span class="err">DW_OP_plus</span><span class="p">,</span><span class="w"> </span><span class="m">64</span><span class="p">),</span><span class="w"> </span><span class="nv nv-Anonymous">!4</span><span class="p">)</span>
<span class="c">; ...</span>
<span class="nv nv-Anonymous">!3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nv">!DILocalVariable</span><span class="p">(</span><span class="nl">name:</span><span class="w"> </span><span class="s">&quot;i&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="c">; int i</span>
<span class="nv nv-Anonymous">!4</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nv">!DILocation</span><span class="p">(...)</span>
</pre></div>
</div>
<p>A frontend should generate exactly one <code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code> record at the point
of declaration of a source variable. Optimization passes that fully promote the
variable from memory to SSA values will replace this record with possibly
multiple <code class="docutils literal notranslate"><span class="pre">#dbg_value`</span></code> records. Passes that delete stores are effectively
partial promotion, and they will insert a mix of <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> records to
track the source variable value when it is available. After optimization, there
may be multiple <code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code> records describing the program points where
the variables lives in memory. All calls for the same concrete source variable
must agree on the memory location.</p>
</section>
<section id="dbg-value">
<h4><a class="toc-backref" href="#id19" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code></a><a class="headerlink" href="#dbg-value" title="Link to this heading">¶</a></h4>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="err">#dbg_value</span><span class="p">([</span><span class="err">Value|DIArgList|MDNode</span><span class="p">],</span><span class="w"> </span><span class="err">DILocalVariable</span><span class="p">,</span><span class="w"> </span><span class="err">DIExpression</span><span class="p">,</span><span class="w"> </span><span class="err">DILocation</span><span class="p">)</span>
</pre></div>
</div>
<p>This record provides information when a user source variable is set to a new
value.  The first argument is the new value. The second argument is a
<a class="reference internal" href="LangRef.html#dilocalvariable"><span class="std std-ref">local variable</span></a> containing a description of the
variable.  The third argument is a <a class="reference internal" href="#diexpression"><span class="std std-ref">complex expression</span></a>.
The fourth argument is a <a class="reference internal" href="LangRef.html#dilocation"><span class="std std-ref">source location</span></a>.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> record describes the <em>value</em> of a source variable
directly, not its address.  Note that the value operand of this intrinsic may
be indirect (i.e, a pointer to the source variable), provided that interpreting
the complex expression derives the direct value.</p>
</section>
<section id="dbg-declare-value">
<h4><a class="toc-backref" href="#id20" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">#dbg_declare_value</span></code></a><a class="headerlink" href="#dbg-declare-value" title="Link to this heading">¶</a></h4>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="err">#dbg_declare_value</span><span class="p">([</span><span class="err">Value|MDNode</span><span class="p">],</span><span class="w"> </span><span class="err">DILocalVariable</span><span class="p">,</span><span class="w"> </span><span class="err">DIExpression</span><span class="p">,</span><span class="w"> </span><span class="err">DILocation</span><span class="p">)</span>
</pre></div>
</div>
<p>This record provides information about a local element (e.g., variable). The
first argument is used to compute the value of the variable throughout the
entire function.  The second argument is a
<a class="reference internal" href="LangRef.html#dilocalvariable"><span class="std std-ref">local variable</span></a> containing a description of the
variable. The third argument is a <a class="reference internal" href="#diexpression"><span class="std std-ref">complex expression</span></a>. The
foruth argument is a <a class="reference internal" href="LangRef.html#dilocation"><span class="std std-ref">source location</span></a>. A
<code class="docutils literal notranslate"><span class="pre">#dbg_declare_value</span></code> record describes describes the <em>value</em> of a source
variable directly, not its address. The difference between a <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> and
a <code class="docutils literal notranslate"><span class="pre">#dbg_declare_value</span></code> is that, just like a <code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code>, a frontend
should generate exactly one <code class="docutils literal notranslate"><span class="pre">#dbg_declare_value</span></code> record. The idea is to have
<code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code> guarantees but be able to describe a value rather than the
address of a value.</p>
</section>
<section id="dbg-assign">
<h4><a class="toc-backref" href="#id21" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">#dbg_assign</span></code></a><a class="headerlink" href="#dbg-assign" title="Link to this heading">¶</a></h4>
<div class="toctree-wrapper compound">
</div>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="err">#dbg_assign</span><span class="p">(</span><span class="w"> </span><span class="p">[</span><span class="err">Value|DIArgList|MDNode</span><span class="p">]</span><span class="w"> </span><span class="err">Value</span><span class="p">,</span>
<span class="w">             </span><span class="err">DILocalVariable</span><span class="w"> </span><span class="err">Variable</span><span class="p">,</span>
<span class="w">             </span><span class="err">DIExpression</span><span class="w"> </span><span class="err">ValueExpression</span><span class="p">,</span>
<span class="w">             </span><span class="err">DIAssignID</span><span class="w"> </span><span class="err">ID</span><span class="p">,</span>
<span class="w">             </span><span class="p">[</span><span class="err">Value|MDNode</span><span class="p">]</span><span class="w"> </span><span class="err">Address</span><span class="p">,</span>
<span class="w">             </span><span class="err">DIExpression</span><span class="w"> </span><span class="err">AddressExpression</span><span class="p">,</span>
<span class="w">             </span><span class="err">DILocation</span><span class="w"> </span><span class="err">SourceLocation</span><span class="w"> </span><span class="p">)</span>
</pre></div>
</div>
<p>This record marks the position in IR where a source assignment occurred. It
encodes the value of the variable. It references the store, if any, that
performs the assignment, and the destination address.</p>
<p>The first three arguments are the same as for a <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code>. The fourth
argument is a <code class="docutils literal notranslate"><span class="pre">DIAssignID</span></code> used to reference a store. The fifth is the
destination of the store, the sixth is a <a class="reference internal" href="#diexpression"><span class="std std-ref">complex expression</span></a> that modifies it, and the seventh is a <a class="reference internal" href="LangRef.html#dilocation"><span class="std std-ref">source location</span></a>.</p>
<p>See <a class="reference internal" href="AssignmentTracking.html"><span class="doc">Debug Info Assignment Tracking</span></a> for more info.</p>
</section>
</section>
<section id="debugger-intrinsic-functions">
<h3><a class="toc-backref" href="#id22" role="doc-backlink">Debugger intrinsic functions</a><a class="headerlink" href="#debugger-intrinsic-functions" title="Link to this heading">¶</a></h3>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>These intrinsics are deprecated, please use <a class="reference internal" href="#debug-records"><span class="std std-ref">debug records</span></a> instead. For more details see <a class="reference external" href="RemoveDIsDebugInfo.html">RemoveDIs</a>.</p>
</div>
<p id="format-common-intrinsics">In intrinsic-mode, LLVM uses several intrinsic functions (name prefixed with “<code class="docutils literal notranslate"><span class="pre">llvm.dbg</span></code>”) to
track source local variables through optimization and code generation. These
intrinsic functions each correspond to one of the debug records above, with a
few syntactic differences: each argument to a debugger intrinsic must be wrapped
as metadata, meaning it must be prefixed with <code class="docutils literal notranslate"><span class="pre">metadata</span></code>, and the
<code class="docutils literal notranslate"><span class="pre">DILocation</span></code> argument in each record must be a metadata attachment to the
call instruction, meaning it appears after the argument list with the prefix
<code class="docutils literal notranslate"><span class="pre">!dbg</span></code>.</p>
<section id="llvm-dbg-declare">
<h4><a class="toc-backref" href="#id23" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">llvm.dbg.declare</span></code></a><a class="headerlink" href="#llvm-dbg-declare" title="Link to this heading">¶</a></h4>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.dbg.declare</span><span class="p">(</span><span class="k">metadata</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="p">)</span>
</pre></div>
</div>
<p>This intrinsic is equivalent to <code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code>:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="err">#dbg_</span><span class="k">declare</span><span class="p">(</span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%i.addr</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!2</span><span class="p">)</span>
<span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.dbg.declare</span><span class="p">(</span><span class="k">metadata</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%i.addr</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span>
<span class="w">                            </span><span class="k">metadata</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">()),</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!2</span>
</pre></div>
</div>
</section>
<section id="llvm-dbg-value">
<h4><a class="toc-backref" href="#id24" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">llvm.dbg.value</span></code></a><a class="headerlink" href="#llvm-dbg-value" title="Link to this heading">¶</a></h4>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.dbg.value</span><span class="p">(</span><span class="k">metadata</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="p">)</span>
</pre></div>
</div>
<p>This intrinsic is equivalent to <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code>:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!2</span><span class="p">)</span>
<span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.dbg.value</span><span class="p">(</span><span class="k">metadata</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span>
<span class="w">                          </span><span class="k">metadata</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">()),</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!2</span>
</pre></div>
</div>
</section>
<section id="llvm-dbg-assign">
<h4><a class="toc-backref" href="#id25" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">llvm.dbg.assign</span></code></a><a class="headerlink" href="#llvm-dbg-assign" title="Link to this heading">¶</a></h4>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.dbg.assign</span><span class="p">(</span><span class="k">metadata</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="p">)</span>
</pre></div>
</div>
<p>This intrinsic is equivalent to <code class="docutils literal notranslate"><span class="pre">#dbg_assign</span></code>:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="err">#dbg_assign</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!2</span><span class="p">,</span>
<span class="w">              </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%i.addr</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="p">)</span>
<span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.dbg.assign</span><span class="p">(</span>
<span class="w">  </span><span class="k">metadata</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="k">metadata</span><span class="w"> </span><span class="nv nv-Anonymous">!2</span><span class="p">,</span>
<span class="w">  </span><span class="k">metadata</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%i.addr</span><span class="p">,</span><span class="w"> </span><span class="k">metadata</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="k">metadata</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="p">),</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span>
</pre></div>
</div>
</section>
</section>
<section id="diexpression">
<span id="id4"></span><h3><a class="toc-backref" href="#id26" role="doc-backlink">DIExpression</a><a class="headerlink" href="#diexpression" title="Link to this heading">¶</a></h3>
<p>Debug expressions are represented as <a class="reference internal" href="LangRef.html#specialized-metadata"><span class="std std-ref">Specialized Metadata Nodes</span></a>.</p>
<p>Debug expressions are interpreted left-to-right: start by pushing the
value/address operand of the record onto a stack, then repeatedly push and
evaluate opcodes from the <code class="docutils literal notranslate"><span class="pre">DIExpression</span></code> until the final variable description
is produced.</p>
<p>The opcodes available in these expressions are described in
<a class="reference internal" href="#dwarf-opcodes"><span class="std std-ref">DWARF Opcodes</span></a> and <a class="reference internal" href="#internal-opcodes"><span class="std std-ref">Internal Opcodes</span></a>.</p>
<p>DWARF specifies three kinds of simple location descriptions: register, memory,
and implicit location descriptions.  Note that a location description is
defined over certain ranges of a program, i.e the location of a variable may
change over the course of the program. Register and memory location
descriptions describe the <em>concrete location</em> of a source variable (in the
sense that a debugger might modify its value), whereas <em>implicit locations</em>
describe merely the actual <em>value</em> of a source variable which might not exist
in registers or in memory (see <code class="docutils literal notranslate"><span class="pre">DW_OP_stack_value</span></code>).</p>
<p>A <code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code> record describes an indirect value (the address) of a source
variable. The first operand of the record must be an address of some kind. A
<code class="docutils literal notranslate"><span class="pre">DIExpression</span></code> operand to the record refines this address to produce a
concrete location for the source variable.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> record describes the direct value of a source variable. The
first operand of the record may be a direct or indirect value. A
<code class="docutils literal notranslate"><span class="pre">DIExpression</span></code> operand to the record refines the first operand to produce a
direct value. For example, if the first operand is an indirect value, it may be
necessary to insert <code class="docutils literal notranslate"><span class="pre">DW_OP_deref</span></code> into the <code class="docutils literal notranslate"><span class="pre">DIExpression</span></code> in order to
produce a valid debug record.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A <code class="docutils literal notranslate"><span class="pre">DIExpression</span></code> is interpreted in the same way regardless of which kind
of debug record it’s attached to.</p>
<p><code class="docutils literal notranslate"><span class="pre">DIExpression</span></code>s are always printed and parsed inline; they can never be
referenced by an ID (e.g. <code class="docutils literal notranslate"><span class="pre">!1</span></code>).</p>
</div>
<section id="dwarf-opcodes">
<span id="id5"></span><h4><a class="toc-backref" href="#id27" role="doc-backlink">DWARF Opcodes</a><a class="headerlink" href="#dwarf-opcodes" title="Link to this heading">¶</a></h4>
<p>When possible LLVM reuses DWARF opcodes and gives them identical semantics in
LLVM expressions as in DWARF expressions. The current supported opcode
vocabulary is limited, but includes at least:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_deref</span></code> dereferences the top of the expression stack.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_plus</span></code> pops the last two entries from the expression stack, adds
them together and pushes the result to the expression stack.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_minus</span></code> pops the last two entries from the expression stack, subtracts
the last entry from the second last entry and appends the result to the
expression stack.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_plus_uconst,</span> <span class="pre">93</span></code> adds <code class="docutils literal notranslate"><span class="pre">93</span></code> to the value on top of the stack.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_swap</span></code> swaps top two stack entries.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_xderef</span></code> provides extended dereference mechanism. The entry at the top
of the stack is treated as an address. The second stack entry is treated as an
address space identifier. The two entries are popped and then an
implementation defined value is pushed on the stack.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_stack_value</span></code> may appear at most once in an expression, and must be
the last opcode if <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_fragment</span></code> is not present, or the second last
opcode if <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_fragment</span></code> is present. It pops the top value of the
expression stack and makes an implicit value location with that value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_breg</span></code> (or <code class="docutils literal notranslate"><span class="pre">DW_OP_bregx</span></code>) represents a content on the provided
signed offset of the specified register. The opcode is only generated by the
<code class="docutils literal notranslate"><span class="pre">AsmPrinter</span></code> pass to describe call site parameter value which requires an
expression over two registers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code> pushes the address of the object which can then
serve as a descriptor in subsequent calculation. This opcode can be used to
calculate bounds of a Fortran allocatable array which has array descriptors.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_over</span></code> duplicates the entry currently second in the stack at the top
of the stack. This opcode can be used to calculate bounds of a Fortran
assumed rank array which has rank known at run time and current dimension
number is implicitly first element of the stack.</p></li>
</ul>
</section>
<section id="internal-opcodes">
<span id="id6"></span><h4><a class="toc-backref" href="#id28" role="doc-backlink">Internal Opcodes</a><a class="headerlink" href="#internal-opcodes" title="Link to this heading">¶</a></h4>
<p>Where the DWARF equivalent is not suitable, or no DWARF equivalent exists, LLVM
defines internal-only opcodes which have no direct analog in DWARF.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Some opcodes do not influence the final DWARF expression directly, instead
encoding information logically belonging to the debug records which use
them.</p>
</div>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_fragment,</span> <span class="pre">&lt;offset&gt;,</span> <span class="pre">&lt;size&gt;</span></code> may appear at most once in an
expression, and must be the last opcode. It specifies the bit offset and bit
size of the variable fragment being described by the record or intrinsic
using the expression. Note that contrary to <code class="docutils literal notranslate"><span class="pre">DW_OP_bit_piece</span></code>, the offset
is describing the location within the described source variable. At DWARF
generation time all fragments for the same variable are collected together
and DWARF <code class="docutils literal notranslate"><span class="pre">DW_OP_piece</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_OP_bit_piece</span></code> opcodes are used to
describe a composite with pieces corresponding to the fragments. (This does
not affect the semantics of the expression containing it.) -
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_convert,</span> <span class="pre">16,</span> <span class="pre">DW_ATE_signed</span></code> specifies a bit size and encoding
(<code class="docutils literal notranslate"><span class="pre">16</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_ATE_signed</span></code> here, respectively) to which the top of the
expression stack is to be converted. Maps into a <code class="docutils literal notranslate"><span class="pre">DW_OP_convert</span></code> operation
that references a base type constructed from the supplied values. -
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_tag_offset,</span> <span class="pre">tag_offset</span></code> specifies that a memory tag should be
optionally applied to the pointer. The memory tag is derived from the given
tag offset in an implementation-defined manner. (This does not affect the
semantics of the expression containing it.) - <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_entry_value,</span> <span class="pre">N</span></code>
evaluates a sub-expression as-if it were evaluated upon entry to the current
call frame.</p>
<p>The sub-expression replaces the operations which comprise it, i.e. all such
operations are evaluated only in the frame entry context.</p>
<p>The sub-expression begins with the operation which immediately precedes
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_entry_value,</span> <span class="pre">N</span></code> in the <code class="docutils literal notranslate"><span class="pre">DIExpression</span></code>. If no such operation
exists (i.e. the expression begins with <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_entry_value,</span> <span class="pre">N</span></code>), the
implicit operation which pushes the first debug argument of the containing
marker/pseudo is used instead. The value <code class="docutils literal notranslate"><span class="pre">N</span></code> must always be at least <code class="docutils literal notranslate"><span class="pre">1</span></code>,
as this first operation cannot be omitted and is counted in <code class="docutils literal notranslate"><span class="pre">N</span></code>.</p>
<p>The rest of the sub-expression comprises the <code class="docutils literal notranslate"><span class="pre">(N</span> <span class="pre">-</span> <span class="pre">1)</span></code> operations following
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_entry_value,</span> <span class="pre">N</span></code> in the <code class="docutils literal notranslate"><span class="pre">DIExpression</span></code>.</p>
<p>Due to framework limitations:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">N</span></code> must not be greater than <code class="docutils literal notranslate"><span class="pre">1</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">N</span></code> must equal
<code class="docutils literal notranslate"><span class="pre">1</span></code>, and the sub-expression comprises only the operation immediately
preceding <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_entry_value,</span> <span class="pre">N</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_entry_value,</span> <span class="pre">N</span></code> must be either the first operation of a
<code class="docutils literal notranslate"><span class="pre">DIExpression</span></code> or the second operation if the expression begins with
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_arg,</span> <span class="pre">0</span></code>.</p></li>
<li><p>The first operation must refer to a register value.</p></li>
</ul>
</div></blockquote>
<p>Taken together, these limitations mean that <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_entry_value</span></code> can
only currently be used to push the value a single register had on entry to
the current stack frame.</p>
<p>For example, <code class="docutils literal notranslate"><span class="pre">!DIExpression(DW_OP_LLVM_arg,</span> <span class="pre">0,</span> <span class="pre">DW_OP_LLVM_entry_value,</span> <span class="pre">1,</span>
<span class="pre">DW_OP_LLVM_arg,</span> <span class="pre">1,</span> <span class="pre">DW_OP_plus,</span> <span class="pre">DW_OP_stack_value)</span></code> specifies an expression
where the entry value of the first argument to the <code class="docutils literal notranslate"><span class="pre">DIExpression</span></code> is added
to the non-entry value of the second argument, and the result is used as the
value for an implicit value location.</p>
<p>When targeting DWARF, a <code class="docutils literal notranslate"><span class="pre">DBG_VALUE(reg,</span> <span class="pre">...,</span>
<span class="pre">DIExpression(DW_OP_LLVM_entry_value,</span> <span class="pre">1,</span> <span class="pre">...)</span></code> is lowered to
<code class="docutils literal notranslate"><span class="pre">DW_OP_entry_value</span> <span class="pre">[reg],</span> <span class="pre">...</span></code>, which pushes the value <code class="docutils literal notranslate"><span class="pre">reg</span></code> had upon
frame entry onto the DWARF expression stack.</p>
<p>Because <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_entry_value</span></code> is currently limited to registers, it is
usually used in MIR, but it is also allowed in LLVM IR when targeting a
<a class="reference internal" href="LangRef.html#swiftasync"><span class="std std-ref">swiftasync</span></a> argument. The operation is introduced by:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">LiveDebugValues</span></code> pass, which applies it to function parameters that
are unmodified throughout the function. Support is limited to simple
register location descriptions, or as indirect locations (e.g.,
parameters passed-by-value to a callee via a pointer to a temporary copy
made in the caller).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AsmPrinter</span></code> pass when a call site parameter value
(<code class="docutils literal notranslate"><span class="pre">DW_AT_call_site_parameter_value</span></code>) is represented as entry value of
the parameter.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CoroSplit</span></code> pass, which may move variables from <code class="docutils literal notranslate"><span class="pre">alloca</span></code>s into a
coroutine frame. If the coroutine frame is a
<a class="reference internal" href="LangRef.html#swiftasync"><span class="std std-ref">swiftasync</span></a> argument, the variable is described with
an <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_entry_value</span></code> operation.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_implicit_pointer</span></code> It specifies the dereferenced value. It can
be used to represent pointer variables which are optimized out but the value
it points to is known. This operator is required as it is different than
DWARF operator <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> in representation and specification
(number and types of operands) and later can not be used as multiple level.</p>
<p>Examples using <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_implicit_pointer</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>IR for &quot;*ptr = 4;&quot;
--------------
  #dbg_value(i32 4, !17, !DIExpression(DW_OP_LLVM_implicit_pointer), !20)
!17 = !DILocalVariable(name: &quot;ptr&quot;, scope: !12, file: !3, line: 5,
                       type: !18)
!18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !19, size: 64)
!19 = !DIBasicType(name: &quot;int&quot;, size: 32, encoding: DW_ATE_signed)
!20 = !DILocation(line: 10, scope: !12)

IR for &quot;**ptr = 4;&quot;
--------------
  #dbg_value(i32 4, !17,
    !DIExpression(DW_OP_LLVM_implicit_pointer, DW_OP_LLVM_implicit_pointer),
    !21)
!17 = !DILocalVariable(name: &quot;ptr&quot;, scope: !12, file: !3, line: 5,
                       type: !18)
!18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !19, size: 64)
!19 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !20, size: 64)
!20 = !DIBasicType(name: &quot;int&quot;, size: 32, encoding: DW_ATE_signed)
!21 = !DILocation(line: 10, scope: !12)
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_arg,</span> <span class="pre">N</span></code> is used in debug intrinsics that refer to more than one
value, such as one that calculates the sum of two registers. This is always
used in combination with an ordered list of values, such that
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_arg,</span> <span class="pre">N</span></code> refers to the <code class="docutils literal notranslate"><span class="pre">N</span></code><sup>th</sup> element in that list.
For example, <code class="docutils literal notranslate"><span class="pre">!DIExpression(DW_OP_LLVM_arg,</span> <span class="pre">0,</span> <span class="pre">DW_OP_LLVM_arg,</span> <span class="pre">1,</span>
<span class="pre">DW_OP_minus,</span> <span class="pre">DW_OP_stack_value)</span></code> used with the list <code class="docutils literal notranslate"><span class="pre">(%reg1,</span> <span class="pre">%reg2)</span></code> would
evaluate to an implicit value location that has the value of
<code class="docutils literal notranslate"><span class="pre">%reg1</span> <span class="pre">-</span> <span class="pre">reg2</span></code>. This list of values should be provided by the containing
intrinsic/instruction.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_extract_bits_sext,</span> <span class="pre">16,</span> <span class="pre">8,</span></code> specifies the offset and size
(<code class="docutils literal notranslate"><span class="pre">16</span></code> and <code class="docutils literal notranslate"><span class="pre">8</span></code> here, respectively) of bits that are to be extracted and
sign-extended from the value at the top of the expression stack. If the top of
the expression stack is a memory location then these bits are extracted from
the value pointed to by that memory location. Maps into a <code class="docutils literal notranslate"><span class="pre">DW_OP_shl</span></code>
followed by <code class="docutils literal notranslate"><span class="pre">DW_OP_shra</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_extract_bits_zext</span></code> behaves similarly to
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_extract_bits_sext</span></code>, but zero-extends instead of sign-extending.
Maps into a <code class="docutils literal notranslate"><span class="pre">DW_OP_shl</span></code> followed by <code class="docutils literal notranslate"><span class="pre">DW_OP_shr</span></code>.</p></li>
</ul>
</section>
</section>
</section>
<section id="object-lifetimes-and-scoping">
<h2><a class="toc-backref" href="#id29" role="doc-backlink">Object lifetimes and scoping</a><a class="headerlink" href="#object-lifetimes-and-scoping" title="Link to this heading">¶</a></h2>
<p>In many languages, the local variables in functions can have their lifetimes or
scopes limited to a subset of a function.  In the C family of languages, for
example, variables are only live (readable and writable) within the source
block that they are defined in.  In functional languages, values are only
readable after they have been defined.  Though this is a very obvious concept,
it is non-trivial to model in LLVM, because it has no notion of scoping in this
sense, and does not want to be tied to a language’s scoping rules.</p>
<p>In order to handle this, the LLVM debug format uses the metadata attached to
LLVM instructions to encode line number and scoping information.  Consider the
following C fragment, for example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="mf">2.</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">21</span><span class="p">;</span>
<span class="mf">3.</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">22</span><span class="p">;</span>
<span class="mf">4.</span><span class="w">    </span><span class="p">{</span>
<span class="mf">5.</span><span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">Z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">23</span><span class="p">;</span>
<span class="mf">6.</span><span class="w">      </span><span class="n">Z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="p">;</span>
<span class="mf">7.</span><span class="w">    </span><span class="p">}</span>
<span class="mf">8.</span><span class="w">    </span><span class="n">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Y</span><span class="p">;</span>
<span class="mf">9.</span><span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>Compiled to LLVM, this function would be represented like this:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>; Function Attrs: nounwind ssp uwtable
define void @foo() #0 !dbg !4 {
entry:
  %X = alloca i32, align 4
  %Y = alloca i32, align 4
  %Z = alloca i32, align 4
    #dbg_declare(ptr %X, !11, !DIExpression(), !13)
  store i32 21, i32* %X, align 4, !dbg !13
    #dbg_declare(ptr %Y, !14, !DIExpression(), !15)
  store i32 22, i32* %Y, align 4, !dbg !15
    #dbg_declare(ptr %Z, !16, !DIExpression(), !18)
  store i32 23, i32* %Z, align 4, !dbg !18
  %0 = load i32, i32* %X, align 4, !dbg !20
  store i32 %0, i32* %Z, align 4, !dbg !21
  %1 = load i32, i32* %Y, align 4, !dbg !22
  store i32 %1, i32* %X, align 4, !dbg !23
  ret void, !dbg !24
}

attributes #0 = { nounwind ssp uwtable &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;frame-pointer&quot;=&quot;all&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;use-soft-float&quot;=&quot;false&quot; }
attributes #1 = { nounwind readnone }

!llvm.dbg.cu = !{!0}
!llvm.module.flags = !{!7, !8, !9}
!llvm.ident = !{!10}

!0 = !DICompileUnit(language: DW_LANG_C99, file: !1, producer: &quot;clang version 3.7.0 (trunk 231150) (llvm/trunk 231154)&quot;, isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, retainedTypes: !2, subprograms: !3, globals: !2, imports: !2)
!1 = !DIFile(filename: &quot;/dev/stdin&quot;, directory: &quot;/Users/dexonsmith/data/llvm/debug-info&quot;)
!2 = !{}
!3 = !{!4}
!4 = distinct !DISubprogram(name: &quot;foo&quot;, scope: !1, file: !1, line: 1, type: !5, isLocal: false, isDefinition: true, scopeLine: 1, isOptimized: false, retainedNodes: !2)
!5 = !DISubroutineType(types: !6)
!6 = !{null}
!7 = !{i32 2, !&quot;Dwarf Version&quot;, i32 2}
!8 = !{i32 2, !&quot;Debug Info Version&quot;, i32 3}
!9 = !{i32 1, !&quot;PIC Level&quot;, i32 2}
!10 = !{!&quot;clang version 3.7.0 (trunk 231150) (llvm/trunk 231154)&quot;}
!11 = !DILocalVariable(name: &quot;X&quot;, scope: !4, file: !1, line: 2, type: !12)
!12 = !DIBasicType(name: &quot;int&quot;, size: 32, align: 32, encoding: DW_ATE_signed)
!13 = !DILocation(line: 2, column: 9, scope: !4)
!14 = !DILocalVariable(name: &quot;Y&quot;, scope: !4, file: !1, line: 3, type: !12)
!15 = !DILocation(line: 3, column: 9, scope: !4)
!16 = !DILocalVariable(name: &quot;Z&quot;, scope: !18, file: !1, line: 5, type: !12)
!17 = distinct !DILexicalBlock(scope: !4, file: !1, line: 4, column: 5)
!18 = !DILocation(line: 5, column: 11, scope: !17)
!29 = !DILocation(line: 6, column: 11, scope: !17)
!20 = !DILocation(line: 6, column: 9, scope: !17)
!21 = !DILocation(line: 8, column: 9, scope: !4)
!22 = !DILocation(line: 8, column: 7, scope: !4)
!23 = !DILocation(line: 9, column: 3, scope: !4)
</pre></div>
</div>
<p>This example illustrates a few important details about LLVM debugging
information.  In particular, it shows how the <code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code> record and
location information, which are attached to an instruction, are applied
together to allow a debugger to analyze the relationship between statements,
variable definitions, and the code used to implement the function.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="err">#dbg_</span><span class="k">declare</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%X</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!11</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!13</span><span class="p">)</span>
<span class="c">; [debug line = 2:9] [debug variable = X]</span>
</pre></div>
</div>
<p>The first record <code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code> encodes debugging information for the
variable <code class="docutils literal notranslate"><span class="pre">X</span></code>.  The location <code class="docutils literal notranslate"><span class="pre">!13</span></code> at the end of the record provides
scope information for the variable <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>!13 = !DILocation(line: 2, column: 9, scope: !4)
!4 = distinct !DISubprogram(name: &quot;foo&quot;, scope: !1, file: !1, line: 1, type: !5,
                            isLocal: false, isDefinition: true, scopeLine: 1,
                            isOptimized: false, retainedNodes: !2)
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">!13</span></code> is metadata providing <a class="reference internal" href="LangRef.html#dilocation"><span class="std std-ref">location information</span></a>.
In this example, scope is encoded by <code class="docutils literal notranslate"><span class="pre">!4</span></code>, a <a class="reference internal" href="LangRef.html#disubprogram"><span class="std std-ref">subprogram descriptor</span></a>.  This way the location information parameter to the records
indicates that the variable <code class="docutils literal notranslate"><span class="pre">X</span></code> is declared at line number 2 at a function
level scope in function <code class="docutils literal notranslate"><span class="pre">foo</span></code>.</p>
<p>Now, let’s take another example.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="err">#dbg_</span><span class="k">declare</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%Z</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!16</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!18</span><span class="p">)</span>
<span class="c">; [debug line = 5:11] [debug variable = Z]</span>
</pre></div>
</div>
<p>The third record <code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code> encodes debugging information for
variable <code class="docutils literal notranslate"><span class="pre">Z</span></code>.  The metadata <code class="docutils literal notranslate"><span class="pre">!18</span></code> at the end of the record provides
scope information for the variable <code class="docutils literal notranslate"><span class="pre">Z</span></code>.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>!17 = distinct !DILexicalBlock(scope: !4, file: !1, line: 4, column: 5)
!18 = !DILocation(line: 5, column: 11, scope: !17)
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">!18</span></code> indicates that <code class="docutils literal notranslate"><span class="pre">Z</span></code> is declared at line number 5 and column
number 11 inside of lexical scope <code class="docutils literal notranslate"><span class="pre">!17</span></code>.  The lexical scope itself resides
inside of subprogram <code class="docutils literal notranslate"><span class="pre">!4</span></code> described above.</p>
<p>The scope information attached to each instruction provides a straightforward
way to find instructions covered by a scope.</p>
</section>
<section id="object-lifetime-in-optimized-code">
<h2><a class="toc-backref" href="#id30" role="doc-backlink">Object lifetime in optimized code</a><a class="headerlink" href="#object-lifetime-in-optimized-code" title="Link to this heading">¶</a></h2>
<p>In the example above, every variable assignment uniquely corresponds to a
memory store to the variable’s position on the stack. However, in heavily
optimized code LLVM promotes most variables into SSA values, which can
eventually be placed in physical registers or memory locations. To track SSA
values through compilation, when objects are promoted to SSA values a
<code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> record is created for each assignment, recording the
variable’s new location. Compared with the <code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code> record:</p>
<ul>
<li><p>A <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> terminates the effects that any preceding records have on
any common bits of a common variable.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The current implementation generally terminates the effect of every
record in its entirety if any of its effects would be terminated, rather
than carrying forward the effect of previous records for non-overlapping
bits as it would be permitted to do by this definition. This is allowed
just as dropping any debug information at any point in the compilation is
allowed.</p>
<p>One exception to this is <a class="reference internal" href="AssignmentTracking.html"><span class="doc">Debug Info Assignment Tracking</span></a> where certain
memory-based locations are carried forward partially in some situations.</p>
</div>
</li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code>’s position in the IR defines where in the instruction
stream the variable’s value changes.</p></li>
<li><p>Operands can be constants, indicating the variable is assigned a
constant value.</p></li>
</ul>
<p>Care must be taken to update <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> records when optimization
passes alter or move instructions and blocks – the developer could observe such
changes reflected in the value of variables when debugging the program. For any
execution of the optimized program, the set of variable values presented to the
developer by the debugger should not show a state that would never have existed
in the execution of the unoptimized program, given the same input. Doing so
risks misleading the developer by reporting a state that does not exist,
damaging their understanding of the optimized program and undermining their
trust in the debugger.</p>
<p>Sometimes perfectly preserving variable locations is not possible, often when a
redundant calculation is optimized out. In such cases, a <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code>
with operand <code class="docutils literal notranslate"><span class="pre">poison</span></code> should be used, to terminate earlier variable locations
and let the debugger present <code class="docutils literal notranslate"><span class="pre">optimized</span> <span class="pre">out</span></code> to the developer. Withholding
these potentially stale variable values from the developer diminishes the
amount of available debug information, but increases the reliability of the
remaining information.</p>
<p>To illustrate some potential issues, consider the following example:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@foo</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!4</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cond</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%truebr</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%falsebr</span>
<span class="nl">truebr:</span>
<span class="w">  </span><span class="nv">%tval</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar</span><span class="p">,</span><span class="w"> </span><span class="m">1</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%tval</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!4</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%g1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@gazonk</span><span class="p">()</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%exit</span>
<span class="nl">falsebr:</span>
<span class="w">  </span><span class="nv">%fval</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar</span><span class="p">,</span><span class="w"> </span><span class="m">2</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%fval</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!4</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%g2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@gazonk</span><span class="p">()</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%exit</span>
<span class="nl">exit:</span>
<span class="w">  </span><span class="nv">%merge</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%tval</span><span class="p">,</span><span class="w"> </span><span class="nv">%truebr</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%fval</span><span class="p">,</span><span class="w"> </span><span class="nv">%falsebr</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="nv">%g</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%g1</span><span class="p">,</span><span class="w"> </span><span class="nv">%truebr</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%g2</span><span class="p">,</span><span class="w"> </span><span class="nv">%falsebr</span><span class="w"> </span><span class="p">]</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%merge</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!4</span><span class="p">)</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%g</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!4</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%plusten</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%merge</span><span class="p">,</span><span class="w"> </span><span class="m">10</span>
<span class="w">  </span><span class="nv">%toret</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%plusten</span><span class="p">,</span><span class="w"> </span><span class="nv">%g</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%toret</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!4</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%toret</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Containing two source-level variables in <code class="docutils literal notranslate"><span class="pre">!1</span></code> and <code class="docutils literal notranslate"><span class="pre">!3</span></code>. The function could,
perhaps, be optimized into the following code:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@foo</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%g</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@gazonk</span><span class="p">()</span>
<span class="w">  </span><span class="nv">%addoper</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cond</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">11</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">12</span>
<span class="w">  </span><span class="nv">%plusten</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar</span><span class="p">,</span><span class="w"> </span><span class="nv">%addoper</span>
<span class="w">  </span><span class="nv">%toret</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%plusten</span><span class="p">,</span><span class="w"> </span><span class="nv">%g</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%toret</span>
<span class="p">}</span>
</pre></div>
</div>
<p>What <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> records should be placed to represent the original variable
locations in this code? Unfortunately the second, third, and fourth
<code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code>s for <code class="docutils literal notranslate"><span class="pre">!1</span></code> in the source function have had their operands
(<code class="docutils literal notranslate"><span class="pre">%tval</span></code>, <code class="docutils literal notranslate"><span class="pre">%fval</span></code>, <code class="docutils literal notranslate"><span class="pre">%merge</span></code>) optimized out. Assuming we cannot recover
them, we might consider this placement of <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code>s:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@foo</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!4</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%g</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@gazonk</span><span class="p">()</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%g</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!4</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%addoper</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cond</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">11</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">12</span>
<span class="w">  </span><span class="nv">%plusten</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar</span><span class="p">,</span><span class="w"> </span><span class="nv">%addoper</span>
<span class="w">  </span><span class="nv">%toret</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%plusten</span><span class="p">,</span><span class="w"> </span><span class="nv">%g</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%toret</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!4</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%toret</span>
<span class="p">}</span>
</pre></div>
</div>
<p>However, this will cause <code class="docutils literal notranslate"><span class="pre">!3</span></code> to have the return value of <code class="docutils literal notranslate"><span class="pre">&#64;gazonk()</span></code> at
the same time as <code class="docutils literal notranslate"><span class="pre">!1</span></code> has the constant value zero – a pair of assignments
that never occurred in the unoptimized program. To avoid this, we must terminate
the range that <code class="docutils literal notranslate"><span class="pre">!1</span></code> has the constant value assignment by inserting an poison
<code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> before the <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> for <code class="docutils literal notranslate"><span class="pre">!3</span></code>:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@foo</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!2</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%g</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@gazonk</span><span class="p">()</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="k">poison</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!2</span><span class="p">)</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%g</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!2</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%addoper</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cond</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">11</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">12</span>
<span class="w">  </span><span class="nv">%plusten</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar</span><span class="p">,</span><span class="w"> </span><span class="nv">%addoper</span>
<span class="w">  </span><span class="nv">%toret</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%plusten</span><span class="p">,</span><span class="w"> </span><span class="nv">%g</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%toret</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!1</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!2</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%toret</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There are a few other <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> configurations that mean it terminates
dominating location definitions without adding a new location. The complete
list is:</p>
<ul class="simple">
<li><p>Any location operand is <code class="docutils literal notranslate"><span class="pre">poison</span></code> (or <code class="docutils literal notranslate"><span class="pre">undef</span></code>).</p></li>
<li><p>Any location operand is an empty metadata tuple (<code class="docutils literal notranslate"><span class="pre">!{}</span></code>) (which cannot
occur in a <code class="docutils literal notranslate"><span class="pre">!DIArgList</span></code>).</p></li>
<li><p>There are no location operands (empty <code class="docutils literal notranslate"><span class="pre">DIArgList</span></code>) and the <code class="docutils literal notranslate"><span class="pre">DIExpression</span></code>
is empty.</p></li>
</ul>
<p>This class of <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> that kills variable locations is called a “kill
<code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code>” or “kill location”, and for legacy reasons the term “<code class="docutils literal notranslate"><span class="pre">undef</span>
<span class="pre">#dbg_value</span></code>” may be used in existing code. The <code class="docutils literal notranslate"><span class="pre">DbgVariableIntrinsic</span></code>
methods <code class="docutils literal notranslate"><span class="pre">isKillLocation</span></code> and <code class="docutils literal notranslate"><span class="pre">setKillLocation</span></code> should be used where
possible rather than inspecting location operands directly to check or set
whether a <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> is a kill location.</p>
<p>In general, if any <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> has its operand optimized out and cannot be
recovered, then a kill <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> is necessary to terminate earlier
variable locations. Additional kill <code class="docutils literal notranslate"><span class="pre">#dbg_values</span></code> may be necessary when the
debugger can observe re-ordering of assignments.</p>
</section>
<section id="how-variable-location-metadata-is-transformed-during-codegen">
<h2><a class="toc-backref" href="#id31" role="doc-backlink">How variable location metadata is transformed during CodeGen</a><a class="headerlink" href="#how-variable-location-metadata-is-transformed-during-codegen" title="Link to this heading">¶</a></h2>
<p>LLVM preserves debug information throughout mid-level and backend passes,
ultimately producing a mapping between source-level information and
instruction ranges. This
is relatively straightforward for line number information, as mapping
instructions to line numbers is a simple association. For variable locations
however the story is more complex. As each <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> record
represents a source-level assignment of a value to a source variable, the
debug records effectively embed a small imperative program
within the LLVM IR. By the end of CodeGen, this becomes a mapping from each
variable to their machine locations over ranges of instructions.
From IR to object emission, the major transformations which affect variable
location fidelity are:</p>
<ol class="arabic simple">
<li><p>Instruction Selection</p></li>
<li><p>Register allocation</p></li>
<li><p>Block layout</p></li>
</ol>
<p>each of which is discussed below. In addition, instruction scheduling can
significantly change the ordering of the program, and occurs in a number of
different passes.</p>
<p>Some variable locations are not transformed during CodeGen. Stack locations
specified by <code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code> are valid and unchanging for the entire duration
of the function, and are recorded in a simple <code class="docutils literal notranslate"><span class="pre">MachineFunction</span></code> table.
Location changes in the prologue and epilogue of a function are also ignored:
frame setup and destruction may take several instructions, require a
disproportionate amount of debugging information in the output binary to
describe, and should be stepped over by debuggers anyway.</p>
<section id="variable-locations-in-instruction-selection-and-mir">
<h3><a class="toc-backref" href="#id32" role="doc-backlink">Variable locations in Instruction Selection and MIR</a><a class="headerlink" href="#variable-locations-in-instruction-selection-and-mir" title="Link to this heading">¶</a></h3>
<p>Instruction selection creates a MIR function from an IR function, and just as
it transforms <code class="docutils literal notranslate"><span class="pre">intermediate</span></code> instructions into machine instructions, so must
<code class="docutils literal notranslate"><span class="pre">intermediate</span></code> variable locations become machine variable locations. Within
IR, variable locations are always identified by a Value, but in MIR there can
be different types of variable locations. In addition, some IR locations become
unavailable, for example if the operation of multiple IR instructions are
combined into one machine instruction (such as multiply-and-accumulate) then
intermediate Values are lost. To track variable locations through instruction
selection, they are first separated into locations that do not depend on code
generation (constants, stack locations, allocated virtual registers) and those
that do. For those that do, debug metadata is attached to <code class="docutils literal notranslate"><span class="pre">SDNode</span></code>s in
<code class="docutils literal notranslate"><span class="pre">SelectionDAG</span></code>s. After instruction selection has occurred and a MIR function
is created, if the <code class="docutils literal notranslate"><span class="pre">SDNode</span></code> associated with debug metadata is allocated a
virtual register, that virtual register is used as the variable location. If
the <code class="docutils literal notranslate"><span class="pre">SDNode</span></code> is folded into a machine instruction or otherwise transformed
into a non-register, the variable location becomes unavailable.</p>
<p>Locations that are unavailable are treated as if they have been optimized out:
in IR the location would be assigned <code class="docutils literal notranslate"><span class="pre">undef</span></code> by a debug record, and in MIR
the equivalent location is used.</p>
<p>After MIR locations are assigned to each variable, machine pseudo-instructions
corresponding to each <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> record are inserted. There are two
forms of this type of instruction.</p>
<p>The first form, <code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code>, appears thus:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DBG_VALUE %1, $noreg, !123, !DIExpression()
</pre></div>
</div>
<dl class="simple">
<dt>And has the following operands:</dt><dd><ul class="simple">
<li><p>The first operand can record the variable location as a register,
a frame index, an immediate, or the base address register if the original
debug record referred to memory. <code class="docutils literal notranslate"><span class="pre">$noreg</span></code> indicates the variable
location is undefined, equivalent to an <code class="docutils literal notranslate"><span class="pre">undef</span> <span class="pre">#dbg_value</span></code> operand.</p></li>
<li><p>The type of the second operand indicates whether the variable location is
directly referred to by the <code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code>, or whether it is indirect. The
<code class="docutils literal notranslate"><span class="pre">$noreg</span></code> register signifies the former, an immediate operand (0) the
latter.</p></li>
<li><p>Operand 3 is the Variable field of the original debug record.</p></li>
<li><p>Operand 4 is the Expression field of the original debug record.</p></li>
</ul>
</dd>
</dl>
<p>The second form, <code class="docutils literal notranslate"><span class="pre">DBG_VALUE_LIST</span></code>, appears thus:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DBG_VALUE_LIST !123, !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_plus), %1, %2
</pre></div>
</div>
<dl class="simple">
<dt>And has the following operands:</dt><dd><ul class="simple">
<li><p>The first operand is the Variable field of the original debug record.</p></li>
<li><p>The second operand is the Expression field of the original debug record.</p></li>
<li><p>Any number of operands, from the 3rd onwards, record a sequence of variable
location operands, which may take any of the same values as the first
operand of the <code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code> instruction above. These variable location
operands are inserted into the final DWARF Expression in positions indicated
by the <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_arg</span></code> operator in the <a class="reference internal" href="#diexpression"><span class="std std-ref">DIExpression</span></a>.</p></li>
</ul>
</dd>
</dl>
<p>The position at which the <code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code>s are inserted should correspond to the
positions of their matching <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> records in the IR block.  As with
optimization, LLVM aims to preserve the order in which variable assignments
occurred in the source program. However, <code class="docutils literal notranslate"><span class="pre">SelectionDAG</span></code> performs some
instruction scheduling, which can reorder assignments (discussed below).
Function parameter locations are moved to the beginning of the function if
they’re not already, to ensure they’re immediately available on function entry.</p>
<p>To demonstrate variable locations during instruction selection, consider
the following example:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@foo</span><span class="p">(</span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%addr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%bb1</span><span class="p">,</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span>

<span class="nl">bb1:</span><span class="w">                                              </span><span class="c">; preds = %bb1, %entry</span>
<span class="w">  </span><span class="nv">%bar.0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nv">%entry</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%add</span><span class="p">,</span><span class="w"> </span><span class="nv">%bb1</span><span class="w"> </span><span class="p">]</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar.0</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%addr1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">*</span><span class="nv">%addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="p">*</span><span class="nv">%addr1</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%loaded1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%addr1</span><span class="p">,</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span>
<span class="w">  </span><span class="nv">%addr2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">*</span><span class="nv">%addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar.0</span><span class="p">,</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="p">*</span><span class="nv">%addr2</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%loaded2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%addr2</span><span class="p">,</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span>
<span class="w">  </span><span class="nv">%add</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%bar.0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span>
<span class="w">    </span><span class="err">#dbg_value</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%add</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="p">,</span><span class="w"> </span><span class="nv">!DIExpression</span><span class="p">(),</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%added</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%loaded1</span><span class="p">,</span><span class="w"> </span><span class="nv">%loaded2</span>
<span class="w">  </span><span class="nv">%cond</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">ult</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%added</span><span class="p">,</span><span class="w"> </span><span class="nv">%bar.0</span><span class="p">,</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cond</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%bb1</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%bb2</span><span class="p">,</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span>

<span class="nl">bb2:</span><span class="w">                                              </span><span class="c">; preds = %bb1</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nv">!dbg</span><span class="w"> </span><span class="nv nv-Anonymous">!5</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If one compiles this IR with <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-o</span> <span class="pre">-</span> <span class="pre">-start-after=codegen-prepare</span> <span class="pre">-stop-after=expand-isel-pseudos</span> <span class="pre">-mtriple=x86_64--</span></code>, the following MIR is produced:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>bb.0.entry:
  successors: %bb.1(0x80000000)
  liveins: $rdi

  %2:gr64 = COPY $rdi
  %3:gr32 = MOV32r0 implicit-def dead $eflags
  DBG_VALUE 0, $noreg, !3, !DIExpression(), debug-location !5

bb.1.bb1:
  successors: %bb.1(0x7c000000), %bb.2(0x04000000)

  %0:gr32 = PHI %3, %bb.0, %1, %bb.1
  DBG_VALUE %0, $noreg, !3, !DIExpression(), debug-location !5
  DBG_VALUE %2, $noreg, !3, !DIExpression(DW_OP_plus_uconst, 4, DW_OP_stack_value), debug-location !5
  %4:gr32 = MOV32rm %2, 1, $noreg, 4, $noreg, debug-location !5 :: (load 4 from %ir.addr1)
  %5:gr64_nosp = MOVSX64rr32 %0, debug-location !5
  DBG_VALUE $noreg, $noreg, !3, !DIExpression(), debug-location !5
  %1:gr32 = INC32r %0, implicit-def dead $eflags, debug-location !5
  DBG_VALUE %1, $noreg, !3, !DIExpression(), debug-location !5
  %6:gr32 = ADD32rm %4, %2, 4, killed %5, 0, $noreg, implicit-def dead $eflags :: (load 4 from %ir.addr2)
  %7:gr32 = SUB32rr %6, %0, implicit-def $eflags, debug-location !5
  JB_1 %bb.1, implicit $eflags, debug-location !5
  JMP_1 %bb.2, debug-location !5

bb.2.bb2:
  %8:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %8, debug-location !5
  RET 0, $eax, debug-location !5
</pre></div>
</div>
<p>Observe first that there is a <code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code> instruction for every <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code>
record in the source IR, ensuring no source level assignments go missing.
Then consider the different ways in which variable locations have been recorded:</p>
<ul class="simple">
<li><p>For the first <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> an immediate operand is used to record a zero value.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> of the PHI instruction leads to a <code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code> of virtual register
<code class="docutils literal notranslate"><span class="pre">%0</span></code>.</p></li>
<li><p>The first GEP has its effect folded into the first load instruction
(as a 4-byte offset), but the variable location is salvaged by folding
the GEPs effect into the <code class="docutils literal notranslate"><span class="pre">DIExpression</span></code>.</p></li>
<li><p>The second GEP is also folded into the corresponding load. However, it is
insufficiently simple to be salvaged, and is emitted as a <code class="docutils literal notranslate"><span class="pre">$noreg</span></code>
<code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code>, indicating that the variable takes on an undefined location.</p></li>
<li><p>The final <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> has its Value placed in virtual register <code class="docutils literal notranslate"><span class="pre">%1</span></code>.</p></li>
</ul>
</section>
<section id="instruction-scheduling">
<h3><a class="toc-backref" href="#id33" role="doc-backlink">Instruction Scheduling</a><a class="headerlink" href="#instruction-scheduling" title="Link to this heading">¶</a></h3>
<p>A number of passes can reschedule instructions, notably instruction selection
and the pre-and-post RA machine schedulers. Instruction scheduling can
significantly change the nature of the program – in the (very unlikely) worst
case the instruction sequence could be completely reversed. In such
circumstances LLVM follows the principle applied to optimizations, that it is
better for the debugger not to display any state than a misleading state.
Thus, whenever instructions are advanced in order of execution, any
corresponding <code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code> is kept in its original position, and if an instruction
is delayed then the variable is given an undefined location for the duration
of the delay. To illustrate, consider this pseudo-MIR:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>%1:gr32 = MOV32rm %0, 1, $noreg, 4, $noreg, debug-location !5 :: (load 4 from %ir.addr1)
DBG_VALUE %1, $noreg, !1, !2
%4:gr32 = ADD32rr %3, %2, implicit-def dead $eflags
DBG_VALUE %4, $noreg, !3, !4
%7:gr32 = SUB32rr %6, %5, implicit-def dead $eflags
DBG_VALUE %7, $noreg, !5, !6
</pre></div>
</div>
<p>Imagine that the <code class="docutils literal notranslate"><span class="pre">SUB32rr</span></code> were moved forward to give us the following MIR:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>%7:gr32 = SUB32rr %6, %5, implicit-def dead $eflags
%1:gr32 = MOV32rm %0, 1, $noreg, 4, $noreg, debug-location !5 :: (load 4 from %ir.addr1)
DBG_VALUE %1, $noreg, !1, !2
%4:gr32 = ADD32rr %3, %2, implicit-def dead $eflags
DBG_VALUE %4, $noreg, !3, !4
DBG_VALUE %7, $noreg, !5, !6
</pre></div>
</div>
<p>In this circumstance LLVM would leave the MIR as shown above. Were we to move
the <code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code> of virtual register %7 upwards with the <code class="docutils literal notranslate"><span class="pre">SUB32rr</span></code>, we would re-order
assignments and introduce a new state of the program. Whereas with the solution
above, the debugger will see one fewer combination of variable values, because
<code class="docutils literal notranslate"><span class="pre">!3</span></code> and <code class="docutils literal notranslate"><span class="pre">!5</span></code> will change value at the same time. This is preferred over
misrepresenting the original program.</p>
<p>In comparison, if one sunk the <code class="docutils literal notranslate"><span class="pre">MOV32rm</span></code>, LLVM would produce the following:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DBG_VALUE $noreg, $noreg, !1, !2
%4:gr32 = ADD32rr %3, %2, implicit-def dead $eflags
DBG_VALUE %4, $noreg, !3, !4
%7:gr32 = SUB32rr %6, %5, implicit-def dead $eflags
DBG_VALUE %7, $noreg, !5, !6
%1:gr32 = MOV32rm %0, 1, $noreg, 4, $noreg, debug-location !5 :: (load 4 from %ir.addr1)
DBG_VALUE %1, $noreg, !1, !2
</pre></div>
</div>
<p>Here, to avoid presenting a state in which the first assignment to <code class="docutils literal notranslate"><span class="pre">!1</span></code>
disappears, the <code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code> at the top of the block assigns the variable the
undefined location, until its value is available at the end of the block where
an additional <code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code> is added. Were any other <code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code> for <code class="docutils literal notranslate"><span class="pre">!1</span></code> to occur
in the instructions that the <code class="docutils literal notranslate"><span class="pre">MOV32rm</span></code> was sunk past, the <code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code> for <code class="docutils literal notranslate"><span class="pre">%1</span></code>
would be dropped and the debugger would never observe it in the variable. This
accurately reflects that the value is not available during the corresponding
portion of the original program.</p>
</section>
<section id="variable-locations-during-register-allocation">
<h3><a class="toc-backref" href="#id34" role="doc-backlink">Variable locations during Register Allocation</a><a class="headerlink" href="#variable-locations-during-register-allocation" title="Link to this heading">¶</a></h3>
<p>To avoid debug instructions interfering with the register allocator, the
<code class="docutils literal notranslate"><span class="pre">LiveDebugVariables</span></code> pass extracts variable locations from a MIR function and
deletes the corresponding <code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code> instructions. Some localized copy
propagation is performed within blocks. After register allocation, the
<code class="docutils literal notranslate"><span class="pre">VirtRegRewriter</span></code> pass re-inserts <code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code> instructions in their
original positions, translating virtual register references into their physical
machine locations. To avoid encoding incorrect variable locations, in this pass
any <code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code> of a virtual register that is not live, is replaced by the
undefined location. The <code class="docutils literal notranslate"><span class="pre">LiveDebugVariables</span></code> may insert redundant
<code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code>s because of virtual register rewriting. These will be
subsequently removed by the <code class="docutils literal notranslate"><span class="pre">RemoveRedundantDebugValues</span></code> pass.</p>
</section>
<section id="livedebugvalues-expansion-of-variable-locations">
<h3><a class="toc-backref" href="#id35" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">LiveDebugValues</span></code> expansion of variable locations</a><a class="headerlink" href="#livedebugvalues-expansion-of-variable-locations" title="Link to this heading">¶</a></h3>
<p>After all optimizations have run and shortly before emission, the
<code class="docutils literal notranslate"><span class="pre">LiveDebugValue</span></code>s pass runs to achieve two aims:</p>
<ul class="simple">
<li><p>To propagate the location of variables through copies and register spills,</p></li>
<li><p>For every block, to record every valid variable location in that block.</p></li>
</ul>
<p>After this pass the <code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code> instruction changes meaning: rather than
corresponding to a source-level assignment where the variable may change value,
it asserts the location of a variable in a block, and loses effect outside the
block. Propagating variable locations through copies and spills is
straightforward: determining the variable location in every basic block
requires the consideration of control flow. Consider the following IR, which
presents several difficulties:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>define dso_local i32 @foo(i1 %cond, i32 %input) !dbg !12 {
entry:
  br i1 %cond, label %truebr, label %falsebr

bb1:
  %value = phi i32 [ %value1, %truebr ], [ %value2, %falsebr ]
  br label %exit, !dbg !26

truebr:
    #dbg_value(i32 %input, !30, !DIExpression(), !24)
    #dbg_value(i32 1, !23, !DIExpression(), !24)
  %value1 = add i32 %input, 1
  br label %bb1

falsebr:
    #dbg_value(i32 %input, !30, !DIExpression(), !24)
    #dbg_value(i32 2, !23, !DIExpression(), !24)
  %value2 = add i32 %input, 2
  br label %bb1

exit:
  ret i32 %value, !dbg !30
}
</pre></div>
</div>
<p>Here the difficulties are:</p>
<ul class="simple">
<li><p>The control flow is roughly the opposite of basic block order</p></li>
<li><p>The value of the <code class="docutils literal notranslate"><span class="pre">!23</span></code> variable merges into <code class="docutils literal notranslate"><span class="pre">%bb1</span></code>, but there is no PHI
node</p></li>
</ul>
<p>As mentioned above, the <code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> records essentially form an
imperative program embedded in the IR, with each record defining a variable
location. This <em>could</em> be converted to an SSA form by <code class="docutils literal notranslate"><span class="pre">mem2reg</span></code>, in the same way
that it uses use-def chains to identify control flow merges and insert phi
nodes for IR Values. However, because debug variable locations are defined for
every machine instruction, in effect every IR instruction uses every variable
location, which would lead to a large number of debugging records being
generated.</p>
<p>Examining the example above, variable <code class="docutils literal notranslate"><span class="pre">!30</span></code> is assigned <code class="docutils literal notranslate"><span class="pre">%input</span></code> on both
conditional paths through the function, while <code class="docutils literal notranslate"><span class="pre">!23</span></code> is assigned differing
constant values on either path. Where control flow merges in <code class="docutils literal notranslate"><span class="pre">%bb1</span></code> we would
want <code class="docutils literal notranslate"><span class="pre">!30</span></code> to keep its location (<code class="docutils literal notranslate"><span class="pre">%input</span></code>), but <code class="docutils literal notranslate"><span class="pre">!23</span></code> to become undefined
as we cannot determine at runtime what value it should have in <code class="docutils literal notranslate"><span class="pre">%bb1</span></code> without
inserting a PHI node. <code class="docutils literal notranslate"><span class="pre">mem2reg</span></code> does not insert the PHI node to avoid changing
CodeGen when debugging is enabled, and does not insert the other <code class="docutils literal notranslate"><span class="pre">#dbg_values</span></code>
to avoid adding very large numbers of records.</p>
<p>Instead, <code class="docutils literal notranslate"><span class="pre">LiveDebugValue</span></code>s determines variable locations when control
flow merges. A dataflow analysis is used to propagate locations between blocks:
when control flow merges, if a variable has the same location in all
predecessors then that location is propagated into the successor. If the
predecessor locations disagree, the location becomes undefined.</p>
<p>Once <code class="docutils literal notranslate"><span class="pre">LiveDebugValue</span></code>s has run, every block should have all valid variable
locations described by <code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code> instructions within the block. Very little
effort is then required by supporting classes (such as
<code class="docutils literal notranslate"><span class="pre">DbgEntityHistoryCalculator</span></code>) to build a map of each instruction to every
valid variable location, without the need to consider control flow. From
the example above, it is otherwise difficult to determine that the location
of variable <code class="docutils literal notranslate"><span class="pre">!30</span></code> should flow “up” into block <code class="docutils literal notranslate"><span class="pre">%bb1</span></code>, but that the location
of variable <code class="docutils literal notranslate"><span class="pre">!23</span></code> should not flow “down” into the <code class="docutils literal notranslate"><span class="pre">%exit</span></code> block.</p>
</section>
</section>
<section id="c-c-front-end-specific-debug-information">
<span id="ccxx-frontend"></span><h2><a class="toc-backref" href="#id36" role="doc-backlink">C/C++ front-end specific debug information</a><a class="headerlink" href="#c-c-front-end-specific-debug-information" title="Link to this heading">¶</a></h2>
<p>The C and C++ front-ends represent information about the program in a
format that is effectively identical to <a class="reference external" href="http://www.dwarfstd.org/">DWARF</a>
in terms of information content.  This allows code generators to
trivially support native debuggers by generating standard dwarf
information, and contains enough information for non-dwarf targets to
translate it as needed.</p>
<p>This section describes the forms used to represent C and C++ programs.  Other
languages could pattern themselves after this (which itself is tuned to
representing programs in the same way that DWARF does), or they could choose
to provide completely different forms if they don’t fit into the DWARF model.
As support for debugging information gets added to the various LLVM
source-language front-ends, the information used should be documented here.</p>
<p>The following sections provide examples of a few C/C++ constructs and
the debug information that would best describe those constructs.  The
canonical references are the <code class="docutils literal notranslate"><span class="pre">DINode</span></code> classes defined in
<code class="docutils literal notranslate"><span class="pre">include/llvm/IR/DebugInfoMetadata.h</span></code> and the implementations of the
helper functions in <code class="docutils literal notranslate"><span class="pre">lib/IR/DIBuilder.cpp</span></code>.</p>
<section id="c-c-source-file-information">
<h3><a class="toc-backref" href="#id37" role="doc-backlink">C/C++ source file information</a><a class="headerlink" href="#c-c-source-file-information" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">llvm::Instruction</span></code> provides easy access to metadata attached to an
instruction.  One can extract line number information encoded in LLVM IR using
<code class="docutils literal notranslate"><span class="pre">Instruction::getDebugLoc()</span></code> and <code class="docutils literal notranslate"><span class="pre">DILocation::getLine()</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">DILocation</span><span class="w"> </span><span class="o">*</span><span class="n">Loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I</span><span class="o">-&gt;</span><span class="n">getDebugLoc</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Here I is an LLVM instruction</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">Line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Loc</span><span class="o">-&gt;</span><span class="n">getLine</span><span class="p">();</span>
<span class="w">  </span><span class="n">StringRef</span><span class="w"> </span><span class="n">File</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Loc</span><span class="o">-&gt;</span><span class="n">getFilename</span><span class="p">();</span>
<span class="w">  </span><span class="n">StringRef</span><span class="w"> </span><span class="n">Dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Loc</span><span class="o">-&gt;</span><span class="n">getDirectory</span><span class="p">();</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">ImplicitCode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Loc</span><span class="o">-&gt;</span><span class="n">isImplicitCode</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When the flag <code class="docutils literal notranslate"><span class="pre">ImplicitCode</span></code> is true then it means that the Instruction has been
added by the front-end but doesn’t correspond to source code written by the user. For example</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">MyBoolean</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MyObject</span><span class="w"> </span><span class="n">MO</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>At the end of the scope the <code class="docutils literal notranslate"><span class="pre">MyObject</span></code>’s destructor is called but it isn’t written
explicitly. This information is useful to avoid having counters on brackets when
making code coverage.</p>
</section>
<section id="c-c-global-variable-information">
<h3><a class="toc-backref" href="#id38" role="doc-backlink">C/C++ global variable information</a><a class="headerlink" href="#c-c-global-variable-information" title="Link to this heading">¶</a></h3>
<p>Given an integer global variable declared as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">_Alignas</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">MyGlobal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
</pre></div>
</div>
<p>a C/C++ front-end would generate the following descriptors:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>;;
;; Define the global itself.
;;
@MyGlobal = global i32 100, align 8, !dbg !0

;;
;; List of debug info of globals
;;
!llvm.dbg.cu = !{!1}

;; Some unrelated metadata.
!llvm.module.flags = !{!6, !7}
!llvm.ident = !{!8}

;; Define the global variable itself
!0 = distinct !DIGlobalVariable(name: &quot;MyGlobal&quot;, scope: !1, file: !2, line: 1, type: !5, isLocal: false, isDefinition: true, align: 64)

;; Define the compile unit.
!1 = distinct !DICompileUnit(language: DW_LANG_C99, file: !2,
                             producer: &quot;clang version 4.0.0&quot;,
                             isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug,
                             enums: !3, globals: !4)

;;
;; Define the file
;;
!2 = !DIFile(filename: &quot;/dev/stdin&quot;,
             directory: &quot;/Users/dexonsmith/data/llvm/debug-info&quot;)

;; An empty array.
!3 = !{}

;; The Array of Global Variables
!4 = !{!0}

;;
;; Define the type
;;
!5 = !DIBasicType(name: &quot;int&quot;, size: 32, encoding: DW_ATE_signed)

;; Dwarf version to output.
!6 = !{i32 2, !&quot;Dwarf Version&quot;, i32 4}

;; Debug info schema version.
!7 = !{i32 2, !&quot;Debug Info Version&quot;, i32 3}

;; Compiler identification
!8 = !{!&quot;clang version 4.0.0&quot;}
</pre></div>
</div>
<p>The align value in <code class="docutils literal notranslate"><span class="pre">DIGlobalVariable</span></code> description specifies variable alignment in
case it was forced by C11 <code class="docutils literal notranslate"><span class="pre">_Alignas()</span></code>, C++11 <code class="docutils literal notranslate"><span class="pre">alignas()</span></code> keywords or compiler
attribute <code class="docutils literal notranslate"><span class="pre">__attribute__((aligned</span> <span class="pre">()))</span></code>. In other case (when this field is missing)
alignment is considered default. This is used when producing DWARF output
for <code class="docutils literal notranslate"><span class="pre">DW_AT_alignment</span></code> value.</p>
</section>
<section id="c-c-function-information">
<h3><a class="toc-backref" href="#id39" role="doc-backlink">C/C++ function information</a><a class="headerlink" href="#c-c-function-information" title="Link to this heading">¶</a></h3>
<p>Given a function declared as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>a C/C++ front-end would generate the following descriptors:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>;;
;; Define the anchor for subprograms.
;;
!4 = !DISubprogram(name: &quot;main&quot;, scope: !1, file: !1, line: 1, type: !5,
                   isLocal: false, isDefinition: true, scopeLine: 1,
                   flags: DIFlagPrototyped, isOptimized: false,
                   retainedNodes: !2)

;;
;; Define the subprogram itself.
;;
define i32 @main(i32 %argc, i8** %argv) !dbg !4 {
...
}
</pre></div>
</div>
</section>
</section>
<section id="c-specific-debug-information">
<h2><a class="toc-backref" href="#id40" role="doc-backlink">C++ specific debug information</a><a class="headerlink" href="#c-specific-debug-information" title="Link to this heading">¶</a></h2>
<section id="c-special-member-functions-information">
<h3><a class="toc-backref" href="#id41" role="doc-backlink">C++ special member functions information</a><a class="headerlink" href="#c-special-member-functions-information" title="Link to this heading">¶</a></h3>
<p>DWARF v5 introduces attributes defined to enhance debugging information of C++ programs. LLVM can generate (or omit) these appropriate DWARF attributes. In C++ a special member function Ctors, Dtors, Copy/Move Ctors, assignment operators can be declared with C++11 keyword deleted. This is represented in LLVM using <code class="docutils literal notranslate"><span class="pre">spFlags</span></code> value <code class="docutils literal notranslate"><span class="pre">DISPFlagDeleted</span></code>.</p>
<p>Given a class declaration with copy constructor declared as deleted:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">class</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="n">public</span><span class="o">:</span>
<span class="w">   </span><span class="n">foo</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">foo</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">deleted</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>A C++ frontend would generate the following:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>!17 = !DISubprogram(name: &quot;foo&quot;, scope: !11, file: !1, line: 5, type: !18, scopeLine: 5, flags: DIFlagPublic | DIFlagPrototyped, spFlags: DISPFlagDeleted)
</pre></div>
</div>
<p>and this will produce an additional DWARF attribute as:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DW_TAG_subprogram [7] *
  DW_AT_name [DW_FORM_strx1]    (indexed (00000006) string = &quot;foo&quot;)
  DW_AT_decl_line [DW_FORM_data1]       (5)
  ...
  DW_AT_deleted [DW_FORM_flag_present]  (true)
</pre></div>
</div>
</section>
</section>
<section id="fortran-specific-debug-information">
<h2><a class="toc-backref" href="#id42" role="doc-backlink">Fortran specific debug information</a><a class="headerlink" href="#fortran-specific-debug-information" title="Link to this heading">¶</a></h2>
<section id="fortran-function-information">
<h3><a class="toc-backref" href="#id43" role="doc-backlink">Fortran function information</a><a class="headerlink" href="#fortran-function-information" title="Link to this heading">¶</a></h3>
<p>There are a few DWARF attributes defined to support client debugging of Fortran programs.  LLVM can generate (or omit) the appropriate DWARF attributes for the prefix-specs of ELEMENTAL, PURE, IMPURE, RECURSIVE, and NON_RECURSIVE.  This is done by using the <code class="docutils literal notranslate"><span class="pre">spFlags</span></code> values: <code class="docutils literal notranslate"><span class="pre">DISPFlagElemental</span></code>, <code class="docutils literal notranslate"><span class="pre">DISPFlagPure</span></code>, and <code class="docutils literal notranslate"><span class="pre">DISPFlagRecursive</span></code>.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">elemental function </span><span class="n">elem_func</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>a Fortran front-end would generate the following descriptors:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>!11 = distinct !DISubprogram(name: &quot;subroutine2&quot;, scope: !1, file: !1,
        line: 5, type: !8, scopeLine: 6,
        spFlags: DISPFlagDefinition | DISPFlagElemental, unit: !0,
        retainedNodes: !2)
</pre></div>
</div>
<p>and this will materialize an additional DWARF attribute as:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DW_TAG_subprogram [3]
   DW_AT_low_pc [DW_FORM_addr]     (0x0000000000000010 &quot;.text&quot;)
   DW_AT_high_pc [DW_FORM_data4]   (0x00000001)
   ...
   DW_AT_elemental [DW_FORM_flag_present]  (true)
</pre></div>
</div>
<p>There are a few DWARF tags defined to represent Fortran specific constructs i.e <code class="docutils literal notranslate"><span class="pre">DW_TAG_string_type</span></code> for representing Fortran character(n). In LLVM, this is represented as <code class="docutils literal notranslate"><span class="pre">DIStringType</span></code>.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="kt">character</span><span class="p">(</span><span class="nb">len</span><span class="o">=*</span><span class="p">),</span><span class="w"> </span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">string</span>
</pre></div>
</div>
<p>a Fortran front-end would generate the following descriptors:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>!DILocalVariable(name: &quot;string&quot;, arg: 1, scope: !10, file: !3, line: 4, type: !15)
!DIStringType(name: &quot;character(*)!2&quot;, stringLength: !16, stringLengthExpression: !DIExpression(), size: 32)
</pre></div>
</div>
<p>A fortran deferred-length character can also contain the information of raw storage of the characters in addition to the length of the string. This information is encoded in the  stringLocationExpression field. Based on this information, <code class="docutils literal notranslate"><span class="pre">DW_AT_data_location</span></code> attribute is emitted in a <code class="docutils literal notranslate"><span class="pre">DW_TAG_string_type</span></code> debug info.</p>
<blockquote>
<div><p>!DIStringType(name: “character(*)!2”, stringLengthExpression: !DIExpression(), stringLocationExpression: !DIExpression(DW_OP_push_object_address, DW_OP_deref), size: 32)</p>
</div></blockquote>
<p>and this will materialize in DWARF tags as:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DW_TAG_string_type
             DW_AT_name      (&quot;character(*)!2&quot;)
             DW_AT_string_length     (0x00000064)
0x00000064:    DW_TAG_variable
               DW_AT_location      (DW_OP_fbreg +16)
               DW_AT_type  (0x00000083 &quot;integer*8&quot;)
               DW_AT_data_location (DW_OP_push_object_address, DW_OP_deref)
               ...
               DW_AT_artificial    (true)
</pre></div>
</div>
<p>A Fortran front-end may need to generate a <em>trampoline</em> function to call a
function defined in a different compilation unit. In this case, the front-end
can emit the following descriptor for the trampoline function:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>!DISubprogram(name: &quot;sub1_.t0p&quot;, linkageName: &quot;sub1_.t0p&quot;, scope: !4, file: !4, type: !5, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !7, retainedNodes: !24, targetFuncName: &quot;sub1_&quot;)
</pre></div>
</div>
<p>The targetFuncName field is the name of the function that the trampoline
calls. This descriptor results in the following DWARF tag:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DW_TAG_subprogram
  ...
  DW_AT_linkage_name  (&quot;sub1_.t0p&quot;)
  DW_AT_name  (&quot;sub1_.t0p&quot;)
  DW_AT_trampoline    (&quot;sub1_&quot;)
</pre></div>
</div>
</section>
</section>
<section id="id7">
<h2><a class="toc-backref" href="#id44" role="doc-backlink">Debugging information format</a><a class="headerlink" href="#id7" title="Link to this heading">¶</a></h2>
<section id="debugging-information-extension-for-objective-c-properties">
<h3><a class="toc-backref" href="#id45" role="doc-backlink">Debugging Information Extension for Objective-C Properties</a><a class="headerlink" href="#debugging-information-extension-for-objective-c-properties" title="Link to this heading">¶</a></h3>
<section id="id8">
<h4><a class="toc-backref" href="#id46" role="doc-backlink">Introduction</a><a class="headerlink" href="#id8" title="Link to this heading">¶</a></h4>
<p>Objective-C provides a simpler way to declare and define accessor methods using
declared properties.  The language provides features to declare a property and
to let compiler synthesize accessor methods.</p>
<p>The debugger lets developers inspect Objective-C interfaces and their instance
variables and class variables.  However, the debugger does not know anything
about the properties defined in Objective-C interfaces.  The debugger consumes
information generated by compiler in DWARF format.  The format does not support
encoding of Objective-C properties.  This proposal describes DWARF extensions to
encode Objective-C properties, which the debugger can use to let developers
inspect Objective-C properties.</p>
</section>
<section id="proposal">
<h4><a class="toc-backref" href="#id47" role="doc-backlink">Proposal</a><a class="headerlink" href="#proposal" title="Link to this heading">¶</a></h4>
<p>Objective-C properties exist separately from class members.  A property can be
defined only by “setter” and “getter” selectors, and be calculated anew on each
access.  Or a property can just be a direct access to some declared ivar.
Finally it can have an ivar “automatically synthesized” for it by the compiler,
in which case the property can be referred to in user code directly using the
standard C dereference syntax as well as through the property “dot” syntax, but
there is no entry in the <code class="docutils literal notranslate"><span class="pre">&#64;interface</span></code> declaration corresponding to this ivar.</p>
<p>To facilitate debugging, these properties we will add a new DWARF TAG into the
<code class="docutils literal notranslate"><span class="pre">DW_TAG_structure_type</span></code> definition for the class to hold the description of a
given property, and a set of DWARF attributes that provide said description.
The property tag will also contain the name and declared type of the property.</p>
<p>If there is a related ivar, there will also be a DWARF property attribute placed
in the <code class="docutils literal notranslate"><span class="pre">DW_TAG_member</span></code> DIE for that ivar referring back to the property TAG
for that property.  And in the case where the compiler synthesizes the ivar
directly, the compiler is expected to generate a <code class="docutils literal notranslate"><span class="pre">DW_TAG_member</span></code> for that
ivar (with the <code class="docutils literal notranslate"><span class="pre">DW_AT_artificial</span></code> set to 1), whose name will be the name used
to access this ivar directly in code, and with the property attribute pointing
back to the property it is backing.</p>
<p>The following examples will serve as illustration for our discussion:</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="nc">I1</span> <span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">n2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">@property</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p1</span><span class="p">;</span>
<span class="k">@property</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p2</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">I1</span>
<span class="k">@synthesize</span><span class="w"> </span><span class="n">p1</span><span class="p">;</span>
<span class="k">@synthesize</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n2</span><span class="p">;</span>
<span class="k">@end</span>
</pre></div>
</div>
<p>This produces the following DWARF (this is a “pseudo dwarfdump” output):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x00000100:  TAG_structure_type [7] *
               AT_APPLE_runtime_class( 0x10 )
               AT_name( &quot;I1&quot; )
               AT_decl_file( &quot;Objc_Property.m&quot; )
               AT_decl_line( 3 )

0x00000110    TAG_APPLE_property
                AT_name ( &quot;p1&quot; )
                AT_type ( {0x00000150} ( int ) )

0x00000120:   TAG_APPLE_property
                AT_name ( &quot;p2&quot; )
                AT_type ( {0x00000150} ( int ) )

0x00000130:   TAG_member [8]
                AT_name( &quot;_p1&quot; )
                AT_APPLE_property ( {0x00000110} &quot;p1&quot; )
                AT_type( {0x00000150} ( int ) )
                AT_artificial ( 0x1 )

0x00000140:    TAG_member [8]
                 AT_name( &quot;n2&quot; )
                 AT_APPLE_property ( {0x00000120} &quot;p2&quot; )
                 AT_type( {0x00000150} ( int ) )

0x00000150:  AT_type( ( int ) )
</pre></div>
</div>
<p>Note, the current convention is that the name of the ivar for an
auto-synthesized property is the name of the property from which it derives
with an underscore prepended, as is shown in the example.  But we actually
don’t need to know this convention, since we are given the name of the ivar
directly.</p>
<p>Also, it is common practice in ObjC to have different property declarations in
the <code class="docutils literal notranslate"><span class="pre">&#64;interface</span></code> and <code class="docutils literal notranslate"><span class="pre">&#64;implementation</span></code> - e.g. to provide a read-only property in
the interface, and a read-write interface in the implementation.  In that case,
the compiler should emit whichever property declaration will be in force in the
current translation unit.</p>
<p>Developers can decorate a property with attributes which are encoded using
<code class="docutils literal notranslate"><span class="pre">DW_AT_APPLE_property_attribute</span></code>.</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="k">@property</span><span class="w"> </span><span class="p">(</span><span class="k">readonly</span><span class="p">,</span><span class="w"> </span><span class="k">nonatomic</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pr</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>TAG_APPLE_property [8]
  AT_name( &quot;pr&quot; )
  AT_type ( {0x00000147} (int) )
  AT_APPLE_property_attribute (DW_APPLE_PROPERTY_readonly, DW_APPLE_PROPERTY_nonatomic)
</pre></div>
</div>
<p>The setter and getter method names are attached to the property using
<code class="docutils literal notranslate"><span class="pre">DW_AT_APPLE_property_setter</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_AT_APPLE_property_getter</span></code> attributes.</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="nc">I1</span>
<span class="k">@property</span><span class="w"> </span><span class="p">(</span><span class="k">setter</span><span class="o">=</span><span class="n">myOwnP3Setter</span><span class="o">:</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p3</span><span class="p">;</span>
<span class="p">-(</span><span class="kt">void</span><span class="p">)</span><span class="nf">myOwnP3Setter:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">a</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">I1</span>
<span class="k">@synthesize</span><span class="w"> </span><span class="n">p3</span><span class="p">;</span>
<span class="p">-(</span><span class="kt">void</span><span class="p">)</span><span class="nf">myOwnP3Setter:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">a</span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="k">@end</span>
</pre></div>
</div>
<p>The DWARF for this would be:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x000003bd: TAG_structure_type [7] *
              AT_APPLE_runtime_class( 0x10 )
              AT_name( &quot;I1&quot; )
              AT_decl_file( &quot;Objc_Property.m&quot; )
              AT_decl_line( 3 )

0x000003cd      TAG_APPLE_property
                  AT_name ( &quot;p3&quot; )
                  AT_APPLE_property_setter ( &quot;myOwnP3Setter:&quot; )
                  AT_type( {0x00000147} ( int ) )

0x000003f3:     TAG_member [8]
                  AT_name( &quot;_p3&quot; )
                  AT_type ( {0x00000147} ( int ) )
                  AT_APPLE_property ( {0x000003cd} )
                  AT_artificial ( 0x1 )
</pre></div>
</div>
</section>
<section id="new-dwarf-tags">
<h4><a class="toc-backref" href="#id48" role="doc-backlink">New DWARF Tags</a><a class="headerlink" href="#new-dwarf-tags" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>TAG</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>DW_TAG_APPLE_property</p></td>
<td><p>0x4200</p></td>
</tr>
</tbody>
</table>
</section>
<section id="new-dwarf-attributes">
<h4><a class="toc-backref" href="#id49" role="doc-backlink">New DWARF Attributes</a><a class="headerlink" href="#new-dwarf-attributes" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Attribute</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Classes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>DW_AT_APPLE_property</p></td>
<td><p>0x3fed</p></td>
<td><p>Reference</p></td>
</tr>
<tr class="row-odd"><td><p>DW_AT_APPLE_property_getter</p></td>
<td><p>0x3fe9</p></td>
<td><p>String</p></td>
</tr>
<tr class="row-even"><td><p>DW_AT_APPLE_property_setter</p></td>
<td><p>0x3fea</p></td>
<td><p>String</p></td>
</tr>
<tr class="row-odd"><td><p>DW_AT_APPLE_property_attribute</p></td>
<td><p>0x3feb</p></td>
<td><p>Constant</p></td>
</tr>
</tbody>
</table>
</section>
<section id="new-dwarf-constants">
<h4><a class="toc-backref" href="#id50" role="doc-backlink">New DWARF Constants</a><a class="headerlink" href="#new-dwarf-constants" title="Link to this heading">¶</a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>DW_APPLE_PROPERTY_readonly</p></td>
<td><p>0x01</p></td>
</tr>
<tr class="row-odd"><td><p>DW_APPLE_PROPERTY_getter</p></td>
<td><p>0x02</p></td>
</tr>
<tr class="row-even"><td><p>DW_APPLE_PROPERTY_assign</p></td>
<td><p>0x04</p></td>
</tr>
<tr class="row-odd"><td><p>DW_APPLE_PROPERTY_readwrite</p></td>
<td><p>0x08</p></td>
</tr>
<tr class="row-even"><td><p>DW_APPLE_PROPERTY_retain</p></td>
<td><p>0x10</p></td>
</tr>
<tr class="row-odd"><td><p>DW_APPLE_PROPERTY_copy</p></td>
<td><p>0x20</p></td>
</tr>
<tr class="row-even"><td><p>DW_APPLE_PROPERTY_nonatomic</p></td>
<td><p>0x40</p></td>
</tr>
<tr class="row-odd"><td><p>DW_APPLE_PROPERTY_setter</p></td>
<td><p>0x80</p></td>
</tr>
<tr class="row-even"><td><p>DW_APPLE_PROPERTY_atomic</p></td>
<td><p>0x100</p></td>
</tr>
<tr class="row-odd"><td><p>DW_APPLE_PROPERTY_weak</p></td>
<td><p>0x200</p></td>
</tr>
<tr class="row-even"><td><p>DW_APPLE_PROPERTY_strong</p></td>
<td><p>0x400</p></td>
</tr>
<tr class="row-odd"><td><p>DW_APPLE_PROPERTY_unsafe_unretained</p></td>
<td><p>0x800</p></td>
</tr>
<tr class="row-even"><td><p>DW_APPLE_PROPERTY_nullability</p></td>
<td><p>0x1000</p></td>
</tr>
<tr class="row-odd"><td><p>DW_APPLE_PROPERTY_null_resettable</p></td>
<td><p>0x2000</p></td>
</tr>
<tr class="row-even"><td><p>DW_APPLE_PROPERTY_class</p></td>
<td><p>0x4000</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="name-accelerator-tables">
<h3><a class="toc-backref" href="#id51" role="doc-backlink">Name Accelerator Tables</a><a class="headerlink" href="#name-accelerator-tables" title="Link to this heading">¶</a></h3>
<section id="id9">
<h4><a class="toc-backref" href="#id52" role="doc-backlink">Introduction</a><a class="headerlink" href="#id9" title="Link to this heading">¶</a></h4>
<p>The “<code class="docutils literal notranslate"><span class="pre">.debug_pubnames</span></code>” and “<code class="docutils literal notranslate"><span class="pre">.debug_pubtypes</span></code>” formats are not what a
debugger needs.  The “<code class="docutils literal notranslate"><span class="pre">pub</span></code>” in the section name indicates that the entries
in the table are publicly visible names only.  This means no static or hidden
functions show up in the “<code class="docutils literal notranslate"><span class="pre">.debug_pubnames</span></code>”.  No static variables or private
class variables are in the “<code class="docutils literal notranslate"><span class="pre">.debug_pubtypes</span></code>”.  Many compilers add different
things to these tables, so we can’t rely upon the contents between gcc, icc, or
clang.</p>
<p>The typical query given by users tends not to match up with the contents of
these tables.  For example, the DWARF spec states that “In the case of the name
of a function member or static data member of a C++ structure, class or union,
the name presented in the “<code class="docutils literal notranslate"><span class="pre">.debug_pubnames</span></code>” section is not the simple name
given by the <code class="docutils literal notranslate"><span class="pre">DW_AT_name</span> <span class="pre">attribute</span></code> of the referenced debugging information
entry, but rather the fully qualified name of the data or function member.”
So the only names in these tables for complex C++ entries is a fully
qualified name.  Debugger users tend not to enter their search strings as
“<code class="docutils literal notranslate"><span class="pre">a::b::c(int,const</span> <span class="pre">Foo&amp;)</span> <span class="pre">const</span></code>”, but rather as “<code class="docutils literal notranslate"><span class="pre">c</span></code>”, “<code class="docutils literal notranslate"><span class="pre">b::c</span></code>” , or
“<code class="docutils literal notranslate"><span class="pre">a::b::c</span></code>”.  So the name entered in the name table must be demangled in
order to chop it up appropriately and additional names must be manually entered
into the table to make it effective as a name lookup table for debuggers to
use.</p>
<p>All debuggers currently ignore the “<code class="docutils literal notranslate"><span class="pre">.debug_pubnames</span></code>” table as a result of
its inconsistent and useless public-only name content making it a waste of
space in the object file.  These tables, when they are written to disk, are not
sorted in any way, leaving every debugger to do its own parsing and sorting.
These tables also include an inlined copy of the string values in the table
itself making the tables much larger than they need to be on disk, especially
for large C++ programs.</p>
<p>Can’t we just fix the sections by adding all of the names we need to this
table? No, because that is not what the tables are defined to contain and we
won’t know the difference between the old bad tables and the new good tables.
At best we could make our own renamed sections that contain all of the data we
need.</p>
<p>These tables are also insufficient for what a debugger like LLDB needs.  LLDB
uses clang for its expression parsing where LLDB acts as a PCH.  LLDB is then
often asked to look for type “<code class="docutils literal notranslate"><span class="pre">foo</span></code>” or namespace “<code class="docutils literal notranslate"><span class="pre">bar</span></code>”, or list items in
namespace “<code class="docutils literal notranslate"><span class="pre">baz</span></code>”.  Namespaces are not included in the pubnames or pubtypes
tables.  Since clang asks a lot of questions when it is parsing an expression,
we need to be very fast when looking up names, as it happens a lot.  Having new
accelerator tables that are optimized for very quick lookups will benefit this
type of debugging experience greatly.</p>
<p>We would like to generate name lookup tables that can be mapped into memory
from disk, and used as is, with little or no up-front parsing.  We would also
be able to control the exact content of these different tables so they contain
exactly what we need.  The Name Accelerator Tables were designed to fix these
issues.  In order to solve these issues we need to:</p>
<ul class="simple">
<li><p>Have a format that can be mapped into memory from disk and used as is</p></li>
<li><p>Lookups should be very fast</p></li>
<li><p>Extensible table format so these tables can be made by many producers</p></li>
<li><p>Contain all of the names needed for typical lookups out of the box</p></li>
<li><p>Strict rules for the contents of tables</p></li>
</ul>
<p>Table size is important and the accelerator table format should allow the reuse
of strings from common string tables so the strings for the names are not
duplicated.  We also want to make sure the table is ready to be used as-is by
simply mapping the table into memory with minimal header parsing.</p>
<p>The name lookups need to be fast and optimized for the kinds of lookups that
debuggers tend to do.  Optimally we would like to touch as few parts of the
mapped table as possible when doing a name lookup and be able to quickly find
the name entry we are looking for, or discover there are no matches.  In the
case of debuggers we optimized for lookups that fail most of the time.</p>
<p>Each table that is defined should have strict rules on exactly what is in the
accelerator tables and documented so clients can rely on the content.</p>
</section>
<section id="hash-tables">
<h4><a class="toc-backref" href="#id53" role="doc-backlink">Hash Tables</a><a class="headerlink" href="#hash-tables" title="Link to this heading">¶</a></h4>
<section id="standard-hash-tables">
<h5><a class="toc-backref" href="#id54" role="doc-backlink">Standard Hash Tables</a><a class="headerlink" href="#standard-hash-tables" title="Link to this heading">¶</a></h5>
<p>Typical hash tables have a header, buckets, and each bucket points to the
bucket contents:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.------------.
|  HEADER    |
|------------|
|  BUCKETS   |
|------------|
|  DATA      |
`------------&#39;
</pre></div>
</div>
<p>The BUCKETS are an array of offsets to DATA for each hash:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.------------.
| 0x00001000 | BUCKETS[0]
| 0x00002000 | BUCKETS[1]
| 0x00002200 | BUCKETS[2]
| 0x000034f0 | BUCKETS[3]
|            | ...
| 0xXXXXXXXX | BUCKETS[n_buckets]
&#39;------------&#39;
</pre></div>
</div>
<p>So for <code class="docutils literal notranslate"><span class="pre">bucket[3]</span></code> in the example above, we have an offset into the table
0x000034f0 which points to a chain of entries for the bucket.  Each bucket must
contain a next pointer, full 32-bit hash value, the string itself, and the data
for the current string value.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>            .------------.
0x000034f0: | 0x00003500 | next pointer
            | 0x12345678 | 32-bit hash
            | &quot;erase&quot;    | string value
            | data[n]    | HashData for this bucket
            |------------|
0x00003500: | 0x00003550 | next pointer
            | 0x29273623 | 32-bit hash
            | &quot;dump&quot;     | string value
            | data[n]    | HashData for this bucket
            |------------|
0x00003550: | 0x00000000 | next pointer
            | 0x82638293 | 32-bit hash
            | &quot;main&quot;     | string value
            | data[n]    | HashData for this bucket
            `------------&#39;
</pre></div>
</div>
<p>The problem with this layout for debuggers is that we need to optimize for the
negative lookup case where the symbol we’re searching for is not present.  So
if we were to lookup “<code class="docutils literal notranslate"><span class="pre">printf</span></code>” in the table above, we would make a 32-bit
hash for “<code class="docutils literal notranslate"><span class="pre">printf</span></code>”, it might match <code class="docutils literal notranslate"><span class="pre">bucket[3]</span></code>.  We would need to go to
the offset 0x000034f0 and start looking to see if our 32-bit hash matches.  To
do so, we need to read the next pointer, then read the hash, compare it, and
skip to the next bucket.  Each time we are skipping many bytes in memory and
touching new pages just to do the compare on the full 32-bit hash.  All of
these accesses then tell us that we didn’t have a match.</p>
</section>
<section id="name-hash-tables">
<h5><a class="toc-backref" href="#id55" role="doc-backlink">Name Hash Tables</a><a class="headerlink" href="#name-hash-tables" title="Link to this heading">¶</a></h5>
<p>To solve the issues mentioned above, we have structured the hash tables a bit
differently: a header, buckets, an array of all unique 32-bit hash values,
followed by an array of hash value data offsets, one for each hash value, then
the data for all hash values:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.-------------.
|  HEADER     |
|-------------|
|  BUCKETS    |
|-------------|
|  HASHES     |
|-------------|
|  OFFSETS    |
|-------------|
|  DATA       |
`-------------&#39;
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">BUCKETS</span></code> in the name tables are an index into the <code class="docutils literal notranslate"><span class="pre">HASHES</span></code> array.  By
making all of the full 32-bit hash values contiguous in memory, we allow
ourselves to efficiently check for a match while touching as little memory as
possible.  Most often checking the 32-bit hash values is as far as the lookup
goes.  If it does match, it usually is a match with no collisions.  So for a
table with “<code class="docutils literal notranslate"><span class="pre">n_buckets</span></code>” buckets, and “<code class="docutils literal notranslate"><span class="pre">n_hashes</span></code>” unique 32-bit hash
values, we can clarify the contents of the <code class="docutils literal notranslate"><span class="pre">BUCKETS</span></code>, <code class="docutils literal notranslate"><span class="pre">HASHES</span></code> and
<code class="docutils literal notranslate"><span class="pre">OFFSETS</span></code> as:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.-------------------------.
|  HEADER.magic           | uint32_t
|  HEADER.version         | uint16_t
|  HEADER.hash_function   | uint16_t
|  HEADER.bucket_count    | uint32_t
|  HEADER.hashes_count    | uint32_t
|  HEADER.header_data_len | uint32_t
|  HEADER_DATA            | HeaderData
|-------------------------|
|  BUCKETS                | uint32_t[n_buckets] // 32-bit hash indexes
|-------------------------|
|  HASHES                 | uint32_t[n_hashes] // 32-bit hash values
|-------------------------|
|  OFFSETS                | uint32_t[n_hashes] // 32-bit offsets to hash value data
|-------------------------|
|  ALL HASH DATA          |
`-------------------------&#39;
</pre></div>
</div>
<p>So taking the exact same data from the standard hash example above, we end up
with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>            .------------.
            | HEADER     |
            |------------|
            |          0 | BUCKETS[0]
            |          2 | BUCKETS[1]
            |          5 | BUCKETS[2]
            |          6 | BUCKETS[3]
            |            | ...
            |        ... | BUCKETS[n_buckets]
            |------------|
            | 0x........ | HASHES[0]
            | 0x........ | HASHES[1]
            | 0x........ | HASHES[2]
            | 0x........ | HASHES[3]
            | 0x........ | HASHES[4]
            | 0x........ | HASHES[5]
            | 0x12345678 | HASHES[6]    hash for BUCKETS[3]
            | 0x29273623 | HASHES[7]    hash for BUCKETS[3]
            | 0x82638293 | HASHES[8]    hash for BUCKETS[3]
            | 0x........ | HASHES[9]
            | 0x........ | HASHES[10]
            | 0x........ | HASHES[11]
            | 0x........ | HASHES[12]
            | 0x........ | HASHES[13]
            | 0x........ | HASHES[n_hashes]
            |------------|
            | 0x........ | OFFSETS[0]
            | 0x........ | OFFSETS[1]
            | 0x........ | OFFSETS[2]
            | 0x........ | OFFSETS[3]
            | 0x........ | OFFSETS[4]
            | 0x........ | OFFSETS[5]
            | 0x000034f0 | OFFSETS[6]   offset for BUCKETS[3]
            | 0x00003500 | OFFSETS[7]   offset for BUCKETS[3]
            | 0x00003550 | OFFSETS[8]   offset for BUCKETS[3]
            | 0x........ | OFFSETS[9]
            | 0x........ | OFFSETS[10]
            | 0x........ | OFFSETS[11]
            | 0x........ | OFFSETS[12]
            | 0x........ | OFFSETS[13]
            | 0x........ | OFFSETS[n_hashes]
            |------------|
            |            |
            |            |
            |            |
            |            |
            |            |
            |------------|
0x000034f0: | 0x00001203 | .debug_str (&quot;erase&quot;)
            | 0x00000004 | A 32-bit array count - number of HashData with name &quot;erase&quot;
            | 0x........ | HashData[0]
            | 0x........ | HashData[1]
            | 0x........ | HashData[2]
            | 0x........ | HashData[3]
            | 0x00000000 | String offset into .debug_str (terminate data for hash)
            |------------|
0x00003500: | 0x00001203 | String offset into .debug_str (&quot;collision&quot;)
            | 0x00000002 | A 32-bit array count - number of HashData with name &quot;collision&quot;
            | 0x........ | HashData[0]
            | 0x........ | HashData[1]
            | 0x00001203 | String offset into .debug_str (&quot;dump&quot;)
            | 0x00000003 | A 32-bit array count - number of HashData with name &quot;dump&quot;
            | 0x........ | HashData[0]
            | 0x........ | HashData[1]
            | 0x........ | HashData[2]
            | 0x00000000 | String offset into .debug_str (terminate data for hash)
            |------------|
0x00003550: | 0x00001203 | String offset into .debug_str (&quot;main&quot;)
            | 0x00000009 | A 32-bit array count - number of HashData with name &quot;main&quot;
            | 0x........ | HashData[0]
            | 0x........ | HashData[1]
            | 0x........ | HashData[2]
            | 0x........ | HashData[3]
            | 0x........ | HashData[4]
            | 0x........ | HashData[5]
            | 0x........ | HashData[6]
            | 0x........ | HashData[7]
            | 0x........ | HashData[8]
            | 0x00000000 | String offset into .debug_str (terminate data for hash)
            `------------&#39;
</pre></div>
</div>
<p>So we still have all of the same data, we just organize it more efficiently for
debugger lookup.  If we repeat the same “<code class="docutils literal notranslate"><span class="pre">printf</span></code>” lookup from above, we
would hash “<code class="docutils literal notranslate"><span class="pre">printf</span></code>” and find it matches <code class="docutils literal notranslate"><span class="pre">BUCKETS[3]</span></code> by taking the 32-bit
hash value and modulo it by <code class="docutils literal notranslate"><span class="pre">n_buckets</span></code>.  <code class="docutils literal notranslate"><span class="pre">BUCKETS[3]</span></code> contains “6” which
is the index into the <code class="docutils literal notranslate"><span class="pre">HASHES</span></code> table.  We would then compare any consecutive
32-bit hash values in the <code class="docutils literal notranslate"><span class="pre">HASHES</span></code> array as long as the hashes would be in
<code class="docutils literal notranslate"><span class="pre">BUCKETS[3]</span></code>.  We do this by verifying that each subsequent hash value modulo
<code class="docutils literal notranslate"><span class="pre">n_buckets</span></code> is still 3.  In the case of a failed lookup we would access the
memory for <code class="docutils literal notranslate"><span class="pre">BUCKETS[3]</span></code>, and then compare a few consecutive 32-bit hashes
before we know that we have no match.  We don’t end up marching through
multiple words of memory and we really keep the number of processor data cache
lines being accessed as small as possible.</p>
<p>The string hash that is used for these lookup tables is the Daniel J.
Bernstein hash which is also used in the ELF <code class="docutils literal notranslate"><span class="pre">GNU_HASH</span></code> sections.  It is a
very good hash for all kinds of names in programs with very few hash
collisions.</p>
<p>Empty buckets are designated by using an invalid hash index of <code class="docutils literal notranslate"><span class="pre">UINT32_MAX</span></code>.</p>
</section>
</section>
<section id="details">
<h4><a class="toc-backref" href="#id56" role="doc-backlink">Details</a><a class="headerlink" href="#details" title="Link to this heading">¶</a></h4>
<p>These name hash tables are designed to be generic where specializations of the
table get to define additional data that goes into the header (”<code class="docutils literal notranslate"><span class="pre">HeaderData</span></code>”),
how the string value is stored (”<code class="docutils literal notranslate"><span class="pre">KeyType</span></code>”) and the content of the data for each
hash value.</p>
<section id="header-layout">
<h5><a class="toc-backref" href="#id57" role="doc-backlink">Header Layout</a><a class="headerlink" href="#header-layout" title="Link to this heading">¶</a></h5>
<p>The header has a fixed part, and the specialized part.  The exact format of the
header is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Header</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w">   </span><span class="n">magic</span><span class="p">;</span><span class="w">           </span><span class="c1">// &#39;HASH&#39; magic value to allow endian detection</span>
<span class="w">  </span><span class="kt">uint16_t</span><span class="w">   </span><span class="n">version</span><span class="p">;</span><span class="w">         </span><span class="c1">// Version number</span>
<span class="w">  </span><span class="kt">uint16_t</span><span class="w">   </span><span class="n">hash_function</span><span class="p">;</span><span class="w">   </span><span class="c1">// The hash function enumeration that was used</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w">   </span><span class="n">bucket_count</span><span class="p">;</span><span class="w">    </span><span class="c1">// The number of buckets in this hash table</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w">   </span><span class="n">hashes_count</span><span class="p">;</span><span class="w">    </span><span class="c1">// The total number of unique hash values and hash data offsets in this table</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w">   </span><span class="n">header_data_len</span><span class="p">;</span><span class="w"> </span><span class="c1">// The bytes to skip to get to the hash indexes (buckets) for correct alignment</span>
<span class="w">                              </span><span class="c1">// Specifically the length of the following HeaderData field - this does not</span>
<span class="w">                              </span><span class="c1">// include the size of the preceding fields</span>
<span class="w">  </span><span class="n">HeaderData</span><span class="w"> </span><span class="n">header_data</span><span class="p">;</span><span class="w">     </span><span class="c1">// Implementation specific header data</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The header starts with a 32-bit “<code class="docutils literal notranslate"><span class="pre">magic</span></code>” value which must be <code class="docutils literal notranslate"><span class="pre">'HASH'</span></code>
encoded as an ASCII integer.  This allows the detection of the start of the
hash table and also allows the table’s byte order to be determined so the table
can be correctly extracted.  The “<code class="docutils literal notranslate"><span class="pre">magic</span></code>” value is followed by a 16-bit
<code class="docutils literal notranslate"><span class="pre">version</span></code> number which allows the table to be revised and modified in the
future.  The current version number is 1. <code class="docutils literal notranslate"><span class="pre">hash_function</span></code> is a <code class="docutils literal notranslate"><span class="pre">uint16_t</span></code>
enumeration that specifies which hash function was used to produce this table.
The current values for the hash function enumerations include:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="n">HashFunctionType</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">eHashFunctionDJB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0u</span><span class="p">,</span><span class="w"> </span><span class="c1">// Daniel J Bernstein hash function</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">bucket_count</span></code> is a 32-bit unsigned integer that represents how many buckets
are in the <code class="docutils literal notranslate"><span class="pre">BUCKETS</span></code> array.  <code class="docutils literal notranslate"><span class="pre">hashes_count</span></code> is the number of unique 32-bit
hash values that are in the <code class="docutils literal notranslate"><span class="pre">HASHES</span></code> array, and is the same number of offsets
are contained in the <code class="docutils literal notranslate"><span class="pre">OFFSETS</span></code> array.  <code class="docutils literal notranslate"><span class="pre">header_data_len</span></code> specifies the size
in bytes of the <code class="docutils literal notranslate"><span class="pre">HeaderData</span></code> that is filled in by specialized versions of
this table.</p>
</section>
<section id="fixed-lookup">
<h5><a class="toc-backref" href="#id58" role="doc-backlink">Fixed Lookup</a><a class="headerlink" href="#fixed-lookup" title="Link to this heading">¶</a></h5>
<p>The header is followed by the buckets, hashes, offsets, and hash value data.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">FixedTable</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">buckets</span><span class="p">[</span><span class="n">Header</span><span class="p">.</span><span class="n">bucket_count</span><span class="p">];</span><span class="w">  </span><span class="c1">// An array of hash indexes into the &quot;hashes[]&quot; array below</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">hashes</span><span class="w"> </span><span class="p">[</span><span class="n">Header</span><span class="p">.</span><span class="n">hashes_count</span><span class="p">];</span><span class="w">  </span><span class="c1">// Every unique 32-bit hash for the entire table is in this table</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">offsets</span><span class="p">[</span><span class="n">Header</span><span class="p">.</span><span class="n">hashes_count</span><span class="p">];</span><span class="w">  </span><span class="c1">// An offset that corresponds to each item in the &quot;hashes[]&quot; array above</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">buckets</span></code> is an array of 32-bit indexes into the <code class="docutils literal notranslate"><span class="pre">hashes</span></code> array.  The
<code class="docutils literal notranslate"><span class="pre">hashes</span></code> array contains all of the 32-bit hash values for all names in the
hash table.  Each hash in the <code class="docutils literal notranslate"><span class="pre">hashes</span></code> table has an offset in the <code class="docutils literal notranslate"><span class="pre">offsets</span></code>
array that points to the data for the hash value.</p>
<p>This table setup makes it very easy to repurpose these tables to contain
different data, while keeping the lookup mechanism the same for all tables.
This layout also makes it possible to save the table to disk and map it in
later and do very efficient name lookups with little or no parsing.</p>
<p>DWARF lookup tables can be implemented in a variety of ways and can store a lot
of information for each name.  We want to make the DWARF tables extensible and
able to store the data efficiently so we have used some of the DWARF features
that enable efficient data storage to define exactly what kind of data we store
for each name.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">HeaderData</span></code> contains a definition of the contents of each HashData chunk.
We might want to store an offset to all of the debug information entries (DIEs)
for each name.  To keep things extensible, we create a list of items, or
Atoms, that are contained in the data for each name.  First comes the type of
the data in each atom:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="n">AtomType</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">eAtomTypeNULL</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="mi">0u</span><span class="p">,</span>
<span class="w">  </span><span class="n">eAtomTypeDIEOffset</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">1u</span><span class="p">,</span><span class="w">   </span><span class="c1">// DIE offset, check form for encoding</span>
<span class="w">  </span><span class="n">eAtomTypeCUOffset</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mi">2u</span><span class="p">,</span><span class="w">   </span><span class="c1">// DIE offset of the compiler unit header that contains the item in question</span>
<span class="w">  </span><span class="n">eAtomTypeTag</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="mi">3u</span><span class="p">,</span><span class="w">   </span><span class="c1">// DW_TAG_xxx value, should be encoded as DW_FORM_data1 (if no tags exceed 255) or DW_FORM_data2</span>
<span class="w">  </span><span class="n">eAtomTypeNameFlags</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">4u</span><span class="p">,</span><span class="w">   </span><span class="c1">// Flags from enum NameFlags</span>
<span class="w">  </span><span class="n">eAtomTypeTypeFlags</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">5u</span><span class="p">,</span><span class="w">   </span><span class="c1">// Flags from enum TypeFlags</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The enumeration values and their meanings are:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>eAtomTypeNULL       - a termination atom that specifies the end of the atom list
eAtomTypeDIEOffset  - an offset into the .debug_info section for the DWARF DIE for this name
eAtomTypeCUOffset   - an offset into the .debug_info section for the CU that contains the DIE
eAtomTypeDIETag     - The DW_TAG_XXX enumeration value so you don&#39;t have to parse the DWARF to see what it is
eAtomTypeNameFlags  - Flags for functions and global variables (isFunction, isInlined, isExternal...)
eAtomTypeTypeFlags  - Flags for types (isCXXClass, isObjCClass, ...)
</pre></div>
</div>
<p>Then we allow each atom type to define the atom type and how the data for each
atom type data is encoded:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Atom</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">type</span><span class="p">;</span><span class="w">  </span><span class="c1">// AtomType enum value</span>
<span class="w">  </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">form</span><span class="p">;</span><span class="w">  </span><span class="c1">// DWARF DW_FORM_XXX defines</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">form</span></code> type above is from the DWARF specification and defines the exact
encoding of the data for the Atom type.  See the DWARF specification for the
<code class="docutils literal notranslate"><span class="pre">DW_FORM_</span></code> definitions.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">HeaderData</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">die_offset_base</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">atom_count</span><span class="p">;</span>
<span class="w">  </span><span class="n">Atoms</span><span class="w">    </span><span class="n">atoms</span><span class="p">[</span><span class="n">atom_count0</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">HeaderData</span></code> defines the base DIE offset that should be added to any atoms
that are encoded using the <code class="docutils literal notranslate"><span class="pre">DW_FORM_ref1</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_FORM_ref2</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_FORM_ref4</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_FORM_ref8</span></code> or <code class="docutils literal notranslate"><span class="pre">DW_FORM_ref_udata</span></code>.  It also defines
what is contained in each <code class="docutils literal notranslate"><span class="pre">HashData</span></code> object – <code class="docutils literal notranslate"><span class="pre">Atom.form</span></code> tells us how large
each field will be in the <code class="docutils literal notranslate"><span class="pre">HashData</span></code> and the <code class="docutils literal notranslate"><span class="pre">Atom.type</span></code> tells us how this data
should be interpreted.</p>
<p>For the current implementations of the “<code class="docutils literal notranslate"><span class="pre">.apple_names</span></code>” (all functions +
globals), the “<code class="docutils literal notranslate"><span class="pre">.apple_types</span></code>” (names of all types that are defined), and
the “<code class="docutils literal notranslate"><span class="pre">.apple_namespaces</span></code>” (all namespaces), we currently set the <code class="docutils literal notranslate"><span class="pre">Atom</span></code>
array to be:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">HeaderData</span><span class="p">.</span><span class="n">atom_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">HeaderData</span><span class="p">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eAtomTypeDIEOffset</span><span class="p">;</span>
<span class="n">HeaderData</span><span class="p">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">form</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DW_FORM_data4</span><span class="p">;</span>
</pre></div>
</div>
<p>This defines the contents to be the DIE offset (<code class="docutils literal notranslate"><span class="pre">eAtomTypeDIEOffset</span></code>) that is
encoded as a 32-bit value (<code class="docutils literal notranslate"><span class="pre">DW_FORM_data4</span></code>).  This allows a single name to have
multiple matching DIEs in a single file, which could come up with an inlined
function for instance.  Future tables could include more information about the
DIE such as flags indicating if the DIE is a function, method, block,
or inlined.</p>
<p>The KeyType for the DWARF table is a 32-bit string table offset into the
“.debug_str” table.  The “.debug_str” is the string table for the DWARF which
may already contain copies of all of the strings.  This helps make sure, with
help from the compiler, that we reuse the strings between all of the DWARF
sections and keeps the hash table size down.  Another benefit to having the
compiler generate all strings as <code class="docutils literal notranslate"><span class="pre">DW_FORM_strp</span></code> in the debug info, is that
DWARF parsing can be made much faster.</p>
<p>After a lookup is made, we get an offset into the hash data.  The hash data
needs to be able to deal with 32-bit hash collisions, so the chunk of data
at the offset in the hash data consists of a triple:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">str_offset</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">hash_data_count</span>
<span class="n">HashData</span><span class="p">[</span><span class="n">hash_data_count</span><span class="p">]</span>
</pre></div>
</div>
<p>If “str_offset” is zero, then the bucket contents are done. 99.9% of the
hash data chunks contain a single item (no 32-bit hash collision):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.------------.
| 0x00001023 | uint32_t KeyType (.debug_str[0x0001023] =&gt; &quot;main&quot;)
| 0x00000004 | uint32_t HashData count
| 0x........ | uint32_t HashData[0] DIE offset
| 0x........ | uint32_t HashData[1] DIE offset
| 0x........ | uint32_t HashData[2] DIE offset
| 0x........ | uint32_t HashData[3] DIE offset
| 0x00000000 | uint32_t KeyType (end of hash chain)
`------------&#39;
</pre></div>
</div>
<p>If there are collisions, you will have multiple valid string offsets:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.------------.
| 0x00001023 | uint32_t KeyType (.debug_str[0x0001023] =&gt; &quot;main&quot;)
| 0x00000004 | uint32_t HashData count
| 0x........ | uint32_t HashData[0] DIE offset
| 0x........ | uint32_t HashData[1] DIE offset
| 0x........ | uint32_t HashData[2] DIE offset
| 0x........ | uint32_t HashData[3] DIE offset
| 0x00002023 | uint32_t KeyType (.debug_str[0x0002023] =&gt; &quot;print&quot;)
| 0x00000002 | uint32_t HashData count
| 0x........ | uint32_t HashData[0] DIE offset
| 0x........ | uint32_t HashData[1] DIE offset
| 0x00000000 | uint32_t KeyType (end of hash chain)
`------------&#39;
</pre></div>
</div>
<p>Current testing with real world C++ binaries has shown that there is around 1
32-bit hash collision per 100,000 name entries.</p>
</section>
</section>
<section id="id10">
<h4><a class="toc-backref" href="#id59" role="doc-backlink">Contents</a><a class="headerlink" href="#id10" title="Link to this heading">¶</a></h4>
<p>As we said, we want to strictly define exactly what is included in the
different tables.  For DWARF, we have 3 tables: “<code class="docutils literal notranslate"><span class="pre">.apple_names</span></code>”,
“<code class="docutils literal notranslate"><span class="pre">.apple_types</span></code>”, and “<code class="docutils literal notranslate"><span class="pre">.apple_namespaces</span></code>”.</p>
<p>“<code class="docutils literal notranslate"><span class="pre">.apple_names</span></code>” sections should contain an entry for each DWARF DIE whose
<code class="docutils literal notranslate"><span class="pre">DW_TAG</span></code> is a <code class="docutils literal notranslate"><span class="pre">DW_TAG_label</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_TAG_inlined_subroutine</span></code>, or
<code class="docutils literal notranslate"><span class="pre">DW_TAG_subprogram</span></code> that has address attributes: <code class="docutils literal notranslate"><span class="pre">DW_AT_low_pc</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_AT_high_pc</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_AT_ranges</span></code> or <code class="docutils literal notranslate"><span class="pre">DW_AT_entry_pc</span></code>.  It also contains
<code class="docutils literal notranslate"><span class="pre">DW_TAG_variable</span></code> DIEs that have a <code class="docutils literal notranslate"><span class="pre">DW_OP_addr</span></code> in the location (global and
static variables).  All global and static variables should be included,
including those scoped within functions and classes.  For example using the
following code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="w"> </span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Both of the static <code class="docutils literal notranslate"><span class="pre">var</span></code> variables would be included in the table.  All
functions should emit both their full names and their basenames.  For C or C++,
the full name is the mangled name (if available) which is usually in the
<code class="docutils literal notranslate"><span class="pre">DW_AT_MIPS_linkage_name</span></code> attribute, and the <code class="docutils literal notranslate"><span class="pre">DW_AT_name</span></code> contains the
function basename.  If global or static variables have a mangled name in a
<code class="docutils literal notranslate"><span class="pre">DW_AT_MIPS_linkage_name</span></code> attribute, this should be emitted along with the
simple name found in the <code class="docutils literal notranslate"><span class="pre">DW_AT_name</span></code> attribute.</p>
<p>“<code class="docutils literal notranslate"><span class="pre">.apple_types</span></code>” sections should contain an entry for each DWARF DIE whose
tag is one of:</p>
<ul class="simple">
<li><p>DW_TAG_array_type</p></li>
<li><p>DW_TAG_class_type</p></li>
<li><p>DW_TAG_enumeration_type</p></li>
<li><p>DW_TAG_pointer_type</p></li>
<li><p>DW_TAG_reference_type</p></li>
<li><p>DW_TAG_string_type</p></li>
<li><p>DW_TAG_structure_type</p></li>
<li><p>DW_TAG_subroutine_type</p></li>
<li><p>DW_TAG_typedef</p></li>
<li><p>DW_TAG_union_type</p></li>
<li><p>DW_TAG_ptr_to_member_type</p></li>
<li><p>DW_TAG_set_type</p></li>
<li><p>DW_TAG_subrange_type</p></li>
<li><p>DW_TAG_base_type</p></li>
<li><p>DW_TAG_const_type</p></li>
<li><p>DW_TAG_immutable_type</p></li>
<li><p>DW_TAG_file_type</p></li>
<li><p>DW_TAG_namelist</p></li>
<li><p>DW_TAG_packed_type</p></li>
<li><p>DW_TAG_volatile_type</p></li>
<li><p>DW_TAG_restrict_type</p></li>
<li><p>DW_TAG_atomic_type</p></li>
<li><p>DW_TAG_interface_type</p></li>
<li><p>DW_TAG_unspecified_type</p></li>
<li><p>DW_TAG_shared_type</p></li>
</ul>
<p>Only entries with a <code class="docutils literal notranslate"><span class="pre">DW_AT_name</span></code> attribute are included, and the entry must
not be a forward declaration (<code class="docutils literal notranslate"><span class="pre">DW_AT_declaration</span></code> attribute with a non-zero
value).  For example, using the following code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We get a few type DIEs:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0x00000067:     TAG_base_type [5]
                AT_encoding( DW_ATE_signed )
                AT_name( &quot;int&quot; )
                AT_byte_size( 0x04 )

0x0000006e:     TAG_pointer_type [6]
                AT_type( {0x00000067} ( int ) )
                AT_byte_size( 0x08 )
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_TAG_pointer_type</span></code> is not included because it does not have a <code class="docutils literal notranslate"><span class="pre">DW_AT_name</span></code>.</p>
<p>“<code class="docutils literal notranslate"><span class="pre">.apple_namespaces</span></code>” section should contain all <code class="docutils literal notranslate"><span class="pre">DW_TAG_namespace</span></code> DIEs.
If we run into a namespace that has no name this is an anonymous namespace, and
the name should be output as “<code class="docutils literal notranslate"><span class="pre">(anonymous</span> <span class="pre">namespace)</span></code>” (without the quotes).
Why?  This matches the output of the <code class="docutils literal notranslate"><span class="pre">abi::cxa_demangle()</span></code> that is in the
standard C++ library that demangles mangled names.</p>
</section>
<section id="language-extensions-and-file-format-changes">
<h4><a class="toc-backref" href="#id60" role="doc-backlink">Language Extensions and File Format Changes</a><a class="headerlink" href="#language-extensions-and-file-format-changes" title="Link to this heading">¶</a></h4>
<section id="objective-c-extensions">
<h5><a class="toc-backref" href="#id61" role="doc-backlink">Objective-C Extensions</a><a class="headerlink" href="#objective-c-extensions" title="Link to this heading">¶</a></h5>
<p>“<code class="docutils literal notranslate"><span class="pre">.apple_objc</span></code>” section should contain all <code class="docutils literal notranslate"><span class="pre">DW_TAG_subprogram</span></code> DIEs for an
Objective-C class.  The name used in the hash table is the name of the
Objective-C class itself.  If the Objective-C class has a category, then an
entry is made for both the class name without the category, and for the class
name with the category.  So if we have a DIE at offset 0x1234 with a name of
method “<code class="docutils literal notranslate"><span class="pre">-[NSString(my_additions)</span> <span class="pre">stringWithSpecialString:]</span></code>”, we would add
an entry for “<code class="docutils literal notranslate"><span class="pre">NSString</span></code>” that points to DIE 0x1234, and an entry for
“<code class="docutils literal notranslate"><span class="pre">NSString(my_additions)</span></code>” that points to 0x1234.  This allows us to quickly
track down all Objective-C methods for an Objective-C class when doing
expressions.  It is needed because of the dynamic nature of Objective-C where
anyone can add methods to a class.  The DWARF for Objective-C methods is also
emitted differently from C++ classes where the methods are not usually
contained in the class definition, they are scattered about across one or more
compile units.  Categories can also be defined in different shared libraries.
So we need to be able to quickly find all of the methods and class functions
given the Objective-C class name, or quickly find all methods and class
functions for a class + category name.  This table does not contain any
selector names, it just maps Objective-C class names (or class names +
category) to all of the methods and class functions.  The selectors are added
as function basenames in the “<code class="docutils literal notranslate"><span class="pre">.debug_names</span></code>” section.</p>
<p>In the “<code class="docutils literal notranslate"><span class="pre">.apple_names</span></code>” section for Objective-C functions, the full name is
the entire function name with the brackets (”<code class="docutils literal notranslate"><span class="pre">-[NSString</span>
<span class="pre">stringWithCString:]</span></code>”) and the basename is the selector only
(”<code class="docutils literal notranslate"><span class="pre">stringWithCString:</span></code>”).</p>
</section>
<section id="mach-o-changes">
<h5><a class="toc-backref" href="#id62" role="doc-backlink">Mach-O Changes</a><a class="headerlink" href="#mach-o-changes" title="Link to this heading">¶</a></h5>
<p>The sections names for the apple hash tables are for non-mach-o files.  For
mach-o files, the sections should be contained in the <code class="docutils literal notranslate"><span class="pre">__DWARF</span></code> segment with
names as follows:</p>
<ul class="simple">
<li><p>“<code class="docutils literal notranslate"><span class="pre">.apple_names</span></code>” -&gt; “<code class="docutils literal notranslate"><span class="pre">__apple_names</span></code>”</p></li>
<li><p>“<code class="docutils literal notranslate"><span class="pre">.apple_types</span></code>” -&gt; “<code class="docutils literal notranslate"><span class="pre">__apple_types</span></code>”</p></li>
<li><p>“<code class="docutils literal notranslate"><span class="pre">.apple_namespaces</span></code>” -&gt; “<code class="docutils literal notranslate"><span class="pre">__apple_namespac</span></code>” (16 character limit)</p></li>
<li><p>“<code class="docutils literal notranslate"><span class="pre">.apple_objc</span></code>” -&gt; “<code class="docutils literal notranslate"><span class="pre">__apple_objc</span></code>”</p></li>
</ul>
</section>
</section>
</section>
</section>
<section id="codeview-debug-info-format">
<span id="codeview"></span><h2><a class="toc-backref" href="#id63" role="doc-backlink">CodeView Debug Info Format</a><a class="headerlink" href="#codeview-debug-info-format" title="Link to this heading">¶</a></h2>
<p>LLVM supports emitting CodeView, the Microsoft debug info format, and this
section describes the design and implementation of that support.</p>
<section id="format-background">
<h3><a class="toc-backref" href="#id64" role="doc-backlink">Format Background</a><a class="headerlink" href="#format-background" title="Link to this heading">¶</a></h3>
<p>CodeView as a format is clearly oriented around C++ debugging, and in C++, the
majority of debug information tends to be type information. Therefore, the
overriding design constraint of CodeView is the separation of type information
from other “symbol” information so that type information can be efficiently
merged across translation units. Both type information and symbol information is
generally stored as a sequence of records, where each record begins with a
16-bit record size and a 16-bit record kind.</p>
<p>Type information is usually stored in the <code class="docutils literal notranslate"><span class="pre">.debug$T</span></code> section of the object
file.  All other debug info, such as line info, string table, symbol info, and
inlinee info, is stored in one or more <code class="docutils literal notranslate"><span class="pre">.debug$S</span></code> sections. There may only be
one <code class="docutils literal notranslate"><span class="pre">.debug$T</span></code> section per object file, since all other debug info refers to
it. If a PDB (enabled by the <code class="docutils literal notranslate"><span class="pre">/Zi</span></code> MSVC option) was used during compilation,
the <code class="docutils literal notranslate"><span class="pre">.debug$T</span></code> section will contain only an <code class="docutils literal notranslate"><span class="pre">LF_TYPESERVER2</span></code> record pointing
to the PDB. When using PDBs, symbol information appears to remain in the object
file <code class="docutils literal notranslate"><span class="pre">.debug$S</span></code> sections.</p>
<p>Type records are referred to by their index, which is the number of records in
the stream before a given record plus <code class="docutils literal notranslate"><span class="pre">0x1000</span></code>. Many common basic types, such
as the basic integral types and unqualified pointers to them, are represented
using type indices less than <code class="docutils literal notranslate"><span class="pre">0x1000</span></code>. Such basic types are built in to
CodeView consumers and do not require type records.</p>
<p>Each type record may only contain type indices that are less than its own type
index. This ensures that the graph of type stream references is acyclic. While
the source-level type graph may contain cycles through pointer types (consider a
linked list struct), these cycles are removed from the type stream by always
referring to the forward declaration record of user-defined record types. Only
“symbol” records in the <code class="docutils literal notranslate"><span class="pre">.debug$S</span></code> streams may refer to complete,
non-forward-declaration type records.</p>
</section>
<section id="working-with-codeview">
<h3><a class="toc-backref" href="#id65" role="doc-backlink">Working with CodeView</a><a class="headerlink" href="#working-with-codeview" title="Link to this heading">¶</a></h3>
<p>These are instructions for some common tasks for developers working to improve
LLVM’s CodeView support. Most of them revolve around using the CodeView dumper
embedded in <code class="docutils literal notranslate"><span class="pre">llvm-readobj</span></code>.</p>
<ul>
<li><p>Testing MSVC’s output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cl -c -Z7 foo.cpp # Use /Z7 to keep types in the object file
$ llvm-readobj --codeview foo.obj
</pre></div>
</div>
</li>
<li><p>Getting LLVM IR debug info out of Clang:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ clang -g -gcodeview --target=x86_64-windows-msvc foo.cpp -S -emit-llvm
</pre></div>
</div>
<p>Use this to generate LLVM IR for LLVM test cases.</p>
</li>
<li><p>Generate and dump CodeView from LLVM IR metadata:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ llc foo.ll -filetype=obj -o foo.obj
$ llvm-readobj --codeview foo.obj &gt; foo.txt
</pre></div>
</div>
<p>Use this pattern in lit test cases and FileCheck the output of llvm-readobj</p>
</li>
</ul>
<p>Improving LLVM’s CodeView support is a process of finding interesting type
records, constructing a C++ test case that makes MSVC emit those records,
dumping the records, understanding them, and then generating equivalent records
in LLVM’s backend.</p>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="AssignmentTracking.html" title="Debug Info Assignment Tracking"
             >next</a> |</li>
        <li class="right" >
          <a href="RISCV/RISCVVectorExtension.html" title="RISC-V Vector Extension"
             >previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" >User Guides</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Source Level Debugging with LLVM</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2003-2026, LLVM Project.
      Last updated on 2026-02-10.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>