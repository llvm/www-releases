
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>User Guide for SPIR-V Target &#8212; LLVM 22.1.0-rc3 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/llvm-theme.css?v=96924833" />
    <script src="_static/documentation_options.js?v=b417f315"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Sandbox IR: A transactional layer over LLVM IR" href="SandboxIR.html" />
    <link rel="prev" title="Debug Info Assignment Tracking" href="AssignmentTracking.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="SandboxIR.html" title="Sandbox IR: A transactional layer over LLVM IR"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="AssignmentTracking.html" title="Debug Info Assignment Tracking"
             accesskey="P">previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" accesskey="U">User Guides</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">User Guide for SPIR-V Target</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="https://llvm.org/docs/UserGuides.html">User Guides</a></li>
    <li><a href="https://llvm.org/docs/Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/Contributing.html">Contributing to LLVM</a></li>
    <li><a href="https://llvm.org/docs/HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#discord">Discord</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/FAQ.html">FAQ</a></li>
    <li><a href="https://llvm.org/docs/Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project/">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/SPIRVUsage.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="user-guide-for-spir-v-target">
<h1>User Guide for SPIR-V Target<a class="headerlink" href="#user-guide-for-spir-v-target" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id11">Introduction</a></p></li>
<li><p><a class="reference internal" href="#usage" id="id12">Usage</a></p>
<ul>
<li><p><a class="reference internal" href="#static-compiler-commands" id="id13">Static Compiler Commands</a></p></li>
<li><p><a class="reference internal" href="#clang-commands" id="id14">Clang Commands</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#compiler-options" id="id15">Compiler Options</a></p>
<ul>
<li><p><a class="reference internal" href="#target-triples" id="id16">Target Triples</a></p></li>
<li><p><a class="reference internal" href="#extensions" id="id17">Extensions</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#spir-v-representation-in-llvm-ir" id="id18">SPIR-V representation in LLVM IR</a></p>
<ul>
<li><p><a class="reference internal" href="#special-types" id="id19">Special types</a></p></li>
<li><p><a class="reference internal" href="#inline-spir-v-types" id="id20">Inline SPIR-V Types</a></p></li>
<li><p><a class="reference internal" href="#target-intrinsics" id="id21">Target Intrinsics</a></p></li>
<li><p><a class="reference internal" href="#builtin-functions" id="id22">Builtin Functions</a></p>
<ul>
<li><p><a class="reference internal" href="#instructions-as-function-calls" id="id23">Instructions as Function Calls</a></p></li>
<li><p><a class="reference internal" href="#extended-instruction-sets" id="id24">Extended Instruction Sets</a></p></li>
<li><p><a class="reference internal" href="#builtin-variables" id="id25">Builtin Variables</a></p></li>
<li><p><a class="reference internal" href="#vector-load-and-store-builtins" id="id26">Vector Load and Store Builtins</a></p></li>
<li><p><a class="reference internal" href="#atomic-operations" id="id27">Atomic Operations</a></p></li>
<li><p><a class="reference internal" href="#image-operations" id="id28">Image Operations</a></p></li>
<li><p><a class="reference internal" href="#group-and-subgroup-operations" id="id29">Group and Subgroup Operations</a></p></li>
<li><p><a class="reference internal" href="#spir-v-instructions-mapped-to-llvm-metadata" id="id30">SPIR-V Instructions Mapped to LLVM Metadata</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<div class="toctree-wrapper compound">
</div>
<section id="introduction">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>The SPIR-V target provides code generation for the SPIR-V binary format described
in  <a class="reference external" href="https://www.khronos.org/registry/SPIR-V/">the official SPIR-V specification</a>.</p>
</section>
<section id="usage">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">Usage</a><a class="headerlink" href="#usage" title="Link to this heading">¶</a></h2>
<p>The SPIR-V backend can be invoked either from LLVM’s Static Compiler (llc) or Clang,
allowing developers to compile LLVM intermediate language (IL) files or OpenCL kernel
sources directly to SPIR-V. This section outlines the usage of various commands to
leverage the SPIR-V backend for different purposes.</p>
<section id="static-compiler-commands">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Static Compiler Commands</a><a class="headerlink" href="#static-compiler-commands" title="Link to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p><strong>Basic SPIR-V Compilation</strong>
Command: <cite>llc -mtriple=spirv32-unknown-unknown input.ll -o output.spvt</cite>
Description: This command compiles an LLVM IL file (<cite>input.ll</cite>) to a SPIR-V binary (<cite>output.spvt</cite>) for a 32-bit architecture.</p></li>
<li><p><strong>Compilation with Extensions and Optimization</strong>
Command: <cite>llc -O1 -mtriple=spirv64-unknown-unknown –spirv-ext=+SPV_ALTERA_arbitrary_precision_integers input.ll -o output.spvt</cite>
Description: Compiles an LLVM IL file to SPIR-V with (<cite>-O1</cite>) optimizations, targeting a 64-bit architecture. It enables the SPV_ALTERA_arbitrary_precision_integers extension.</p></li>
<li><p><strong>Compilation with experimental NonSemantic.Shader.DebugInfo.100 support</strong>
Command: <cite>llc –spv-emit-nonsemantic-debug-info –spirv-ext=+SPV_KHR_non_semantic_info input.ll -o output.spvt</cite>
Description: Compiles an LLVM IL file to SPIR-V with additional NonSemantic.Shader.DebugInfo.100 instructions. It enables the required SPV_KHR_non_semantic_info extension.</p></li>
<li><p><strong>SPIR-V Binary Generation</strong>
Command: <cite>llc -O0 -mtriple=spirv64-unknown-unknown -filetype=obj input.ll -o output.spvt</cite>
Description: Generates a SPIR-V object file (<cite>output.spvt</cite>) from an LLVM module, targeting a 64-bit SPIR-V architecture with no optimizations.</p></li>
</ol>
</section>
<section id="clang-commands">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Clang Commands</a><a class="headerlink" href="#clang-commands" title="Link to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p><strong>SPIR-V Generation</strong>
Command: <cite>clang –target=spirv64 input.cl</cite>
Description: Generates a SPIR-V file directly from an OpenCL kernel source file (<cite>input.cl</cite>).</p></li>
</ol>
</section>
</section>
<section id="compiler-options">
<h2><a class="toc-backref" href="#id15" role="doc-backlink">Compiler Options</a><a class="headerlink" href="#compiler-options" title="Link to this heading">¶</a></h2>
<section id="target-triples">
<span id="spirv-target-triples"></span><h3><a class="toc-backref" href="#id16" role="doc-backlink">Target Triples</a><a class="headerlink" href="#target-triples" title="Link to this heading">¶</a></h3>
<p>For cross-compilation into SPIR-V use option</p>
<p><code class="docutils literal notranslate"><span class="pre">-target</span> <span class="pre">&lt;Architecture&gt;&lt;Subarchitecture&gt;-&lt;Vendor&gt;-&lt;OS&gt;-&lt;Environment&gt;</span></code></p>
<p>to specify the target triple:</p>
<blockquote>
<div><table class="docutils align-default" id="id2">
<caption><span class="caption-number">Table 133 </span><span class="caption-text">SPIR-V Architectures</span><a class="headerlink" href="#id2" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Architecture</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">spirv32</span></code></p></td>
<td><p>SPIR-V with 32-bit pointer width.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">spirv64</span></code></p></td>
<td><p>SPIR-V with 64-bit pointer width.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">spirv</span></code></p></td>
<td><p>SPIR-V with logical memory layout.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id3">
<caption><span class="caption-number">Table 134 </span><span class="caption-text">SPIR-V Subarchitectures</span><a class="headerlink" href="#id3" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Subarchitecture</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>&lt;empty&gt;</em></p></td>
<td><p>SPIR-V version deduced by backend based on the input.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">v1.0</span></code></p></td>
<td><p>SPIR-V version 1.0.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">v1.1</span></code></p></td>
<td><p>SPIR-V version 1.1.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">v1.2</span></code></p></td>
<td><p>SPIR-V version 1.2.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">v1.3</span></code></p></td>
<td><p>SPIR-V version 1.3.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">v1.4</span></code></p></td>
<td><p>SPIR-V version 1.4.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">v1.5</span></code></p></td>
<td><p>SPIR-V version 1.5.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">v1.6</span></code></p></td>
<td><p>SPIR-V version 1.6.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id4">
<caption><span class="caption-number">Table 135 </span><span class="caption-text">SPIR-V Vendors</span><a class="headerlink" href="#id4" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Vendor</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>&lt;empty&gt;</em>/<code class="docutils literal notranslate"><span class="pre">unknown</span></code></p></td>
<td><p>Generic SPIR-V target without any vendor-specific settings.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">amd</span></code></p></td>
<td><p>AMDGCN SPIR-V target, with support for target specific
builtins and ASM, meant to be consumed by AMDGCN toolchains.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id5">
<caption><span class="caption-number">Table 136 </span><span class="caption-text">Operating Systems</span><a class="headerlink" href="#id5" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>OS</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>&lt;empty&gt;</em>/<code class="docutils literal notranslate"><span class="pre">unknown</span></code></p></td>
<td><p>Defaults to the OpenCL runtime.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">vulkan</span></code></p></td>
<td><p>Vulkan shader runtime.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">vulkan1.2</span></code></p></td>
<td><p>Vulkan 1.2 runtime, corresponding to SPIR-V 1.5.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">vulkan1.3</span></code></p></td>
<td><p>Vulkan 1.3 runtime, corresponding to SPIR-V 1.6.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">amdhsa</span></code></p></td>
<td><p>AMDHSA runtime, meant to be used on HSA compatible runtimes,
corresponding to SPIR-V 1.6.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id6">
<caption><span class="caption-number">Table 137 </span><span class="caption-text">SPIR-V Environments</span><a class="headerlink" href="#id6" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Environment</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>&lt;empty&gt;</em>/<code class="docutils literal notranslate"><span class="pre">unknown</span></code></p></td>
<td><p>OpenCL environment or deduced by backend based on the input.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Example:</p>
<p><code class="docutils literal notranslate"><span class="pre">-target</span> <span class="pre">spirv64v1.0</span></code> can be used to compile for SPIR-V version 1.0 with 64-bit pointer width.</p>
<p><code class="docutils literal notranslate"><span class="pre">-target</span> <span class="pre">spirv64-amd-amdhsa</span></code> can be used to compile for AMDGCN flavoured SPIR-V with 64-bit pointer width.</p>
</section>
<section id="extensions">
<span id="spirv-extensions"></span><h3><a class="toc-backref" href="#id17" role="doc-backlink">Extensions</a><a class="headerlink" href="#extensions" title="Link to this heading">¶</a></h3>
<p>The SPIR-V backend supports a variety of <a class="reference external" href="https://github.com/KhronosGroup/SPIRV-Registry/tree/main/extensions">extensions</a>
that enable or enhance features beyond the core SPIR-V specification.
The enabled extensions can be controlled using the <code class="docutils literal notranslate"><span class="pre">-spirv-ext</span></code> option followed by a list of
extensions to enable or disable, each prefixed with <code class="docutils literal notranslate"><span class="pre">+</span></code> or <code class="docutils literal notranslate"><span class="pre">-</span></code>, respectively.</p>
<p>To enable multiple extensions, list them separated by comma. For example, to enable support for atomic operations on floating-point numbers and arbitrary precision integers, use:</p>
<p><code class="docutils literal notranslate"><span class="pre">-spirv-ext=+SPV_EXT_shader_atomic_float_add,+SPV_ALTERA_arbitrary_precision_integers</span></code></p>
<p>To enable all extensions, use the following option:
<code class="docutils literal notranslate"><span class="pre">-spirv-ext=all</span></code></p>
<p>To enable all KHR extensions, use the following option:
<code class="docutils literal notranslate"><span class="pre">-spirv-ext=khr</span></code></p>
<p>To enable all extensions except specified, specify <code class="docutils literal notranslate"><span class="pre">all</span></code> followed by a list of disallowed extensions. For example:
<code class="docutils literal notranslate"><span class="pre">-spirv-ext=all,-SPV_ALTERA_arbitrary_precision_integers</span></code></p>
<p>Below is a list of supported SPIR-V extensions, sorted alphabetically by their extension names:</p>
<table class="docutils align-default" id="id7">
<caption><span class="caption-number">Table 138 </span><span class="caption-text">Supported SPIR-V Extensions</span><a class="headerlink" href="#id7" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Extension Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_EXT_arithmetic_fence</span></code></p></td>
<td><p>Adds an instruction that prevents fast-math optimizations between its argument and the expression that contains it.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_EXT_demote_to_helper_invocation</span></code></p></td>
<td><p>Adds an instruction that demotes a fragment shader invocation to a helper invocation.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_EXT_optnone</span></code></p></td>
<td><p>Adds OptNoneEXT value for Function Control mask that indicates a request to not optimize the function.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_EXT_shader_atomic_float16_add</span></code></p></td>
<td><p>Extends the SPV_EXT_shader_atomic_float_add extension to support atomically adding to 16-bit floating-point numbers in memory.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_EXT_shader_atomic_float_add</span></code></p></td>
<td><p>Adds atomic add instruction on floating-point numbers.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_EXT_shader_atomic_float_min_max</span></code></p></td>
<td><p>Adds atomic min and max instruction on floating-point numbers.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_16bit_atomics</span></code></p></td>
<td><p>Extends the SPV_EXT_shader_atomic_float_add and SPV_EXT_shader_atomic_float_min_max to support addition, minimum and maximum on 16-bit <cite>bfloat16</cite> floating-point numbers in memory.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_NV_shader_atomic_fp16_vector</span></code></p></td>
<td><p>Adds atomic add, min and max instructions on 2 or 4-component vectors with 16-bit float components.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_2d_block_io</span></code></p></td>
<td><p>Adds additional subgroup block prefetch, load, load transposed, load transformed and store instructions to read two-dimensional blocks of data from a two-dimensional region of memory, or to write two-dimensional blocks of data to a two dimensional region of memory.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_ALTERA_arbitrary_precision_integers</span></code></p></td>
<td><p>Allows generating arbitrary width integer types.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_bindless_images</span></code></p></td>
<td><p>Adds instructions to convert convert unsigned integer handles to images, samplers and sampled images.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_bfloat16_arithmetic</span></code></p></td>
<td><p>Allows the use of 16-bit bfloat16 values in arithmetic and relational operators.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_bfloat16_conversion</span></code></p></td>
<td><p>Adds instructions to convert between single-precision 32-bit floating-point values and 16-bit bfloat16 values.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_cache_controls</span></code></p></td>
<td><p>Allows cache control information to be applied to memory access instructions.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_float_controls2</span></code></p></td>
<td><p>Adds execution modes and decorations to control floating-point computations.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_function_pointers</span></code></p></td>
<td><p>Allows translation of function pointers.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_inline_assembly</span></code></p></td>
<td><p>Allows to use inline assembly.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_global_variable_host_access</span></code></p></td>
<td><p>Adds decorations that can be applied to global (module scope) variables.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_global_variable_fpga_decorations</span></code></p></td>
<td><p>Adds decorations that can be applied to global (module scope) variables to help code generation for FPGA devices.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_kernel_attributes</span></code></p></td>
<td><p>Adds execution modes that can be applied to entry points to inform scheduling.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_media_block_io</span></code></p></td>
<td><p>Adds additional subgroup block read and write functionality that allow applications to flexibly specify the width and height of the block to read from or write to a 2D image.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_memory_access_aliasing</span></code></p></td>
<td><p>Adds instructions and decorations to specify memory access aliasing, similar to alias.scope and noalias LLVM metadata.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_optnone</span></code></p></td>
<td><p>Adds OptNoneINTEL value for Function Control mask that indicates a request to not optimize the function.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_split_barrier</span></code></p></td>
<td><p>Adds SPIR-V instructions to split a control barrier into two separate operations: the first indicates that an invocation has “arrived” at the barrier but should continue executing, and the second indicates that an invocation should “wait” for other invocations to arrive at the barrier before executing further.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_subgroups</span></code></p></td>
<td><p>Allows work items in a subgroup to share data without the use of local memory and work group barriers, and to utilize specialized hardware to load and store blocks of data from images or buffers.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_usm_storage_classes</span></code></p></td>
<td><p>Introduces two new storage classes that are subclasses of the CrossWorkgroup storage class that provides additional information that can enable optimization.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_variable_length_array</span></code></p></td>
<td><p>Allows to allocate local arrays whose number of elements is unknown at compile time.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_joint_matrix</span></code></p></td>
<td><p>Adds few matrix capabilities on top of SPV_KHR_cooperative_matrix extension, such as matrix prefetch, get element coordinate and checked load/store/construct instructions, tensor float 32 and bfloat type interpretations for multiply-add instruction.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_KHR_bit_instructions</span></code></p></td>
<td><p>Enables bit instructions to be used by SPIR-V modules without requiring the Shader capability.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_KHR_expect_assume</span></code></p></td>
<td><p>Provides additional information to a compiler, similar to the llvm.assume and llvm.expect intrinsics.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_KHR_float_controls</span></code></p></td>
<td><p>Provides new execution modes to control floating-point computations by overriding an implementation’s default behavior for rounding modes, denormals, signed zero, and infinities.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_KHR_integer_dot_product</span></code></p></td>
<td><p>Adds instructions for dot product operations on integer vectors with optional accumulation. Integer vectors includes 4-component vector of 8-bit integers and 4-component vectors of 8-bit integers packed into 32-bit integers.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_KHR_linkonce_odr</span></code></p></td>
<td><p>Allows to use the LinkOnceODR linkage type that lets a function or global variable to be merged with other functions or global variables of the same name when linkage occurs.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_KHR_no_integer_wrap_decoration</span></code></p></td>
<td><p>Adds decorations to indicate that a given instruction does not cause integer wrapping.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_KHR_shader_clock</span></code></p></td>
<td><p>Adds the extension cl_khr_kernel_clock that adds the ability for a kernel to sample the value from clocks provided by compute units.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_KHR_subgroup_rotate</span></code></p></td>
<td><p>Adds a new instruction that enables rotating values across invocations within a subgroup.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_KHR_uniform_group_instructions</span></code></p></td>
<td><p>Allows support for additional group operations within uniform control flow.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_KHR_non_semantic_info</span></code></p></td>
<td><p>Adds the ability to declare extended instruction sets that have no semantic impact and can be safely removed from a module.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_fp_max_error</span></code></p></td>
<td><p>Adds the ability to specify the maximum error for floating-point operations.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_ternary_bitwise_function</span></code></p></td>
<td><p>Adds a bitwise instruction on three operands and a look-up table index for specifying the bitwise operation to perform.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_subgroup_matrix_multiply_accumulate</span></code></p></td>
<td><p>Adds an instruction to compute the matrix product of an M x K matrix with a K x N matrix and then add an M x N matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_int4</span></code></p></td>
<td><p>Adds support for 4-bit integer type, and allow this type to be used in cooperative matrices.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_KHR_float_controls2</span></code></p></td>
<td><p>Adds execution modes and decorations to control floating-point computations in both kernels and shaders. It can be used on whole modules and individual instructions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_INTEL_predicated_io</span></code></p></td>
<td><p>Adds predicated load and store instructions that conditionally read from or write to memory based on a boolean predicate.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_KHR_maximal_reconvergence</span></code></p></td>
<td><p>Adds execution mode and capability to enable maximal reconvergence.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_ALTERA_blocking_pipes</span></code></p></td>
<td><p>Adds new pipe read and write functions that have blocking semantics instead of the non-blocking semantics of the existing pipe read/write functions.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_ALTERA_arbitrary_precision_fixed_point</span></code></p></td>
<td><p>Add instructions for fixed point arithmetic. The extension works without SPV_ALTERA_arbitrary_precision_integers, but together they allow greater flexibility in representing arbitrary precision data types.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">SPV_EXT_image_raw10_raw12</span></code></p></td>
<td><p>Adds Image Channel Data Type definitions for RAW10 and RAW12 image formats.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="spir-v-representation-in-llvm-ir">
<h2><a class="toc-backref" href="#id18" role="doc-backlink">SPIR-V representation in LLVM IR</a><a class="headerlink" href="#spir-v-representation-in-llvm-ir" title="Link to this heading">¶</a></h2>
<p>SPIR-V is intentionally designed for seamless integration with various Intermediate
Representations (IRs), including LLVM IR, facilitating straightforward mappings for
most of its entities. The development of the SPIR-V backend has been guided by a
principle of compatibility with the <a class="reference external" href="https://github.com/KhronosGroup/SPIRV-LLVM-Translator">Khronos Group SPIR-V LLVM Translator</a>.
Consequently, the input representation accepted by the SPIR-V backend aligns closely
with that detailed in <a class="reference external" href="https://github.com/KhronosGroup/SPIRV-LLVM-Translator/blob/main/docs/SPIRVRepresentationInLLVM.rst">the SPIR-V Representation in LLVM document</a>.
This document, along with the sections that follow, delineate the main points and focus
on any differences between the LLVM IR that this backend processes and the conventions
used by other tools.</p>
<section id="special-types">
<span id="spirv-special-types"></span><h3><a class="toc-backref" href="#id19" role="doc-backlink">Special types</a><a class="headerlink" href="#special-types" title="Link to this heading">¶</a></h3>
<p>SPIR-V specifies several kinds of opaque types. These types are represented
using target extension types and are represented as follows:</p>
<blockquote>
<div><table class="docutils align-default" id="id8">
<caption><span class="caption-number">Table 139 </span><span class="caption-text">SPIR-V Opaque Types</span><a class="headerlink" href="#id8" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>SPIR-V Type</p></th>
<th class="head"><p>LLVM type name</p></th>
<th class="head"><p>LLVM type arguments</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>OpTypeImage</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">spirv.Image</span></code></p></td>
<td><p>sampled type, dimensionality, depth, arrayed, MS, sampled, image format, [access qualifier]</p></td>
</tr>
<tr class="row-odd"><td><p>OpTypeImage</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">spirv.SignedImage</span></code></p></td>
<td><p>sampled type, dimensionality, depth, arrayed, MS, sampled, image format, [access qualifier]</p></td>
</tr>
<tr class="row-even"><td><p>OpTypeSampler</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">spirv.Sampler</span></code></p></td>
<td><p>(none)</p></td>
</tr>
<tr class="row-odd"><td><p>OpTypeSampledImage</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">spirv.SampledImage</span></code></p></td>
<td><p>sampled type, dimensionality, depth, arrayed, MS, sampled, image format, [access qualifier]</p></td>
</tr>
<tr class="row-even"><td><p>OpTypeEvent</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">spirv.Event</span></code></p></td>
<td><p>(none)</p></td>
</tr>
<tr class="row-odd"><td><p>OpTypeDeviceEvent</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">spirv.DeviceEvent</span></code></p></td>
<td><p>(none)</p></td>
</tr>
<tr class="row-even"><td><p>OpTypeReserveId</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">spirv.ReserveId</span></code></p></td>
<td><p>(none)</p></td>
</tr>
<tr class="row-odd"><td><p>OpTypeQueue</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">spirv.Queue</span></code></p></td>
<td><p>(none)</p></td>
</tr>
<tr class="row-even"><td><p>OpTypePipe</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">spirv.Pipe</span></code></p></td>
<td><p>access qualifier</p></td>
</tr>
<tr class="row-odd"><td><p>OpTypePipeStorage</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">spirv.PipeStorage</span></code></p></td>
<td><p>(none)</p></td>
</tr>
<tr class="row-even"><td><p>NA</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">spirv.VulkanBuffer</span></code></p></td>
<td><p>ElementType, StorageClass, IsWriteable</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>All integer arguments take the same value as they do in their <a class="reference external" href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_type_declaration_instructions">corresponding
SPIR-V instruction</a>.
For example, the OpenCL type <code class="docutils literal notranslate"><span class="pre">image2d_depth_ro_t</span></code> would be represented in
SPIR-V IR as <code class="docutils literal notranslate"><span class="pre">target(&quot;spirv.Image&quot;,</span> <span class="pre">void,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0)</span></code>, with its
dimensionality parameter as <code class="docutils literal notranslate"><span class="pre">1</span></code> meaning 2D. Sampled image types include the
parameters of its underlying image type, so that a sampled image for the
previous type has the representation
<code class="docutils literal notranslate"><span class="pre">target(&quot;spirv.SampledImage,</span> <span class="pre">void,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0)</span></code>.</p>
<p>The differences between <code class="docutils literal notranslate"><span class="pre">spirv.Image</span></code> and <code class="docutils literal notranslate"><span class="pre">spirv.SignedImage</span></code> is that the
backend will generate code assuming that the format of the image is a signed
integer instead of unsigned. This is required because llvm-ir will create the
same sampled type for signed and unsigned integers. If the image format is
unknown, the backend cannot distinguish the two case.</p>
<p>See <a class="reference external" href="https://github.com/llvm/wg-hlsl/blob/main/proposals/0018-spirv-resource-representation.md">wg-hlsl proposal 0018</a>
for details on <code class="docutils literal notranslate"><span class="pre">spirv.VulkanBuffer</span></code>.</p>
</section>
<section id="inline-spir-v-types">
<span id="inline-spirv-types"></span><h3><a class="toc-backref" href="#id20" role="doc-backlink">Inline SPIR-V Types</a><a class="headerlink" href="#inline-spir-v-types" title="Link to this heading">¶</a></h3>
<p>HLSL allows users to create types representing specific SPIR-V types, using <code class="docutils literal notranslate"><span class="pre">vk::SpirvType</span></code> and
<code class="docutils literal notranslate"><span class="pre">vk::SpirvOpaqueType</span></code>. These are specified in the <a class="reference external" href="https://microsoft.github.io/hlsl-specs/proposals/0011-inline-spirv.html#types">Inline SPIR-V</a> proposal. They may be
represented using target extension types:</p>
<blockquote>
<div><table class="docutils align-default" id="id9">
<caption><span class="caption-number">Table 140 </span><span class="caption-text">Inline SPIR-V Types</span><a class="headerlink" href="#id9" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>LLVM type name</p></th>
<th class="head"><p>LLVM type arguments</p></th>
<th class="head"><p>LLVM integer arguments</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">spirv.Type</span></code></p></td>
<td><p>SPIR-V operands</p></td>
<td><p>opcode, size, alignment</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">spirv.IntegralConstant</span></code></p></td>
<td><p>integral type</p></td>
<td><p>value</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">spirv.Literal</span></code></p></td>
<td><p>(none)</p></td>
<td><p>value</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The operand arguments to <code class="docutils literal notranslate"><span class="pre">spirv.Type</span></code> may be either a <code class="docutils literal notranslate"><span class="pre">spirv.IntegralConstant</span></code> type,
representing an <code class="docutils literal notranslate"><span class="pre">OpConstant</span></code> id operand, a <code class="docutils literal notranslate"><span class="pre">spirv.Literal</span></code> type, representing an immediate
literal operand, or any other type, representing the id of that type as an operand.
<code class="docutils literal notranslate"><span class="pre">spirv.IntegralConstant</span></code> and <code class="docutils literal notranslate"><span class="pre">spirv.Literal</span></code> may not be used outside of this context.</p>
<p>For example, <code class="docutils literal notranslate"><span class="pre">OpTypeArray</span></code> (opcode 28) takes an id for the element type and an id for the element
length, so an array of 16 integers could be declared as:</p>
<p><code class="docutils literal notranslate"><span class="pre">target(&quot;spirv.Type&quot;,</span> <span class="pre">i32,</span> <span class="pre">target(&quot;spirv.IntegralConstant&quot;,</span> <span class="pre">i32,</span> <span class="pre">16),</span> <span class="pre">28,</span> <span class="pre">64,</span> <span class="pre">32)</span></code></p>
<p>This will be lowered to:</p>
<p><code class="docutils literal notranslate"><span class="pre">OpTypeArray</span> <span class="pre">%int</span> <span class="pre">%int_16</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">OpTypeVector</span></code> takes an id for the component type and a literal for the component count, so a
4-integer vector could be declared as:</p>
<p><code class="docutils literal notranslate"><span class="pre">target(&quot;spirv.Type&quot;,</span> <span class="pre">i32,</span> <span class="pre">target(&quot;spirv.Literal&quot;,</span> <span class="pre">4),</span> <span class="pre">23,</span> <span class="pre">16,</span> <span class="pre">32)</span></code></p>
<p>This will be lowered to:</p>
<p><code class="docutils literal notranslate"><span class="pre">OpTypeVector</span> <span class="pre">%int</span> <span class="pre">4</span></code></p>
<p>See <a class="reference external" href="https://github.com/llvm/wg-hlsl/blob/main/proposals/0017-inline-spirv-and-decorated-types.md">Target Extension Types for Inline SPIR-V and Decorated Types</a> for further details.</p>
</section>
<section id="target-intrinsics">
<span id="spirv-intrinsics"></span><h3><a class="toc-backref" href="#id21" role="doc-backlink">Target Intrinsics</a><a class="headerlink" href="#target-intrinsics" title="Link to this heading">¶</a></h3>
<p>The SPIR-V backend employs several LLVM IR intrinsics that facilitate various low-level
operations essential for generating correct and efficient SPIR-V code. These intrinsics
cover a range of functionalities from type assignment and memory management to control
flow and atomic operations. Below is a detailed table of selected intrinsics used in the
SPIR-V backend, along with their descriptions and argument details.</p>
<table class="docutils align-default" id="id10">
<caption><span class="caption-number">Table 141 </span><span class="caption-text">LLVM IR Intrinsics for SPIR-V</span><a class="headerlink" href="#id10" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 25.0%" />
<col style="width: 15.0%" />
<col style="width: 20.0%" />
<col style="width: 40.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Intrinsic ID</p></th>
<th class="head"><p>Return Type</p></th>
<th class="head"><p>Argument Types</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>int_spv_assign_type</cite></p></td>
<td><p>None</p></td>
<td><p><cite>[Type, Metadata]</cite></p></td>
<td><p>Associates a type with metadata, crucial for maintaining type information in SPIR-V structures. Not emitted directly but supports the type system internally.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>int_spv_assign_ptr_type</cite></p></td>
<td><p>None</p></td>
<td><p><cite>[Type, Metadata, Integer]</cite></p></td>
<td><p>Similar to <cite>int_spv_assign_type</cite>, but for pointer types with an additional integer specifying the storage class. Supports SPIR-V’s detailed pointer type system. Not emitted directly.</p></td>
</tr>
<tr class="row-even"><td><p><cite>int_spv_assign_name</cite></p></td>
<td><p>None</p></td>
<td><p><cite>[Type, Vararg]</cite></p></td>
<td><p>Assigns names to types or values, enhancing readability and debuggability of SPIR-V code. Not emitted directly but used for metadata enrichment.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>int_spv_value_md</cite></p></td>
<td><p>None</p></td>
<td><p><cite>[Metadata]</cite></p></td>
<td><p>Assigns a set of attributes (such as name and data type) to a value that is the argument of the associated <cite>llvm.fake.use</cite> intrinsic call. The latter is used as a mean to map virtual registers created by IRTranslator to the original value.</p></td>
</tr>
<tr class="row-even"><td><p><cite>int_spv_assign_decoration</cite></p></td>
<td><p>None</p></td>
<td><p><cite>[Type, Metadata]</cite></p></td>
<td><p>Assigns decoration to values by associating them with metadatas. Not emitted directly but used to support SPIR-V representation in LLVM IR.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>int_spv_assign_aliasing_decoration</cite></p></td>
<td><p>None</p></td>
<td><p><cite>[Type, 32-bit Integer, Metadata]</cite></p></td>
<td><p>Assigns one of two memory aliasing decorations (specified by the second argument) to instructions using original aliasing metadata node. Not emitted directly but used to support SPIR-V representation in LLVM IR.</p></td>
</tr>
<tr class="row-even"><td><p><cite>int_spv_assign_fpmaxerror_decoration</cite></p></td>
<td><p>None</p></td>
<td><p><cite>[Type, Metadata]</cite></p></td>
<td><p>Assigns the maximum error decoration to floating-point instructions using the original metadata node. Not emitted directly but used to support SPIR-V representation in LLVM IR.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>int_spv_track_constant</cite></p></td>
<td><p>Type</p></td>
<td><p><cite>[Type, Metadata]</cite></p></td>
<td><p>Tracks constants in the SPIR-V module. Essential for optimizing and reducing redundancy. Emitted for internal use only.</p></td>
</tr>
<tr class="row-even"><td><p><cite>int_spv_init_global</cite></p></td>
<td><p>None</p></td>
<td><p><cite>[Type, Type]</cite></p></td>
<td><p>Initializes global variables, a necessary step for ensuring correct global state management in SPIR-V. Emitted for internal use only.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>int_spv_unref_global</cite></p></td>
<td><p>None</p></td>
<td><p><cite>[Type]</cite></p></td>
<td><p>Manages the lifetime of global variables by marking them as unreferenced, thus enabling optimizations related to global variable usage. Emitted for internal use only.</p></td>
</tr>
<tr class="row-even"><td><p><cite>int_spv_gep</cite></p></td>
<td><p>Pointer</p></td>
<td><p><cite>[Boolean, Type, Vararg]</cite></p></td>
<td><p>Computes the address of a sub-element of an aggregate type. Critical for accessing array elements and structure fields. Supports conditionally addressing elements in a generic way.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>int_spv_load</cite></p></td>
<td><p>32-bit Integer</p></td>
<td><p><cite>[Pointer, 16-bit Integer, 8-bit Integer]</cite></p></td>
<td><p>Loads a value from a memory location. The additional integers specify memory access and alignment details, vital for ensuring correct and efficient memory operations.</p></td>
</tr>
<tr class="row-even"><td><p><cite>int_spv_store</cite></p></td>
<td><p>None</p></td>
<td><p><cite>[Type, Pointer, 16-bit Integer, 8-bit Integer]</cite></p></td>
<td><p>Stores a value to a memory location. Like <cite>int_spv_load</cite>, it includes specifications for memory access and alignment, essential for memory operations.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>int_spv_extractv</cite></p></td>
<td><p>Type</p></td>
<td><p><cite>[32-bit Integer, Vararg]</cite></p></td>
<td><p>Extracts a value from a vector, allowing for vector operations within SPIR-V. Enables manipulation of vector components.</p></td>
</tr>
<tr class="row-even"><td><p><cite>int_spv_insertv</cite></p></td>
<td><p>32-bit Integer</p></td>
<td><p><cite>[32-bit Integer, Type, Vararg]</cite></p></td>
<td><p>Inserts a value into a vector. Complementary to <cite>int_spv_extractv</cite>, it facilitates the construction and manipulation of vectors.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>int_spv_extractelt</cite></p></td>
<td><p>Type</p></td>
<td><p><cite>[Type, Any Integer]</cite></p></td>
<td><p>Extracts an element from an aggregate type based on an index. Essential for operations on arrays and vectors.</p></td>
</tr>
<tr class="row-even"><td><p><cite>int_spv_insertelt</cite></p></td>
<td><p>Type</p></td>
<td><p><cite>[Type, Type, Any Integer]</cite></p></td>
<td><p>Inserts an element into an aggregate type at a specified index. Allows for building and modifying arrays and vectors.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>int_spv_const_composite</cite></p></td>
<td><p>Type</p></td>
<td><p><cite>[Vararg]</cite></p></td>
<td><p>Constructs a composite type from given elements. Key for creating arrays, structs, and vectors from individual components.</p></td>
</tr>
<tr class="row-even"><td><p><cite>int_spv_bitcast</cite></p></td>
<td><p>Type</p></td>
<td><p><cite>[Type]</cite></p></td>
<td><p>Performs a bit-wise cast between types. Critical for type conversions that do not change the bit representation.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>int_spv_ptrcast</cite></p></td>
<td><p>Type</p></td>
<td><p><cite>[Type, Metadata, Integer]</cite></p></td>
<td><p>Casts pointers between different types. Similar to <cite>int_spv_bitcast</cite> but specifically for pointers, taking into account SPIR-V’s strict type system.</p></td>
</tr>
<tr class="row-even"><td><p><cite>int_spv_switch</cite></p></td>
<td><p>None</p></td>
<td><p><cite>[Type, Vararg]</cite></p></td>
<td><p>Implements a multi-way branch based on a value. Enables complex control flow structures, similar to the switch statement in high-level languages.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>int_spv_cmpxchg</cite></p></td>
<td><p>32-bit Integer</p></td>
<td><p><cite>[Type, Vararg]</cite></p></td>
<td><p>Performs an atomic compare-and-exchange operation. Crucial for synchronization and concurrency control in compute shaders.</p></td>
</tr>
<tr class="row-even"><td><p><cite>int_spv_unreachable</cite></p></td>
<td><p>None</p></td>
<td><p><cite>[]</cite></p></td>
<td><p>Marks a point in the code that should never be reached, enabling optimizations by indicating unreachable code paths.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>int_spv_alloca</cite></p></td>
<td><p>Type</p></td>
<td><p><cite>[]</cite></p></td>
<td><p>Allocates memory on the stack. Fundamental for local variable storage in functions.</p></td>
</tr>
<tr class="row-even"><td><p><cite>int_spv_alloca_array</cite></p></td>
<td><p>Type</p></td>
<td><p><cite>[Any Integer]</cite></p></td>
<td><p>Allocates an array on the stack. Extends <cite>int_spv_alloca</cite> to support array allocations, essential for temporary arrays.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>int_spv_undef</cite></p></td>
<td><p>32-bit Integer</p></td>
<td><p><cite>[]</cite></p></td>
<td><p>Generates an undefined value. Useful for optimizations and indicating uninitialized variables.</p></td>
</tr>
<tr class="row-even"><td><p><cite>int_spv_inline_asm</cite></p></td>
<td><p>None</p></td>
<td><p><cite>[Metadata, Metadata, Vararg]</cite></p></td>
<td><p>Associates inline assembly features to inline assembly call instances by creating metadatas and preserving original arguments. Not emitted directly but used to support SPIR-V representation in LLVM IR.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>int_spv_assume</cite></p></td>
<td><p>None</p></td>
<td><p><cite>[1-bit Integer]</cite></p></td>
<td><p>Provides hints to the optimizer about assumptions that can be made about program state. Improves optimization potential.</p></td>
</tr>
<tr class="row-even"><td><p><cite>int_spv_expect</cite></p></td>
<td><p>Any Integer Type</p></td>
<td><p><cite>[Type, Type]</cite></p></td>
<td><p>Guides branch prediction by indicating expected branch paths. Enhances performance by optimizing common code paths.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>int_spv_thread_id</cite></p></td>
<td><p>32-bit Integer</p></td>
<td><p><cite>[32-bit Integer]</cite></p></td>
<td><p>Retrieves the thread ID within a workgroup. Essential for identifying execution context in parallel compute operations.</p></td>
</tr>
<tr class="row-even"><td><p><cite>int_spv_flattened_thread_id_in_group</cite></p></td>
<td><p>32-bit Integer</p></td>
<td><p><cite>[32-bit Integer]</cite></p></td>
<td><p>Provides a flattened index for a given thread within a given group (SV_GroupIndex)</p></td>
</tr>
<tr class="row-odd"><td><p><cite>int_spv_create_handle</cite></p></td>
<td><p>Pointer</p></td>
<td><p><cite>[8-bit Integer]</cite></p></td>
<td><p>Creates a resource handle for graphics or compute resources. Facilitates the management and use of resources in shaders.</p></td>
</tr>
<tr class="row-even"><td><p><cite>int_spv_resource_handlefrombinding</cite></p></td>
<td><p>spirv.Image</p></td>
<td><p><cite>[32-bit Integer set, 32-bit Integer binding, 32-bit Integer arraySize, 32-bit Integer index, bool isUniformIndex]</cite></p></td>
<td><p>Returns the handle for the resource at the given set and binding.If <cite>arraySize &gt; 1</cite>, then the binding represents an array of resourcesof the given size, and the handle for the resource at the given index is returned.If the index is possibly non-uniform, then <cite>isUniformIndex</cite> must get set to true.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>int_spv_typeBufferLoad</cite></p></td>
<td><p>Scalar or vector</p></td>
<td><p><cite>[spirv.Image ImageBuffer, 32-bit Integer coordinate]</cite></p></td>
<td><p>Loads a value from a Vulkan image buffer at the given coordinate. The image buffer data is assumed to be stored as a 4-element vector. If the return type is a scalar, then the first element of the vector is returned. If the return type is an n-element vector, then the first n-elements of the 4-element vector are returned.</p></td>
</tr>
<tr class="row-even"><td><p><cite>int_spv_resource_store_typedbuffer</cite></p></td>
<td><p>void</p></td>
<td><p><cite>[spirv.Image Image, 32-bit Integer coordinate, vec4 data]</cite></p></td>
<td><p>Stores the data to the image buffer at the given coordinate. The data must be a 4-element vector.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="builtin-functions">
<span id="spirv-builtin-functions"></span><h3><a class="toc-backref" href="#id22" role="doc-backlink">Builtin Functions</a><a class="headerlink" href="#builtin-functions" title="Link to this heading">¶</a></h3>
<p>The following section highlights the representation of SPIR-V builtins in LLVM IR,
emphasizing builtins that do not have direct counterparts in LLVM.</p>
<section id="instructions-as-function-calls">
<h4><a class="toc-backref" href="#id23" role="doc-backlink">Instructions as Function Calls</a><a class="headerlink" href="#instructions-as-function-calls" title="Link to this heading">¶</a></h4>
<p>SPIR-V builtins without direct LLVM counterparts are represented as LLVM function calls.
These functions, termed SPIR-V builtin functions, follow an IA64 mangling scheme with
SPIR-V-specific extensions. Parsing non-mangled calls to builtins is supported in some cases,
but not tested extensively. The general format is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">__spirv_</span><span class="p">{</span><span class="n">OpCodeName</span><span class="p">}{</span><span class="n">_OptionalPostfixes</span><span class="p">}</span>
</pre></div>
</div>
<p>Where <cite>{OpCodeName}</cite> is the SPIR-V opcode name sans the “Op” prefix, and
<cite>{OptionalPostfixes}</cite> are decoration-specific postfixes, if any. The mangling and
postfixes allow for the representation of SPIR-V’s rich instruction set within LLVM’s
framework.</p>
</section>
<section id="extended-instruction-sets">
<h4><a class="toc-backref" href="#id24" role="doc-backlink">Extended Instruction Sets</a><a class="headerlink" href="#extended-instruction-sets" title="Link to this heading">¶</a></h4>
<p>SPIR-V defines several extended instruction sets for additional functionalities, such as
OpenCL-specific operations. In LLVM IR, these are represented by function calls to
mangled builtins and selected based on the environment. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">acos_f32</span>
</pre></div>
</div>
<p>represents the <cite>acos</cite> function from the OpenCL extended instruction set for a float32
input.</p>
</section>
<section id="builtin-variables">
<h4><a class="toc-backref" href="#id25" role="doc-backlink">Builtin Variables</a><a class="headerlink" href="#builtin-variables" title="Link to this heading">¶</a></h4>
<p>SPIR-V builtin variables, which provide access to special hardware or execution model
properties, are mapped to either LLVM function calls or LLVM global variables. The
representation follows the naming convention:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">__spirv_BuiltIn</span><span class="p">{</span><span class="n">VariableName</span><span class="p">}</span>
</pre></div>
</div>
<p>For instance, the SPIR-V builtin <cite>GlobalInvocationId</cite> is accessible in LLVM IR as
<cite>__spirv_BuiltInGlobalInvocationId</cite>.</p>
</section>
<section id="vector-load-and-store-builtins">
<h4><a class="toc-backref" href="#id26" role="doc-backlink">Vector Load and Store Builtins</a><a class="headerlink" href="#vector-load-and-store-builtins" title="Link to this heading">¶</a></h4>
<p>SPIR-V’s capabilities for loading and storing vectors are represented in LLVM IR using
functions that mimic the SPIR-V instructions. These builtins handle cases that LLVM’s
native instructions do not directly support, enabling fine-grained control over memory
operations.</p>
</section>
<section id="atomic-operations">
<h4><a class="toc-backref" href="#id27" role="doc-backlink">Atomic Operations</a><a class="headerlink" href="#atomic-operations" title="Link to this heading">¶</a></h4>
<p>SPIR-V’s atomic operations, especially those operating on floating-point data, are
represented in LLVM IR with corresponding function calls. These builtins ensure
atomicity in operations where LLVM might not have direct support, essential for parallel
execution and synchronization.</p>
</section>
<section id="image-operations">
<h4><a class="toc-backref" href="#id28" role="doc-backlink">Image Operations</a><a class="headerlink" href="#image-operations" title="Link to this heading">¶</a></h4>
<p>SPIR-V provides extensive support for image and sampler operations, which LLVM
represents through function calls to builtins. These include image reads, writes, and
queries, allowing detailed manipulation of image data and parameters.</p>
</section>
<section id="group-and-subgroup-operations">
<h4><a class="toc-backref" href="#id29" role="doc-backlink">Group and Subgroup Operations</a><a class="headerlink" href="#group-and-subgroup-operations" title="Link to this heading">¶</a></h4>
<p>For workgroup and subgroup operations, LLVM uses function calls to represent SPIR-V’s
group-based instructions. These builtins facilitate group synchronization, data sharing,
and collective operations essential for efficient parallel computation.</p>
</section>
<section id="spir-v-instructions-mapped-to-llvm-metadata">
<h4><a class="toc-backref" href="#id30" role="doc-backlink">SPIR-V Instructions Mapped to LLVM Metadata</a><a class="headerlink" href="#spir-v-instructions-mapped-to-llvm-metadata" title="Link to this heading">¶</a></h4>
<p>Some SPIR-V instructions don’t have a direct equivalent in the LLVM IR language. To
address this, the SPIR-V Target uses different specific LLVM named metadata to convey
the necessary information. The SPIR-V specification allows multiple module-scope
instructions, where as LLVM named metadata must be unique. Therefore, the encoding of
such instructions has the following format:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv">!spirv.</span><span class="p">&lt;</span><span class="err">OpCodeName</span><span class="p">&gt;</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{!&lt;</span><span class="err">InstructionMetadata</span><span class="m">1</span><span class="p">&gt;,</span><span class="w"> </span><span class="p">!&lt;</span><span class="err">InstructionMetadata</span><span class="m">2</span><span class="p">&gt;,</span><span class="w"> </span><span class="p">..}</span>
<span class="p">!&lt;</span><span class="err">InstructionMetadata</span><span class="m">1</span><span class="p">&gt;</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{&lt;</span><span class="err">Operand</span><span class="m">1</span><span class="p">&gt;,</span><span class="w"> </span><span class="p">&lt;</span><span class="err">Operand</span><span class="m">2</span><span class="p">&gt;,</span><span class="w"> </span><span class="p">..}</span>
<span class="p">!&lt;</span><span class="err">InstructionMetadata</span><span class="m">2</span><span class="p">&gt;</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{&lt;</span><span class="err">Operand</span><span class="m">1</span><span class="p">&gt;,</span><span class="w"> </span><span class="p">&lt;</span><span class="err">Operand</span><span class="m">2</span><span class="p">&gt;,</span><span class="w"> </span><span class="p">..}</span>
</pre></div>
</div>
<p>Below, you will find the mappings between SPIR-V instruction and their corresponding
LLVM IR representations.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>SPIR-V instruction</p></th>
<th class="head"><p>LLVM IR</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>OpExecutionMode</p></td>
<td><div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv">!spirv.ExecutionMode</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="nv nv-Anonymous">!0</span><span class="p">}</span>
<span class="nv nv-Anonymous">!0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="k">void</span><span class="w"> </span><span class="vg">@worker</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">30</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">262149</span><span class="p">}</span>
<span class="c">; Set execution mode with id 30 (VecTypeHint) and</span>
<span class="c">; literal `262149` operand.</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="SandboxIR.html" title="Sandbox IR: A transactional layer over LLVM IR"
             >next</a> |</li>
        <li class="right" >
          <a href="AssignmentTracking.html" title="Debug Info Assignment Tracking"
             >previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" >User Guides</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">User Guide for SPIR-V Target</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2003-2026, LLVM Project.
      Last updated on 2026-02-10.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>