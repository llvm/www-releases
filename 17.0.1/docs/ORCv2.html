
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>ORC Design and Implementation &#8212; LLVM 17.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b849a4e9" />
    <link rel="stylesheet" type="text/css" href="_static/llvm-theme.css?v=be84393e" />
    <script src="_static/documentation_options.js?v=08e2baec"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Opaque Pointers" href="OpaquePointers.html" />
    <link rel="prev" title="Misexpect" href="MisExpect.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="OpaquePointers.html" title="Opaque Pointers"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="MisExpect.html" title="Misexpect"
             accesskey="P">previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" accesskey="U">User Guides</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ORC Design and Implementation</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="https://llvm.org/docs/UserGuides.html">User Guides</a></li>
    <li><a href="https://llvm.org/docs/Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/Contributing.html">Contributing to LLVM</a></li>
    <li><a href="https://llvm.org/docs/HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#irc">IRC</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/FAQ.html">FAQ</a></li>
    <li><a href="https://llvm.org/docs/Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project/">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/ORCv2.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="orc-design-and-implementation">
<h1>ORC Design and Implementation<a class="headerlink" href="#orc-design-and-implementation" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id8">Introduction</a></p></li>
<li><p><a class="reference internal" href="#use-cases" id="id9">Use-cases</a></p></li>
<li><p><a class="reference internal" href="#features" id="id10">Features</a></p></li>
<li><p><a class="reference internal" href="#lljit-and-lllazyjit" id="id11">LLJIT and LLLazyJIT</a></p></li>
<li><p><a class="reference internal" href="#design-overview" id="id12">Design Overview</a></p></li>
<li><p><a class="reference internal" href="#top-level-apis" id="id13">Top Level APIs</a></p></li>
<li><p><a class="reference internal" href="#absolute-symbols-aliases-and-reexports" id="id14">Absolute Symbols, Aliases, and Reexports</a></p>
<ul>
<li><p><a class="reference internal" href="#absolute-symbols" id="id15">Absolute Symbols</a></p></li>
<li><p><a class="reference internal" href="#aliases-and-reexports" id="id16">Aliases and Reexports</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#laziness" id="id17">Laziness</a></p></li>
<li><p><a class="reference internal" href="#supporting-custom-compilers" id="id18">Supporting Custom Compilers</a></p></li>
<li><p><a class="reference internal" href="#transitioning-from-orcv1-to-orcv2" id="id19">Transitioning from ORCv1 to ORCv2</a></p></li>
<li><p><a class="reference internal" href="#how-tos" id="id20">How-tos</a></p>
<ul>
<li><p><a class="reference internal" href="#how-to-manage-symbol-strings" id="id21">How to manage symbol strings</a></p></li>
<li><p><a class="reference internal" href="#how-to-create-jitdylibs-and-set-up-linkage-relationships" id="id22">How to create JITDylibs and set up linkage relationships</a></p></li>
<li><p><a class="reference internal" href="#how-to-remove-code" id="id23">How to remove code</a></p></li>
<li><p><a class="reference internal" href="#how-to-add-the-support-for-custom-program-representation" id="id24">How to add the support for custom program representation</a></p></li>
<li><p><a class="reference internal" href="#how-to-use-threadsafemodule-and-threadsafecontext" id="id25">How to use ThreadSafeModule and ThreadSafeContext</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#how-to-add-process-and-library-symbols-to-jitdylibs" id="id26">How to Add Process and Library Symbols to JITDylibs</a></p></li>
<li><p><a class="reference internal" href="#roadmap" id="id27">Roadmap</a></p>
<ul>
<li><p><a class="reference internal" href="#current-work" id="id28">Current Work</a></p></li>
<li><p><a class="reference internal" href="#near-future-work" id="id29">Near Future Work</a></p></li>
<li><p><a class="reference internal" href="#further-future-work" id="id30">Further Future Work</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>This document aims to provide a high-level overview of the design and
implementation of the ORC JIT APIs. Except where otherwise stated all discussion
refers to the modern ORCv2 APIs (available since LLVM 7). Clients wishing to
transition from OrcV1 should see Section <a class="reference internal" href="#transitioning-orcv1-to-orcv2"><span class="std std-ref">Transitioning from ORCv1 to ORCv2</span></a>.</p>
</section>
<section id="use-cases">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">Use-cases</a><a class="headerlink" href="#use-cases" title="Link to this heading">¶</a></h2>
<p>ORC provides a modular API for building JIT compilers. There are a number
of use cases for such an API. For example:</p>
<p>1. The LLVM tutorials use a simple ORC-based JIT class to execute expressions
compiled from a toy language: Kaleidoscope.</p>
<p>2. The LLVM debugger, LLDB, uses a cross-compiling JIT for expression
evaluation. In this use case, cross compilation allows expressions compiled
in the debugger process to be executed on the debug target process, which may
be on a different device/architecture.</p>
<p>3. In high-performance JITs (e.g. JVMs, Julia) that want to make use of LLVM’s
optimizations within an existing JIT infrastructure.</p>
<ol class="arabic simple" start="4">
<li><p>In interpreters and REPLs, e.g. Cling (C++) and the Swift interpreter.</p></li>
</ol>
<p>By adopting a modular, library-based design we aim to make ORC useful in as many
of these contexts as possible.</p>
</section>
<section id="features">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">Features</a><a class="headerlink" href="#features" title="Link to this heading">¶</a></h2>
<p>ORC provides the following features:</p>
<dl class="simple">
<dt><strong>JIT-linking</strong></dt><dd><p>ORC provides APIs to link relocatable object files (COFF, ELF, MachO) <a class="footnote-reference brackets" href="#id5" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>
into a target process at runtime. The target process may be the same process
that contains the JIT session object and jit-linker, or may be another process
(even one running on a different machine or architecture) that communicates
with the JIT via RPC.</p>
</dd>
<dt><strong>LLVM IR compilation</strong></dt><dd><p>ORC provides off the shelf components (IRCompileLayer, SimpleCompiler,
ConcurrentIRCompiler) that make it easy to add LLVM IR to a JIT’d process.</p>
</dd>
<dt><strong>Eager and lazy compilation</strong></dt><dd><p>By default, ORC will compile symbols as soon as they are looked up in the JIT
session object (<code class="docutils literal notranslate"><span class="pre">ExecutionSession</span></code>). Compiling eagerly by default makes it
easy to use ORC as an in-memory compiler for an existing JIT (similar to how
MCJIT is commonly used). However ORC also provides built-in support for lazy
compilation via lazy-reexports (see <a class="reference internal" href="#laziness"><span class="std std-ref">Laziness</span></a>).</p>
</dd>
<dt><strong>Support for Custom Compilers and Program Representations</strong></dt><dd><p>Clients can supply custom compilers for each symbol that they define in their
JIT session. ORC will run the user-supplied compiler when the a definition of
a symbol is needed. ORC is actually fully language agnostic: LLVM IR is not
treated specially, and is supported via the same wrapper mechanism (the
<code class="docutils literal notranslate"><span class="pre">MaterializationUnit</span></code> class) that is used for custom compilers.</p>
</dd>
<dt><strong>Concurrent JIT’d code</strong> and <strong>Concurrent Compilation</strong></dt><dd><p>JIT’d code may be executed in multiple threads, may spawn new threads, and may
re-enter the ORC (e.g. to request lazy compilation) concurrently from multiple
threads. Compilers launched my ORC can run concurrently (provided the client
sets up an appropriate dispatcher). Built-in dependency tracking ensures that
ORC does not release pointers to JIT’d code or data until all dependencies
have also been JIT’d and they are safe to call or use.</p>
</dd>
<dt><strong>Removable Code</strong></dt><dd><p>Resources for JIT’d program representations</p>
</dd>
<dt><strong>Orthogonality</strong> and <strong>Composability</strong></dt><dd><p>Each of the features above can be used independently. It is possible to put
ORC components together to make a non-lazy, in-process, single threaded JIT
or a lazy, out-of-process, concurrent JIT, or anything in between.</p>
</dd>
</dl>
</section>
<section id="lljit-and-lllazyjit">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">LLJIT and LLLazyJIT</a><a class="headerlink" href="#lljit-and-lllazyjit" title="Link to this heading">¶</a></h2>
<p>ORC provides two basic JIT classes off-the-shelf. These are useful both as
examples of how to assemble ORC components to make a JIT, and as replacements
for earlier LLVM JIT APIs (e.g. MCJIT).</p>
<p>The LLJIT class uses an IRCompileLayer and RTDyldObjectLinkingLayer to support
compilation of LLVM IR and linking of relocatable object files. All operations
are performed eagerly on symbol lookup (i.e. a symbol’s definition is compiled
as soon as you attempt to look up its address). LLJIT is a suitable replacement
for MCJIT in most cases (note: some more advanced features, e.g.
JITEventListeners are not supported yet).</p>
<p>The LLLazyJIT extends LLJIT and adds a CompileOnDemandLayer to enable lazy
compilation of LLVM IR. When an LLVM IR module is added via the addLazyIRModule
method, function bodies in that module will not be compiled until they are first
called. LLLazyJIT aims to provide a replacement of LLVM’s original (pre-MCJIT)
JIT API.</p>
<p>LLJIT and LLLazyJIT instances can be created using their respective builder
classes: LLJITBuilder and LLazyJITBuilder. For example, assuming you have a
module <code class="docutils literal notranslate"><span class="pre">M</span></code> loaded on a ThreadSafeContext <code class="docutils literal notranslate"><span class="pre">Ctx</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Try to detect the host arch and construct an LLJIT instance.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">JIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LLJITBuilder</span><span class="p">().</span><span class="n">create</span><span class="p">();</span>

<span class="c1">// If we could not construct an instance, return an error.</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">JIT</span><span class="p">)</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">JIT</span><span class="p">.</span><span class="n">takeError</span><span class="p">();</span>

<span class="c1">// Add the module.</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">Err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JIT</span><span class="o">-&gt;</span><span class="n">addIRModule</span><span class="p">(</span><span class="n">TheadSafeModule</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">M</span><span class="p">),</span><span class="w"> </span><span class="n">Ctx</span><span class="p">)))</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Err</span><span class="p">;</span>

<span class="c1">// Look up the JIT&#39;d code entry point.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">EntrySym</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JIT</span><span class="o">-&gt;</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;entry&quot;</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">EntrySym</span><span class="p">)</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">EntrySym</span><span class="p">.</span><span class="n">takeError</span><span class="p">();</span>

<span class="c1">// Cast the entry point address to a function pointer.</span>
<span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">Entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EntrySym</span><span class="p">.</span><span class="n">getAddress</span><span class="p">().</span><span class="n">toPtr</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)()</span><span class="o">&gt;</span><span class="p">();</span>

<span class="c1">// Call into JIT&#39;d code.</span>
<span class="n">Entry</span><span class="p">();</span>
</pre></div>
</div>
<p>The builder classes provide a number of configuration options that can be
specified before the JIT instance is constructed. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Build an LLLazyJIT instance that uses four worker threads for compilation,</span>
<span class="c1">// and jumps to a specific error handler (rather than null) on lazy compile</span>
<span class="c1">// failures.</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">handleLazyCompileFailure</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// JIT&#39;d code will jump here if lazy compilation fails, giving us an</span>
<span class="w">  </span><span class="c1">// opportunity to exit or throw an exception into JIT&#39;d code.</span>
<span class="w">  </span><span class="k">throw</span><span class="w"> </span><span class="n">JITFailed</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">auto</span><span class="w"> </span><span class="n">JIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LLLazyJITBuilder</span><span class="p">()</span>
<span class="w">             </span><span class="p">.</span><span class="n">setNumCompileThreads</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="w">             </span><span class="p">.</span><span class="n">setLazyCompileFailureAddr</span><span class="p">(</span>
<span class="w">                 </span><span class="n">ExecutorAddr</span><span class="o">::</span><span class="n">fromPtr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handleLazyCompileFailure</span><span class="p">))</span>
<span class="w">             </span><span class="p">.</span><span class="n">create</span><span class="p">();</span>

<span class="c1">// ...</span>
</pre></div>
</div>
<p>For users wanting to get started with LLJIT a minimal example program can be
found at <code class="docutils literal notranslate"><span class="pre">llvm/examples/HowToUseLLJIT</span></code>.</p>
</section>
<section id="design-overview">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">Design Overview</a><a class="headerlink" href="#design-overview" title="Link to this heading">¶</a></h2>
<p>ORC’s JIT program model aims to emulate the linking and symbol resolution
rules used by the static and dynamic linkers. This allows ORC to JIT
arbitrary LLVM IR, including IR produced by an ordinary static compiler (e.g.
clang) that uses constructs like symbol linkage and visibility, and weak <a class="footnote-reference brackets" href="#id7" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>
and common symbol definitions.</p>
<p>To see how this works, imagine a program <code class="docutils literal notranslate"><span class="pre">foo</span></code> which links against a pair
of dynamic libraries: <code class="docutils literal notranslate"><span class="pre">libA</span></code> and <code class="docutils literal notranslate"><span class="pre">libB</span></code>. On the command line, building this
program might look like:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>clang++<span class="w"> </span>-shared<span class="w"> </span>-o<span class="w"> </span>libA.dylib<span class="w"> </span>a1.cpp<span class="w"> </span>a2.cpp
$<span class="w"> </span>clang++<span class="w"> </span>-shared<span class="w"> </span>-o<span class="w"> </span>libB.dylib<span class="w"> </span>b1.cpp<span class="w"> </span>b2.cpp
$<span class="w"> </span>clang++<span class="w"> </span>-o<span class="w"> </span>myapp<span class="w"> </span>myapp.cpp<span class="w"> </span>-L.<span class="w"> </span>-lA<span class="w"> </span>-lB
$<span class="w"> </span>./myapp
</pre></div>
</div>
<p>In ORC, this would translate into API calls on a hypothetical CXXCompilingLayer
(with error checking omitted for brevity) as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ExecutionSession</span><span class="w"> </span><span class="n">ES</span><span class="p">;</span>
<span class="n">RTDyldObjectLinkingLayer</span><span class="w"> </span><span class="nf">ObjLinkingLayer</span><span class="p">(</span>
<span class="w">    </span><span class="n">ES</span><span class="p">,</span><span class="w"> </span><span class="p">[]()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">SectionMemoryManager</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="p">});</span>
<span class="n">CXXCompileLayer</span><span class="w"> </span><span class="nf">CXXLayer</span><span class="p">(</span><span class="n">ES</span><span class="p">,</span><span class="w"> </span><span class="n">ObjLinkingLayer</span><span class="p">);</span>

<span class="c1">// Create JITDylib &quot;A&quot; and add code to it using the CXX layer.</span>
<span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">LibA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ES</span><span class="p">.</span><span class="n">createJITDylib</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">);</span>
<span class="n">CXXLayer</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">LibA</span><span class="p">,</span><span class="w"> </span><span class="n">MemoryBuffer</span><span class="o">::</span><span class="n">getFile</span><span class="p">(</span><span class="s">&quot;a1.cpp&quot;</span><span class="p">));</span>
<span class="n">CXXLayer</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">LibA</span><span class="p">,</span><span class="w"> </span><span class="n">MemoryBuffer</span><span class="o">::</span><span class="n">getFile</span><span class="p">(</span><span class="s">&quot;a2.cpp&quot;</span><span class="p">));</span>

<span class="c1">// Create JITDylib &quot;B&quot; and add code to it using the CXX layer.</span>
<span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">LibB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ES</span><span class="p">.</span><span class="n">createJITDylib</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">);</span>
<span class="n">CXXLayer</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">LibB</span><span class="p">,</span><span class="w"> </span><span class="n">MemoryBuffer</span><span class="o">::</span><span class="n">getFile</span><span class="p">(</span><span class="s">&quot;b1.cpp&quot;</span><span class="p">));</span>
<span class="n">CXXLayer</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">LibB</span><span class="p">,</span><span class="w"> </span><span class="n">MemoryBuffer</span><span class="o">::</span><span class="n">getFile</span><span class="p">(</span><span class="s">&quot;b2.cpp&quot;</span><span class="p">));</span>

<span class="c1">// Create and specify the search order for the main JITDylib. This is</span>
<span class="c1">// equivalent to a &quot;links against&quot; relationship in a command-line link.</span>
<span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MainJD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ES</span><span class="p">.</span><span class="n">createJITDylib</span><span class="p">(</span><span class="s">&quot;main&quot;</span><span class="p">);</span>
<span class="n">MainJD</span><span class="p">.</span><span class="n">addToLinkOrder</span><span class="p">(</span><span class="o">&amp;</span><span class="n">LibA</span><span class="p">);</span>
<span class="n">MainJD</span><span class="p">.</span><span class="n">addToLinkOrder</span><span class="p">(</span><span class="o">&amp;</span><span class="n">LibB</span><span class="p">);</span>
<span class="n">CXXLayer</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">MainJD</span><span class="p">,</span><span class="w"> </span><span class="n">MemoryBuffer</span><span class="o">::</span><span class="n">getFile</span><span class="p">(</span><span class="s">&quot;main.cpp&quot;</span><span class="p">));</span>

<span class="c1">// Look up the JIT&#39;d main, cast it to a function pointer, then call it.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">MainSym</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExitOnErr</span><span class="p">(</span><span class="n">ES</span><span class="p">.</span><span class="n">lookup</span><span class="p">({</span><span class="o">&amp;</span><span class="n">MainJD</span><span class="p">},</span><span class="w"> </span><span class="s">&quot;main&quot;</span><span class="p">));</span>
<span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">Main</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MainSym</span><span class="p">.</span><span class="n">getAddress</span><span class="p">().</span><span class="n">toPtr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">[])</span><span class="o">&gt;</span><span class="p">();</span>

<span class="kt">int</span><span class="w"> </span><span class="n">Result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Main</span><span class="p">(...);</span>
</pre></div>
</div>
<p>This example tells us nothing about <em>how</em> or <em>when</em> compilation will happen.
That will depend on the implementation of the hypothetical CXXCompilingLayer.
The same linker-based symbol resolution rules will apply regardless of that
implementation, however. For example, if a1.cpp and a2.cpp both define a
function “foo” then ORCv2 will generate a duplicate definition error. On the
other hand, if a1.cpp and b1.cpp both define “foo” there is no error (different
dynamic libraries may define the same symbol). If main.cpp refers to “foo”, it
should bind to the definition in LibA rather than the one in LibB, since
main.cpp is part of the “main” dylib, and the main dylib links against LibA
before LibB.</p>
<p>Many JIT clients will have no need for this strict adherence to the usual
ahead-of-time linking rules, and should be able to get by just fine by putting
all of their code in a single JITDylib. However, clients who want to JIT code
for languages/projects that traditionally rely on ahead-of-time linking (e.g.
C++) will find that this feature makes life much easier.</p>
<p>Symbol lookup in ORC serves two other important functions, beyond providing
addresses for symbols: (1) It triggers compilation of the symbol(s) searched for
(if they have not been compiled already), and (2) it provides the
synchronization mechanism for concurrent compilation. The pseudo-code for the
lookup process is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>construct a query object from a query set and query handler
lock the session
lodge query against requested symbols, collect required materializers (if any)
unlock the session
dispatch materializers (if any)
</pre></div>
</div>
<p>In this context a materializer is something that provides a working definition
of a symbol upon request. Usually materializers are just wrappers for compilers,
but they may also wrap a jit-linker directly (if the program representation
backing the definitions is an object file), or may even be a class that writes
bits directly into memory (for example, if the definitions are
stubs). Materialization is the blanket term for any actions (compiling, linking,
splatting bits, registering with runtimes, etc.) that are required to generate a
symbol definition that is safe to call or access.</p>
<p>As each materializer completes its work it notifies the JITDylib, which in turn
notifies any query objects that are waiting on the newly materialized
definitions. Each query object maintains a count of the number of symbols that
it is still waiting on, and once this count reaches zero the query object calls
the query handler with a <em>SymbolMap</em> (a map of symbol names to addresses)
describing the result. If any symbol fails to materialize the query immediately
calls the query handler with an error.</p>
<p>The collected materialization units are sent to the ExecutionSession to be
dispatched, and the dispatch behavior can be set by the client. By default each
materializer is run on the calling thread. Clients are free to create new
threads to run materializers, or to send the work to a work queue for a thread
pool (this is what LLJIT/LLLazyJIT do).</p>
</section>
<section id="top-level-apis">
<h2><a class="toc-backref" href="#id13" role="doc-backlink">Top Level APIs</a><a class="headerlink" href="#top-level-apis" title="Link to this heading">¶</a></h2>
<p>Many of ORC’s top-level APIs are visible in the example above:</p>
<ul class="simple">
<li><p><em>ExecutionSession</em> represents the JIT’d program and provides context for the
JIT: It contains the JITDylibs, error reporting mechanisms, and dispatches the
materializers.</p></li>
<li><p><em>JITDylibs</em> provide the symbol tables.</p></li>
<li><p><em>Layers</em> (ObjLinkingLayer and CXXLayer) are wrappers around compilers and
allow clients to add uncompiled program representations supported by those
compilers to JITDylibs.</p></li>
<li><p><em>ResourceTrackers</em> allow you to remove code.</p></li>
</ul>
<p>Several other important APIs are used explicitly. JIT clients need not be aware
of them, but Layer authors will use them:</p>
<ul class="simple">
<li><p><em>MaterializationUnit</em> - When XXXLayer::add is invoked it wraps the given
program representation (in this example, C++ source) in a MaterializationUnit,
which is then stored in the JITDylib. MaterializationUnits are responsible for
describing the definitions they provide, and for unwrapping the program
representation and passing it back to the layer when compilation is required
(this ownership shuffle makes writing thread-safe layers easier, since the
ownership of the program representation will be passed back on the stack,
rather than having to be fished out of a Layer member, which would require
synchronization).</p></li>
<li><p><em>MaterializationResponsibility</em> - When a MaterializationUnit hands a program
representation back to the layer it comes with an associated
MaterializationResponsibility object. This object tracks the definitions
that must be materialized and provides a way to notify the JITDylib once they
are either successfully materialized or a failure occurs.</p></li>
</ul>
</section>
<section id="absolute-symbols-aliases-and-reexports">
<h2><a class="toc-backref" href="#id14" role="doc-backlink">Absolute Symbols, Aliases, and Reexports</a><a class="headerlink" href="#absolute-symbols-aliases-and-reexports" title="Link to this heading">¶</a></h2>
<p>ORC makes it easy to define symbols with absolute addresses, or symbols that
are simply aliases of other symbols:</p>
<section id="absolute-symbols">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">Absolute Symbols</a><a class="headerlink" href="#absolute-symbols" title="Link to this heading">¶</a></h3>
<p>Absolute symbols are symbols that map directly to addresses without requiring
further materialization, for example: “foo” = 0x1234. One use case for
absolute symbols is allowing resolution of process symbols. E.g.</p>
<p>With this mapping established code added to the JIT can refer to printf
symbolically rather than requiring the address of printf to be “baked in”.
This in turn allows cached versions of the JIT’d code (e.g. compiled objects)
to be re-used across JIT sessions as the JIT’d code no longer changes, only the
absolute symbol definition does.</p>
<p>For process and library symbols the DynamicLibrarySearchGenerator utility (See
<a class="reference internal" href="#processandlibrarysymbols"><span class="std std-ref">How to Add Process and Library Symbols to JITDylibs</span></a>) can be used to automatically build absolute
symbol mappings for you. However the absoluteSymbols function is still useful
for making non-global objects in your JIT visible to JIT’d code. For example,
imagine that your JIT standard library needs access to your JIT object to make
some calls. We could bake the address of your object into the library, but then
it would need to be recompiled for each session:</p>
<p>We can turn this into a symbolic reference in the JIT standard library:</p>
<p>And then make our JIT object visible to the JIT standard library with an
absolute symbol definition when the JIT is started:</p>
</section>
<section id="aliases-and-reexports">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">Aliases and Reexports</a><a class="headerlink" href="#aliases-and-reexports" title="Link to this heading">¶</a></h3>
<p>Aliases and reexports allow you to define new symbols that map to existing
symbols. This can be useful for changing linkage relationships between symbols
across sessions without having to recompile code. For example, imagine that
JIT’d code has access to a log function, <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">log(const</span> <span class="pre">char*)</span></code> for which
there are two implementations in the JIT standard library: <code class="docutils literal notranslate"><span class="pre">log_fast</span></code> and
<code class="docutils literal notranslate"><span class="pre">log_detailed</span></code>. Your JIT can choose which one of these definitions will be
used when the <code class="docutils literal notranslate"><span class="pre">log</span></code> symbol is referenced by setting up an alias at JIT startup
time:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">symbolAliases</span></code> function allows you to define aliases within a single
JITDylib. The <code class="docutils literal notranslate"><span class="pre">reexports</span></code> function provides the same functionality, but
operates across JITDylib boundaries. E.g.</p>
<p>The reexports utility can be handy for composing a single JITDylib interface by
re-exporting symbols from several other JITDylibs.</p>
</section>
</section>
<section id="laziness">
<span id="id3"></span><h2><a class="toc-backref" href="#id17" role="doc-backlink">Laziness</a><a class="headerlink" href="#laziness" title="Link to this heading">¶</a></h2>
<p>Laziness in ORC is provided by a utility called “lazy reexports”. A lazy
reexport is similar to a regular reexport or alias: It provides a new name for
an existing symbol. Unlike regular reexports however, lookups of lazy reexports
do not trigger immediate materialization of the reexported symbol. Instead, they
only trigger materialization of a function stub. This function stub is
initialized to point at a <em>lazy call-through</em>, which provides reentry into the
JIT. If the stub is called at runtime then the lazy call-through will look up
the reexported symbol (triggering materialization for it if necessary), update
the stub (to call directly to the reexported symbol on subsequent calls), and
then return via the reexported symbol. By re-using the existing symbol lookup
mechanism, lazy reexports inherit the same concurrency guarantees: calls to lazy
reexports can be made from multiple threads concurrently, and the reexported
symbol can be any state of compilation (uncompiled, already in the process of
being compiled, or already compiled) and the call will succeed. This allows
laziness to be safely mixed with features like remote compilation, concurrent
compilation, concurrent JIT’d code, and speculative compilation.</p>
<p>There is one other key difference between regular reexports and lazy reexports
that some clients must be aware of: The address of a lazy reexport will be
<em>different</em> from the address of the reexported symbol (whereas a regular
reexport is guaranteed to have the same address as the reexported symbol).
Clients who care about pointer equality will generally want to use the address
of the reexport as the canonical address of the reexported symbol. This will
allow the address to be taken without forcing materialization of the reexport.</p>
<p>Usage example:</p>
<p>If JITDylib <code class="docutils literal notranslate"><span class="pre">JD</span></code> contains definitions for symbols <code class="docutils literal notranslate"><span class="pre">foo_body</span></code> and
<code class="docutils literal notranslate"><span class="pre">bar_body</span></code>, we can create lazy entry points <code class="docutils literal notranslate"><span class="pre">Foo</span></code> and <code class="docutils literal notranslate"><span class="pre">Bar</span></code> in JITDylib
<code class="docutils literal notranslate"><span class="pre">JD2</span></code> by calling:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">ReexportFlags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JITSymbolFlags</span><span class="o">::</span><span class="n">Exported</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">JITSymbolFlags</span><span class="o">::</span><span class="n">Callable</span><span class="p">;</span>
<span class="n">JD2</span><span class="p">.</span><span class="n">define</span><span class="p">(</span>
<span class="w">  </span><span class="n">lazyReexports</span><span class="p">(</span><span class="n">CallThroughMgr</span><span class="p">,</span><span class="w"> </span><span class="n">StubsMgr</span><span class="p">,</span><span class="w"> </span><span class="n">JD</span><span class="p">,</span>
<span class="w">                </span><span class="n">SymbolAliasMap</span><span class="p">({</span>
<span class="w">                  </span><span class="p">{</span><span class="w"> </span><span class="n">Mangle</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Mangle</span><span class="p">(</span><span class="s">&quot;foo_body&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">ReexportedFlags</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">},</span>
<span class="w">                  </span><span class="p">{</span><span class="w"> </span><span class="n">Mangle</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">),</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Mangle</span><span class="p">(</span><span class="s">&quot;bar_body&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">ReexportedFlags</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span>
<span class="w">                </span><span class="p">}));</span>
</pre></div>
</div>
<p>A full example of how to use lazyReexports with the LLJIT class can be found at
<code class="docutils literal notranslate"><span class="pre">llvm/examples/OrcV2Examples/LLJITWithLazyReexports</span></code>.</p>
</section>
<section id="supporting-custom-compilers">
<h2><a class="toc-backref" href="#id18" role="doc-backlink">Supporting Custom Compilers</a><a class="headerlink" href="#supporting-custom-compilers" title="Link to this heading">¶</a></h2>
<p>TBD.</p>
</section>
<section id="transitioning-from-orcv1-to-orcv2">
<span id="transitioning-orcv1-to-orcv2"></span><h2><a class="toc-backref" href="#id19" role="doc-backlink">Transitioning from ORCv1 to ORCv2</a><a class="headerlink" href="#transitioning-from-orcv1-to-orcv2" title="Link to this heading">¶</a></h2>
<p>Since LLVM 7.0, new ORC development work has focused on adding support for
concurrent JIT compilation. The new APIs (including new layer interfaces and
implementations, and new utilities) that support concurrency are collectively
referred to as ORCv2, and the original, non-concurrent layers and utilities
are now referred to as ORCv1.</p>
<p>The majority of the ORCv1 layers and utilities were renamed with a ‘Legacy’
prefix in LLVM 8.0, and have deprecation warnings attached in LLVM 9.0. In LLVM
12.0 ORCv1 will be removed entirely.</p>
<p>Transitioning from ORCv1 to ORCv2 should be easy for most clients. Most of the
ORCv1 layers and utilities have ORCv2 counterparts <a class="footnote-reference brackets" href="#id6" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> that can be directly
substituted. However there are some design differences between ORCv1 and ORCv2
to be aware of:</p>
<blockquote>
<div><ol class="arabic">
<li><p>ORCv2 fully adopts the JIT-as-linker model that began with MCJIT. Modules
(and other program representations, e.g. Object Files)  are no longer added
directly to JIT classes or layers. Instead, they are added to <code class="docutils literal notranslate"><span class="pre">JITDylib</span></code>
instances <em>by</em> layers. The <code class="docutils literal notranslate"><span class="pre">JITDylib</span></code> determines <em>where</em> the definitions
reside, the layers determine <em>how</em> the definitions will be compiled.
Linkage relationships between <code class="docutils literal notranslate"><span class="pre">JITDylibs</span></code> determine how inter-module
references are resolved, and symbol resolvers are no longer used. See the
section <a class="reference internal" href="#design-overview">Design Overview</a> for more details.</p>
<p>Unless multiple JITDylibs are needed to model linkage relationships, ORCv1
clients should place all code in a single JITDylib.
MCJIT clients should use LLJIT (see <a class="reference internal" href="#lljit-and-lllazyjit">LLJIT and LLLazyJIT</a>), and can place
code in LLJIT’s default created main JITDylib (See
<code class="docutils literal notranslate"><span class="pre">LLJIT::getMainJITDylib()</span></code>).</p>
</li>
<li><p>All JIT stacks now need an <code class="docutils literal notranslate"><span class="pre">ExecutionSession</span></code> instance. ExecutionSession
manages the string pool, error reporting, synchronization, and symbol
lookup.</p></li>
<li><p>ORCv2 uses uniqued strings (<code class="docutils literal notranslate"><span class="pre">SymbolStringPtr</span></code> instances) rather than
string values in order to reduce memory overhead and improve lookup
performance. See the subsection <a class="reference internal" href="#how-to-manage-symbol-strings">How to manage symbol strings</a>.</p></li>
<li><p>IR layers require ThreadSafeModule instances, rather than
std::unique_ptr&lt;Module&gt;s. ThreadSafeModule is a wrapper that ensures that
Modules that use the same LLVMContext are not accessed concurrently.
See <a class="reference internal" href="#how-to-use-threadsafemodule-and-threadsafecontext">How to use ThreadSafeModule and ThreadSafeContext</a>.</p></li>
<li><p>Symbol lookup is no longer handled by layers. Instead, there is a
<code class="docutils literal notranslate"><span class="pre">lookup</span></code> method on JITDylib that takes a list of JITDylibs to scan.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ExecutionSession</span><span class="w"> </span><span class="n">ES</span><span class="p">;</span>
<span class="n">JITDylib</span><span class="w"> </span><span class="o">&amp;</span><span class="n">JD1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="n">JITDylib</span><span class="w"> </span><span class="o">&amp;</span><span class="n">JD2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>

<span class="k">auto</span><span class="w"> </span><span class="n">Sym</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ES</span><span class="p">.</span><span class="n">lookup</span><span class="p">({</span><span class="o">&amp;</span><span class="n">JD1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">JD2</span><span class="p">},</span><span class="w"> </span><span class="n">ES</span><span class="p">.</span><span class="n">intern</span><span class="p">(</span><span class="s">&quot;_main&quot;</span><span class="p">));</span>
</pre></div>
</div>
</li>
<li><p>The removeModule/removeObject methods are replaced by
<code class="docutils literal notranslate"><span class="pre">ResourceTracker::remove</span></code>.
See the subsection <a class="reference internal" href="#how-to-remove-code">How to remove code</a>.</p></li>
</ol>
</div></blockquote>
<p>For code examples and suggestions of how to use the ORCv2 APIs, please see
the section <a class="reference internal" href="#how-tos">How-tos</a>.</p>
</section>
<section id="how-tos">
<h2><a class="toc-backref" href="#id20" role="doc-backlink">How-tos</a><a class="headerlink" href="#how-tos" title="Link to this heading">¶</a></h2>
<section id="how-to-manage-symbol-strings">
<h3><a class="toc-backref" href="#id21" role="doc-backlink">How to manage symbol strings</a><a class="headerlink" href="#how-to-manage-symbol-strings" title="Link to this heading">¶</a></h3>
<p>Symbol strings in ORC are uniqued to improve lookup performance, reduce memory
overhead, and allow symbol names to function as efficient keys. To get the
unique <code class="docutils literal notranslate"><span class="pre">SymbolStringPtr</span></code> for a string value, call the
<code class="docutils literal notranslate"><span class="pre">ExecutionSession::intern</span></code> method:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ExecutionSession</span><span class="w"> </span><span class="n">ES</span><span class="p">;</span>
<span class="c1">/// ...</span>
<span class="k">auto</span><span class="w"> </span><span class="n">MainSymbolName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ES</span><span class="p">.</span><span class="n">intern</span><span class="p">(</span><span class="s">&quot;main&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>If you wish to perform lookup using the C/IR name of a symbol you will also
need to apply the platform linker-mangling before interning the string. On
Linux this mangling is a no-op, but on other platforms it usually involves
adding a prefix to the string (e.g. ‘_’ on Darwin). The mangling scheme is
based on the DataLayout for the target. Given a DataLayout and an
ExecutionSession, you can create a MangleAndInterner function object that
will perform both jobs for you:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ExecutionSession</span><span class="w"> </span><span class="n">ES</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="n">DataLayout</span><span class="w"> </span><span class="o">&amp;</span><span class="n">DL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="n">MangleAndInterner</span><span class="w"> </span><span class="nf">Mangle</span><span class="p">(</span><span class="n">ES</span><span class="p">,</span><span class="w"> </span><span class="n">DL</span><span class="p">);</span>

<span class="c1">// ...</span>

<span class="c1">// Portable IR-symbol-name lookup:</span>
<span class="k">auto</span><span class="w"> </span><span class="n">Sym</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ES</span><span class="p">.</span><span class="n">lookup</span><span class="p">({</span><span class="o">&amp;</span><span class="n">MainJD</span><span class="p">},</span><span class="w"> </span><span class="n">Mangle</span><span class="p">(</span><span class="s">&quot;main&quot;</span><span class="p">));</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="how-to-create-jitdylibs-and-set-up-linkage-relationships">
<h3><a class="toc-backref" href="#id22" role="doc-backlink">How to create JITDylibs and set up linkage relationships</a><a class="headerlink" href="#how-to-create-jitdylibs-and-set-up-linkage-relationships" title="Link to this heading">¶</a></h3>
<p>In ORC, all symbol definitions reside in JITDylibs. JITDylibs are created by
calling the <code class="docutils literal notranslate"><span class="pre">ExecutionSession::createJITDylib</span></code> method with a unique name:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ExecutionSession</span><span class="w"> </span><span class="n">ES</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">JD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ES</span><span class="p">.</span><span class="n">createJITDylib</span><span class="p">(</span><span class="s">&quot;libFoo.dylib&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>The JITDylib is owned by the <code class="docutils literal notranslate"><span class="pre">ExecutionEngine</span></code> instance and will be freed
when it is destroyed.</p>
</section>
<section id="how-to-remove-code">
<h3><a class="toc-backref" href="#id23" role="doc-backlink">How to remove code</a><a class="headerlink" href="#how-to-remove-code" title="Link to this heading">¶</a></h3>
<p>To remove an individual module from a JITDylib it must first be added using an
explicit <code class="docutils literal notranslate"><span class="pre">ResourceTracker</span></code>. The module can then be removed by calling
<code class="docutils literal notranslate"><span class="pre">ResourceTracker::remove</span></code>:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">JD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">;</span>

<span class="k">auto</span><span class="w"> </span><span class="n">RT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JD</span><span class="p">.</span><span class="n">createResourceTracker</span><span class="p">();</span>
<span class="n">Layer</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">RT</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">M</span><span class="p">));</span><span class="w"> </span><span class="c1">// Add M to JD, tracking resources with RT</span>

<span class="n">RT</span><span class="p">.</span><span class="n">remove</span><span class="p">();</span><span class="w"> </span><span class="c1">// Remove M from JD.</span>
</pre></div>
</div>
</div></blockquote>
<p>Modules added directly to a JITDylib will be tracked by that JITDylib’s default
resource tracker.</p>
<p>All code can be removed from a JITDylib by calling <code class="docutils literal notranslate"><span class="pre">JITDylib::clear</span></code>. This
leaves the cleared JITDylib in an empty but usable state.</p>
<p>JITDylibs can be removed by calling <code class="docutils literal notranslate"><span class="pre">ExecutionSession::removeJITDylib</span></code>. This
clears the JITDylib and then puts it into a defunct state. No further operations
can be performed on the JITDylib, and it will be destroyed as soon as the last
handle to it is released.</p>
<p>An example of how to use the resource management APIs can be found at
<code class="docutils literal notranslate"><span class="pre">llvm/examples/OrcV2Examples/LLJITRemovableCode</span></code>.</p>
</section>
<section id="how-to-add-the-support-for-custom-program-representation">
<h3><a class="toc-backref" href="#id24" role="doc-backlink">How to add the support for custom program representation</a><a class="headerlink" href="#how-to-add-the-support-for-custom-program-representation" title="Link to this heading">¶</a></h3>
<p>In order to add the support for a custom program representation, a custom <code class="docutils literal notranslate"><span class="pre">MaterializationUnit</span></code>
for the program representation, and a custom <code class="docutils literal notranslate"><span class="pre">Layer</span></code> are needed. The Layer will have two
operations: <code class="docutils literal notranslate"><span class="pre">add</span></code> and <code class="docutils literal notranslate"><span class="pre">emit</span></code>. The <code class="docutils literal notranslate"><span class="pre">add</span></code> operation takes an instance of your program
representation, builds one of your custom <code class="docutils literal notranslate"><span class="pre">MaterializationUnits</span></code> to hold it, then adds it
to a <code class="docutils literal notranslate"><span class="pre">JITDylib</span></code>. The emit operation takes a <code class="docutils literal notranslate"><span class="pre">MaterializationResponsibility</span></code> object and an
instance of your program representation and materializes it, usually by compiling it and handing
the resulting object off to an <code class="docutils literal notranslate"><span class="pre">ObjectLinkingLayer</span></code>.</p>
<p>Your custom <code class="docutils literal notranslate"><span class="pre">MaterializationUnit</span></code> will have two operations: <code class="docutils literal notranslate"><span class="pre">materialize</span></code> and <code class="docutils literal notranslate"><span class="pre">discard</span></code>. The
<code class="docutils literal notranslate"><span class="pre">materialize</span></code> function will be called for you when any symbol provided by the unit is looked up,
and it should just call the <code class="docutils literal notranslate"><span class="pre">emit</span></code> function on your layer, passing in the given
<code class="docutils literal notranslate"><span class="pre">MaterializationResponsibility</span></code> and the wrapped program representation. The <code class="docutils literal notranslate"><span class="pre">discard</span></code> function
will be called if some weak symbol provided by your unit is not needed (because the JIT found an
overriding definition). You can use this to drop your definition early, or just ignore it and let
the linker drops the definition later.</p>
<p>Here is an example of an ASTLayer:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// ... In you JIT class</span>
<span class="n">AstLayer</span><span class="w"> </span><span class="n">astLayer</span><span class="p">;</span>
<span class="c1">// ...</span>


<span class="k">class</span><span class="w"> </span><span class="nc">AstMaterializationUnit</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">orc</span><span class="o">::</span><span class="n">MaterializationUnit</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">AstMaterializationUnit</span><span class="p">(</span><span class="n">AstLayer</span><span class="w"> </span><span class="o">&amp;</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">Ast</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ast</span><span class="p">)</span>
<span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">orc</span><span class="o">::</span><span class="n">MaterializationUnit</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">getInterface</span><span class="p">(</span><span class="n">ast</span><span class="p">)),</span><span class="w"> </span><span class="n">astLayer</span><span class="p">(</span><span class="n">l</span><span class="p">),</span>
<span class="w">  </span><span class="n">ast</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span><span class="w"> </span><span class="p">{};</span>

<span class="w">  </span><span class="n">llvm</span><span class="o">::</span><span class="n">StringRef</span><span class="w"> </span><span class="nf">getName</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;AstMaterializationUnit&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">materialize</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">orc</span><span class="o">::</span><span class="n">MaterializationResponsibility</span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">astLayer</span><span class="p">.</span><span class="n">emit</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">r</span><span class="p">),</span><span class="w"> </span><span class="n">ast</span><span class="p">);</span>
<span class="w">  </span><span class="p">};</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">discard</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">orc</span><span class="o">::</span><span class="n">JITDylib</span><span class="w"> </span><span class="o">&amp;</span><span class="n">jd</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">orc</span><span class="o">::</span><span class="n">SymbolStringPtr</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sym</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;functions are not overridable&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>


<span class="w">  </span><span class="n">AstLayer</span><span class="w"> </span><span class="o">&amp;</span><span class="n">astLayer</span><span class="p">;</span>
<span class="w">  </span><span class="n">Ast</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ast</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">AstLayer</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">llvhm</span><span class="o">::</span><span class="n">orc</span><span class="o">::</span><span class="n">IRLayer</span><span class="w"> </span><span class="o">&amp;</span><span class="n">baseLayer</span><span class="p">;</span>
<span class="w">  </span><span class="n">llvhm</span><span class="o">::</span><span class="n">orc</span><span class="o">::</span><span class="n">MangleAndInterner</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mangler</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">AstLayer</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">orc</span><span class="o">::</span><span class="n">IRLayer</span><span class="w"> </span><span class="o">&amp;</span><span class="n">baseLayer</span><span class="p">,</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">orc</span><span class="o">::</span><span class="n">MangleAndInterner</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mangler</span><span class="p">)</span>
<span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="n">baseLayer</span><span class="p">(</span><span class="n">baseLayer</span><span class="p">),</span><span class="w"> </span><span class="n">mangler</span><span class="p">(</span><span class="n">mangler</span><span class="p">){};</span>

<span class="w">  </span><span class="n">llvm</span><span class="o">::</span><span class="n">Error</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">orc</span><span class="o">::</span><span class="n">ResourceTrackerSP</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rt</span><span class="p">,</span><span class="w"> </span><span class="n">Ast</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ast</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">getJITDylib</span><span class="p">().</span><span class="n">define</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">AstMaterializationUnit</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">ast</span><span class="p">),</span><span class="w"> </span><span class="n">rt</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">orc</span><span class="o">::</span><span class="n">MaterializationResponsibility</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mr</span><span class="p">,</span><span class="w"> </span><span class="n">Ast</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ast</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// compileAst is just function that compiles the given AST and returns</span>
<span class="w">    </span><span class="c1">// a `llvm::orc::ThreadSafeModule`</span>
<span class="w">    </span><span class="n">baseLayer</span><span class="p">.</span><span class="n">emit</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">mr</span><span class="p">),</span><span class="w"> </span><span class="n">compileAst</span><span class="p">(</span><span class="n">ast</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">llvm</span><span class="o">::</span><span class="n">orc</span><span class="o">::</span><span class="n">MaterializationUnit</span><span class="o">::</span><span class="n">Interface</span><span class="w"> </span><span class="nf">getInterface</span><span class="p">(</span><span class="n">Ast</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ast</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">SymbolFlagsMap</span><span class="w"> </span><span class="n">Symbols</span><span class="p">;</span>
<span class="w">      </span><span class="c1">// Find all the symbols in the AST and for each of them</span>
<span class="w">      </span><span class="c1">// add it to the Symbols map.</span>
<span class="w">      </span><span class="n">Symbols</span><span class="p">[</span><span class="n">mangler</span><span class="p">(</span><span class="n">someNameFromAST</span><span class="p">)]</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">JITSymbolFlags</span><span class="p">(</span><span class="n">JITSymbolFlags</span><span class="o">::</span><span class="n">Exported</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">JITSymbolFlags</span><span class="o">::</span><span class="n">Callable</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">MaterializationUnit</span><span class="o">::</span><span class="n">Interface</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Symbols</span><span class="p">),</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div></blockquote>
<p>Take look at the source code of <a class="reference external" href="tutorial/BuildingAJIT4.html">Building A JIT’s Chapter 4</a> for a complete example.</p>
</section>
<section id="how-to-use-threadsafemodule-and-threadsafecontext">
<h3><a class="toc-backref" href="#id25" role="doc-backlink">How to use ThreadSafeModule and ThreadSafeContext</a><a class="headerlink" href="#how-to-use-threadsafemodule-and-threadsafecontext" title="Link to this heading">¶</a></h3>
<p>ThreadSafeModule and ThreadSafeContext are wrappers around Modules and
LLVMContexts respectively. A ThreadSafeModule is a pair of a
std::unique_ptr&lt;Module&gt; and a (possibly shared) ThreadSafeContext value. A
ThreadSafeContext is a pair of a std::unique_ptr&lt;LLVMContext&gt; and a lock.
This design serves two purposes: providing a locking scheme and lifetime
management for LLVMContexts. The ThreadSafeContext may be locked to prevent
accidental concurrent access by two Modules that use the same LLVMContext.
The underlying LLVMContext is freed once all ThreadSafeContext values pointing
to it are destroyed, allowing the context memory to be reclaimed as soon as
the Modules referring to it are destroyed.</p>
<p>ThreadSafeContexts can be explicitly constructed from a
std::unique_ptr&lt;LLVMContext&gt;:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ThreadSafeContext</span><span class="w"> </span><span class="nf">TSCtx</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">LLVMContext</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
</div>
</div></blockquote>
<p>ThreadSafeModules can be constructed from a pair of a std::unique_ptr&lt;Module&gt;
and a ThreadSafeContext value. ThreadSafeContext values may be shared between
multiple ThreadSafeModules:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ThreadSafeModule</span><span class="w"> </span><span class="n">TSM1</span><span class="p">(</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Module</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;M1&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">TSCtx</span><span class="p">.</span><span class="n">getContext</span><span class="p">()),</span><span class="w"> </span><span class="n">TSCtx</span><span class="p">);</span>

<span class="n">ThreadSafeModule</span><span class="w"> </span><span class="n">TSM2</span><span class="p">(</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Module</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;M2&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">TSCtx</span><span class="p">.</span><span class="n">getContext</span><span class="p">()),</span><span class="w"> </span><span class="n">TSCtx</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>Before using a ThreadSafeContext, clients should ensure that either the context
is only accessible on the current thread, or that the context is locked. In the
example above (where the context is never locked) we rely on the fact that both
<code class="docutils literal notranslate"><span class="pre">TSM1</span></code> and <code class="docutils literal notranslate"><span class="pre">TSM2</span></code>, and TSCtx are all created on one thread. If a context is
going to be shared between threads then it must be locked before any accessing
or creating any Modules attached to it. E.g.</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ThreadSafeContext</span><span class="w"> </span><span class="nf">TSCtx</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">LLVMContext</span><span class="o">&gt;</span><span class="p">());</span>

<span class="n">ThreadPool</span><span class="w"> </span><span class="nf">TP</span><span class="p">(</span><span class="n">NumThreads</span><span class="p">);</span>
<span class="n">JITStack</span><span class="w"> </span><span class="n">J</span><span class="p">;</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ModulePath</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ModulePaths</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">TP</span><span class="p">.</span><span class="n">async</span><span class="p">(</span>
<span class="w">    </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">Lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TSCtx</span><span class="p">.</span><span class="n">getLock</span><span class="p">();</span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">loadModuleOnContext</span><span class="p">(</span><span class="n">ModulePath</span><span class="p">,</span><span class="w"> </span><span class="n">TSCtx</span><span class="p">.</span><span class="n">getContext</span><span class="p">());</span>
<span class="w">      </span><span class="n">J</span><span class="p">.</span><span class="n">addModule</span><span class="p">(</span><span class="n">ThreadSafeModule</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">M</span><span class="p">),</span><span class="w"> </span><span class="n">TSCtx</span><span class="p">));</span>
<span class="w">    </span><span class="p">});</span>
<span class="p">}</span>

<span class="n">TP</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</pre></div>
</div>
</div></blockquote>
<p>To make exclusive access to Modules easier to manage the ThreadSafeModule class
provides a convenience function, <code class="docutils literal notranslate"><span class="pre">withModuleDo</span></code>, that implicitly (1) locks the
associated context, (2) runs a given function object, (3) unlocks the context,
and (3) returns the result generated by the function object. E.g.</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ThreadSafeModule</span><span class="w"> </span><span class="n">TSM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getModule</span><span class="p">(...);</span>

<span class="c1">// Dump the module:</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">NumFunctionsInModule</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">TSM</span><span class="p">.</span><span class="n">withModuleDo</span><span class="p">(</span>
<span class="w">    </span><span class="p">[](</span><span class="n">Module</span><span class="w"> </span><span class="o">&amp;</span><span class="n">M</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// &lt;- Context locked before entering lambda.</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">M</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// &lt;- Context unlocked after leaving.</span>
<span class="w">  </span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>Clients wishing to maximize possibilities for concurrent compilation will want
to create every new ThreadSafeModule on a new ThreadSafeContext. For this
reason a convenience constructor for ThreadSafeModule is provided that implicitly
constructs a new ThreadSafeContext value from a std::unique_ptr&lt;LLVMContext&gt;:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Maximize concurrency opportunities by loading every module on a</span>
<span class="c1">// separate context.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">IRPath</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IRPaths</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">Ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">LLVMContext</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">LLVMContext</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;M&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">Ctx</span><span class="p">);</span>
<span class="w">  </span><span class="n">CompileLayer</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">MainJD</span><span class="p">,</span><span class="w"> </span><span class="n">ThreadSafeModule</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">M</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Ctx</span><span class="p">)));</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>Clients who plan to run single-threaded may choose to save memory by loading
all modules on the same context:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Save memory by using one context for all Modules:</span>
<span class="n">ThreadSafeContext</span><span class="w"> </span><span class="nf">TSCtx</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">LLVMContext</span><span class="o">&gt;</span><span class="p">());</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">IRPath</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IRPaths</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ThreadSafeModule</span><span class="w"> </span><span class="nf">TSM</span><span class="p">(</span><span class="n">parsePath</span><span class="p">(</span><span class="n">IRPath</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">TSCtx</span><span class="p">.</span><span class="n">getContext</span><span class="p">()),</span><span class="w"> </span><span class="n">TSCtx</span><span class="p">);</span>
<span class="w">  </span><span class="n">CompileLayer</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">MainJD</span><span class="p">,</span><span class="w"> </span><span class="n">ThreadSafeModule</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">TSM</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</section>
</section>
<section id="how-to-add-process-and-library-symbols-to-jitdylibs">
<span id="processandlibrarysymbols"></span><h2><a class="toc-backref" href="#id26" role="doc-backlink">How to Add Process and Library Symbols to JITDylibs</a><a class="headerlink" href="#how-to-add-process-and-library-symbols-to-jitdylibs" title="Link to this heading">¶</a></h2>
<p>JIT’d code may need to access symbols in the host program or in supporting
libraries. The best way to enable this is to reflect these symbols into your
JITDylibs so that they appear the same as any other symbol defined within the
execution session (i.e. they are findable via <cite>ExecutionSession::lookup</cite>, and
so visible to the JIT linker during linking).</p>
<p>One way to reflect external symbols is to add them manually using the
absoluteSymbols function:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">DataLayout</span><span class="w"> </span><span class="o">&amp;</span><span class="n">DL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getDataLayout</span><span class="p">();</span>
<span class="n">MangleAndInterner</span><span class="w"> </span><span class="nf">Mangle</span><span class="p">(</span><span class="n">ES</span><span class="p">,</span><span class="w"> </span><span class="n">DL</span><span class="p">);</span>

<span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">JD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ES</span><span class="p">.</span><span class="n">createJITDylib</span><span class="p">(</span><span class="s">&quot;main&quot;</span><span class="p">);</span>

<span class="n">JD</span><span class="p">.</span><span class="n">define</span><span class="p">(</span>
<span class="w">  </span><span class="n">absoluteSymbols</span><span class="p">({</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">Mangle</span><span class="p">(</span><span class="s">&quot;puts&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">ExecutorAddr</span><span class="o">::</span><span class="n">fromPtr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">puts</span><span class="p">)},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">Mangle</span><span class="p">(</span><span class="s">&quot;gets&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">ExecutorAddr</span><span class="o">::</span><span class="n">fromPtr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">getS</span><span class="p">)}</span>
<span class="w">  </span><span class="p">}));</span>
</pre></div>
</div>
</div></blockquote>
<p>Using absoluteSymbols is reasonable if the set of symbols to be reflected is
small and fixed. On the other hand, if the set of symbols is large or variable
it may make more sense to have the definitions added for you on demand by a
<em>definition generator</em>.A definition generator is an object that can be attached
to a JITDylib, receiving a callback whenever a lookup within that JITDylib fails
to find one or more symbols. The definition generator is given a chance to
produce a definition of the missing symbol(s) before the lookup proceeds.</p>
<p>ORC provides the <code class="docutils literal notranslate"><span class="pre">DynamicLibrarySearchGenerator</span></code> utility for reflecting symbols
from the process (or a specific dynamic library) for you. For example, to reflect
the whole interface of a runtime library:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">DataLayout</span><span class="w"> </span><span class="o">&amp;</span><span class="n">DL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getDataLayout</span><span class="p">();</span>
<span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">JD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ES</span><span class="p">.</span><span class="n">createJITDylib</span><span class="p">(</span><span class="s">&quot;main&quot;</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">DLSGOrErr</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">DynamicLibrarySearchGenerator</span><span class="o">::</span><span class="n">Load</span><span class="p">(</span><span class="s">&quot;/path/to/lib&quot;</span>
<span class="w">                                        </span><span class="n">DL</span><span class="p">.</span><span class="n">getGlobalPrefix</span><span class="p">()))</span>
<span class="w">  </span><span class="n">JD</span><span class="p">.</span><span class="n">addGenerator</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">DLSGOrErr</span><span class="p">);</span>
<span class="k">else</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">DLSGOrErr</span><span class="p">.</span><span class="n">takeError</span><span class="p">();</span>

<span class="c1">// IR added to JD can now link against all symbols exported by the library</span>
<span class="c1">// at &#39;/path/to/lib&#39;.</span>
<span class="n">CompileLayer</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">JD</span><span class="p">,</span><span class="w"> </span><span class="n">loadModule</span><span class="p">(...));</span>
</pre></div>
</div>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">DynamicLibrarySearchGenerator</span></code> utility can also be constructed with a
filter function to restrict the set of symbols that may be reflected. For
example, to expose an allowed set of symbols from the main process:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">DataLayout</span><span class="w"> </span><span class="o">&amp;</span><span class="n">DL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getDataLayout</span><span class="p">();</span>
<span class="n">MangleAndInterner</span><span class="w"> </span><span class="nf">Mangle</span><span class="p">(</span><span class="n">ES</span><span class="p">,</span><span class="w"> </span><span class="n">DL</span><span class="p">);</span>

<span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">JD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ES</span><span class="p">.</span><span class="n">createJITDylib</span><span class="p">(</span><span class="s">&quot;main&quot;</span><span class="p">);</span>

<span class="n">DenseSet</span><span class="o">&lt;</span><span class="n">SymbolStringPtr</span><span class="o">&gt;</span><span class="w"> </span><span class="n">AllowList</span><span class="p">({</span>
<span class="w">    </span><span class="n">Mangle</span><span class="p">(</span><span class="s">&quot;puts&quot;</span><span class="p">),</span>
<span class="w">    </span><span class="n">Mangle</span><span class="p">(</span><span class="s">&quot;gets&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">});</span>

<span class="c1">// Use GetForCurrentProcess with a predicate function that checks the</span>
<span class="c1">// allowed list.</span>
<span class="n">JD</span><span class="p">.</span><span class="n">addGenerator</span><span class="p">(</span><span class="n">cantFail</span><span class="p">(</span><span class="n">DynamicLibrarySearchGenerator</span><span class="o">::</span><span class="n">GetForCurrentProcess</span><span class="p">(</span>
<span class="w">      </span><span class="n">DL</span><span class="p">.</span><span class="n">getGlobalPrefix</span><span class="p">(),</span>
<span class="w">      </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">SymbolStringPtr</span><span class="w"> </span><span class="o">&amp;</span><span class="n">S</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">AllowList</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">S</span><span class="p">);</span><span class="w"> </span><span class="p">})));</span>

<span class="c1">// IR added to JD can now link against any symbols exported by the process</span>
<span class="c1">// and contained in the list.</span>
<span class="n">CompileLayer</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">JD</span><span class="p">,</span><span class="w"> </span><span class="n">loadModule</span><span class="p">(...));</span>
</pre></div>
</div>
</div></blockquote>
<p>References to process or library symbols could also be hardcoded into your IR
or object files using the symbols’ raw addresses, however symbolic resolution
using the JIT symbol tables should be preferred: it keeps the IR and objects
readable and reusable in subsequent JIT sessions. Hardcoded addresses are
difficult to read, and usually only good for one session.</p>
</section>
<section id="roadmap">
<h2><a class="toc-backref" href="#id27" role="doc-backlink">Roadmap</a><a class="headerlink" href="#roadmap" title="Link to this heading">¶</a></h2>
<p>ORC is still undergoing active development. Some current and future works are
listed below.</p>
<section id="current-work">
<h3><a class="toc-backref" href="#id28" role="doc-backlink">Current Work</a><a class="headerlink" href="#current-work" title="Link to this heading">¶</a></h3>
<ol class="arabic">
<li><p><strong>TargetProcessControl: Improvements to in-tree support for out-of-process
execution</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">TargetProcessControl</span></code> API provides various operations on the JIT
target process (the one which will execute the JIT’d code), including
memory allocation, memory writes, function execution, and process queries
(e.g. for the target triple). By targeting this API new components can be
developed which will work equally well for in-process and out-of-process
JITing.</p>
</li>
<li><p><strong>ORC RPC based TargetProcessControl implementation</strong></p>
<p>An ORC RPC based implementation of the <code class="docutils literal notranslate"><span class="pre">TargetProcessControl</span></code> API is
currently under development to enable easy out-of-process JITing via
file descriptors / sockets.</p>
</li>
<li><p><strong>Core State Machine Cleanup</strong></p>
<p>The core ORC state machine is currently implemented between JITDylib and
ExecutionSession. Methods are slowly being moved to <cite>ExecutionSession</cite>. This
will tidy up the code base, and also allow us to support asynchronous removal
of JITDylibs (in practice deleting an associated state object in
ExecutionSession and leaving the JITDylib instance in a defunct state until
all references to it have been released).</p>
</li>
</ol>
</section>
<section id="near-future-work">
<h3><a class="toc-backref" href="#id29" role="doc-backlink">Near Future Work</a><a class="headerlink" href="#near-future-work" title="Link to this heading">¶</a></h3>
<ol class="arabic">
<li><p><strong>ORC JIT Runtime Libraries</strong></p>
<p>We need a runtime library for JIT’d code. This would include things like
TLS registration, reentry functions, registration code for language runtimes
(e.g. Objective C and Swift) and other JIT specific runtime code. This should
be built in a similar manner to compiler-rt (possibly even as part of it).</p>
</li>
<li><p><strong>Remote jit_dlopen / jit_dlclose</strong></p>
<p>To more fully mimic the environment that static programs operate in we would
like JIT’d code to be able to “dlopen” and “dlclose” JITDylibs, running all of
their initializers/deinitializers on the current thread. This would require
support from the runtime library described above.</p>
</li>
<li><p><strong>Debugging support</strong></p>
<p>ORC currently supports the GDBRegistrationListener API when using RuntimeDyld
as the underlying JIT linker. We will need a new solution for JITLink based
platforms.</p>
</li>
</ol>
</section>
<section id="further-future-work">
<h3><a class="toc-backref" href="#id30" role="doc-backlink">Further Future Work</a><a class="headerlink" href="#further-future-work" title="Link to this heading">¶</a></h3>
<ol class="arabic">
<li><p><strong>Speculative Compilation</strong></p>
<p>ORC’s support for concurrent compilation allows us to easily enable
<em>speculative</em> JIT compilation: compilation of code that is not needed yet,
but which we have reason to believe will be needed in the future. This can be
used to hide compile latency and improve JIT throughput. A proof-of-concept
example of speculative compilation with ORC has already been developed (see
<code class="docutils literal notranslate"><span class="pre">llvm/examples/SpeculativeJIT</span></code>). Future work on this is likely to focus on
re-using and improving existing profiling support (currently used by PGO) to
feed speculation decisions, as well as built-in tools to simplify use of
speculative compilation.</p>
</li>
</ol>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id5" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Formats/architectures vary in terms of supported features. MachO and
ELF tend to have better support than COFF. Patches very welcome!</p>
</aside>
<aside class="footnote brackets" id="id6" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">2</a><span class="fn-bracket">]</span></span>
<p>The <code class="docutils literal notranslate"><span class="pre">LazyEmittingLayer</span></code>, <code class="docutils literal notranslate"><span class="pre">RemoteObjectClientLayer</span></code> and
<code class="docutils literal notranslate"><span class="pre">RemoteObjectServerLayer</span></code> do not have counterparts in the new
system. In the case of <code class="docutils literal notranslate"><span class="pre">LazyEmittingLayer</span></code> it was simply no longer
needed: in ORCv2, deferring compilation until symbols are looked up is
the default. The removal of <code class="docutils literal notranslate"><span class="pre">RemoteObjectClientLayer</span></code> and
<code class="docutils literal notranslate"><span class="pre">RemoteObjectServerLayer</span></code> means that JIT stacks can no longer be split
across processes, however this functionality appears not to have been
used.</p>
</aside>
<aside class="footnote brackets" id="id7" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">3</a><span class="fn-bracket">]</span></span>
<p>Weak definitions are currently handled correctly within dylibs, but if
multiple dylibs provide a weak definition of a symbol then each will end
up with its own definition (similar to how weak definitions are handled
in Windows DLLs). This will be fixed in the future.</p>
</aside>
</aside>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="OpaquePointers.html" title="Opaque Pointers"
             >next</a> |</li>
        <li class="right" >
          <a href="MisExpect.html" title="Misexpect"
             >previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" >User Guides</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ORC Design and Implementation</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2003-2023, LLVM Project.
      Last updated on 2023-09-19.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.5.
    </div>
  </body>
</html>