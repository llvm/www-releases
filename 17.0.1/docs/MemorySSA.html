
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>MemorySSA &#8212; LLVM 17.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b849a4e9" />
    <link rel="stylesheet" type="text/css" href="_static/llvm-theme.css?v=be84393e" />
    <script src="_static/documentation_options.js?v=08e2baec"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="MergeFunctions pass, how it works" href="MergeFunctions.html" />
    <link rel="prev" title="Markdown Quickstart Template" href="MarkdownQuickstartTemplate.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="MergeFunctions.html" title="MergeFunctions pass, how it works"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="MarkdownQuickstartTemplate.html" title="Markdown Quickstart Template"
             accesskey="P">previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" accesskey="U">User Guides</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">MemorySSA</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="https://llvm.org/docs/UserGuides.html">User Guides</a></li>
    <li><a href="https://llvm.org/docs/Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/Contributing.html">Contributing to LLVM</a></li>
    <li><a href="https://llvm.org/docs/HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#irc">IRC</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/FAQ.html">FAQ</a></li>
    <li><a href="https://llvm.org/docs/Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project/">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/MemorySSA.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="memoryssa">
<h1>MemorySSA<a class="headerlink" href="#memoryssa" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id1">Introduction</a></p></li>
<li><p><a class="reference internal" href="#memoryssa-structure" id="id2">MemorySSA Structure</a></p></li>
<li><p><a class="reference internal" href="#design-of-memoryssa" id="id3">Design of MemorySSA</a></p>
<ul>
<li><p><a class="reference internal" href="#the-walker" id="id4">The walker</a></p>
<ul>
<li><p><a class="reference internal" href="#default-walker-apis" id="id5">Default walker APIs</a></p></li>
<li><p><a class="reference internal" href="#locating-clobbers-yourself" id="id6">Locating clobbers yourself</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#use-and-def-optimization" id="id7">Use and Def optimization</a></p></li>
<li><p><a class="reference internal" href="#invalidation-and-updating" id="id8">Invalidation and updating</a></p>
<ul>
<li><p><a class="reference internal" href="#phi-placement" id="id9">Phi placement</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#non-goals" id="id10">Non-Goals</a></p></li>
<li><p><a class="reference internal" href="#design-tradeoffs" id="id11">Design tradeoffs</a></p>
<ul>
<li><p><a class="reference internal" href="#precision" id="id12">Precision</a></p></li>
<li><p><a class="reference internal" href="#precision-in-practice" id="id13">Precision in practice</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#llvm-developers-meeting-presentations" id="id14">LLVM Developers Meeting presentations</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> is an analysis that allows us to cheaply reason about the
interactions between various memory operations. Its goal is to replace
<code class="docutils literal notranslate"><span class="pre">MemoryDependenceAnalysis</span></code> for most (if not all) use-cases. This is because,
unless you’re very careful, use of <code class="docutils literal notranslate"><span class="pre">MemoryDependenceAnalysis</span></code> can easily
result in quadratic-time algorithms in LLVM. Additionally, <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> doesn’t
have as many arbitrary limits as <code class="docutils literal notranslate"><span class="pre">MemoryDependenceAnalysis</span></code>, so you should get
better results, too. One common use of <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> is to quickly find out
that something definitely cannot happen (for example, reason that a hoist
out of a loop can’t happen).</p>
<p>At a high level, one of the goals of <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> is to provide an SSA based
form for memory, complete with def-use and use-def chains, which
enables users to quickly find may-def and may-uses of memory operations.
It can also be thought of as a way to cheaply give versions to the complete
state of memory, and associate memory operations with those versions.</p>
<p>This document goes over how <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> is structured, and some basic
intuition on how <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> works.</p>
<p>A paper on MemorySSA (with notes about how it’s implemented in GCC) <a class="reference external" href="http://www.airs.com/dnovillo/Papers/mem-ssa.pdf">can be
found here</a>. Though, it’s
relatively out-of-date; the paper references multiple memory partitions, but GCC
eventually swapped to just using one, like we now have in LLVM.  Like
GCC’s, LLVM’s MemorySSA is intraprocedural.</p>
</section>
<section id="memoryssa-structure">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">MemorySSA Structure</a><a class="headerlink" href="#memoryssa-structure" title="Link to this heading">¶</a></h2>
<p>MemorySSA is a virtual IR. After it’s built, <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> will contain a
structure that maps <code class="docutils literal notranslate"><span class="pre">Instruction</span></code>s to <code class="docutils literal notranslate"><span class="pre">MemoryAccess</span></code>es, which are
<code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code>’s parallel to LLVM <code class="docutils literal notranslate"><span class="pre">Instruction</span></code>s.</p>
<p>Each <code class="docutils literal notranslate"><span class="pre">MemoryAccess</span></code> can be one of three types:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MemoryPhi</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MemoryUse</span></code></p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code>s are operations which may either modify memory, or which
introduce some kind of ordering constraints. Examples of <code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code>s
include <code class="docutils literal notranslate"><span class="pre">store</span></code>s, function calls, <code class="docutils literal notranslate"><span class="pre">load</span></code>s with <code class="docutils literal notranslate"><span class="pre">acquire</span></code> (or higher)
ordering, volatile operations, memory fences, etc. A <code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code>
always introduces a new version of the entire memory and is linked with a single
<code class="docutils literal notranslate"><span class="pre">MemoryDef/MemoryPhi</span></code> which is the version of memory that the new
version is based on. This implies that there is a <em>single</em>
<code class="docutils literal notranslate"><span class="pre">Def</span></code> chain that connects all the <code class="docutils literal notranslate"><span class="pre">Def</span></code>s, either directly
or indirectly. For example in:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="err">b</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="err">MemoryDef</span><span class="p">(</span><span class="err">a</span><span class="p">)</span>
<span class="k">c</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="err">MemoryDef</span><span class="p">(</span><span class="err">b</span><span class="p">)</span>
<span class="err">d</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="err">MemoryDef</span><span class="p">(</span><span class="k">c</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">d</span></code> is connected directly with <code class="docutils literal notranslate"><span class="pre">c</span></code> and indirectly with <code class="docutils literal notranslate"><span class="pre">b</span></code>.
This means that <code class="docutils literal notranslate"><span class="pre">d</span></code> potentially clobbers (see below) <code class="docutils literal notranslate"><span class="pre">c</span></code> <em>or</em>
<code class="docutils literal notranslate"><span class="pre">b</span></code> <em>or</em> both. This in turn implies that without the use of <a class="reference internal" href="#the-walker">The walker</a>,
initially every <code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code> clobbers every other <code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">MemoryPhi</span></code>s are <code class="docutils literal notranslate"><span class="pre">PhiNode</span></code>s, but for memory operations. If at any
point we have two (or more) <code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code>s that could flow into a
<code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code>, the block’s top <code class="docutils literal notranslate"><span class="pre">MemoryAccess</span></code> will be a
<code class="docutils literal notranslate"><span class="pre">MemoryPhi</span></code>. As in LLVM IR, <code class="docutils literal notranslate"><span class="pre">MemoryPhi</span></code>s don’t correspond to any
concrete operation. As such, <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code>s are mapped to <code class="docutils literal notranslate"><span class="pre">MemoryPhi</span></code>s
inside <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code>, whereas <code class="docutils literal notranslate"><span class="pre">Instruction</span></code>s are mapped to <code class="docutils literal notranslate"><span class="pre">MemoryUse</span></code>s
and <code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code>s.</p>
<p>Note also that in SSA, Phi nodes merge must-reach definitions (that is,
definitions that <em>must</em> be new versions of variables). In MemorySSA, PHI nodes
merge may-reach definitions (that is, until disambiguated, the versions that
reach a phi node may or may not clobber a given variable).</p>
<p><code class="docutils literal notranslate"><span class="pre">MemoryUse</span></code>s are operations which use but don’t modify memory. An example of
a <code class="docutils literal notranslate"><span class="pre">MemoryUse</span></code> is a <code class="docutils literal notranslate"><span class="pre">load</span></code>, or a <code class="docutils literal notranslate"><span class="pre">readonly</span></code> function call.</p>
<p>Every function that exists has a special <code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code> called <code class="docutils literal notranslate"><span class="pre">liveOnEntry</span></code>.
It dominates every <code class="docutils literal notranslate"><span class="pre">MemoryAccess</span></code> in the function that <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> is being
run on, and implies that we’ve hit the top of the function. It’s the only
<code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code> that maps to no <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> in LLVM IR. Use of
<code class="docutils literal notranslate"><span class="pre">liveOnEntry</span></code> implies that the memory being used is either undefined or
defined before the function begins.</p>
<p>An example of all of this overlaid on LLVM IR (obtained by running <code class="docutils literal notranslate"><span class="pre">opt</span>
<span class="pre">-passes='print&lt;memoryssa&gt;'</span> <span class="pre">-disable-output</span></code> on an <code class="docutils literal notranslate"><span class="pre">.ll</span></code> file) is below. When
viewing this example, it may be helpful to view it in terms of clobbers.
The operands of a given <code class="docutils literal notranslate"><span class="pre">MemoryAccess</span></code> are all (potential) clobbers of said
<code class="docutils literal notranslate"><span class="pre">MemoryAccess</span></code>, and the value produced by a <code class="docutils literal notranslate"><span class="pre">MemoryAccess</span></code> can act as a clobber
for other <code class="docutils literal notranslate"><span class="pre">MemoryAccess</span></code>es.</p>
<p>If a <code class="docutils literal notranslate"><span class="pre">MemoryAccess</span></code> is a <em>clobber</em> of another, it means that these two
<code class="docutils literal notranslate"><span class="pre">MemoryAccess</span></code>es may access the same memory. For example, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">MemoryDef(y)</span></code>
means that <code class="docutils literal notranslate"><span class="pre">x</span></code> potentially modifies memory that <code class="docutils literal notranslate"><span class="pre">y</span></code> modifies/constrains
(or has modified / constrained).
In the same manner, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">MemoryPhi({BB1,b},{BB2,c})</span></code> means that
anyone that uses <code class="docutils literal notranslate"><span class="pre">a</span></code> is accessing memory potentially modified / constrained
by either <code class="docutils literal notranslate"><span class="pre">b</span></code> or <code class="docutils literal notranslate"><span class="pre">c</span></code> (or both).  And finally, <code class="docutils literal notranslate"><span class="pre">MemoryUse(x)</span></code> means
that this use accesses memory that <code class="docutils literal notranslate"><span class="pre">x</span></code> has modified / constrained
(as an example, think that if <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">MemoryDef(...)</span></code>
and <code class="docutils literal notranslate"><span class="pre">MemoryUse(x)</span></code> are in the same loop, the use can’t
be hoisted outside alone).</p>
<p>Another useful way of looking at it is in terms of memory versions.
In that view, operands of a given <code class="docutils literal notranslate"><span class="pre">MemoryAccess</span></code> are the version
of the entire memory before the operation, and if the access produces
a value (i.e. <code class="docutils literal notranslate"><span class="pre">MemoryDef/MemoryPhi</span></code>),
the value is the new version of the memory after the operation.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%p1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i8</span>
<span class="w">  </span><span class="nv">%p2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i8</span>
<span class="w">  </span><span class="nv">%p3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i8</span>
<span class="w">  </span><span class="c">; 1 = MemoryDef(liveOnEntry)</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p3</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%while.cond</span>

<span class="nl">while.cond:</span>
<span class="w">  </span><span class="c">; 6 = MemoryPhi({entry,1},{if.end,4})</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">undef</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%if.then</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%if.else</span>

<span class="nl">if.then:</span>
<span class="w">  </span><span class="c">; 2 = MemoryDef(6)</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p1</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%if.end</span>

<span class="nl">if.else:</span>
<span class="w">  </span><span class="c">; 3 = MemoryDef(6)</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p2</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%if.end</span>

<span class="nl">if.end:</span>
<span class="w">  </span><span class="c">; 5 = MemoryPhi({if.then,2},{if.else,3})</span>
<span class="w">  </span><span class="c">; MemoryUse(5)</span>
<span class="w">  </span><span class="nv nv-Anonymous">%1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i8</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p1</span>
<span class="w">  </span><span class="c">; 4 = MemoryDef(5)</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p2</span>
<span class="w">  </span><span class="c">; MemoryUse(1)</span>
<span class="w">  </span><span class="nv nv-Anonymous">%2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i8</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p3</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%while.cond</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> IR is shown in comments that precede the instructions they map
to (if such an instruction exists). For example, <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">=</span> <span class="pre">MemoryDef(liveOnEntry)</span></code>
is a <code class="docutils literal notranslate"><span class="pre">MemoryAccess</span></code> (specifically, a <code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code>), and it describes the LLVM
instruction <code class="docutils literal notranslate"><span class="pre">store</span> <span class="pre">i8</span> <span class="pre">0,</span> <span class="pre">ptr</span> <span class="pre">%p3</span></code>. Other places in <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> refer to this
particular <code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code> as <code class="docutils literal notranslate"><span class="pre">1</span></code> (much like how one can refer to <code class="docutils literal notranslate"><span class="pre">load</span> <span class="pre">i8,</span> <span class="pre">ptr</span>
<span class="pre">%p1</span></code> in LLVM with <code class="docutils literal notranslate"><span class="pre">%1</span></code>). Again, <code class="docutils literal notranslate"><span class="pre">MemoryPhi</span></code>s don’t correspond to any LLVM
Instruction, so the line directly below a <code class="docutils literal notranslate"><span class="pre">MemoryPhi</span></code> isn’t special.</p>
<p>Going from the top down:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">6</span> <span class="pre">=</span> <span class="pre">MemoryPhi({entry,1},{if.end,4})</span></code> notes that, when entering
<code class="docutils literal notranslate"><span class="pre">while.cond</span></code>, the reaching definition for it is either <code class="docutils literal notranslate"><span class="pre">1</span></code> or <code class="docutils literal notranslate"><span class="pre">4</span></code>. This
<code class="docutils literal notranslate"><span class="pre">MemoryPhi</span></code> is referred to in the textual IR by the number <code class="docutils literal notranslate"><span class="pre">6</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">=</span> <span class="pre">MemoryDef(6)</span></code> notes that <code class="docutils literal notranslate"><span class="pre">store</span> <span class="pre">i8</span> <span class="pre">0,</span> <span class="pre">ptr</span> <span class="pre">%p1</span></code> is a definition,
and its reaching definition before it is <code class="docutils literal notranslate"><span class="pre">6</span></code>, or the <code class="docutils literal notranslate"><span class="pre">MemoryPhi</span></code> after
<code class="docutils literal notranslate"><span class="pre">while.cond</span></code>. (See the <a class="reference internal" href="#use-and-def-optimization">Use and Def optimization</a> and <a class="reference internal" href="#precision">Precision</a>
sections below for why this <code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code> isn’t linked to a separate,
disambiguated <code class="docutils literal notranslate"><span class="pre">MemoryPhi</span></code>.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">=</span> <span class="pre">MemoryDef(6)</span></code> notes that <code class="docutils literal notranslate"><span class="pre">store</span> <span class="pre">i8</span> <span class="pre">0,</span> <span class="pre">ptr</span> <span class="pre">%p2</span></code> is a definition; its
reaching definition is also <code class="docutils literal notranslate"><span class="pre">6</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">5</span> <span class="pre">=</span> <span class="pre">MemoryPhi({if.then,2},{if.else,3})</span></code> notes that the clobber before
this block could either be <code class="docutils literal notranslate"><span class="pre">2</span></code> or <code class="docutils literal notranslate"><span class="pre">3</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MemoryUse(5)</span></code> notes that <code class="docutils literal notranslate"><span class="pre">load</span> <span class="pre">i8,</span> <span class="pre">ptr</span> <span class="pre">%p1</span></code> is a use of memory, and that
it’s clobbered by <code class="docutils literal notranslate"><span class="pre">5</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">4</span> <span class="pre">=</span> <span class="pre">MemoryDef(5)</span></code> notes that <code class="docutils literal notranslate"><span class="pre">store</span> <span class="pre">i8</span> <span class="pre">2,</span> <span class="pre">ptr</span> <span class="pre">%p2</span></code> is a definition; its
reaching definition is <code class="docutils literal notranslate"><span class="pre">5</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MemoryUse(1)</span></code> notes that <code class="docutils literal notranslate"><span class="pre">load</span> <span class="pre">i8,</span> <span class="pre">ptr</span> <span class="pre">%p3</span></code> is just a user of memory,
and the last thing that could clobber this use is above <code class="docutils literal notranslate"><span class="pre">while.cond</span></code> (e.g.
the store to <code class="docutils literal notranslate"><span class="pre">%p3</span></code>). In memory versioning parlance, it really only depends on
the memory version 1, and is unaffected by the new memory versions generated since
then.</p></li>
</ul>
<p>As an aside, <code class="docutils literal notranslate"><span class="pre">MemoryAccess</span></code> is a <code class="docutils literal notranslate"><span class="pre">Value</span></code> mostly for convenience; it’s not
meant to interact with LLVM IR.</p>
</section>
<section id="design-of-memoryssa">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">Design of MemorySSA</a><a class="headerlink" href="#design-of-memoryssa" title="Link to this heading">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> is an analysis that can be built for any arbitrary function. When
it’s built, it does a pass over the function’s IR in order to build up its
mapping of <code class="docutils literal notranslate"><span class="pre">MemoryAccess</span></code>es. You can then query <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> for things
like the dominance relation between <code class="docutils literal notranslate"><span class="pre">MemoryAccess</span></code>es, and get the
<code class="docutils literal notranslate"><span class="pre">MemoryAccess</span></code> for any given <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> .</p>
<p>When <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> is done building, it also hands you a <code class="docutils literal notranslate"><span class="pre">MemorySSAWalker</span></code>
that you can use (see below).</p>
<section id="the-walker">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">The walker</a><a class="headerlink" href="#the-walker" title="Link to this heading">¶</a></h3>
<p>A structure that helps <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> do its job is the <code class="docutils literal notranslate"><span class="pre">MemorySSAWalker</span></code>, or
the walker, for short. The goal of the walker is to provide answers to clobber
queries beyond what’s represented directly by <code class="docutils literal notranslate"><span class="pre">MemoryAccess</span></code>es. For example,
given:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%a</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i8</span>
<span class="w">  </span><span class="nv">%b</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i8</span>

<span class="w">  </span><span class="c">; 1 = MemoryDef(liveOnEntry)</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%a</span>
<span class="w">  </span><span class="c">; 2 = MemoryDef(1)</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%b</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The store to <code class="docutils literal notranslate"><span class="pre">%a</span></code> is clearly not a clobber for the store to <code class="docutils literal notranslate"><span class="pre">%b</span></code>. It would
be the walker’s goal to figure this out, and return <code class="docutils literal notranslate"><span class="pre">liveOnEntry</span></code> when queried
for the clobber of <code class="docutils literal notranslate"><span class="pre">MemoryAccess</span></code> <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
<p>By default, <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> provides a walker that can optimize <code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code>s
and <code class="docutils literal notranslate"><span class="pre">MemoryUse</span></code>s by consulting whatever alias analysis stack you happen to
be using. Walkers were built to be flexible, though, so it’s entirely reasonable
(and expected) to create more specialized walkers (e.g. one that specifically
queries <code class="docutils literal notranslate"><span class="pre">GlobalsAA</span></code>, one that always stops at <code class="docutils literal notranslate"><span class="pre">MemoryPhi</span></code> nodes, etc).</p>
<section id="default-walker-apis">
<h4><a class="toc-backref" href="#id5" role="doc-backlink">Default walker APIs</a><a class="headerlink" href="#default-walker-apis" title="Link to this heading">¶</a></h4>
<p>There are two main APIs used to retrieve the clobbering access using the walker:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MemoryAccess</span> <span class="pre">*getClobberingMemoryAccess(MemoryAccess</span> <span class="pre">*MA);</span></code> return the
clobbering memory access for <code class="docutils literal notranslate"><span class="pre">MA</span></code>, caching all intermediate results
computed along the way as part of each access queried.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MemoryAccess</span> <span class="pre">*getClobberingMemoryAccess(MemoryAccess</span> <span class="pre">*MA,</span> <span class="pre">const</span> <span class="pre">MemoryLocation</span> <span class="pre">&amp;Loc);</span></code>
returns the access clobbering memory location <code class="docutils literal notranslate"><span class="pre">Loc</span></code>, starting at <code class="docutils literal notranslate"><span class="pre">MA</span></code>.
Because this API does not request the clobbering access of a specific memory
access, there are no results that can be cached.</p></li>
</ul>
</section>
<section id="locating-clobbers-yourself">
<h4><a class="toc-backref" href="#id6" role="doc-backlink">Locating clobbers yourself</a><a class="headerlink" href="#locating-clobbers-yourself" title="Link to this heading">¶</a></h4>
<p>If you choose to make your own walker, you can find the clobber for a
<code class="docutils literal notranslate"><span class="pre">MemoryAccess</span></code> by walking every <code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code> that dominates said
<code class="docutils literal notranslate"><span class="pre">MemoryAccess</span></code>. The structure of <code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code>s makes this relatively simple;
they ultimately form a linked list of every clobber that dominates the
<code class="docutils literal notranslate"><span class="pre">MemoryAccess</span></code> that you’re trying to optimize. In other words, the
<code class="docutils literal notranslate"><span class="pre">definingAccess</span></code> of a <code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code> is always the nearest dominating
<code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code> or <code class="docutils literal notranslate"><span class="pre">MemoryPhi</span></code> of said <code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code>.</p>
</section>
</section>
<section id="use-and-def-optimization">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Use and Def optimization</a><a class="headerlink" href="#use-and-def-optimization" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">MemoryUse</span></code>s keep a single operand, which is their defining or optimized
access.
Traditionally <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> optimized <code class="docutils literal notranslate"><span class="pre">MemoryUse</span></code>s at build-time, up to a
given threshold.
Specifically, the operand of every <code class="docutils literal notranslate"><span class="pre">MemoryUse</span></code> was optimized to point to the
actual clobber of said <code class="docutils literal notranslate"><span class="pre">MemoryUse</span></code>. This can be seen in the above example; the
second <code class="docutils literal notranslate"><span class="pre">MemoryUse</span></code> in <code class="docutils literal notranslate"><span class="pre">if.end</span></code> has an operand of <code class="docutils literal notranslate"><span class="pre">1</span></code>, which is a
<code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code> from the entry block.  This is done to make walking,
value numbering, etc, faster and easier.
As of <a class="reference external" href="https://reviews.llvm.org/D121381">this revision</a>, the default was
changed to not optimize uses at build time, in order to provide the option to
reduce compile-time if the walking is not necessary in a pass. Most users call
the new API <code class="docutils literal notranslate"><span class="pre">ensureOptimizedUses()</span></code> to keep the previous behavior and do a
one-time optimization of <code class="docutils literal notranslate"><span class="pre">MemoryUse</span></code>s, if this was not done before.
New pass users are recommended to call <code class="docutils literal notranslate"><span class="pre">ensureOptimizedUses()</span></code>.</p>
<p>Initially it was not possible to optimize <code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code>s in the same way, as we
restricted <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> to one operand per access.
This was changed and <code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code>s now keep two operands.
The first one, the defining access, is
always the previous <code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code> or <code class="docutils literal notranslate"><span class="pre">MemoryPhi</span></code> in the same basic block, or
the last one in a dominating predecessor if the current block doesn’t have any
other accesses writing to memory. This is needed for walking Def chains.
The second operand is the optimized access, if there was a previous call on the
walker’s <code class="docutils literal notranslate"><span class="pre">getClobberingMemoryAccess(MA)</span></code>. This API will cache information
as part of <code class="docutils literal notranslate"><span class="pre">MA</span></code>.
Optimizing all <code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code>s has quadratic time complexity and is not done
by default.</p>
<p>A walk of the uses for any MemoryDef can find the accesses that were optimized
to it.
A code snippet for such a walk looks like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MemoryDef</span><span class="w"> </span><span class="o">*</span><span class="n">Def</span><span class="p">;</span><span class="w">  </span><span class="c1">// find who&#39;s optimized or defining for this MemoryDef</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Def</span><span class="o">-&gt;</span><span class="n">uses</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MemoryAccess</span><span class="w"> </span><span class="o">*</span><span class="n">MA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cast</span><span class="o">&lt;</span><span class="n">MemoryAccess</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Use</span><span class="p">.</span><span class="n">getUser</span><span class="p">());</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">DefUser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cast_of_null</span><span class="o">&lt;</span><span class="n">MemoryDef</span><span class="o">&gt;</span><span class="n">MA</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">DefUser</span><span class="o">-&gt;</span><span class="n">isOptimized</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">DefUser</span><span class="o">-&gt;</span><span class="n">getOptimized</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Def</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// User who is optimized to Def</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// User who&#39;s defining access is Def; optimized to something else or not optimized.</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">MemoryUse</span></code>s are optimized, for a given store,  you can find all loads
clobbered by that store by walking the immediate and transitive uses of
the store.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">checkUses</span><span class="p">(</span><span class="n">MemoryAccess</span><span class="w"> </span><span class="o">*</span><span class="n">Def</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Def can be a MemoryDef or a MemoryPhi.</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Def</span><span class="o">-&gt;</span><span class="n">uses</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">MemoryAccess</span><span class="w"> </span><span class="o">*</span><span class="n">MA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cast</span><span class="o">&lt;</span><span class="n">MemoryAccess</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Use</span><span class="p">.</span><span class="n">getUser</span><span class="p">());</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">MU</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cast_of_null</span><span class="o">&lt;</span><span class="n">MemoryUse</span><span class="o">&gt;</span><span class="n">MA</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Process MemoryUse as needed.</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Process MemoryDef or MemoryPhi as needed.</span>

<span class="w">      </span><span class="c1">// As a user can come up twice, as an optimized access and defining</span>
<span class="w">      </span><span class="c1">// access, keep a visited list.</span>

<span class="w">      </span><span class="c1">// Check transitive uses as needed</span>
<span class="w">      </span><span class="n">checkUses</span><span class="w"> </span><span class="p">(</span><span class="n">MA</span><span class="p">);</span><span class="w"> </span><span class="c1">// use a worklist for an iterative algorithm</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>An example of similar traversals can be found in the DeadStoreElimination pass.</p>
</section>
<section id="invalidation-and-updating">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Invalidation and updating</a><a class="headerlink" href="#invalidation-and-updating" title="Link to this heading">¶</a></h3>
<p>Because <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> keeps track of LLVM IR, it needs to be updated whenever
the IR is updated. “Update”, in this case, includes the addition, deletion, and
motion of <code class="docutils literal notranslate"><span class="pre">Instructions</span></code>. The update API is being made on an as-needed basis.
If you’d like examples, <code class="docutils literal notranslate"><span class="pre">GVNHoist</span></code> and <code class="docutils literal notranslate"><span class="pre">LICM</span></code> are users of <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code>s
update API.
Note that adding new <code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code>s (by calling <code class="docutils literal notranslate"><span class="pre">insertDef</span></code>) can be a
time-consuming update, if the new access triggers many <code class="docutils literal notranslate"><span class="pre">MemoryPhi</span></code> insertions and
renaming (optimization invalidation) of many <code class="docutils literal notranslate"><span class="pre">MemoryAccesses</span></code>es.</p>
<section id="phi-placement">
<h4><a class="toc-backref" href="#id9" role="doc-backlink">Phi placement</a><a class="headerlink" href="#phi-placement" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> only places <code class="docutils literal notranslate"><span class="pre">MemoryPhi</span></code>s where they’re actually
needed. That is, it is a pruned SSA form, like LLVM’s SSA form.  For
example, consider:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%p1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i8</span>
<span class="w">  </span><span class="nv">%p2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i8</span>
<span class="w">  </span><span class="nv">%p3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i8</span>
<span class="w">  </span><span class="c">; 1 = MemoryDef(liveOnEntry)</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p3</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%while.cond</span>

<span class="nl">while.cond:</span>
<span class="w">  </span><span class="c">; 3 = MemoryPhi({%0,1},{if.end,2})</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">undef</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%if.then</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%if.else</span>

<span class="nl">if.then:</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%if.end</span>

<span class="nl">if.else:</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%if.end</span>

<span class="nl">if.end:</span>
<span class="w">  </span><span class="c">; MemoryUse(1)</span>
<span class="w">  </span><span class="nv nv-Anonymous">%1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i8</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p1</span>
<span class="w">  </span><span class="c">; 2 = MemoryDef(3)</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p2</span>
<span class="w">  </span><span class="c">; MemoryUse(1)</span>
<span class="w">  </span><span class="nv nv-Anonymous">%2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i8</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p3</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%while.cond</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Because we removed the stores from <code class="docutils literal notranslate"><span class="pre">if.then</span></code> and <code class="docutils literal notranslate"><span class="pre">if.else</span></code>, a <code class="docutils literal notranslate"><span class="pre">MemoryPhi</span></code>
for <code class="docutils literal notranslate"><span class="pre">if.end</span></code> would be pointless, so we don’t place one. So, if you need to
place a <code class="docutils literal notranslate"><span class="pre">MemoryDef</span></code> in <code class="docutils literal notranslate"><span class="pre">if.then</span></code> or <code class="docutils literal notranslate"><span class="pre">if.else</span></code>, you’ll need to also create
a <code class="docutils literal notranslate"><span class="pre">MemoryPhi</span></code> for <code class="docutils literal notranslate"><span class="pre">if.end</span></code>.</p>
<p>If it turns out that this is a large burden, we can just place <code class="docutils literal notranslate"><span class="pre">MemoryPhi</span></code>s
everywhere. Because we have Walkers that are capable of optimizing above said
phis, doing so shouldn’t prohibit optimizations.</p>
</section>
</section>
<section id="non-goals">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Non-Goals</a><a class="headerlink" href="#non-goals" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> is meant to reason about the relation between memory
operations, and enable quicker querying.
It isn’t meant to be the single source of truth for all potential memory-related
optimizations. Specifically, care must be taken when trying to use <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code>
to reason about atomic or volatile operations, as in:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="vg">@foo</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">undef</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%if.then</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%if.end</span>

<span class="nl">if.then:</span>
<span class="w">  </span><span class="c">; 1 = MemoryDef(liveOnEntry)</span>
<span class="w">  </span><span class="nv nv-Anonymous">%0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="kt">i8</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%a</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%if.end</span>

<span class="nl">if.end:</span>
<span class="w">  </span><span class="nv">%av</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="p">[</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nv">%entry</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="nv nv-Anonymous">%0</span><span class="p">,</span><span class="w"> </span><span class="nv">%if.then</span><span class="p">]</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%av</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Going solely by <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code>’s analysis, hoisting the <code class="docutils literal notranslate"><span class="pre">load</span></code> to <code class="docutils literal notranslate"><span class="pre">entry</span></code> may
seem legal. Because it’s a volatile load, though, it’s not.</p>
</section>
<section id="design-tradeoffs">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Design tradeoffs</a><a class="headerlink" href="#design-tradeoffs" title="Link to this heading">¶</a></h3>
<section id="precision">
<h4><a class="toc-backref" href="#id12" role="doc-backlink">Precision</a><a class="headerlink" href="#precision" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> in LLVM deliberately trades off precision for speed.
Let us think about memory variables as if they were disjoint partitions of the
memory (that is, if you have one variable, as above, it represents the entire
memory, and if you have multiple variables, each one represents some
disjoint portion of the memory)</p>
<p>First, because alias analysis results conflict with each other, and
each result may be what an analysis wants (IE
TBAA may say no-alias, and something else may say must-alias), it is
not possible to partition the memory the way every optimization wants.
Second, some alias analysis results are not transitive (IE A noalias B,
and B noalias C, does not mean A noalias C), so it is not possible to
come up with a precise partitioning in all cases without variables to
represent every pair of possible aliases.  Thus, partitioning
precisely may require introducing at least N^2 new virtual variables,
phi nodes, etc.</p>
<p>Each of these variables may be clobbered at multiple def sites.</p>
<p>To give an example, if you were to split up struct fields into
individual variables, all aliasing operations that may-def multiple struct
fields, will may-def more than one of them.  This is pretty common (calls,
copies, field stores, etc).</p>
<p>Experience with SSA forms for memory in other compilers has shown that
it is simply not possible to do this precisely, and in fact, doing it
precisely is not worth it, because now all the optimizations have to
walk tons and tons of virtual variables and phi nodes.</p>
<p>So we partition.  At the point at which you partition, again,
experience has shown us there is no point in partitioning to more than
one variable.  It simply generates more IR, and optimizations still
have to query something to disambiguate further anyway.</p>
<p>As a result, LLVM partitions to one variable.</p>
</section>
<section id="precision-in-practice">
<h4><a class="toc-backref" href="#id13" role="doc-backlink">Precision in practice</a><a class="headerlink" href="#precision-in-practice" title="Link to this heading">¶</a></h4>
<p>In practice, there are implementation details in LLVM that also affect the
results’ precision provided by <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code>. For example, AliasAnalysis has various
caps, or restrictions on looking through phis which can affect what <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code>
can infer. Changes made by different passes may make MemorySSA either “overly
optimized” (it can provide a more accurate result than if it were recomputed
from scratch), or “under optimized” (it could infer more if it were recomputed).
This can lead to challenges to reproduced results in isolation with a single pass
when the result relies on the state acquired by <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> due to being updated by
multiple subsequent passes.
Passes that use and update <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> should do so through the APIs provided by the
<code class="docutils literal notranslate"><span class="pre">MemorySSAUpdater</span></code>, or through calls on the Walker.
Direct optimizations to <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> are not permitted.
There is currently a single, narrowly scoped exception where DSE (DeadStoreElimination)
updates an optimized access of a store, after a traversal that guarantees the
optimization is correct. This is solely allowed due to the traversals and inferences
being beyond what <code class="docutils literal notranslate"><span class="pre">MemorySSA</span></code> does and them being “free” (i.e. DSE does them anyway).
This exception is set under a flag (“-dse-optimize-memoryssa”) and can be disabled to
help reproduce optimizations in isolation.</p>
</section>
</section>
<section id="llvm-developers-meeting-presentations">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">LLVM Developers Meeting presentations</a><a class="headerlink" href="#llvm-developers-meeting-presentations" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://www.youtube.com/watch?v=bdxWmryoHak">2016 LLVM Developers’ Meeting: G. Burgess - MemorySSA in Five Minutes</a>.</p></li>
<li><p><a class="reference external" href="https://www.youtube.com/watch?v=1e5y6WDbXCQ">2020 LLVM Developers’ Meeting: S. Baziotis &amp; S. Moll - Finding Your Way Around the LLVM Dependence Analysis Zoo</a></p></li>
</ul>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="MergeFunctions.html" title="MergeFunctions pass, how it works"
             >next</a> |</li>
        <li class="right" >
          <a href="MarkdownQuickstartTemplate.html" title="Markdown Quickstart Template"
             >previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" >User Guides</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">MemorySSA</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2003-2023, LLVM Project.
      Last updated on 2023-09-19.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.5.
    </div>
  </body>
</html>