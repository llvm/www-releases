
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>YAML I/O &#8212; LLVM 22.1.0-rc2 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/llvm-theme.css?v=96924833" />
    <script src="_static/documentation_options.js?v=106f770c"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="User Guides" href="UserGuides.html" />
    <link rel="prev" title="XRay Flight Data Recorder Trace Format" href="XRayFDRFormat.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="UserGuides.html" title="User Guides"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="XRayFDRFormat.html" title="XRay Flight Data Recorder Trace Format"
             accesskey="P">previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="Reference.html" accesskey="U">Reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">YAML I/O</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="https://llvm.org/docs/UserGuides.html">User Guides</a></li>
    <li><a href="https://llvm.org/docs/Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/Contributing.html">Contributing to LLVM</a></li>
    <li><a href="https://llvm.org/docs/HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#discord">Discord</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/FAQ.html">FAQ</a></li>
    <li><a href="https://llvm.org/docs/Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project/">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/YamlIO.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="yaml-i-o">
<h1>YAML I/O<a class="headerlink" href="#yaml-i-o" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction-to-yaml" id="id1">Introduction to YAML</a></p></li>
<li><p><a class="reference internal" href="#introduction-to-yaml-i-o" id="id2">Introduction to YAML I/O</a></p></li>
<li><p><a class="reference internal" href="#error-handling" id="id3">Error Handling</a></p></li>
<li><p><a class="reference internal" href="#scalars" id="id4">Scalars</a></p>
<ul>
<li><p><a class="reference internal" href="#built-in-types" id="id5">Built-in types</a></p></li>
<li><p><a class="reference internal" href="#unique-types" id="id6">Unique types</a></p></li>
<li><p><a class="reference internal" href="#hex-types" id="id7">Hex types</a></p></li>
<li><p><a class="reference internal" href="#scalarenumerationtraits" id="id8">ScalarEnumerationTraits</a></p></li>
<li><p><a class="reference internal" href="#bitvalue" id="id9">BitValue</a></p></li>
<li><p><a class="reference internal" href="#custom-scalar" id="id10">Custom Scalar</a></p></li>
<li><p><a class="reference internal" href="#block-scalars" id="id11">Block Scalars</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#mappings" id="id12">Mappings</a></p>
<ul>
<li><p><a class="reference internal" href="#no-normalization" id="id13">No Normalization</a></p></li>
<li><p><a class="reference internal" href="#normalization" id="id14">Normalization</a></p></li>
<li><p><a class="reference internal" href="#default-values" id="id15">Default values</a></p></li>
<li><p><a class="reference internal" href="#order-of-keys" id="id16">Order of Keys</a></p></li>
<li><p><a class="reference internal" href="#tags" id="id17">Tags</a></p></li>
<li><p><a class="reference internal" href="#validation" id="id18">Validation</a></p></li>
<li><p><a class="reference internal" href="#flow-mapping" id="id19">Flow Mapping</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#sequence" id="id20">Sequence</a></p>
<ul>
<li><p><a class="reference internal" href="#flow-sequence" id="id21">Flow Sequence</a></p></li>
<li><p><a class="reference internal" href="#utility-macros" id="id22">Utility Macros</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#document-list" id="id23">Document List</a></p></li>
<li><p><a class="reference internal" href="#user-context-data" id="id24">User Context Data</a></p></li>
<li><p><a class="reference internal" href="#output" id="id25">Output</a></p></li>
<li><p><a class="reference internal" href="#input" id="id26">Input</a></p></li>
</ul>
</nav>
<section id="introduction-to-yaml">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">Introduction to YAML</a><a class="headerlink" href="#introduction-to-yaml" title="Link to this heading">¶</a></h2>
<p>YAML is a human-readable data serialization language.  The full YAML language
spec can be read at <a class="reference external" href="http://www.yaml.org/spec/1.2/spec.html#Introduction">yaml.org</a>.  The simplest form of
YAML is just “scalars”, “mappings”, and “sequences”.  A scalar is any number
or string.  The pound/hash symbol (<code class="docutils literal notranslate"><span class="pre">#</span></code>) begins a comment line.   A mapping is
a set of key-value pairs where the key ends with a colon.  For example:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="c1"># a mapping</span>
<span class="nt">name</span><span class="p">:</span><span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">Tom</span>
<span class="nt">hat-size</span><span class="p">:</span><span class="w">  </span><span class="l l-Scalar l-Scalar-Plain">7</span>
</pre></div>
</div>
<p>A sequence is a list of items where each item starts with a leading dash (<code class="docutils literal notranslate"><span class="pre">-</span></code>).
For example:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="c1"># a sequence</span>
<span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">x86</span>
<span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">x86_64</span>
<span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">PowerPC</span>
</pre></div>
</div>
<p>You can combine mappings and sequences by indenting.  For example a sequence
of mappings in which one of the mapping values is itself a sequence:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="c1"># a sequence of mappings with one key&#39;s value being a sequence</span>
<span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">Tom</span>
<span class="w">  </span><span class="nt">cpus</span><span class="p">:</span>
<span class="w">   </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">x86</span>
<span class="w">   </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">x86_64</span>
<span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">Bob</span>
<span class="w">  </span><span class="nt">cpus</span><span class="p">:</span>
<span class="w">   </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">x86</span>
<span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">Dan</span>
<span class="w">  </span><span class="nt">cpus</span><span class="p">:</span>
<span class="w">   </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">PowerPC</span>
<span class="w">   </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">x86</span>
</pre></div>
</div>
<p>Sometimes sequences are known to be short and the one entry per line is too
verbose, so YAML offers an alternative syntax for sequences called a “Flow
Sequence” in which you put comma separated sequence elements into square
brackets.  The above example could then be simplified to:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="c1"># a sequence of mappings with one key&#39;s value being a flow sequence</span>
<span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">Tom</span>
<span class="w">  </span><span class="nt">cpus</span><span class="p">:</span><span class="w">      </span><span class="p p-Indicator">[</span><span class="w"> </span><span class="nv">x86</span><span class="p p-Indicator">,</span><span class="w"> </span><span class="nv">x86_64</span><span class="w"> </span><span class="p p-Indicator">]</span>
<span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">Bob</span>
<span class="w">  </span><span class="nt">cpus</span><span class="p">:</span><span class="w">      </span><span class="p p-Indicator">[</span><span class="w"> </span><span class="nv">x86</span><span class="w"> </span><span class="p p-Indicator">]</span>
<span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">Dan</span>
<span class="w">  </span><span class="nt">cpus</span><span class="p">:</span><span class="w">      </span><span class="p p-Indicator">[</span><span class="w"> </span><span class="nv">PowerPC</span><span class="p p-Indicator">,</span><span class="w"> </span><span class="nv">x86</span><span class="w"> </span><span class="p p-Indicator">]</span>
</pre></div>
</div>
</section>
<section id="introduction-to-yaml-i-o">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Introduction to YAML I/O</a><a class="headerlink" href="#introduction-to-yaml-i-o" title="Link to this heading">¶</a></h2>
<p>The use of indenting makes the YAML easy for a human to read and understand,
but having a program read and write YAML involves a lot of tedious details.
The YAML I/O library structures and simplifies reading and writing YAML
documents.</p>
<p>YAML I/O assumes you have some “native” data structures which you want to be
able to dump as YAML and recreate from YAML.  The first step is to try
writing example YAML for your data structures. You may find after looking at
possible YAML representations that a direct mapping of your data structures
to YAML is not very readable.  Often, the fields are not in an order that
a human would find readable.  Or the same information is replicated in multiple
locations, making it hard for a human to write such YAML correctly.</p>
<p>In relational database theory there is a design step called normalization in
which you reorganize fields and tables.  The same considerations need to
go into the design of your YAML encoding.  But, you may not want to change
your existing native data structures.  Therefore, when writing out YAML,
there may be a normalization step, and when reading YAML there would be a
corresponding denormalization step.</p>
<p>YAML I/O uses a non-invasive, traits-based design.  YAML I/O defines some
abstract base templates.  You specialize those templates on your data types.
For instance, if you have an enumerated type <code class="docutils literal notranslate"><span class="pre">FooBar</span></code> you could specialize
<code class="docutils literal notranslate"><span class="pre">ScalarEnumerationTraits</span></code> on that type and define the <code class="docutils literal notranslate"><span class="pre">enumeration()</span></code> method:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">ScalarEnumerationTraits</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">IO</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ScalarEnumerationTraits</span><span class="o">&lt;</span><span class="n">FooBar</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">enumeration</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">FooBar</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>As with all YAML I/O template specializations, the <code class="docutils literal notranslate"><span class="pre">ScalarEnumerationTraits</span></code> is used for
both reading and writing YAML. That is, the mapping between in-memory enum
values and the YAML string representation is only in one place.
This assures that the code for writing and parsing of YAML stays in sync.</p>
<p>To specify YAML mappings, you define a specialization on
<code class="docutils literal notranslate"><span class="pre">llvm::yaml::MappingTraits</span></code>.
If your native data structure happens to be a struct that is already normalized,
then the specialization is simple.  For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">MappingTraits</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">IO</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MappingTraits</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">mapping</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">Person</span><span class="w"> </span><span class="o">&amp;</span><span class="n">info</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">mapRequired</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">,</span><span class="w">         </span><span class="n">info</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">mapOptional</span><span class="p">(</span><span class="s">&quot;hat-size&quot;</span><span class="p">,</span><span class="w">     </span><span class="n">info</span><span class="p">.</span><span class="n">hatSize</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>A YAML sequence is automatically inferred if your data type has <code class="docutils literal notranslate"><span class="pre">begin()</span></code>/<code class="docutils literal notranslate"><span class="pre">end()</span></code>
iterators and a <code class="docutils literal notranslate"><span class="pre">push_back()</span></code> method.  Therefore any of the STL containers
(such as <code class="docutils literal notranslate"><span class="pre">std::vector&lt;&gt;</span></code>) will automatically translate to YAML sequences.</p>
<p>Once you have defined specializations for your data types, you can
programmatically use YAML I/O to write a YAML document:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">Output</span><span class="p">;</span>

<span class="n">Person</span><span class="w"> </span><span class="n">tom</span><span class="p">;</span>
<span class="n">tom</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Tom&quot;</span><span class="p">;</span>
<span class="n">tom</span><span class="p">.</span><span class="n">hatSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
<span class="n">Person</span><span class="w"> </span><span class="n">dan</span><span class="p">;</span>
<span class="n">dan</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Dan&quot;</span><span class="p">;</span>
<span class="n">dan</span><span class="p">.</span><span class="n">hatSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span><span class="w"> </span><span class="n">persons</span><span class="p">;</span>
<span class="n">persons</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tom</span><span class="p">);</span>
<span class="n">persons</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">dan</span><span class="p">);</span>

<span class="n">Output</span><span class="w"> </span><span class="nf">yout</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">outs</span><span class="p">());</span>
<span class="n">yout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">persons</span><span class="p">;</span>
</pre></div>
</div>
<p>This would write the following:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">Tom</span>
<span class="w">  </span><span class="nt">hat-size</span><span class="p">:</span><span class="w">  </span><span class="l l-Scalar l-Scalar-Plain">8</span>
<span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">Dan</span>
<span class="w">  </span><span class="nt">hat-size</span><span class="p">:</span><span class="w">  </span><span class="l l-Scalar l-Scalar-Plain">7</span>
</pre></div>
</div>
<p>And you can also read such YAML documents with the following code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">Input</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PersonList</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PersonList</span><span class="o">&gt;</span><span class="w"> </span><span class="n">docs</span><span class="p">;</span>

<span class="n">Input</span><span class="w"> </span><span class="nf">yin</span><span class="p">(</span><span class="n">document</span><span class="p">.</span><span class="n">getBuffer</span><span class="p">());</span>
<span class="n">yin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">docs</span><span class="p">;</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">yin</span><span class="p">.</span><span class="n">error</span><span class="p">()</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="k">return</span><span class="p">;</span>

<span class="c1">// Process read document</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">PersonList</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pl</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">docs</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Person</span><span class="w"> </span><span class="o">&amp;</span><span class="n">person</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">pl</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;name=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">person</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>One other feature of YAML is the ability to define multiple documents in a
single file.  That is why reading YAML produces a vector of your document type.</p>
</section>
<section id="error-handling">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">Error Handling</a><a class="headerlink" href="#error-handling" title="Link to this heading">¶</a></h2>
<p>When parsing a YAML document, if the input does not match your schema (as
expressed in your <code class="docutils literal notranslate"><span class="pre">XxxTraits&lt;&gt;</span></code> specializations).  YAML I/O
will print out an error message and your Input object’s <code class="docutils literal notranslate"><span class="pre">error()</span></code> method will
return true. For instance, the following document:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">Tom</span>
<span class="w">  </span><span class="nt">shoe-size</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">12</span>
<span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">Dan</span>
<span class="w">  </span><span class="nt">hat-size</span><span class="p">:</span><span class="w">  </span><span class="l l-Scalar l-Scalar-Plain">7</span>
</pre></div>
</div>
<p>Has a key (shoe-size) that is not defined in the schema.  YAML I/O will
automatically generate this error:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">YAML:2:2: error</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">unknown key &#39;shoe-size&#39;</span>
<span class="w">  </span><span class="l l-Scalar l-Scalar-Plain">shoe-size</span><span class="p p-Indicator">:</span><span class="w">       </span><span class="l l-Scalar l-Scalar-Plain">12</span>
<span class="w">  </span><span class="l l-Scalar l-Scalar-Plain">^~~~~~~~~</span>
</pre></div>
</div>
<p>Similar errors are produced for other input not conforming to the schema.</p>
</section>
<section id="scalars">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">Scalars</a><a class="headerlink" href="#scalars" title="Link to this heading">¶</a></h2>
<p>YAML scalars are just strings (i.e., not a sequence or mapping).  The YAML I/O
library provides support for translating between YAML scalars and specific
C++ types.</p>
<section id="built-in-types">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">Built-in types</a><a class="headerlink" href="#built-in-types" title="Link to this heading">¶</a></h3>
<p>The following types have built-in support in YAML I/O:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">float</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">double</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">StringRef</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::string</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int64_t</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int32_t</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int16_t</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int8_t</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint64_t</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint32_t</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint16_t</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">uint8_t</span></code></p></li>
</ul>
<p>That is, you can use those types in fields of <code class="docutils literal notranslate"><span class="pre">MappingTraits</span></code> or as the element type
in a sequence.  When reading, YAML I/O will validate that the string found
is convertible to that type and error out if not.</p>
</section>
<section id="unique-types">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">Unique types</a><a class="headerlink" href="#unique-types" title="Link to this heading">¶</a></h3>
<p>Given that YAML I/O is trait based, the selection of how to convert your data
to YAML is based on the type of your data.  But in C++ type matching, typedefs
do not generate unique type names.  That means if you have two typedefs of
unsigned int, to YAML I/O both types look exactly like unsigned int.  To
facilitate making unique type names, YAML I/O provides a macro which is used
like a typedef on built-in types, but expands to create a class with conversion
operators to and from the base type.  For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">LLVM_YAML_STRONG_TYPEDEF</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">MyFooFlags</span><span class="p">)</span>
<span class="n">LLVM_YAML_STRONG_TYPEDEF</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">MyBarFlags</span><span class="p">)</span>
</pre></div>
</div>
<p>This generates two classes <code class="docutils literal notranslate"><span class="pre">MyFooFlags</span></code> and <code class="docutils literal notranslate"><span class="pre">MyBarFlags</span></code> which you can use in your
native data structures instead of <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code>. They are implicitly
converted to and from <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code>.  The point of creating these unique types
is that you can now specify traits on them to get different YAML conversions.</p>
</section>
<section id="hex-types">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Hex types</a><a class="headerlink" href="#hex-types" title="Link to this heading">¶</a></h3>
<p>An example use of a unique type is that YAML I/O provides fixed-sized unsigned
integers that are written with YAML I/O as hexadecimal instead of the decimal
format used by the built-in integer types:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Hex64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Hex32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Hex16</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Hex8</span></code></p></li>
</ul>
<p>You can use <code class="docutils literal notranslate"><span class="pre">llvm::yaml::Hex32</span></code> instead of <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code>. The only difference will
be that when YAML I/O writes out that type it will be formatted in hexadecimal.</p>
</section>
<section id="scalarenumerationtraits">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">ScalarEnumerationTraits</a><a class="headerlink" href="#scalarenumerationtraits" title="Link to this heading">¶</a></h3>
<p>YAML I/O supports translating between in-memory enumerations and a set of string
values in YAML documents. This is done by specializing <code class="docutils literal notranslate"><span class="pre">ScalarEnumerationTraits&lt;&gt;</span></code>
on your enumeration type and defining an <code class="docutils literal notranslate"><span class="pre">enumeration()</span></code> method.
For instance, suppose you had an enumeration of CPUs and a struct with it as
a field:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="nc">CPUs</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cpu_x86_64</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span>
<span class="w">  </span><span class="n">cpu_x86</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span>
<span class="w">  </span><span class="n">cpu_PowerPC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Info</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">CPUs</span><span class="w">      </span><span class="n">cpu</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w">  </span><span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>To support reading and writing of this enumeration, you can define a
<code class="docutils literal notranslate"><span class="pre">ScalarEnumerationTraits</span></code> specialization on CPUs, which can then be used
as a field type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">ScalarEnumerationTraits</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">MappingTraits</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">IO</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ScalarEnumerationTraits</span><span class="o">&lt;</span><span class="n">CPUs</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">enumeration</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">CPUs</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">enumCase</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;x86_64&quot;</span><span class="p">,</span><span class="w">  </span><span class="n">cpu_x86_64</span><span class="p">);</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">enumCase</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;x86&quot;</span><span class="p">,</span><span class="w">     </span><span class="n">cpu_x86</span><span class="p">);</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">enumCase</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;PowerPC&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cpu_PowerPC</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MappingTraits</span><span class="o">&lt;</span><span class="n">Info</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">mapping</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">Info</span><span class="w"> </span><span class="o">&amp;</span><span class="n">info</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">mapRequired</span><span class="p">(</span><span class="s">&quot;cpu&quot;</span><span class="p">,</span><span class="w">       </span><span class="n">info</span><span class="p">.</span><span class="n">cpu</span><span class="p">);</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">mapOptional</span><span class="p">(</span><span class="s">&quot;flags&quot;</span><span class="p">,</span><span class="w">     </span><span class="n">info</span><span class="p">.</span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>When reading YAML, if the string found does not match any of the strings
specified by <code class="docutils literal notranslate"><span class="pre">enumCase()</span></code> methods, an error is automatically generated.
When writing YAML, if the value being written does not match any of the values
specified by the <code class="docutils literal notranslate"><span class="pre">enumCase()</span></code> methods, a runtime assertion is triggered.</p>
</section>
<section id="bitvalue">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">BitValue</a><a class="headerlink" href="#bitvalue" title="Link to this heading">¶</a></h3>
<p>Another common data structure in C++ is a field where each bit has a unique
meaning.  This is often used in a “flags” field.  YAML I/O has support for
converting such fields to a flow sequence.   For instance suppose you
had the following bit flags defined:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">flagsPointy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="n">flagsHollow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span>
<span class="w">  </span><span class="n">flagsFlat</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span>
<span class="w">  </span><span class="n">flagsRound</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span>
<span class="p">};</span>

<span class="n">LLVM_YAML_STRONG_TYPEDEF</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">MyFlags</span><span class="p">)</span>
</pre></div>
</div>
<p>To support reading and writing of <code class="docutils literal notranslate"><span class="pre">MyFlags</span></code>, you specialize <code class="docutils literal notranslate"><span class="pre">ScalarBitSetTraits&lt;&gt;</span></code>
on <code class="docutils literal notranslate"><span class="pre">MyFlags</span></code> and provide the bit values and their names.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">ScalarBitSetTraits</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">MappingTraits</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">IO</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ScalarBitSetTraits</span><span class="o">&lt;</span><span class="n">MyFlags</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bitset</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">MyFlags</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">bitSetCase</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;hollow&quot;</span><span class="p">,</span><span class="w">  </span><span class="n">flagHollow</span><span class="p">);</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">bitSetCase</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;flat&quot;</span><span class="p">,</span><span class="w">    </span><span class="n">flagFlat</span><span class="p">);</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">bitSetCase</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;round&quot;</span><span class="p">,</span><span class="w">   </span><span class="n">flagRound</span><span class="p">);</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">bitSetCase</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;pointy&quot;</span><span class="p">,</span><span class="w">  </span><span class="n">flagPointy</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Info</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">StringRef</span><span class="w">   </span><span class="n">name</span><span class="p">;</span>
<span class="w">  </span><span class="n">MyFlags</span><span class="w">     </span><span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MappingTraits</span><span class="o">&lt;</span><span class="n">Info</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">mapping</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">Info</span><span class="o">&amp;</span><span class="w"> </span><span class="n">info</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">mapRequired</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">,</span><span class="w">  </span><span class="n">info</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">mapRequired</span><span class="p">(</span><span class="s">&quot;flags&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">flags</span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>With the above, YAML I/O (when writing) will test mask each value in the
bitset trait against the flags field, and each that matches will
cause the corresponding string to be added to the flow sequence.  The opposite
is done when reading and any unknown string values will result in an error. With
the above schema, a same valid YAML document is:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">name</span><span class="p">:</span><span class="w">    </span><span class="l l-Scalar l-Scalar-Plain">Tom</span>
<span class="nt">flags</span><span class="p">:</span><span class="w">   </span><span class="p p-Indicator">[</span><span class="w"> </span><span class="nv">pointy</span><span class="p p-Indicator">,</span><span class="w"> </span><span class="nv">flat</span><span class="w"> </span><span class="p p-Indicator">]</span>
</pre></div>
</div>
<p>Sometimes a “flags” field might contain an enumeration part
defined by a bit-mask.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">flagsFeatureA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">  </span><span class="n">flagsFeatureB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">  </span><span class="n">flagsFeatureC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span>

<span class="w">  </span><span class="n">flagsCPUMask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">24</span><span class="p">,</span>

<span class="w">  </span><span class="n">flagsCPU1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span>
<span class="w">  </span><span class="n">flagsCPU2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span>
<span class="p">};</span>
</pre></div>
</div>
<p>To support reading and writing such fields, you need to use the <code class="docutils literal notranslate"><span class="pre">maskedBitSet()</span></code>
method and provide the bit values, their names and the enumeration mask.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ScalarBitSetTraits</span><span class="o">&lt;</span><span class="n">MyFlags</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bitset</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">MyFlags</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">bitSetCase</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;featureA&quot;</span><span class="p">,</span><span class="w">  </span><span class="n">flagsFeatureA</span><span class="p">);</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">bitSetCase</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;featureB&quot;</span><span class="p">,</span><span class="w">  </span><span class="n">flagsFeatureB</span><span class="p">);</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">bitSetCase</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;featureC&quot;</span><span class="p">,</span><span class="w">  </span><span class="n">flagsFeatureC</span><span class="p">);</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">maskedBitSetCase</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;CPU1&quot;</span><span class="p">,</span><span class="w">  </span><span class="n">flagsCPU1</span><span class="p">,</span><span class="w"> </span><span class="n">flagsCPUMask</span><span class="p">);</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">maskedBitSetCase</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;CPU2&quot;</span><span class="p">,</span><span class="w">  </span><span class="n">flagsCPU2</span><span class="p">,</span><span class="w"> </span><span class="n">flagsCPUMask</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>YAML I/O (when writing) will apply the enumeration mask to the flags field,
and compare the result and values from the bitset. As in case of a regular
bitset, each that matches will cause the corresponding string to be added
to the flow sequence.</p>
</section>
<section id="custom-scalar">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Custom Scalar</a><a class="headerlink" href="#custom-scalar" title="Link to this heading">¶</a></h3>
<p>Sometimes, for readability, a scalar needs to be formatted in a custom way. For
instance, your internal data structure may use an integer for time (seconds since
some epoch), but in YAML it would be much nicer to express that integer in
some time format (e.g., <code class="docutils literal notranslate"><span class="pre">4-May-2012</span> <span class="pre">10:30pm</span></code>).  YAML I/O has a way to support
custom formatting and parsing of scalar types by specializing <code class="docutils literal notranslate"><span class="pre">ScalarTraits&lt;&gt;</span></code> on
your data type.  When writing, YAML I/O will provide the native type and
your specialization must create a temporary <code class="docutils literal notranslate"><span class="pre">llvm::StringRef</span></code>.  When reading,
YAML I/O will provide an <code class="docutils literal notranslate"><span class="pre">llvm::StringRef</span></code> of scalar and your specialization
must convert that to your native data type.  An outline of a custom scalar type
looks like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">ScalarTraits</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">IO</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ScalarTraits</span><span class="o">&lt;</span><span class="n">MyCustomType</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyCustomType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">,</span>
<span class="w">                     </span><span class="n">llvm</span><span class="o">::</span><span class="n">raw_ostream</span><span class="w"> </span><span class="o">&amp;</span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">out</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w">  </span><span class="c1">// do custom formatting here</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">StringRef</span><span class="w"> </span><span class="nf">input</span><span class="p">(</span><span class="n">StringRef</span><span class="w"> </span><span class="n">scalar</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">MyCustomType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// do custom parsing here.  Return the empty string on success,</span>
<span class="w">    </span><span class="c1">// or an error message on failure.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">StringRef</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Determine if this scalar needs quotes.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">QuotingType</span><span class="w"> </span><span class="nf">mustQuote</span><span class="p">(</span><span class="n">StringRef</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">QuotingType</span><span class="o">::</span><span class="n">Single</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="block-scalars">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Block Scalars</a><a class="headerlink" href="#block-scalars" title="Link to this heading">¶</a></h3>
<p>YAML block scalars are string literals that are represented in YAML using the
literal block notation, just like the example shown below:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">text</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">|</span>
<span class="w">  </span><span class="no">First line</span>
<span class="w">  </span><span class="no">Second line</span>
</pre></div>
</div>
<p>The YAML I/O library provides support for translating between YAML block scalars
and specific C++ types by allowing you to specialize <code class="docutils literal notranslate"><span class="pre">BlockScalarTraits&lt;&gt;</span></code> on
your data type. The library doesn’t provide any built-in support for block
scalar I/O for types like <code class="docutils literal notranslate"><span class="pre">std::string</span></code> and <code class="docutils literal notranslate"><span class="pre">llvm::StringRef</span></code> as they are already
supported by YAML I/O and use the ordinary scalar notation by default.</p>
<p><code class="docutils literal notranslate"><span class="pre">BlockScalarTraits</span></code> specializations are very similar to the
<code class="docutils literal notranslate"><span class="pre">ScalarTraits</span></code> specialization - YAML I/O will provide the native type and your
specialization must create a temporary <code class="docutils literal notranslate"><span class="pre">llvm::StringRef</span></code> when writing, and
it will also provide an <code class="docutils literal notranslate"><span class="pre">llvm::StringRef</span></code> that has the value of that block scalar
and your specialization must convert that to your native data type when reading.
An example of a custom type with an appropriate specialization of
<code class="docutils literal notranslate"><span class="pre">BlockScalarTraits</span></code> is shown below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">BlockScalarTraits</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">IO</span><span class="p">;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">MyStringType</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">Str</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">BlockScalarTraits</span><span class="o">&lt;</span><span class="n">MyStringType</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyStringType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Value</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">Ctxt</span><span class="p">,</span>
<span class="w">                     </span><span class="n">llvm</span><span class="o">::</span><span class="n">raw_ostream</span><span class="w"> </span><span class="o">&amp;</span><span class="n">OS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">OS</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Value</span><span class="p">.</span><span class="n">Str</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">StringRef</span><span class="w"> </span><span class="nf">input</span><span class="p">(</span><span class="n">StringRef</span><span class="w"> </span><span class="n">Scalar</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">Ctxt</span><span class="p">,</span>
<span class="w">                         </span><span class="n">MyStringType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Value</span><span class="p">.</span><span class="n">Str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Scalar</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">StringRef</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
</section>
<section id="mappings">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">Mappings</a><a class="headerlink" href="#mappings" title="Link to this heading">¶</a></h2>
<p>To be translated to or from a YAML mapping for your type <code class="docutils literal notranslate"><span class="pre">T</span></code>, you must specialize
<code class="docutils literal notranslate"><span class="pre">llvm::yaml::MappingTraits</span></code> on <code class="docutils literal notranslate"><span class="pre">T</span></code> and implement the <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">mapping(IO</span> <span class="pre">&amp;io,</span> <span class="pre">T&amp;)</span></code>
method. If your native data structures use pointers to a class everywhere,
you can specialize on the class pointer.  Examples:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">MappingTraits</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">IO</span><span class="p">;</span>

<span class="c1">// Example of struct Foo which is used by value</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MappingTraits</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">mapping</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="o">&amp;</span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">mapOptional</span><span class="p">(</span><span class="s">&quot;size&quot;</span><span class="p">,</span><span class="w">      </span><span class="n">foo</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Example of struct Bar which is natively always a pointer</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MappingTraits</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">*&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">mapping</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">bar</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">mapOptional</span><span class="p">(</span><span class="s">&quot;size&quot;</span><span class="p">,</span><span class="w">    </span><span class="n">bar</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>There are circumstances where we want to allow the entire mapping to be
read as an enumeration.  For example, say some configuration option
started as an enumeration.  Then it got more complex so it is now a
mapping.  But it is necessary to support the old configuration files.
In that case, add a function <code class="docutils literal notranslate"><span class="pre">enumInput</span></code> like for
<code class="docutils literal notranslate"><span class="pre">ScalarEnumerationTraits::enumeration</span></code>.  Examples:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">FooBarEnum</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">Foo</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">Bar</span><span class="p">;</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">FooBarEnum</span><span class="w"> </span><span class="o">&amp;</span><span class="n">R</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">R</span><span class="p">.</span><span class="n">Foo</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">R</span><span class="p">.</span><span class="n">Bar</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">MappingTraits</span><span class="o">&lt;</span><span class="n">FooBarEnum</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">enumInput</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">FooBarEnum</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">enumCase</span><span class="p">(</span><span class="n">Val</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;OnlyFoo&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">FooBarEnum</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">}));</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">enumCase</span><span class="p">(</span><span class="n">Val</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;OnlyBar&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">FooBarEnum</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">}));</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">mapping</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">FooBarEnum</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">mapOptional</span><span class="p">(</span><span class="s">&quot;Foo&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Val</span><span class="p">.</span><span class="n">Foo</span><span class="p">);</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">mapOptional</span><span class="p">(</span><span class="s">&quot;Bar&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Val</span><span class="p">.</span><span class="n">Bar</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<section id="no-normalization">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">No Normalization</a><a class="headerlink" href="#no-normalization" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">mapping()</span></code> method is responsible, if needed, for normalizing and
denormalizing. In a simple case where the native data structure requires no
normalization, the mapping method just uses <code class="docutils literal notranslate"><span class="pre">mapOptional()</span></code> or <code class="docutils literal notranslate"><span class="pre">mapRequired()</span></code> to
bind the struct’s fields to YAML key names.  For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">MappingTraits</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">IO</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MappingTraits</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">mapping</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">Person</span><span class="w"> </span><span class="o">&amp;</span><span class="n">info</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">mapRequired</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">,</span><span class="w">         </span><span class="n">info</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">mapOptional</span><span class="p">(</span><span class="s">&quot;hat-size&quot;</span><span class="p">,</span><span class="w">     </span><span class="n">info</span><span class="p">.</span><span class="n">hatSize</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="normalization">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Normalization</a><a class="headerlink" href="#normalization" title="Link to this heading">¶</a></h3>
<p>When [de]normalization is required, the <code class="docutils literal notranslate"><span class="pre">mapping()</span></code> method needs a way to access
normalized values as fields. To help with this, there is
a template <code class="docutils literal notranslate"><span class="pre">MappingNormalization&lt;&gt;</span></code> which you can then use to automatically
do the normalization and denormalization.  The template is used to create
a local variable in your <code class="docutils literal notranslate"><span class="pre">mapping()</span></code> method which contains the normalized keys.</p>
<p>Suppose you have native data type
Polar which specifies a position in polar coordinates (distance, angle):</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Polar</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">distance</span><span class="p">;</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">angle</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>but you’ve decided the normalized YAML form should be in x,y coordinates. That
is, you want the yaml to look like:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">x</span><span class="p">:</span><span class="w">   </span><span class="l l-Scalar l-Scalar-Plain">10.3</span>
<span class="nt">y</span><span class="p">:</span><span class="w">   </span><span class="l l-Scalar l-Scalar-Plain">-4.7</span>
</pre></div>
</div>
<p>You can support this by defining a <code class="docutils literal notranslate"><span class="pre">MappingTraits</span></code> that normalizes the polar
coordinates to x,y coordinates when writing YAML and denormalizes x,y
coordinates into polar when reading YAML.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">MappingTraits</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">IO</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MappingTraits</span><span class="o">&lt;</span><span class="n">Polar</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">NormalizedPolar</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">NormalizedPolar</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">)</span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span><span class="w"> </span><span class="n">y</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">NormalizedPolar</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">Polar</span><span class="w"> </span><span class="o">&amp;</span><span class="n">polar</span><span class="p">)</span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">polar</span><span class="p">.</span><span class="n">distance</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="n">polar</span><span class="p">.</span><span class="n">angle</span><span class="p">)),</span>
<span class="w">        </span><span class="n">y</span><span class="p">(</span><span class="n">polar</span><span class="p">.</span><span class="n">distance</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">polar</span><span class="p">.</span><span class="n">angle</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">Polar</span><span class="w"> </span><span class="n">denormalize</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">Polar</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="p">),</span><span class="w"> </span><span class="n">arctan</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">float</span><span class="w">        </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w">        </span><span class="n">y</span><span class="p">;</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">mapping</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">Polar</span><span class="w"> </span><span class="o">&amp;</span><span class="n">polar</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">MappingNormalization</span><span class="o">&lt;</span><span class="n">NormalizedPolar</span><span class="p">,</span><span class="w"> </span><span class="n">Polar</span><span class="o">&gt;</span><span class="w"> </span><span class="n">keys</span><span class="p">(</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">polar</span><span class="p">);</span>

<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">mapRequired</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">,</span><span class="w">    </span><span class="n">keys</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">mapRequired</span><span class="p">(</span><span class="s">&quot;y&quot;</span><span class="p">,</span><span class="w">    </span><span class="n">keys</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>When writing YAML, the local variable “keys” will be a stack allocated
instance of <code class="docutils literal notranslate"><span class="pre">NormalizedPolar</span></code>, constructed from the supplied polar object which
initializes it x and y fields.  The <code class="docutils literal notranslate"><span class="pre">mapRequired()</span></code> methods then write out the x
and y values as key/value pairs.</p>
<p>When reading YAML, the local variable “keys” will be a stack allocated instance
of <code class="docutils literal notranslate"><span class="pre">NormalizedPolar</span></code>, constructed by the empty constructor.  The <code class="docutils literal notranslate"><span class="pre">mapRequired()</span></code>
methods will find the matching key in the YAML document and fill in the x and y
fields of the <code class="docutils literal notranslate"><span class="pre">NormalizedPolar</span></code> object keys. At the end of the <code class="docutils literal notranslate"><span class="pre">mapping()</span></code> method
when the local keys variable goes out of scope, the <code class="docutils literal notranslate"><span class="pre">denormalize()</span></code> method will
automatically be called to convert the read values back to polar coordinates,
and then assigned back to the second parameter to <code class="docutils literal notranslate"><span class="pre">mapping()</span></code>.</p>
<p>In some cases, the normalized class may be a subclass of the native type and
could be returned by the <code class="docutils literal notranslate"><span class="pre">denormalize()</span></code> method, except that the temporary
normalized instance is stack allocated.  In these cases, the utility template
<code class="docutils literal notranslate"><span class="pre">MappingNormalizationHeap&lt;&gt;</span></code> can be used instead.  It just like
<code class="docutils literal notranslate"><span class="pre">MappingNormalization&lt;&gt;</span></code> except that it heap allocates the normalized object
when reading YAML.  It never destroys the normalized object.  The <code class="docutils literal notranslate"><span class="pre">denormalize()</span></code>
method can this return <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</section>
<section id="default-values">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">Default values</a><a class="headerlink" href="#default-values" title="Link to this heading">¶</a></h3>
<p>Within a <code class="docutils literal notranslate"><span class="pre">mapping()</span></code> method, calls to <code class="docutils literal notranslate"><span class="pre">io.mapRequired()</span></code> mean that that key is
required to exist when parsing YAML documents; otherwise, YAML I/O will issue an
error.</p>
<p>On the other hand, keys registered with <code class="docutils literal notranslate"><span class="pre">io.mapOptional()</span></code> are allowed to not
exist in the YAML document being read.  So what value is put in the field
for those optional keys?
There are two steps to how those optional fields are filled in. First, the
second parameter to the <code class="docutils literal notranslate"><span class="pre">mapping()</span></code> method is a reference to a native class.  That
native class must have a default constructor.  Whatever value the default
constructor initially sets for an optional field will be that field’s value.
Second, the <code class="docutils literal notranslate"><span class="pre">mapOptional()</span></code> method has an optional third parameter.  If provided
it is the value that <code class="docutils literal notranslate"><span class="pre">mapOptional()</span></code> should set that field to if the YAML document
does not have that key.</p>
<p>There is one important difference between those two ways (default constructor
and third parameter to <code class="docutils literal notranslate"><span class="pre">mapOptional()</span></code>). When YAML I/O generates a YAML document,
if the <code class="docutils literal notranslate"><span class="pre">mapOptional()</span></code> third parameter is used, if the actual value being written
is the same as (using <code class="docutils literal notranslate"><span class="pre">==</span></code>) the default value, then that key/value is not written.</p>
</section>
<section id="order-of-keys">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">Order of Keys</a><a class="headerlink" href="#order-of-keys" title="Link to this heading">¶</a></h3>
<p>When writing out a YAML document, the keys are written in the order that the
calls to <code class="docutils literal notranslate"><span class="pre">mapRequired()</span></code>/<code class="docutils literal notranslate"><span class="pre">mapOptional()</span></code> are made in the <code class="docutils literal notranslate"><span class="pre">mapping()</span></code> method. This
gives you a chance to write the fields in an order that a human reader of
the YAML document would find natural.  This may be different that the order
of the fields in the native class.</p>
<p>When reading in a YAML document, the keys in the document can be in any order,
but they are processed in the order that the calls to <code class="docutils literal notranslate"><span class="pre">mapRequired()</span></code>/<code class="docutils literal notranslate"><span class="pre">mapOptional()</span></code>
are made in the <code class="docutils literal notranslate"><span class="pre">mapping()</span></code> method.  That enables some interesting
functionality.  For instance, if the first field bound is the cpu and the second
field bound is flags, and the flags are cpu specific, you can programmatically
switch how the flags are converted to and from YAML based on the cpu.
This works for both reading and writing. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">MappingTraits</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">IO</span><span class="p">;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Info</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">CPUs</span><span class="w">        </span><span class="n">cpu</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w">    </span><span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MappingTraits</span><span class="o">&lt;</span><span class="n">Info</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">mapping</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">Info</span><span class="w"> </span><span class="o">&amp;</span><span class="n">info</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">io</span><span class="p">.</span><span class="n">mapRequired</span><span class="p">(</span><span class="s">&quot;cpu&quot;</span><span class="p">,</span><span class="w">       </span><span class="n">info</span><span class="p">.</span><span class="n">cpu</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// flags must come after cpu for this to work when reading yaml</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">cpu</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">cpu_x86_64</span><span class="w"> </span><span class="p">)</span>
<span class="w">      </span><span class="n">io</span><span class="p">.</span><span class="n">mapRequired</span><span class="p">(</span><span class="s">&quot;flags&quot;</span><span class="p">,</span><span class="w">  </span><span class="o">*</span><span class="p">(</span><span class="n">My86_64Flags</span><span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="p">.</span><span class="n">flags</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">      </span><span class="n">io</span><span class="p">.</span><span class="n">mapRequired</span><span class="p">(</span><span class="s">&quot;flags&quot;</span><span class="p">,</span><span class="w">  </span><span class="o">*</span><span class="p">(</span><span class="n">My86Flags</span><span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="p">.</span><span class="n">flags</span><span class="p">);</span>
<span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="tags">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">Tags</a><a class="headerlink" href="#tags" title="Link to this heading">¶</a></h3>
<p>The YAML syntax supports tags as a way to specify the type of a node before
it is parsed. This allows dynamic types of nodes.  But the YAML I/O model uses
static typing, so there are limits to how you can use tags with the YAML I/O
model. Recently, we added support to YAML I/O for checking/setting the optional
tag on a map. Using this functionality it is even possible to support different
mappings, as long as they are convertible.</p>
<p>To check a tag, inside your <code class="docutils literal notranslate"><span class="pre">mapping()</span></code> method you can use <code class="docutils literal notranslate"><span class="pre">io.mapTag()</span></code> to specify
what the tag should be.  This will also add that tag when writing YAML.</p>
</section>
<section id="validation">
<h3><a class="toc-backref" href="#id18" role="doc-backlink">Validation</a><a class="headerlink" href="#validation" title="Link to this heading">¶</a></h3>
<p>Sometimes in a YAML map, each key/value pair is valid, but the combination is
not.  This is similar to something having no syntax errors, but still having
semantic errors.  To support semantic-level checking, YAML I/O allows
an optional <code class="docutils literal notranslate"><span class="pre">validate()</span></code> method in a MappingTraits template specialization.</p>
<p>When parsing YAML, the <code class="docutils literal notranslate"><span class="pre">validate()</span></code> method is called <em>after</em> all key/values in
the map have been processed. Any error message returned by the <code class="docutils literal notranslate"><span class="pre">validate()</span></code>
method during input will be printed just like a syntax error would be printed.
When writing YAML, the <code class="docutils literal notranslate"><span class="pre">validate()</span></code> method is called <em>before</em> the YAML
key/values  are written.  Any error during output will trigger an <code class="docutils literal notranslate"><span class="pre">assert()</span></code>
because it is a programming error to have invalid struct values.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">MappingTraits</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">IO</span><span class="p">;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Stuff</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MappingTraits</span><span class="o">&lt;</span><span class="n">Stuff</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">mapping</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">Stuff</span><span class="w"> </span><span class="o">&amp;</span><span class="n">stuff</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">validate</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">Stuff</span><span class="w"> </span><span class="o">&amp;</span><span class="n">stuff</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Look at all fields in &#39;stuff&#39; and if there</span>
<span class="w">    </span><span class="c1">// are any bad values return a string describing</span>
<span class="w">    </span><span class="c1">// the error.  Otherwise return an empty string.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{};</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="flow-mapping">
<h3><a class="toc-backref" href="#id19" role="doc-backlink">Flow Mapping</a><a class="headerlink" href="#flow-mapping" title="Link to this heading">¶</a></h3>
<p>A YAML “flow mapping” is a mapping that uses the inline notation
(e.g { x: 1, y: 0 } ) when written to YAML. To specify that a type should be
written in YAML using flow mapping, your MappingTraits specialization should
add <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">constexpr</span> <span class="pre">bool</span> <span class="pre">flow</span> <span class="pre">=</span> <span class="pre">true;</span></code>. For instance:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">MappingTraits</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">IO</span><span class="p">;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Stuff</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MappingTraits</span><span class="o">&lt;</span><span class="n">Stuff</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">mapping</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">Stuff</span><span class="w"> </span><span class="o">&amp;</span><span class="n">stuff</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">flow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Flow mappings are subject to line wrapping according to the <code class="docutils literal notranslate"><span class="pre">Output</span></code> object
configuration.</p>
</section>
</section>
<section id="sequence">
<h2><a class="toc-backref" href="#id20" role="doc-backlink">Sequence</a><a class="headerlink" href="#sequence" title="Link to this heading">¶</a></h2>
<p>To be translated to or from a YAML sequence for your type <code class="docutils literal notranslate"><span class="pre">T</span></code>, you must specialize
<code class="docutils literal notranslate"><span class="pre">llvm::yaml::SequenceTraits</span></code> on <code class="docutils literal notranslate"><span class="pre">T</span></code> and implement two methods:
<code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size(IO</span> <span class="pre">&amp;io,</span> <span class="pre">T&amp;)</span></code> and
<code class="docutils literal notranslate"><span class="pre">T::value_type&amp;</span> <span class="pre">element(IO</span> <span class="pre">&amp;io,</span> <span class="pre">T&amp;,</span> <span class="pre">size_t</span> <span class="pre">indx)</span></code>.  For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">SequenceTraits</span><span class="o">&lt;</span><span class="n">MySeq</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">size</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">MySeq</span><span class="w"> </span><span class="o">&amp;</span><span class="n">list</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">MySeqEl</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">element</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">MySeq</span><span class="w"> </span><span class="o">&amp;</span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">size()</span></code> method returns how many elements are currently in your sequence.
The <code class="docutils literal notranslate"><span class="pre">element()</span></code> method returns a reference to the i’th element in the sequence.
When parsing YAML, the <code class="docutils literal notranslate"><span class="pre">element()</span></code> method may be called with an index one bigger
than the current size.  Your <code class="docutils literal notranslate"><span class="pre">element()</span></code> method should allocate space for one
more element (using default constructor if element is a C++ object) and return
a reference to that new allocated space.</p>
<section id="flow-sequence">
<h3><a class="toc-backref" href="#id21" role="doc-backlink">Flow Sequence</a><a class="headerlink" href="#flow-sequence" title="Link to this heading">¶</a></h3>
<p>A YAML “flow sequence” is a sequence that when written to YAML it uses the
inline notation (e.g., <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">foo,</span> <span class="pre">bar</span> <span class="pre">]</span></code> ).  To specify that a sequence type should
be written in YAML as a flow sequence, your SequenceTraits specialization should
add <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">constexpr</span> <span class="pre">bool</span> <span class="pre">flow</span> <span class="pre">=</span> <span class="pre">true;</span></code>.  For instance:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">SequenceTraits</span><span class="o">&lt;</span><span class="n">MyList</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">size</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">MyList</span><span class="w"> </span><span class="o">&amp;</span><span class="n">list</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">MyListEl</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">element</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">MyList</span><span class="w"> </span><span class="o">&amp;</span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// The existence of this member causes YAML I/O to use a flow sequence</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">flow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>With the above, if you used <code class="docutils literal notranslate"><span class="pre">MyList</span></code> as the data type in your native data
structures, then when converted to YAML, a flow sequence of integers
will be used (e.g., <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">10,</span> <span class="pre">-3,</span> <span class="pre">4</span> <span class="pre">]</span></code>).</p>
<p>Flow sequences are subject to line wrapping according to the Output object
configuration.</p>
</section>
<section id="utility-macros">
<h3><a class="toc-backref" href="#id22" role="doc-backlink">Utility Macros</a><a class="headerlink" href="#utility-macros" title="Link to this heading">¶</a></h3>
<p>Since a common source of sequences is <code class="docutils literal notranslate"><span class="pre">std::vector&lt;&gt;</span></code>, YAML I/O provides macros:
<code class="docutils literal notranslate"><span class="pre">LLVM_YAML_IS_SEQUENCE_VECTOR()</span></code> and <code class="docutils literal notranslate"><span class="pre">LLVM_YAML_IS_FLOW_SEQUENCE_VECTOR()</span></code> which
can be used to easily specify <code class="docutils literal notranslate"><span class="pre">SequenceTraits&lt;&gt;</span></code> on a <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> type.  YAML
I/O does not partial specialize <code class="docutils literal notranslate"><span class="pre">SequenceTraits</span></code> on <code class="docutils literal notranslate"><span class="pre">std::vector&lt;&gt;</span></code> because that
would force all vectors to be sequences.  An example use of the macros:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MyType1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MyType2</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">LLVM_YAML_IS_SEQUENCE_VECTOR</span><span class="p">(</span><span class="n">MyType1</span><span class="p">)</span>
<span class="n">LLVM_YAML_IS_FLOW_SEQUENCE_VECTOR</span><span class="p">(</span><span class="n">MyType2</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="document-list">
<h2><a class="toc-backref" href="#id23" role="doc-backlink">Document List</a><a class="headerlink" href="#document-list" title="Link to this heading">¶</a></h2>
<p>YAML allows you to define multiple “documents” in a single YAML file.  Each
new document starts with a left aligned <code class="docutils literal notranslate"><span class="pre">---</span></code> token.  The end of all documents
is denoted with a left aligned <code class="docutils literal notranslate"><span class="pre">...</span></code> token.  Many users of YAML will never
have need for multiple documents.  The top level node in their YAML schema
will be a mapping or sequence. For those cases, the following is not needed.
But for cases where you do want multiple documents, you can specify a
trait for you document list type.  The trait has the same methods as
<code class="docutils literal notranslate"><span class="pre">SequenceTraits</span></code> but is named <code class="docutils literal notranslate"><span class="pre">DocumentListTraits</span></code>.  For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">DocumentListTraits</span><span class="o">&lt;</span><span class="n">MyDocList</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">size</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">MyDocList</span><span class="w"> </span><span class="o">&amp;</span><span class="n">list</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">MyDocType</span><span class="w"> </span><span class="nf">element</span><span class="p">(</span><span class="n">IO</span><span class="w"> </span><span class="o">&amp;</span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">MyDocList</span><span class="w"> </span><span class="o">&amp;</span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="user-context-data">
<h2><a class="toc-backref" href="#id24" role="doc-backlink">User Context Data</a><a class="headerlink" href="#user-context-data" title="Link to this heading">¶</a></h2>
<p>When an <code class="docutils literal notranslate"><span class="pre">llvm::yaml::Input</span></code> or <code class="docutils literal notranslate"><span class="pre">llvm::yaml::Output</span></code> object is created, its
constructor takes an optional “context” parameter.  This is a pointer to
whatever state information you might need.</p>
<p>For instance, in a previous example we showed how the conversion type for a
flags field could be determined at runtime based on the value of another field
in the mapping. But what if an inner mapping needs to know some field value
of an outer mapping?  That is where the “context” parameter comes in. You
can set values in the context in the outer map’s <code class="docutils literal notranslate"><span class="pre">mapping()</span></code> method and
retrieve those values in the inner map’s <code class="docutils literal notranslate"><span class="pre">mapping()</span></code> method.</p>
<p>The context value is just a <code class="docutils literal notranslate"><span class="pre">void*</span></code>.  All your traits which use the context
and operate on your native data types, need to agree what the context value
actually is.  It could be a pointer to an object or struct which your various
traits use to share context sensitive information.</p>
</section>
<section id="output">
<h2><a class="toc-backref" href="#id25" role="doc-backlink">Output</a><a class="headerlink" href="#output" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">llvm::yaml::Output</span></code> class is used to generate a YAML document from your
in-memory data structures, using traits defined on your data types.
To instantiate an <code class="docutils literal notranslate"><span class="pre">Output</span></code> object you need an <code class="docutils literal notranslate"><span class="pre">llvm::raw_ostream</span></code>, an optional
context pointer and an optional wrapping column:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Output</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">IO</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">Output</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">raw_ostream</span><span class="w"> </span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">WrapColumn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">70</span><span class="p">);</span>
</pre></div>
</div>
<p>Once you have an <code class="docutils literal notranslate"><span class="pre">Output</span></code> object, you can use the C++ stream operator on it
to write your native data as YAML. One thing to recall is that a YAML file
can contain multiple “documents”.  If the top level data structure you are
streaming as YAML is a mapping, scalar, or sequence, then <code class="docutils literal notranslate"><span class="pre">Output</span></code> assumes you
are generating one document and wraps the mapping output
with <code class="docutils literal notranslate"><span class="pre">---</span></code> and trailing <code class="docutils literal notranslate"><span class="pre">...</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">WrapColumn</span></code> parameter will cause the flow mappings and sequences to
line-wrap when they go over the supplied column. Pass 0 to completely
suppress the wrapping.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">Output</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">dumpMyMapDoc</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyMapType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">info</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Output</span><span class="w"> </span><span class="n">yout</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">outs</span><span class="p">());</span>
<span class="w">  </span><span class="n">yout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">info</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above could produce output like:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nn">---</span>
<span class="nt">name</span><span class="p">:</span><span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">Tom</span>
<span class="nt">hat-size</span><span class="p">:</span><span class="w">  </span><span class="l l-Scalar l-Scalar-Plain">7</span>
<span class="nn">...</span>
</pre></div>
</div>
<p>On the other hand, if the top level data structure you are streaming as YAML
has a <code class="docutils literal notranslate"><span class="pre">DocumentListTraits</span></code> specialization, then Output walks through each element
of your DocumentList and generates a <code class="docutils literal notranslate"><span class="pre">---</span></code> before the start of each element
and ends with a <code class="docutils literal notranslate"><span class="pre">...</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">Output</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">dumpMyMapDoc</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyDocListType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">docList</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Output</span><span class="w"> </span><span class="n">yout</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">outs</span><span class="p">());</span>
<span class="w">  </span><span class="n">yout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">docList</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above could produce output like:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nn">---</span>
<span class="nt">name</span><span class="p">:</span><span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">Tom</span>
<span class="nt">hat-size</span><span class="p">:</span><span class="w">  </span><span class="l l-Scalar l-Scalar-Plain">7</span>
<span class="nn">---</span>
<span class="nt">name</span><span class="p">:</span><span class="w">      </span><span class="l l-Scalar l-Scalar-Plain">Tom</span>
<span class="nt">shoe-size</span><span class="p">:</span><span class="w">  </span><span class="l l-Scalar l-Scalar-Plain">11</span>
<span class="nn">...</span>
</pre></div>
</div>
</section>
<section id="input">
<h2><a class="toc-backref" href="#id26" role="doc-backlink">Input</a><a class="headerlink" href="#input" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">llvm::yaml::Input</span></code> class is used to parse YAML document(s) into your native
data structures. To instantiate an <code class="docutils literal notranslate"><span class="pre">Input</span></code>
object you need a <code class="docutils literal notranslate"><span class="pre">StringRef</span></code> to the entire YAML file, and optionally a context
pointer:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Input</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">IO</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">Input</span><span class="p">(</span><span class="n">StringRef</span><span class="w"> </span><span class="n">inputContent</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="o">=</span><span class="nb">NULL</span><span class="p">);</span>
</pre></div>
</div>
<p>Once you have an <code class="docutils literal notranslate"><span class="pre">Input</span></code> object, you can use the C++ stream operator to read
the document(s).  If you expect there might be multiple YAML documents in
one file, you’ll need to specialize <code class="docutils literal notranslate"><span class="pre">DocumentListTraits</span></code> on a list of your
document type and stream in that document list type.  Otherwise, you can
just stream in the document type.  Also, you can check if there was
any syntax errors in the YAML by calling the <code class="docutils literal notranslate"><span class="pre">error()</span></code> method on the <code class="docutils literal notranslate"><span class="pre">Input</span></code>
object.  For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Reading a single document</span>
<span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">Input</span><span class="p">;</span>

<span class="n">Input</span><span class="w"> </span><span class="nf">yin</span><span class="p">(</span><span class="n">mb</span><span class="p">.</span><span class="n">getBuffer</span><span class="p">());</span>

<span class="c1">// Parse the YAML file</span>
<span class="n">MyDocType</span><span class="w"> </span><span class="n">theDoc</span><span class="p">;</span>
<span class="n">yin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">theDoc</span><span class="p">;</span>

<span class="c1">// Check for error</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">yin</span><span class="p">.</span><span class="n">error</span><span class="p">()</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="k">return</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Reading multiple documents in one file</span>
<span class="k">using</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">yaml</span><span class="o">::</span><span class="n">Input</span><span class="p">;</span>

<span class="n">LLVM_YAML_IS_DOCUMENT_LIST_VECTOR</span><span class="p">(</span><span class="n">MyDocType</span><span class="p">)</span>

<span class="n">Input</span><span class="w"> </span><span class="n">yin</span><span class="p">(</span><span class="n">mb</span><span class="p">.</span><span class="n">getBuffer</span><span class="p">());</span>

<span class="c1">// Parse the YAML file</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MyDocType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">theDocList</span><span class="p">;</span>
<span class="n">yin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">theDocList</span><span class="p">;</span>

<span class="c1">// Check for error</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">yin</span><span class="p">.</span><span class="n">error</span><span class="p">()</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="k">return</span><span class="p">;</span>
</pre></div>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="UserGuides.html" title="User Guides"
             >next</a> |</li>
        <li class="right" >
          <a href="XRayFDRFormat.html" title="XRay Flight Data Recorder Trace Format"
             >previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="Reference.html" >Reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">YAML I/O</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2003-2026, LLVM Project.
      Last updated on 2026-01-27.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>