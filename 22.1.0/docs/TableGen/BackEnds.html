
<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>TableGen BackEnds &#8212; LLVM 22.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="../_static/llvm-theme.css?v=96924833" />
    <script src="../_static/documentation_options.js?v=19ab019f"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="1 TableGen Backend Developer’s Guide" href="BackGuide.html" />
    <link rel="prev" title="TableGen Overview" href="index.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="../index.html">
    <img src="../_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="BackGuide.html" title="1 TableGen Backend Developer’s Guide"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="TableGen Overview"
             accesskey="P">previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="../index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="../UserGuides.html" >User Guides</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">TableGen Overview</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">TableGen BackEnds</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="https://llvm.org/docs/UserGuides.html">User Guides</a></li>
    <li><a href="https://llvm.org/docs/Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/Contributing.html">Contributing to LLVM</a></li>
    <li><a href="https://llvm.org/docs/HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#discord">Discord</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/FAQ.html">FAQ</a></li>
    <li><a href="https://llvm.org/docs/Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project/">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/TableGen/BackEnds.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="tablegen-backends">
<h1>TableGen BackEnds<a class="headerlink" href="#tablegen-backends" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id1">Introduction</a></p></li>
<li><p><a class="reference internal" href="#llvm-backends" id="id2">LLVM BackEnds</a></p>
<ul>
<li><p><a class="reference internal" href="#codeemitter" id="id3">CodeEmitter</a></p></li>
<li><p><a class="reference internal" href="#registerinfo" id="id4">RegisterInfo</a></p></li>
<li><p><a class="reference internal" href="#instrinfo" id="id5">InstrInfo</a></p></li>
<li><p><a class="reference internal" href="#asmwriter" id="id6">AsmWriter</a></p></li>
<li><p><a class="reference internal" href="#asmmatcher" id="id7">AsmMatcher</a></p></li>
<li><p><a class="reference internal" href="#disassembler" id="id8">Disassembler</a></p></li>
<li><p><a class="reference internal" href="#pseudolowering" id="id9">PseudoLowering</a></p></li>
<li><p><a class="reference internal" href="#callingconv" id="id10">CallingConv</a></p></li>
<li><p><a class="reference internal" href="#dagisel" id="id11">DAGISel</a></p></li>
<li><p><a class="reference internal" href="#dfapacketizer" id="id12">DFAPacketizer</a></p></li>
<li><p><a class="reference internal" href="#fastisel" id="id13">FastISel</a></p></li>
<li><p><a class="reference internal" href="#subtarget" id="id14">Subtarget</a></p></li>
<li><p><a class="reference internal" href="#intrinsic" id="id15">Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#optparserdefs" id="id16">OptParserDefs</a></p></li>
<li><p><a class="reference internal" href="#searchabletables" id="id17">SearchableTables</a></p></li>
<li><p><a class="reference internal" href="#ctags" id="id18">CTags</a></p></li>
<li><p><a class="reference internal" href="#x86evex2vex" id="id19">X86EVEX2VEX</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#clang-backends" id="id20">Clang BackEnds</a></p>
<ul>
<li><p><a class="reference internal" href="#clangattrclasses" id="id21">ClangAttrClasses</a></p></li>
<li><p><a class="reference internal" href="#clangattrparserstringswitches" id="id22">ClangAttrParserStringSwitches</a></p></li>
<li><p><a class="reference internal" href="#clangattrimpl" id="id23">ClangAttrImpl</a></p></li>
<li><p><a class="reference internal" href="#clangattrlist" id="id24">ClangAttrList</a></p></li>
<li><p><a class="reference internal" href="#clangattrpchread" id="id25">ClangAttrPCHRead</a></p></li>
<li><p><a class="reference internal" href="#clangattrpchwrite" id="id26">ClangAttrPCHWrite</a></p></li>
<li><p><a class="reference internal" href="#clangattrspellings" id="id27">ClangAttrSpellings</a></p></li>
<li><p><a class="reference internal" href="#clangattrspellinglistindex" id="id28">ClangAttrSpellingListIndex</a></p></li>
<li><p><a class="reference internal" href="#clangattrvisitor" id="id29">ClangAttrVisitor</a></p></li>
<li><p><a class="reference internal" href="#clangattrtemplateinstantiate" id="id30">ClangAttrTemplateInstantiate</a></p></li>
<li><p><a class="reference internal" href="#clangattrparsedattrlist" id="id31">ClangAttrParsedAttrList</a></p></li>
<li><p><a class="reference internal" href="#clangattrparsedattrimpl" id="id32">ClangAttrParsedAttrImpl</a></p></li>
<li><p><a class="reference internal" href="#clangattrparsedattrkinds" id="id33">ClangAttrParsedAttrKinds</a></p></li>
<li><p><a class="reference internal" href="#clangattristypedependent" id="id34">ClangAttrIsTypeDependent</a></p></li>
<li><p><a class="reference internal" href="#clangattrdump" id="id35">ClangAttrDump</a></p></li>
<li><p><a class="reference internal" href="#clangdiagsdefs" id="id36">ClangDiagsDefs</a></p></li>
<li><p><a class="reference internal" href="#clangdiaggroups" id="id37">ClangDiagGroups</a></p></li>
<li><p><a class="reference internal" href="#clangdiagsindexname" id="id38">ClangDiagsIndexName</a></p></li>
<li><p><a class="reference internal" href="#clangcommentnodes" id="id39">ClangCommentNodes</a></p></li>
<li><p><a class="reference internal" href="#clangdeclnodes" id="id40">ClangDeclNodes</a></p></li>
<li><p><a class="reference internal" href="#clangstmtnodes" id="id41">ClangStmtNodes</a></p></li>
<li><p><a class="reference internal" href="#clangsacheckers" id="id42">ClangSACheckers</a></p></li>
<li><p><a class="reference internal" href="#clangcommenthtmltags" id="id43">ClangCommentHTMLTags</a></p></li>
<li><p><a class="reference internal" href="#clangcommenthtmltagsproperties" id="id44">ClangCommentHTMLTagsProperties</a></p></li>
<li><p><a class="reference internal" href="#clangcommenthtmlnamedcharacterreferences" id="id45">ClangCommentHTMLNamedCharacterReferences</a></p></li>
<li><p><a class="reference internal" href="#clangcommentcommandinfo" id="id46">ClangCommentCommandInfo</a></p></li>
<li><p><a class="reference internal" href="#clangcommentcommandlist" id="id47">ClangCommentCommandList</a></p></li>
<li><p><a class="reference internal" href="#armneon" id="id48">ArmNeon</a></p></li>
<li><p><a class="reference internal" href="#armneonsema" id="id49">ArmNeonSema</a></p></li>
<li><p><a class="reference internal" href="#armneontest" id="id50">ArmNeonTest</a></p></li>
<li><p><a class="reference internal" href="#attrdocs" id="id51">AttrDocs</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#general-backends" id="id52">General BackEnds</a></p>
<ul>
<li><p><a class="reference internal" href="#print-records" id="id53">Print Records</a></p></li>
<li><p><a class="reference internal" href="#print-detailed-records" id="id54">Print Detailed Records</a></p></li>
<li><p><a class="reference internal" href="#json-reference" id="id55">JSON Reference</a></p></li>
<li><p><a class="reference internal" href="#searchabletables-reference" id="id56">SearchableTables Reference</a></p>
<ul>
<li><p><a class="reference internal" href="#generic-enumerated-types" id="id57">Generic Enumerated Types</a></p></li>
<li><p><a class="reference internal" href="#generic-tables" id="id58">Generic Tables</a></p></li>
<li><p><a class="reference internal" href="#search-indexes" id="id59">Search Indexes</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>TableGen backends are at the core of TableGen’s functionality. The source
files provide the classes and records that are parsed and end up as a
collection of record instances, but it’s up to the backend to interpret and
print the records in a way that is meaningful to the user (normally a C++
include file or a textual list of warnings, options, and error messages).</p>
<p>TableGen is used by both LLVM, Clang, and MLIR with very different goals.
LLVM uses it as a way to automate the generation of massive amounts of
information regarding instructions, schedules, cores, and architecture
features. Some backends generate output that is consumed by more than one
source file, so they need to be created in a way that makes it is easy for
preprocessor tricks to be used. Some backends can also print C++ code
structures, so that they can be directly included as-is.</p>
<p>Clang, on the other hand, uses it mainly for diagnostic messages (errors,
warnings, tips) and attributes, so more on the textual end of the scale.</p>
<p>MLIR uses TableGen to define operations, operation dialects, and operation
traits.</p>
<p>See the <a class="reference internal" href="ProgRef.html"><span class="doc">TableGen Programmer’s Reference</span></a> for an in-depth
description of TableGen, and the <a class="reference internal" href="BackGuide.html"><span class="doc">TableGen Backend Developer’s Guide</span></a> for a guide to writing a new backend.</p>
</section>
<section id="llvm-backends">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">LLVM BackEnds</a><a class="headerlink" href="#llvm-backends" title="Link to this heading">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This portion is incomplete. Each section below needs three subsections:
description of its purpose with a list of users, output generated from
generic input, and finally why it needed a new backend (in case there’s
something similar).</p>
</div>
<p>Overall, each backend will take the same TableGen file type and transform into
similar output for different targets/uses. There is an implicit contract between
the TableGen files, the back-ends and their users.</p>
<p>For instance, a global contract is that each back-end produces macro-guarded
sections. Based on whether the file is included by a header or a source file,
or even in which context of each file the include is being used, you have
to define a macro just before including it, to get the right output:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define GET_REGINFO_TARGET_DESC</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ARMGenRegisterInfo.inc&quot;</span>
</pre></div>
</div>
<p>And just part of the generated file would be included. This is useful if
you need the same information in multiple formats (instantiation, initialization,
getter/setter functions, etc) from the same source TableGen file without having
to re-compile the TableGen file multiple times.</p>
<p>Sometimes, multiple macros might be defined before the same include file to
output multiple blocks:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define GET_REGISTER_MATCHER</span>
<span class="cp">#define GET_SUBTARGET_FEATURE_NAME</span>
<span class="cp">#define GET_MATCHER_IMPLEMENTATION</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ARMGenAsmMatcher.inc&quot;</span>
</pre></div>
</div>
<p>The macros will be undef’d automatically as they’re used, in the include file.</p>
<p>On all LLVM back-ends, the <code class="docutils literal notranslate"><span class="pre">llvm-tblgen</span></code> binary will be executed on the root
TableGen file <code class="docutils literal notranslate"><span class="pre">&lt;Target&gt;.td</span></code>, which should include all others. This guarantees
that all information needed is accessible, and that no duplication is needed
in the TableGen files.</p>
<section id="codeemitter">
<h3><a class="toc-backref" href="#id3" role="doc-backlink">CodeEmitter</a><a class="headerlink" href="#codeemitter" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: <code class="docutils literal notranslate"><span class="pre">CodeEmitterGen</span></code> uses the descriptions of instructions and their fields to
construct an automated code emitter: a function that, given a <code class="docutils literal notranslate"><span class="pre">MachineInstr</span></code>,
returns the (currently, 32-bit unsigned) value of the instruction.</p>
<p><strong>Output</strong>: C++ code, implementing the target’s CodeEmitter
class by overriding the virtual functions as <code class="docutils literal notranslate"><span class="pre">&lt;Target&gt;CodeEmitter::function()</span></code>.</p>
<p><strong>Usage</strong>: Used to include directly at the end of <code class="docutils literal notranslate"><span class="pre">&lt;Target&gt;MCCodeEmitter.cpp</span></code>.</p>
</section>
<section id="registerinfo">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">RegisterInfo</a><a class="headerlink" href="#registerinfo" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: This tablegen backend is responsible for emitting a description of a target
register file for a code generator.  It uses instances of the Register,
RegisterAliases, and RegisterClass classes to gather this information.</p>
<p><strong>Output</strong>: C++ code with enums and structures representing the register mappings,
properties, masks, etc.</p>
<p><strong>Usage</strong>: Both on <code class="docutils literal notranslate"><span class="pre">&lt;Target&gt;BaseRegisterInfo</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;Target&gt;MCTargetDesc</span></code> (headers
and source files) with macros defining in which they are for declaration vs.
initialization issues.</p>
</section>
<section id="instrinfo">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">InstrInfo</a><a class="headerlink" href="#instrinfo" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: This tablegen backend is responsible for emitting a description of the target
instruction set for the code generator. (what are the differences from CodeEmitter?)</p>
<p><strong>Output</strong>: C++ code with enums and structures representing the instruction mappings,
properties, masks, etc.</p>
<p><strong>Usage</strong>: Both on <code class="docutils literal notranslate"><span class="pre">&lt;Target&gt;BaseInstrInfo</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;Target&gt;MCTargetDesc</span></code> (headers
and source files) with macros defining in which they are for declaration vs.
initialization issues.</p>
</section>
<section id="asmwriter">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">AsmWriter</a><a class="headerlink" href="#asmwriter" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Emits an assembly printer for the current target.</p>
<p><strong>Output</strong>: Implementation of <code class="docutils literal notranslate"><span class="pre">&lt;Target&gt;InstPrinter::printInstruction()</span></code>, among
other things.</p>
<p><strong>Usage</strong>: Included directly into <code class="docutils literal notranslate"><span class="pre">InstPrinter/&lt;Target&gt;InstPrinter.cpp</span></code>.</p>
</section>
<section id="asmmatcher">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">AsmMatcher</a><a class="headerlink" href="#asmmatcher" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Emits a target specifier matcher for
converting parsed assembly operands in the <code class="docutils literal notranslate"><span class="pre">MCInst</span></code> structures. It also
emits a matcher for custom operand parsing. Extensive documentation is
written on the <code class="docutils literal notranslate"><span class="pre">AsmMatcherEmitter.cpp</span></code> file.</p>
<p><strong>Output</strong>: Assembler parsers’ matcher functions, declarations, etc.</p>
<p><strong>Usage</strong>: Used in back-ends’ <code class="docutils literal notranslate"><span class="pre">AsmParser/&lt;Target&gt;AsmParser.cpp</span></code> for
building the AsmParser class.</p>
</section>
<section id="disassembler">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Disassembler</a><a class="headerlink" href="#disassembler" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Contains disassembler table emitters for various
architectures. Extensive documentation is written on the
<code class="docutils literal notranslate"><span class="pre">DisassemblerEmitter.cpp</span></code> file.</p>
<p><strong>Output</strong>: Decoding tables, static decoding functions, etc.</p>
<p><strong>Usage</strong>: Directly included in <code class="docutils literal notranslate"><span class="pre">Disassembler/&lt;Target&gt;Disassembler.cpp</span></code>
to cater for all default decodings, after all hand-made ones.</p>
</section>
<section id="pseudolowering">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">PseudoLowering</a><a class="headerlink" href="#pseudolowering" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Generate pseudo instruction lowering.</p>
<p><strong>Output</strong>: Implements <code class="docutils literal notranslate"><span class="pre">&lt;Target&gt;AsmPrinter::emitPseudoExpansionLowering()</span></code>.</p>
<p><strong>Usage</strong>: Included directly into <code class="docutils literal notranslate"><span class="pre">&lt;Target&gt;AsmPrinter.cpp</span></code>.</p>
</section>
<section id="callingconv">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">CallingConv</a><a class="headerlink" href="#callingconv" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Responsible for emitting descriptions of the calling
conventions supported by this target.</p>
<p><strong>Output</strong>: Implement static functions to deal with calling conventions
chained by matching styles, returning <code class="docutils literal notranslate"><span class="pre">false</span></code> on no match.</p>
<p><strong>Usage</strong>: Used in ISelLowering and FastIsel as function pointers to
implementation returned by a CC selection function.</p>
</section>
<section id="dagisel">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">DAGISel</a><a class="headerlink" href="#dagisel" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Generate a DAG instruction selector.</p>
<p><strong>Output</strong>: Creates huge functions for automating DAG selection.</p>
<p><strong>Usage</strong>: Included in <code class="docutils literal notranslate"><span class="pre">&lt;Target&gt;ISelDAGToDAG.cpp</span></code> inside the target’s
implementation of <code class="docutils literal notranslate"><span class="pre">SelectionDAGISel</span></code>.</p>
</section>
<section id="dfapacketizer">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">DFAPacketizer</a><a class="headerlink" href="#dfapacketizer" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: This class parses the Schedule.td file and produces an API that
can be used to reason about whether an instruction can be added to a packet
on a VLIW architecture. The class internally generates a deterministic finite
automaton (DFA) that models all possible mappings of machine instructions
to functional units as instructions are added to a packet.</p>
<p><strong>Output</strong>: Scheduling tables for GPU back-ends (Hexagon, AMD).</p>
<p><strong>Usage</strong>: Included directly on <code class="docutils literal notranslate"><span class="pre">&lt;Target&gt;InstrInfo.cpp</span></code>.</p>
</section>
<section id="fastisel">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">FastISel</a><a class="headerlink" href="#fastisel" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: This tablegen backend emits code for use by the “fast”
instruction selection algorithm. See the comments at the top of
<code class="docutils literal notranslate"><span class="pre">lib/CodeGen/SelectionDAG/FastISel.cpp</span></code> for background. This file
scans through the target’s tablegen instruction-info files
and extracts instructions with obvious-looking patterns, and it emits
code to look up these instructions by type and operator.</p>
<p><strong>Output</strong>: Generates <code class="docutils literal notranslate"><span class="pre">Predicate</span></code> and <code class="docutils literal notranslate"><span class="pre">FastEmit</span></code> methods.</p>
<p><strong>Usage</strong>: Implements private methods of the targets’ implementation
of <code class="docutils literal notranslate"><span class="pre">FastISel</span></code> class.</p>
</section>
<section id="subtarget">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Subtarget</a><a class="headerlink" href="#subtarget" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Generate subtarget enumerations.</p>
<p><strong>Output</strong>: Enums, globals, local tables for sub-target information.</p>
<p><strong>Usage</strong>: Populates <code class="docutils literal notranslate"><span class="pre">&lt;Target&gt;Subtarget</span></code> and
<code class="docutils literal notranslate"><span class="pre">MCTargetDesc/&lt;Target&gt;MCTargetDesc</span></code> files (both headers and source).</p>
</section>
<section id="intrinsic">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">Intrinsic</a><a class="headerlink" href="#intrinsic" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Generate (target) intrinsic information.</p>
</section>
<section id="optparserdefs">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">OptParserDefs</a><a class="headerlink" href="#optparserdefs" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Print enum values for a class.</p>
</section>
<section id="searchabletables">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">SearchableTables</a><a class="headerlink" href="#searchabletables" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Generate custom searchable tables.</p>
<p><strong>Output</strong>: Enums, global tables, and lookup helper functions.</p>
<p><strong>Usage</strong>: This backend allows generating free-form, target-specific tables
from TableGen records. The ARM and AArch64 targets use this backend to generate
tables of system registers; the AMDGPU target uses it to generate meta-data
about complex image and memory buffer instructions.</p>
<p>See <a class="reference internal" href="#searchabletables-reference">SearchableTables Reference</a> for a detailed description.</p>
</section>
<section id="ctags">
<h3><a class="toc-backref" href="#id18" role="doc-backlink">CTags</a><a class="headerlink" href="#ctags" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: This tablegen backend emits an index of definitions in ctags(1)
format. A helper script, utils/TableGen/tdtags, provides an easier-to-use
interface; run ‘tdtags -H’ for documentation.</p>
</section>
<section id="x86evex2vex">
<h3><a class="toc-backref" href="#id19" role="doc-backlink">X86EVEX2VEX</a><a class="headerlink" href="#x86evex2vex" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: This X86 specific tablegen backend emits tables that map EVEX
encoded instructions to their VEX encoded identical instruction.</p>
</section>
</section>
<section id="clang-backends">
<h2><a class="toc-backref" href="#id20" role="doc-backlink">Clang BackEnds</a><a class="headerlink" href="#clang-backends" title="Link to this heading">¶</a></h2>
<section id="clangattrclasses">
<h3><a class="toc-backref" href="#id21" role="doc-backlink">ClangAttrClasses</a><a class="headerlink" href="#clangattrclasses" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Creates Attrs.inc, which contains semantic attribute class
declarations for any attribute in <code class="docutils literal notranslate"><span class="pre">Attr.td</span></code> that has not set <code class="docutils literal notranslate"><span class="pre">ASTNode</span> <span class="pre">=</span> <span class="pre">0</span></code>.
This file is included as part of <code class="docutils literal notranslate"><span class="pre">Attr.h</span></code>.</p>
</section>
<section id="clangattrparserstringswitches">
<h3><a class="toc-backref" href="#id22" role="doc-backlink">ClangAttrParserStringSwitches</a><a class="headerlink" href="#clangattrparserstringswitches" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Creates <code class="docutils literal notranslate"><span class="pre">AttrParserStringSwitches.inc</span></code>, which contains
<code class="docutils literal notranslate"><span class="pre">StringSwitch::Case</span></code> statements for parser-related string switches. Each switch
is given its own macro (such as <code class="docutils literal notranslate"><span class="pre">CLANG_ATTR_ARG_CONTEXT_LIST</span></code>, or
<code class="docutils literal notranslate"><span class="pre">CLANG_ATTR_IDENTIFIER_ARG_LIST</span></code>), which is expected to be defined before
including <code class="docutils literal notranslate"><span class="pre">AttrParserStringSwitches.inc</span></code>, and undefined after.</p>
</section>
<section id="clangattrimpl">
<h3><a class="toc-backref" href="#id23" role="doc-backlink">ClangAttrImpl</a><a class="headerlink" href="#clangattrimpl" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Creates <code class="docutils literal notranslate"><span class="pre">AttrImpl.inc</span></code>, which contains semantic attribute class
definitions for any attribute in <code class="docutils literal notranslate"><span class="pre">Attr.td</span></code> that has not set <code class="docutils literal notranslate"><span class="pre">ASTNode</span> <span class="pre">=</span> <span class="pre">0</span></code>.
This file is included as part of <code class="docutils literal notranslate"><span class="pre">AttrImpl.cpp</span></code>.</p>
</section>
<section id="clangattrlist">
<h3><a class="toc-backref" href="#id24" role="doc-backlink">ClangAttrList</a><a class="headerlink" href="#clangattrlist" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Creates <code class="docutils literal notranslate"><span class="pre">AttrList.inc</span></code>, which is used when a list of semantic
attribute identifiers is required. For instance, <code class="docutils literal notranslate"><span class="pre">AttrKinds.h</span></code> includes this
file to generate the list of <code class="docutils literal notranslate"><span class="pre">attr::Kind</span></code> enumeration values. This list is
separated out into multiple categories: attributes, inheritable attributes, and
inheritable parameter attributes. This categorization happens automatically
based on information in <code class="docutils literal notranslate"><span class="pre">Attr.td</span></code> and is used to implement the <code class="docutils literal notranslate"><span class="pre">classof</span></code>
functionality required for <code class="docutils literal notranslate"><span class="pre">dyn_cast</span></code> and similar APIs.</p>
</section>
<section id="clangattrpchread">
<h3><a class="toc-backref" href="#id25" role="doc-backlink">ClangAttrPCHRead</a><a class="headerlink" href="#clangattrpchread" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Creates <code class="docutils literal notranslate"><span class="pre">AttrPCHRead.inc</span></code>, which is used to deserialize attributes
in the <code class="docutils literal notranslate"><span class="pre">ASTReader::ReadAttributes</span></code> function.</p>
</section>
<section id="clangattrpchwrite">
<h3><a class="toc-backref" href="#id26" role="doc-backlink">ClangAttrPCHWrite</a><a class="headerlink" href="#clangattrpchwrite" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Creates <code class="docutils literal notranslate"><span class="pre">AttrPCHWrite.inc</span></code>, which is used to serialize attributes in
the <code class="docutils literal notranslate"><span class="pre">ASTWriter::WriteAttributes</span></code> function.</p>
</section>
<section id="clangattrspellings">
<h3><a class="toc-backref" href="#id27" role="doc-backlink">ClangAttrSpellings</a><a class="headerlink" href="#clangattrspellings" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Creates <code class="docutils literal notranslate"><span class="pre">AttrSpellings.inc</span></code>, which is used to implement the
<code class="docutils literal notranslate"><span class="pre">__has_attribute</span></code> feature test macro.</p>
</section>
<section id="clangattrspellinglistindex">
<h3><a class="toc-backref" href="#id28" role="doc-backlink">ClangAttrSpellingListIndex</a><a class="headerlink" href="#clangattrspellinglistindex" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Creates <code class="docutils literal notranslate"><span class="pre">AttrSpellingListIndex.inc</span></code>, which is used to map parsed
attribute spellings (including which syntax or scope was used) to an attribute
spelling list index. These spelling list index values are internal
implementation details exposed via
<code class="docutils literal notranslate"><span class="pre">AttributeList::getAttributeSpellingListIndex</span></code>.</p>
</section>
<section id="clangattrvisitor">
<h3><a class="toc-backref" href="#id29" role="doc-backlink">ClangAttrVisitor</a><a class="headerlink" href="#clangattrvisitor" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Creates <code class="docutils literal notranslate"><span class="pre">AttrVisitor.inc</span></code>, which is used when implementing
recursive AST visitors.</p>
</section>
<section id="clangattrtemplateinstantiate">
<h3><a class="toc-backref" href="#id30" role="doc-backlink">ClangAttrTemplateInstantiate</a><a class="headerlink" href="#clangattrtemplateinstantiate" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Creates <code class="docutils literal notranslate"><span class="pre">AttrTemplateInstantiate.inc</span></code>, which implements the
<code class="docutils literal notranslate"><span class="pre">instantiateTemplateAttribute</span></code> function, used when instantiating a template
that requires an attribute to be cloned.</p>
</section>
<section id="clangattrparsedattrlist">
<h3><a class="toc-backref" href="#id31" role="doc-backlink">ClangAttrParsedAttrList</a><a class="headerlink" href="#clangattrparsedattrlist" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Creates <code class="docutils literal notranslate"><span class="pre">AttrParsedAttrList.inc</span></code>, which is used to generate the
<code class="docutils literal notranslate"><span class="pre">AttributeList::Kind</span></code> parsed attribute enumeration.</p>
</section>
<section id="clangattrparsedattrimpl">
<h3><a class="toc-backref" href="#id32" role="doc-backlink">ClangAttrParsedAttrImpl</a><a class="headerlink" href="#clangattrparsedattrimpl" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Creates <code class="docutils literal notranslate"><span class="pre">AttrParsedAttrImpl.inc</span></code>, which is used by
<code class="docutils literal notranslate"><span class="pre">AttributeList.cpp</span></code> to implement several functions on the <code class="docutils literal notranslate"><span class="pre">AttributeList</span></code>
class. This functionality is implemented via the <code class="docutils literal notranslate"><span class="pre">AttrInfoMap</span> <span class="pre">ParsedAttrInfo</span></code>
array, which contains one element per parsed attribute object.</p>
</section>
<section id="clangattrparsedattrkinds">
<h3><a class="toc-backref" href="#id33" role="doc-backlink">ClangAttrParsedAttrKinds</a><a class="headerlink" href="#clangattrparsedattrkinds" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Creates <code class="docutils literal notranslate"><span class="pre">AttrParsedAttrKinds.inc</span></code>, which is used to implement the
<code class="docutils literal notranslate"><span class="pre">AttributeList::getKind</span></code> function, mapping a string (and syntax) to a parsed
attribute <code class="docutils literal notranslate"><span class="pre">AttributeList::Kind</span></code> enumeration.</p>
</section>
<section id="clangattristypedependent">
<h3><a class="toc-backref" href="#id34" role="doc-backlink">ClangAttrIsTypeDependent</a><a class="headerlink" href="#clangattristypedependent" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Creates <code class="docutils literal notranslate"><span class="pre">AttrIsTypeDependent.inc</span></code>, which is used to implement the
<code class="docutils literal notranslate"><span class="pre">Sema::CheckAttributesOnDeducedType</span></code> function, mapping an attribute kind to a
Sema function if it exists.</p>
</section>
<section id="clangattrdump">
<h3><a class="toc-backref" href="#id35" role="doc-backlink">ClangAttrDump</a><a class="headerlink" href="#clangattrdump" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Creates <code class="docutils literal notranslate"><span class="pre">AttrDump.inc</span></code>, which dumps information about an attribute.
It is used to implement <code class="docutils literal notranslate"><span class="pre">ASTDumper::dumpAttr</span></code>.</p>
</section>
<section id="clangdiagsdefs">
<h3><a class="toc-backref" href="#id36" role="doc-backlink">ClangDiagsDefs</a><a class="headerlink" href="#clangdiagsdefs" title="Link to this heading">¶</a></h3>
<p>Generate Clang diagnostics definitions.</p>
</section>
<section id="clangdiaggroups">
<h3><a class="toc-backref" href="#id37" role="doc-backlink">ClangDiagGroups</a><a class="headerlink" href="#clangdiaggroups" title="Link to this heading">¶</a></h3>
<p>Generate Clang diagnostic groups.</p>
</section>
<section id="clangdiagsindexname">
<h3><a class="toc-backref" href="#id38" role="doc-backlink">ClangDiagsIndexName</a><a class="headerlink" href="#clangdiagsindexname" title="Link to this heading">¶</a></h3>
<p>Generate Clang diagnostic name index.</p>
</section>
<section id="clangcommentnodes">
<h3><a class="toc-backref" href="#id39" role="doc-backlink">ClangCommentNodes</a><a class="headerlink" href="#clangcommentnodes" title="Link to this heading">¶</a></h3>
<p>Generate Clang AST comment nodes.</p>
</section>
<section id="clangdeclnodes">
<h3><a class="toc-backref" href="#id40" role="doc-backlink">ClangDeclNodes</a><a class="headerlink" href="#clangdeclnodes" title="Link to this heading">¶</a></h3>
<p>Generate Clang AST declaration nodes.</p>
</section>
<section id="clangstmtnodes">
<h3><a class="toc-backref" href="#id41" role="doc-backlink">ClangStmtNodes</a><a class="headerlink" href="#clangstmtnodes" title="Link to this heading">¶</a></h3>
<p>Generate Clang AST statement nodes.</p>
</section>
<section id="clangsacheckers">
<h3><a class="toc-backref" href="#id42" role="doc-backlink">ClangSACheckers</a><a class="headerlink" href="#clangsacheckers" title="Link to this heading">¶</a></h3>
<p>Generate Clang Static Analyzer checkers.</p>
</section>
<section id="clangcommenthtmltags">
<h3><a class="toc-backref" href="#id43" role="doc-backlink">ClangCommentHTMLTags</a><a class="headerlink" href="#clangcommenthtmltags" title="Link to this heading">¶</a></h3>
<p>Generate efficient matchers for HTML tag names that are used in documentation comments.</p>
</section>
<section id="clangcommenthtmltagsproperties">
<h3><a class="toc-backref" href="#id44" role="doc-backlink">ClangCommentHTMLTagsProperties</a><a class="headerlink" href="#clangcommenthtmltagsproperties" title="Link to this heading">¶</a></h3>
<p>Generate efficient matchers for HTML tag properties.</p>
</section>
<section id="clangcommenthtmlnamedcharacterreferences">
<h3><a class="toc-backref" href="#id45" role="doc-backlink">ClangCommentHTMLNamedCharacterReferences</a><a class="headerlink" href="#clangcommenthtmlnamedcharacterreferences" title="Link to this heading">¶</a></h3>
<p>Generate function to translate named character references to UTF-8 sequences.</p>
</section>
<section id="clangcommentcommandinfo">
<h3><a class="toc-backref" href="#id46" role="doc-backlink">ClangCommentCommandInfo</a><a class="headerlink" href="#clangcommentcommandinfo" title="Link to this heading">¶</a></h3>
<p>Generate command properties for commands that are used in documentation comments.</p>
</section>
<section id="clangcommentcommandlist">
<h3><a class="toc-backref" href="#id47" role="doc-backlink">ClangCommentCommandList</a><a class="headerlink" href="#clangcommentcommandlist" title="Link to this heading">¶</a></h3>
<p>Generate list of commands that are used in documentation comments.</p>
</section>
<section id="armneon">
<h3><a class="toc-backref" href="#id48" role="doc-backlink">ArmNeon</a><a class="headerlink" href="#armneon" title="Link to this heading">¶</a></h3>
<p>Generate <code class="docutils literal notranslate"><span class="pre">arm_neon.h</span></code> for clang.</p>
</section>
<section id="armneonsema">
<h3><a class="toc-backref" href="#id49" role="doc-backlink">ArmNeonSema</a><a class="headerlink" href="#armneonsema" title="Link to this heading">¶</a></h3>
<p>Generate ARM NEON sema support for clang.</p>
</section>
<section id="armneontest">
<h3><a class="toc-backref" href="#id50" role="doc-backlink">ArmNeonTest</a><a class="headerlink" href="#armneontest" title="Link to this heading">¶</a></h3>
<p>Generate ARM NEON tests for clang.</p>
</section>
<section id="attrdocs">
<h3><a class="toc-backref" href="#id51" role="doc-backlink">AttrDocs</a><a class="headerlink" href="#attrdocs" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Creates <code class="docutils literal notranslate"><span class="pre">AttributeReference.rst</span></code> from <code class="docutils literal notranslate"><span class="pre">AttrDocs.td</span></code>, and is
used for documenting user-facing attributes.</p>
</section>
</section>
<section id="general-backends">
<h2><a class="toc-backref" href="#id52" role="doc-backlink">General BackEnds</a><a class="headerlink" href="#general-backends" title="Link to this heading">¶</a></h2>
<section id="print-records">
<h3><a class="toc-backref" href="#id53" role="doc-backlink">Print Records</a><a class="headerlink" href="#print-records" title="Link to this heading">¶</a></h3>
<p>The TableGen command option <code class="docutils literal notranslate"><span class="pre">--print-records</span></code> invokes a simple backend
that prints all the classes and records defined in the source files. This is
the default backend option. See the <a class="reference internal" href="BackGuide.html"><span class="doc">TableGen Backend Developer’s Guide</span></a> for more information.</p>
</section>
<section id="print-detailed-records">
<h3><a class="toc-backref" href="#id54" role="doc-backlink">Print Detailed Records</a><a class="headerlink" href="#print-detailed-records" title="Link to this heading">¶</a></h3>
<p>The TableGen command option <code class="docutils literal notranslate"><span class="pre">--print-detailed-records</span></code> invokes a backend
that prints all the global variables, classes, and records defined in the
source files, with more detail than the default record printer. See the
<a class="reference internal" href="BackGuide.html"><span class="doc">TableGen Backend Developer’s Guide</span></a> for more
information.</p>
</section>
<section id="json-reference">
<h3><a class="toc-backref" href="#id55" role="doc-backlink">JSON Reference</a><a class="headerlink" href="#json-reference" title="Link to this heading">¶</a></h3>
<p><strong>Purpose</strong>: Output all the values in every <code class="docutils literal notranslate"><span class="pre">def</span></code>, as a JSON data
structure that can be easily parsed by a variety of languages. Useful
for writing custom backends without having to modify TableGen itself,
or for performing auxiliary analysis on the same TableGen data passed
to a built-in backend.</p>
<p><strong>Output</strong>:</p>
<p>The root of the output file is a JSON object (i.e., dictionary),
containing the following fixed keys:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">!tablegen_json_version</span></code>: a numeric version field that will
increase if an incompatible change is ever made to the structure of
this data. The format described here corresponds to version 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!instanceof</span></code>: a dictionary whose keys are the class names defined
in the TableGen input. For each key, the corresponding value is an
array of strings giving the names of <code class="docutils literal notranslate"><span class="pre">def</span></code> records that derive
from that class. So <code class="docutils literal notranslate"><span class="pre">root[&quot;!instanceof&quot;][&quot;Instruction&quot;]</span></code>, for
example, would list the names of all the records deriving from the
class <code class="docutils literal notranslate"><span class="pre">Instruction</span></code>.</p></li>
</ul>
<p>For each <code class="docutils literal notranslate"><span class="pre">def</span></code> record, the root object also has a key for the record
name. The corresponding value is a subsidiary object containing the
following fixed keys:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">!superclasses</span></code>: an array of strings giving the names of all the
classes that this record derives from.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!fields</span></code>: an array of strings giving the names of all the variables
in this record that were defined with the <code class="docutils literal notranslate"><span class="pre">field</span></code> keyword.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!name</span></code>: a string giving the name of the record. This is always
identical to the key in the JSON root object corresponding to this
record’s dictionary. (If the record is anonymous, the name is
arbitrary.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!anonymous</span></code>: a boolean indicating whether the record’s name was
specified by the TableGen input (if it is <code class="docutils literal notranslate"><span class="pre">false</span></code>), or invented by
TableGen itself (if <code class="docutils literal notranslate"><span class="pre">true</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!locs</span></code>: an array of strings giving the source locations associated with
this record. For records instantiated from a <code class="docutils literal notranslate"><span class="pre">multiclass</span></code>, this gives the
location of each <code class="docutils literal notranslate"><span class="pre">def</span></code> or <code class="docutils literal notranslate"><span class="pre">defm</span></code>, starting with the inner-most
<code class="docutils literal notranslate"><span class="pre">multiclass</span></code>, and ending with the top-level <code class="docutils literal notranslate"><span class="pre">defm</span></code>. Each string contains
the file name and line number, separated by a colon.</p></li>
</ul>
<p>For each variable defined in a record, the <code class="docutils literal notranslate"><span class="pre">def</span></code> object for that
record also has a key for the variable name. The corresponding value
is a translation into JSON of the variable’s value, using the
conventions described below.</p>
<p>Some TableGen data types are translated directly into the
corresponding JSON type:</p>
<ul class="simple">
<li><p>A completely undefined value (e.g., for a variable declared without
initializer in some superclass of this record, and never initialized
by the record itself or any other superclass) is emitted as the JSON
<code class="docutils literal notranslate"><span class="pre">null</span></code> value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">bit</span></code> values are emitted as numbers. Note that
TableGen <code class="docutils literal notranslate"><span class="pre">int</span></code> values are capable of holding integers too large to
be exactly representable in IEEE double precision. The integer
literal in the JSON output will show the full exact integer value.
So if you need to retrieve large integers with full precision, you
should use a JSON reader capable of translating such literals back
into 64-bit integers without losing precision, such as Python’s
standard <code class="docutils literal notranslate"><span class="pre">json</span></code> module.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">string</span></code> and <code class="docutils literal notranslate"><span class="pre">code</span></code> values are emitted as JSON strings.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">list&lt;T&gt;</span></code> values, for any element type <code class="docutils literal notranslate"><span class="pre">T</span></code>, are emitted as JSON
arrays. Each element of the array is represented in turn using these
same conventions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bits</span></code> values are also emitted as arrays. A <code class="docutils literal notranslate"><span class="pre">bits</span></code> array is
ordered from least-significant bit to most-significant. So the
element with index <code class="docutils literal notranslate"><span class="pre">i</span></code> corresponds to the bit described as
<code class="docutils literal notranslate"><span class="pre">x{i}</span></code> in TableGen source. However, note that this means that
scripting languages are likely to <em>display</em> the array in the
opposite order from the way it appears in the TableGen source or in
the diagnostic <code class="docutils literal notranslate"><span class="pre">-print-records</span></code> output.</p></li>
</ul>
<p>All other TableGen value types are emitted as a JSON object,
containing two standard fields: <code class="docutils literal notranslate"><span class="pre">kind</span></code> is a discriminator describing
which kind of value the object represents, and <code class="docutils literal notranslate"><span class="pre">printable</span></code> is a
string giving the same representation of the value that would appear
in <code class="docutils literal notranslate"><span class="pre">-print-records</span></code>.</p>
<ul class="simple">
<li><p>A reference to a <code class="docutils literal notranslate"><span class="pre">def</span></code> object has <code class="docutils literal notranslate"><span class="pre">kind==&quot;def&quot;</span></code>, and has an
extra field <code class="docutils literal notranslate"><span class="pre">def</span></code> giving the name of the object referred to.</p></li>
<li><p>A reference to another variable in the same record has
<code class="docutils literal notranslate"><span class="pre">kind==&quot;var&quot;</span></code>, and has an extra field <code class="docutils literal notranslate"><span class="pre">var</span></code> giving the name of
the variable referred to.</p></li>
<li><p>A reference to a specific bit of a <code class="docutils literal notranslate"><span class="pre">bits</span></code>-typed variable in the
same record has <code class="docutils literal notranslate"><span class="pre">kind==&quot;varbit&quot;</span></code>, and has two extra fields:
<code class="docutils literal notranslate"><span class="pre">var</span></code> gives the name of the variable referred to, and <code class="docutils literal notranslate"><span class="pre">index</span></code>
gives the index of the bit.</p></li>
<li><p>A value of type <code class="docutils literal notranslate"><span class="pre">dag</span></code> has <code class="docutils literal notranslate"><span class="pre">kind==&quot;dag&quot;</span></code>, and has two extra
fields. <code class="docutils literal notranslate"><span class="pre">operator</span></code> gives the initial value after the opening
parenthesis of the dag initializer; <code class="docutils literal notranslate"><span class="pre">args</span></code> is an array giving the
following arguments. The elements of <code class="docutils literal notranslate"><span class="pre">args</span></code> are arrays of length
2, giving the value of each argument followed by its colon-suffixed
name (if any). For example, in the JSON representation of the dag
value <code class="docutils literal notranslate"><span class="pre">(Op</span> <span class="pre">22,</span> <span class="pre">&quot;hello&quot;:$foo)</span></code> (assuming that <code class="docutils literal notranslate"><span class="pre">Op</span></code> is the name of
a record defined elsewhere with a <code class="docutils literal notranslate"><span class="pre">def</span></code> statement):</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">operator</span></code> will be an object in which <code class="docutils literal notranslate"><span class="pre">kind==&quot;def&quot;</span></code> and
<code class="docutils literal notranslate"><span class="pre">def==&quot;Op&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">args</span></code> will be the array <code class="docutils literal notranslate"><span class="pre">[[22,</span> <span class="pre">null],</span> <span class="pre">[&quot;hello&quot;,</span> <span class="pre">&quot;foo&quot;]]</span></code>.</p></li>
</ul>
</li>
<li><p>If any other kind of value or complicated expression appears in the
output, it will have <code class="docutils literal notranslate"><span class="pre">kind==&quot;complex&quot;</span></code>, and no additional fields.
These values are not expected to be needed by backends. The standard
<code class="docutils literal notranslate"><span class="pre">printable</span></code> field can be used to extract a representation of them
in TableGen source syntax if necessary.</p></li>
</ul>
</section>
<section id="searchabletables-reference">
<h3><a class="toc-backref" href="#id56" role="doc-backlink">SearchableTables Reference</a><a class="headerlink" href="#searchabletables-reference" title="Link to this heading">¶</a></h3>
<p>A TableGen include file, <code class="docutils literal notranslate"><span class="pre">SearchableTable.td</span></code>, provides classes for
generating C++ searchable tables. These tables are described in the
following sections. To generate the C++ code, run <code class="docutils literal notranslate"><span class="pre">llvm-tblgen</span></code> with the
<code class="docutils literal notranslate"><span class="pre">--gen-searchable-tables</span></code> option, which invokes the backend that generates
the tables from the records you provide.</p>
<p>Each of the data structures generated for searchable tables is guarded by an
<code class="docutils literal notranslate"><span class="pre">#ifdef</span></code>. This allows you to include the generated <code class="docutils literal notranslate"><span class="pre">.inc</span></code> file and select only
certain data structures for inclusion. The examples below show the macro
names used in these guards.</p>
<section id="generic-enumerated-types">
<h4><a class="toc-backref" href="#id57" role="doc-backlink">Generic Enumerated Types</a><a class="headerlink" href="#generic-enumerated-types" title="Link to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">GenericEnum</span></code> class makes it easy to define a C++ enumerated type and
the enumerated <em>elements</em> of that type. To define the type, define a record
whose parent class is <code class="docutils literal notranslate"><span class="pre">GenericEnum</span></code> and whose name is the desired enum
type. This class provides three fields, which you can set in the record
using the <code class="docutils literal notranslate"><span class="pre">let</span></code> statement.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">string</span> <span class="pre">FilterClass</span></code>. The enum type will have one element for each record
that derives from this class. These records are collected to assemble the
complete set of elements.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">string</span> <span class="pre">NameField</span></code>. The name of a field <em>in the collected records</em> that specifies
the name of the element. If a record has no such field, the record’s
name will be used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">string</span> <span class="pre">ValueField</span></code>. The name of a field <em>in the collected records</em> that
specifies the numerical value of the element. If a record has no such
field, it will be assigned an integer value. Values are assigned in
alphabetical order starting with 0.</p></li>
</ul>
<p>Here is an example where the values of the elements are specified
explicitly, as a template argument to the <code class="docutils literal notranslate"><span class="pre">BEntry</span></code> class. The resulting
C++ code is shown.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def BValues : GenericEnum {
  let FilterClass = &quot;BEntry&quot;;
  let NameField = &quot;Name&quot;;
  let ValueField = &quot;Encoding&quot;;
}

class BEntry&lt;bits&lt;16&gt; enc&gt; {
  string Name = NAME;
  bits&lt;16&gt; Encoding = enc;
}

def BFoo   : BEntry&lt;0xac&gt;;
def BBar   : BEntry&lt;0x14&gt;;
def BZoo   : BEntry&lt;0x80&gt;;
def BSnork : BEntry&lt;0x4c&gt;;
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>#ifdef GET_BValues_DECL
enum BValues {
  BBar = 20,
  BFoo = 172,
  BSnork = 76,
  BZoo = 128,
};
#endif
</pre></div>
</div>
<p>In the following example, the values of the elements are assigned
automatically. Note that values are assigned from 0, in alphabetical order
by element name.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def CEnum : GenericEnum {
  let FilterClass = &quot;CEnum&quot;;
}

class CEnum;

def CFoo : CEnum;
def CBar : CEnum;
def CBaz : CEnum;
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>#ifdef GET_CEnum_DECL
enum CEnum {
  CBar = 0,
  CBaz = 1,
  CFoo = 2,
};
#endif
</pre></div>
</div>
</section>
<section id="generic-tables">
<h4><a class="toc-backref" href="#id58" role="doc-backlink">Generic Tables</a><a class="headerlink" href="#generic-tables" title="Link to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">GenericTable</span></code> class is used to define a searchable generic table.
TableGen produces C++ code to define the table entries and also produces
the declaration and definition of a function to search the table based on a
primary key. To define the table, define a record whose parent class is
<code class="docutils literal notranslate"><span class="pre">GenericTable</span></code> and whose name is the name of the global table of entries.
This class provides six fields.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">string</span> <span class="pre">FilterClass</span></code>. The table will have one entry for each record
that derives from this class.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">string</span> <span class="pre">FilterClassField</span></code>. This is an optional field of <code class="docutils literal notranslate"><span class="pre">FilterClass</span></code>
which should be <cite>bit</cite> type. If specified, only those records with this field
being true will have corresponding entries in the table. This field won’t be
included in generated C++ fields if it isn’t included in <code class="docutils literal notranslate"><span class="pre">Fields</span></code> list.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">string</span> <span class="pre">CppTypeName</span></code>. The name of the C++ struct/class type of the
table that holds the entries. If unspecified, the <code class="docutils literal notranslate"><span class="pre">FilterClass</span></code> name is
used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">list&lt;string&gt;</span> <span class="pre">Fields</span></code>. A list of the names of the fields <em>in the
collected records</em> that contain the data for the table entries. The order of
this list determines the order of the values in the C++ initializers. See
below for information about the types of these fields.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">list&lt;string&gt;</span> <span class="pre">PrimaryKey</span></code>. The list of fields that make up the
primary key.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">string</span> <span class="pre">PrimaryKeyName</span></code>. The name of the generated C++ function
that performs a lookup on the primary key.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bit</span> <span class="pre">PrimaryKeyEarlyOut</span></code>. See the third example below.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bit</span> <span class="pre">PrimaryKeyReturnRange</span></code>. when set to 1, modifies the lookup function’s
definition to return a range of results rather than a single pointer to the
object. This feature proves useful when multiple objects meet the criteria
specified by the lookup function. Currently, it is supported only for primary
lookup functions. Refer to the second example below for further details.</p></li>
</ul>
<p>TableGen attempts to deduce the type of each of the table fields so that it
can format the C++ initializers in the emitted table. It can deduce <code class="docutils literal notranslate"><span class="pre">bit</span></code>,
<code class="docutils literal notranslate"><span class="pre">bits&lt;n&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">string</span></code>, <code class="docutils literal notranslate"><span class="pre">Intrinsic</span></code>, and <code class="docutils literal notranslate"><span class="pre">Instruction</span></code>.  These can be
used in the primary key. Any other field types must be specified
explicitly; this is done as shown in the second example below. Such fields
cannot be used in the primary key.</p>
<p>One special case of the field type has to do with code. Arbitrary code is
represented by a string, but has to be emitted as a C++ initializer without
quotes. If the code field was defined using a code literal (<code class="docutils literal notranslate"><span class="pre">[{...}]</span></code>),
then TableGen will know to emit it without quotes. However, if it was
defined using a string literal or complex string expression, then TableGen
will not know. In this case, you can force TableGen to treat the field as
code by including the following line in the <code class="docutils literal notranslate"><span class="pre">GenericTable</span></code> record, where
<em>xxx</em> is the code field name.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>string TypeOf_xxx = &quot;code&quot;;
</pre></div>
</div>
<p>Here is an example where TableGen can deduce the field types. Note that the
table entry records are anonymous; the names of entry records are
irrelevant.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def ATable : GenericTable {
  let FilterClass = &quot;AEntry&quot;;
  let FilterClassField = &quot;IsNeeded&quot;;
  let Fields = [&quot;Str&quot;, &quot;Val1&quot;, &quot;Val2&quot;];
  let PrimaryKey = [&quot;Val1&quot;, &quot;Val2&quot;];
  let PrimaryKeyName = &quot;lookupATableByValues&quot;;
}

class AEntry&lt;string str, int val1, int val2, bit isNeeded&gt; {
  string Str = str;
  bits&lt;8&gt; Val1 = val1;
  bits&lt;10&gt; Val2 = val2;
  bit IsNeeded = isNeeded;
}

def : AEntry&lt;&quot;Bob&quot;,   5, 3, 1&gt;;
def : AEntry&lt;&quot;Carol&quot;, 2, 6, 1&gt;;
def : AEntry&lt;&quot;Ted&quot;,   4, 4, 1&gt;;
def : AEntry&lt;&quot;Alice&quot;, 4, 5, 1&gt;;
def : AEntry&lt;&quot;Costa&quot;, 2, 1, 1&gt;;
def : AEntry&lt;&quot;Dale&quot;,  2, 1, 0&gt;;
</pre></div>
</div>
<p>Here is the generated C++ code. The declaration of <code class="docutils literal notranslate"><span class="pre">lookupATableByValues</span></code>
is guarded by <code class="docutils literal notranslate"><span class="pre">GET_ATable_DECL</span></code>, while the definitions are guarded by
<code class="docutils literal notranslate"><span class="pre">GET_ATable_IMPL</span></code>.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>#ifdef GET_ATable_DECL
const AEntry *lookupATableByValues(uint8_t Val1, uint16_t Val2);
#endif

#ifdef GET_ATable_IMPL
constexpr AEntry ATable[] = {
  { &quot;Costa&quot;, 0x2, 0x1 }, // 0
  { &quot;Carol&quot;, 0x2, 0x6 }, // 1
  { &quot;Ted&quot;, 0x4, 0x4 }, // 2
  { &quot;Alice&quot;, 0x4, 0x5 }, // 3
  { &quot;Bob&quot;, 0x5, 0x3 }, // 4
  /* { &quot;Dale&quot;, 0x2, 0x1 }, // 5 */ // We don&#39;t generate this line as `IsNeeded` is 0.
};

const AEntry *lookupATableByValues(uint8_t Val1, uint16_t Val2) {
  struct KeyType {
    uint8_t Val1;
    uint16_t Val2;
  };
  KeyType Key = { Val1, Val2 };
  auto Table = ArrayRef(ATable);
  auto Idx = std::lower_bound(Table.begin(), Table.end(), Key,
    [](const AEntry &amp;LHS, const KeyType &amp;RHS) {
      if (LHS.Val1 &lt; RHS.Val1)
        return true;
      if (LHS.Val1 &gt; RHS.Val1)
        return false;
      if (LHS.Val2 &lt; RHS.Val2)
        return true;
      if (LHS.Val2 &gt; RHS.Val2)
        return false;
      return false;
    });

  if (Idx == Table.end() ||
      Key.Val1 != Idx-&gt;Val1 ||
      Key.Val2 != Idx-&gt;Val2)
    return nullptr;
  return &amp;*Idx;
}
#endif
</pre></div>
</div>
<p>The table entries in <code class="docutils literal notranslate"><span class="pre">ATable</span></code> are sorted in order by <code class="docutils literal notranslate"><span class="pre">Val1</span></code>, and within
each of those values, by <code class="docutils literal notranslate"><span class="pre">Val2</span></code>. This allows a binary search of the table,
which is performed in the lookup function by <code class="docutils literal notranslate"><span class="pre">std::lower_bound</span></code>. The
lookup function returns a reference to the found table entry, or the null
pointer if no entry is found. If the table has a single primary key field
which is integral and densely numbered, a direct lookup is generated rather
than a binary search.</p>
<p>This example includes a field whose type TableGen cannot deduce. The <code class="docutils literal notranslate"><span class="pre">Kind</span></code>
field uses the enumerated type <code class="docutils literal notranslate"><span class="pre">CEnum</span></code> defined above. To inform TableGen
of the type, the record derived from <code class="docutils literal notranslate"><span class="pre">GenericTable</span></code> must include a string field
named <code class="docutils literal notranslate"><span class="pre">TypeOf_</span></code><em>field</em>, where <em>field</em> is the name of the field whose type
is required.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def CTable : GenericTable {
  let FilterClass = &quot;CEntry&quot;;
  let Fields = [&quot;Name&quot;, &quot;Kind&quot;, &quot;Encoding&quot;];
  string TypeOf_Kind = &quot;CEnum&quot;;
  let PrimaryKey = [&quot;Encoding&quot;];
  let PrimaryKeyName = &quot;lookupCEntryByEncoding&quot;;
}

class CEntry&lt;string name, CEnum kind, int enc&gt; {
  string Name = name;
  CEnum Kind = kind;
  bits&lt;16&gt; Encoding = enc;
}

def : CEntry&lt;&quot;Apple&quot;, CFoo, 10&gt;;
def : CEntry&lt;&quot;Pear&quot;,  CBaz, 15&gt;;
def : CEntry&lt;&quot;Apple&quot;, CBar, 13&gt;;
</pre></div>
</div>
<p>Here is the generated C++ code.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>#ifdef GET_CTable_DECL
const CEntry *lookupCEntryByEncoding(uint16_t Encoding);
#endif

#ifdef GET_CTable_IMPL
constexpr CEntry CTable[] = {
  { &quot;Apple&quot;, CFoo, 0xA }, // 0
  { &quot;Apple&quot;, CBar, 0xD }, // 1
  { &quot;Pear&quot;, CBaz, 0xF }, // 2
};

const CEntry *lookupCEntryByEncoding(uint16_t Encoding) {
  struct KeyType {
    uint16_t Encoding;
  };
  KeyType Key = { Encoding };
  auto Table = ArrayRef(CTable);
  auto Idx = std::lower_bound(Table.begin(), Table.end(), Key,
    [](const CEntry &amp;LHS, const KeyType &amp;RHS) {
      if (LHS.Encoding &lt; RHS.Encoding)
        return true;
      if (LHS.Encoding &gt; RHS.Encoding)
        return false;
      return false;
    });

  if (Idx == Table.end() ||
      Key.Encoding != Idx-&gt;Encoding)
    return nullptr;
  return &amp;*Idx;
}
</pre></div>
</div>
<p>In the above example, lets add one more record with encoding same as that of
record <code class="docutils literal notranslate"><span class="pre">CEntry&lt;&quot;Pear&quot;,</span>&#160; <span class="pre">CBaz,</span> <span class="pre">15&gt;</span></code>.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def CFoobar : CEnum;
def : CEntry&lt;&quot;Banana&quot;, CFoobar, 15&gt;;
</pre></div>
</div>
<p>Below is the new generated <code class="docutils literal notranslate"><span class="pre">CTable</span></code></p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>#ifdef GET_Table_IMPL
constexpr CEntry Table[] = {
  { &quot;Apple&quot;, CFoo, 0xA }, // 0
  { &quot;Apple&quot;, CBar, 0xD }, // 1
  { &quot;Banana&quot;, CFoobar, 0xF }, // 2
  { &quot;Pear&quot;, CBaz, 0xF }, // 3
};
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">Banana</span></code> lexicographically appears first, therefore in the <code class="docutils literal notranslate"><span class="pre">CEntry</span></code>
table, record with name <code class="docutils literal notranslate"><span class="pre">Banana</span></code> will come before the record with name
<code class="docutils literal notranslate"><span class="pre">Pear</span></code>. Because of this, the <code class="docutils literal notranslate"><span class="pre">lookupCEntryByEncoding</span></code> function will always
return a pointer to the record with name <code class="docutils literal notranslate"><span class="pre">Banana</span></code> even though in some cases
the correct result can be the record with name <code class="docutils literal notranslate"><span class="pre">Pear</span></code>. Such kind of scenario
makes the existing lookup function insufficient because they always return a
pointer to a single entry from the table, but instead it should return a range
of results because multiple entries match the criteria sought by the lookup
function. In this case, the definition of the lookup function needs to be
modified to return a range of results which can be done by setting
<code class="docutils literal notranslate"><span class="pre">PrimaryKeyReturnRange</span></code>.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def CTable : GenericTable {
  let FilterClass = &quot;CEntry&quot;;
  let Fields = [&quot;Name&quot;, &quot;Kind&quot;, &quot;Encoding&quot;];
  string TypeOf_Kind = &quot;CEnum&quot;;
  let PrimaryKey = [&quot;Encoding&quot;];
  let PrimaryKeyName = &quot;lookupCEntryByEncoding&quot;;
  let PrimaryKeyReturnRange = true;
}
</pre></div>
</div>
<p>Here is the modified lookup function.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>llvm::iterator_range&lt;const CEntry *&gt; lookupCEntryByEncoding(uint16_t Encoding) {
  struct KeyType {
    uint16_t Encoding;
  };
  KeyType Key = {Encoding};
  struct Comp {
    bool operator()(const CEntry &amp;LHS, const KeyType &amp;RHS) const {
      if (LHS.Encoding &lt; RHS.Encoding)
        return true;
      if (LHS.Encoding &gt; RHS.Encoding)
        return false;
      return false;
    }
    bool operator()(const KeyType &amp;LHS, const CEntry &amp;RHS) const {
      if (LHS.Encoding &lt; RHS.Encoding)
        return true;
      if (LHS.Encoding &gt; RHS.Encoding)
        return false;
      return false;
    }
  };
  auto Table = ArrayRef(Table);
  auto It = std::equal_range(Table.begin(), Table.end(), Key, Comp());
  return llvm::make_range(It.first, It.second);
}
</pre></div>
</div>
<p>The new lookup function will return an iterator range with first pointer to the
first result and the last pointer to the last matching result from the table.
However, please note that the support for emitting a modified definition exists
for <code class="docutils literal notranslate"><span class="pre">PrimaryKeyName</span></code> only.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">PrimaryKeyEarlyOut</span></code> field, when set to 1, modifies the lookup
function so that it tests the first field of the primary key to determine
whether it is within the range of the collected records’ primary keys. If
not, the function returns the null pointer without performing the binary
search. This is useful for tables that provide data for only some of the
elements of a larger enum-based space. The first field of the primary key
must be an integral type; it cannot be a string.</p>
<p>Adding <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">PrimaryKeyEarlyOut</span> <span class="pre">=</span> <span class="pre">1</span></code> to the <code class="docutils literal notranslate"><span class="pre">ATable</span></code> above:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def ATable : GenericTable {
  let FilterClass = &quot;AEntry&quot;;
  let Fields = [&quot;Str&quot;, &quot;Val1&quot;, &quot;Val2&quot;];
  let PrimaryKey = [&quot;Val1&quot;, &quot;Val2&quot;];
  let PrimaryKeyName = &quot;lookupATableByValues&quot;;
  let PrimaryKeyEarlyOut = 1;
}
</pre></div>
</div>
<p>causes the lookup function to change as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>const AEntry *lookupATableByValues(uint8_t Val1, uint16_t Val2) {
  if ((Val1 &lt; 0x2) ||
      (Val1 &gt; 0x5))
    return nullptr;

  struct KeyType {
  ...
</pre></div>
</div>
<p>We can construct two GenericTables with the same <code class="docutils literal notranslate"><span class="pre">FilterClass</span></code>, so that they
select from the same overall set of records, but assign them with different
<code class="docutils literal notranslate"><span class="pre">FilterClassField</span></code> values so that they include different subsets of the
records of that class.</p>
<p>For example, we can create two tables that contain only even or odd records.
Fields <code class="docutils literal notranslate"><span class="pre">IsEven</span></code> and <code class="docutils literal notranslate"><span class="pre">IsOdd</span></code> won’t be included in generated C++ fields
because they aren’t included in <code class="docutils literal notranslate"><span class="pre">Fields</span></code> list.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>class EEntry&lt;bits&lt;8&gt; value&gt; {
  bits&lt;8&gt; Value = value;
  bit IsEven = !eq(!and(value, 1), 0);
  bit IsOdd = !not(IsEven);
}

foreach i = {1-10} in {
  def : EEntry&lt;i&gt;;
}

def EEntryEvenTable : GenericTable {
  let FilterClass = &quot;EEntry&quot;;
  let FilterClassField = &quot;IsEven&quot;;
  let Fields = [&quot;Value&quot;];
  let PrimaryKey = [&quot;Value&quot;];
  let PrimaryKeyName = &quot;lookupEEntryEvenTableByValue&quot;;
}

def EEntryOddTable : GenericTable {
  let FilterClass = &quot;EEntry&quot;;
  let FilterClassField = &quot;IsOdd&quot;;
  let Fields = [&quot;Value&quot;];
  let PrimaryKey = [&quot;Value&quot;];
  let PrimaryKeyName = &quot;lookupEEntryOddTableByValue&quot;;
}
</pre></div>
</div>
<p>The generated tables are:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>constexpr EEntry EEntryEvenTable[] = {
  { 0x2 }, // 0
  { 0x4 }, // 1
  { 0x6 }, // 2
  { 0x8 }, // 3
  { 0xA }, // 4
};

constexpr EEntry EEntryOddTable[] = {
  { 0x1 }, // 0
  { 0x3 }, // 1
  { 0x5 }, // 2
  { 0x7 }, // 3
  { 0x9 }, // 4
};
</pre></div>
</div>
</section>
<section id="search-indexes">
<h4><a class="toc-backref" href="#id59" role="doc-backlink">Search Indexes</a><a class="headerlink" href="#search-indexes" title="Link to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">SearchIndex</span></code> class is used to define additional lookup functions for
generic tables. To define an additional function, define a record whose parent
class is <code class="docutils literal notranslate"><span class="pre">SearchIndex</span></code> and whose name is the name of the desired lookup
function. This class provides three fields.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">GenericTable</span> <span class="pre">Table</span></code>. The name of the table that is to receive another
lookup function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">list&lt;string&gt;</span> <span class="pre">Key</span></code>. The list of fields that make up the secondary key.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bit</span> <span class="pre">EarlyOut</span></code>. See the third example in <a class="reference internal" href="#generic-tables">Generic Tables</a>.</p></li>
</ul>
<p>Here is an example of a secondary key added to the <code class="docutils literal notranslate"><span class="pre">CTable</span></code> above. The
generated function looks up entries based on the <code class="docutils literal notranslate"><span class="pre">Name</span></code> and <code class="docutils literal notranslate"><span class="pre">Kind</span></code> fields.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def lookupCEntry : SearchIndex {
  let Table = CTable;
  let Key = [&quot;Name&quot;, &quot;Kind&quot;];
}
</pre></div>
</div>
<p>This use of <code class="docutils literal notranslate"><span class="pre">SearchIndex</span></code> generates the following additional C++ code.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>const CEntry *lookupCEntry(StringRef Name, unsigned Kind);

...

const CEntry *lookupCEntryByName(StringRef Name, unsigned Kind) {
  struct IndexType {
    const char * Name;
    unsigned Kind;
    unsigned _index;
  };
  static const struct IndexType Index[] = {
    { &quot;APPLE&quot;, CBar, 1 },
    { &quot;APPLE&quot;, CFoo, 0 },
    { &quot;PEAR&quot;, CBaz, 2 },
  };

  struct KeyType {
    std::string Name;
    unsigned Kind;
  };
  KeyType Key = { Name.upper(), Kind };
  auto Table = ArrayRef(Index);
  auto Idx = std::lower_bound(Table.begin(), Table.end(), Key,
    [](const IndexType &amp;LHS, const KeyType &amp;RHS) {
      int CmpName = StringRef(LHS.Name).compare(RHS.Name);
      if (CmpName &lt; 0) return true;
      if (CmpName &gt; 0) return false;
      if ((unsigned)LHS.Kind &lt; (unsigned)RHS.Kind)
        return true;
      if ((unsigned)LHS.Kind &gt; (unsigned)RHS.Kind)
        return false;
      return false;
    });

  if (Idx == Table.end() ||
      Key.Name != Idx-&gt;Name ||
      Key.Kind != Idx-&gt;Kind)
    return nullptr;
  return &amp;CTable[Idx-&gt;_index];
}
</pre></div>
</div>
</section>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="BackGuide.html" title="1 TableGen Backend Developer’s Guide"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="TableGen Overview"
             >previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="../index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="../UserGuides.html" >User Guides</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >TableGen Overview</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">TableGen BackEnds</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2003-2026, LLVM Project.
      Last updated on 2026-02-24.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>