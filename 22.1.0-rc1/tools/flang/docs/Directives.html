<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Compiler directives supported by Flang &#8212; The Flang Compiler</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=e491ac2d" />
    <script src="_static/documentation_options.js?v=b0deac7f"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Flang OpenMP Support" href="OpenMPSupport.html" />
    <link rel="prev" title="Fortran Extensions supported by Flang" href="Extensions.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>The Flang Compiler</span></a></h1>
        <h2 class="heading"><span>Compiler directives supported by Flang</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="Extensions.html">Fortran Extensions supported by Flang</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="OpenMPSupport.html">Flang OpenMP Support</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <!--===- docs/Directives.md

   Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
   See https://llvm.org/LICENSE.txt for license information.
   SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

-->
<section id="compiler-directives-supported-by-flang">
<h1>Compiler directives supported by Flang<a class="headerlink" href="#compiler-directives-supported-by-flang" title="Link to this heading">¶</a></h1>
<p>A list of non-standard directives supported by Flang</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">!dir$</span> <span class="pre">fixed</span></code> and <code class="docutils literal notranslate"><span class="pre">!dir$</span> <span class="pre">free</span></code> select Fortran source forms.  Their effect
persists to the end of the current source file.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!dir$</span> <span class="pre">ignore_tkr</span> <span class="pre">[[(TKRDMACP)]</span> <span class="pre">dummy-arg-name]...</span></code> in an interface definition
disables some semantic checks at call sites for the actual arguments that
correspond to some named dummy arguments (or all of them, by default). The
directive allow actual arguments that would otherwise be diagnosed as
incompatible in type (T), kind (K), rank (R), CUDA device (D), or managed (M)
status. The letter (A) is a shorthand for (TKRDM), and is the default when no
letters appear. The letter (C) checks for contiguity, for example allowing an
element of an assumed-shape array to be passed as a dummy argument. The
letter (P) ignores pointer and allocatable matching, so that one can pass an
allocatable array to routine with pointer array argument and vice versa. For
example, if one wanted to call a “set all bytes to zero” utility that could
be applied to arrays of any type or rank:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  interface
    subroutine clear(arr,bytes)
!dir$ ignore_tkr arr
      integer(1), intent(out) :: arr(bytes)
    end
  end interface
</pre></div>
</div>
<p>Note that it’s not allowed to pass array actual argument to <code class="docutils literal notranslate"><span class="pre">ignore_trk(R)</span></code>
dummy argument that is a scalar with <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> attribute, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  interface
    subroutine s(b)
      !dir$ ignore_tkr(r) b
      integer, value :: b
    end
  end interface
  integer :: a(5)
  call s(a)
</pre></div>
</div>
<p>The reason for this limitation is that scalars with <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> attribute can
be passed in registers, so it’s not clear how lowering should handle this
case. (Passing scalar actual argument to <code class="docutils literal notranslate"><span class="pre">ignore_tkr(R)</span></code> dummy argument
that is a scalar with <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> attribute is allowed.)</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">!dir$</span> <span class="pre">assume_aligned</span> <span class="pre">desginator:alignment</span></code>, where designator is a variable,
maybe with array indices, and alignment is what the compiler should assume the
alignment to be. E.g A:64 or B(1,1,1):128. The alignment should be a power of 2,
and is limited to 256.
[This directive is currently recognised by the parser, but not
handled by the other parts of the compiler].</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!dir$</span> <span class="pre">vector</span> <span class="pre">always</span></code> forces vectorization on the following loop regardless
of cost model decisions. The loop must still be vectorizable.
[This directive currently only works on plain do loops without labels].</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!dir$</span> <span class="pre">vector</span> <span class="pre">vectorlength({fixed|scalable|&lt;num&gt;|&lt;num&gt;,fixed|&lt;num&gt;,scalable})</span></code>
specifies a hint to the compiler about the desired vectorization factor. If
<code class="docutils literal notranslate"><span class="pre">fixed</span></code> is used, the compiler should prefer fixed-width vectorization.
Scalable vectorization instructions may still be used with a fixed-width
predicate. If <code class="docutils literal notranslate"><span class="pre">scalable</span></code> is used the compiler should prefer scalable
vectorization, though it can choose to use fixed length vectorization or not
at all. <code class="docutils literal notranslate"><span class="pre">&lt;num&gt;</span></code> means that the compiler should consider using this specific
vectorization factor, which should be an integer literal. This directive
currently has the same limitations as <code class="docutils literal notranslate"><span class="pre">!dir$</span> <span class="pre">vector</span> <span class="pre">always</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!dir$</span> <span class="pre">unroll</span> <span class="pre">[n]</span></code> specifies that the compiler ought to unroll the immediately
following loop <code class="docutils literal notranslate"><span class="pre">n</span></code> times. When <code class="docutils literal notranslate"><span class="pre">n</span></code> is <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">1</span></code>, the loop should not be unrolled
at all. When <code class="docutils literal notranslate"><span class="pre">n</span></code> is <code class="docutils literal notranslate"><span class="pre">2</span></code> or greater, the loop should be unrolled exactly <code class="docutils literal notranslate"><span class="pre">n</span></code>
times if possible. When <code class="docutils literal notranslate"><span class="pre">n</span></code> is omitted, the compiler should attempt to fully
unroll the loop. Some compilers accept an optional <code class="docutils literal notranslate"><span class="pre">=</span></code> before the <code class="docutils literal notranslate"><span class="pre">n</span></code> when <code class="docutils literal notranslate"><span class="pre">n</span></code>
is present in the directive. Flang does not.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!dir$</span> <span class="pre">unroll_and_jam</span> <span class="pre">[N]</span></code> control how many times a loop should be unrolled and
jammed. It must be placed immediately before a loop that follows. <code class="docutils literal notranslate"><span class="pre">N</span></code> is an optional
integer that specifying the unrolling factor. When <code class="docutils literal notranslate"><span class="pre">N</span></code> is <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">1</span></code>, the loop
should not be unrolled at all. If <code class="docutils literal notranslate"><span class="pre">N</span></code> is omitted the optimizer will
selects the number of times to unroll the loop.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!dir$</span> <span class="pre">prefetch</span> <span class="pre">designator[,</span> <span class="pre">designator]...</span></code>, where the designator list can be
a variable or an array reference. This directive is used to insert a hint to
the code generator to prefetch instructions for memory references.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!dir$</span> <span class="pre">novector</span></code> disabling vectorization on the following loop.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!dir$</span> <span class="pre">nounroll</span></code> disabling unrolling on the following loop.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!dir$</span> <span class="pre">nounroll_and_jam</span></code> disabling unrolling and jamming on the following loop.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!dir$</span> <span class="pre">inline</span></code> instructs the compiler to attempt to inline the called routines if the
directive is specified before a call statement or all call statements within the loop
body if specified before a DO LOOP or all function references if specified before an
assignment statement.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!dir$</span> <span class="pre">forceinline</span></code> works in the same way as the <code class="docutils literal notranslate"><span class="pre">inline</span></code> directive, but it forces
inlining by the compiler on a function call statement.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!dir$</span> <span class="pre">noinline</span></code> works in the same way as the <code class="docutils literal notranslate"><span class="pre">inline</span></code> directive, but prevents
any attempt of inlining by the compiler on a function call statement.</p></li>
</ul>
</section>
<section id="directive-details">
<h1>Directive Details<a class="headerlink" href="#directive-details" title="Link to this heading">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>Directives are commonly used in Fortran programs to specify additional actions
to be performed by the compiler. The directives are always specified with the
<code class="docutils literal notranslate"><span class="pre">!dir$</span></code> or <code class="docutils literal notranslate"><span class="pre">cdir$</span></code> prefix.</p>
</section>
<section id="loop-directives">
<h2>Loop Directives<a class="headerlink" href="#loop-directives" title="Link to this heading">¶</a></h2>
<p>Some directives are associated with the following construct, for example loop
directives. Directives on loops are used to specify additional transformation to
be performed by the compiler like enabling vectorisation, unrolling, interchange
etc.</p>
<p>Currently loop directives are not accepted in the presence of OpenMP or OpenACC
constructs on the loop. This should be implemented as it is used in some
applications.</p>
<section id="array-expressions">
<h3>Array Expressions<a class="headerlink" href="#array-expressions" title="Link to this heading">¶</a></h3>
<p>It is to be decided whether loop directives should also be able to be associated
with array expressions.</p>
</section>
</section>
<section id="semantics">
<h2>Semantics<a class="headerlink" href="#semantics" title="Link to this heading">¶</a></h2>
<p>Directives that are associated with constructs must appear in the same section
as the construct they are associated with, for example loop directives must
appear in the executable section as the loops appear there. To facilitate this
the parse tree is corrected to move such directives that appear in the
specification part into the execution part.</p>
<p>When a directive that must be associated with a construct appears, a search
forward from that directive to the next non-directive construct is performed to
check that that construct matches the expected construct for the directive.
Skipping other intermediate directives allows multiple directives to appear on
the same construct.</p>
</section>
<section id="lowering">
<h2>Lowering<a class="headerlink" href="#lowering" title="Link to this heading">¶</a></h2>
<p>Evaluation is extended with a new field called dirs for representing directives
associated with that Evaluation. When lowering loop directives, the associated
Do Loop’s evaluation is found and the directive is added to it. This information
is used only during the lowering of the loop.</p>
<section id="representation-in-llvm">
<h3>Representation in LLVM<a class="headerlink" href="#representation-in-llvm" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">llvm.loop</span></code> metadata is used in LLVM to provide information to the optimizer
about the loop. For example, the <code class="docutils literal notranslate"><span class="pre">llvm.loop.vectorize.enable</span></code> metadata informs
the optimizer that a loop can be vectorized without considering its cost-model.
This attribute is added to the loop condition branch.</p>
</section>
<section id="representation-in-mlir">
<h3>Representation in MLIR<a class="headerlink" href="#representation-in-mlir" title="Link to this heading">¶</a></h3>
<p>The MLIR LLVM dialect models this by an attribute called LoopAnnotation
Attribute. The attribute can be added to the latch of the loop in the cf
dialect and is then carried through lowering to the LLVM dialect.</p>
</section>
</section>
<section id="testing">
<h2>Testing<a class="headerlink" href="#testing" title="Link to this heading">¶</a></h2>
<p>Since directives must maintain a flow from source to LLVM IR, an integration
test is provided that tests the <code class="docutils literal notranslate"><span class="pre">vector</span> <span class="pre">always</span></code> directive, as well as individual
lit tests for each of the parsing, semantics and lowering stages.</p>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="Extensions.html">Fortran Extensions supported by Flang</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="OpenMPSupport.html">Flang OpenMP Support</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2017-2026, The Flang Team.
      Last updated on Jan 16, 2026.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>