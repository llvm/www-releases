
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>MemProf: Memory Profiling for LLVM &#8212; LLVM 22.1.0-rc1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/llvm-theme.css?v=96924833" />
    <script src="_static/documentation_options.js?v=2797fd66"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="MergeFunctions pass, how it works" href="MergeFunctions.html" />
    <link rel="prev" title="MemorySSA" href="MemorySSA.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="MergeFunctions.html" title="MergeFunctions pass, how it works"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="MemorySSA.html" title="MemorySSA"
             accesskey="P">previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" accesskey="U">User Guides</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">MemProf: Memory Profiling for LLVM</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="https://llvm.org/docs/UserGuides.html">User Guides</a></li>
    <li><a href="https://llvm.org/docs/Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/Contributing.html">Contributing to LLVM</a></li>
    <li><a href="https://llvm.org/docs/HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#discord">Discord</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/FAQ.html">FAQ</a></li>
    <li><a href="https://llvm.org/docs/Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project/">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/MemProf.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="memprof-memory-profiling-for-llvm">
<h1>MemProf: Memory Profiling for LLVM<a class="headerlink" href="#memprof-memory-profiling-for-llvm" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id2">Introduction</a></p>
<ul>
<li><p><a class="reference internal" href="#motivation" id="id3">Motivation</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#user-manual" id="id4">User Manual</a></p>
<ul>
<li><p><a class="reference internal" href="#building-with-memprof-instrumentation" id="id5">Building with MemProf Instrumentation</a></p></li>
<li><p><a class="reference internal" href="#running-and-generating-profiles" id="id6">Running and Generating Profiles</a></p></li>
<li><p><a class="reference internal" href="#processing-profiles" id="id7">Processing Profiles</a></p></li>
<li><p><a class="reference internal" href="#using-profiles-for-optimization" id="id8">Using Profiles for Optimization</a></p></li>
<li><p><a class="reference internal" href="#context-disambiguation-lto" id="id9">Context Disambiguation (LTO)</a></p></li>
<li><p><a class="reference internal" href="#static-data-partitioning" id="id10">Static Data Partitioning</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#developer-manual" id="id11">Developer Manual</a></p>
<ul>
<li><p><a class="reference internal" href="#architecture-overview" id="id12">Architecture Overview</a></p></li>
<li><p><a class="reference internal" href="#detailed-workflow-lto" id="id13">Detailed Workflow (LTO)</a></p></li>
<li><p><a class="reference internal" href="#source-structure" id="id14">Source Structure</a></p></li>
<li><p><a class="reference internal" href="#runtime-implementation" id="id15">Runtime Implementation</a></p></li>
<li><p><a class="reference internal" href="#profile-format" id="id16">Profile Format</a></p></li>
<li><p><a class="reference internal" href="#testing-with-yaml-profiles" id="id17">Testing with YAML Profiles</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>MemProf is a profile-guided optimization (PGO) feature for memory. It enables the compiler to optimize memory allocations and static data layout based on runtime profiling information. By understanding the “hotness”, lifetime, and access frequency of memory, the compiler can make better decisions about where to place data (both heap and static), reducing fragmentation and improving cache locality.</p>
<section id="motivation">
<h3><a class="toc-backref" href="#id3" role="doc-backlink">Motivation</a><a class="headerlink" href="#motivation" title="Link to this heading">¶</a></h3>
<p>Traditional PGO focuses on control flow (hot vs. cold code). MemProf extends this concept to data. It answers questions like:</p>
<ul class="simple">
<li><p>Which allocation sites are “hot” (frequently accessed)?</p></li>
<li><p>Which allocation sites are “cold” (rarely accessed)?</p></li>
<li><p>What is the lifetime of an allocation?</p></li>
</ul>
<p>This information enables optimizations such as:</p>
<ul class="simple">
<li><p><strong>Heap Layout Optimization:</strong> Grouping objects with similar lifetimes or access density. This currently requires an allocator that supports the necessary interfaces (e.g., tcmalloc).</p></li>
<li><p><strong>Static Data Partitioning:</strong> Segregating frequently accessed (hot) global variables and constants from rarely accessed (cold) ones to improve data locality and TLB utilization.</p></li>
</ul>
</section>
</section>
<section id="user-manual">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">User Manual</a><a class="headerlink" href="#user-manual" title="Link to this heading">¶</a></h2>
<p>This section describes how to use MemProf to profile and optimize your application.</p>
<section id="building-with-memprof-instrumentation">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">Building with MemProf Instrumentation</a><a class="headerlink" href="#building-with-memprof-instrumentation" title="Link to this heading">¶</a></h3>
<p>To enable MemProf instrumentation, compile your application with the <code class="docutils literal notranslate"><span class="pre">-fmemory-profile</span></code> flag. Make sure to include debug information (<code class="docutils literal notranslate"><span class="pre">-gmlt</span></code> and <code class="docutils literal notranslate"><span class="pre">-fdebug-info-for-profiling</span></code>) and frame pointers to ensure accurate stack traces and line number reporting.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>clang++<span class="w"> </span>-fmemory-profile<span class="w"> </span>-fno-omit-frame-pointer<span class="w"> </span>-mno-omit-leaf-frame-pointer<span class="w"> </span>-fno-optimize-sibling-calls<span class="w"> </span>-fdebug-info-for-profiling<span class="w"> </span>-gmlt<span class="w"> </span>-O2<span class="w"> </span>-fno-pie<span class="w"> </span>-no-pie<span class="w"> </span>-Wl,-z,noseparate-code<span class="w"> </span>-Wl,--build-id<span class="w"> </span>source.cpp<span class="w"> </span>-o<span class="w"> </span>app
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Link with <code class="docutils literal notranslate"><span class="pre">-fmemory-profile</span></code> as well to link the necessary runtime libraries. If you use a separate link step, ensure the flag is passed to the linker.
On Linux, the flags <code class="docutils literal notranslate"><span class="pre">-fno-pie</span> <span class="pre">-no-pie</span> <span class="pre">-Wl,-z,noseparate-code</span> <span class="pre">-Wl,--build-id</span></code> are currently required to ensure the binary layout (executable segment at offset 0) and Build ID presence are compatible with the <code class="docutils literal notranslate"><span class="pre">llvm-profdata</span></code> profile reader.</p>
</div>
</section>
<section id="running-and-generating-profiles">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">Running and Generating Profiles</a><a class="headerlink" href="#running-and-generating-profiles" title="Link to this heading">¶</a></h3>
<p>Run the instrumented application. By default, MemProf writes a raw profile file named <code class="docutils literal notranslate"><span class="pre">memprof.profraw.&lt;pid&gt;</span></code> to the current directory upon exit. Control the runtime behavior using the <code class="docutils literal notranslate"><span class="pre">MEMPROF_OPTIONS</span></code> environment variable. Common options include:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">log_path</span></code>: Redirects runtime logs (e.g., <code class="docutils literal notranslate"><span class="pre">stdout</span></code>, <code class="docutils literal notranslate"><span class="pre">stderr</span></code>, or a file path).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">print_text</span></code>: If set to <code class="docutils literal notranslate"><span class="pre">true</span></code>, prints a text-based summary of the profile to the log path.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbosity</span></code>: Controls the level of debug output.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">MEMPROF_OPTIONS</span><span class="o">=</span><span class="nv">log_path</span><span class="o">=</span>stdout:print_text<span class="o">=</span><span class="nb">true</span><span class="w"> </span>./app
</pre></div>
</div>
</section>
<section id="processing-profiles">
<span id="id1"></span><h3><a class="toc-backref" href="#id7" role="doc-backlink">Processing Profiles</a><a class="headerlink" href="#processing-profiles" title="Link to this heading">¶</a></h3>
<p>Raw profiles must be indexed before the compiler can use them. Use <code class="docutils literal notranslate"><span class="pre">llvm-profdata</span></code> to merge and index the raw profiles.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>llvm-profdata<span class="w"> </span>merge<span class="w"> </span>memprof.profraw.*<span class="w"> </span>--profiled-binary<span class="w"> </span>./app<span class="w"> </span>-o<span class="w"> </span>memprof.memprofdata
</pre></div>
</div>
<p>To dump the profile in YAML format (useful for debugging or creating test cases):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>llvm-profdata<span class="w"> </span>show<span class="w"> </span>--memory<span class="w"> </span>memprof.memprofdata<span class="w"> </span>&gt;<span class="w"> </span>memprof.yaml
</pre></div>
</div>
<p>Merge MemProf profiles with standard PGO instrumentation profiles if you have both (optional).</p>
</section>
<section id="using-profiles-for-optimization">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Using Profiles for Optimization</a><a class="headerlink" href="#using-profiles-for-optimization" title="Link to this heading">¶</a></h3>
<p>Feed the indexed profile back into the compiler using the <code class="docutils literal notranslate"><span class="pre">-fmemory-profile-use=</span></code> option (or low-level passes options).</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>clang++<span class="w"> </span>-fmemory-profile-use<span class="o">=</span>memprof.memprofdata<span class="w"> </span>-O2<span class="w"> </span>-Wl,-mllvm,-enable-memprof-context-disambiguation<span class="w"> </span>-Wl,-mllvm,-optimize-hot-cold-new<span class="w"> </span>-Wl,-mllvm,-supports-hot-cold-new<span class="w"> </span>source.cpp<span class="w"> </span>-o<span class="w"> </span>optimized_app<span class="w"> </span>-ltcmalloc
</pre></div>
</div>
<p>If invoking the optimizer directly via <code class="docutils literal notranslate"><span class="pre">opt</span></code>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>opt<span class="w"> </span>-passes<span class="o">=</span><span class="s1">&#39;memprof-use&lt;profile-filename=memprof.memprofdata&gt;&#39;</span><span class="w"> </span>...
</pre></div>
</div>
<p>The compiler uses the profile data to annotate allocation instructions with <code class="docutils literal notranslate"><span class="pre">!memprof</span></code> metadata (<a class="reference external" href="https://llvm.org/docs/LangRef.html#memprof-metadata">MemProf Metadata Documentation</a>), distinguishing between “hot”, “cold”, and “notcold” allocations. This metadata guides downstream optimizations. Additionally, callsites which are part of allocation contexts are also annotated with <code class="docutils literal notranslate"><span class="pre">!callsite</span></code> metadata (<a class="reference external" href="https://llvm.org/docs/LangRef.html#callsite-metadata">Callsite Metadata Documentation</a>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Ensure that the same debug info flags (e.g. <code class="docutils literal notranslate"><span class="pre">-gmlt</span></code> and <code class="docutils literal notranslate"><span class="pre">-fdebug-info-for-profiling</span></code>) used during instrumentation are also passed during this compilation step to enable correct matching of the profile data.
For the optimized binary to fully utilize the hot/cold hinting, it must be linked with an allocator that supports this mechanism, such as <a class="reference external" href="https://github.com/google/tcmalloc">tcmalloc</a>. TCMalloc provides an API (<code class="docutils literal notranslate"><span class="pre">tcmalloc::hot_cold_t</span></code>) that accepts a hint (0 for cold, 255 for hot) to guide data placement and improve locality. To indicate that the library supports these interfaces, the <code class="docutils literal notranslate"><span class="pre">-mllvm</span> <span class="pre">-supports-hot-cold-new</span></code> flag is used during the LTO link.</p>
</div>
</section>
<section id="context-disambiguation-lto">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">Context Disambiguation (LTO)</a><a class="headerlink" href="#context-disambiguation-lto" title="Link to this heading">¶</a></h3>
<p>To fully benefit from MemProf, especially for common allocation wrappers, enabling <strong>ThinLTO</strong> (preferred) or <strong>Full LTO</strong> is required. This allows the compiler to perform <strong>context disambiguation</strong>.</p>
<p>Consider the following example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">allocate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">char</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span><span class="w"> </span><span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">hot_path</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// This path is executed frequently.</span>
<span class="w">  </span><span class="n">allocate</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">cold_path</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="c1">// This path is executed rarely.</span>
<span class="w">   </span><span class="n">allocate</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Without context disambiguation, the compiler sees a single <code class="docutils literal notranslate"><span class="pre">allocate</span></code> function called from both hot and cold contexts. It must conservatively assume the allocation is “not cold” or “ambiguous”.</p>
<p>With LTO and MemProf:</p>
<ol class="arabic simple">
<li><p>The compiler constructs a whole-program call graph.</p></li>
<li><p>It identifies that <code class="docutils literal notranslate"><span class="pre">allocate</span></code> has distinct calling contexts with different behaviors.</p></li>
<li><p>It <strong>clones</strong> <code class="docutils literal notranslate"><span class="pre">allocate</span></code> into two versions: one for the hot path and one for the cold path.</p></li>
<li><p>The call in <code class="docutils literal notranslate"><span class="pre">cold_path</span></code> is updated to call the cloned “cold” version of <code class="docutils literal notranslate"><span class="pre">allocate</span></code>, which can then be optimized (e.g., by passing a cold hint to the allocator).</p></li>
</ol>
</section>
<section id="static-data-partitioning">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Static Data Partitioning</a><a class="headerlink" href="#static-data-partitioning" title="Link to this heading">¶</a></h3>
<p>MemProf profiles guide the layout of static data (e.g., global variables, constants). The goal is to separate “hot” data from “cold” data in the binary, placing hot data into specific sections (e.g., <code class="docutils literal notranslate"><span class="pre">.rodata.hot</span></code>) to minimize the number of pages required for the working set.</p>
<p>This feature uses a hybrid approach:</p>
<ol class="arabic simple">
<li><p><strong>Symbolizable Data:</strong> Data with external or local linkage (tracked by the symbol table) is partitioned based on data access profiles collected via instrumentation (<a class="reference external" href="https://github.com/llvm/llvm-project/pull/142884">PR</a>) or hardware performance counters (e.g., Intel PEBS events such as <code class="docutils literal notranslate"><span class="pre">MEM_INST_RETIRED.ALL_LOADS</span></code>).</p></li>
<li><p><strong>Module-Internal Data:</strong> Data not tracked by the symbol table (e.g., jump tables, constant pools, internal globals) has its hotness inferred from standard PGO code execution profiles.</p></li>
</ol>
<p>To enable this feature, pass the following flags to the compiler:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-memprof-annotate-static-data-prefix</span></code>: Enables annotation of global variables in IR.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-split-static-data</span></code>: Enables partitioning of other data (like jump tables) in the backend.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-Wl,-z,keep-data-section-prefix</span></code>: Instructs the linker (LLD) to group hot and cold data sections together.</p></li>
</ul>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>clang++<span class="w"> </span>-fmemory-profile-use<span class="o">=</span>memprof.memprofdata<span class="w"> </span>-mllvm<span class="w"> </span>-memprof-annotate-static-data-prefix<span class="w"> </span>-mllvm<span class="w"> </span>-split-static-data<span class="w"> </span>-fuse-ld<span class="o">=</span>lld<span class="w"> </span>-Wl,-z,keep-data-section-prefix<span class="w"> </span>-O2<span class="w"> </span>source.cpp<span class="w"> </span>-o<span class="w"> </span>optimized_app
</pre></div>
</div>
<p>The optimized layout clusters hot static data, improving dTLB and cache efficiency.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For an LTO build -split-static-data needs to be passed to the LTO backend via the linker using <code class="docutils literal notranslate"><span class="pre">-Wl,-mllvm,-split-static-data</span></code>.</p>
</div>
</section>
</section>
<section id="developer-manual">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Developer Manual</a><a class="headerlink" href="#developer-manual" title="Link to this heading">¶</a></h2>
<p>This section provides an overview of the MemProf architecture and implementation for contributors.</p>
<section id="architecture-overview">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Architecture Overview</a><a class="headerlink" href="#architecture-overview" title="Link to this heading">¶</a></h3>
<p>MemProf consists of three main components:</p>
<ol class="arabic simple">
<li><p><strong>Instrumentation Pass (Compile-time):</strong> Memory accesses are instrumented to increment the access count held in a shadow memory location, or alternatively to call into the runtime. Memory allocations are intercepted by the runtime library.</p></li>
<li><p><strong>Runtime Library (Link-time/Run-time):</strong> Manages shadow memory and tracks allocation contexts and access statistics.</p></li>
<li><p><strong>Profile Analysis (Post-processing/Compile-time):</strong> Tools and passes that read the profile, annotate the IR using metadata, and perform context disambiguation if necessary when LTO is enabled.</p></li>
</ol>
</section>
<section id="detailed-workflow-lto">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Detailed Workflow (LTO)</a><a class="headerlink" href="#detailed-workflow-lto" title="Link to this heading">¶</a></h3>
<p>The optimization process, using LTO, involves several steps:</p>
<ol class="arabic simple">
<li><p><strong>Matching (MemProfUse Pass):</strong> The memprof profile is mapped onto allocation calls and callsites which are part of the allocation context using debug information. MemProf metadata is attached to the call instructions in the IR. If the allocation call site is unambiguously cold (or hot) an attribute is added directly which guides the transformation.</p></li>
<li><p><strong>Metadata Serialization:</strong> For ThinLTO, during the summary analysis step, MemProf metadata (<code class="docutils literal notranslate"><span class="pre">!memprof</span></code> and <code class="docutils literal notranslate"><span class="pre">!callsite</span></code>) is serialized into the module summary. This is implemented in <code class="docutils literal notranslate"><span class="pre">llvm/lib/Analysis/ModuleSummaryAnalysis.cpp</span></code>.</p></li>
<li><p><strong>Whole Program Graph Construction:</strong> During the LTO step, the compiler constructs a whole-program <code class="docutils literal notranslate"><span class="pre">CallsiteContextGraph</span></code> to analyze and disambiguate contexts. This graph identifies where allocation contexts diverge (e.g., same function called from hot vs. cold paths). This logic resides in <code class="docutils literal notranslate"><span class="pre">llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp</span></code>.</p></li>
<li><p><strong>Cloning Decisions:</strong> The analysis identifies which functions and callsites need to be cloned to isolate cold allocation paths from hot ones using the <code class="docutils literal notranslate"><span class="pre">CallsiteContextGraph</span></code>.</p></li>
<li><p><strong>LTO Backend:</strong> The actual cloning of functions happens in the <code class="docutils literal notranslate"><span class="pre">MemProfContextDisambiguation</span></code> pass. The replacement of allocation calls (e.g., <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">new</span></code> to the <code class="docutils literal notranslate"><span class="pre">hot_cold_t</span></code> variant) happens in <code class="docutils literal notranslate"><span class="pre">SimplifyLibCalls</span></code> during the <code class="docutils literal notranslate"><span class="pre">InstCombine</span></code> pass. These transformations are guided by the decisions made during the LTO step.</p></li>
</ol>
</section>
<section id="source-structure">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Source Structure</a><a class="headerlink" href="#source-structure" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><strong>Runtime:</strong> <code class="docutils literal notranslate"><span class="pre">compiler-rt/lib/memprof</span></code></p>
<ul>
<li><p>Contains the runtime implementation, including shadow memory mapping, interceptors (malloc, free, etc.), and the thread-local storage for recording stats.</p></li>
</ul>
</li>
<li><p><strong>Instrumentation:</strong> <code class="docutils literal notranslate"><span class="pre">llvm/lib/Transforms/Instrumentation/MemProfInstrumentation.cpp</span></code></p>
<ul>
<li><p>Implements the LLVM IR pass that adds instrumentation calls.</p></li>
</ul>
</li>
<li><p><strong>Profile Data:</strong> <code class="docutils literal notranslate"><span class="pre">llvm/include/llvm/ProfileData/MemProf.h</span></code> and <code class="docutils literal notranslate"><span class="pre">MemProfData.inc</span></code></p>
<ul>
<li><p>Defines the profile format, data structures (like <code class="docutils literal notranslate"><span class="pre">MemInfoBlock</span></code>), and serialization logic.</p></li>
</ul>
</li>
<li><p><strong>Use Pass:</strong> <code class="docutils literal notranslate"><span class="pre">llvm/lib/Transforms/Instrumentation/MemProfUse.cpp</span></code></p>
<ul>
<li><p>Reads the profile and annotates the IR with metadata.</p></li>
</ul>
</li>
<li><p><strong>Context Disambiguation:</strong> <code class="docutils literal notranslate"><span class="pre">llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp</span></code></p>
<ul>
<li><p>Implements the analysis and transformations (e.g., cloning) for resolving ambiguous allocation contexts using LTO.</p></li>
</ul>
</li>
<li><p><strong>Transformation:</strong> <code class="docutils literal notranslate"><span class="pre">llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp</span></code></p>
<ul>
<li><p>Implements the rewriting of allocation calls based on the hot/cold hints.</p></li>
</ul>
</li>
<li><p><strong>Static Data Partitioning:</strong> <code class="docutils literal notranslate"><span class="pre">llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp</span></code>, <code class="docutils literal notranslate"><span class="pre">llvm/lib/CodeGen/StaticDataSplitter.cpp</span></code>, and <code class="docutils literal notranslate"><span class="pre">llvm/lib/CodeGen/StaticDataAnnotator.cpp</span></code></p>
<ul>
<li><p>Implements the splitting of static data (Jump tables, Module-internal global variables, and Constant pools) into hot and cold sections using branch profile data. <code class="docutils literal notranslate"><span class="pre">StaticDataAnnotator</span></code> iterates over global variables and sets their section prefixes based on the profile analysis from <code class="docutils literal notranslate"><span class="pre">StaticDataSplitter</span></code>.</p></li>
</ul>
</li>
</ul>
</section>
<section id="runtime-implementation">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">Runtime Implementation</a><a class="headerlink" href="#runtime-implementation" title="Link to this heading">¶</a></h3>
<p>The runtime uses a <strong>shadow memory</strong> scheme similar to AddressSanitizer (ASan) but optimized for profiling.</p>
<ul class="simple">
<li><p><strong>Shadow Mapping:</strong> Application memory is mapped to shadow memory.</p></li>
<li><p><strong>Granularity:</strong> The default granularity is 64 bytes. One byte of shadow memory tracks the access state of 64 bytes of application memory.</p></li>
<li><p><strong>MemInfoBlock (MIB):</strong> A key data structure that stores statistics for an allocation context, including: <code class="docutils literal notranslate"><span class="pre">AllocCount</span></code>, <code class="docutils literal notranslate"><span class="pre">TotalAccessCount</span></code>, <code class="docutils literal notranslate"><span class="pre">TotalLifetime</span></code>, and <code class="docutils literal notranslate"><span class="pre">Min/MaxAccessDensity</span></code>.</p></li>
</ul>
</section>
<section id="profile-format">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">Profile Format</a><a class="headerlink" href="#profile-format" title="Link to this heading">¶</a></h3>
<p>The MemProf profile is a schema-based binary format designed for extensibility. Key structures include:</p>
<ul class="simple">
<li><p><strong>Frame:</strong> Represents a function in the call stack (Function GUID, Line, Column).</p></li>
<li><p><strong>CallStack:</strong> A sequence of Frames identifying the context of an allocation.</p></li>
<li><p><strong>MemInfoBlock:</strong> The statistics gathered for a specific CallStack.</p></li>
</ul>
<p>The format supports versioning to allow adding new fields to the MIB without breaking backward compatibility.</p>
<section id="static-data-profile">
<h4>Static Data Profile<a class="headerlink" href="#static-data-profile" title="Link to this heading">¶</a></h4>
<p>To support static data partitioning, the profile format includes a payload for symbolized data access profiles. This maps data addresses to canonical symbol names (or module source location for internal data) and access counts. This enables the compiler to identify which global variables are hot.</p>
<p>Testing</p>
<hr class="docutils" />
<p>When making changes to MemProf, verify your changes using the following test suites:</p>
<ol class="arabic simple">
<li><p><strong>Runtime Tests:</strong></p>
<ul class="simple">
<li><p>Location: <code class="docutils literal notranslate"><span class="pre">compiler-rt/test/memprof</span></code></p></li>
<li><p>Purpose: Verify the runtime instrumentation, shadow memory behavior, and profile generation.</p></li>
</ul>
</li>
<li><p><strong>Profile Manipulation Tests:</strong></p>
<ul class="simple">
<li><p>Location: <code class="docutils literal notranslate"><span class="pre">llvm/test/tools/llvm-profdata</span></code></p></li>
<li><p>Purpose: Verify that <code class="docutils literal notranslate"><span class="pre">llvm-profdata</span></code> can correctly merge, show, and handle MemProf profiles.</p></li>
</ul>
</li>
<li><p><strong>Instrumentation &amp; Optimization Tests:</strong></p>
<ul class="simple">
<li><p>Location: <code class="docutils literal notranslate"><span class="pre">llvm/test/Transforms/PGOProfile</span></code></p></li>
<li><p>Purpose: Verify the correctness of the <code class="docutils literal notranslate"><span class="pre">MemProfUse</span></code> pass, metadata annotation, and IR transformations.</p></li>
</ul>
</li>
<li><p><strong>ThinLTO &amp; Context Disambiguation Tests:</strong></p>
<ul class="simple">
<li><p>Location: <code class="docutils literal notranslate"><span class="pre">llvm/test/ThinLTO/X86/memprof*</span></code> and <code class="docutils literal notranslate"><span class="pre">llvm/test/Transforms/MemProfContextDisambiguation</span></code></p></li>
<li><p>Purpose: Verify context disambiguation, cloning, and summary analysis during ThinLTO and LTO.</p></li>
</ul>
</li>
</ol>
</section>
</section>
<section id="testing-with-yaml-profiles">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">Testing with YAML Profiles</a><a class="headerlink" href="#testing-with-yaml-profiles" title="Link to this heading">¶</a></h3>
<p>You can create MemProf profiles in YAML format for testing purposes. This is useful for creating small, self-contained test cases without needing to run a binary.</p>
<ol class="arabic">
<li><p><strong>Create a YAML Profile:</strong> You can start by dumping a real profile to YAML (see <a class="reference internal" href="#processing-profiles"><span class="std std-ref">Processing Profiles</span></a> above) or writing one from scratch.</p></li>
<li><p><strong>Convert to Indexed Format:</strong> Use <code class="docutils literal notranslate"><span class="pre">llvm-profdata</span></code> to convert the YAML to the indexed MemProf format.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>llvm-profdata<span class="w"> </span>merge<span class="w"> </span>--memprof-version<span class="o">=</span><span class="m">4</span><span class="w"> </span>profile.yaml<span class="w"> </span>-o<span class="w"> </span>profile.memprofdata
</pre></div>
</div>
</li>
<li><p><strong>Run the Compiler:</strong> Use the indexed profile with <code class="docutils literal notranslate"><span class="pre">opt</span></code> or <code class="docutils literal notranslate"><span class="pre">clang</span></code>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>opt<span class="w"> </span>-passes<span class="o">=</span><span class="s1">&#39;memprof-use&lt;profile-filename=profile.memprofdata&gt;&#39;</span><span class="w"> </span>test.ll<span class="w"> </span>-S
</pre></div>
</div>
</li>
</ol>
<p><strong>Example YAML Profile:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">---</span>
<span class="n">HeapProfileRecords</span><span class="p">:</span>
  <span class="o">-</span> <span class="n">GUID</span><span class="p">:</span>            <span class="n">_Z3foov</span>
    <span class="n">AllocSites</span><span class="p">:</span>
      <span class="o">-</span> <span class="n">Callstack</span><span class="p">:</span>
          <span class="o">-</span> <span class="p">{</span> <span class="n">Function</span><span class="p">:</span> <span class="n">_Z3foov</span><span class="p">,</span> <span class="n">LineOffset</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Column</span><span class="p">:</span> <span class="mi">22</span><span class="p">,</span> <span class="n">IsInlineFrame</span><span class="p">:</span> <span class="n">false</span> <span class="p">}</span>
          <span class="o">-</span> <span class="p">{</span> <span class="n">Function</span><span class="p">:</span> <span class="n">main</span><span class="p">,</span> <span class="n">LineOffset</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">Column</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="n">IsInlineFrame</span><span class="p">:</span> <span class="n">false</span> <span class="p">}</span>
        <span class="n">MemInfoBlock</span><span class="p">:</span>
          <span class="n">TotalSize</span><span class="p">:</span>                  <span class="mi">400</span>
          <span class="n">AllocCount</span><span class="p">:</span>                 <span class="mi">1</span>
          <span class="n">TotalLifetimeAccessDensity</span><span class="p">:</span> <span class="mi">1</span>
          <span class="n">TotalLifetime</span><span class="p">:</span>              <span class="mi">1000000</span>
    <span class="n">CallSites</span><span class="p">:</span>       <span class="p">[]</span>
<span class="o">...</span>
</pre></div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="MergeFunctions.html" title="MergeFunctions pass, how it works"
             >next</a> |</li>
        <li class="right" >
          <a href="MemorySSA.html" title="MemorySSA"
             >previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" >User Guides</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">MemProf: Memory Profiling for LLVM</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2003-2026, LLVM Project.
      Last updated on 2026-01-16.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>