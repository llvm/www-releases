

<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Runtime Descriptors &#8212; The Flang Compiler</title>
    <link rel="stylesheet" href="_static/llvm.css" type="text/css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="The derived type runtime information table" href="RuntimeTypeInfo.html" />
    <link rel="prev" title="Fortran Preprocessing" href="Preprocessing.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="RuntimeTypeInfo.html" title="The derived type runtime information table"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Preprocessing.html" title="Fortran Preprocessing"
             accesskey="P">previous</a> |</li>
<! TODO: Change the webpage  >
  <li><a href="https://flang.llvm.org">Flang Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

        <li class="nav-item nav-item-this"><a href="">Runtime Descriptors</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://github.com/llvm/llvm-project/blob/main/flang/README.md#getting-started">Getting Started</a></li>
</ul>

<h3>Getting Involved</h3>
<! TODO: Point links to website(flang.llvm.org) and not github once webpage comes up.>
<ul class="want-points">
    <li><a href="https://github.com/llvm/llvm-project/blob/main/flang/docs/GettingInvolved.md#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://github.com/llvm/llvm-project/blob/main/flang/docs/GettingInvolved.md#chat">Slack</a></li>
    <li><a href="https://github.com/llvm/llvm-project/blob/main/flang/docs/GettingInvolved.md#calls">Calls</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://github.com/llvm/llvm-project/tree/main/flang/">Github Repository</a></li>
    <li><a href="https://bugs.llvm.org/">Bug Reports</a></li>
    <li><a href="https://reviews.llvm.org/">Code Review</a></li>
<! TODO: Have the bots setup first>
    <li><a href="#">Doxygen API</a></li>
</ul>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <!--===- docs/RuntimeDescriptor.md 
  
   Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
   See https://llvm.org/LICENSE.txt for license information.
   SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
  
--><div class="section" id="runtime-descriptors">
<h1>Runtime Descriptors<a class="headerlink" href="#runtime-descriptors" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#concept" id="id1">Concept</a></p>
<ul>
<li><p><a class="reference internal" href="#references" id="id2">References</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#a-survey-of-dynamic-characteristics" id="id3">A survey of dynamic characteristics</a></p>
<ul>
<li><p><a class="reference internal" href="#length-of-assumed-length-character-function-results-b-3-6" id="id4">Length of assumed-length <code class="docutils literal notranslate"><span class="pre">CHARACTER</span></code> function results (B.3.6)</a></p></li>
<li><p><a class="reference internal" href="#assumed-length-type-parameters-7-2" id="id5">Assumed length type parameters (7.2)</a></p></li>
<li><p><a class="reference internal" href="#explicit-shape-arrays-8-5-8-2" id="id6">Explicit-shape arrays (8.5.8.2)</a></p></li>
<li><p><a class="reference internal" href="#leading-dimensions-of-assumed-size-arrays-8-5-8-5" id="id7">Leading dimensions of assumed-size arrays (8.5.8.5)</a></p></li>
<li><p><a class="reference internal" href="#some-function-results" id="id8">Some function results</a></p></li>
<li><p><a class="reference internal" href="#assumed-shape-arrays" id="id9">Assumed-shape arrays</a></p></li>
<li><p><a class="reference internal" href="#deferred-shape-arrays" id="id10">Deferred-shape arrays</a></p></li>
<li><p><a class="reference internal" href="#strides" id="id11">Strides</a></p></li>
<li><p><a class="reference internal" href="#derived-type-component-initializers" id="id12">Derived type component initializers</a></p></li>
<li><p><a class="reference internal" href="#polymorphic-class-class-and-type" id="id13">Polymorphic <code class="docutils literal notranslate"><span class="pre">CLASS()</span></code>, <code class="docutils literal notranslate"><span class="pre">CLASS(*)</span></code>, and <code class="docutils literal notranslate"><span class="pre">TYPE(*)</span></code></a></p></li>
<li><p><a class="reference internal" href="#deferred-length-type-parameters" id="id14">Deferred length type parameters</a></p></li>
<li><p><a class="reference internal" href="#components-whose-types-and-or-shape-depends-on-length-type-parameters" id="id15">Components whose types and/or shape depends on length type parameters</a></p></li>
<li><p><a class="reference internal" href="#assumed-rank-arrays" id="id16">Assumed rank arrays</a></p></li>
<li><p><a class="reference internal" href="#cached-invariant-subexpressions-for-addressing" id="id17">Cached invariant subexpressions for addressing</a></p></li>
<li><p><a class="reference internal" href="#coarray-state-8-5-6" id="id18">Coarray state (8.5.6)</a></p></li>
<li><p><a class="reference internal" href="#presence-of-optional-dummy-arguments" id="id19">Presence of <code class="docutils literal notranslate"><span class="pre">OPTIONAL</span></code> dummy arguments</a></p></li>
<li><p><a class="reference internal" href="#stronger-contiguity-enforcement-or-indication" id="id20">Stronger contiguity enforcement or indication</a></p></li>
<li><p><a class="reference internal" href="#host-instances-for-dummy-procedures-and-procedure-pointers" id="id21">Host instances for dummy procedures and procedure pointers</a></p></li>
<li><p><a class="reference internal" href="#alternate-returns" id="id22">Alternate returns</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#implementation-options" id="id23">Implementation options</a></p>
<ul>
<li><p><a class="reference internal" href="#a-note-on-array-descriptions" id="id24">A note on array descriptions</a></p></li>
<li><p><a class="reference internal" href="#interoperability-requirements" id="id25">Interoperability requirements</a></p></li>
<li><p><a class="reference internal" href="#design-space" id="id26">Design space</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#proposal" id="id27">Proposal</a></p></li>
</ul>
</div>
<div class="section" id="concept">
<h2><a class="toc-backref" href="#id1">Concept</a><a class="headerlink" href="#concept" title="Permalink to this headline">¶</a></h2>
<p>The properties that characterize data values and objects in Fortran
programs must sometimes be materialized when the program runs.</p>
<p>Some properties are known during compilation and constant during
execution, yet must be reified anyway for execution in order to
drive the interfaces of a language support library or the mandated
interfaces of interoperable (i.e., C) procedure calls.</p>
<p>Note that many Fortran intrinsic subprograms have interfaces
that are more flexible and generic than actual Fortran subprograms
can be, so properties that must be known during compilation and
are constant during execution may still need to be materialized
for calls to the library, even if only by modifying names to
distinguish types or their kind specializations.</p>
<p>Other properties are deferred to execution, and need to be represented
to serve the needs of compiled code and the run time support library.</p>
<p>Previous implementations of Fortran have typically defined a small
sheaf of <em>descriptor</em> data structures for this purpose, and attached
these descriptors as additional hidden arguments, type components,
and local variables so as to convey dynamic characteristics between
subprograms and between user code and the run-time support library.</p>
<div class="section" id="references">
<h3><a class="toc-backref" href="#id2">References</a><a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h3>
<p>References are to the 12-2017 draft of the Fortran 2018 standard
(N2146).</p>
<p>Section 15.4.2.2 can be interpreted as a decent list of things that
might need descriptors or other hidden state passed across a
subprogram call, since such features (apart from assumed-length
<code class="docutils literal notranslate"><span class="pre">CHARACTER</span></code> function results) trigger a requirement for the
subprogram to have an explicit interface visible to their callers.</p>
<p>Section 15.5.2 has good laundry lists of situations that can arise
across subprogram call boundaries.</p>
</div>
</div>
<div class="section" id="a-survey-of-dynamic-characteristics">
<h2><a class="toc-backref" href="#id3">A survey of dynamic characteristics</a><a class="headerlink" href="#a-survey-of-dynamic-characteristics" title="Permalink to this headline">¶</a></h2>
<div class="section" id="length-of-assumed-length-character-function-results-b-3-6">
<h3><a class="toc-backref" href="#id4">Length of assumed-length <code class="docutils literal notranslate"><span class="pre">CHARACTER</span></code> function results (B.3.6)</a><a class="headerlink" href="#length-of-assumed-length-character-function-results-b-3-6" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CHARACTER</span><span class="o">*</span><span class="mi">8</span> <span class="p">::</span> <span class="n">FOO</span>
<span class="n">PRINT</span> <span class="o">*</span><span class="p">,</span> <span class="n">FOO</span><span class="p">(</span><span class="s1">&#39;abcdefghijklmnopqrstuvwxyz&#39;</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">CHARACTER</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="n">FUNCTION</span> <span class="n">FOO</span><span class="p">(</span><span class="n">STR</span><span class="p">)</span>
  <span class="n">CHARACTER</span><span class="o">*</span><span class="mi">26</span> <span class="n">STR</span>
  <span class="n">FOO</span><span class="o">=</span><span class="n">STR</span>
<span class="n">END</span>
</pre></div>
</div>
<p>prints <code class="docutils literal notranslate"><span class="pre">abcdefgh</span></code> because the length parameter of the character type
of the result of <code class="docutils literal notranslate"><span class="pre">FOO</span></code> is passed across the call – even in the absence
of an explicit interface!</p>
</div>
<div class="section" id="assumed-length-type-parameters-7-2">
<h3><a class="toc-backref" href="#id5">Assumed length type parameters (7.2)</a><a class="headerlink" href="#assumed-length-type-parameters-7-2" title="Permalink to this headline">¶</a></h3>
<p>Dummy arguments and associate names for <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">TYPE</span></code> can have assumed length
type parameters, which are denoted by asterisks (not colons).
Their values come from actual arguments or the associated expression (resp.).</p>
</div>
<div class="section" id="explicit-shape-arrays-8-5-8-2">
<h3><a class="toc-backref" href="#id6">Explicit-shape arrays (8.5.8.2)</a><a class="headerlink" href="#explicit-shape-arrays-8-5-8-2" title="Permalink to this headline">¶</a></h3>
<p>The expressions used for lower and upper bounds must be captured and remain
invariant over the scope of an array, even if they contain references to
variables that are later modified.</p>
<p>Explicit-shape arrays can be dummy arguments, “adjustable” local variables,
and components of derived type (using specification expressions in terms
of constants and KIND type parameters).</p>
</div>
<div class="section" id="leading-dimensions-of-assumed-size-arrays-8-5-8-5">
<h3><a class="toc-backref" href="#id7">Leading dimensions of assumed-size arrays (8.5.8.5)</a><a class="headerlink" href="#leading-dimensions-of-assumed-size-arrays-8-5-8-5" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SUBROUTINE</span> <span class="n">BAR</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
  <span class="n">REAL</span> <span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">*</span><span class="p">)</span>
<span class="n">END</span>
</pre></div>
</div>
<p>The total size and final dimension’s extent do not constitute dynamic
properties.
The called subprogram has no means to extract the extent of the
last (major) dimension, and may not depend upon it implicitly by using
the array in any context that demands a known shape.</p>
<p>The values of the expressions used as the bounds of the dimensions
that appear prior to
the last dimension are, however, effectively captured on entry to the
subprogram, and remain invariant even if the variables that appear in
those expressions have their values modified later.
This is similar to the requirements for an explicit-shape array.</p>
</div>
<div class="section" id="some-function-results">
<h3><a class="toc-backref" href="#id8">Some function results</a><a class="headerlink" href="#some-function-results" title="Permalink to this headline">¶</a></h3>
<ol class="simple">
<li><p>Deferred-shape</p></li>
<li><p>Deferred length type parameter values</p></li>
<li><p>Stride information for <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> results</p></li>
</ol>
<p>Note that while function result variables can have the <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code>
attribute, the function itself and the value returned to the caller
do not possess the attribute.</p>
</div>
<div class="section" id="assumed-shape-arrays">
<h3><a class="toc-backref" href="#id9">Assumed-shape arrays</a><a class="headerlink" href="#assumed-shape-arrays" title="Permalink to this headline">¶</a></h3>
<p>The extents of the dimensions of assumed-shape dummy argument arrays
are conveyed from those of the actual effective arguments.
The bounds, however, are not.  The called subprogram can define the
lower bound to be a value other than 1, but that is a local effect
only.</p>
</div>
<div class="section" id="deferred-shape-arrays">
<h3><a class="toc-backref" href="#id10">Deferred-shape arrays</a><a class="headerlink" href="#deferred-shape-arrays" title="Permalink to this headline">¶</a></h3>
<p>The extents and bounds of <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> and <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> arrays are
established by pointer assignments and <code class="docutils literal notranslate"><span class="pre">ALLOCATE</span></code> statements.
Note that dummy arguments and function results that are <code class="docutils literal notranslate"><span class="pre">POINTER</span></code>
or <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> can be deferred-shape, not assumed-shape – one cannot
supply a lower bound expression as a local effect.</p>
</div>
<div class="section" id="strides">
<h3><a class="toc-backref" href="#id11">Strides</a><a class="headerlink" href="#strides" title="Permalink to this headline">¶</a></h3>
<p>Some arrays can have discontiguous (or negative) strides.
These include assumed-shape dummy arguments and deferred-shape
<code class="docutils literal notranslate"><span class="pre">POINTER</span></code> variables, components, and function results.</p>
<p>Fortran disallows some conceivable cases that might otherwise
require implied strides, such as passing an array of an extended
derived type as an actual argument that corresponds to a
nonpolymorphic dummy array of a base type, or the similar
case of pointer assignment to a base of an extended derived type.</p>
<p>Other arrays, including <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code>, can be assured to
be contiguous, and do not necessarily need to manage or
convey dynamic stride information.
<code class="docutils literal notranslate"><span class="pre">CONTIGUOUS</span></code> dummy arguments and <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> arrays need not
record stride information either.
(The standard notes that a <code class="docutils literal notranslate"><span class="pre">CONTIGUOUS</span> <span class="pre">POINTER</span></code> occupies a
number of storage units that is distinct from that required
to hold a non-<code class="docutils literal notranslate"><span class="pre">CONTIGUOUS</span></code> pointer.)</p>
<p>Note that Fortran distinguishes the <code class="docutils literal notranslate"><span class="pre">CONTIGUOUS</span></code> attribute from
the concept of being known or required to be <em>simply contiguous</em> (9.5.4),
which includes <code class="docutils literal notranslate"><span class="pre">CONTIGUOUS</span></code> entities as well as many others, and
the concept of actually <em>being</em> contiguous (8.5.7) during execution.
I believe that the property of being simply contiguous implies
that an entity is known at compilation time to not require the
use or maintenance of hidden stride values.</p>
</div>
<div class="section" id="derived-type-component-initializers">
<h3><a class="toc-backref" href="#id12">Derived type component initializers</a><a class="headerlink" href="#derived-type-component-initializers" title="Permalink to this headline">¶</a></h3>
<p>Fortran allows components of derived types to be declared with
initial values that are to be assigned to the components when an
instance of the derived type is created.
These include <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> components, which are always initialized
to a deallocated state.</p>
<p>These can be implemented with constructor subroutines, inline
stores or block copies from static initializer blocks, or a sequence
of sparse offset/size/value component initializers to be emplaced
by the run-time library.</p>
<p>N.B. Fortran allows kind type parameters to appear in component
initialization constant expressions, but not length type parameters,
so the initialization values are constants.</p>
<p>N.B. Initialization is not assignment, and cannot be implemented
with assignments to uninitialized derived type instances from
static constant initializers.</p>
</div>
<div class="section" id="polymorphic-class-class-and-type">
<h3><a class="toc-backref" href="#id13">Polymorphic <code class="docutils literal notranslate"><span class="pre">CLASS()</span></code>, <code class="docutils literal notranslate"><span class="pre">CLASS(*)</span></code>, and <code class="docutils literal notranslate"><span class="pre">TYPE(*)</span></code></a><a class="headerlink" href="#polymorphic-class-class-and-type" title="Permalink to this headline">¶</a></h3>
<p>Type identification for <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">TYPE</span></code>.
Default initializers (see above).
Offset locations of <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> and polymorphic components.
Presence of <code class="docutils literal notranslate"><span class="pre">FINAL</span></code> procedures.
Mappings to overridable type-bound specific procedures.</p>
</div>
<div class="section" id="deferred-length-type-parameters">
<h3><a class="toc-backref" href="#id14">Deferred length type parameters</a><a class="headerlink" href="#deferred-length-type-parameters" title="Permalink to this headline">¶</a></h3>
<p>Derived types with length type parameters, and <code class="docutils literal notranslate"><span class="pre">CHARACTER</span></code>, may be used
with the values of those parameters deferred to execution.
Their actual values must be maintained as characteristics of the dynamic
type that is associated with a value or object
.
A single copy of the deferred length type parameters suffices for
all of the elements of an array of that parameterized derived type.</p>
</div>
<div class="section" id="components-whose-types-and-or-shape-depends-on-length-type-parameters">
<h3><a class="toc-backref" href="#id15">Components whose types and/or shape depends on length type parameters</a><a class="headerlink" href="#components-whose-types-and-or-shape-depends-on-length-type-parameters" title="Permalink to this headline">¶</a></h3>
<p>Non-pointer, non-allocatable components whose types or shapes are expressed
in terms of length type parameters will probably have to be implemented as
if they had deferred type and/or shape and were <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code>.
The derived type instance constructor must allocate them and possibly
initialize them; the instance destructor must deallocate them.</p>
</div>
<div class="section" id="assumed-rank-arrays">
<h3><a class="toc-backref" href="#id16">Assumed rank arrays</a><a class="headerlink" href="#assumed-rank-arrays" title="Permalink to this headline">¶</a></h3>
<p>Rank is almost always known at compilation time and would be redundant
in most circumstances if also managed dynamically.
<code class="docutils literal notranslate"><span class="pre">DIMENSION(..)</span></code> dummy arguments (8.5.8.7), however, are a recent feature
with which the rank of a whole array is dynamic outside the cases of
a <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">RANK</span></code> construct.</p>
<p>The lower bounds of the dimensions of assumed rank arrays
are always 1.</p>
</div>
<div class="section" id="cached-invariant-subexpressions-for-addressing">
<h3><a class="toc-backref" href="#id17">Cached invariant subexpressions for addressing</a><a class="headerlink" href="#cached-invariant-subexpressions-for-addressing" title="Permalink to this headline">¶</a></h3>
<p>Implementations of Fortran have often maintained precalculated integer
values to accelerate subscript computations.
For example, given <code class="docutils literal notranslate"><span class="pre">REAL*8</span> <span class="pre">::</span> <span class="pre">A(2:4,3:5)</span></code>, the data reference <code class="docutils literal notranslate"><span class="pre">A(I,J)</span></code>
resolves to something like <code class="docutils literal notranslate"><span class="pre">&amp;A</span> <span class="pre">+</span> <span class="pre">8*((I-2)+3*(J-3))</span></code>, and this can be
effectively reassociated to <code class="docutils literal notranslate"><span class="pre">&amp;A</span> <span class="pre">-</span> <span class="pre">88</span> <span class="pre">+</span> <span class="pre">8*I</span> <span class="pre">+</span> <span class="pre">24*J</span></code>
or <code class="docutils literal notranslate"><span class="pre">&amp;A</span> <span class="pre">-</span> <span class="pre">88</span> <span class="pre">+</span> <span class="pre">8*(I</span> <span class="pre">+</span> <span class="pre">3*J)</span></code>.
When the offset term and coefficients are not compile-time constants,
they are at least invariant and can be precomputed.</p>
<p>In the cases of dummy argument arrays, <code class="docutils literal notranslate"><span class="pre">POINTER</span></code>, and <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code>,
these addressing invariants could be managed alongside other dynamic
information like deferred extents and lower bounds to avoid their
recalculation.
It’s not clear that it’s worth the trouble to do so, since the
expressions are invariant and cheap.</p>
</div>
<div class="section" id="coarray-state-8-5-6">
<h3><a class="toc-backref" href="#id18">Coarray state (8.5.6)</a><a class="headerlink" href="#coarray-state-8-5-6" title="Permalink to this headline">¶</a></h3>
<p>A <em>coarray</em> is an <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> variable or component, or statically
allocated variable (<code class="docutils literal notranslate"><span class="pre">SAVE</span></code> attribute explicit or implied), or dummy
argument whose ultimate effective argument is one of such things.</p>
<p>Each image in a team maintains its portion of each coarray and can
access those portions of the coarray that are maintained by other images
in the team.
Allocations and deallocations are synchronization events at which
the several images can exchange whatever information is needed by
the underlying intercommunication interface to access the data
of their peers.
(Strictly speaking, an implementation could synchronize
images at allocations and deallocations with simple barriers, and defer
the communication of remote access information until it is needed for a
given coarray on a given image, so long as it could be acquired in a
“one-sided” fashion.)</p>
</div>
<div class="section" id="presence-of-optional-dummy-arguments">
<h3><a class="toc-backref" href="#id19">Presence of <code class="docutils literal notranslate"><span class="pre">OPTIONAL</span></code> dummy arguments</a><a class="headerlink" href="#presence-of-optional-dummy-arguments" title="Permalink to this headline">¶</a></h3>
<p>Typically indicated with null argument addresses.
Note that <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> and <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> objects can be passed to
non-<code class="docutils literal notranslate"><span class="pre">POINTER</span></code> non-<code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> dummy arguments, and their
association or allocation status (resp.) determines the presence
of the dummy argument.</p>
</div>
<div class="section" id="stronger-contiguity-enforcement-or-indication">
<h3><a class="toc-backref" href="#id20">Stronger contiguity enforcement or indication</a><a class="headerlink" href="#stronger-contiguity-enforcement-or-indication" title="Permalink to this headline">¶</a></h3>
<p>Some implementations of Fortran guarantee that dummy argument arrays
are, or have been made to be, contiguous on one or more dimensions
when the language does not require them to be so (8.5.7 p2).
Others pass a flag to identify contiguous arrays (or could pass the
number of contiguous leading dimensions, although I know of no such
implementation) so that optimizing transformations that depend on
contiguity can be made conditional with multiple-version code generation
and selected during execution.</p>
<p>In the absence of a contiguity guarantee or flag, the called side
would have to determine contiguity dynamically, if it cares,
by calculating addresses of elements in the array whose subscripts
differ by exactly 1 on exactly 1 dimension of interest, and checking
whether that difference exactly matches the byte size of the type times
the product of the extents of any prior dimensions.</p>
</div>
<div class="section" id="host-instances-for-dummy-procedures-and-procedure-pointers">
<h3><a class="toc-backref" href="#id21">Host instances for dummy procedures and procedure pointers</a><a class="headerlink" href="#host-instances-for-dummy-procedures-and-procedure-pointers" title="Permalink to this headline">¶</a></h3>
<p>A static link or other means of accessing the imported state of the
host procedure must be available when an internal procedure is
used as an actual argument or as a pointer assignment target.</p>
</div>
<div class="section" id="alternate-returns">
<h3><a class="toc-backref" href="#id22">Alternate returns</a><a class="headerlink" href="#alternate-returns" title="Permalink to this headline">¶</a></h3>
<p>Subroutines (only) with alternate return arguments need a
means, such as the otherwise unused function return value, by which
to distinguish and identify the use of an alternate <code class="docutils literal notranslate"><span class="pre">RETURN</span></code> statement.
The protocol can be a simple nonzero integer that drives a switch
in the caller, or the caller can pass multiple return addresses as
arguments for the callee to substitute on the stack for the original
return address in the event of an alternate <code class="docutils literal notranslate"><span class="pre">RETURN</span></code>.</p>
</div>
</div>
<div class="section" id="implementation-options">
<h2><a class="toc-backref" href="#id23">Implementation options</a><a class="headerlink" href="#implementation-options" title="Permalink to this headline">¶</a></h2>
<div class="section" id="a-note-on-array-descriptions">
<h3><a class="toc-backref" href="#id24">A note on array descriptions</a><a class="headerlink" href="#a-note-on-array-descriptions" title="Permalink to this headline">¶</a></h3>
<p>Some arrays require dynamic management of distinct combinations of
values per dimension.</p>
<p>One can extract the extent on a dimension from its bounds, or extract
the upper bound from the extent and the lower bound.  Having distinct
extent and upper bound would be redundant.</p>
<p>Contiguous arrays can assume a stride of 1 on each dimension.</p>
<p>Assumed-shape and assumed-size dummy argument arrays need not convey
lower bounds.</p>
<p>So there are examples of dimensions with</p>
<ul class="simple">
<li><p>extent only (== upper bound): <code class="docutils literal notranslate"><span class="pre">CONTIGUOUS</span></code> assumed-shape, explict shape and multidimensional assumed-size with constant lower bound</p></li>
<li><p>lower bound and either extent or upper bound: <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code>, <code class="docutils literal notranslate"><span class="pre">CONTIGUOUS</span></code> <code class="docutils literal notranslate"><span class="pre">POINTER</span></code>, general explicit-shape and multidimensional assumed-size</p></li>
<li><p>extent (== upper bound) and stride: general (non-<code class="docutils literal notranslate"><span class="pre">CONTIGUOUS</span></code>) assumed-shape</p></li>
<li><p>lower bound, stride, and either extent or upper bound: general (non-<code class="docutils literal notranslate"><span class="pre">CONTIGUOUS</span></code>) <code class="docutils literal notranslate"><span class="pre">POINTER</span></code>, assumed-rank</p></li>
</ul>
<p>and these cases could be accompanied by precomputed invariant
addressing subexpressions to accelerate indexing calculations.</p>
</div>
<div class="section" id="interoperability-requirements">
<h3><a class="toc-backref" href="#id25">Interoperability requirements</a><a class="headerlink" href="#interoperability-requirements" title="Permalink to this headline">¶</a></h3>
<p>Fortran 2018 requires that a Fortran implementation supply a header file
<code class="docutils literal notranslate"><span class="pre">ISO_Fortran_binding.h</span></code> for use in C and C++ programs that defines and
implements an interface to Fortran objects from the <em>interoperable</em>
subset of Fortran objects and their types suitable for use when those
objects are passed to C functions.
This interface mandates a fat descriptor that is passed by address,
containing (at least)</p>
<ul class="simple">
<li><p>a data base address</p></li>
<li><p>explicit rank and type</p></li>
<li><p>flags to distinguish <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> and <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code></p></li>
<li><p>elemental byte size, and</p></li>
<li><p>(per-dimension) lower bound, extent, and byte stride</p></li>
</ul>
<p>The requirements on the interoperability API do not mandate any
support for features like derived type component initialization,
automatic deallocation of <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> components, finalization,
derived type parameters, data contiguity flags, &amp;c.
But neither does the Standard preclude inclusion of additional
interfaces to describe and support such things.</p>
<p>Given a desire to fully support the Fortran 2018 language, we need
to either support the interoperability requirements as a distinct
specialization of the procedure call protocol, or use the
<code class="docutils literal notranslate"><span class="pre">ISO_Fortran_binding.h</span></code> header file requirements as a subset basis for a
complete implementation that adds representations for all the
missing capabilities, which would be isolated and named so as
to prevent user C code from relying upon them.</p>
</div>
<div class="section" id="design-space">
<h3><a class="toc-backref" href="#id26">Design space</a><a class="headerlink" href="#design-space" title="Permalink to this headline">¶</a></h3>
<p>There is a range of possible options for representing the
properties of values and objects during the execution of Fortran
programs.</p>
<p>At one extreme, the amount of dynamic information is minimized,
and is packaged in custom data structures or additional arguments
for each situation to convey only the values that are unknown at
compilation time and actually needed at execution time.</p>
<p>At the other extreme, data values and objects are described completely,
including even the values of properties are known at compilation time.
This is not as silly as it sounds – e.g., Fortran array descriptors
have historically materialized the number of dimensions they cover, even
though rank will be (nearly) always be a known constant during compilation.</p>
<p>When data are packaged, their containers can be self-describing to
some degree.
Description records can have tag values or strings.
Their fields can have presence flags or identifying tags, and fields
need not have fixed offsets or ordering.
This flexibility can increase binary compatibility across revisions
of the run-time support library, and is convenient for debugging
that library.
However, it is not free.</p>
<p>Further, the requirements of the representation of dynamic
properties of values and objects depend on the execution model:
specifically, are the complicated semantics of intrinsic assignment,
deallocation, and finalization of allocatables implemented entirely
in the support library, in generated code for non-recursive cases,
or by means of a combination of the two approaches?</p>
<p>Consider how to implement the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">TYPE</span> <span class="p">::</span> <span class="n">LIST</span>
  <span class="n">REAL</span> <span class="p">::</span> <span class="n">HEAD</span>
  <span class="n">TYPE</span><span class="p">(</span><span class="n">LIST</span><span class="p">),</span> <span class="n">ALLOCATABLE</span> <span class="p">::</span> <span class="n">REST</span>
<span class="n">END</span> <span class="n">TYPE</span> <span class="n">LIST</span>
<span class="n">TYPE</span><span class="p">(</span><span class="n">LIST</span><span class="p">),</span> <span class="n">ALLOCATABLE</span> <span class="p">::</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span>
<span class="o">...</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">B</span>
</pre></div>
</div>
<p>Fortran requires that <code class="docutils literal notranslate"><span class="pre">A</span></code>’s arbitrary-length linked list be deleted and
replaced with a “deep copy” of <code class="docutils literal notranslate"><span class="pre">B</span></code>’s.
So either a complicated pair of loops must be generated by the compiler,
or a sophisticated run time support library needs to be driven with
an expressive representation of type information.</p>
</div>
</div>
<div class="section" id="proposal">
<h2><a class="toc-backref" href="#id27">Proposal</a><a class="headerlink" href="#proposal" title="Permalink to this headline">¶</a></h2>
<p>We need to write <code class="docutils literal notranslate"><span class="pre">ISO_Fortran_binding.h</span></code> in any event.
It is a header that is published for use in user C code for interoperation
with compiled Fortran and the Fortran run time support library.</p>
<p>There is a sole descriptor structure defined in <code class="docutils literal notranslate"><span class="pre">ISO_Fortran_binding.h</span></code>.
It is suitable for characterizing scalars and array sections of intrinsic
types.
It is essentially a “fat” data pointer that encapsulates a raw data pointer,
a type code, rank, elemental byte size, and per-dimension bounds and stride.</p>
<p>Please note that the mandated interoperable descriptor includes the data
pointer.
This design in the Standard precludes the use of static descriptors that
could be associated with dynamic base addresses.</p>
<p>The F18 runtime cannot use just the mandated interoperable
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">CFI_cdesc_t</span></code> argument descriptor structure as its
all-purpose data descriptor.
It has no information about derived type components, overridable
type-bound procedure bindings, type parameters, &amp;c.</p>
<p>However, we could extend the standard interoperable argument descriptor.
The <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">CFI_cdesc_t</span></code> structure is not of fixed size, but we
can efficiently locate the first address after an instance of the
standard descriptor and attach our own data record there to
hold what we need.
There’s at least one unused padding byte in the standard argument
descriptor that can be used to hold a flag indicating the presence
of the addenda.</p>
<p>The definitions of our additional run time data structures must
appear in a header file that is distinct from <code class="docutils literal notranslate"><span class="pre">ISO_Fortran_binding.h</span></code>,
and they should never be used by user applications.</p>
<p>This expanded descriptor structure can serve, at least initially for
simplicity, as the sole representation of <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> variables and
components, <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> variables and components, and derived type
instances, including length parameter values.</p>
<p>An immediate concern with this concept is the amount of space and
initialization time that would be wasted when derived type components
needing a descriptor would have to be accompanied by an instance
of the general descriptor.
(In the linked list example close above, what could be done with a
single pointer for the <code class="docutils literal notranslate"><span class="pre">REST</span></code> component would become at least
a four-word dynamic structure.)
This concern is amplified when derived type instances
are allocated as arrays, since the overhead is per-element.</p>
<p>We can reduce this wastage in two ways.
First, when the content of the component’s descriptor is constant
at compilation apart from its base address, a static descriptor
can be placed in read-only storage and attached to the description
of the derived type’s components.
Second, we could eventually optimize the storage requirements by
omitting all static fields from the dynamic descriptor, and
expand the compressed dynamic descriptor during execution when
needed.</p>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="RuntimeTypeInfo.html" title="The derived type runtime information table"
             >next</a> |</li>
        <li class="right" >
          <a href="Preprocessing.html" title="Fortran Preprocessing"
             >previous</a> |</li>
<! TODO: Change the webpage  >
  <li><a href="https://flang.llvm.org">Flang Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

        <li class="nav-item nav-item-this"><a href="">Runtime Descriptors</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017-2022, The Flang Team.
      Last updated on Sep 06, 2022.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>
  </body>
</html>