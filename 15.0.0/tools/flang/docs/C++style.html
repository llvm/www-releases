

<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Flang C++ Style Guide &#8212; The Flang Compiler</title>
    <link rel="stylesheet" href="_static/llvm.css" type="text/css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Fortran For C Programmers" href="FortranForCProgrammers.html" />
    <link rel="prev" title="C++14/17 features used in f18" href="C%2B%2B17.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="FortranForCProgrammers.html" title="Fortran For C Programmers"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="C%2B%2B17.html" title="C++14/17 features used in f18"
             accesskey="P">previous</a> |</li>
<! TODO: Change the webpage  >
  <li><a href="https://flang.llvm.org">Flang Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

        <li class="nav-item nav-item-this"><a href="">Flang C++ Style Guide</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://github.com/llvm/llvm-project/blob/main/flang/README.md#getting-started">Getting Started</a></li>
</ul>

<h3>Getting Involved</h3>
<! TODO: Point links to website(flang.llvm.org) and not github once webpage comes up.>
<ul class="want-points">
    <li><a href="https://github.com/llvm/llvm-project/blob/main/flang/docs/GettingInvolved.md#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://github.com/llvm/llvm-project/blob/main/flang/docs/GettingInvolved.md#chat">Slack</a></li>
    <li><a href="https://github.com/llvm/llvm-project/blob/main/flang/docs/GettingInvolved.md#calls">Calls</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://github.com/llvm/llvm-project/tree/main/flang/">Github Repository</a></li>
    <li><a href="https://bugs.llvm.org/">Bug Reports</a></li>
    <li><a href="https://reviews.llvm.org/">Code Review</a></li>
<! TODO: Have the bots setup first>
    <li><a href="#">Doxygen API</a></li>
</ul>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <!--===- docs/C++style.md 
  
   Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
   See https://llvm.org/LICENSE.txt for license information.
   SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
  
--><div class="section" id="flang-c-style-guide">
<h1>Flang C++ Style Guide<a class="headerlink" href="#flang-c-style-guide" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#in-brief" id="id1">In brief:</a></p></li>
<li><p><a class="reference internal" href="#in-particular" id="id2">In particular:</a></p>
<ul>
<li><p><a class="reference internal" href="#error-messages" id="id3">Error messages</a></p></li>
<li><p><a class="reference internal" href="#files" id="id4">Files</a></p></li>
<li><p><a class="reference internal" href="#naming" id="id5">Naming</a></p></li>
<li><p><a class="reference internal" href="#commentary" id="id6">Commentary</a></p></li>
<li><p><a class="reference internal" href="#layout" id="id7">Layout</a></p></li>
<li><p><a class="reference internal" href="#c-language" id="id8">C++ language</a></p>
<ul>
<li><p><a class="reference internal" href="#classes" id="id9">Classes</a></p></li>
<li><p><a class="reference internal" href="#pointers" id="id10">Pointers</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#overall-design-preferences" id="id11">Overall design preferences</a></p></li>
<li><p><a class="reference internal" href="#exceptions-to-these-guidelines" id="id12">Exceptions to these guidelines</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#c-compiler-bug-workarounds" id="id13">C++ compiler bug workarounds</a></p>
<ul>
<li><p><a class="reference internal" href="#explicitly-move-noncopyable-local-variable-into-optional-results" id="id14">Explicitly move noncopyable local variable into optional results</a></p></li>
</ul>
</li>
</ul>
</div>
<p>This document captures the style guide rules that are followed in the Flang codebase.</p>
<div class="section" id="in-brief">
<h2><a class="toc-backref" href="#id1">In brief:</a><a class="headerlink" href="#in-brief" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Use <em>clang-format</em>
from llvm 7
on all C++ source and header files before
every merge to main.  All code layout should be determined
by means of clang-format.</p></li>
<li><p>Where a clear precedent exists in the project, follow it.</p></li>
<li><p>Otherwise, where <a class="reference external" href="https://llvm.org/docs/CodingStandards.html#style-issues">LLVM’s C++ style guide</a>
is clear on usage, follow it.</p></li>
<li><p>Otherwise, where a good public C++ style guide is relevant and clear,
follow it.  <a class="reference external" href="https://google.github.io/styleguide/cppguide.html">Google’s</a>
is pretty good and comes with lots of justifications for its rules.</p></li>
<li><p>Reasonable exceptions to these guidelines can be made.</p></li>
<li><p>Be aware of some workarounds for known issues in older C++ compilers that should
still be able to compile f18. They are listed at the end of this document.</p></li>
</ul>
</div>
<div class="section" id="in-particular">
<h2><a class="toc-backref" href="#id2">In particular:</a><a class="headerlink" href="#in-particular" title="Permalink to this headline">¶</a></h2>
<p>Use serial commas in comments, error messages, and documentation
unless they introduce ambiguity.</p>
<div class="section" id="error-messages">
<h3><a class="toc-backref" href="#id3">Error messages</a><a class="headerlink" href="#error-messages" title="Permalink to this headline">¶</a></h3>
<ol class="simple">
<li><p>Messages should be a single sentence with few exceptions.</p></li>
<li><p>Fortran keywords should appear in upper case.</p></li>
<li><p>Names from the program appear in single quotes.</p></li>
<li><p>Messages should start with a capital letter.</p></li>
<li><p>Messages should not end with a period.</p></li>
</ol>
</div>
<div class="section" id="files">
<h3><a class="toc-backref" href="#id4">Files</a><a class="headerlink" href="#files" title="Permalink to this headline">¶</a></h3>
<ol class="simple">
<li><p>File names should use dashes, not underscores.  C++ sources have the
extension “.cpp”, not “.C” or “.cc” or “.cxx”.  Don’t create needless
source directory hierarchies.</p></li>
<li><p>Header files should be idempotent.  Use the usual technique:</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#ifndef FORTRAN_header_H_</span>
<span class="c1">#define FORTRAN_header_H_</span>
<span class="o">//</span> <span class="n">code</span>
<span class="c1">#endif  // FORTRAN_header_H_</span>
</pre></div>
</div>
<ol class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">#include</span></code> every header defining an entity that your project header or source
file actually uses directly.  (Exception: when foo.cpp starts, as it should,
with <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;foo.h&quot;</span></code>, and foo.h includes bar.h in order to define the
interface to the module foo, you don’t have to redundantly <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;bar.h&quot;</span></code>
in foo.cpp.)</p></li>
<li><p>In the source file “foo.cpp”, put its corresponding <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;foo.h&quot;</span></code>
first in the sequence of inclusions.
Then <code class="docutils literal notranslate"><span class="pre">#include</span></code> other project headers in alphabetic order; then C++ standard
headers, also alphabetically; then C and system headers.</p></li>
<li><p>Don’t use <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;iostream&gt;</span></code>.  If you need it for temporary debugging,
remove the inclusion before committing.</p></li>
</ol>
</div>
<div class="section" id="naming">
<h3><a class="toc-backref" href="#id5">Naming</a><a class="headerlink" href="#naming" title="Permalink to this headline">¶</a></h3>
<ol class="simple">
<li><p>C++ names that correspond to well-known interfaces from the STL, LLVM,
and Fortran standard
can and should look like their models when the reader can safely assume that
they mean the same thing – e.g., <code class="docutils literal notranslate"><span class="pre">clear()</span></code> and <code class="docutils literal notranslate"><span class="pre">size()</span></code> member functions
in a class that implements an STL-ish container.
Fortran intrinsic function names are conventionally in ALL CAPS.</p></li>
<li><p>Non-public data members should be named with leading miniscule (lower-case)
letters, internal camelCase capitalization, and a trailing underscore,
e.g. <code class="docutils literal notranslate"><span class="pre">DoubleEntryBookkeepingSystem</span> <span class="pre">myLedger_;</span></code>.  POD structures with
only public data members shouldn’t use trailing underscores, since they
don’t have class functions from which data members need to be distinguishable.</p></li>
<li><p>Accessor member functions are named with the non-public data member’s name,
less the trailing underscore.  Mutator member functions are named <code class="docutils literal notranslate"><span class="pre">set_...</span></code>
and should return <code class="docutils literal notranslate"><span class="pre">*this</span></code>.  Don’t define accessors or mutators needlessly.</p></li>
<li><p>Other class functions should be named with leading capital letters,
CamelCase, and no underscores, and, like all functions, should be based
on imperative verbs, e.g. <code class="docutils literal notranslate"><span class="pre">HaltAndCatchFire()</span></code>.</p></li>
<li><p>It is fine to use short names for local variables with limited scopes,
especially when you can declare them directly in a <code class="docutils literal notranslate"><span class="pre">for()</span></code>/<code class="docutils literal notranslate"><span class="pre">while()</span></code>/<code class="docutils literal notranslate"><span class="pre">if()</span></code>
condition.  Otherwise, prefer complete English words to abbreviations
when creating names.</p></li>
</ol>
</div>
<div class="section" id="commentary">
<h3><a class="toc-backref" href="#id6">Commentary</a><a class="headerlink" href="#commentary" title="Permalink to this headline">¶</a></h3>
<ol class="simple">
<li><p>Use <code class="docutils literal notranslate"><span class="pre">//</span></code> for all comments except for short <code class="docutils literal notranslate"><span class="pre">/*notes*/</span></code> within expressions.</p></li>
<li><p>When <code class="docutils literal notranslate"><span class="pre">//</span></code> follows code on a line, precede it with two spaces.</p></li>
<li><p>Comments should matter.  Assume that the reader knows current C++ at least as
well as you do and avoid distracting her by calling out usage of new
features in comments.</p></li>
</ol>
</div>
<div class="section" id="layout">
<h3><a class="toc-backref" href="#id7">Layout</a><a class="headerlink" href="#layout" title="Permalink to this headline">¶</a></h3>
<p>Always run <code class="docutils literal notranslate"><span class="pre">clang-format</span></code> on your changes before committing code. LLVM
has a <code class="docutils literal notranslate"><span class="pre">git-clang-format</span></code> script to facilitate running clang-format only
on the lines that have changed.</p>
<p>Here’s what you can expect to see <code class="docutils literal notranslate"><span class="pre">clang-format</span></code> do:</p>
<ol class="simple">
<li><p>Indent with two spaces.</p></li>
<li><p>Don’t indent public:, protected:, and private:
accessibility labels.</p></li>
<li><p>Never use more than 80 characters per source line.</p></li>
<li><p>Don’t use tabs.</p></li>
<li><p>Don’t indent the bodies of namespaces, even when nested.</p></li>
<li><p>Function result types go on the same line as the function and argument
names.</p></li>
</ol>
<p>Don’t try to make columns of variable names or comments
align vertically – they are maintenance problems.</p>
<p>Always wrap the bodies of <code class="docutils literal notranslate"><span class="pre">if()</span></code>, <code class="docutils literal notranslate"><span class="pre">else</span></code>, <code class="docutils literal notranslate"><span class="pre">while()</span></code>, <code class="docutils literal notranslate"><span class="pre">for()</span></code>, <code class="docutils literal notranslate"><span class="pre">do</span></code>, &amp;c.
with braces, even when the body is a single statement or empty.  Note that this
diverges from the LLVM coding style.  In parts of the codebase that make heavy
use of LLVM or MLIR APIs (e.g. the Lower and Optimizer libraries), use the
LLVM style instead.  The
opening <code class="docutils literal notranslate"><span class="pre">{</span></code> goes on
the end of the line, not on the next line.  Functions also put the opening
<code class="docutils literal notranslate"><span class="pre">{</span></code> after the formal arguments or new-style result type, not on the next
line.  Use <code class="docutils literal notranslate"><span class="pre">{}</span></code> for empty inline constructors and destructors in classes.</p>
<p>If any branch of an <code class="docutils literal notranslate"><span class="pre">if</span></code>/<code class="docutils literal notranslate"><span class="pre">else</span> <span class="pre">if</span></code>/<code class="docutils literal notranslate"><span class="pre">else</span></code> cascade ends with a return statement,
they all should, with the understanding that the cases are all unexceptional.
When testing for an error case that should cause an early return, do so with
an <code class="docutils literal notranslate"><span class="pre">if</span></code> that doesn’t have a following <code class="docutils literal notranslate"><span class="pre">else</span></code>.</p>
<p>Don’t waste space on the screen with needless blank lines or elaborate block
commentary (lines of dashes, boxes of asterisks, &amp;c.).  Write code so as to be
easily read and understood with a minimum of scrolling.</p>
<p>Avoid using assignments in controlling expressions of <code class="docutils literal notranslate"><span class="pre">if()</span></code> &amp;c., even with
the idiom of wrapping them with extra parentheses.</p>
<p>In multi-element initializer lists (especially <code class="docutils literal notranslate"><span class="pre">common::visitors{...}</span></code>),
including a comma after the last element often causes <code class="docutils literal notranslate"><span class="pre">clang-format</span></code> to do
a better jobs of formatting.</p>
</div>
<div class="section" id="c-language">
<h3><a class="toc-backref" href="#id8">C++ language</a><a class="headerlink" href="#c-language" title="Permalink to this headline">¶</a></h3>
<p>Use <em>C++17</em>, unless some compiler to which we must be portable lacks a feature
you are considering.
However:</p>
<ol class="simple">
<li><p>Never throw or catch exceptions.</p></li>
<li><p>Never use run-time type information or <code class="docutils literal notranslate"><span class="pre">dynamic_cast&lt;&gt;</span></code>.</p></li>
<li><p>Never declare static data that executes a constructor.
(This is why <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;iostream&gt;</span></code> is contraindicated.)</p></li>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">{braced</span> <span class="pre">initializers}</span></code> in all circumstances where they work, including
default data member initialization.  They inhibit implicit truncation.
Don’t use <code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">expr</span></code> initialization just to effect implicit truncation;
prefer an explicit <code class="docutils literal notranslate"><span class="pre">static_cast&lt;&gt;</span></code>.
With C++17, braced initializers work fine with <code class="docutils literal notranslate"><span class="pre">auto</span></code> too.
Sometimes, however, there are better alternatives to empty braces;
e.g., prefer <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">std::nullopt;</span></code> to <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">{};</span></code> to make it more clear
that the function’s result type is a <code class="docutils literal notranslate"><span class="pre">std::optional&lt;&gt;</span></code>.</p></li>
<li><p>Avoid unsigned types apart from <code class="docutils literal notranslate"><span class="pre">size_t</span></code>, which must be used with care.
When <code class="docutils literal notranslate"><span class="pre">int</span></code> just obviously works, just use <code class="docutils literal notranslate"><span class="pre">int</span></code>.  When you need something
bigger than <code class="docutils literal notranslate"><span class="pre">int</span></code>, use <code class="docutils literal notranslate"><span class="pre">std::int64_t</span></code> rather than <code class="docutils literal notranslate"><span class="pre">long</span></code> or <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code>.</p></li>
<li><p>Use namespaces to avoid conflicts with client code.  Use one top-level
<code class="docutils literal notranslate"><span class="pre">Fortran</span></code> project namespace.  Don’t introduce needless nested namespaces within the
project when names don’t conflict or better solutions exist.  Never use
<code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span> <span class="pre">...;</span></code> outside test code; never use <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span> <span class="pre">std;</span></code>
anywhere.  Access STL entities with names like <code class="docutils literal notranslate"><span class="pre">std::unique_ptr&lt;&gt;</span></code>,
without a leading <code class="docutils literal notranslate"><span class="pre">::</span></code>.</p></li>
<li><p>Prefer <code class="docutils literal notranslate"><span class="pre">static</span></code> functions over functions in anonymous namespaces in source files.</p></li>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">auto</span></code> judiciously.  When the type of a local variable is known,
monomorphic, and easy to type, be explicit rather than using <code class="docutils literal notranslate"><span class="pre">auto</span></code>.
Don’t use <code class="docutils literal notranslate"><span class="pre">auto</span></code> functions unless the type of the result of an outlined member
function definition can be more clear due to its use of types declared in the
class.</p></li>
<li><p>Use move semantics and smart pointers to make dynamic memory ownership
clear.  Consider reworking any code that uses <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> or a (non-placement)
<code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">new</span></code>.
See the section on Pointers below for some suggested options.</p></li>
<li><p>When defining argument types, use values when object semantics are
not required and the value is small and copyable without allocation
(e.g., <code class="docutils literal notranslate"><span class="pre">int</span></code>);
use <code class="docutils literal notranslate"><span class="pre">const</span></code> or rvalue references for larger values (e.g., <code class="docutils literal notranslate"><span class="pre">std::string</span></code>);
use <code class="docutils literal notranslate"><span class="pre">const</span></code> references to rather than pointers to immutable objects;
and use non-<code class="docutils literal notranslate"><span class="pre">const</span></code> references for mutable objects, including “output” arguments
when they can’t be function results.
Put such output arguments last (<em>pace</em> the standard C library conventions for <code class="docutils literal notranslate"><span class="pre">memcpy()</span></code> &amp; al.).</p></li>
<li><p>Prefer <code class="docutils literal notranslate"><span class="pre">typename</span></code> to <code class="docutils literal notranslate"><span class="pre">class</span></code> in template argument declarations.</p></li>
<li><p>Prefer <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span></code> to plain <code class="docutils literal notranslate"><span class="pre">enum</span></code> wherever <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span></code> will work.
We have an <code class="docutils literal notranslate"><span class="pre">ENUM_CLASS</span></code> macro that helps capture the names of constants.</p></li>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> and <code class="docutils literal notranslate"><span class="pre">const</span></code> generously.</p></li>
<li><p>When a <code class="docutils literal notranslate"><span class="pre">switch()</span></code> statement’s labels do not cover all possible case values
explicitly, it should contain either a <code class="docutils literal notranslate"><span class="pre">default:;</span></code> at its end or a
<code class="docutils literal notranslate"><span class="pre">default:</span></code> label that obviously crashes; we have a <code class="docutils literal notranslate"><span class="pre">CRASH_NO_CASE</span></code> macro
for such situations.</p></li>
<li><p>On the other hand, when a <code class="docutils literal notranslate"><span class="pre">switch()</span></code> statement really does cover all of
the values of an <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span></code>, please insert a call to the <code class="docutils literal notranslate"><span class="pre">SWITCH_COVERS_ALL_CASES</span></code>
macro at the top of the block.  This macro does the right thing for G++ and
clang to ensure that no warning is emitted when the cases are indeed all covered.</p></li>
<li><p>When using <code class="docutils literal notranslate"><span class="pre">std::optional</span></code> values, avoid unprotected access to their content.
This is usually by means of <code class="docutils literal notranslate"><span class="pre">x.has_value()</span></code> guarding execution of <code class="docutils literal notranslate"><span class="pre">*x</span></code>.
This is implicit when they are function results assigned to local variables
in <code class="docutils literal notranslate"><span class="pre">if</span></code>/<code class="docutils literal notranslate"><span class="pre">while</span></code> predicates.
When no presence test is obviously protecting a <code class="docutils literal notranslate"><span class="pre">*x</span></code> reference to the
contents, and it is assumed that the contents are present, validate that
assumption by using <code class="docutils literal notranslate"><span class="pre">x.value()</span></code> instead.</p></li>
<li><p>We use <code class="docutils literal notranslate"><span class="pre">c_str()</span></code> rather than <code class="docutils literal notranslate"><span class="pre">data()</span></code> when converting a <code class="docutils literal notranslate"><span class="pre">std::string</span></code>
to a <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code> when the result is expected to be NUL-terminated.</p></li>
<li><p>Avoid explicit comparisions of pointers to <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> and tests of
presence of <code class="docutils literal notranslate"><span class="pre">optional&lt;&gt;</span></code> values with <code class="docutils literal notranslate"><span class="pre">.has_value()</span></code> in the predicate
expressions of control flow statements, but prefer them to implicit
conversions to <code class="docutils literal notranslate"><span class="pre">bool</span></code> when initializing <code class="docutils literal notranslate"><span class="pre">bool</span></code> variables and arguments,
and to the use of the idiom <code class="docutils literal notranslate"><span class="pre">!!</span></code>.</p></li>
</ol>
<div class="section" id="classes">
<h4><a class="toc-backref" href="#id9">Classes</a><a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h4>
<ol class="simple">
<li><p>Define POD structures with <code class="docutils literal notranslate"><span class="pre">struct</span></code>.</p></li>
<li><p>Don’t use <code class="docutils literal notranslate"><span class="pre">this-&gt;</span></code> in (non-static) member functions, unless forced to
do so in a template member function.</p></li>
<li><p>Define accessor and mutator member functions (implicitly) inline in the
class, after constructors and assignments.  Don’t needlessly define
(implicit) inline member functions in classes unless they really solve a
performance problem.</p></li>
<li><p>Try to make class definitions in headers concise specifications of
interfaces, at least to the extent that C++ allows.</p></li>
<li><p>When copy constructors and copy assignment are not necessary,
and move constructors/assignment is present, don’t declare them and they
will be implicitly deleted.  When neither copy nor move constructors
or assignments should exist for a class, explicitly <code class="docutils literal notranslate"><span class="pre">=delete</span></code> all of them.</p></li>
<li><p>Make single-argument constructors (other than copy and move constructors)
‘explicit’ unless you really want to define an implicit conversion.</p></li>
</ol>
</div>
<div class="section" id="pointers">
<h4><a class="toc-backref" href="#id10">Pointers</a><a class="headerlink" href="#pointers" title="Permalink to this headline">¶</a></h4>
<p>There are many – perhaps too many – means of indirect addressing
data in this project.
Some of these are standard C++ language and library features,
while others are local inventions in <code class="docutils literal notranslate"><span class="pre">lib/Common</span></code>:</p>
<ul class="simple">
<li><p>Bare pointers (<code class="docutils literal notranslate"><span class="pre">Foo</span> <span class="pre">*p</span></code>): these are obviously nullable, non-owning,
undefined when uninitialized, shallowly copyable, reassignable, and often
not the right abstraction to use in this project.
But they can be the right choice to represent an optional
non-owning reference, as in a function result.
Use the <code class="docutils literal notranslate"><span class="pre">DEREF()</span></code> macro to convert a pointer to a reference that isn’t
already protected by an explicit test for null.</p></li>
<li><p>References (<code class="docutils literal notranslate"><span class="pre">Foo</span> <span class="pre">&amp;r</span></code>, <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">Foo</span> <span class="pre">&amp;r</span></code>): non-nullable, not owning,
shallowly copyable, and not reassignable.
References are great for invisible indirection to objects whose lifetimes are
broader than that of the reference.
Take care when initializing a reference with another reference to ensure
that a copy is not made because only one of the references is <code class="docutils literal notranslate"><span class="pre">const</span></code>;
this is a pernicious C++ language pitfall!</p></li>
<li><p>Rvalue references (<code class="docutils literal notranslate"><span class="pre">Foo</span> <span class="pre">&amp;&amp;r</span></code>): These are non-nullable references
<em>with</em> ownership, and they are ubiquitously used for formal arguments
wherever appropriate.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::reference_wrapper&lt;&gt;</span></code>: non-nullable, not owning, shallowly
copyable, and (unlike bare references) reassignable, so suitable for
use in STL containers and for data members in classes that need to be
copyable or assignable.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">common::Reference&lt;&gt;</span></code>: like <code class="docutils literal notranslate"><span class="pre">std::reference_wrapper&lt;&gt;</span></code>, but also supports
move semantics, member access, and comparison for equality; suitable for use in
<code class="docutils literal notranslate"><span class="pre">std::variant&lt;&gt;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::unique_ptr&lt;&gt;</span></code>: A nullable pointer with ownership, null by default,
not copyable, reassignable.
F18 has a helpful <code class="docutils literal notranslate"><span class="pre">Deleter&lt;&gt;</span></code> class template that makes <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;&gt;</span></code>
easier to use with forward-referenced data types.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::shared_ptr&lt;&gt;</span></code>: A nullable pointer with shared ownership via reference
counting, null by default, shallowly copyable, reassignable, and slow.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Indirection&lt;&gt;</span></code>: A non-nullable pointer with ownership and
optional deep copy semantics; reassignable.
Often better than a reference (due to ownership) or <code class="docutils literal notranslate"><span class="pre">std::unique_ptr&lt;&gt;</span></code>
(due to non-nullability and copyability).
Can be wrapped in <code class="docutils literal notranslate"><span class="pre">std::optional&lt;&gt;</span></code> when nullability is required.
Usable with forward-referenced data types with some use of <code class="docutils literal notranslate"><span class="pre">extern</span> <span class="pre">template</span></code>
in headers and explicit template instantiation in source files.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CountedReference&lt;&gt;</span></code>: A nullable pointer with shared ownership via
reference counting, null by default, shallowly copyable, reassignable.
Safe to use <em>only</em> when the data are private to just one
thread of execution.
Used sparingly in place of <code class="docutils literal notranslate"><span class="pre">std::shared_ptr&lt;&gt;</span></code> only when the overhead
of that standard feature is prohibitive.</p></li>
</ul>
<p>A feature matrix:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>indirection</th>
<th>nullable</th>
<th>default null</th>
<th>owning</th>
<th>reassignable</th>
<th>copyable</th>
<th>undefined type ok?</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*p</code></td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>shallowly</td>
<td>yes</td>
</tr>
<tr>
<td><code>&amp;r</code></td>
<td>no</td>
<td>n/a</td>
<td>no</td>
<td>no</td>
<td>shallowly</td>
<td>yes</td>
</tr>
<tr>
<td><code>&amp;&amp;r</code></td>
<td>no</td>
<td>n/a</td>
<td>yes</td>
<td>no</td>
<td>shallowly</td>
<td>yes</td>
</tr>
<tr>
<td><code>reference_wrapper&lt;&gt;</code></td>
<td>no</td>
<td>n/a</td>
<td>no</td>
<td>yes</td>
<td>shallowly</td>
<td>yes</td>
</tr>
<tr>
<td><code>Reference&lt;&gt;</code></td>
<td>no</td>
<td>n/a</td>
<td>no</td>
<td>yes</td>
<td>shallowly</td>
<td>yes</td>
</tr>
<tr>
<td><code>unique_ptr&lt;&gt;</code></td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>yes, with work</td>
</tr>
<tr>
<td><code>shared_ptr&lt;&gt;</code></td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>shallowly</td>
<td>no</td>
</tr>
<tr>
<td><code>Indirection&lt;&gt;</code></td>
<td>no</td>
<td>n/a</td>
<td>yes</td>
<td>yes</td>
<td>optionally deeply</td>
<td>yes, with work</td>
</tr>
<tr>
<td><code>CountedReference&lt;&gt;</code></td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>shallowly</td>
<td>no</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="overall-design-preferences">
<h3><a class="toc-backref" href="#id11">Overall design preferences</a><a class="headerlink" href="#overall-design-preferences" title="Permalink to this headline">¶</a></h3>
<p>Don’t use dynamic solutions to solve problems that can be solved at
build time; don’t solve build time problems by writing programs that
produce source code when macros and templates suffice; don’t write macros
when templates suffice.  Templates are statically typed, checked by the
compiler, and are (or should be) visible to debuggers.</p>
</div>
<div class="section" id="exceptions-to-these-guidelines">
<h3><a class="toc-backref" href="#id12">Exceptions to these guidelines</a><a class="headerlink" href="#exceptions-to-these-guidelines" title="Permalink to this headline">¶</a></h3>
<p>Reasonable exceptions will be allowed; these guidelines cannot anticipate
all situations.
For example, names that come from other sources might be more clear if
their original spellings are preserved rather than mangled to conform
needlessly to the conventions here, as Google’s C++ style guide does
in a way that leads to weirdly capitalized abbreviations in names
like <code class="docutils literal notranslate"><span class="pre">Http</span></code>.
Consistency is one of many aspects in the pursuit of clarity,
but not an end in itself.</p>
</div>
</div>
<div class="section" id="c-compiler-bug-workarounds">
<h2><a class="toc-backref" href="#id13">C++ compiler bug workarounds</a><a class="headerlink" href="#c-compiler-bug-workarounds" title="Permalink to this headline">¶</a></h2>
<p>Below is a list of workarounds for C++ compiler bugs met with f18 that, even
if the bugs are fixed in latest C++ compiler versions, need to be applied so
that all desired tool-chains can compile f18.</p>
<div class="section" id="explicitly-move-noncopyable-local-variable-into-optional-results">
<h3><a class="toc-backref" href="#id14">Explicitly move noncopyable local variable into optional results</a><a class="headerlink" href="#explicitly-move-noncopyable-local-variable-into-optional-results" title="Permalink to this headline">¶</a></h3>
<p>The following code is legal C++ but fails to compile with the
default Ubuntu 18.04 g++ compiler (7.4.0-1ubuntu1~18.0.4.1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CantBeCopied</span> <span class="p">{</span>
 <span class="n">public</span><span class="p">:</span>
 <span class="n">CantBeCopied</span><span class="p">(</span><span class="n">const</span> <span class="n">CantBeCopied</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">delete</span><span class="p">;</span>
 <span class="n">CantBeCopied</span><span class="p">(</span><span class="n">CantBeCopied</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">default</span><span class="p">;</span>
 <span class="n">CantBeCopied</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>
<span class="n">std</span><span class="p">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">CantBeCopied</span><span class="o">&gt;</span> <span class="n">fooNOK</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">CantBeCopied</span> <span class="n">result</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span> <span class="o">//</span> <span class="n">Legal</span> <span class="n">C</span><span class="o">++</span><span class="p">,</span> <span class="n">but</span> <span class="n">does</span> <span class="ow">not</span> <span class="nb">compile</span> <span class="k">with</span> <span class="n">Ubuntu</span> <span class="mf">18.04</span> <span class="n">default</span> <span class="n">g</span><span class="o">++</span>
<span class="p">}</span>
<span class="n">std</span><span class="p">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">CantBeCopied</span><span class="o">&gt;</span> <span class="n">fooOK</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">CantBeCopied</span> <span class="n">result</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">{</span><span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">result</span><span class="p">)};</span> <span class="o">//</span> <span class="n">Compiles</span> <span class="n">OK</span> <span class="n">everywhere</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The underlying bug is actually not specific to <code class="docutils literal notranslate"><span class="pre">std::optional</span></code> but this is the most common
case in f18 where the issue may occur. The actual bug can be reproduced with any class <code class="docutils literal notranslate"><span class="pre">B</span></code>
that has a perfect forwarding constructor taking <code class="docutils literal notranslate"><span class="pre">CantBeCopied</span></code> as argument:
<code class="docutils literal notranslate"><span class="pre">template&lt;typename</span> <span class="pre">CantBeCopied&gt;</span> <span class="pre">B(CantBeCopied&amp;&amp;</span> <span class="pre">x)</span> <span class="pre">x_{std::forward&lt;CantBeCopied&gt;(x)}</span> <span class="pre">{}</span></code>.
In such scenarios, Ubuntu 18.04 g++ fails to instantiate the move constructor
and to construct the returned value as it should, instead it complains about a
missing copy constructor.</p>
<p>Local result variables do not need to and should not be explicitly moved into optionals
if they have a copy constructor.</p>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="FortranForCProgrammers.html" title="Fortran For C Programmers"
             >next</a> |</li>
        <li class="right" >
          <a href="C%2B%2B17.html" title="C++14/17 features used in f18"
             >previous</a> |</li>
<! TODO: Change the webpage  >
  <li><a href="https://flang.llvm.org">Flang Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

        <li class="nav-item nav-item-this"><a href="">Flang C++ Style Guide</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017-2022, The Flang Team.
      Last updated on Sep 06, 2022.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>
  </body>
</html>