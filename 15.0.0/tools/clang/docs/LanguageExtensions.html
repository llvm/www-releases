
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clang Language Extensions &#8212; Clang 15.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Objective-C Literals" href="ObjectiveCLiterals.html" />
    <link rel="prev" title="Assembling a Complete Toolchain" href="Toolchain.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Clang 15.0.0 documentation</span></a></h1>
        <h2 class="heading"><span>Clang Language Extensions</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="Toolchain.html">Assembling a Complete Toolchain</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="ObjectiveCLiterals.html">Objective-C Literals</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <div class="section" id="clang-language-extensions">
<h1>Clang Language Extensions<a class="headerlink" href="#clang-language-extensions" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id12">Introduction</a></p></li>
<li><p><a class="reference internal" href="#feature-checking-macros" id="id13">Feature Checking Macros</a></p></li>
<li><p><a class="reference internal" href="#include-file-checking-macros" id="id14">Include File Checking Macros</a></p></li>
<li><p><a class="reference internal" href="#builtin-macros" id="id15">Builtin Macros</a></p></li>
<li><p><a class="reference internal" href="#vectors-and-extended-vectors" id="id16">Vectors and Extended Vectors</a></p></li>
<li><p><a class="reference internal" href="#matrix-types" id="id17">Matrix Types</a></p></li>
<li><p><a class="reference internal" href="#half-precision-floating-point" id="id18">Half-Precision Floating Point</a></p></li>
<li><p><a class="reference internal" href="#messages-on-deprecated-and-unavailable-attributes" id="id19">Messages on <code class="docutils literal notranslate"><span class="pre">deprecated</span></code> and <code class="docutils literal notranslate"><span class="pre">unavailable</span></code> Attributes</a></p></li>
<li><p><a class="reference internal" href="#attributes-on-enumerators" id="id20">Attributes on Enumerators</a></p></li>
<li><p><a class="reference internal" href="#c-11-attributes-on-using-declarations" id="id21">C++11 Attributes on using-declarations</a></p></li>
<li><p><a class="reference internal" href="#user-specified-system-frameworks" id="id22">‘User-Specified’ System Frameworks</a></p></li>
<li><p><a class="reference internal" href="#checks-for-standard-language-features" id="id23">Checks for Standard Language Features</a></p></li>
<li><p><a class="reference internal" href="#type-trait-primitives" id="id24">Type Trait Primitives</a></p></li>
<li><p><a class="reference internal" href="#blocks" id="id25">Blocks</a></p></li>
<li><p><a class="reference internal" href="#asm-goto-with-output-constraints" id="id26">ASM Goto with Output Constraints</a></p></li>
<li><p><a class="reference internal" href="#objective-c-features" id="id27">Objective-C Features</a></p></li>
<li><p><a class="reference internal" href="#initializer-lists-for-complex-numbers-in-c" id="id28">Initializer lists for complex numbers in C</a></p></li>
<li><p><a class="reference internal" href="#opencl-features" id="id29">OpenCL Features</a></p></li>
<li><p><a class="reference internal" href="#builtin-functions" id="id30">Builtin Functions</a></p></li>
<li><p><a class="reference internal" href="#non-standard-c-11-attributes" id="id31">Non-standard C++11 Attributes</a></p></li>
<li><p><a class="reference internal" href="#target-specific-extensions" id="id32">Target-Specific Extensions</a></p></li>
<li><p><a class="reference internal" href="#extensions-for-static-analysis" id="id33">Extensions for Static Analysis</a></p></li>
<li><p><a class="reference internal" href="#extensions-for-dynamic-analysis" id="id34">Extensions for Dynamic Analysis</a></p></li>
<li><p><a class="reference internal" href="#extensions-for-selectively-disabling-optimization" id="id35">Extensions for selectively disabling optimization</a></p></li>
<li><p><a class="reference internal" href="#extensions-for-loop-hint-optimizations" id="id36">Extensions for loop hint optimizations</a></p></li>
<li><p><a class="reference internal" href="#extensions-to-specify-floating-point-flags" id="id37">Extensions to specify floating-point flags</a></p></li>
<li><p><a class="reference internal" href="#specifying-an-attribute-for-multiple-declarations-pragma-clang-attribute" id="id38">Specifying an attribute for multiple declarations (#pragma clang attribute)</a></p></li>
<li><p><a class="reference internal" href="#specifying-section-names-for-global-objects-pragma-clang-section" id="id39">Specifying section names for global objects (#pragma clang section)</a></p></li>
<li><p><a class="reference internal" href="#specifying-linker-options-on-elf-targets" id="id40">Specifying Linker Options on ELF Targets</a></p></li>
<li><p><a class="reference internal" href="#evaluating-object-size-dynamically" id="id41">Evaluating Object Size Dynamically</a></p></li>
<li><p><a class="reference internal" href="#deprecating-macros" id="id42">Deprecating Macros</a></p></li>
<li><p><a class="reference internal" href="#restricted-expansion-macros" id="id43">Restricted Expansion Macros</a></p></li>
<li><p><a class="reference internal" href="#final-macros" id="id44">Final Macros</a></p></li>
<li><p><a class="reference internal" href="#line-control" id="id45">Line Control</a></p></li>
<li><p><a class="reference internal" href="#extended-integer-types" id="id46">Extended Integer Types</a></p></li>
<li><p><a class="reference internal" href="#intrinsics-support-within-constant-expressions" id="id47">Intrinsics Support within Constant Expressions</a></p></li>
</ul>
</div>
<div class="toctree-wrapper compound">
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id12">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document describes the language extensions provided by Clang.  In addition
to the language extensions listed here, Clang aims to support a broad range of
GCC extensions.  Please see the <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html">GCC manual</a> for more information on
these extensions.</p>
</div>
<div class="section" id="feature-checking-macros">
<span id="langext-feature-check"></span><h2><a class="toc-backref" href="#id13">Feature Checking Macros</a><a class="headerlink" href="#feature-checking-macros" title="Permalink to this headline">¶</a></h2>
<p>Language extensions can be very useful, but only if you know you can depend on
them.  In order to allow fine-grain features checks, we support three builtin
function-like macros.  This allows you to directly test for a feature in your
code without having to resort to something like autoconf or fragile “compiler
version checks”.</p>
<div class="section" id="has-builtin">
<h3><code class="docutils literal notranslate"><span class="pre">__has_builtin</span></code><a class="headerlink" href="#has-builtin" title="Permalink to this headline">¶</a></h3>
<p>This function-like macro takes a single identifier argument that is the name of
a builtin function, a builtin pseudo-function (taking one or more type
arguments), or a builtin template.
It evaluates to 1 if the builtin is supported or 0 if not.
It can be used like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef __has_builtin         </span><span class="c1">// Optional of course.</span>
<span class="w">  </span><span class="cp">#define __has_builtin(x) 0  </span><span class="c1">// Compatibility with non-clang compilers.</span>
<span class="cp">#endif</span>

<span class="p">...</span><span class="w"></span>
<span class="cp">#if __has_builtin(__builtin_trap)</span>
<span class="w">  </span><span class="n">__builtin_trap</span><span class="p">();</span><span class="w"></span>
<span class="cp">#else</span>
<span class="w">  </span><span class="n">abort</span><span class="p">();</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Prior to Clang 10, <code class="docutils literal notranslate"><span class="pre">__has_builtin</span></code> could not be used to detect most builtin
pseudo-functions.</p>
<p><code class="docutils literal notranslate"><span class="pre">__has_builtin</span></code> should not be used to detect support for a builtin macro;
use <code class="docutils literal notranslate"><span class="pre">#ifdef</span></code> instead.</p>
</div>
</div>
<div class="section" id="has-feature-and-has-extension">
<span id="langext-has-feature-has-extension"></span><h3><code class="docutils literal notranslate"><span class="pre">__has_feature</span></code> and <code class="docutils literal notranslate"><span class="pre">__has_extension</span></code><a class="headerlink" href="#has-feature-and-has-extension" title="Permalink to this headline">¶</a></h3>
<p>These function-like macros take a single identifier argument that is the name
of a feature.  <code class="docutils literal notranslate"><span class="pre">__has_feature</span></code> evaluates to 1 if the feature is both
supported by Clang and standardized in the current language standard or 0 if
not (but see <a class="reference internal" href="#langext-has-feature-back-compat"><span class="std std-ref">below</span></a>), while
<code class="docutils literal notranslate"><span class="pre">__has_extension</span></code> evaluates to 1 if the feature is supported by Clang in the
current language (either as a language extension or a standard language
feature) or 0 if not.  They can be used like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef __has_feature         </span><span class="c1">// Optional of course.</span>
<span class="w">  </span><span class="cp">#define __has_feature(x) 0  </span><span class="c1">// Compatibility with non-clang compilers.</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef __has_extension</span>
<span class="w">  </span><span class="cp">#define __has_extension __has_feature </span><span class="c1">// Compatibility with pre-3.0 compilers.</span>
<span class="cp">#endif</span>

<span class="p">...</span><span class="w"></span>
<span class="cp">#if __has_feature(cxx_rvalue_references)</span>
<span class="c1">// This code will only be compiled with the -std=c++11 and -std=gnu++11</span>
<span class="c1">// options, because rvalue references are only standardized in C++11.</span>
<span class="cp">#endif</span>

<span class="cp">#if __has_extension(cxx_rvalue_references)</span>
<span class="c1">// This code will be compiled with the -std=c++11, -std=gnu++11, -std=c++98</span>
<span class="c1">// and -std=gnu++98 options, because rvalue references are supported as a</span>
<span class="c1">// language extension in C++98.</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p id="langext-has-feature-back-compat">For backward compatibility, <code class="docutils literal notranslate"><span class="pre">__has_feature</span></code> can also be used to test
for support for non-standardized features, i.e. features not prefixed <code class="docutils literal notranslate"><span class="pre">c_</span></code>,
<code class="docutils literal notranslate"><span class="pre">cxx_</span></code> or <code class="docutils literal notranslate"><span class="pre">objc_</span></code>.</p>
<p>Another use of <code class="docutils literal notranslate"><span class="pre">__has_feature</span></code> is to check for compiler features not related
to the language standard, such as e.g. <a class="reference internal" href="AddressSanitizer.html"><span class="doc">AddressSanitizer</span></a>.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">-pedantic-errors</span></code> option is given, <code class="docutils literal notranslate"><span class="pre">__has_extension</span></code> is equivalent
to <code class="docutils literal notranslate"><span class="pre">__has_feature</span></code>.</p>
<p>The feature tag is described along with the language feature below.</p>
<p>The feature name or extension name can also be specified with a preceding and
following <code class="docutils literal notranslate"><span class="pre">__</span></code> (double underscore) to avoid interference from a macro with
the same name.  For instance, <code class="docutils literal notranslate"><span class="pre">__cxx_rvalue_references__</span></code> can be used instead
of <code class="docutils literal notranslate"><span class="pre">cxx_rvalue_references</span></code>.</p>
</div>
<div class="section" id="has-cpp-attribute">
<h3><code class="docutils literal notranslate"><span class="pre">__has_cpp_attribute</span></code><a class="headerlink" href="#has-cpp-attribute" title="Permalink to this headline">¶</a></h3>
<p>This function-like macro is available in C++20 by default, and is provided as an
extension in earlier language standards. It takes a single argument that is the
name of a double-square-bracket-style attribute. The argument can either be a
single identifier or a scoped identifier. If the attribute is supported, a
nonzero value is returned. If the attribute is a standards-based attribute, this
macro returns a nonzero value based on the year and month in which the attribute
was voted into the working draft. See <a class="reference external" href="https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations">WG21 SD-6</a>
for the list of values returned for standards-based attributes. If the attribute
is not supported by the current compilation target, this macro evaluates to 0.
It can be used like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef __has_cpp_attribute         </span><span class="c1">// For backwards compatibility</span>
<span class="w">  </span><span class="cp">#define __has_cpp_attribute(x) 0</span>
<span class="cp">#endif</span>

<span class="p">...</span><span class="w"></span>
<span class="cp">#if __has_cpp_attribute(clang::fallthrough)</span>
<span class="cp">#define FALLTHROUGH [[clang::fallthrough]]</span>
<span class="cp">#else</span>
<span class="cp">#define FALLTHROUGH</span>
<span class="cp">#endif</span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<p>The attribute scope tokens <code class="docutils literal notranslate"><span class="pre">clang</span></code> and <code class="docutils literal notranslate"><span class="pre">_Clang</span></code> are interchangeable, as are
the attribute scope tokens <code class="docutils literal notranslate"><span class="pre">gnu</span></code> and <code class="docutils literal notranslate"><span class="pre">__gnu__</span></code>. Attribute tokens in either
of these namespaces can be specified with a preceding and following <code class="docutils literal notranslate"><span class="pre">__</span></code>
(double underscore) to avoid interference from a macro with the same name. For
instance, <code class="docutils literal notranslate"><span class="pre">gnu::__const__</span></code> can be used instead of <code class="docutils literal notranslate"><span class="pre">gnu::const</span></code>.</p>
</div>
<div class="section" id="has-c-attribute">
<h3><code class="docutils literal notranslate"><span class="pre">__has_c_attribute</span></code><a class="headerlink" href="#has-c-attribute" title="Permalink to this headline">¶</a></h3>
<p>This function-like macro takes a single argument that is the name of an
attribute exposed with the double square-bracket syntax in C mode. The argument
can either be a single identifier or a scoped identifier. If the attribute is
supported, a nonzero value is returned. If the attribute is not supported by the
current compilation target, this macro evaluates to 0. It can be used like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef __has_c_attribute         </span><span class="c1">// Optional of course.</span>
<span class="w">  </span><span class="cp">#define __has_c_attribute(x) 0  </span><span class="c1">// Compatibility with non-clang compilers.</span>
<span class="cp">#endif</span>

<span class="p">...</span><span class="w"></span>
<span class="cp">#if __has_c_attribute(fallthrough)</span>
<span class="w">  </span><span class="cp">#define FALLTHROUGH [[fallthrough]]</span>
<span class="cp">#else</span>
<span class="w">  </span><span class="cp">#define FALLTHROUGH</span>
<span class="cp">#endif</span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<p>The attribute scope tokens <code class="docutils literal notranslate"><span class="pre">clang</span></code> and <code class="docutils literal notranslate"><span class="pre">_Clang</span></code> are interchangeable, as are
the attribute scope tokens <code class="docutils literal notranslate"><span class="pre">gnu</span></code> and <code class="docutils literal notranslate"><span class="pre">__gnu__</span></code>. Attribute tokens in either
of these namespaces can be specified with a preceding and following <code class="docutils literal notranslate"><span class="pre">__</span></code>
(double underscore) to avoid interference from a macro with the same name. For
instance, <code class="docutils literal notranslate"><span class="pre">gnu::__const__</span></code> can be used instead of <code class="docutils literal notranslate"><span class="pre">gnu::const</span></code>.</p>
</div>
<div class="section" id="has-attribute">
<h3><code class="docutils literal notranslate"><span class="pre">__has_attribute</span></code><a class="headerlink" href="#has-attribute" title="Permalink to this headline">¶</a></h3>
<p>This function-like macro takes a single identifier argument that is the name of
a GNU-style attribute.  It evaluates to 1 if the attribute is supported by the
current compilation target, or 0 if not.  It can be used like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef __has_attribute         </span><span class="c1">// Optional of course.</span>
<span class="w">  </span><span class="cp">#define __has_attribute(x) 0  </span><span class="c1">// Compatibility with non-clang compilers.</span>
<span class="cp">#endif</span>

<span class="p">...</span><span class="w"></span>
<span class="cp">#if __has_attribute(always_inline)</span>
<span class="cp">#define ALWAYS_INLINE __attribute__((always_inline))</span>
<span class="cp">#else</span>
<span class="cp">#define ALWAYS_INLINE</span>
<span class="cp">#endif</span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<p>The attribute name can also be specified with a preceding and following <code class="docutils literal notranslate"><span class="pre">__</span></code>
(double underscore) to avoid interference from a macro with the same name.  For
instance, <code class="docutils literal notranslate"><span class="pre">__always_inline__</span></code> can be used instead of <code class="docutils literal notranslate"><span class="pre">always_inline</span></code>.</p>
</div>
<div class="section" id="has-declspec-attribute">
<h3><code class="docutils literal notranslate"><span class="pre">__has_declspec_attribute</span></code><a class="headerlink" href="#has-declspec-attribute" title="Permalink to this headline">¶</a></h3>
<p>This function-like macro takes a single identifier argument that is the name of
an attribute implemented as a Microsoft-style <code class="docutils literal notranslate"><span class="pre">__declspec</span></code> attribute.  It
evaluates to 1 if the attribute is supported by the current compilation target,
or 0 if not.  It can be used like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef __has_declspec_attribute         </span><span class="c1">// Optional of course.</span>
<span class="w">  </span><span class="cp">#define __has_declspec_attribute(x) 0  </span><span class="c1">// Compatibility with non-clang compilers.</span>
<span class="cp">#endif</span>

<span class="p">...</span><span class="w"></span>
<span class="cp">#if __has_declspec_attribute(dllexport)</span>
<span class="cp">#define DLLEXPORT __declspec(dllexport)</span>
<span class="cp">#else</span>
<span class="cp">#define DLLEXPORT</span>
<span class="cp">#endif</span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<p>The attribute name can also be specified with a preceding and following <code class="docutils literal notranslate"><span class="pre">__</span></code>
(double underscore) to avoid interference from a macro with the same name.  For
instance, <code class="docutils literal notranslate"><span class="pre">__dllexport__</span></code> can be used instead of <code class="docutils literal notranslate"><span class="pre">dllexport</span></code>.</p>
</div>
<div class="section" id="is-identifier">
<h3><code class="docutils literal notranslate"><span class="pre">__is_identifier</span></code><a class="headerlink" href="#is-identifier" title="Permalink to this headline">¶</a></h3>
<p>This function-like macro takes a single identifier argument that might be either
a reserved word or a regular identifier. It evaluates to 1 if the argument is just
a regular identifier and not a reserved word, in the sense that it can then be
used as the name of a user-defined function or variable. Otherwise it evaluates
to 0.  It can be used like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">...</span><span class="w"></span>
<span class="cp">#ifdef __is_identifier          </span><span class="c1">// Compatibility with non-clang compilers.</span>
<span class="w">  </span><span class="cp">#if __is_identifier(__wchar_t)</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="kt">wchar_t</span><span class="w"> </span><span class="kr">__wchar_t</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="kr">__wchar_t</span><span class="w"> </span><span class="n">WideCharacter</span><span class="p">;</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="include-file-checking-macros">
<h2><a class="toc-backref" href="#id14">Include File Checking Macros</a><a class="headerlink" href="#include-file-checking-macros" title="Permalink to this headline">¶</a></h2>
<p>Not all developments systems have the same include files.  The
<a class="reference internal" href="#langext-has-include"><span class="std std-ref">__has_include</span></a> and <a class="reference internal" href="#langext-has-include-next"><span class="std std-ref">__has_include_next</span></a> macros allow
you to check for the existence of an include file before doing a possibly
failing <code class="docutils literal notranslate"><span class="pre">#include</span></code> directive.  Include file checking macros must be used
as expressions in <code class="docutils literal notranslate"><span class="pre">#if</span></code> or <code class="docutils literal notranslate"><span class="pre">#elif</span></code> preprocessing directives.</p>
<div class="section" id="has-include">
<span id="langext-has-include"></span><h3><code class="docutils literal notranslate"><span class="pre">__has_include</span></code><a class="headerlink" href="#has-include" title="Permalink to this headline">¶</a></h3>
<p>This function-like macro takes a single file name string argument that is the
name of an include file.  It evaluates to 1 if the file can be found using the
include paths, or 0 otherwise:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Note the two possible file name string formats.</span>
<span class="cp">#if __has_include(&quot;myinclude.h&quot;) &amp;&amp; __has_include(&lt;stdint.h&gt;)</span>
<span class="cp">#</span><span class="w"> </span><span class="cp">include</span><span class="w"> </span><span class="cpf">&quot;myinclude.h&quot;</span><span class="cp"></span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>To test for this feature, use <code class="docutils literal notranslate"><span class="pre">#if</span> <span class="pre">defined(__has_include)</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// To avoid problem with non-clang compilers not having this macro.</span>
<span class="cp">#if defined(__has_include)</span>
<span class="cp">#if __has_include(&quot;myinclude.h&quot;)</span>
<span class="cp">#</span><span class="w"> </span><span class="cp">include</span><span class="w"> </span><span class="cpf">&quot;myinclude.h&quot;</span><span class="cp"></span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
</pre></div>
</div>
</div>
<div class="section" id="has-include-next">
<span id="langext-has-include-next"></span><h3><code class="docutils literal notranslate"><span class="pre">__has_include_next</span></code><a class="headerlink" href="#has-include-next" title="Permalink to this headline">¶</a></h3>
<p>This function-like macro takes a single file name string argument that is the
name of an include file.  It is like <code class="docutils literal notranslate"><span class="pre">__has_include</span></code> except that it looks for
the second instance of the given file found in the include paths.  It evaluates
to 1 if the second instance of the file can be found using the include paths,
or 0 otherwise:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Note the two possible file name string formats.</span>
<span class="cp">#if __has_include_next(&quot;myinclude.h&quot;) &amp;&amp; __has_include_next(&lt;stdint.h&gt;)</span>
<span class="cp"># include_next &quot;myinclude.h&quot;</span>
<span class="cp">#endif</span>

<span class="c1">// To avoid problem with non-clang compilers not having this macro.</span>
<span class="cp">#if defined(__has_include_next)</span>
<span class="cp">#if __has_include_next(&quot;myinclude.h&quot;)</span>
<span class="cp"># include_next &quot;myinclude.h&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">__has_include_next</span></code>, like the GNU extension <code class="docutils literal notranslate"><span class="pre">#include_next</span></code>
directive, is intended for use in headers only, and will issue a warning if
used in the top-level compilation file.  A warning will also be issued if an
absolute path is used in the file argument.</p>
</div>
<div class="section" id="has-warning">
<h3><code class="docutils literal notranslate"><span class="pre">__has_warning</span></code><a class="headerlink" href="#has-warning" title="Permalink to this headline">¶</a></h3>
<p>This function-like macro takes a string literal that represents a command line
option for a warning and returns true if that is a valid warning option.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#if __has_warning(&quot;-Wformat&quot;)</span>
<span class="p">...</span><span class="w"></span>
<span class="cp">#endif</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="builtin-macros">
<span id="languageextensions-builtin-macros"></span><h2><a class="toc-backref" href="#id15">Builtin Macros</a><a class="headerlink" href="#builtin-macros" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__BASE_FILE__</span></code></dt><dd><p>Defined to a string that contains the name of the main input file passed to
Clang.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__FILE_NAME__</span></code></dt><dd><p>Clang-specific extension that functions similar to <code class="docutils literal notranslate"><span class="pre">__FILE__</span></code> but only
renders the last path component (the filename) instead of an invocation
dependent full path to that file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__COUNTER__</span></code></dt><dd><p>Defined to an integer value that starts at zero and is incremented each time
the <code class="docutils literal notranslate"><span class="pre">__COUNTER__</span></code> macro is expanded.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__INCLUDE_LEVEL__</span></code></dt><dd><p>Defined to an integral value that is the include depth of the file currently
being translated.  For the main file, this value is zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__TIMESTAMP__</span></code></dt><dd><p>Defined to the date and time of the last modification of the current source
file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__clang__</span></code></dt><dd><p>Defined when compiling with Clang</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__clang_major__</span></code></dt><dd><p>Defined to the major marketing version number of Clang (e.g., the 2 in
2.0.1).  Note that marketing version numbers should not be used to check for
language features, as different vendors use different numbering schemes.
Instead, use the <a class="reference internal" href="#langext-feature-check"><span class="std std-ref">Feature Checking Macros</span></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__clang_minor__</span></code></dt><dd><p>Defined to the minor version number of Clang (e.g., the 0 in 2.0.1).  Note
that marketing version numbers should not be used to check for language
features, as different vendors use different numbering schemes.  Instead, use
the <a class="reference internal" href="#langext-feature-check"><span class="std std-ref">Feature Checking Macros</span></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__clang_patchlevel__</span></code></dt><dd><p>Defined to the marketing patch level of Clang (e.g., the 1 in 2.0.1).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__clang_version__</span></code></dt><dd><p>Defined to a string that captures the Clang marketing version, including the
Subversion tag or revision number, e.g., “<code class="docutils literal notranslate"><span class="pre">1.5</span> <span class="pre">(trunk</span> <span class="pre">102332)</span></code>”.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__clang_literal_encoding__</span></code></dt><dd><p>Defined to a narrow string literal that represents the current encoding of
narrow string literals, e.g., <code class="docutils literal notranslate"><span class="pre">&quot;hello&quot;</span></code>. This macro typically expands to
“UTF-8” (but may change in the future if the
<code class="docutils literal notranslate"><span class="pre">-fexec-charset=&quot;Encoding-Name&quot;</span></code> option is implemented.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__clang_wide_literal_encoding__</span></code></dt><dd><p>Defined to a narrow string literal that represents the current encoding of
wide string literals, e.g., <code class="docutils literal notranslate"><span class="pre">L&quot;hello&quot;</span></code>. This macro typically expands to
“UTF-16” or “UTF-32” (but may change in the future if the
<code class="docutils literal notranslate"><span class="pre">-fwide-exec-charset=&quot;Encoding-Name&quot;</span></code> option is implemented.)</p>
</dd>
</dl>
</div>
<div class="section" id="vectors-and-extended-vectors">
<span id="langext-vectors"></span><h2><a class="toc-backref" href="#id16">Vectors and Extended Vectors</a><a class="headerlink" href="#vectors-and-extended-vectors" title="Permalink to this headline">¶</a></h2>
<p>Supports the GCC, OpenCL, AltiVec, NEON and SVE vector extensions.</p>
<p>OpenCL vector types are created using the <code class="docutils literal notranslate"><span class="pre">ext_vector_type</span></code> attribute.  It
supports the <code class="docutils literal notranslate"><span class="pre">V.xyzw</span></code> syntax and other tidbits as seen in OpenCL.  An example
is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">float4</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">ext_vector_type</span><span class="p">(</span><span class="mi">4</span><span class="p">)));</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">float2</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">ext_vector_type</span><span class="p">(</span><span class="mi">2</span><span class="p">)));</span><span class="w"></span>

<span class="n">float4</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">float2</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">float2</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">float4</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">c</span><span class="p">.</span><span class="n">xz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">c</span><span class="p">.</span><span class="n">yw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_attribute(ext_vector_type)</span></code>.</p>
<p>Giving <code class="docutils literal notranslate"><span class="pre">-maltivec</span></code> option to clang enables support for AltiVec vector syntax
and functions.  For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec_add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">vector</span><span class="w"> </span><span class="kt">float</span><span class="p">)</span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>NEON vector types are created using <code class="docutils literal notranslate"><span class="pre">neon_vector_type</span></code> and
<code class="docutils literal notranslate"><span class="pre">neon_polyvector_type</span></code> attributes.  For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">neon_vector_type</span><span class="p">(</span><span class="mi">8</span><span class="p">)))</span><span class="w"> </span><span class="kt">int8_t</span><span class="w"> </span><span class="n">int8x8_t</span><span class="p">;</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">neon_polyvector_type</span><span class="p">(</span><span class="mi">16</span><span class="p">)))</span><span class="w"> </span><span class="n">poly8_t</span><span class="w"> </span><span class="n">poly8x16_t</span><span class="p">;</span><span class="w"></span>

<span class="n">int8x8_t</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">int8x8_t</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">int8x8_t</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>GCC vector types are created using the <code class="docutils literal notranslate"><span class="pre">vector_size(N)</span></code> attribute.  The
argument <code class="docutils literal notranslate"><span class="pre">N</span></code> specifies the number of bytes that will be allocated for an
object of this type.  The size has to be multiple of the size of the vector
element type. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// OK: This declares a vector type with four &#39;int&#39; elements</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">int4</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">vector_size</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))));</span><span class="w"></span>

<span class="c1">// ERROR: &#39;11&#39; is not a multiple of sizeof(int)</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">int_impossible</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">vector_size</span><span class="p">(</span><span class="mi">11</span><span class="p">)));</span><span class="w"></span>

<span class="n">int4</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">int4</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">int4</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="boolean-vectors">
<h3>Boolean Vectors<a class="headerlink" href="#boolean-vectors" title="Permalink to this headline">¶</a></h3>
<p>Clang also supports the ext_vector_type attribute with boolean element types in
C and C++.  For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// legal for Clang, error for GCC:</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">bool4</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">ext_vector_type</span><span class="p">(</span><span class="mi">4</span><span class="p">)));</span><span class="w"></span>
<span class="c1">// Objects of bool4 type hold 8 bits, sizeof(bool4) == 1</span>

<span class="n">bool4</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">bool4</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">bool4</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Boolean vectors are a Clang extension of the ext vector type.  Boolean vectors
are intended, though not guaranteed, to map to vector mask registers.  The size
parameter of a boolean vector type is the number of bits in the vector.  The
boolean vector is dense and each bit in the boolean vector is one vector
element.</p>
<p>The semantics of boolean vectors borrows from C bit-fields with the following
differences:</p>
<ul class="simple">
<li><p>Distinct boolean vectors are always distinct memory objects (there is no
packing).</p></li>
<li><p>Only the operators <cite>?:</cite>, <cite>!</cite>, <cite>~</cite>, <cite>|</cite>, <cite>&amp;</cite>, <cite>^</cite> and comparison are allowed on
boolean vectors.</p></li>
<li><p>Casting a scalar bool value to a boolean vector type means broadcasting the
scalar value onto all lanes (same as general ext_vector_type).</p></li>
<li><p>It is not possible to access or swizzle elements of a boolean vector
(different than general ext_vector_type).</p></li>
</ul>
<p>The size and alignment are both the number of bits rounded up to the next power
of two, but the alignment is at most the maximum vector alignment of the
target.</p>
</div>
<div class="section" id="vector-literals">
<h3>Vector Literals<a class="headerlink" href="#vector-literals" title="Permalink to this headline">¶</a></h3>
<p>Vector literals can be used to create vectors from a set of scalars, or
vectors.  Either parentheses or braces form can be used.  In the parentheses
form the number of literal values specified must be one, i.e. referring to a
scalar value, or must match the size of the vector type being created.  If a
single scalar literal value is specified, the scalar literal value will be
replicated to all the components of the vector type.  In the brackets form any
number of literals can be specified.  For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v4si</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">__vector_size__</span><span class="p">(</span><span class="mi">16</span><span class="p">)));</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">float4</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">ext_vector_type</span><span class="p">(</span><span class="mi">4</span><span class="p">)));</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">float2</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">ext_vector_type</span><span class="p">(</span><span class="mi">2</span><span class="p">)));</span><span class="w"></span>

<span class="n">v4si</span><span class="w"> </span><span class="n">vsi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">v4si</span><span class="p">){</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">};</span><span class="w"></span>
<span class="n">float4</span><span class="w"> </span><span class="n">vf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">float4</span><span class="p">)(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">4.0f</span><span class="p">);</span><span class="w"></span>
<span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">vi1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="p">)(</span><span class="mi">1</span><span class="p">);</span><span class="w">    </span><span class="c1">// vi1 will be (1, 1, 1, 1).</span>
<span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">vi2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="p">){</span><span class="mi">1</span><span class="p">};</span><span class="w">    </span><span class="c1">// vi2 will be (1, 0, 0, 0).</span>
<span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">vi3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="c1">// error</span>
<span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">vi4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="p">){</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">};</span><span class="w"> </span><span class="c1">// vi4 will be (1, 2, 0, 0).</span>
<span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">vi5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="n">float4</span><span class="w"> </span><span class="n">vf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">float4</span><span class="p">)((</span><span class="n">float2</span><span class="p">)(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="n">float2</span><span class="p">)(</span><span class="mf">3.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">4.0f</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="vector-operations">
<span id="id1"></span><h3>Vector Operations<a class="headerlink" href="#vector-operations" title="Permalink to this headline">¶</a></h3>
<p>The table below shows the support for each operation by vector extension.  A
dash indicates that an operation is not accepted according to a corresponding
specification.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 41%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 18%" />
<col style="width: 10%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operator</p></th>
<th class="head"><p>OpenCL</p></th>
<th class="head"><p>AltiVec</p></th>
<th class="head"><p>GCC</p></th>
<th class="head"><p>NEON</p></th>
<th class="head"><p>SVE</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>[]</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-odd"><td><p>unary operators +, –</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-even"><td><p>++, – –</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>+,–,*,/,%</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-even"><td><p>bitwise operators &amp;,|,^,~</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-odd"><td><p>&gt;&gt;,&lt;&lt;</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-even"><td><p>!, &amp;&amp;, ||</p></td>
<td><p>yes</p></td>
<td><p>–</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-odd"><td><p>==, !=, &gt;, &lt;, &gt;=, &lt;=</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-even"><td><p>=</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-odd"><td><p>?: <a class="footnote-reference brackets" href="#id5" id="id2">1</a></p></td>
<td><p>yes</p></td>
<td><p>–</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-even"><td><p>sizeof</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes <a class="footnote-reference brackets" href="#id6" id="id3">2</a></p></td>
</tr>
<tr class="row-odd"><td><p>C-style cast</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p>reinterpret_cast</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>static_cast</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p>const_cast</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>address &amp;v[i]</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>no <a class="footnote-reference brackets" href="#id7" id="id4">3</a></p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
</tbody>
</table>
<p>See also <a class="reference internal" href="#langext-builtin-shufflevector"><span class="std std-ref">__builtin_shufflevector</span></a>, <a class="reference internal" href="#langext-builtin-convertvector"><span class="std std-ref">__builtin_convertvector</span></a>.</p>
<dl class="footnote brackets">
<dt class="label" id="id5"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>ternary operator(?:) has different behaviors depending on condition
operand’s vector type. If the condition is a GNU vector (i.e. __vector_size__),
a NEON vector or an SVE vector, it’s only available in C++ and uses normal bool
conversions (that is, != 0).
If it’s an extension (OpenCL) vector, it’s only available in C and OpenCL C.
And it selects base on signedness of the condition operands (OpenCL v1.1 s6.3.9).</p>
</dd>
<dt class="label" id="id6"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><p>sizeof can only be used on vector length specific SVE types.</p>
</dd>
<dt class="label" id="id7"><span class="brackets"><a class="fn-backref" href="#id4">3</a></span></dt>
<dd><p>Clang does not allow the address of an element to be taken while GCC
allows this. This is intentional for vectors with a boolean element type and
not implemented otherwise.</p>
</dd>
</dl>
</div>
<div class="section" id="vector-builtins">
<h3>Vector Builtins<a class="headerlink" href="#vector-builtins" title="Permalink to this headline">¶</a></h3>
<p><strong>Note: The implementation of vector builtins is work-in-progress and incomplete.</strong></p>
<p>In addition to the operators mentioned above, Clang provides a set of builtins
to perform additional operations on certain scalar and vector types.</p>
<p>Let <code class="docutils literal notranslate"><span class="pre">T</span></code> be one of the following types:</p>
<ul class="simple">
<li><p>an integer type (as in C2x 6.2.5p19), but excluding enumerated types and _Bool</p></li>
<li><p>the standard floating types float or double</p></li>
<li><p>a half-precision floating point type, if one is supported on the target</p></li>
<li><p>a vector type.</p></li>
</ul>
<p>For scalar types, consider the operation applied to a vector with a single element.</p>
<p><em>Elementwise Builtins</em></p>
<p>Each builtin returns a vector equivalent to applying the specified operation
elementwise to the input.</p>
<p>Unless specified otherwise operation(±0) = ±0 and operation(±infinity) = ±infinity</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 43%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Operation</p></th>
<th class="head"><p>Supported element types</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>T __builtin_elementwise_abs(T x)</p></td>
<td><p>return the absolute value of a number x; the absolute value of
the most negative integer remains the most negative integer</p></td>
<td><p>signed integer and floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_ceil(T x)</p></td>
<td><p>return the smallest integral value greater than or equal to x</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-even"><td><p>T __builtin_elementwise_floor(T x)</p></td>
<td><p>return the largest integral value less than or equal to x</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_roundeven(T x)</p></td>
<td><p>round x to the nearest integer value in floating point format,
rounding halfway cases to even (that is, to the nearest value
that is an even integer), regardless of the current rounding
direction.</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-even"><td><p>T__builtin_elementwise_trunc(T x)</p></td>
<td><p>return the integral value nearest to but no larger in
magnitude than x</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_max(T x, T y)</p></td>
<td><p>return x or y, whichever is larger</p></td>
<td><p>integer and floating point types</p></td>
</tr>
<tr class="row-even"><td><p>T __builtin_elementwise_min(T x, T y)</p></td>
<td><p>return x or y, whichever is smaller</p></td>
<td><p>integer and floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_add_sat(T x, T y)</p></td>
<td><p>return the sum of x and y, clamped to the range of
representable values for the signed/unsigned integer type.</p></td>
<td><p>integer types</p></td>
</tr>
<tr class="row-even"><td><p>T __builtin_elementwise_sub_sat(T x, T y)</p></td>
<td><p>return the difference of x and y, clamped to the range of
representable values for the signed/unsigned integer type.</p></td>
<td><p>integer types</p></td>
</tr>
</tbody>
</table>
<p><em>Reduction Builtins</em></p>
<p>Each builtin returns a scalar equivalent to applying the specified
operation(x, y) as recursive even-odd pairwise reduction to all vector
elements. <code class="docutils literal notranslate"><span class="pre">operation(x,</span> <span class="pre">y)</span></code> is repeatedly applied to each non-overlapping
even-odd element pair with indices <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">*</span> <span class="pre">2</span></code> and <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">*</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">1</span></code> with
<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">in</span> <span class="pre">[0,</span> <span class="pre">Number</span> <span class="pre">of</span> <span class="pre">elements</span> <span class="pre">/</span> <span class="pre">2)</span></code>. If the numbers of elements is not a
power of 2, the vector is widened with neutral elements for the reduction
at the end to the next power of 2.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_reduce_add</span><span class="p">([</span><span class="n">e3</span><span class="p">,</span><span class="w"> </span><span class="n">e2</span><span class="p">,</span><span class="w"> </span><span class="n">e1</span><span class="p">,</span><span class="w"> </span><span class="n">e0</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_reduced_add</span><span class="p">([</span><span class="n">e3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">e2</span><span class="p">,</span><span class="w"> </span><span class="n">e1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">e0</span><span class="p">])</span><span class="w"></span>
<span class="w">                                       </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">e3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">e2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">e1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">e0</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Let <code class="docutils literal notranslate"><span class="pre">VT</span></code> be a vector type and <code class="docutils literal notranslate"><span class="pre">ET</span></code> the element type of <code class="docutils literal notranslate"><span class="pre">VT</span></code>.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28%" />
<col style="width: 47%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Operation</p></th>
<th class="head"><p>Supported element types</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ET __builtin_reduce_max(VT a)</p></td>
<td><p>return x or y, whichever is larger; If exactly one argument is
a NaN, return the other argument. If both arguments are NaNs,
fmax() return a NaN.</p></td>
<td><p>integer and floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>ET __builtin_reduce_min(VT a)</p></td>
<td><p>return x or y, whichever is smaller; If exactly one argument
is a NaN, return the other argument. If both arguments are
NaNs, fmax() return a NaN.</p></td>
<td><p>integer and floating point types</p></td>
</tr>
<tr class="row-even"><td><p>ET __builtin_reduce_add(VT a)</p></td>
<td><p>+</p></td>
<td><p>integer and floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>ET __builtin_reduce_mul(VT a)</p></td>
<td><p>*</p></td>
<td><p>integer and floating point types</p></td>
</tr>
<tr class="row-even"><td><p>ET __builtin_reduce_and(VT a)</p></td>
<td><p>&amp;</p></td>
<td><p>integer types</p></td>
</tr>
<tr class="row-odd"><td><p>ET __builtin_reduce_or(VT a)</p></td>
<td><p>|</p></td>
<td><p>integer types</p></td>
</tr>
<tr class="row-even"><td><p>ET __builtin_reduce_xor(VT a)</p></td>
<td><p>^</p></td>
<td><p>integer types</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="matrix-types">
<h2><a class="toc-backref" href="#id17">Matrix Types</a><a class="headerlink" href="#matrix-types" title="Permalink to this headline">¶</a></h2>
<p>Clang provides an extension for matrix types, which is currently being
implemented. See <a class="reference internal" href="MatrixTypes.html#matrixtypes"><span class="std std-ref">the draft specification</span></a> for more details.</p>
<p>For example, the code below uses the matrix types extension to multiply two 4x4
float matrices and add the result to a third 4x4 matrix.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">m4x4_t</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">matrix_type</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)));</span><span class="w"></span>

<span class="n">m4x4_t</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">m4x4_t</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">m4x4_t</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">m4x4_t</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The matrix type extension also supports operations on a matrix and a scalar.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">m4x4_t</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">matrix_type</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)));</span><span class="w"></span>

<span class="n">m4x4_t</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">m4x4_t</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">23</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The matrix type extension supports division on a matrix and a scalar but not on a matrix and a matrix.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">m4x4_t</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">matrix_type</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)));</span><span class="w"></span>

<span class="n">m4x4_t</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">m4x4_t</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">3.0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The matrix type extension supports compound assignments for addition, subtraction, and multiplication on matrices
and on a matrix and a scalar, provided their types are consistent.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">m4x4_t</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">matrix_type</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)));</span><span class="w"></span>

<span class="n">m4x4_t</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">m4x4_t</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">m4x4_t</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">23</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The matrix type extension supports explicit casts. Implicit type conversion between matrix types is not allowed.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ix5x5</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">matrix_type</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)));</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">fx5x5</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">matrix_type</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)));</span><span class="w"></span>

<span class="n">fx5x5</span><span class="w"> </span><span class="nf">f1</span><span class="p">(</span><span class="n">ix5x5</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">fx5x5</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">fx5x5</span><span class="p">)</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">X</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">matrix_4_4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">matrix_type</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)));</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">f2</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">matrix_5_5</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">matrix_5_5</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">matrix_5_5</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span><span class="n">d</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">matrix_5_5</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">d</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="half-precision-floating-point">
<h2><a class="toc-backref" href="#id18">Half-Precision Floating Point</a><a class="headerlink" href="#half-precision-floating-point" title="Permalink to this headline">¶</a></h2>
<p>Clang supports three half-precision (16-bit) floating point types: <code class="docutils literal notranslate"><span class="pre">__fp16</span></code>,
<code class="docutils literal notranslate"><span class="pre">_Float16</span></code> and <code class="docutils literal notranslate"><span class="pre">__bf16</span></code>.  These types are supported in all language modes.</p>
<p><code class="docutils literal notranslate"><span class="pre">__fp16</span></code> is supported on every target, as it is purely a storage format; see below.
<code class="docutils literal notranslate"><span class="pre">_Float16</span></code> is currently only supported on the following targets, with further
targets pending ABI standardization:</p>
<ul class="simple">
<li><p>32-bit ARM</p></li>
<li><p>64-bit ARM (AArch64)</p></li>
<li><p>AMDGPU</p></li>
<li><p>SPIR</p></li>
<li><p>X86 (see below)</p></li>
</ul>
<p>On X86 targets, <code class="docutils literal notranslate"><span class="pre">_Float16</span></code> is supported as long as SSE2 is available, which
includes all 64-bit and all recent 32-bit processors. When the target supports
AVX512-FP16, <code class="docutils literal notranslate"><span class="pre">_Float16</span></code> arithmetic is performed using that native support.
Otherwise, <code class="docutils literal notranslate"><span class="pre">_Float16</span></code> arithmetic is performed by promoting to <code class="docutils literal notranslate"><span class="pre">float</span></code>,
performing the operation, and then truncating to <code class="docutils literal notranslate"><span class="pre">_Float16</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">_Float16</span></code> will be supported on more targets as they define ABIs for it.</p>
<p><code class="docutils literal notranslate"><span class="pre">__bf16</span></code> is purely a storage format; it is currently only supported on the following targets:
* 32-bit ARM
* 64-bit ARM (AArch64)
* X86 (see below)</p>
<p>On X86 targets, <code class="docutils literal notranslate"><span class="pre">__bf16</span></code> is supported as long as SSE2 is available, which
includes all 64-bit and all recent 32-bit processors.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__bf16</span></code> type is only available when supported in hardware.</p>
<p><code class="docutils literal notranslate"><span class="pre">__fp16</span></code> is a storage and interchange format only.  This means that values of
<code class="docutils literal notranslate"><span class="pre">__fp16</span></code> are immediately promoted to (at least) <code class="docutils literal notranslate"><span class="pre">float</span></code> when used in arithmetic
operations, so that e.g. the result of adding two <code class="docutils literal notranslate"><span class="pre">__fp16</span></code> values has type <code class="docutils literal notranslate"><span class="pre">float</span></code>.
The behavior of <code class="docutils literal notranslate"><span class="pre">__fp16</span></code> is specified by the ARM C Language Extensions (<a class="reference external" href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053d/IHI0053D_acle_2_1.pdf">ACLE</a>).
Clang uses the <code class="docutils literal notranslate"><span class="pre">binary16</span></code> format from IEEE 754-2008 for <code class="docutils literal notranslate"><span class="pre">__fp16</span></code>, not the ARM
alternative format.</p>
<p><code class="docutils literal notranslate"><span class="pre">_Float16</span></code> is an interchange floating-point type.  This means that, just like arithmetic on
<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">double</span></code>, arithmetic on <code class="docutils literal notranslate"><span class="pre">_Float16</span></code> operands is formally performed in the
<code class="docutils literal notranslate"><span class="pre">_Float16</span></code> type, so that e.g. the result of adding two <code class="docutils literal notranslate"><span class="pre">_Float16</span></code> values has type
<code class="docutils literal notranslate"><span class="pre">_Float16</span></code>.  The behavior of <code class="docutils literal notranslate"><span class="pre">_Float16</span></code> is specified by ISO/IEC TS 18661-3:2015
(“Floating-point extensions for C”).  As with <code class="docutils literal notranslate"><span class="pre">__fp16</span></code>, Clang uses the <code class="docutils literal notranslate"><span class="pre">binary16</span></code>
format from IEEE 754-2008 for <code class="docutils literal notranslate"><span class="pre">_Float16</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">_Float16</span></code> arithmetic will be performed using native half-precision support
when available on the target (e.g. on ARMv8.2a); otherwise it will be performed
at a higher precision (currently always <code class="docutils literal notranslate"><span class="pre">float</span></code>) and then truncated down to
<code class="docutils literal notranslate"><span class="pre">_Float16</span></code>.  Note that C and C++ allow intermediate floating-point operands
of an expression to be computed with greater precision than is expressible in
their type, so Clang may avoid intermediate truncations in certain cases; this may
lead to results that are inconsistent with native arithmetic.</p>
<p>It is recommended that portable code use <code class="docutils literal notranslate"><span class="pre">_Float16</span></code> instead of <code class="docutils literal notranslate"><span class="pre">__fp16</span></code>,
as it has been defined by the C standards committee and has behavior that is
more familiar to most programmers.</p>
<p>Because <code class="docutils literal notranslate"><span class="pre">__fp16</span></code> operands are always immediately promoted to <code class="docutils literal notranslate"><span class="pre">float</span></code>, the
common real type of <code class="docutils literal notranslate"><span class="pre">__fp16</span></code> and <code class="docutils literal notranslate"><span class="pre">_Float16</span></code> for the purposes of the usual
arithmetic conversions is <code class="docutils literal notranslate"><span class="pre">float</span></code>.</p>
<p>A literal can be given <code class="docutils literal notranslate"><span class="pre">_Float16</span></code> type using the suffix <code class="docutils literal notranslate"><span class="pre">f16</span></code>. For example,
<code class="docutils literal notranslate"><span class="pre">3.14f16</span></code>.</p>
<p>Because default argument promotion only applies to the standard floating-point
types, <code class="docutils literal notranslate"><span class="pre">_Float16</span></code> values are not promoted to <code class="docutils literal notranslate"><span class="pre">double</span></code> when passed as variadic
or untyped arguments.  As a consequence, some caution must be taken when using
certain library facilities with <code class="docutils literal notranslate"><span class="pre">_Float16</span></code>; for example, there is no <code class="docutils literal notranslate"><span class="pre">printf</span></code> format
specifier for <code class="docutils literal notranslate"><span class="pre">_Float16</span></code>, and (unlike <code class="docutils literal notranslate"><span class="pre">float</span></code>) it will not be implicitly promoted to
<code class="docutils literal notranslate"><span class="pre">double</span></code> when passed to <code class="docutils literal notranslate"><span class="pre">printf</span></code>, so the programmer must explicitly cast it to
<code class="docutils literal notranslate"><span class="pre">double</span></code> before using it with an <code class="docutils literal notranslate"><span class="pre">%f</span></code> or similar specifier.</p>
</div>
<div class="section" id="messages-on-deprecated-and-unavailable-attributes">
<h2><a class="toc-backref" href="#id19">Messages on <code class="docutils literal notranslate"><span class="pre">deprecated</span></code> and <code class="docutils literal notranslate"><span class="pre">unavailable</span></code> Attributes</a><a class="headerlink" href="#messages-on-deprecated-and-unavailable-attributes" title="Permalink to this headline">¶</a></h2>
<p>An optional string message can be added to the <code class="docutils literal notranslate"><span class="pre">deprecated</span></code> and
<code class="docutils literal notranslate"><span class="pre">unavailable</span></code> attributes.  For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">explode</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">deprecated</span><span class="p">(</span><span class="s">&quot;extremely unsafe, use &#39;combust&#39; instead!!!&quot;</span><span class="p">)));</span><span class="w"></span>
</pre></div>
</div>
<p>If the deprecated or unavailable declaration is used, the message will be
incorporated into the appropriate diagnostic:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>harmless.c:4:3: warning: &#39;explode&#39; is deprecated: extremely unsafe, use &#39;combust&#39; instead!!!
      [-Wdeprecated-declarations]
  explode();
  ^
</pre></div>
</div>
<p>Query for this feature with
<code class="docutils literal notranslate"><span class="pre">__has_extension(attribute_deprecated_with_message)</span></code> and
<code class="docutils literal notranslate"><span class="pre">__has_extension(attribute_unavailable_with_message)</span></code>.</p>
</div>
<div class="section" id="attributes-on-enumerators">
<h2><a class="toc-backref" href="#id20">Attributes on Enumerators</a><a class="headerlink" href="#attributes-on-enumerators" title="Permalink to this headline">¶</a></h2>
<p>Clang allows attributes to be written on individual enumerators.  This allows
enumerators to be deprecated, made unavailable, etc.  The attribute must appear
after the enumerator name and before any initializer, like so:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="nc">OperationMode</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">OM_Invalid</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">OM_Normal</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">OM_Terrified</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">deprecated</span><span class="p">)),</span><span class="w"></span>
<span class="w">  </span><span class="n">OM_AbortOnError</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">deprecated</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Attributes on the <code class="docutils literal notranslate"><span class="pre">enum</span></code> declaration do not apply to individual enumerators.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_extension(enumerator_attributes)</span></code>.</p>
</div>
<div class="section" id="c-11-attributes-on-using-declarations">
<h2><a class="toc-backref" href="#id21">C++11 Attributes on using-declarations</a><a class="headerlink" href="#c-11-attributes-on-using-declarations" title="Permalink to this headline">¶</a></h2>
<p>Clang allows C++-style <code class="docutils literal notranslate"><span class="pre">[[]]</span></code> attributes to be written on using-declarations.
For instance:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">using_if_exists</span><span class="p">]]</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">foo</span><span class="o">::</span><span class="n">baz</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">using_if_exists</span><span class="p">]];</span><span class="w"></span>
</pre></div>
</div>
<p>You can test for support for this extension with
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_attributes_on_using_declarations)</span></code>.</p>
</div>
<div class="section" id="user-specified-system-frameworks">
<h2><a class="toc-backref" href="#id22">‘User-Specified’ System Frameworks</a><a class="headerlink" href="#user-specified-system-frameworks" title="Permalink to this headline">¶</a></h2>
<p>Clang provides a mechanism by which frameworks can be built in such a way that
they will always be treated as being “system frameworks”, even if they are not
present in a system framework directory.  This can be useful to system
framework developers who want to be able to test building other applications
with development builds of their framework, including the manner in which the
compiler changes warning behavior for system headers.</p>
<p>Framework developers can opt-in to this mechanism by creating a
“<code class="docutils literal notranslate"><span class="pre">.system_framework</span></code>” file at the top-level of their framework.  That is, the
framework should have contents like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.../TestFramework.framework
.../TestFramework.framework/.system_framework
.../TestFramework.framework/Headers
.../TestFramework.framework/Headers/TestFramework.h
...
</pre></div>
</div>
<p>Clang will treat the presence of this file as an indicator that the framework
should be treated as a system framework, regardless of how it was found in the
framework search path.  For consistency, we recommend that such files never be
included in installed versions of the framework.</p>
</div>
<div class="section" id="checks-for-standard-language-features">
<h2><a class="toc-backref" href="#id23">Checks for Standard Language Features</a><a class="headerlink" href="#checks-for-standard-language-features" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">__has_feature</span></code> macro can be used to query if certain standard language
features are enabled.  The <code class="docutils literal notranslate"><span class="pre">__has_extension</span></code> macro can be used to query if
language features are available as an extension when compiling for a standard
which does not provide them.  The features which can be tested are listed here.</p>
<p>Since Clang 3.4, the C++ SD-6 feature test macros are also supported.
These are macros with names of the form <code class="docutils literal notranslate"><span class="pre">__cpp_&lt;feature_name&gt;</span></code>, and are
intended to be a portable way to query the supported features of the compiler.
See <a class="reference external" href="https://clang.llvm.org/cxx_status.html#ts">the C++ status page</a> for
information on the version of SD-6 supported by each Clang release, and the
macros provided by that revision of the recommendations.</p>
<div class="section" id="c-98">
<h3>C++98<a class="headerlink" href="#c-98" title="Permalink to this headline">¶</a></h3>
<p>The features listed below are part of the C++98 standard.  These features are
enabled by default when compiling C++ code.</p>
<div class="section" id="c-exceptions">
<h4>C++ exceptions<a class="headerlink" href="#c-exceptions" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_exceptions)</span></code> to determine if C++ exceptions have been
enabled.  For example, compiling code with <code class="docutils literal notranslate"><span class="pre">-fno-exceptions</span></code> disables C++
exceptions.</p>
</div>
<div class="section" id="c-rtti">
<h4>C++ RTTI<a class="headerlink" href="#c-rtti" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_rtti)</span></code> to determine if C++ RTTI has been enabled.  For
example, compiling code with <code class="docutils literal notranslate"><span class="pre">-fno-rtti</span></code> disables the use of RTTI.</p>
</div>
</div>
<div class="section" id="c-11">
<h3>C++11<a class="headerlink" href="#c-11" title="Permalink to this headline">¶</a></h3>
<p>The features listed below are part of the C++11 standard.  As a result, all
these features are enabled with the <code class="docutils literal notranslate"><span class="pre">-std=c++11</span></code> or <code class="docutils literal notranslate"><span class="pre">-std=gnu++11</span></code> option
when compiling C++ code.</p>
<div class="section" id="c-11-sfinae-includes-access-control">
<h4>C++11 SFINAE includes access control<a class="headerlink" href="#c-11-sfinae-includes-access-control" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_access_control_sfinae)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_access_control_sfinae)</span></code> to determine whether
access-control errors (e.g., calling a private constructor) are considered to
be template argument deduction errors (aka SFINAE errors), per <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1170">C++ DR1170</a>.</p>
</div>
<div class="section" id="c-11-alias-templates">
<h4>C++11 alias templates<a class="headerlink" href="#c-11-alias-templates" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_alias_templates)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_alias_templates)</span></code> to determine if support for C++11’s
alias declarations and alias templates is enabled.</p>
</div>
<div class="section" id="c-11-alignment-specifiers">
<h4>C++11 alignment specifiers<a class="headerlink" href="#c-11-alignment-specifiers" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_alignas)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_alignas)</span></code> to
determine if support for alignment specifiers using <code class="docutils literal notranslate"><span class="pre">alignas</span></code> is enabled.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_alignof)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_alignof)</span></code> to
determine if support for the <code class="docutils literal notranslate"><span class="pre">alignof</span></code> keyword is enabled.</p>
</div>
<div class="section" id="c-11-attributes">
<h4>C++11 attributes<a class="headerlink" href="#c-11-attributes" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_attributes)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_attributes)</span></code> to
determine if support for attribute parsing with C++11’s square bracket notation
is enabled.</p>
</div>
<div class="section" id="c-11-generalized-constant-expressions">
<h4>C++11 generalized constant expressions<a class="headerlink" href="#c-11-generalized-constant-expressions" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_constexpr)</span></code> to determine if support for generalized
constant expressions (e.g., <code class="docutils literal notranslate"><span class="pre">constexpr</span></code>) is enabled.</p>
</div>
<div class="section" id="c-11-decltype">
<h4>C++11 <code class="docutils literal notranslate"><span class="pre">decltype()</span></code><a class="headerlink" href="#c-11-decltype" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_decltype)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_decltype)</span></code> to
determine if support for the <code class="docutils literal notranslate"><span class="pre">decltype()</span></code> specifier is enabled.  C++11’s
<code class="docutils literal notranslate"><span class="pre">decltype</span></code> does not require type-completeness of a function call expression.
Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_decltype_incomplete_return_types)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_decltype_incomplete_return_types)</span></code> to determine if
support for this feature is enabled.</p>
</div>
<div class="section" id="c-11-default-template-arguments-in-function-templates">
<h4>C++11 default template arguments in function templates<a class="headerlink" href="#c-11-default-template-arguments-in-function-templates" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_default_function_template_args)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_default_function_template_args)</span></code> to determine if support
for default template arguments in function templates is enabled.</p>
</div>
<div class="section" id="c-11-defaulted-functions">
<h4>C++11 <code class="docutils literal notranslate"><span class="pre">default</span></code>ed functions<a class="headerlink" href="#c-11-defaulted-functions" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_defaulted_functions)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_defaulted_functions)</span></code> to determine if support for
defaulted function definitions (with <code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">default</span></code>) is enabled.</p>
</div>
<div class="section" id="c-11-delegating-constructors">
<h4>C++11 delegating constructors<a class="headerlink" href="#c-11-delegating-constructors" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_delegating_constructors)</span></code> to determine if support for
delegating constructors is enabled.</p>
</div>
<div class="section" id="c-11-deleted-functions">
<h4>C++11 <code class="docutils literal notranslate"><span class="pre">deleted</span></code> functions<a class="headerlink" href="#c-11-deleted-functions" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_deleted_functions)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_deleted_functions)</span></code> to determine if support for deleted
function definitions (with <code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">delete</span></code>) is enabled.</p>
</div>
<div class="section" id="c-11-explicit-conversion-functions">
<h4>C++11 explicit conversion functions<a class="headerlink" href="#c-11-explicit-conversion-functions" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_explicit_conversions)</span></code> to determine if support for
<code class="docutils literal notranslate"><span class="pre">explicit</span></code> conversion functions is enabled.</p>
</div>
<div class="section" id="c-11-generalized-initializers">
<h4>C++11 generalized initializers<a class="headerlink" href="#c-11-generalized-initializers" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_generalized_initializers)</span></code> to determine if support for
generalized initializers (using braced lists and <code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code>) is
enabled.</p>
</div>
<div class="section" id="c-11-implicit-move-constructors-assignment-operators">
<h4>C++11 implicit move constructors/assignment operators<a class="headerlink" href="#c-11-implicit-move-constructors-assignment-operators" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_implicit_moves)</span></code> to determine if Clang will implicitly
generate move constructors and move assignment operators where needed.</p>
</div>
<div class="section" id="c-11-inheriting-constructors">
<h4>C++11 inheriting constructors<a class="headerlink" href="#c-11-inheriting-constructors" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_inheriting_constructors)</span></code> to determine if support for
inheriting constructors is enabled.</p>
</div>
<div class="section" id="c-11-inline-namespaces">
<h4>C++11 inline namespaces<a class="headerlink" href="#c-11-inline-namespaces" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_inline_namespaces)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_inline_namespaces)</span></code> to determine if support for inline
namespaces is enabled.</p>
</div>
<div class="section" id="c-11-lambdas">
<h4>C++11 lambdas<a class="headerlink" href="#c-11-lambdas" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_lambdas)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_lambdas)</span></code> to
determine if support for lambdas is enabled.</p>
</div>
<div class="section" id="c-11-local-and-unnamed-types-as-template-arguments">
<h4>C++11 local and unnamed types as template arguments<a class="headerlink" href="#c-11-local-and-unnamed-types-as-template-arguments" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_local_type_template_args)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_local_type_template_args)</span></code> to determine if support for
local and unnamed types as template arguments is enabled.</p>
</div>
<div class="section" id="c-11-noexcept">
<h4>C++11 noexcept<a class="headerlink" href="#c-11-noexcept" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_noexcept)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_noexcept)</span></code> to
determine if support for noexcept exception specifications is enabled.</p>
</div>
<div class="section" id="c-11-in-class-non-static-data-member-initialization">
<h4>C++11 in-class non-static data member initialization<a class="headerlink" href="#c-11-in-class-non-static-data-member-initialization" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_nonstatic_member_init)</span></code> to determine whether in-class
initialization of non-static data members is enabled.</p>
</div>
<div class="section" id="c-11-nullptr">
<h4>C++11 <code class="docutils literal notranslate"><span class="pre">nullptr</span></code><a class="headerlink" href="#c-11-nullptr" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_nullptr)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_nullptr)</span></code> to
determine if support for <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> is enabled.</p>
</div>
<div class="section" id="c-11-override-control">
<h4>C++11 <code class="docutils literal notranslate"><span class="pre">override</span> <span class="pre">control</span></code><a class="headerlink" href="#c-11-override-control" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_override_control)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_override_control)</span></code> to determine if support for the
override control keywords is enabled.</p>
</div>
<div class="section" id="c-11-reference-qualified-functions">
<h4>C++11 reference-qualified functions<a class="headerlink" href="#c-11-reference-qualified-functions" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_reference_qualified_functions)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_reference_qualified_functions)</span></code> to determine if support
for reference-qualified functions (e.g., member functions with <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> or <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>
applied to <code class="docutils literal notranslate"><span class="pre">*this</span></code>) is enabled.</p>
</div>
<div class="section" id="c-11-range-based-for-loop">
<h4>C++11 range-based <code class="docutils literal notranslate"><span class="pre">for</span></code> loop<a class="headerlink" href="#c-11-range-based-for-loop" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_range_for)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_range_for)</span></code> to
determine if support for the range-based for loop is enabled.</p>
</div>
<div class="section" id="c-11-raw-string-literals">
<h4>C++11 raw string literals<a class="headerlink" href="#c-11-raw-string-literals" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_raw_string_literals)</span></code> to determine if support for raw
string literals (e.g., <code class="docutils literal notranslate"><span class="pre">R&quot;x(foo\bar)x&quot;</span></code>) is enabled.</p>
</div>
<div class="section" id="c-11-rvalue-references">
<h4>C++11 rvalue references<a class="headerlink" href="#c-11-rvalue-references" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_rvalue_references)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_rvalue_references)</span></code> to determine if support for rvalue
references is enabled.</p>
</div>
<div class="section" id="c-11-static-assert">
<h4>C++11 <code class="docutils literal notranslate"><span class="pre">static_assert()</span></code><a class="headerlink" href="#c-11-static-assert" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_static_assert)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_static_assert)</span></code> to determine if support for compile-time
assertions using <code class="docutils literal notranslate"><span class="pre">static_assert</span></code> is enabled.</p>
</div>
<div class="section" id="c-11-thread-local">
<h4>C++11 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code><a class="headerlink" href="#c-11-thread-local" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_thread_local)</span></code> to determine if support for
<code class="docutils literal notranslate"><span class="pre">thread_local</span></code> variables is enabled.</p>
</div>
<div class="section" id="c-11-type-inference">
<h4>C++11 type inference<a class="headerlink" href="#c-11-type-inference" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_auto_type)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_auto_type)</span></code> to
determine C++11 type inference is supported using the <code class="docutils literal notranslate"><span class="pre">auto</span></code> specifier.  If
this is disabled, <code class="docutils literal notranslate"><span class="pre">auto</span></code> will instead be a storage class specifier, as in C
or C++98.</p>
</div>
<div class="section" id="c-11-strongly-typed-enumerations">
<h4>C++11 strongly typed enumerations<a class="headerlink" href="#c-11-strongly-typed-enumerations" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_strong_enums)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_strong_enums)</span></code> to determine if support for strongly
typed, scoped enumerations is enabled.</p>
</div>
<div class="section" id="c-11-trailing-return-type">
<h4>C++11 trailing return type<a class="headerlink" href="#c-11-trailing-return-type" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_trailing_return)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_trailing_return)</span></code> to determine if support for the
alternate function declaration syntax with trailing return type is enabled.</p>
</div>
<div class="section" id="c-11-unicode-string-literals">
<h4>C++11 Unicode string literals<a class="headerlink" href="#c-11-unicode-string-literals" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_unicode_literals)</span></code> to determine if support for Unicode
string literals is enabled.</p>
</div>
<div class="section" id="c-11-unrestricted-unions">
<h4>C++11 unrestricted unions<a class="headerlink" href="#c-11-unrestricted-unions" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_unrestricted_unions)</span></code> to determine if support for
unrestricted unions is enabled.</p>
</div>
<div class="section" id="c-11-user-defined-literals">
<h4>C++11 user-defined literals<a class="headerlink" href="#c-11-user-defined-literals" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_user_literals)</span></code> to determine if support for
user-defined literals is enabled.</p>
</div>
<div class="section" id="c-11-variadic-templates">
<h4>C++11 variadic templates<a class="headerlink" href="#c-11-variadic-templates" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_variadic_templates)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_variadic_templates)</span></code> to determine if support for
variadic templates is enabled.</p>
</div>
</div>
<div class="section" id="c-14">
<h3>C++14<a class="headerlink" href="#c-14" title="Permalink to this headline">¶</a></h3>
<p>The features listed below are part of the C++14 standard.  As a result, all
these features are enabled with the <code class="docutils literal notranslate"><span class="pre">-std=C++14</span></code> or <code class="docutils literal notranslate"><span class="pre">-std=gnu++14</span></code> option
when compiling C++ code.</p>
<div class="section" id="c-14-binary-literals">
<h4>C++14 binary literals<a class="headerlink" href="#c-14-binary-literals" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_binary_literals)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_binary_literals)</span></code> to determine whether
binary literals (for instance, <code class="docutils literal notranslate"><span class="pre">0b10010</span></code>) are recognized. Clang supports this
feature as an extension in all language modes.</p>
</div>
<div class="section" id="c-14-contextual-conversions">
<h4>C++14 contextual conversions<a class="headerlink" href="#c-14-contextual-conversions" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_contextual_conversions)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_contextual_conversions)</span></code> to determine if the C++14 rules
are used when performing an implicit conversion for an array bound in a
<em>new-expression</em>, the operand of a <em>delete-expression</em>, an integral constant
expression, or a condition in a <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement.</p>
</div>
<div class="section" id="c-14-decltype-auto">
<h4>C++14 decltype(auto)<a class="headerlink" href="#c-14-decltype-auto" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_decltype_auto)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_decltype_auto)</span></code> to determine if support
for the <code class="docutils literal notranslate"><span class="pre">decltype(auto)</span></code> placeholder type is enabled.</p>
</div>
<div class="section" id="c-14-default-initializers-for-aggregates">
<h4>C++14 default initializers for aggregates<a class="headerlink" href="#c-14-default-initializers-for-aggregates" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_aggregate_nsdmi)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_aggregate_nsdmi)</span></code> to determine if support
for default initializers in aggregate members is enabled.</p>
</div>
<div class="section" id="c-14-digit-separators">
<h4>C++14 digit separators<a class="headerlink" href="#c-14-digit-separators" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__cpp_digit_separators</span></code> to determine if support for digit separators
using single quotes (for instance, <code class="docutils literal notranslate"><span class="pre">10'000</span></code>) is enabled. At this time, there
is no corresponding <code class="docutils literal notranslate"><span class="pre">__has_feature</span></code> name</p>
</div>
<div class="section" id="c-14-generalized-lambda-capture">
<h4>C++14 generalized lambda capture<a class="headerlink" href="#c-14-generalized-lambda-capture" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_init_captures)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_init_captures)</span></code> to determine if support for
lambda captures with explicit initializers is enabled
(for instance, <code class="docutils literal notranslate"><span class="pre">[n(0)]</span> <span class="pre">{</span> <span class="pre">return</span> <span class="pre">++n;</span> <span class="pre">}</span></code>).</p>
</div>
<div class="section" id="c-14-generic-lambdas">
<h4>C++14 generic lambdas<a class="headerlink" href="#c-14-generic-lambdas" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_generic_lambdas)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_generic_lambdas)</span></code> to determine if support for generic
(polymorphic) lambdas is enabled
(for instance, <code class="docutils literal notranslate"><span class="pre">[]</span> <span class="pre">(auto</span> <span class="pre">x)</span> <span class="pre">{</span> <span class="pre">return</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1;</span> <span class="pre">}</span></code>).</p>
</div>
<div class="section" id="c-14-relaxed-constexpr">
<h4>C++14 relaxed constexpr<a class="headerlink" href="#c-14-relaxed-constexpr" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_relaxed_constexpr)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_relaxed_constexpr)</span></code> to determine if variable
declarations, local variable modification, and control flow constructs
are permitted in <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> functions.</p>
</div>
<div class="section" id="c-14-return-type-deduction">
<h4>C++14 return type deduction<a class="headerlink" href="#c-14-return-type-deduction" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_return_type_deduction)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_return_type_deduction)</span></code> to determine if support
for return type deduction for functions (using <code class="docutils literal notranslate"><span class="pre">auto</span></code> as a return type)
is enabled.</p>
</div>
<div class="section" id="c-14-runtime-sized-arrays">
<h4>C++14 runtime-sized arrays<a class="headerlink" href="#c-14-runtime-sized-arrays" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_runtime_array)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_runtime_array)</span></code> to determine if support
for arrays of runtime bound (a restricted form of variable-length arrays)
is enabled.
Clang’s implementation of this feature is incomplete.</p>
</div>
<div class="section" id="c-14-variable-templates">
<h4>C++14 variable templates<a class="headerlink" href="#c-14-variable-templates" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_variable_templates)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_variable_templates)</span></code> to determine if support for
templated variable declarations is enabled.</p>
</div>
</div>
<div class="section" id="c11">
<h3>C11<a class="headerlink" href="#c11" title="Permalink to this headline">¶</a></h3>
<p>The features listed below are part of the C11 standard.  As a result, all these
features are enabled with the <code class="docutils literal notranslate"><span class="pre">-std=c11</span></code> or <code class="docutils literal notranslate"><span class="pre">-std=gnu11</span></code> option when
compiling C code.  Additionally, because these features are all
backward-compatible, they are available as extensions in all language modes.</p>
<div class="section" id="c11-alignment-specifiers">
<h4>C11 alignment specifiers<a class="headerlink" href="#c11-alignment-specifiers" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(c_alignas)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(c_alignas)</span></code> to determine
if support for alignment specifiers using <code class="docutils literal notranslate"><span class="pre">_Alignas</span></code> is enabled.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(c_alignof)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(c_alignof)</span></code> to determine
if support for the <code class="docutils literal notranslate"><span class="pre">_Alignof</span></code> keyword is enabled.</p>
</div>
<div class="section" id="c11-atomic-operations">
<h4>C11 atomic operations<a class="headerlink" href="#c11-atomic-operations" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(c_atomic)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(c_atomic)</span></code> to determine
if support for atomic types using <code class="docutils literal notranslate"><span class="pre">_Atomic</span></code> is enabled.  Clang also provides
<a class="reference internal" href="#langext-c11-atomic"><span class="std std-ref">a set of builtins</span></a> which can be used to implement
the <code class="docutils literal notranslate"><span class="pre">&lt;stdatomic.h&gt;</span></code> operations on <code class="docutils literal notranslate"><span class="pre">_Atomic</span></code> types. Use
<code class="docutils literal notranslate"><span class="pre">__has_include(&lt;stdatomic.h&gt;)</span></code> to determine if C11’s <code class="docutils literal notranslate"><span class="pre">&lt;stdatomic.h&gt;</span></code> header
is available.</p>
<p>Clang will use the system’s <code class="docutils literal notranslate"><span class="pre">&lt;stdatomic.h&gt;</span></code> header when one is available, and
will otherwise use its own. When using its own, implementations of the atomic
operations are provided as macros. In the cases where C11 also requires a real
function, this header provides only the declaration of that function (along
with a shadowing macro implementation), and you must link to a library which
provides a definition of the function if you use it instead of the macro.</p>
</div>
<div class="section" id="c11-generic-selections">
<h4>C11 generic selections<a class="headerlink" href="#c11-generic-selections" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(c_generic_selections)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(c_generic_selections)</span></code> to determine if support for generic
selections is enabled.</p>
<p>As an extension, the C11 generic selection expression is available in all
languages supported by Clang.  The syntax is the same as that given in the C11
standard.</p>
<p>In C, type compatibility is decided according to the rules given in the
appropriate standard, but in C++, which lacks the type compatibility rules used
in C, types are considered compatible only if they are equivalent.</p>
</div>
<div class="section" id="c11-static-assert">
<h4>C11 <code class="docutils literal notranslate"><span class="pre">_Static_assert()</span></code><a class="headerlink" href="#c11-static-assert" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(c_static_assert)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(c_static_assert)</span></code>
to determine if support for compile-time assertions using <code class="docutils literal notranslate"><span class="pre">_Static_assert</span></code> is
enabled.</p>
</div>
<div class="section" id="c11-thread-local">
<h4>C11 <code class="docutils literal notranslate"><span class="pre">_Thread_local</span></code><a class="headerlink" href="#c11-thread-local" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(c_thread_local)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(c_thread_local)</span></code>
to determine if support for <code class="docutils literal notranslate"><span class="pre">_Thread_local</span></code> variables is enabled.</p>
</div>
</div>
<div class="section" id="modules">
<h3>Modules<a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h3>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(modules)</span></code> to determine if Modules have been enabled.
For example, compiling code with <code class="docutils literal notranslate"><span class="pre">-fmodules</span></code> enables the use of Modules.</p>
<p>More information could be found <a class="reference external" href="https://clang.llvm.org/docs/Modules.html">here</a>.</p>
</div>
</div>
<div class="section" id="type-trait-primitives">
<h2><a class="toc-backref" href="#id24">Type Trait Primitives</a><a class="headerlink" href="#type-trait-primitives" title="Permalink to this headline">¶</a></h2>
<p>Type trait primitives are special builtin constant expressions that can be used
by the standard C++ library to facilitate or simplify the implementation of
user-facing type traits in the &lt;type_traits&gt; header.</p>
<p>They are not intended to be used directly by user code because they are
implementation-defined and subject to change – as such they’re tied closely to
the supported set of system headers, currently:</p>
<ul class="simple">
<li><p>LLVM’s own libc++</p></li>
<li><p>GNU libstdc++</p></li>
<li><p>The Microsoft standard C++ library</p></li>
</ul>
<p>Clang supports the <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/Type-Traits.html">GNU C++ type traits</a> and a subset of the
<a class="reference external" href="https://msdn.microsoft.com/en-us/library/ms177194(v=VS.100).aspx">Microsoft Visual C++ type traits</a>,
as well as nearly all of the
<a class="reference external" href="http://docwiki.embarcadero.com/RADStudio/Rio/en/Type_Trait_Functions_(C%2B%2B11)_Index">Embarcadero C++ type traits</a>.</p>
<p>The following type trait primitives are supported by Clang. Those traits marked
(C++) provide implementations for type traits specified by the C++ standard;
<code class="docutils literal notranslate"><span class="pre">__X(...)</span></code> has the same semantics and constraints as the corresponding
<code class="docutils literal notranslate"><span class="pre">std::X_t&lt;...&gt;</span></code> or <code class="docutils literal notranslate"><span class="pre">std::X_v&lt;...&gt;</span></code> type trait.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__array_rank(type)</span></code> (Embarcadero):
Returns the number of levels of array in the type <code class="docutils literal notranslate"><span class="pre">type</span></code>:
<code class="docutils literal notranslate"><span class="pre">0</span></code> if <code class="docutils literal notranslate"><span class="pre">type</span></code> is not an array type, and
<code class="docutils literal notranslate"><span class="pre">__array_rank(element)</span> <span class="pre">+</span> <span class="pre">1</span></code> if <code class="docutils literal notranslate"><span class="pre">type</span></code> is an array of <code class="docutils literal notranslate"><span class="pre">element</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__array_extent(type,</span> <span class="pre">dim)</span></code> (Embarcadero):
The <code class="docutils literal notranslate"><span class="pre">dim</span></code>’th array bound in the type <code class="docutils literal notranslate"><span class="pre">type</span></code>, or <code class="docutils literal notranslate"><span class="pre">0</span></code> if
<code class="docutils literal notranslate"><span class="pre">dim</span> <span class="pre">&gt;=</span> <span class="pre">__array_rank(type)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_nothrow_assign</span></code> (GNU, Microsoft, Embarcadero):
Deprecated, use <code class="docutils literal notranslate"><span class="pre">__is_nothrow_assignable</span></code> instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_nothrow_move_assign</span></code> (GNU, Microsoft):
Deprecated, use <code class="docutils literal notranslate"><span class="pre">__is_nothrow_assignable</span></code> instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_nothrow_copy</span></code> (GNU, Microsoft):
Deprecated, use <code class="docutils literal notranslate"><span class="pre">__is_nothrow_constructible</span></code> instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_nothrow_constructor</span></code> (GNU, Microsoft):
Deprecated, use <code class="docutils literal notranslate"><span class="pre">__is_nothrow_constructible</span></code> instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_trivial_assign</span></code> (GNU, Microsoft, Embarcadero):
Deprecated, use <code class="docutils literal notranslate"><span class="pre">__is_trivially_assignable</span></code> instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_trivial_move_assign</span></code> (GNU, Microsoft):
Deprecated, use <code class="docutils literal notranslate"><span class="pre">__is_trivially_assignable</span></code> instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_trivial_copy</span></code> (GNU, Microsoft):
Deprecated, use <code class="docutils literal notranslate"><span class="pre">__is_trivially_copyable</span></code> instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_trivial_constructor</span></code> (GNU, Microsoft):
Deprecated, use <code class="docutils literal notranslate"><span class="pre">__is_trivially_constructible</span></code> instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_trivial_move_constructor</span></code> (GNU, Microsoft):
Deprecated, use <code class="docutils literal notranslate"><span class="pre">__is_trivially_constructible</span></code> instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_trivial_destructor</span></code> (GNU, Microsoft, Embarcadero):
Deprecated, use <code class="docutils literal notranslate"><span class="pre">__is_trivially_destructible</span></code> instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_unique_object_representations</span></code> (C++, GNU)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_virtual_destructor</span></code> (C++, GNU, Microsoft, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_abstract</span></code> (C++, GNU, Microsoft, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_aggregate</span></code> (C++, GNU, Microsoft)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_arithmetic</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_array</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_assignable</span></code> (C++, MSVC 2015)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_base_of</span></code> (C++, GNU, Microsoft, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_class</span></code> (C++, GNU, Microsoft, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_complete_type(type)</span></code> (Embarcadero):
Return <code class="docutils literal notranslate"><span class="pre">true</span></code> if <code class="docutils literal notranslate"><span class="pre">type</span></code> is a complete type.
Warning: this trait is dangerous because it can return different values at
different points in the same program.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_compound</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_const</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_constructible</span></code> (C++, MSVC 2013)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_convertible</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_convertible_to</span></code> (Microsoft):
Synonym for <code class="docutils literal notranslate"><span class="pre">__is_convertible</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_destructible</span></code> (C++, MSVC 2013):
Only available in <code class="docutils literal notranslate"><span class="pre">-fms-extensions</span></code> mode.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_empty</span></code> (C++, GNU, Microsoft, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_enum</span></code> (C++, GNU, Microsoft, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_final</span></code> (C++, GNU, Microsoft)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_floating_point</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_function</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_fundamental</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_integral</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_interface_class</span></code> (Microsoft):
Returns <code class="docutils literal notranslate"><span class="pre">false</span></code>, even for types defined with <code class="docutils literal notranslate"><span class="pre">__interface</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_literal</span></code> (Clang):
Synonym for <code class="docutils literal notranslate"><span class="pre">__is_literal_type</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_literal_type</span></code> (C++, GNU, Microsoft):
Note, the corresponding standard trait was deprecated in C++17
and removed in C++20.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_lvalue_reference</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_member_object_pointer</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_member_function_pointer</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_member_pointer</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_nothrow_assignable</span></code> (C++, MSVC 2013)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_nothrow_constructible</span></code> (C++, MSVC 2013)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_nothrow_destructible</span></code> (C++, MSVC 2013)
Only available in <code class="docutils literal notranslate"><span class="pre">-fms-extensions</span></code> mode.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_object</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_pod</span></code> (C++, GNU, Microsoft, Embarcadero):
Note, the corresponding standard trait was deprecated in C++20.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_pointer</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_polymorphic</span></code> (C++, GNU, Microsoft, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_reference</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_rvalue_reference</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_same</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_same_as</span></code> (GCC): Synonym for <code class="docutils literal notranslate"><span class="pre">__is_same</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_scalar</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_sealed</span></code> (Microsoft):
Synonym for <code class="docutils literal notranslate"><span class="pre">__is_final</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_signed</span></code> (C++, Embarcadero):
Returns false for enumeration types, and returns true for floating-point
types. Note, before Clang 10, returned true for enumeration types if the
underlying type was signed, and returned false for floating-point types.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_standard_layout</span></code> (C++, GNU, Microsoft, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_trivial</span></code> (C++, GNU, Microsoft, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_trivially_assignable</span></code> (C++, GNU, Microsoft)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_trivially_constructible</span></code> (C++, GNU, Microsoft)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_trivially_copyable</span></code> (C++, GNU, Microsoft)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_trivially_destructible</span></code> (C++, MSVC 2013)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_trivially_relocatable</span></code> (Clang): Returns true if moving an object
of the given type, and then destroying the source object, is known to be
functionally equivalent to copying the underlying bytes and then dropping the
source object on the floor. This is true of trivial types and types which
were made trivially relocatable via the <code class="docutils literal notranslate"><span class="pre">clang::trivial_abi</span></code> attribute.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_union</span></code> (C++, GNU, Microsoft, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_unsigned</span></code> (C++, Embarcadero):
Returns false for enumeration types. Note, before Clang 13, returned true for
enumeration types if the underlying type was unsigned.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_void</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_volatile</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__reference_binds_to_temporary(T,</span> <span class="pre">U)</span></code> (Clang):  Determines whether a
reference of type <code class="docutils literal notranslate"><span class="pre">T</span></code> bound to an expression of type <code class="docutils literal notranslate"><span class="pre">U</span></code> would bind to a
materialized temporary object. If <code class="docutils literal notranslate"><span class="pre">T</span></code> is not a reference type the result
is false. Note this trait will also return false when the initialization of
<code class="docutils literal notranslate"><span class="pre">T</span></code> from <code class="docutils literal notranslate"><span class="pre">U</span></code> is ill-formed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__underlying_type</span></code> (C++, GNU, Microsoft)</p></li>
</ul>
<p>In addition, the following expression traits are supported:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__is_lvalue_expr(e)</span></code> (Embarcadero):
Returns true if <code class="docutils literal notranslate"><span class="pre">e</span></code> is an lvalue expression.
Deprecated, use <code class="docutils literal notranslate"><span class="pre">__is_lvalue_reference(decltype((e)))</span></code> instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_rvalue_expr(e)</span></code> (Embarcadero):
Returns true if <code class="docutils literal notranslate"><span class="pre">e</span></code> is a prvalue expression.
Deprecated, use <code class="docutils literal notranslate"><span class="pre">!__is_reference(decltype((e)))</span></code> instead.</p></li>
</ul>
<p>There are multiple ways to detect support for a type trait <code class="docutils literal notranslate"><span class="pre">__X</span></code> in the
compiler, depending on the oldest version of Clang you wish to support.</p>
<ul class="simple">
<li><p>From Clang 10 onwards, <code class="docutils literal notranslate"><span class="pre">__has_builtin(__X)</span></code> can be used.</p></li>
<li><p>From Clang 6 onwards, <code class="docutils literal notranslate"><span class="pre">!__is_identifier(__X)</span></code> can be used.</p></li>
<li><p>From Clang 3 onwards, <code class="docutils literal notranslate"><span class="pre">__has_feature(X)</span></code> can be used, but only supports
the following traits:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_nothrow_assign</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_nothrow_copy</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_nothrow_constructor</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_trivial_assign</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_trivial_copy</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_trivial_constructor</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_trivial_destructor</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_virtual_destructor</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_abstract</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_base_of</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_class</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_constructible</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_convertible_to</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_empty</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_enum</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_final</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_literal</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_standard_layout</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_pod</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_polymorphic</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_sealed</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_trivial</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_trivially_assignable</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_trivially_constructible</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_trivially_copyable</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_union</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__underlying_type</span></code></p></li>
</ul>
</li>
</ul>
<p>A simplistic usage example as might be seen in standard C++ headers follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#if __has_builtin(__is_convertible_to)</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">From</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span> <span class="nc">To</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">is_convertible_to</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__is_convertible_to</span><span class="p">(</span><span class="n">From</span><span class="p">,</span><span class="w"> </span><span class="n">To</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="cp">#else</span>
<span class="c1">// Emulate type trait for compatibility with other compilers.</span>
<span class="cp">#endif</span>
</pre></div>
</div>
</div>
<div class="section" id="blocks">
<h2><a class="toc-backref" href="#id25">Blocks</a><a class="headerlink" href="#blocks" title="Permalink to this headline">¶</a></h2>
<p>The syntax and high level language feature description is in
<a class="reference internal" href="BlockLanguageSpec.html"><span class="doc">BlockLanguageSpec</span></a>. Implementation and ABI details for
the clang implementation are in <a class="reference internal" href="Block-ABI-Apple.html"><span class="doc">Block-ABI-Apple</span></a>.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_extension(blocks)</span></code>.</p>
</div>
<div class="section" id="asm-goto-with-output-constraints">
<h2><a class="toc-backref" href="#id26">ASM Goto with Output Constraints</a><a class="headerlink" href="#asm-goto-with-output-constraints" title="Permalink to this headline">¶</a></h2>
<p>In addition to the functionality provided by <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">GCC’s extended
assembly</a>, clang
supports output constraints with the <cite>goto</cite> form.</p>
<p>The goto form of GCC’s extended assembly allows the programmer to branch to a C
label from within an inline assembly block. Clang extends this behavior by
allowing the programmer to use output constraints:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">asm</span><span class="w"> </span><span class="k">goto</span><span class="p">(</span><span class="s">&quot;# %0 %1 %l2&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">err</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="nl">err</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>It’s important to note that outputs are valid only on the “fallthrough” branch.
Using outputs on an indirect branch may result in undefined behavior. For
example, in the function above, use of the value assigned to <cite>y</cite> in the <cite>err</cite>
block is undefined behavior.</p>
<p>When using tied-outputs (i.e. outputs that are inputs and outputs, not just
outputs) with the <cite>+r</cite> constraint, there is a hidden input that’s created
before the label, so numeric references to operands must account for that.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// %0 and %1 both refer to x</span>
<span class="w">    </span><span class="c1">// %l2 refers to err</span>
<span class="w">    </span><span class="k">asm</span><span class="w"> </span><span class="k">goto</span><span class="p">(</span><span class="s">&quot;# %0 %1 %l2&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;+r&quot;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">err</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="nl">err</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This was changed to match GCC in clang-13; for better portability, symbolic
references can be used instead of numeric references.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">asm</span><span class="w"> </span><span class="k">goto</span><span class="p">(</span><span class="s">&quot;# %[x] %l[err]&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="s">&quot;+r&quot;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">err</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="nl">err</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_extension(gnu_asm_goto_with_outputs)</span></code>.</p>
</div>
<div class="section" id="objective-c-features">
<h2><a class="toc-backref" href="#id27">Objective-C Features</a><a class="headerlink" href="#objective-c-features" title="Permalink to this headline">¶</a></h2>
<div class="section" id="related-result-types">
<h3>Related result types<a class="headerlink" href="#related-result-types" title="Permalink to this headline">¶</a></h3>
<p>According to Cocoa conventions, Objective-C methods with certain names
(“<code class="docutils literal notranslate"><span class="pre">init</span></code>”, “<code class="docutils literal notranslate"><span class="pre">alloc</span></code>”, etc.) always return objects that are an instance of
the receiving class’s type.  Such methods are said to have a “related result
type”, meaning that a message send to one of these methods will have the same
static type as an instance of the receiver class.  For example, given the
following classes:</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="bp">NSObject</span><span class="w"></span>
<span class="p">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">alloc</span><span class="p">;</span><span class="w"></span>
<span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span><span class="p">;</span><span class="w"></span>
<span class="k">@end</span><span class="w"></span>

<span class="k">@interface</span> <span class="bp">NSArray</span> : <span class="bp">NSObject</span><span class="w"></span>
<span class="k">@end</span><span class="w"></span>
</pre></div>
</div>
<p>and this common initialization pattern</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="bp">NSArray</span><span class="w"> </span><span class="o">*</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[[</span><span class="bp">NSArray</span><span class="w"> </span><span class="n">alloc</span><span class="p">]</span><span class="w"> </span><span class="n">init</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<p>the type of the expression <code class="docutils literal notranslate"><span class="pre">[NSArray</span> <span class="pre">alloc]</span></code> is <code class="docutils literal notranslate"><span class="pre">NSArray*</span></code> because
<code class="docutils literal notranslate"><span class="pre">alloc</span></code> implicitly has a related result type.  Similarly, the type of the
expression <code class="docutils literal notranslate"><span class="pre">[[NSArray</span> <span class="pre">alloc]</span> <span class="pre">init]</span></code> is <code class="docutils literal notranslate"><span class="pre">NSArray*</span></code>, since <code class="docutils literal notranslate"><span class="pre">init</span></code> has a
related result type and its receiver is known to have the type <code class="docutils literal notranslate"><span class="pre">NSArray</span> <span class="pre">*</span></code>.
If neither <code class="docutils literal notranslate"><span class="pre">alloc</span></code> nor <code class="docutils literal notranslate"><span class="pre">init</span></code> had a related result type, the expressions
would have had type <code class="docutils literal notranslate"><span class="pre">id</span></code>, as declared in the method signature.</p>
<p>A method with a related result type can be declared by using the type
<code class="docutils literal notranslate"><span class="pre">instancetype</span></code> as its result type.  <code class="docutils literal notranslate"><span class="pre">instancetype</span></code> is a contextual keyword
that is only permitted in the result type of an Objective-C method, e.g.</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="nc">A</span><span class="w"></span>
<span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">constructAnA</span><span class="p">;</span><span class="w"></span>
<span class="k">@end</span><span class="w"></span>
</pre></div>
</div>
<p>The related result type can also be inferred for some methods.  To determine
whether a method has an inferred related result type, the first word in the
camel-case selector (e.g., “<code class="docutils literal notranslate"><span class="pre">init</span></code>” in “<code class="docutils literal notranslate"><span class="pre">initWithObjects</span></code>”) is considered,
and the method will have a related result type if its return type is compatible
with the type of its class and if:</p>
<ul class="simple">
<li><p>the first word is “<code class="docutils literal notranslate"><span class="pre">alloc</span></code>” or “<code class="docutils literal notranslate"><span class="pre">new</span></code>”, and the method is a class method,
or</p></li>
<li><p>the first word is “<code class="docutils literal notranslate"><span class="pre">autorelease</span></code>”, “<code class="docutils literal notranslate"><span class="pre">init</span></code>”, “<code class="docutils literal notranslate"><span class="pre">retain</span></code>”, or “<code class="docutils literal notranslate"><span class="pre">self</span></code>”,
and the method is an instance method.</p></li>
</ul>
<p>If a method with a related result type is overridden by a subclass method, the
subclass method must also return a type that is compatible with the subclass
type.  For example:</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="bp">NSString</span> : <span class="bp">NSObject</span><span class="w"></span>
<span class="p">-</span> <span class="p">(</span><span class="n">NSUnrelated</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="nf">init</span><span class="p">;</span><span class="w"> </span><span class="c1">// incorrect usage: NSUnrelated is not NSString or a superclass of NSString</span>
<span class="k">@end</span><span class="w"></span>
</pre></div>
</div>
<p>Related result types only affect the type of a message send or property access
via the given method.  In all other respects, a method with a related result
type is treated the same way as method that returns <code class="docutils literal notranslate"><span class="pre">id</span></code>.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(objc_instancetype)</span></code> to determine whether the
<code class="docutils literal notranslate"><span class="pre">instancetype</span></code> contextual keyword is available.</p>
</div>
<div class="section" id="automatic-reference-counting">
<h3>Automatic reference counting<a class="headerlink" href="#automatic-reference-counting" title="Permalink to this headline">¶</a></h3>
<p>Clang provides support for <a class="reference internal" href="AutomaticReferenceCounting.html"><span class="doc">automated reference counting</span></a> in Objective-C, which eliminates the need
for manual <code class="docutils literal notranslate"><span class="pre">retain</span></code>/<code class="docutils literal notranslate"><span class="pre">release</span></code>/<code class="docutils literal notranslate"><span class="pre">autorelease</span></code> message sends.  There are three
feature macros associated with automatic reference counting:
<code class="docutils literal notranslate"><span class="pre">__has_feature(objc_arc)</span></code> indicates the availability of automated reference
counting in general, while <code class="docutils literal notranslate"><span class="pre">__has_feature(objc_arc_weak)</span></code> indicates that
automated reference counting also includes support for <code class="docutils literal notranslate"><span class="pre">__weak</span></code> pointers to
Objective-C objects. <code class="docutils literal notranslate"><span class="pre">__has_feature(objc_arc_fields)</span></code> indicates that C structs
are allowed to have fields that are pointers to Objective-C objects managed by
automatic reference counting.</p>
</div>
<div class="section" id="weak-references">
<span id="objc-weak"></span><h3>Weak references<a class="headerlink" href="#weak-references" title="Permalink to this headline">¶</a></h3>
<p>Clang supports ARC-style weak and unsafe references in Objective-C even
outside of ARC mode.  Weak references must be explicitly enabled with
the <code class="docutils literal notranslate"><span class="pre">-fobjc-weak</span></code> option; use <code class="docutils literal notranslate"><span class="pre">__has_feature((objc_arc_weak))</span></code>
to test whether they are enabled.  Unsafe references are enabled
unconditionally.  ARC-style weak and unsafe references cannot be used
when Objective-C garbage collection is enabled.</p>
<p>Except as noted below, the language rules for the <code class="docutils literal notranslate"><span class="pre">__weak</span></code> and
<code class="docutils literal notranslate"><span class="pre">__unsafe_unretained</span></code> qualifiers (and the <code class="docutils literal notranslate"><span class="pre">weak</span></code> and
<code class="docutils literal notranslate"><span class="pre">unsafe_unretained</span></code> property attributes) are just as laid out
in the <a class="reference internal" href="AutomaticReferenceCounting.html"><span class="doc">ARC specification</span></a>.
In particular, note that some classes do not support forming weak
references to their instances, and note that special care must be
taken when storing weak references in memory where initialization
and deinitialization are outside the responsibility of the compiler
(such as in <code class="docutils literal notranslate"><span class="pre">malloc</span></code>-ed memory).</p>
<p>Loading from a <code class="docutils literal notranslate"><span class="pre">__weak</span></code> variable always implicitly retains the
loaded value.  In non-ARC modes, this retain is normally balanced
by an implicit autorelease.  This autorelease can be suppressed
by performing the load in the receiver position of a <code class="docutils literal notranslate"><span class="pre">-retain</span></code>
message send (e.g. <code class="docutils literal notranslate"><span class="pre">[weakReference</span> <span class="pre">retain]</span></code>); note that this performs
only a single retain (the retain done when primitively loading from
the weak reference).</p>
<p>For the most part, <code class="docutils literal notranslate"><span class="pre">__unsafe_unretained</span></code> in non-ARC modes is just the
default behavior of variables and therefore is not needed.  However,
it does have an effect on the semantics of block captures: normally,
copying a block which captures an Objective-C object or block pointer
causes the captured pointer to be retained or copied, respectively,
but that behavior is suppressed when the captured variable is qualified
with <code class="docutils literal notranslate"><span class="pre">__unsafe_unretained</span></code>.</p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">__weak</span></code> qualifier formerly meant the GC qualifier in
all non-ARC modes and was silently ignored outside of GC modes.  It now
means the ARC-style qualifier in all non-GC modes and is no longer
allowed if not enabled by either <code class="docutils literal notranslate"><span class="pre">-fobjc-arc</span></code> or <code class="docutils literal notranslate"><span class="pre">-fobjc-weak</span></code>.
It is expected that <code class="docutils literal notranslate"><span class="pre">-fobjc-weak</span></code> will eventually be enabled by default
in all non-GC Objective-C modes.</p>
</div>
<div class="section" id="enumerations-with-a-fixed-underlying-type">
<span id="objc-fixed-enum"></span><h3>Enumerations with a fixed underlying type<a class="headerlink" href="#enumerations-with-a-fixed-underlying-type" title="Permalink to this headline">¶</a></h3>
<p>Clang provides support for C++11 enumerations with a fixed underlying type
within Objective-C.  For example, one can write an enumeration type as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span> <span class="o">:</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Red</span><span class="p">,</span><span class="w"> </span><span class="n">Green</span><span class="p">,</span><span class="w"> </span><span class="n">Blue</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="n">Color</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>This specifies that the underlying type, which is used to store the enumeration
value, is <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code>.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(objc_fixed_enum)</span></code> to determine whether support for fixed
underlying types is available in Objective-C.</p>
</div>
<div class="section" id="interoperability-with-c-11-lambdas">
<h3>Interoperability with C++11 lambdas<a class="headerlink" href="#interoperability-with-c-11-lambdas" title="Permalink to this headline">¶</a></h3>
<p>Clang provides interoperability between C++11 lambdas and blocks-based APIs, by
permitting a lambda to be implicitly converted to a block pointer with the
corresponding signature.  For example, consider an API such as <code class="docutils literal notranslate"><span class="pre">NSArray</span></code>’s
array-sorting method:</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="bp">NSArray</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="nf">sortedArrayUsingComparator:</span><span class="p">(</span><span class="n">NSComparator</span><span class="p">)</span><span class="nv">cmptr</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">NSComparator</span></code> is simply a typedef for the block pointer <code class="docutils literal notranslate"><span class="pre">NSComparisonResult</span>
<span class="pre">(^)(id,</span> <span class="pre">id)</span></code>, and parameters of this type are generally provided with block
literals as arguments.  However, one can also use a C++11 lambda so long as it
provides the same signature (in this case, accepting two parameters of type
<code class="docutils literal notranslate"><span class="pre">id</span></code> and returning an <code class="docutils literal notranslate"><span class="pre">NSComparisonResult</span></code>):</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="bp">NSArray</span><span class="w"> </span><span class="o">*</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="l">@[</span><span class="s">@&quot;string 1&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">@&quot;string 21&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">@&quot;string 12&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">@&quot;String 11&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                   </span><span class="s">@&quot;String 02&quot;</span><span class="l">]</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">NSStringCompareOptions</span><span class="w"> </span><span class="n">comparisonOptions</span><span class="w"></span>
<span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">NSCaseInsensitiveSearch</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">NSNumericSearch</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="w">    </span><span class="n">NSWidthInsensitiveSearch</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">NSForcedOrderingSearch</span><span class="p">;</span><span class="w"></span>
<span class="bp">NSLocale</span><span class="w"> </span><span class="o">*</span><span class="n">currentLocale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="bp">NSLocale</span><span class="w"> </span><span class="n">currentLocale</span><span class="p">];</span><span class="w"></span>
<span class="bp">NSArray</span><span class="w"> </span><span class="o">*</span><span class="n">sorted</span><span class="w"></span>
<span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">array</span><span class="w"> </span><span class="nl">sortedArrayUsingComparator</span><span class="p">:[</span><span class="o">=</span><span class="p">](</span><span class="kt">id</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="kt">id</span><span class="w"> </span><span class="n">s2</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">NSComparisonResult</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">             </span><span class="n">NSRange</span><span class="w"> </span><span class="n">string1Range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">s1</span><span class="w"> </span><span class="n">length</span><span class="p">]);</span><span class="w"></span>
<span class="w">             </span><span class="k">return</span><span class="w"> </span><span class="p">[</span><span class="n">s1</span><span class="w"> </span><span class="nl">compare</span><span class="p">:</span><span class="n">s2</span><span class="w"> </span><span class="nl">options</span><span class="p">:</span><span class="n">comparisonOptions</span><span class="w"></span>
<span class="w">             </span><span class="nl">range</span><span class="p">:</span><span class="n">string1Range</span><span class="w"> </span><span class="nl">locale</span><span class="p">:</span><span class="n">currentLocale</span><span class="p">];</span><span class="w"></span>
<span class="w">     </span><span class="p">}];</span><span class="w"></span>
<span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;sorted: %@&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sorted</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This code relies on an implicit conversion from the type of the lambda
expression (an unnamed, local class type called the <em>closure type</em>) to the
corresponding block pointer type.  The conversion itself is expressed by a
conversion operator in that closure type that produces a block pointer with the
same signature as the lambda itself, e.g.,</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="n">operator</span><span class="w"> </span><span class="nf">NSComparisonResult</span><span class="w"> </span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span><span class="w"> </span><span class="kt">id</span><span class="p">)()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>This conversion function returns a new block that simply forwards the two
parameters to the lambda object (which it captures by copy), then returns the
result.  The returned block is first copied (with <code class="docutils literal notranslate"><span class="pre">Block_copy</span></code>) and then
autoreleased.  As an optimization, if a lambda expression is immediately
converted to a block pointer (as in the first example, above), then the block
is not copied and autoreleased: rather, it is given the same lifetime as a
block literal written at that point in the program, which avoids the overhead
of copying a block to the heap in the common case.</p>
<p>The conversion from a lambda to a block pointer is only available in
Objective-C++, and not in C++ with blocks, due to its use of Objective-C memory
management (autorelease).</p>
</div>
<div class="section" id="object-literals-and-subscripting">
<h3>Object Literals and Subscripting<a class="headerlink" href="#object-literals-and-subscripting" title="Permalink to this headline">¶</a></h3>
<p>Clang provides support for <a class="reference internal" href="ObjectiveCLiterals.html"><span class="doc">Object Literals and Subscripting</span></a> in Objective-C, which simplifies common Objective-C
programming patterns, makes programs more concise, and improves the safety of
container creation.  There are several feature macros associated with object
literals and subscripting: <code class="docutils literal notranslate"><span class="pre">__has_feature(objc_array_literals)</span></code> tests the
availability of array literals; <code class="docutils literal notranslate"><span class="pre">__has_feature(objc_dictionary_literals)</span></code>
tests the availability of dictionary literals;
<code class="docutils literal notranslate"><span class="pre">__has_feature(objc_subscripting)</span></code> tests the availability of object
subscripting.</p>
</div>
<div class="section" id="objective-c-autosynthesis-of-properties">
<h3>Objective-C Autosynthesis of Properties<a class="headerlink" href="#objective-c-autosynthesis-of-properties" title="Permalink to this headline">¶</a></h3>
<p>Clang provides support for autosynthesis of declared properties.  Using this
feature, clang provides default synthesis of those properties not declared
&#64;dynamic and not having user provided backing getter and setter methods.
<code class="docutils literal notranslate"><span class="pre">__has_feature(objc_default_synthesize_properties)</span></code> checks for availability
of this feature in version of clang being used.</p>
</div>
<div class="section" id="objective-c-retaining-behavior-attributes">
<span id="langext-objc-retain-release"></span><h3>Objective-C retaining behavior attributes<a class="headerlink" href="#objective-c-retaining-behavior-attributes" title="Permalink to this headline">¶</a></h3>
<p>In Objective-C, functions and methods are generally assumed to follow the
<a class="reference external" href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html">Cocoa Memory Management</a>
conventions for ownership of object arguments and
return values. However, there are exceptions, and so Clang provides attributes
to allow these exceptions to be documented. This are used by ARC and the
<a class="reference external" href="https://clang-analyzer.llvm.org">static analyzer</a> Some exceptions may be
better described using the <code class="docutils literal notranslate"><span class="pre">objc_method_family</span></code> attribute instead.</p>
<p><strong>Usage</strong>: The <code class="docutils literal notranslate"><span class="pre">ns_returns_retained</span></code>, <code class="docutils literal notranslate"><span class="pre">ns_returns_not_retained</span></code>,
<code class="docutils literal notranslate"><span class="pre">ns_returns_autoreleased</span></code>, <code class="docutils literal notranslate"><span class="pre">cf_returns_retained</span></code>, and
<code class="docutils literal notranslate"><span class="pre">cf_returns_not_retained</span></code> attributes can be placed on methods and functions
that return Objective-C or CoreFoundation objects. They are commonly placed at
the end of a function prototype or method declaration:</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="kt">id</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="bp">__attribute__</span><span class="p">((</span><span class="n">ns_returns_retained</span><span class="p">));</span><span class="w"></span>

<span class="p">-</span> <span class="p">(</span><span class="bp">NSString</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="nf">bar:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">x</span><span class="w"> </span><span class="bp">__attribute__</span><span class="p">((</span><span class="n">ns_returns_retained</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">*_returns_retained</span></code> attributes specify that the returned object has a +1
retain count.  The <code class="docutils literal notranslate"><span class="pre">*_returns_not_retained</span></code> attributes specify that the return
object has a +0 retain count, even if the normal convention for its selector
would be +1.  <code class="docutils literal notranslate"><span class="pre">ns_returns_autoreleased</span></code> specifies that the returned object is
+0, but is guaranteed to live at least as long as the next flush of an
autorelease pool.</p>
<p><strong>Usage</strong>: The <code class="docutils literal notranslate"><span class="pre">ns_consumed</span></code> and <code class="docutils literal notranslate"><span class="pre">cf_consumed</span></code> attributes can be placed on
an parameter declaration; they specify that the argument is expected to have a
+1 retain count, which will be balanced in some way by the function or method.
The <code class="docutils literal notranslate"><span class="pre">ns_consumes_self</span></code> attribute can only be placed on an Objective-C
method; it specifies that the method expects its <code class="docutils literal notranslate"><span class="pre">self</span></code> parameter to have a
+1 retain count, which it will balance in some way.</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="bp">__attribute__</span><span class="p">((</span><span class="n">ns_consumed</span><span class="p">))</span><span class="w"> </span><span class="bp">NSString</span><span class="w"> </span><span class="o">*</span><span class="n">string</span><span class="p">);</span><span class="w"></span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">bar</span><span class="w"> </span><span class="bp">__attribute__</span><span class="p">((</span><span class="n">ns_consumes_self</span><span class="p">));</span><span class="w"></span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">baz:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span> <span class="nv">__attribute__</span><span class="p">((</span><span class="n">ns_consumed</span><span class="p">))</span> <span class="nv">x</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Further examples of these attributes are available in the static analyzer’s <a class="reference external" href="https://clang-analyzer.llvm.org/annotations.html#cocoa_mem">list of annotations for analysis</a>.</p>
<p>Query for these features with <code class="docutils literal notranslate"><span class="pre">__has_attribute(ns_consumed)</span></code>,
<code class="docutils literal notranslate"><span class="pre">__has_attribute(ns_returns_retained)</span></code>, etc.</p>
</div>
<div class="section" id="objective-c-available">
<h3>Objective-C &#64;available<a class="headerlink" href="#objective-c-available" title="Permalink to this headline">¶</a></h3>
<p>It is possible to use the newest SDK but still build a program that can run on
older versions of macOS and iOS by passing <code class="docutils literal notranslate"><span class="pre">-mmacosx-version-min=</span></code> /
<code class="docutils literal notranslate"><span class="pre">-miphoneos-version-min=</span></code>.</p>
<p>Before LLVM 5.0, when calling a function that exists only in the OS that’s
newer than the target OS (as determined by the minimum deployment version),
programmers had to carefully check if the function exists at runtime, using
null checks for weakly-linked C functions, <code class="docutils literal notranslate"><span class="pre">+class</span></code> for Objective-C classes,
and <code class="docutils literal notranslate"><span class="pre">-respondsToSelector:</span></code> or <code class="docutils literal notranslate"><span class="pre">+instancesRespondToSelector:</span></code> for
Objective-C methods.  If such a check was missed, the program would compile
fine, run fine on newer systems, but crash on older systems.</p>
<p>As of LLVM 5.0, <code class="docutils literal notranslate"><span class="pre">-Wunguarded-availability</span></code> uses the <a class="reference external" href="https://clang.llvm.org/docs/AttributeReference.html#availability">availability attributes</a> together
with the new <code class="docutils literal notranslate"><span class="pre">&#64;available()</span></code> keyword to assist with this issue.
When a method that’s introduced in the OS newer than the target OS is called, a
-Wunguarded-availability warning is emitted if that call is not guarded:</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">my_fun</span><span class="p">(</span><span class="n">NSSomeClass</span><span class="o">*</span><span class="w"> </span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// If fancyNewMethod was added in e.g. macOS 10.12, but the code is</span>
<span class="w">  </span><span class="c1">// built with -mmacosx-version-min=10.11, then this unconditional call</span>
<span class="w">  </span><span class="c1">// will emit a -Wunguarded-availability warning:</span>
<span class="w">  </span><span class="p">[</span><span class="n">var</span><span class="w"> </span><span class="n">fancyNewMethod</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>To fix the warning and to avoid the crash on macOS 10.11, wrap it in
<code class="docutils literal notranslate"><span class="pre">if(&#64;available())</span></code>:</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">my_fun</span><span class="p">(</span><span class="n">NSSomeClass</span><span class="o">*</span><span class="w"> </span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(@</span><span class="n">available</span><span class="p">(</span><span class="n">macOS</span><span class="w"> </span><span class="mf">10.12</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="n">var</span><span class="w"> </span><span class="n">fancyNewMethod</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Put fallback behavior for old macOS versions (and for non-mac</span>
<span class="w">    </span><span class="c1">// platforms) here.</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">*</span></code> is required and means that platforms not explicitly listed will take
the true branch, and the compiler will emit <code class="docutils literal notranslate"><span class="pre">-Wunguarded-availability</span></code>
warnings for unlisted platforms based on those platform’s deployment target.
More than one platform can be listed in <code class="docutils literal notranslate"><span class="pre">&#64;available()</span></code>:</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">my_fun</span><span class="p">(</span><span class="n">NSSomeClass</span><span class="o">*</span><span class="w"> </span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(@</span><span class="n">available</span><span class="p">(</span><span class="n">macOS</span><span class="w"> </span><span class="mf">10.12</span><span class="p">,</span><span class="w"> </span><span class="n">iOS</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="n">var</span><span class="w"> </span><span class="n">fancyNewMethod</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>If the caller of <code class="docutils literal notranslate"><span class="pre">my_fun()</span></code> already checks that <code class="docutils literal notranslate"><span class="pre">my_fun()</span></code> is only called
on 10.12, then add an <a class="reference external" href="https://clang.llvm.org/docs/AttributeReference.html#availability">availability attribute</a> to it,
which will also suppress the warning and require that calls to my_fun() are
checked:</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="n">API_AVAILABLE</span><span class="p">(</span><span class="n">macos</span><span class="p">(</span><span class="mf">10.12</span><span class="p">))</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">my_fun</span><span class="p">(</span><span class="n">NSSomeClass</span><span class="o">*</span><span class="w"> </span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">[</span><span class="n">var</span><span class="w"> </span><span class="n">fancyNewMethod</span><span class="p">];</span><span class="w">  </span><span class="c1">// Now ok.</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&#64;available()</span></code> is only available in Objective-C code.  To use the feature
in C and C++ code, use the <code class="docutils literal notranslate"><span class="pre">__builtin_available()</span></code> spelling instead.</p>
<p>If existing code uses null checks or <code class="docutils literal notranslate"><span class="pre">-respondsToSelector:</span></code>, it should
be changed to use <code class="docutils literal notranslate"><span class="pre">&#64;available()</span></code> (or <code class="docutils literal notranslate"><span class="pre">__builtin_available</span></code>) instead.</p>
<p><code class="docutils literal notranslate"><span class="pre">-Wunguarded-availability</span></code> is disabled by default, but
<code class="docutils literal notranslate"><span class="pre">-Wunguarded-availability-new</span></code>, which only emits this warning for APIs
that have been introduced in macOS &gt;= 10.13, iOS &gt;= 11, watchOS &gt;= 4 and
tvOS &gt;= 11, is enabled by default.</p>
</div>
<div class="section" id="objective-c-abi-protocol-qualifier-mangling-of-parameters">
<span id="langext-overloading"></span><h3>Objective-C++ ABI: protocol-qualifier mangling of parameters<a class="headerlink" href="#objective-c-abi-protocol-qualifier-mangling-of-parameters" title="Permalink to this headline">¶</a></h3>
<p>Starting with LLVM 3.4, Clang produces a new mangling for parameters whose
type is a qualified-<code class="docutils literal notranslate"><span class="pre">id</span></code> (e.g., <code class="docutils literal notranslate"><span class="pre">id&lt;Foo&gt;</span></code>).  This mangling allows such
parameters to be differentiated from those with the regular unqualified <code class="docutils literal notranslate"><span class="pre">id</span></code>
type.</p>
<p>This was a non-backward compatible mangling change to the ABI.  This change
allows proper overloading, and also prevents mangling conflicts with template
parameters of protocol-qualified type.</p>
<p>Query the presence of this new mangling with
<code class="docutils literal notranslate"><span class="pre">__has_feature(objc_protocol_qualifier_mangling)</span></code>.</p>
</div>
</div>
<div class="section" id="initializer-lists-for-complex-numbers-in-c">
<h2><a class="toc-backref" href="#id28">Initializer lists for complex numbers in C</a><a class="headerlink" href="#initializer-lists-for-complex-numbers-in-c" title="Permalink to this headline">¶</a></h2>
<p>clang supports an extension which allows the following in C:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;math.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;complex.h&gt;</span><span class="cp"></span>
<span class="n">complex</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="n">INFINITY</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// Init to (1, Inf)</span>
</pre></div>
</div>
<p>This construct is useful because there is no way to separately initialize the
real and imaginary parts of a complex variable in standard C, given that clang
does not support <code class="docutils literal notranslate"><span class="pre">_Imaginary</span></code>.  (Clang also supports the <code class="docutils literal notranslate"><span class="pre">__real__</span></code> and
<code class="docutils literal notranslate"><span class="pre">__imag__</span></code> extensions from gcc, which help in some cases, but are not usable
in static initializers.)</p>
<p>Note that this extension does not allow eliding the braces; the meaning of the
following two lines is different:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">complex</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// [0] = (1, 1)</span>
<span class="n">complex</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// [0] = (1, 0), [1] = (1, 0)</span>
</pre></div>
</div>
<p>This extension also works in C++ mode, as far as that goes, but does not apply
to the C++ <code class="docutils literal notranslate"><span class="pre">std::complex</span></code>.  (In C++11, list initialization allows the same
syntax to be used with <code class="docutils literal notranslate"><span class="pre">std::complex</span></code> with the same meaning.)</p>
<p>For GCC compatibility, <code class="docutils literal notranslate"><span class="pre">__builtin_complex(re,</span> <span class="pre">im)</span></code> can also be used to
construct a complex number from the given real and imaginary components.</p>
</div>
<div class="section" id="opencl-features">
<h2><a class="toc-backref" href="#id29">OpenCL Features</a><a class="headerlink" href="#opencl-features" title="Permalink to this headline">¶</a></h2>
<p>Clang supports internal OpenCL extensions documented below.</p>
<div class="section" id="cl-clang-bitfields">
<h3><code class="docutils literal notranslate"><span class="pre">__cl_clang_bitfields</span></code><a class="headerlink" href="#cl-clang-bitfields" title="Permalink to this headline">¶</a></h3>
<p>With this extension it is possible to enable bitfields in structs
or unions using the OpenCL extension pragma mechanism detailed in
<a class="reference external" href="https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview">the OpenCL Extension Specification, section 1.2</a>.</p>
<p>Use of bitfields in OpenCL kernels can result in reduced portability as struct
layout is not guaranteed to be consistent when compiled by different compilers.
If structs with bitfields are used as kernel function parameters, it can result
in incorrect functionality when the layout is different between the host and
device code.</p>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma OPENCL EXTENSION __cl_clang_bitfields : enable</span>
<span class="k">struct</span> <span class="nc">with_bitfield</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nl">i</span> <span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// compiled - no diagnostic generated</span>
<span class="p">};</span><span class="w"></span>

<span class="cp">#pragma OPENCL EXTENSION __cl_clang_bitfields : disable</span>
<span class="k">struct</span> <span class="nc">without_bitfield</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nl">i</span> <span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// error - bitfields are not supported</span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="cl-clang-function-pointers">
<h3><code class="docutils literal notranslate"><span class="pre">__cl_clang_function_pointers</span></code><a class="headerlink" href="#cl-clang-function-pointers" title="Permalink to this headline">¶</a></h3>
<p>With this extension it is possible to enable various language features that
are relying on function pointers using regular OpenCL extension pragma
mechanism detailed in <a class="reference external" href="https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview">the OpenCL Extension Specification,
section 1.2</a>.</p>
<p>In C++ for OpenCL this also enables:</p>
<ul class="simple">
<li><p>Use of member function pointers;</p></li>
<li><p>Unrestricted use of references to functions;</p></li>
<li><p>Virtual member functions.</p></li>
</ul>
<p>Such functionality is not conformant and does not guarantee to compile
correctly in any circumstances. It can be used if:</p>
<ul class="simple">
<li><p>the kernel source does not contain call expressions to (member-) function
pointers, or virtual functions. For example this extension can be used in
metaprogramming algorithms to be able to specify/detect types generically.</p></li>
<li><p>the generated kernel binary does not contain indirect calls because they
are eliminated using compiler optimizations e.g. devirtualization.</p></li>
<li><p>the selected target supports the function pointer like functionality e.g.
most CPU targets.</p></li>
</ul>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma OPENCL EXTENSION __cl_clang_function_pointers : enable</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)();</span><span class="w"> </span><span class="c1">// compiled - no diagnostic generated</span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#pragma OPENCL EXTENSION __cl_clang_function_pointers : disable</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)();</span><span class="w"> </span><span class="c1">// error - pointers to function are not allowed</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="cl-clang-variadic-functions">
<h3><code class="docutils literal notranslate"><span class="pre">__cl_clang_variadic_functions</span></code><a class="headerlink" href="#cl-clang-variadic-functions" title="Permalink to this headline">¶</a></h3>
<p>With this extension it is possible to enable variadic arguments in functions
using regular OpenCL extension pragma mechanism detailed in <a class="reference external" href="https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview">the OpenCL
Extension Specification, section 1.2</a>.</p>
<p>This is not conformant behavior and it can only be used portably when the
functions with variadic prototypes do not get generated in binary e.g. the
variadic prototype is used to specify a function type with any number of
arguments in metaprogramming algorithms in C++ for OpenCL.</p>
<p>This extensions can also be used when the kernel code is intended for targets
supporting the variadic arguments e.g. majority of CPU targets.</p>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma OPENCL EXTENSION __cl_clang_variadic_functions : enable</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"> </span><span class="c1">// compiled - no diagnostic generated</span>

<span class="cp">#pragma OPENCL EXTENSION __cl_clang_variadic_functions : disable</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"> </span><span class="c1">// error - variadic prototype is not allowed</span>
</pre></div>
</div>
</div>
<div class="section" id="cl-clang-non-portable-kernel-param-types">
<h3><code class="docutils literal notranslate"><span class="pre">__cl_clang_non_portable_kernel_param_types</span></code><a class="headerlink" href="#cl-clang-non-portable-kernel-param-types" title="Permalink to this headline">¶</a></h3>
<p>With this extension it is possible to enable the use of some restricted types
in kernel parameters specified in <a class="reference external" href="https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html#kernel_function">C++ for OpenCL v1.0 s2.4</a>.
The restrictions can be relaxed using regular OpenCL extension pragma mechanism
detailed in <a class="reference external" href="https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview">the OpenCL Extension Specification, section 1.2</a>.</p>
<p>This is not a conformant behavior and it can only be used when the
kernel arguments are not accessed on the host side or the data layout/size
between the host and device is known to be compatible.</p>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Plain Old Data type.</span>
<span class="k">struct</span> <span class="nc">Pod</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// Not POD type because of the constructor.</span>
<span class="c1">// Standard layout type because there is only one access control.</span>
<span class="k">struct</span> <span class="nc">OnlySL</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">NotPod</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// Not standard layout type because of two different access controls.</span>
<span class="k">struct</span> <span class="nc">NotSL</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">kernel</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel_main</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="n">Pod</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"></span>
<span class="cp">#pragma OPENCL EXTENSION __cl_clang_non_portable_kernel_param_types : enable</span>
<span class="w">  </span><span class="n">OnlySL</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">global</span><span class="w"> </span><span class="n">NotSL</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="p">,</span><span class="w"></span>
<span class="cp">#pragma OPENCL EXTENSION __cl_clang_non_portable_kernel_param_types : disable</span>
<span class="w">  </span><span class="n">global</span><span class="w"> </span><span class="n">OnlySL</span><span class="w"> </span><span class="o">*</span><span class="n">d</span><span class="p">,</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="remove-address-space-builtin-function">
<h3>Remove address space builtin function<a class="headerlink" href="#remove-address-space-builtin-function" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__remove_address_space</span></code> allows to derive types in C++ for OpenCL
that have address space qualifiers removed. This utility only affects
address space qualifiers, therefore, other type qualifiers such as
<code class="docutils literal notranslate"><span class="pre">const</span></code> or <code class="docutils literal notranslate"><span class="pre">volatile</span></code> remain unchanged.</p>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">par</span><span class="p">){</span><span class="w"></span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="n">var1</span><span class="p">;</span><span class="w"> </span><span class="c1">// error - local function variable with global address space</span>
<span class="w">  </span><span class="n">__private</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">var2</span><span class="p">;</span><span class="w"> </span><span class="c1">// error - conflicting address space qualifiers</span>
<span class="w">  </span><span class="n">__private</span><span class="w"> </span><span class="n">__remove_address_space</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="w"> </span><span class="n">var3</span><span class="p">;</span><span class="w"> </span><span class="c1">// var3 is __private int</span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">bar</span><span class="p">(){</span><span class="w"></span>
<span class="w">  </span><span class="n">__global</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">foo</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="legacy-1-x-atomics-with-generic-address-space">
<h3>Legacy 1.x atomics with generic address space<a class="headerlink" href="#legacy-1-x-atomics-with-generic-address-space" title="Permalink to this headline">¶</a></h3>
<p>Clang allows use of atomic functions from the OpenCL 1.x standards
with the generic address space pointer in C++ for OpenCL mode.</p>
<p>This is a non-portable feature and might not be supported by all
targets.</p>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">__generic</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">atomic_add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="builtin-functions">
<h2><a class="toc-backref" href="#id30">Builtin Functions</a><a class="headerlink" href="#builtin-functions" title="Permalink to this headline">¶</a></h2>
<p>Clang supports a number of builtin library functions with the same syntax as
GCC, including things like <code class="docutils literal notranslate"><span class="pre">__builtin_nan</span></code>, <code class="docutils literal notranslate"><span class="pre">__builtin_constant_p</span></code>,
<code class="docutils literal notranslate"><span class="pre">__builtin_choose_expr</span></code>, <code class="docutils literal notranslate"><span class="pre">__builtin_types_compatible_p</span></code>,
<code class="docutils literal notranslate"><span class="pre">__builtin_assume_aligned</span></code>, <code class="docutils literal notranslate"><span class="pre">__sync_fetch_and_add</span></code>, etc.  In addition to
the GCC builtins, Clang supports a number of builtins that GCC does not, which
are listed here.</p>
<p>Please note that Clang does not and will not support all of the GCC builtins
for vector operations.  Instead of using builtins, you should use the functions
defined in target-specific header files like <code class="docutils literal notranslate"><span class="pre">&lt;xmmintrin.h&gt;</span></code>, which define
portable wrappers for these.  Many of the Clang versions of these functions are
implemented directly in terms of <a class="reference internal" href="#langext-vectors"><span class="std std-ref">extended vector support</span></a> instead of builtins, in order to reduce the number of
builtins that we need to implement.</p>
<div class="section" id="builtin-alloca">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_alloca</span></code><a class="headerlink" href="#builtin-alloca" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_alloca</span></code> is used to dynamically allocate memory on the stack. Memory
is automatically freed upon function termination.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_alloca</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nbelems</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nbelems</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">mem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">__builtin_alloca</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">init</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">process</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="cm">/* mem is automatically freed at this point */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_alloca</span></code> is meant to be used to allocate a dynamic amount of memory
on the stack. This amount is subject to stack allocation limits.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_alloca)</span></code>.</p>
</div>
<div class="section" id="builtin-alloca-with-align">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_alloca_with_align</span></code><a class="headerlink" href="#builtin-alloca-with-align" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_alloca_with_align</span></code> is used to dynamically allocate memory on the
stack while controlling its alignment. Memory is automatically freed upon
function termination.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_alloca_with_align</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">align</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nbelems</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nbelems</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">mem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">__builtin_alloca_with_align</span><span class="p">(</span><span class="w"></span>
<span class="w">                      </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span><span class="w"></span>
<span class="w">                      </span><span class="n">CHAR_BIT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">alignof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">init</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">process</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="cm">/* mem is automatically freed at this point */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_alloca_with_align</span></code> is meant to be used to allocate a dynamic amount of memory
on the stack. It is similar to <code class="docutils literal notranslate"><span class="pre">__builtin_alloca</span></code> but accepts a second
argument whose value is the alignment constraint, as a power of 2 in <em>bits</em>.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_alloca_with_align)</span></code>.</p>
</div>
<div class="section" id="builtin-assume">
<span id="langext-builtin-assume"></span><h3><code class="docutils literal notranslate"><span class="pre">__builtin_assume</span></code><a class="headerlink" href="#builtin-assume" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_assume</span></code> is used to provide the optimizer with a boolean
invariant that is defined to be true.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_assume</span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">__builtin_assume</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// The optimizer may short-circuit this check using the invariant.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="n">do_something</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">do_something_else</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The boolean argument to this function is defined to be true. The optimizer may
analyze the form of the expression provided as the argument and deduce from
that information used to optimize the program. If the condition is violated
during execution, the behavior is undefined. The argument itself is never
evaluated, so any side effects of the expression will be discarded.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_assume)</span></code>.</p>
</div>
<div class="section" id="builtin-call-with-static-chain">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_call_with_static_chain</span></code><a class="headerlink" href="#builtin-call-with-static-chain" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_call_with_static_chain</span></code> is used to perform a static call while
setting updating the static chain register.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="w"> </span><span class="n">__builtin_call_with_static_chain</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_call_with_static_chain</span><span class="p">(</span><span class="n">foo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="n">foo</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>This builtin returns <code class="docutils literal notranslate"><span class="pre">expr</span></code> after checking that <code class="docutils literal notranslate"><span class="pre">expr</span></code> is a non-member
static call expression. The call to that expression is made while using <code class="docutils literal notranslate"><span class="pre">ptr</span></code>
as a function pointer stored in a dedicated register to implement <em>static chain</em>
calling convention, as used by some language to implement closures or nested
functions.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_call_with_static_chain)</span></code>.</p>
</div>
<div class="section" id="builtin-readcyclecounter">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_readcyclecounter</span></code><a class="headerlink" href="#builtin-readcyclecounter" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_readcyclecounter</span></code> is used to access the cycle counter register (or
a similar low-latency, high-accuracy clock) on those targets that support it.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_readcyclecounter</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_readcyclecounter</span><span class="p">();</span><span class="w"></span>
<span class="n">do_something</span><span class="p">();</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_readcyclecounter</span><span class="p">();</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">cycles_to_do_something</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="p">;</span><span class="w"> </span><span class="c1">// assuming no overflow</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__builtin_readcyclecounter()</span></code> builtin returns the cycle counter value,
which may be either global or process/thread-specific depending on the target.
As the backing counters often overflow quickly (on the order of seconds) this
should only be used for timing small intervals.  When not supported by the
target, the return value is always zero.  This builtin takes no arguments and
produces an unsigned long long result.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_readcyclecounter)</span></code>. Note
that even if present, its use may depend on run-time privilege or other OS
controlled state.</p>
</div>
<div class="section" id="builtin-dump-struct">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_dump_struct</span></code><a class="headerlink" href="#builtin-dump-struct" title="Permalink to this headline">¶</a></h3>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_dump_struct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">some_struct</span><span class="p">,</span><span class="w"> </span><span class="n">some_printf_func</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">...);</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Examples</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">S</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span> <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="k">struct</span> <span class="nc">S</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">__builtin_dump_struct</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">printf</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Example output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct S {
  int x = 100
  int y = 42
  float f = 3.141593
  struct T t = {
    int i = 1997
  }
}
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="k">struct</span> <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">constexpr_sprintf</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">format</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="k">auto</span><span class="w"> </span><span class="p">...</span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">dump_struct</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">__builtin_dump_struct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">constexpr_sprintf</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">dump_struct</span><span class="p">(</span><span class="n">T</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">})</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span><span class="s">struct T {</span>
<span class="s">  int a = 1</span>
<span class="s">  int b = 2</span>
<span class="s">}</span>
<span class="dl">)</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__builtin_dump_struct</span></code> function is used to print the fields of a simple
structure and their values for debugging purposes. The first argument of the
builtin should be a pointer to the struct to dump. The second argument <code class="docutils literal notranslate"><span class="pre">f</span></code>
should be some callable expression, and can be a function object or an overload
set. The builtin calls <code class="docutils literal notranslate"><span class="pre">f</span></code>, passing any further arguments <code class="docutils literal notranslate"><span class="pre">args...</span></code>
followed by a <code class="docutils literal notranslate"><span class="pre">printf</span></code>-compatible format string and the corresponding
arguments. <code class="docutils literal notranslate"><span class="pre">f</span></code> may be called more than once, and <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">args</span></code> will be
evaluated once per call. In C++, <code class="docutils literal notranslate"><span class="pre">f</span></code> may be a template or overload set and
resolve to different functions for each call.</p>
<p>In the format string, a suitable format specifier will be used for builtin
types that Clang knows how to format. This includes standard builtin types, as
well as aggregate structures, <code class="docutils literal notranslate"><span class="pre">void*</span></code> (printed with <code class="docutils literal notranslate"><span class="pre">%p</span></code>), and <code class="docutils literal notranslate"><span class="pre">const</span>
<span class="pre">char*</span></code> (printed with <code class="docutils literal notranslate"><span class="pre">%s</span></code>). A <code class="docutils literal notranslate"><span class="pre">*%p</span></code> specifier will be used for a field
that Clang doesn’t know how to format, and the corresopnding argument will be a
pointer to the field. This allows a C++ templated formatting function to detect
this case and implement custom formatting. A <code class="docutils literal notranslate"><span class="pre">*</span></code> will otherwise not precede a
format specifier.</p>
<p>This builtin does not return a value.</p>
<p>This builtin can be used in constant expressions.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_dump_struct)</span></code></p>
</div>
<div class="section" id="builtin-shufflevector">
<span id="langext-builtin-shufflevector"></span><h3><code class="docutils literal notranslate"><span class="pre">__builtin_shufflevector</span></code><a class="headerlink" href="#builtin-shufflevector" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_shufflevector</span></code> is used to express generic vector
permutation/shuffle/swizzle operations.  This builtin is also very important
for the implementation of various target-specific header files like
<code class="docutils literal notranslate"><span class="pre">&lt;xmmintrin.h&gt;</span></code>.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_shufflevector</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span><span class="w"> </span><span class="n">vec2</span><span class="p">,</span><span class="w"> </span><span class="n">index1</span><span class="p">,</span><span class="w"> </span><span class="n">index2</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Examples</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// identity operation - return 4-element vector v1.</span>
<span class="n">__builtin_shufflevector</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"></span>

<span class="c1">// &quot;Splat&quot; element 0 of V1 into a 4-element result.</span>
<span class="n">__builtin_shufflevector</span><span class="p">(</span><span class="n">V1</span><span class="p">,</span><span class="w"> </span><span class="n">V1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>

<span class="c1">// Reverse 4-element vector V1.</span>
<span class="n">__builtin_shufflevector</span><span class="p">(</span><span class="n">V1</span><span class="p">,</span><span class="w"> </span><span class="n">V1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>

<span class="c1">// Concatenate every other element of 4-element vectors V1 and V2.</span>
<span class="n">__builtin_shufflevector</span><span class="p">(</span><span class="n">V1</span><span class="p">,</span><span class="w"> </span><span class="n">V2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"></span>

<span class="c1">// Concatenate every other element of 8-element vectors V1 and V2.</span>
<span class="n">__builtin_shufflevector</span><span class="p">(</span><span class="n">V1</span><span class="p">,</span><span class="w"> </span><span class="n">V2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">)</span><span class="w"></span>

<span class="c1">// Shuffle v1 with some elements being undefined</span>
<span class="n">__builtin_shufflevector</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The first two arguments to <code class="docutils literal notranslate"><span class="pre">__builtin_shufflevector</span></code> are vectors that have
the same element type.  The remaining arguments are a list of integers that
specify the elements indices of the first two vectors that should be extracted
and returned in a new vector.  These element indices are numbered sequentially
starting with the first vector, continuing into the second vector.  Thus, if
<code class="docutils literal notranslate"><span class="pre">vec1</span></code> is a 4-element vector, index 5 would refer to the second element of
<code class="docutils literal notranslate"><span class="pre">vec2</span></code>. An index of -1 can be used to indicate that the corresponding element
in the returned vector is a don’t care and can be optimized by the backend.</p>
<p>The result of <code class="docutils literal notranslate"><span class="pre">__builtin_shufflevector</span></code> is a vector with the same element
type as <code class="docutils literal notranslate"><span class="pre">vec1</span></code>/<code class="docutils literal notranslate"><span class="pre">vec2</span></code> but that has an element count equal to the number of
indices specified.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_shufflevector)</span></code>.</p>
</div>
<div class="section" id="builtin-convertvector">
<span id="langext-builtin-convertvector"></span><h3><code class="docutils literal notranslate"><span class="pre">__builtin_convertvector</span></code><a class="headerlink" href="#builtin-convertvector" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_convertvector</span></code> is used to express generic vector
type-conversion operations. The input vector and the output vector
type must have the same number of elements.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_convertvector</span><span class="p">(</span><span class="n">src_vec</span><span class="p">,</span><span class="w"> </span><span class="n">dst_vec_type</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Examples</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">vector4double</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">__vector_size__</span><span class="p">(</span><span class="mi">32</span><span class="p">)));</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w">  </span><span class="n">vector4float</span><span class="w">  </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">__vector_size__</span><span class="p">(</span><span class="mi">16</span><span class="p">)));</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">short</span><span class="w">  </span><span class="n">vector4short</span><span class="w">  </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">__vector_size__</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span><span class="w"></span>
<span class="n">vector4float</span><span class="w"> </span><span class="n">vf</span><span class="p">;</span><span class="w"> </span><span class="n">vector4short</span><span class="w"> </span><span class="n">vs</span><span class="p">;</span><span class="w"></span>

<span class="c1">// convert from a vector of 4 floats to a vector of 4 doubles.</span>
<span class="n">__builtin_convertvector</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span><span class="w"> </span><span class="n">vector4double</span><span class="p">)</span><span class="w"></span>
<span class="c1">// equivalent to:</span>
<span class="p">(</span><span class="n">vector4double</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">vf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">vf</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">vf</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">vf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="c1">// convert from a vector of 4 shorts to a vector of 4 floats.</span>
<span class="n">__builtin_convertvector</span><span class="p">(</span><span class="n">vs</span><span class="p">,</span><span class="w"> </span><span class="n">vector4float</span><span class="p">)</span><span class="w"></span>
<span class="c1">// equivalent to:</span>
<span class="p">(</span><span class="n">vector4float</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="n">vs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="n">vs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="n">vs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="n">vs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The first argument to <code class="docutils literal notranslate"><span class="pre">__builtin_convertvector</span></code> is a vector, and the second
argument is a vector type with the same number of elements as the first
argument.</p>
<p>The result of <code class="docutils literal notranslate"><span class="pre">__builtin_convertvector</span></code> is a vector with the same element
type as the second argument, with a value defined in terms of the action of a
C-style cast applied to each element of the first argument.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_convertvector)</span></code>.</p>
</div>
<div class="section" id="builtin-bitreverse">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_bitreverse</span></code><a class="headerlink" href="#builtin-bitreverse" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_bitreverse8</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_bitreverse16</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_bitreverse32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_bitreverse64</span></code></p></li>
</ul>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_bitreverse32</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Examples</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">rev_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_bitreverse8</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="n">rev_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_bitreverse16</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">rev_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_bitreverse32</span><span class="p">(</span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="kt">uint64_t</span><span class="w"> </span><span class="n">rev_z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_bitreverse64</span><span class="p">(</span><span class="n">z</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">__builtin_bitreverse</span></code>’ family of builtins is used to reverse
the bitpattern of an integer value; for example <code class="docutils literal notranslate"><span class="pre">0b10110110</span></code> becomes
<code class="docutils literal notranslate"><span class="pre">0b01101101</span></code>. These builtins can be used within constant expressions.</p>
</div>
<div class="section" id="builtin-rotateleft">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_rotateleft</span></code><a class="headerlink" href="#builtin-rotateleft" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateleft8</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateleft16</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateleft32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateleft64</span></code></p></li>
</ul>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_rotateleft32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Examples</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">rot_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_rotateleft8</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="n">rot_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_rotateleft16</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">rot_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_rotateleft32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="kt">uint64_t</span><span class="w"> </span><span class="n">rot_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_rotateleft64</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">__builtin_rotateleft</span></code>’ family of builtins is used to rotate
the bits in the first argument by the amount in the second argument.
For example, <code class="docutils literal notranslate"><span class="pre">0b10000110</span></code> rotated left by 11 becomes <code class="docutils literal notranslate"><span class="pre">0b00110100</span></code>.
The shift value is treated as an unsigned amount modulo the size of
the arguments. Both arguments and the result have the bitwidth specified
by the name of the builtin. These builtins can be used within constant
expressions.</p>
</div>
<div class="section" id="builtin-rotateright">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_rotateright</span></code><a class="headerlink" href="#builtin-rotateright" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateright8</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateright16</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateright32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateright64</span></code></p></li>
</ul>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_rotateright32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Examples</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">rot_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_rotateright8</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="n">rot_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_rotateright16</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">rot_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_rotateright32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="kt">uint64_t</span><span class="w"> </span><span class="n">rot_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_rotateright64</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">__builtin_rotateright</span></code>’ family of builtins is used to rotate
the bits in the first argument by the amount in the second argument.
For example, <code class="docutils literal notranslate"><span class="pre">0b10000110</span></code> rotated right by 3 becomes <code class="docutils literal notranslate"><span class="pre">0b11010000</span></code>.
The shift value is treated as an unsigned amount modulo the size of
the arguments. Both arguments and the result have the bitwidth specified
by the name of the builtin. These builtins can be used within constant
expressions.</p>
</div>
<div class="section" id="builtin-unreachable">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_unreachable</span></code><a class="headerlink" href="#builtin-unreachable" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_unreachable</span></code> is used to indicate that a specific point in the
program cannot be reached, even if the compiler might otherwise think it can.
This is useful to improve optimization and eliminates certain warnings.  For
example, without the <code class="docutils literal notranslate"><span class="pre">__builtin_unreachable</span></code> in the example below, the
compiler assumes that the inline asm can fall through and prints a “function
declared ‘<code class="docutils literal notranslate"><span class="pre">noreturn</span></code>’ should not return” warning.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_unreachable</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Example of use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">myabort</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">noreturn</span><span class="p">));</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">myabort</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;int3&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">__builtin_unreachable</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__builtin_unreachable()</span></code> builtin has completely undefined behavior.
Since it has undefined behavior, it is a statement that it is never reached and
the optimizer can take advantage of this to produce better code.  This builtin
takes no arguments and produces a void result.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_unreachable)</span></code>.</p>
</div>
<div class="section" id="builtin-unpredictable">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_unpredictable</span></code><a class="headerlink" href="#builtin-unpredictable" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_unpredictable</span></code> is used to indicate that a branch condition is
unpredictable by hardware mechanisms such as branch prediction logic.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_unpredictable</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Example of use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__builtin_unpredictable</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">foo</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__builtin_unpredictable()</span></code> builtin is expected to be used with control
flow conditions such as in <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">switch</span></code> statements.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_unpredictable)</span></code>.</p>
</div>
<div class="section" id="builtin-expect">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_expect</span></code><a class="headerlink" href="#builtin-expect" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_expect</span></code> is used to indicate that the value of an expression is
anticipated to be the same as a statically known result.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">long</span><span class="w"> </span><span class="n">__builtin_expect</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Example of use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__builtin_expect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">bar</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__builtin_expect()</span></code> builtin is typically used with control flow
conditions such as in <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">switch</span></code> statements to help branch
prediction. It means that its first argument <code class="docutils literal notranslate"><span class="pre">expr</span></code> is expected to take the
value of its second argument <code class="docutils literal notranslate"><span class="pre">val</span></code>. It always returns <code class="docutils literal notranslate"><span class="pre">expr</span></code>.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_expect)</span></code>.</p>
</div>
<div class="section" id="builtin-expect-with-probability">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_expect_with_probability</span></code><a class="headerlink" href="#builtin-expect-with-probability" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_expect_with_probability</span></code> is similar to <code class="docutils literal notranslate"><span class="pre">__builtin_expect</span></code> but it
takes a probability as third argument.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">long</span><span class="w"> </span><span class="n">__builtin_expect_with_probability</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Example of use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__builtin_expect_with_probability</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mf">.3</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">bar</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__builtin_expect_with_probability()</span></code> builtin is typically used with
control flow conditions such as in <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">switch</span></code> statements to help
branch prediction. It means that its first argument <code class="docutils literal notranslate"><span class="pre">expr</span></code> is expected to take
the value of its second argument <code class="docutils literal notranslate"><span class="pre">val</span></code> with probability <code class="docutils literal notranslate"><span class="pre">p</span></code>. <code class="docutils literal notranslate"><span class="pre">p</span></code> must be
within <code class="docutils literal notranslate"><span class="pre">[0.0</span> <span class="pre">;</span> <span class="pre">1.0]</span></code> bounds. This builtin always returns the value of <code class="docutils literal notranslate"><span class="pre">expr</span></code>.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_expect_with_probability)</span></code>.</p>
</div>
<div class="section" id="builtin-prefetch">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_prefetch</span></code><a class="headerlink" href="#builtin-prefetch" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_prefetch</span></code> is used to communicate with the cache handler to bring
data into the cache before it gets used.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">__builtin_prefetch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rw</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">locality</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Example of use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_prefetch</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__builtin_prefetch(addr,</span> <span class="pre">rw,</span> <span class="pre">locality)</span></code> builtin is expected to be used to
avoid cache misses when the developper has a good understanding of which data
are going to be used next. <code class="docutils literal notranslate"><span class="pre">addr</span></code> is the address that needs to be brought into
the cache. <code class="docutils literal notranslate"><span class="pre">rw</span></code> indicates the expected access mode: <code class="docutils literal notranslate"><span class="pre">0</span></code> for <em>read</em> and <code class="docutils literal notranslate"><span class="pre">1</span></code>
for <em>write</em>. In case of <em>read write</em> access, <code class="docutils literal notranslate"><span class="pre">1</span></code> is to be used. <code class="docutils literal notranslate"><span class="pre">locality</span></code>
indicates the expected persistance of data in cache, from <code class="docutils literal notranslate"><span class="pre">0</span></code> which means that
data can be discarded from cache after its next use to <code class="docutils literal notranslate"><span class="pre">3</span></code> which means that
data is going to be reused a lot once in cache. <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">2</span></code> provide
intermediate behavior between these two extremes.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_prefetch)</span></code>.</p>
</div>
<div class="section" id="sync-swap">
<h3><code class="docutils literal notranslate"><span class="pre">__sync_swap</span></code><a class="headerlink" href="#sync-swap" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__sync_swap</span></code> is used to atomically swap integers or pointers in memory.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">type</span><span class="w"> </span><span class="n">__sync_swap</span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">old_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__sync_swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">new_value</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__sync_swap()</span></code> builtin extends the existing <code class="docutils literal notranslate"><span class="pre">__sync_*()</span></code> family of
atomic intrinsics to allow code to atomically swap the current value with the
new value.  More importantly, it helps developers write more efficient and
correct code by avoiding expensive loops around
<code class="docutils literal notranslate"><span class="pre">__sync_bool_compare_and_swap()</span></code> or relying on the platform specific
implementation details of <code class="docutils literal notranslate"><span class="pre">__sync_lock_test_and_set()</span></code>.  The
<code class="docutils literal notranslate"><span class="pre">__sync_swap()</span></code> builtin is a full barrier.</p>
</div>
<div class="section" id="builtin-addressof">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_addressof</span></code><a class="headerlink" href="#builtin-addressof" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_addressof</span></code> performs the functionality of the built-in <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>
operator, ignoring any <code class="docutils literal notranslate"><span class="pre">operator&amp;</span></code> overload.  This is useful in constant
expressions in C++11, where there is no other way to take the address of an
object that overloads <code class="docutils literal notranslate"><span class="pre">operator&amp;</span></code>.</p>
<p><strong>Example of use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addressof</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">__builtin_addressof</span><span class="p">(</span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="builtin-function-start">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_function_start</span></code><a class="headerlink" href="#builtin-function-start" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_function_start</span></code> returns the address of a function body.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">__builtin_function_start</span><span class="p">(</span><span class="n">function</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Example of use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">a</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_function_start</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w"></span>

<span class="k">class</span> <span class="nc">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">a</span><span class="p">();</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">A::a</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">A::a</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pa1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_function_start</span><span class="p">((</span><span class="kt">void</span><span class="p">(</span><span class="n">A</span><span class="o">::*</span><span class="p">)(</span><span class="kt">int</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">a</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pa2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_function_start</span><span class="p">((</span><span class="kt">void</span><span class="p">(</span><span class="n">A</span><span class="o">::*</span><span class="p">)())</span><span class="w"> </span><span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">a</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__builtin_function_start</span></code> builtin accepts an argument that can be
constant-evaluated to a function, and returns the address of the function
body.  This builtin is not supported on all targets.</p>
<p>The returned pointer may differ from the normally taken function address
and is not safe to call.  For example, with <code class="docutils literal notranslate"><span class="pre">-fsanitize=cfi</span></code>, taking a
function address produces a callable pointer to a CFI jump table, while
<code class="docutils literal notranslate"><span class="pre">__builtin_function_start</span></code> returns an address that fails
<a class="reference internal" href="ControlFlowIntegrity.html"><span class="doc">cfi-icall</span></a> checks.</p>
</div>
<div class="section" id="builtin-operator-new-and-builtin-operator-delete">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_operator_new</span></code> and <code class="docutils literal notranslate"><span class="pre">__builtin_operator_delete</span></code><a class="headerlink" href="#builtin-operator-new-and-builtin-operator-delete" title="Permalink to this headline">¶</a></h3>
<p>A call to <code class="docutils literal notranslate"><span class="pre">__builtin_operator_new(args)</span></code> is exactly the same as a call to
<code class="docutils literal notranslate"><span class="pre">::operator</span> <span class="pre">new(args)</span></code>, except that it allows certain optimizations
that the C++ standard does not permit for a direct function call to
<code class="docutils literal notranslate"><span class="pre">::operator</span> <span class="pre">new</span></code> (in particular, removing <code class="docutils literal notranslate"><span class="pre">new</span></code> / <code class="docutils literal notranslate"><span class="pre">delete</span></code> pairs and
merging allocations), and that the call is required to resolve to a
<a class="reference external" href="https://en.cppreference.com/w/cpp/memory/new/operator_new">replaceable global allocation function</a>.</p>
<p>Likewise, <code class="docutils literal notranslate"><span class="pre">__builtin_operator_delete</span></code> is exactly the same as a call to
<code class="docutils literal notranslate"><span class="pre">::operator</span> <span class="pre">delete(args)</span></code>, except that it permits optimizations
and that the call is required to resolve to a
<a class="reference external" href="https://en.cppreference.com/w/cpp/memory/new/operator_delete">replaceable global deallocation function</a>.</p>
<p>These builtins are intended for use in the implementation of <code class="docutils literal notranslate"><span class="pre">std::allocator</span></code>
and other similar allocation libraries, and are only available in C++.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_operator_new)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_operator_delete)</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>If the value is at least <code class="docutils literal notranslate"><span class="pre">201802L</span></code>, the builtins behave as described above.</p></li>
<li><p>If the value is non-zero, the builtins may not support calling arbitrary
replaceable global (de)allocation functions, but do support calling at least
<code class="docutils literal notranslate"><span class="pre">::operator</span> <span class="pre">new(size_t)</span></code> and <code class="docutils literal notranslate"><span class="pre">::operator</span> <span class="pre">delete(void*)</span></code>.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="builtin-preserve-access-index">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_preserve_access_index</span></code><a class="headerlink" href="#builtin-preserve-access-index" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_preserve_access_index</span></code> specifies a code section where
array subscript access and structure/union member access are relocatable
under bpf compile-once run-everywhere framework. Debuginfo (typically
with <code class="docutils literal notranslate"><span class="pre">-g</span></code>) is needed, otherwise, the compiler will exit with an error.
The return type for the intrinsic is the same as the type of the
argument.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">type</span><span class="w"> </span><span class="n">__builtin_preserve_access_index</span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">t</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">union</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">c</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">t</span><span class="w"> </span><span class="o">*</span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">pb</span><span class="w"> </span><span class="o">=</span><span class="n">__builtin_preserve_access_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="n">__builtin_preserve_access_index</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">j</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="builtin-debugtrap">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_debugtrap</span></code><a class="headerlink" href="#builtin-debugtrap" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_debugtrap</span></code> causes the program to stop its execution in such a way that a debugger can catch it.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_debugtrap</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Description</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_debugtrap</span></code> is lowered to the ` <code class="docutils literal notranslate"><span class="pre">llvm.debugtrap</span></code> &lt;<a class="reference external" href="https://llvm.org/docs/LangRef.html#llvm-debugtrap-intrinsic">https://llvm.org/docs/LangRef.html#llvm-debugtrap-intrinsic</a>&gt;`_ builtin. It should have the same effect as setting a breakpoint on the line where the builtin is called.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_debugtrap)</span></code>.</p>
</div>
<div class="section" id="builtin-trap">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_trap</span></code><a class="headerlink" href="#builtin-trap" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_trap</span></code> causes the program to stop its execution abnormally.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_trap</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Description</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_trap</span></code> is lowered to the ` <code class="docutils literal notranslate"><span class="pre">llvm.trap</span></code> &lt;<a class="reference external" href="https://llvm.org/docs/LangRef.html#llvm-trap-intrinsic">https://llvm.org/docs/LangRef.html#llvm-trap-intrinsic</a>&gt;`_ builtin.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_trap)</span></code>.</p>
</div>
<div class="section" id="builtin-sycl-unique-stable-name">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_sycl_unique_stable_name</span></code><a class="headerlink" href="#builtin-sycl-unique-stable-name" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_sycl_unique_stable_name()</span></code> is a builtin that takes a type and
produces a string literal containing a unique name for the type that is stable
across split compilations, mainly to support SYCL/Data Parallel C++ language.</p>
<p>In cases where the split compilation needs to share a unique token for a type
across the boundary (such as in an offloading situation), this name can be used
for lookup purposes, such as in the SYCL Integration Header.</p>
<p>The value of this builtin is computed entirely at compile time, so it can be
used in constant expressions. This value encodes lambda functions based on a
stable numbering order in which they appear in their local declaration contexts.
Once this builtin is evaluated in a constexpr context, it is erroneous to use
it in an instantiation which changes its value.</p>
<p>In order to produce the unique name, the current implementation of the bultin
uses Itanium mangling even if the host compilation uses a different name
mangling scheme at runtime. The mangler marks all the lambdas required to name
the SYCL kernel and emits a stable local ordering of the respective lambdas.
The resulting pattern is demanglable.  When non-lambda types are passed to the
builtin, the mangler emits their usual pattern without any special treatment.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Computes a unique stable name for the given type.</span>
<span class="n">constexpr</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">__builtin_sycl_unique_stable_name</span><span class="p">(</span><span class="w"> </span><span class="n">type</span><span class="o">-</span><span class="n">id</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="multiprecision-arithmetic-builtins">
<h3>Multiprecision Arithmetic Builtins<a class="headerlink" href="#multiprecision-arithmetic-builtins" title="Permalink to this headline">¶</a></h3>
<p>Clang provides a set of builtins which expose multiprecision arithmetic in a
manner amenable to C. They all have the following form:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">carryin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">carryout</span><span class="p">;</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_addc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">carryout</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Thus one can form a multiprecision addition chain in the following manner:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">carryin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">carryout</span><span class="p">;</span><span class="w"></span>
<span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_addc</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">carryout</span><span class="p">);</span><span class="w"></span>
<span class="n">carryin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">carryout</span><span class="p">;</span><span class="w"></span>
<span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_addc</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">carryout</span><span class="p">);</span><span class="w"></span>
<span class="n">carryin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">carryout</span><span class="p">;</span><span class="w"></span>
<span class="n">z</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_addc</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">carryout</span><span class="p">);</span><span class="w"></span>
<span class="n">carryin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">carryout</span><span class="p">;</span><span class="w"></span>
<span class="n">z</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_addc</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">carryout</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The complete list of builtins are:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">      </span><span class="n">__builtin_addcb</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">carryout</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w">     </span><span class="n">__builtin_addcs</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="o">*</span><span class="n">carryout</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w">           </span><span class="nf">__builtin_addc</span><span class="w">  </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="o">*</span><span class="n">carryout</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">      </span><span class="n">__builtin_addcl</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">carryout</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">__builtin_addcll</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">carryout</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">      </span><span class="n">__builtin_subcb</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">carryout</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w">     </span><span class="n">__builtin_subcs</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="o">*</span><span class="n">carryout</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w">           </span><span class="nf">__builtin_subc</span><span class="w">  </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="o">*</span><span class="n">carryout</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">      </span><span class="n">__builtin_subcl</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">carryout</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">__builtin_subcll</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">carryout</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="checked-arithmetic-builtins">
<h3>Checked Arithmetic Builtins<a class="headerlink" href="#checked-arithmetic-builtins" title="Permalink to this headline">¶</a></h3>
<p>Clang provides a set of builtins that implement checked arithmetic for security
critical applications in a manner that is fast and easily expressible in C. As
an example of their usage:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">errorcode_t</span><span class="w"> </span><span class="nf">security_critical_application</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__builtin_mul_overflow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">result</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">kErrorCodeHackers</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="n">use_multiply</span><span class="p">(</span><span class="n">result</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Clang provides the following checked arithmetic builtins:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_add_overflow</span><span class="w">   </span><span class="p">(</span><span class="n">type1</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">type2</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">type3</span><span class="w"> </span><span class="o">*</span><span class="n">sum</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_sub_overflow</span><span class="w">   </span><span class="p">(</span><span class="n">type1</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">type2</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">type3</span><span class="w"> </span><span class="o">*</span><span class="n">diff</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_mul_overflow</span><span class="w">   </span><span class="p">(</span><span class="n">type1</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">type2</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">type3</span><span class="w"> </span><span class="o">*</span><span class="n">prod</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_uadd_overflow</span><span class="w">  </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="o">*</span><span class="n">sum</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_uaddl_overflow</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">sum</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_uaddll_overflow</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">sum</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_usub_overflow</span><span class="w">  </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="o">*</span><span class="n">diff</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_usubl_overflow</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">diff</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_usubll_overflow</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">diff</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_umul_overflow</span><span class="w">  </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="o">*</span><span class="n">prod</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_umull_overflow</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">prod</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_umulll_overflow</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">prod</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_sadd_overflow</span><span class="w">  </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">sum</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_saddl_overflow</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">sum</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_saddll_overflow</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">sum</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_ssub_overflow</span><span class="w">  </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">diff</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_ssubl_overflow</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">diff</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_ssubll_overflow</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">diff</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_smul_overflow</span><span class="w">  </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">prod</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_smull_overflow</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">prod</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_smulll_overflow</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">prod</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Each builtin performs the specified mathematical operation on the
first two arguments and stores the result in the third argument.  If
possible, the result will be equal to mathematically-correct result
and the builtin will return 0.  Otherwise, the builtin will return
1 and the result will be equal to the unique value that is equivalent
to the mathematically-correct result modulo two raised to the <em>k</em>
power, where <em>k</em> is the number of bits in the result type.  The
behavior of these builtins is well-defined for all argument values.</p>
<p>The first three builtins work generically for operands of any integer type,
including boolean types.  The operands need not have the same type as each
other, or as the result.  The other builtins may implicitly promote or
convert their operands before performing the operation.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_add_overflow)</span></code>, etc.</p>
</div>
<div class="section" id="floating-point-builtins">
<h3>Floating point builtins<a class="headerlink" href="#floating-point-builtins" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="builtin-canonicalize">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_canonicalize</span></code><a class="headerlink" href="#builtin-canonicalize" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="nf">__builtin_canonicalize</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="nf">__builtin_canonicalizef</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span><span class="w"></span>
<span class="kt">long</span><span class="w"> </span><span class="nf">double__builtin_canonicalizel</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">double</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Returns the platform specific canonical encoding of a floating point
number. This canonicalization is useful for implementing certain
numeric primitives such as frexp. See <a class="reference external" href="https://llvm.org/docs/LangRef.html#llvm-canonicalize-intrinsic">LLVM canonicalize intrinsic</a> for
more information on the semantics.</p>
</div>
<div class="section" id="string-builtins">
<h3>String builtins<a class="headerlink" href="#string-builtins" title="Permalink to this headline">¶</a></h3>
<p>Clang provides constant expression evaluation support for builtins forms of
the following functions from the C standard library headers
<code class="docutils literal notranslate"><span class="pre">&lt;string.h&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;wchar.h&gt;</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">memchr</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">memcmp</span></code> (and its deprecated BSD / POSIX alias <code class="docutils literal notranslate"><span class="pre">bcmp</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">strchr</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">strcmp</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">strlen</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">strncmp</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wcschr</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wcscmp</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wcslen</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wcsncmp</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wmemchr</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wmemcmp</span></code></p></li>
</ul>
<p>In each case, the builtin form has the name of the C library function prefixed
by <code class="docutils literal notranslate"><span class="pre">__builtin_</span></code>. Example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_memchr</span><span class="p">(</span><span class="s">&quot;foobar&quot;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;b&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>In addition to the above, one further builtin is provided:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">__builtin_char_memchr</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">haystack</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">needle</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_char_memchr(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> is identical to
<code class="docutils literal notranslate"><span class="pre">(char*)__builtin_memchr(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> except that its use is permitted within
constant expressions in C++11 onwards (where a cast from <code class="docutils literal notranslate"><span class="pre">void*</span></code> to <code class="docutils literal notranslate"><span class="pre">char*</span></code>
is disallowed in general).</p>
<p>Constant evaluation support for the <code class="docutils literal notranslate"><span class="pre">__builtin_mem*</span></code> functions is provided
only for arrays of <code class="docutils literal notranslate"><span class="pre">char</span></code>, <code class="docutils literal notranslate"><span class="pre">signed</span> <span class="pre">char</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code>, or <code class="docutils literal notranslate"><span class="pre">char8_t</span></code>,
despite these functions accepting an argument of type <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void*</span></code>.</p>
<p>Support for constant expression evaluation for the above builtins can be detected
with <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_constexpr_string_builtins)</span></code>.</p>
</div>
<div class="section" id="memory-builtins">
<h3>Memory builtins<a class="headerlink" href="#memory-builtins" title="Permalink to this headline">¶</a></h3>
<p>Clang provides constant expression evaluation support for builtin forms of the
following functions from the C standard library headers
<code class="docutils literal notranslate"><span class="pre">&lt;string.h&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;wchar.h&gt;</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">memcpy</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">memmove</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wmemcpy</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wmemmove</span></code></p></li>
</ul>
<p>In each case, the builtin form has the name of the C library function prefixed
by <code class="docutils literal notranslate"><span class="pre">__builtin_</span></code>.</p>
<p>Constant evaluation support is only provided when the source and destination
are pointers to arrays with the same trivially copyable element type, and the
given size is an exact multiple of the element size that is no greater than
the number of elements accessible through the source and destination operands.</p>
<div class="section" id="guaranteed-inlined-copy">
<h4>Guaranteed inlined copy<a class="headerlink" href="#guaranteed-inlined-copy" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">__builtin_memcpy_inline</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_memcpy_inline</span></code> has been designed as a building block for efficient
<code class="docutils literal notranslate"><span class="pre">memcpy</span></code> implementations. It is identical to <code class="docutils literal notranslate"><span class="pre">__builtin_memcpy</span></code> but also
guarantees not to call any external functions. See LLVM IR <a class="reference external" href="https://llvm.org/docs/LangRef.html#llvm-memcpy-inline-intrinsic">llvm.memcpy.inline</a> intrinsic
for more information.</p>
<p>This is useful to implement a custom version of <code class="docutils literal notranslate"><span class="pre">memcpy</span></code>, implement a
<code class="docutils literal notranslate"><span class="pre">libc</span></code> memcpy or work around the absence of a <code class="docutils literal notranslate"><span class="pre">libc</span></code>.</p>
<p>Note that the <cite>size</cite> argument must be a compile time constant.</p>
<p>Note that this intrinsic cannot yet be called in a <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> context.</p>
</div>
<div class="section" id="guaranteed-inlined-memset">
<h4>Guaranteed inlined memset<a class="headerlink" href="#guaranteed-inlined-memset" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">__builtin_memset_inline</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_memset_inline</span></code> has been designed as a building block for efficient
<code class="docutils literal notranslate"><span class="pre">memset</span></code> implementations. It is identical to <code class="docutils literal notranslate"><span class="pre">__builtin_memset</span></code> but also
guarantees not to call any external functions. See LLVM IR <a class="reference external" href="https://llvm.org/docs/LangRef.html#llvm-memset-inline-intrinsic">llvm.memset.inline</a> intrinsic
for more information.</p>
<p>This is useful to implement a custom version of <code class="docutils literal notranslate"><span class="pre">memset</span></code>, implement a
<code class="docutils literal notranslate"><span class="pre">libc</span></code> memset or work around the absence of a <code class="docutils literal notranslate"><span class="pre">libc</span></code>.</p>
<p>Note that the <cite>size</cite> argument must be a compile time constant.</p>
<p>Note that this intrinsic cannot yet be called in a <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> context.</p>
</div>
</div>
<div class="section" id="atomic-min-max-builtins-with-memory-ordering">
<h3>Atomic Min/Max builtins with memory ordering<a class="headerlink" href="#atomic-min-max-builtins-with-memory-ordering" title="Permalink to this headline">¶</a></h3>
<p>There are two atomic builtins with min/max in-memory comparison and swap.
The syntax and semantics are similar to GCC-compatible __atomic_* builtins.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__atomic_fetch_min</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__atomic_fetch_max</span></code></p></li>
</ul>
<p>The builtins work with signed and unsigned integers and require to specify memory ordering.
The return value is the original value that was stored in memory before comparison.</p>
<p>Example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__atomic_fetch_min</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">pi</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ui</span><span class="p">,</span><span class="w"> </span><span class="n">__ATOMIC_RELAXED</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The third argument is one of the memory ordering specifiers <code class="docutils literal notranslate"><span class="pre">__ATOMIC_RELAXED</span></code>,
<code class="docutils literal notranslate"><span class="pre">__ATOMIC_CONSUME</span></code>, <code class="docutils literal notranslate"><span class="pre">__ATOMIC_ACQUIRE</span></code>, <code class="docutils literal notranslate"><span class="pre">__ATOMIC_RELEASE</span></code>,
<code class="docutils literal notranslate"><span class="pre">__ATOMIC_ACQ_REL</span></code>, or <code class="docutils literal notranslate"><span class="pre">__ATOMIC_SEQ_CST</span></code> following C++11 memory model semantics.</p>
<p>In terms or aquire-release ordering barriers these two operations are always
considered as operations with <em>load-store</em> semantics, even when the original value
is not actually modified after comparison.</p>
</div>
<div class="section" id="c11-atomic-builtins">
<span id="langext-c11-atomic"></span><h3>__c11_atomic builtins<a class="headerlink" href="#c11-atomic-builtins" title="Permalink to this headline">¶</a></h3>
<p>Clang provides a set of builtins which are intended to be used to implement
C11’s <code class="docutils literal notranslate"><span class="pre">&lt;stdatomic.h&gt;</span></code> header.  These builtins provide the semantics of the
<code class="docutils literal notranslate"><span class="pre">_explicit</span></code> form of the corresponding C11 operation, and are named with a
<code class="docutils literal notranslate"><span class="pre">__c11_</span></code> prefix.  The supported operations, and the differences from
the corresponding C11 operations, are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_init</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_thread_fence</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_signal_fence</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_is_lock_free</span></code> (The argument is the size of the
<code class="docutils literal notranslate"><span class="pre">_Atomic(...)</span></code> object, instead of its address)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_store</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_load</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_exchange</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_compare_exchange_strong</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_compare_exchange_weak</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_fetch_add</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_fetch_sub</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_fetch_and</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_fetch_or</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_fetch_xor</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_fetch_nand</span></code> (Nand is not presented in <code class="docutils literal notranslate"><span class="pre">&lt;stdatomic.h&gt;</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_fetch_max</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_fetch_min</span></code></p></li>
</ul>
<p>The macros <code class="docutils literal notranslate"><span class="pre">__ATOMIC_RELAXED</span></code>, <code class="docutils literal notranslate"><span class="pre">__ATOMIC_CONSUME</span></code>, <code class="docutils literal notranslate"><span class="pre">__ATOMIC_ACQUIRE</span></code>,
<code class="docutils literal notranslate"><span class="pre">__ATOMIC_RELEASE</span></code>, <code class="docutils literal notranslate"><span class="pre">__ATOMIC_ACQ_REL</span></code>, and <code class="docutils literal notranslate"><span class="pre">__ATOMIC_SEQ_CST</span></code> are
provided, with values corresponding to the enumerators of C11’s
<code class="docutils literal notranslate"><span class="pre">memory_order</span></code> enumeration.</p>
<p>(Note that Clang additionally provides GCC-compatible <code class="docutils literal notranslate"><span class="pre">__atomic_*</span></code>
builtins and OpenCL 2.0 <code class="docutils literal notranslate"><span class="pre">__opencl_atomic_*</span></code> builtins. The OpenCL 2.0
atomic builtins are an explicit form of the corresponding OpenCL 2.0
builtin function, and are named with a <code class="docutils literal notranslate"><span class="pre">__opencl_</span></code> prefix. The macros
<code class="docutils literal notranslate"><span class="pre">__OPENCL_MEMORY_SCOPE_WORK_ITEM</span></code>, <code class="docutils literal notranslate"><span class="pre">__OPENCL_MEMORY_SCOPE_WORK_GROUP</span></code>,
<code class="docutils literal notranslate"><span class="pre">__OPENCL_MEMORY_SCOPE_DEVICE</span></code>, <code class="docutils literal notranslate"><span class="pre">__OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES</span></code>,
and <code class="docutils literal notranslate"><span class="pre">__OPENCL_MEMORY_SCOPE_SUB_GROUP</span></code> are provided, with values
corresponding to the enumerators of OpenCL’s <code class="docutils literal notranslate"><span class="pre">memory_scope</span></code> enumeration.)</p>
</div>
<div class="section" id="low-level-arm-exclusive-memory-builtins">
<h3>Low-level ARM exclusive memory builtins<a class="headerlink" href="#low-level-arm-exclusive-memory-builtins" title="Permalink to this headline">¶</a></h3>
<p>Clang provides overloaded builtins giving direct access to the three key ARM
instructions for implementing atomic operations.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="w"> </span><span class="nf">__builtin_arm_ldrex</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">);</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="nf">__builtin_arm_ldaex</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">__builtin_arm_strex</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">__builtin_arm_stlex</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__builtin_arm_clrex</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The types <code class="docutils literal notranslate"><span class="pre">T</span></code> currently supported are:</p>
<ul class="simple">
<li><p>Integer types with width at most 64 bits (or 128 bits on AArch64).</p></li>
<li><p>Floating-point types</p></li>
<li><p>Pointer types.</p></li>
</ul>
<p>Note that the compiler does not guarantee it will not insert stores which clear
the exclusive monitor in between an <code class="docutils literal notranslate"><span class="pre">ldrex</span></code> type operation and its paired
<code class="docutils literal notranslate"><span class="pre">strex</span></code>. In practice this is only usually a risk when the extra store is on
the same cache line as the variable being modified and Clang will only insert
stack stores on its own, so it is best not to use these operations on variables
with automatic storage duration.</p>
<p>Also, loads and stores may be implicit in code written between the <code class="docutils literal notranslate"><span class="pre">ldrex</span></code> and
<code class="docutils literal notranslate"><span class="pre">strex</span></code>. Clang will not necessarily mitigate the effects of these either, so
care should be exercised.</p>
<p>For these reasons the higher level atomic primitives should be preferred where
possible.</p>
</div>
<div class="section" id="non-temporal-load-store-builtins">
<h3>Non-temporal load/store builtins<a class="headerlink" href="#non-temporal-load-store-builtins" title="Permalink to this headline">¶</a></h3>
<p>Clang provides overloaded builtins allowing generation of non-temporal memory
accesses.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="w"> </span><span class="nf">__builtin_nontemporal_load</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__builtin_nontemporal_store</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The types <code class="docutils literal notranslate"><span class="pre">T</span></code> currently supported are:</p>
<ul class="simple">
<li><p>Integer types.</p></li>
<li><p>Floating-point types.</p></li>
<li><p>Vector types.</p></li>
</ul>
<p>Note that the compiler does not guarantee that non-temporal loads or stores
will be used.</p>
</div>
<div class="section" id="c-coroutines-support-builtins">
<h3>C++ Coroutines support builtins<a class="headerlink" href="#c-coroutines-support-builtins" title="Permalink to this headline">¶</a></h3>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is a work in progress. Compatibility across Clang/LLVM releases is not
guaranteed.</p>
</div>
<p>Clang provides experimental builtins to support C++ Coroutines as defined by
<a class="reference external" href="https://wg21.link/P0057">https://wg21.link/P0057</a>. The following four are intended to be used by the
standard library to implement the <code class="docutils literal notranslate"><span class="pre">std::coroutine_handle</span></code> type.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w">  </span><span class="nf">__builtin_coro_resume</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w">  </span><span class="nf">__builtin_coro_destroy</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w">  </span><span class="nf">__builtin_coro_done</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">__builtin_coro_promise</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">alignment</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">from_promise</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Example of use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="k">struct</span> <span class="nc">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">resume</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">__builtin_coro_resume</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">destroy</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">__builtin_coro_destroy</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">done</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">__builtin_coro_done</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="k">protected</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Promise</span><span class="o">&gt;</span><span class="w"> </span><span class="k">struct</span> <span class="nc">coroutine_handle</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="w">  </span><span class="n">Promise</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">promise</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Promise</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">__builtin_coro_promise</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="k">alignof</span><span class="p">(</span><span class="n">Promise</span><span class="p">),</span><span class="w"> </span><span class="cm">/*from-promise=*/</span><span class="nb">false</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">coroutine_handle</span><span class="w"> </span><span class="nf">from_promise</span><span class="p">(</span><span class="n">Promise</span><span class="w"> </span><span class="o">&amp;</span><span class="n">promise</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">coroutine_handle</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">p</span><span class="p">.</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_coro_promise</span><span class="p">(</span><span class="o">&amp;</span><span class="n">promise</span><span class="p">,</span><span class="w"> </span><span class="k">alignof</span><span class="p">(</span><span class="n">Promise</span><span class="p">),</span><span class="w"></span>
<span class="w">                                                    </span><span class="cm">/*from-promise=*/</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Other coroutine builtins are either for internal clang use or for use during
development of the coroutine feature. See <a class="reference external" href="https://llvm.org/docs/Coroutines.html#intrinsics">Coroutines in LLVM</a> for
more information on their semantics. Note that builtins matching the intrinsics
that take token as the first parameter (llvm.coro.begin, llvm.coro.alloc,
llvm.coro.free and llvm.coro.suspend) omit the token parameter and fill it to
an appropriate value during the emission.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">size_t</span><span class="w"> </span><span class="n">__builtin_coro_size</span><span class="p">()</span><span class="w"></span>
<span class="kt">void</span><span class="w">  </span><span class="o">*</span><span class="n">__builtin_coro_frame</span><span class="p">()</span><span class="w"></span>
<span class="kt">void</span><span class="w">  </span><span class="o">*</span><span class="n">__builtin_coro_free</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">coro_frame</span><span class="p">)</span><span class="w"></span>

<span class="kt">void</span><span class="w">  </span><span class="o">*</span><span class="n">__builtin_coro_id</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">align</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">promise</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">fnaddr</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">parts</span><span class="p">)</span><span class="w"></span>
<span class="kt">bool</span><span class="w">   </span><span class="n">__builtin_coro_alloc</span><span class="p">()</span><span class="w"></span>
<span class="kt">void</span><span class="w">  </span><span class="o">*</span><span class="n">__builtin_coro_begin</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">memory</span><span class="p">)</span><span class="w"></span>
<span class="kt">void</span><span class="w">   </span><span class="n">__builtin_coro_end</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">coro_frame</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">unwind</span><span class="p">)</span><span class="w"></span>
<span class="kt">char</span><span class="w">   </span><span class="n">__builtin_coro_suspend</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">final</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Note that there is no builtin matching the <cite>llvm.coro.save</cite> intrinsic. LLVM
automatically will insert one if the first argument to <cite>llvm.coro.suspend</cite> is
token <cite>none</cite>. If a user calls <cite>__builin_suspend</cite>, clang will insert <cite>token none</cite>
as the first argument to the intrinsic.</p>
</div>
<div class="section" id="source-location-builtins">
<h3>Source location builtins<a class="headerlink" href="#source-location-builtins" title="Permalink to this headline">¶</a></h3>
<p>Clang provides builtins to support C++ standard library implementation
of <code class="docutils literal notranslate"><span class="pre">std::source_location</span></code> as specified in C++20.  With the exception
of <code class="docutils literal notranslate"><span class="pre">__builtin_COLUMN</span></code>, these builtins are also implemented by GCC.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">__builtin_FILE</span><span class="p">();</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">__builtin_FUNCTION</span><span class="p">();</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w">    </span><span class="nf">__builtin_LINE</span><span class="p">();</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w">    </span><span class="nf">__builtin_COLUMN</span><span class="p">();</span><span class="w"> </span><span class="c1">// Clang only</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">source_location</span><span class="o">::</span><span class="n">__impl</span><span class="w"> </span><span class="o">*</span><span class="nf">__builtin_source_location</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Example of use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">my_assert</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">pred</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_LINE</span><span class="p">(),</span><span class="w"> </span><span class="c1">// Captures line of caller</span>
<span class="w">               </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_FILE</span><span class="p">(),</span><span class="w"></span>
<span class="w">               </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_FUNCTION</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pred</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s:%d assertion failed in function %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="n">function</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">abort</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">MyAggregateType</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_LINE</span><span class="p">();</span><span class="w"> </span><span class="c1">// captures line where aggregate initialization occurs</span>
<span class="p">};</span><span class="w"></span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">MyAggregateType</span><span class="p">{</span><span class="mi">42</span><span class="p">}.</span><span class="n">line</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">__LINE__</span><span class="p">);</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">MyClassType</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_LINE</span><span class="p">();</span><span class="w"> </span><span class="c1">// captures line of the constructor used during initialization</span>
<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="n">MyClassType</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">assert</span><span class="p">(</span><span class="n">line</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">__LINE__</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The builtins <code class="docutils literal notranslate"><span class="pre">__builtin_LINE</span></code>, <code class="docutils literal notranslate"><span class="pre">__builtin_FUNCTION</span></code>, and <code class="docutils literal notranslate"><span class="pre">__builtin_FILE</span></code>
return the values, at the “invocation point”, for <code class="docutils literal notranslate"><span class="pre">__LINE__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__FUNCTION__</span></code>, and <code class="docutils literal notranslate"><span class="pre">__FILE__</span></code> respectively. <code class="docutils literal notranslate"><span class="pre">__builtin_COLUMN</span></code> similarly
returns the column, though there is no corresponding macro. These builtins are
constant expressions.</p>
<p>When the builtins appear as part of a default function argument the invocation
point is the location of the caller. When the builtins appear as part of a
default member initializer, the invocation point is the location of the
constructor or aggregate initialization used to create the object. Otherwise
the invocation point is the same as the location of the builtin.</p>
<p>When the invocation point of <code class="docutils literal notranslate"><span class="pre">__builtin_FUNCTION</span></code> is not a function scope the
empty string is returned.</p>
<p>The builtin <code class="docutils literal notranslate"><span class="pre">__builtin_source_location</span></code> returns a pointer to constant static
data of type <code class="docutils literal notranslate"><span class="pre">std::source_location::__impl</span></code>. This type must have already been
defined, and must contain exactly four fields: <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*_M_file_name</span></code>,
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*_M_function_name</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;any-integral-type&gt;</span> <span class="pre">_M_line</span></code>, and
<code class="docutils literal notranslate"><span class="pre">&lt;any-integral-type&gt;</span> <span class="pre">_M_column</span></code>. The fields will be populated in the same
manner as the above four builtins, except that <code class="docutils literal notranslate"><span class="pre">_M_function_name</span></code> is populated
with <code class="docutils literal notranslate"><span class="pre">__PRETTY_FUNCTION__</span></code> rather than <code class="docutils literal notranslate"><span class="pre">__FUNCTION__</span></code>.</p>
</div>
<div class="section" id="alignment-builtins">
<h3>Alignment builtins<a class="headerlink" href="#alignment-builtins" title="Permalink to this headline">¶</a></h3>
<p>Clang provides builtins to support checking and adjusting alignment of
pointers and integers.
These builtins can be used to avoid relying on implementation-defined behavior
of arithmetic on integers derived from pointers.
Additionally, these builtins retain type information and, unlike bitwise
arithmetic, they can perform semantic checking on the alignment value.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Type</span><span class="w"> </span><span class="nf">__builtin_align_up</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">alignment</span><span class="p">);</span><span class="w"></span>
<span class="n">Type</span><span class="w"> </span><span class="nf">__builtin_align_down</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">alignment</span><span class="p">);</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_is_aligned</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">alignment</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Example of use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">global_alloc_buffer</span><span class="p">;</span><span class="w"></span>
<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">my_aligned_allocator</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">alloc_size</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">alignment</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_align_up</span><span class="p">(</span><span class="n">global_alloc_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">alignment</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// result now contains the value of global_alloc_buffer rounded up to the</span>
<span class="w">  </span><span class="c1">// next multiple of alignment.</span>
<span class="w">  </span><span class="n">global_alloc_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">alloc_size</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">get_start_of_page</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">__builtin_align_down</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">example</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__builtin_is_aligned</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="n">do_fast_aligned_copy</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="n">do_unaligned_copy</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// In addition to pointers, the builtins can also be used on integer types</span>
<span class="c1">// and are evaluatable inside constant expressions.</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">__builtin_align_up</span><span class="p">(</span><span class="mi">123</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">__builtin_align_down</span><span class="p">(</span><span class="mi">123u</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">64u</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">__builtin_is_aligned</span><span class="p">(</span><span class="mi">123</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The builtins <code class="docutils literal notranslate"><span class="pre">__builtin_align_up</span></code>, <code class="docutils literal notranslate"><span class="pre">__builtin_align_down</span></code>, return their
first argument aligned up/down to the next multiple of the second argument.
If the value is already sufficiently aligned, it is returned unchanged.
The builtin <code class="docutils literal notranslate"><span class="pre">__builtin_is_aligned</span></code> returns whether the first argument is
aligned to a multiple of the second argument.
All of these builtins expect the alignment to be expressed as a number of bytes.</p>
<p>These builtins can be used for all integer types as well as (non-function)
pointer types. For pointer types, these builtins operate in terms of the integer
address of the pointer and return a new pointer of the same type (including
qualifiers such as <code class="docutils literal notranslate"><span class="pre">const</span></code>) with an adjusted address.
When aligning pointers up or down, the resulting value must be within the same
underlying allocation or one past the end (see C17 6.5.6p8, C++ [expr.add]).
This means that arbitrary integer values stored in pointer-type variables must
not be passed to these builtins. For those use cases, the builtins can still be
used, but the operation must be performed on the pointer cast to <code class="docutils literal notranslate"><span class="pre">uintptr_t</span></code>.</p>
<p>If Clang can determine that the alignment is not a power of two at compile time,
it will result in a compilation failure. If the alignment argument is not a
power of two at run time, the behavior of these builtins is undefined.</p>
</div>
</div>
<div class="section" id="non-standard-c-11-attributes">
<h2><a class="toc-backref" href="#id31">Non-standard C++11 Attributes</a><a class="headerlink" href="#non-standard-c-11-attributes" title="Permalink to this headline">¶</a></h2>
<p>Clang’s non-standard C++11 attributes live in the <code class="docutils literal notranslate"><span class="pre">clang</span></code> attribute
namespace.</p>
<p>Clang supports GCC’s <code class="docutils literal notranslate"><span class="pre">gnu</span></code> attribute namespace. All GCC attributes which
are accepted with the <code class="docutils literal notranslate"><span class="pre">__attribute__((foo))</span></code> syntax are also accepted as
<code class="docutils literal notranslate"><span class="pre">[[gnu::foo]]</span></code>. This only extends to attributes which are specified by GCC
(see the list of <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html">GCC function attributes</a>, <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html">GCC variable
attributes</a>, and
<a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html">GCC type attributes</a>). As with the GCC
implementation, these attributes must appertain to the <em>declarator-id</em> in a
declaration, which means they must go either at the start of the declaration or
immediately after the name being declared.</p>
<p>For example, this applies the GNU <code class="docutils literal notranslate"><span class="pre">unused</span></code> attribute to <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">f</span></code>, and
also applies the GNU <code class="docutils literal notranslate"><span class="pre">noreturn</span></code> attribute to <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">gnu</span><span class="o">::</span><span class="n">unused</span><span class="p">]]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">[[</span><span class="n">gnu</span><span class="o">::</span><span class="n">noreturn</span><span class="p">]]</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="target-specific-extensions">
<h2><a class="toc-backref" href="#id32">Target-Specific Extensions</a><a class="headerlink" href="#target-specific-extensions" title="Permalink to this headline">¶</a></h2>
<p>Clang supports some language features conditionally on some targets.</p>
<div class="section" id="arm-aarch64-language-extensions">
<h3>ARM/AArch64 Language Extensions<a class="headerlink" href="#arm-aarch64-language-extensions" title="Permalink to this headline">¶</a></h3>
<div class="section" id="memory-barrier-intrinsics">
<h4>Memory Barrier Intrinsics<a class="headerlink" href="#memory-barrier-intrinsics" title="Permalink to this headline">¶</a></h4>
<p>Clang implements the <code class="docutils literal notranslate"><span class="pre">__dmb</span></code>, <code class="docutils literal notranslate"><span class="pre">__dsb</span></code> and <code class="docutils literal notranslate"><span class="pre">__isb</span></code> intrinsics as defined
in the <a class="reference external" href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf">ARM C Language Extensions Release 2.0</a>.
Note that these intrinsics are implemented as motion barriers that block
reordering of memory accesses and side effect instructions. Other instructions
like simple arithmetic may be reordered around the intrinsic. If you expect to
have no reordering at all, use inline assembly instead.</p>
</div>
</div>
<div class="section" id="x86-x86-64-language-extensions">
<h3>X86/X86-64 Language Extensions<a class="headerlink" href="#x86-x86-64-language-extensions" title="Permalink to this headline">¶</a></h3>
<p>The X86 backend has these language extensions:</p>
<div class="section" id="memory-references-to-specified-segments">
<h4>Memory references to specified segments<a class="headerlink" href="#memory-references-to-specified-segments" title="Permalink to this headline">¶</a></h4>
<p>Annotating a pointer with address space #256 causes it to be code generated
relative to the X86 GS segment register, address space #257 causes it to be
relative to the X86 FS segment, and address space #258 causes it to be
relative to the X86 SS segment.  Note that this is a very very low-level
feature that should only be used if you know what you’re doing (for example in
an OS kernel).</p>
<p>Here is an example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define GS_RELATIVE __attribute__((address_space(256)))</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">GS_RELATIVE</span><span class="w"> </span><span class="o">*</span><span class="n">P</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">P</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Which compiles to (on X86-32):</p>
<div class="highlight-gas notranslate"><div class="highlight"><pre><span></span><span class="nl">_foo:</span>
        <span class="nf">movl</span>    <span class="mi">4</span><span class="p">(</span><span class="nv">%esp</span><span class="p">),</span> <span class="nv">%eax</span>
        <span class="nf">movl</span>    <span class="nv">%gs</span><span class="p">:(</span><span class="nv">%eax</span><span class="p">),</span> <span class="nv">%eax</span>
        <span class="nf">ret</span>
</pre></div>
</div>
<p>You can also use the GCC compatibility macros <code class="docutils literal notranslate"><span class="pre">__seg_fs</span></code> and <code class="docutils literal notranslate"><span class="pre">__seg_gs</span></code> for
the same purpose. The preprocessor symbols <code class="docutils literal notranslate"><span class="pre">__SEG_FS</span></code> and <code class="docutils literal notranslate"><span class="pre">__SEG_GS</span></code>
indicate their support.</p>
</div>
</div>
<div class="section" id="powerpc-language-extensions">
<h3>PowerPC Language Extensions<a class="headerlink" href="#powerpc-language-extensions" title="Permalink to this headline">¶</a></h3>
<div class="section" id="set-the-floating-point-rounding-mode">
<h4>Set the Floating Point Rounding Mode<a class="headerlink" href="#set-the-floating-point-rounding-mode" title="Permalink to this headline">¶</a></h4>
<p>PowerPC64/PowerPC64le supports the builtin function <code class="docutils literal notranslate"><span class="pre">__builtin_setrnd</span></code> to set
the floating point rounding mode. This function will use the least significant
two bits of integer argument to set the floating point rounding mode.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="nf">__builtin_setrnd</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">mode</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The effective values for mode are:</p>
<blockquote>
<div><ul class="simple">
<li><p>0 - round to nearest</p></li>
<li><p>1 - round to zero</p></li>
<li><p>2 - round to +infinity</p></li>
<li><p>3 - round to -infinity</p></li>
</ul>
</div></blockquote>
<p>Note that the mode argument will modulo 4, so if the integer argument is greater
than 3, it will only use the least significant two bits of the mode.
Namely, <code class="docutils literal notranslate"><span class="pre">__builtin_setrnd(102))</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">__builtin_setrnd(2)</span></code>.</p>
</div>
<div class="section" id="powerpc-cache-builtins">
<h4>PowerPC cache builtins<a class="headerlink" href="#powerpc-cache-builtins" title="Permalink to this headline">¶</a></h4>
<p>The PowerPC architecture specifies instructions implementing cache operations.
Clang provides builtins that give direct programmer access to these cache
instructions.</p>
<p>Currently the following builtins are implemented in clang:</p>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_dcbf</span></code> copies the contents of a modified block from the data cache
to main memory and flushes the copy from the data cache.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">__dcbf</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">addr</span><span class="p">);</span><span class="w"> </span><span class="cm">/* Data Cache Block Flush */</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">__builtin_dcbf</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="extensions-for-static-analysis">
<h2><a class="toc-backref" href="#id33">Extensions for Static Analysis</a><a class="headerlink" href="#extensions-for-static-analysis" title="Permalink to this headline">¶</a></h2>
<p>Clang supports additional attributes that are useful for documenting program
invariants and rules for static analysis tools, such as the <a class="reference external" href="https://clang-analyzer.llvm.org/">Clang Static
Analyzer</a>. These attributes are documented
in the analyzer’s <a class="reference external" href="https://clang-analyzer.llvm.org/annotations.html">list of source-level annotations</a>.</p>
</div>
<div class="section" id="extensions-for-dynamic-analysis">
<h2><a class="toc-backref" href="#id34">Extensions for Dynamic Analysis</a><a class="headerlink" href="#extensions-for-dynamic-analysis" title="Permalink to this headline">¶</a></h2>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(address_sanitizer)</span></code> to check if the code is being built
with <a class="reference internal" href="AddressSanitizer.html"><span class="doc">AddressSanitizer</span></a>.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(thread_sanitizer)</span></code> to check if the code is being built
with <a class="reference internal" href="ThreadSanitizer.html"><span class="doc">ThreadSanitizer</span></a>.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(memory_sanitizer)</span></code> to check if the code is being built
with <a class="reference internal" href="MemorySanitizer.html"><span class="doc">MemorySanitizer</span></a>.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(dataflow_sanitizer)</span></code> to check if the code is being built
with <a class="reference internal" href="DataFlowSanitizer.html"><span class="doc">DataFlowSanitizer</span></a>.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(safe_stack)</span></code> to check if the code is being built
with <a class="reference internal" href="SafeStack.html"><span class="doc">SafeStack</span></a>.</p>
</div>
<div class="section" id="extensions-for-selectively-disabling-optimization">
<h2><a class="toc-backref" href="#id35">Extensions for selectively disabling optimization</a><a class="headerlink" href="#extensions-for-selectively-disabling-optimization" title="Permalink to this headline">¶</a></h2>
<p>Clang provides a mechanism for selectively disabling optimizations in functions
and methods.</p>
<p>To disable optimizations in a single function definition, the GNU-style or C++11
non-standard attribute <code class="docutils literal notranslate"><span class="pre">optnone</span></code> can be used.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// The following functions will not be optimized.</span>
<span class="c1">// GNU-style attribute</span>
<span class="n">__attribute__</span><span class="p">((</span><span class="n">optnone</span><span class="p">))</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... code</span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// C++11 attribute</span>
<span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">optnone</span><span class="p">]]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">bar</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... code</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>To facilitate disabling optimization for a range of function definitions, a
range-based pragma is provided. Its syntax is <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">optimize</span></code>
followed by <code class="docutils literal notranslate"><span class="pre">off</span></code> or <code class="docutils literal notranslate"><span class="pre">on</span></code>.</p>
<p>All function definitions in the region between an <code class="docutils literal notranslate"><span class="pre">off</span></code> and the following
<code class="docutils literal notranslate"><span class="pre">on</span></code> will be decorated with the <code class="docutils literal notranslate"><span class="pre">optnone</span></code> attribute unless doing so would
conflict with explicit attributes already present on the function (e.g. the
ones that control inlining).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang optimize off</span>
<span class="c1">// This function will be decorated with optnone.</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... code</span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// optnone conflicts with always_inline, so bar() will not be decorated.</span>
<span class="n">__attribute__</span><span class="p">((</span><span class="n">always_inline</span><span class="p">))</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">bar</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ... code</span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#pragma clang optimize on</span>
</pre></div>
</div>
<p>If no <code class="docutils literal notranslate"><span class="pre">on</span></code> is found to close an <code class="docutils literal notranslate"><span class="pre">off</span></code> region, the end of the region is the
end of the compilation unit.</p>
<p>Note that a stray <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">optimize</span> <span class="pre">on</span></code> does not selectively enable
additional optimizations when compiling at low optimization levels. This feature
can only be used to selectively disable optimizations.</p>
<p>The pragma has an effect on functions only at the point of their definition; for
function templates, this means that the state of the pragma at the point of an
instantiation is not necessarily relevant. Consider the following example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">twice</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#pragma clang optimize off</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">thrice</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">container</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">twice</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">thrice</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#pragma clang optimize on</span>
</pre></div>
</div>
<p>In this example, the definition of the template function <code class="docutils literal notranslate"><span class="pre">twice</span></code> is outside
the pragma region, whereas the definition of <code class="docutils literal notranslate"><span class="pre">thrice</span></code> is inside the region.
The <code class="docutils literal notranslate"><span class="pre">container</span></code> function is also in the region and will not be optimized, but
it causes the instantiation of <code class="docutils literal notranslate"><span class="pre">twice</span></code> and <code class="docutils literal notranslate"><span class="pre">thrice</span></code> with an <code class="docutils literal notranslate"><span class="pre">int</span></code> type; of
these two instantiations, <code class="docutils literal notranslate"><span class="pre">twice</span></code> will be optimized (because its definition
was outside the region) and <code class="docutils literal notranslate"><span class="pre">thrice</span></code> will not be optimized.</p>
<p>Clang also implements MSVC’s range-based pragma,
<code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">optimize(&quot;[optimization-list]&quot;,</span> <span class="pre">on</span> <span class="pre">|</span> <span class="pre">off)</span></code>. At the moment, Clang only
supports an empty optimization list, whereas MSVC supports the arguments, <code class="docutils literal notranslate"><span class="pre">s</span></code>,
<code class="docutils literal notranslate"><span class="pre">g</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code>, and <code class="docutils literal notranslate"><span class="pre">y</span></code>. Currently, the implementation of <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">optimize</span></code> behaves
the same as <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">optimize</span></code>. All functions
between <code class="docutils literal notranslate"><span class="pre">off</span></code> and <code class="docutils literal notranslate"><span class="pre">on</span></code> will be decorated with the <code class="docutils literal notranslate"><span class="pre">optnone</span></code> attribute.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma optimize(&quot;&quot;, off)</span>
<span class="c1">// This function will be decorated with optnone.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">f1</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="cp">#pragma optimize(&quot;&quot;, on)</span>
<span class="c1">// This function will be optimized with whatever was specified on</span>
<span class="c1">// the commandline.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">f2</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="c1">// This will warn with Clang&#39;s current implementation.</span>
<span class="cp">#pragma optimize(&quot;g&quot;, on)</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">f3</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</pre></div>
</div>
<p>For MSVC, an empty optimization list and <code class="docutils literal notranslate"><span class="pre">off</span></code> parameter will turn off
all optimizations, <code class="docutils literal notranslate"><span class="pre">s</span></code>, <code class="docutils literal notranslate"><span class="pre">g</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code>, and <code class="docutils literal notranslate"><span class="pre">y</span></code>. An empty optimization and
<code class="docutils literal notranslate"><span class="pre">on</span></code> parameter will reset the optimizations to the ones specified on the
commandline.</p>
<table class="docutils align-default" id="id11">
<caption><span class="caption-text">Parameters (unsupported by Clang)</span><a class="headerlink" href="#id11" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Parameter</p></td>
<td><p>Type of optimization</p></td>
</tr>
<tr class="row-even"><td><p>g</p></td>
<td><p>Deprecated</p></td>
</tr>
<tr class="row-odd"><td><p>s or t</p></td>
<td><p>Short or fast sequences of machine code</p></td>
</tr>
<tr class="row-even"><td><p>y</p></td>
<td><p>Enable frame pointers</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="extensions-for-loop-hint-optimizations">
<h2><a class="toc-backref" href="#id36">Extensions for loop hint optimizations</a><a class="headerlink" href="#extensions-for-loop-hint-optimizations" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">loop</span></code> directive is used to specify hints for optimizing the
subsequent for, while, do-while, or c++11 range-based for loop. The directive
provides options for vectorization, interleaving, predication, unrolling and
distribution. Loop hints can be specified before any loop and will be ignored if
the optimization is not safe to apply.</p>
<p>There are loop hints that control transformations (e.g. vectorization, loop
unrolling) and there are loop hints that set transformation options (e.g.
<code class="docutils literal notranslate"><span class="pre">vectorize_width</span></code>, <code class="docutils literal notranslate"><span class="pre">unroll_count</span></code>).  Pragmas setting transformation options
imply the transformation is enabled, as if it was enabled via the corresponding
transformation pragma (e.g. <code class="docutils literal notranslate"><span class="pre">vectorize(enable)</span></code>). If the transformation is
disabled  (e.g. <code class="docutils literal notranslate"><span class="pre">vectorize(disable)</span></code>), that takes precedence over
transformations option pragmas implying that transformation.</p>
<div class="section" id="vectorization-interleaving-and-predication">
<h3>Vectorization, Interleaving, and Predication<a class="headerlink" href="#vectorization-interleaving-and-predication" title="Permalink to this headline">¶</a></h3>
<p>A vectorized loop performs multiple iterations of the original loop
in parallel using vector instructions. The instruction set of the target
processor determines which vector instructions are available and their vector
widths. This restricts the types of loops that can be vectorized. The vectorizer
automatically determines if the loop is safe and profitable to vectorize. A
vector instruction cost model is used to select the vector width.</p>
<p>Interleaving multiple loop iterations allows modern processors to further
improve instruction-level parallelism (ILP) using advanced hardware features,
such as multiple execution units and out-of-order execution. The vectorizer uses
a cost model that depends on the register pressure and generated code size to
select the interleaving count.</p>
<p>Vectorization is enabled by <code class="docutils literal notranslate"><span class="pre">vectorize(enable)</span></code> and interleaving is enabled
by <code class="docutils literal notranslate"><span class="pre">interleave(enable)</span></code>. This is useful when compiling with <code class="docutils literal notranslate"><span class="pre">-Os</span></code> to
manually enable vectorization or interleaving.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang loop vectorize(enable)</span>
<span class="cp">#pragma clang loop interleave(enable)</span>
<span class="k">for</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The vector width is specified by
<code class="docutils literal notranslate"><span class="pre">vectorize_width(_value_[,</span> <span class="pre">fixed|scalable])</span></code>, where _value_ is a positive
integer and the type of vectorization can be specified with an optional
second parameter. The default for the second parameter is ‘fixed’ and
refers to fixed width vectorization, whereas ‘scalable’ indicates the
compiler should use scalable vectors instead. Another use of vectorize_width
is <code class="docutils literal notranslate"><span class="pre">vectorize_width(fixed|scalable)</span></code> where the user can hint at the type
of vectorization to use without specifying the exact width. In both variants
of the pragma the vectorizer may decide to fall back on fixed width
vectorization if the target does not support scalable vectors.</p>
<p>The interleave count is specified by <code class="docutils literal notranslate"><span class="pre">interleave_count(_value_)</span></code>, where
_value_ is a positive integer. This is useful for specifying the optimal
width/count of the set of target architectures supported by your application.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang loop vectorize_width(2)</span>
<span class="cp">#pragma clang loop interleave_count(2)</span>
<span class="k">for</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Specifying a width/count of 1 disables the optimization, and is equivalent to
<code class="docutils literal notranslate"><span class="pre">vectorize(disable)</span></code> or <code class="docutils literal notranslate"><span class="pre">interleave(disable)</span></code>.</p>
<p>Vector predication is enabled by <code class="docutils literal notranslate"><span class="pre">vectorize_predicate(enable)</span></code>, for example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang loop vectorize(enable)</span>
<span class="cp">#pragma clang loop vectorize_predicate(enable)</span>
<span class="k">for</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This predicates (masks) all instructions in the loop, which allows the scalar
remainder loop (the tail) to be folded into the main vectorized loop. This
might be more efficient when vector predication is efficiently supported by the
target platform.</p>
</div>
<div class="section" id="loop-unrolling">
<h3>Loop Unrolling<a class="headerlink" href="#loop-unrolling" title="Permalink to this headline">¶</a></h3>
<p>Unrolling a loop reduces the loop control overhead and exposes more
opportunities for ILP. Loops can be fully or partially unrolled. Full unrolling
eliminates the loop and replaces it with an enumerated sequence of loop
iterations. Full unrolling is only possible if the loop trip count is known at
compile time. Partial unrolling replicates the loop body within the loop and
reduces the trip count.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">unroll(enable)</span></code> is specified the unroller will attempt to fully unroll the
loop if the trip count is known at compile time. If the fully unrolled code size
is greater than an internal limit the loop will be partially unrolled up to this
limit. If the trip count is not known at compile time the loop will be partially
unrolled with a heuristically chosen unroll factor.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang loop unroll(enable)</span>
<span class="k">for</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">unroll(full)</span></code> is specified the unroller will attempt to fully unroll the
loop if the trip count is known at compile time identically to
<code class="docutils literal notranslate"><span class="pre">unroll(enable)</span></code>. However, with <code class="docutils literal notranslate"><span class="pre">unroll(full)</span></code> the loop will not be unrolled
if the loop count is not known at compile time.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang loop unroll(full)</span>
<span class="k">for</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The unroll count can be specified explicitly with <code class="docutils literal notranslate"><span class="pre">unroll_count(_value_)</span></code> where
_value_ is a positive integer. If this value is greater than the trip count the
loop will be fully unrolled. Otherwise the loop is partially unrolled subject
to the same code size limit as with <code class="docutils literal notranslate"><span class="pre">unroll(enable)</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang loop unroll_count(8)</span>
<span class="k">for</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Unrolling of a loop can be prevented by specifying <code class="docutils literal notranslate"><span class="pre">unroll(disable)</span></code>.</p>
<p>Loop unroll parameters can be controlled by options
<cite>-mllvm -unroll-count=n</cite> and <cite>-mllvm -pragma-unroll-threshold=n</cite>.</p>
</div>
<div class="section" id="loop-distribution">
<h3>Loop Distribution<a class="headerlink" href="#loop-distribution" title="Permalink to this headline">¶</a></h3>
<p>Loop Distribution allows splitting a loop into multiple loops.  This is
beneficial for example when the entire loop cannot be vectorized but some of the
resulting loops can.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">distribute(enable))</span></code> is specified and the loop has memory dependencies
that inhibit vectorization, the compiler will attempt to isolate the offending
operations into a new loop.  This optimization is not enabled by default, only
loops marked with the pragma are considered.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang loop distribute(enable)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nl">S1</span><span class="p">:</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="nl">S2</span><span class="p">:</span><span class="w"> </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This loop will be split into two loops between statements S1 and S2.  The
second loop containing S2 will be vectorized.</p>
<p>Loop Distribution is currently not enabled by default in the optimizer because
it can hurt performance in some cases.  For example, instruction-level
parallelism could be reduced by sequentializing the execution of the
statements S1 and S2 above.</p>
<p>If Loop Distribution is turned on globally with
<code class="docutils literal notranslate"><span class="pre">-mllvm</span> <span class="pre">-enable-loop-distribution</span></code>, specifying <code class="docutils literal notranslate"><span class="pre">distribute(disable)</span></code> can
be used the disable it on a per-loop basis.</p>
</div>
<div class="section" id="additional-information">
<h3>Additional Information<a class="headerlink" href="#additional-information" title="Permalink to this headline">¶</a></h3>
<p>For convenience multiple loop hints can be specified on a single line.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang loop vectorize_width(4) interleave_count(8)</span>
<span class="k">for</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>If an optimization cannot be applied any hints that apply to it will be ignored.
For example, the hint <code class="docutils literal notranslate"><span class="pre">vectorize_width(4)</span></code> is ignored if the loop is not
proven safe to vectorize. To identify and diagnose optimization issues use
<cite>-Rpass</cite>, <cite>-Rpass-missed</cite>, and <cite>-Rpass-analysis</cite> command line options. See the
user guide for details.</p>
</div>
</div>
<div class="section" id="extensions-to-specify-floating-point-flags">
<h2><a class="toc-backref" href="#id37">Extensions to specify floating-point flags</a><a class="headerlink" href="#extensions-to-specify-floating-point-flags" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">fp</span></code> pragma allows floating-point options to be specified
for a section of the source code. This pragma can only appear at file scope or
at the start of a compound statement (excluding comments). When using within a
compound statement, the pragma is active within the scope of the compound
statement.</p>
<p>Currently, the following settings can be controlled with this pragma:</p>
<p><code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">fp</span> <span class="pre">reassociate</span></code> allows control over the reassociation
of floating point expressions. When enabled, this pragma allows the expression
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">(y</span> <span class="pre">+</span> <span class="pre">z)</span></code> to be reassociated as <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y)</span> <span class="pre">+</span> <span class="pre">z</span></code>.
Reassociation can also occur across multiple statements.
This pragma can be used to disable reassociation when it is otherwise
enabled for the translation unit with the <code class="docutils literal notranslate"><span class="pre">-fassociative-math</span></code> flag.
The pragma can take two values: <code class="docutils literal notranslate"><span class="pre">on</span></code> and <code class="docutils literal notranslate"><span class="pre">off</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Enable floating point reassociation across statements</span>
<span class="w">  </span><span class="cp">#pragma clang fp reassociate(on)</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">fp</span> <span class="pre">contract</span></code> specifies whether the compiler should
contract a multiply and an addition (or subtraction) into a fused FMA
operation when supported by the target.</p>
<p>The pragma can take three values: <code class="docutils literal notranslate"><span class="pre">on</span></code>, <code class="docutils literal notranslate"><span class="pre">fast</span></code> and <code class="docutils literal notranslate"><span class="pre">off</span></code>.  The <code class="docutils literal notranslate"><span class="pre">on</span></code>
option is identical to using <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">STDC</span> <span class="pre">FP_CONTRACT(ON)</span></code> and it allows
fusion as specified the language standard.  The <code class="docutils literal notranslate"><span class="pre">fast</span></code> option allows fusion
in cases when the language standard does not make this possible (e.g. across
statements in C).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma clang fp contract(fast)</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The pragma can also be used with <code class="docutils literal notranslate"><span class="pre">off</span></code> which turns FP contraction off for a
section of the code. This can be useful when fast contraction is otherwise
enabled for the translation unit with the <code class="docutils literal notranslate"><span class="pre">-ffp-contract=fast-honor-pragmas</span></code> flag.
Note that <code class="docutils literal notranslate"><span class="pre">-ffp-contract=fast</span></code> will override pragmas to fuse multiply and
addition across statements regardless of any controlling pragmas.</p>
<p><code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">fp</span> <span class="pre">exceptions</span></code> specifies floating point exception behavior. It
may take one of the values: <code class="docutils literal notranslate"><span class="pre">ignore</span></code>, <code class="docutils literal notranslate"><span class="pre">maytrap</span></code> or <code class="docutils literal notranslate"><span class="pre">strict</span></code>. Meaning of
these values is same as for <a class="reference external" href="http://llvm.org/docs/LangRef.html#constrained-floating-point-intrinsics">constrained floating point intrinsics</a>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Preserve floating point exceptions</span>
<span class="w">  </span><span class="cp">#pragma clang fp exceptions(strict)</span>
<span class="w">  </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fetestexcept</span><span class="p">(</span><span class="n">FE_OVERFLOW</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">fp</span></code> pragma may contain any number of options:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cp">#pragma clang fp exceptions(maytrap) contract(fast) reassociate(on)</span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">fp</span> <span class="pre">eval_method</span></code> allows floating-point behavior to be specified
for a section of the source code. This pragma can appear at file or namespace
scope, or at the start of a compound statement (excluding comments).
The pragma is active within the scope of the compound statement.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">clang</span> <span class="pre">fp</span> <span class="pre">eval_method(source)</span></code> is enabled, the section of code
governed by the pragma behaves as though the command-line option
<code class="docutils literal notranslate"><span class="pre">-ffp-eval-method=source</span></code> is enabled. Rounds intermediate results to
source-defined precision.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">clang</span> <span class="pre">fp</span> <span class="pre">eval_method(double)</span></code> is enabled, the section of code
governed by the pragma behaves as though the command-line option
<code class="docutils literal notranslate"><span class="pre">-ffp-eval-method=double</span></code> is enabled. Rounds intermediate results to
<code class="docutils literal notranslate"><span class="pre">double</span></code> precision.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">clang</span> <span class="pre">fp</span> <span class="pre">eval_method(extended)</span></code> is enabled, the section of code
governed by the pragma behaves as though the command-line option
<code class="docutils literal notranslate"><span class="pre">-ffp-eval-method=extended</span></code> is enabled. Rounds intermediate results to
target-dependent <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">double</span></code> precision. In Win32 programming, for instance,
the long double data type maps to the double, 64-bit precision data type.</p>
<p>The full syntax this pragma supports is
<code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">fp</span> <span class="pre">eval_method(source|double|extended)</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// The compiler will use long double as the floating-point evaluation</span>
<span class="w">  </span><span class="c1">// method.</span>
<span class="w">  </span><span class="cp">#pragma clang fp eval_method(extended)</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">float_control</span></code> pragma allows precise floating-point
semantics and floating-point exception behavior to be specified
for a section of the source code. This pragma can only appear at file or
namespace scope, within a language linkage specification or at the start of a
compound statement (excluding comments). When used within a compound statement,
the pragma is active within the scope of the compound statement.  This pragma
is modeled after a Microsoft pragma with the same spelling and syntax.  For
pragmas specified at file or namespace scope, or within a language linkage
specification, a stack is supported so that the <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">float_control</span></code>
settings can be pushed or popped.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">float_control(precise,</span> <span class="pre">on)</span></code> is enabled, the section of code
governed by the pragma uses precise floating point semantics, effectively
<code class="docutils literal notranslate"><span class="pre">-ffast-math</span></code> is disabled and <code class="docutils literal notranslate"><span class="pre">-ffp-contract=on</span></code>
(fused multiply add) is enabled.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">float_control(except,</span> <span class="pre">on)</span></code> is enabled, the section of code
governed by the pragma behaves as though the command-line option
<code class="docutils literal notranslate"><span class="pre">-ffp-exception-behavior=strict</span></code> is enabled,
when <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">float_control(except,</span> <span class="pre">off)</span></code> is enabled, the section of code
governed by the pragma behaves as though the command-line option
<code class="docutils literal notranslate"><span class="pre">-ffp-exception-behavior=ignore</span></code> is enabled.</p>
<p>The full syntax this pragma supports is
<code class="docutils literal notranslate"><span class="pre">float_control(except|precise,</span> <span class="pre">on|off</span> <span class="pre">[,</span> <span class="pre">push])</span></code> and
<code class="docutils literal notranslate"><span class="pre">float_control(push|pop)</span></code>.
The <code class="docutils literal notranslate"><span class="pre">push</span></code> and <code class="docutils literal notranslate"><span class="pre">pop</span></code> forms, including using <code class="docutils literal notranslate"><span class="pre">push</span></code> as the optional
third argument, can only occur at file scope.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// This block will be compiled with -fno-fast-math and -ffp-contract=on</span>
<span class="w">  </span><span class="cp">#pragma float_control(precise, on)</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="specifying-an-attribute-for-multiple-declarations-pragma-clang-attribute">
<h2><a class="toc-backref" href="#id38">Specifying an attribute for multiple declarations (#pragma clang attribute)</a><a class="headerlink" href="#specifying-an-attribute-for-multiple-declarations-pragma-clang-attribute" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">attribute</span></code> directive can be used to apply an attribute to
multiple declarations. The <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">attribute</span> <span class="pre">push</span></code> variation of the
directive pushes a new “scope” of <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">attribute</span></code> that attributes
can be added to. The <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">attribute</span> <span class="pre">(...)</span></code> variation adds an
attribute to that scope, and the <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">attribute</span> <span class="pre">pop</span></code> variation pops
the scope. You can also use <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">attribute</span> <span class="pre">push</span> <span class="pre">(...)</span></code>, which is a
shorthand for when you want to add one attribute to a new scope. Multiple push
directives can be nested inside each other.</p>
<p>The attributes that are used in the <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">attribute</span></code> directives
can be written using the GNU-style syntax:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang attribute push (__attribute__((annotate(&quot;custom&quot;))), apply_to = function)</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">function</span><span class="p">();</span><span class="w"> </span><span class="c1">// The function now has the annotate(&quot;custom&quot;) attribute</span>

<span class="cp">#pragma clang attribute pop</span>
</pre></div>
</div>
<p>The attributes can also be written using the C++11 style syntax:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang attribute push ([[noreturn]], apply_to = function)</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">function</span><span class="p">();</span><span class="w"> </span><span class="c1">// The function now has the [[noreturn]] attribute</span>

<span class="cp">#pragma clang attribute pop</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">__declspec</span></code> style syntax is also supported:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang attribute push (__declspec(dllexport), apply_to = function)</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">function</span><span class="p">();</span><span class="w"> </span><span class="c1">// The function now has the __declspec(dllexport) attribute</span>

<span class="cp">#pragma clang attribute pop</span>
</pre></div>
</div>
<p>A single push directive can contain multiple attributes, however,
only one syntax style can be used within a single directive:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang attribute push ([[noreturn, noinline]], apply_to = function)</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">function1</span><span class="p">();</span><span class="w"> </span><span class="c1">// The function now has the [[noreturn]] and [[noinline]] attributes</span>

<span class="cp">#pragma clang attribute pop</span>

<span class="cp">#pragma clang attribute push (__attribute((noreturn, noinline)), apply_to = function)</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">function2</span><span class="p">();</span><span class="w"> </span><span class="c1">// The function now has the __attribute((noreturn)) and __attribute((noinline)) attributes</span>

<span class="cp">#pragma clang attribute pop</span>
</pre></div>
</div>
<p>Because multiple push directives can be nested, if you’re writing a macro that
expands to <code class="docutils literal notranslate"><span class="pre">_Pragma(&quot;clang</span> <span class="pre">attribute&quot;)</span></code> it’s good hygiene (though not
required) to add a namespace to your push/pop directives. A pop directive with a
namespace will pop the innermost push that has that same namespace. This will
ensure that another macro’s <code class="docutils literal notranslate"><span class="pre">pop</span></code> won’t inadvertently pop your attribute. Note
that an <code class="docutils literal notranslate"><span class="pre">pop</span></code> without a namespace will pop the innermost <code class="docutils literal notranslate"><span class="pre">push</span></code> without a
namespace. <code class="docutils literal notranslate"><span class="pre">push``es</span> <span class="pre">with</span> <span class="pre">a</span> <span class="pre">namespace</span> <span class="pre">can</span> <span class="pre">only</span> <span class="pre">be</span> <span class="pre">popped</span> <span class="pre">by</span> <span class="pre">``pop</span></code> with the
same namespace. For instance:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define ASSUME_NORETURN_BEGIN _Pragma(&quot;clang attribute AssumeNoreturn.push ([[noreturn]], apply_to = function)&quot;)</span>
<span class="cp">#define ASSUME_NORETURN_END   _Pragma(&quot;clang attribute AssumeNoreturn.pop&quot;)</span>

<span class="cp">#define ASSUME_UNAVAILABLE_BEGIN _Pragma(&quot;clang attribute Unavailable.push (__attribute__((unavailable)), apply_to=function)&quot;)</span>
<span class="cp">#define ASSUME_UNAVAILABLE_END   _Pragma(&quot;clang attribute Unavailable.pop&quot;)</span>


<span class="n">ASSUME_NORETURN_BEGIN</span><span class="w"></span>
<span class="n">ASSUME_UNAVAILABLE_BEGIN</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">function</span><span class="p">();</span><span class="w"> </span><span class="c1">// function has [[noreturn]] and __attribute__((unavailable))</span>
<span class="n">ASSUME_NORETURN_END</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">other_function</span><span class="p">();</span><span class="w"> </span><span class="c1">// function has __attribute__((unavailable))</span>
<span class="n">ASSUME_UNAVAILABLE_END</span><span class="w"></span>
</pre></div>
</div>
<p>Without the namespaces on the macros, <code class="docutils literal notranslate"><span class="pre">other_function</span></code> will be annotated with
<code class="docutils literal notranslate"><span class="pre">[[noreturn]]</span></code> instead of <code class="docutils literal notranslate"><span class="pre">__attribute__((unavailable))</span></code>. This may seem like
a contrived example, but its very possible for this kind of situation to appear
in real code if the pragmas are spread out across a large file. You can test if
your version of clang supports namespaces on <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">attribute</span></code> with
<code class="docutils literal notranslate"><span class="pre">__has_extension(pragma_clang_attribute_namespaces)</span></code>.</p>
<div class="section" id="subject-match-rules">
<h3>Subject Match Rules<a class="headerlink" href="#subject-match-rules" title="Permalink to this headline">¶</a></h3>
<p>The set of declarations that receive a single attribute from the attribute stack
depends on the subject match rules that were specified in the pragma. Subject
match rules are specified after the attribute. The compiler expects an
identifier that corresponds to the subject set specifier. The <code class="docutils literal notranslate"><span class="pre">apply_to</span></code>
specifier is currently the only supported subject set specifier. It allows you
to specify match rules that form a subset of the attribute’s allowed subject
set, i.e. the compiler doesn’t require all of the attribute’s subjects. For
example, an attribute like <code class="docutils literal notranslate"><span class="pre">[[nodiscard]]</span></code> whose subject set includes
<code class="docutils literal notranslate"><span class="pre">enum</span></code>, <code class="docutils literal notranslate"><span class="pre">record</span></code> and <code class="docutils literal notranslate"><span class="pre">hasType(functionType)</span></code>, requires the presence of at
least one of these rules after <code class="docutils literal notranslate"><span class="pre">apply_to</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang attribute push([[nodiscard]], apply_to = enum)</span>

<span class="k">enum</span> <span class="nc">Enum1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">A1</span><span class="p">,</span><span class="w"> </span><span class="n">B1</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// The enum will receive [[nodiscard]]</span>

<span class="k">struct</span> <span class="nc">Record1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// The struct will *not* receive [[nodiscard]]</span>

<span class="cp">#pragma clang attribute pop</span>

<span class="cp">#pragma clang attribute push([[nodiscard]], apply_to = any(record, enum))</span>

<span class="k">enum</span> <span class="nc">Enum2</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">A2</span><span class="p">,</span><span class="w"> </span><span class="n">B2</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// The enum will receive [[nodiscard]]</span>

<span class="k">struct</span> <span class="nc">Record2</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// The struct *will* receive [[nodiscard]]</span>

<span class="cp">#pragma clang attribute pop</span>

<span class="c1">// This is an error, since [[nodiscard]] can&#39;t be applied to namespaces:</span>
<span class="cp">#pragma clang attribute push([[nodiscard]], apply_to = any(record, namespace))</span>

<span class="cp">#pragma clang attribute pop</span>
</pre></div>
</div>
<p>Multiple match rules can be specified using the <code class="docutils literal notranslate"><span class="pre">any</span></code> match rule, as shown
in the example above. The <code class="docutils literal notranslate"><span class="pre">any</span></code> rule applies attributes to all declarations
that are matched by at least one of the rules in the <code class="docutils literal notranslate"><span class="pre">any</span></code>. It doesn’t nest
and can’t be used inside the other match rules. Redundant match rules or rules
that conflict with one another should not be used inside of <code class="docutils literal notranslate"><span class="pre">any</span></code>. Failing to
specify a rule within the <code class="docutils literal notranslate"><span class="pre">any</span></code> rule results in an error.</p>
<p>Clang supports the following match rules:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">function</span></code>: Can be used to apply attributes to functions. This includes C++
member functions, static functions, operators, and constructors/destructors.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">function(is_member)</span></code>: Can be used to apply attributes to C++ member
functions. This includes members like static functions, operators, and
constructors/destructors.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hasType(functionType)</span></code>: Can be used to apply attributes to functions, C++
member functions, and variables/fields whose type is a function pointer. It
does not apply attributes to Objective-C methods or blocks.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type_alias</span></code>: Can be used to apply attributes to <code class="docutils literal notranslate"><span class="pre">typedef</span></code> declarations
and C++11 type aliases.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">record</span></code>: Can be used to apply attributes to <code class="docutils literal notranslate"><span class="pre">struct</span></code>, <code class="docutils literal notranslate"><span class="pre">class</span></code>, and
<code class="docutils literal notranslate"><span class="pre">union</span></code> declarations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">record(unless(is_union))</span></code>: Can be used to apply attributes only to
<code class="docutils literal notranslate"><span class="pre">struct</span></code> and <code class="docutils literal notranslate"><span class="pre">class</span></code> declarations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">enum</span></code>: Can be be used to apply attributes to enumeration declarations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">enum_constant</span></code>: Can be used to apply attributes to enumerators.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">variable</span></code>: Can be used to apply attributes to variables, including
local variables, parameters, global variables, and static member variables.
It does not apply attributes to instance member variables or Objective-C
ivars.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">variable(is_thread_local)</span></code>: Can be used to apply attributes to thread-local
variables only.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">variable(is_global)</span></code>: Can be used to apply attributes to global variables
only.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">variable(is_local)</span></code>: Can be used to apply attributes to local variables
only.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">variable(is_parameter)</span></code>: Can be used to apply attributes to parameters
only.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">variable(unless(is_parameter))</span></code>: Can be used to apply attributes to all
the variables that are not parameters.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">field</span></code>: Can be used to apply attributes to non-static member variables
in a record. This includes Objective-C ivars.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">namespace</span></code>: Can be used to apply attributes to <code class="docutils literal notranslate"><span class="pre">namespace</span></code> declarations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">objc_interface</span></code>: Can be used to apply attributes to <code class="docutils literal notranslate"><span class="pre">&#64;interface</span></code>
declarations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">objc_protocol</span></code>: Can be used to apply attributes to <code class="docutils literal notranslate"><span class="pre">&#64;protocol</span></code>
declarations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">objc_category</span></code>: Can be used to apply attributes to category declarations,
including class extensions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">objc_method</span></code>: Can be used to apply attributes to Objective-C methods,
including instance and class methods. Implicit methods like implicit property
getters and setters do not receive the attribute.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">objc_method(is_instance)</span></code>: Can be used to apply attributes to Objective-C
instance methods.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">objc_property</span></code>: Can be used to apply attributes to <code class="docutils literal notranslate"><span class="pre">&#64;property</span></code>
declarations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block</span></code>: Can be used to apply attributes to block declarations. This does
not include variables/fields of block pointer type.</p></li>
</ul>
<p>The use of <code class="docutils literal notranslate"><span class="pre">unless</span></code> in match rules is currently restricted to a strict set of
sub-rules that are used by the supported attributes. That means that even though
<code class="docutils literal notranslate"><span class="pre">variable(unless(is_parameter))</span></code> is a valid match rule,
<code class="docutils literal notranslate"><span class="pre">variable(unless(is_thread_local))</span></code> is not.</p>
</div>
<div class="section" id="supported-attributes">
<h3>Supported Attributes<a class="headerlink" href="#supported-attributes" title="Permalink to this headline">¶</a></h3>
<p>Not all attributes can be used with the <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">attribute</span></code> directive.
Notably, statement attributes like <code class="docutils literal notranslate"><span class="pre">[[fallthrough]]</span></code> or type attributes
like <code class="docutils literal notranslate"><span class="pre">address_space</span></code> aren’t supported by this directive. You can determine
whether or not an attribute is supported by the pragma by referring to the
<a class="reference internal" href="AttributeReference.html"><span class="doc">individual documentation for that attribute</span></a>.</p>
<p>The attributes are applied to all matching declarations individually, even when
the attribute is semantically incorrect. The attributes that aren’t applied to
any declaration are not verified semantically.</p>
</div>
</div>
<div class="section" id="specifying-section-names-for-global-objects-pragma-clang-section">
<h2><a class="toc-backref" href="#id39">Specifying section names for global objects (#pragma clang section)</a><a class="headerlink" href="#specifying-section-names-for-global-objects-pragma-clang-section" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">section</span></code> directive provides a means to assign section-names
to global variables, functions and static variables.</p>
<p>The section names can be specified as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang section bss=&quot;myBSS&quot; data=&quot;myData&quot; rodata=&quot;myRodata&quot; relro=&quot;myRelro&quot; text=&quot;myText&quot;</span>
</pre></div>
</div>
<p>The section names can be reverted back to default name by supplying an empty
string to the section kind, for example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang section bss=&quot;&quot; data=&quot;&quot; text=&quot;&quot; rodata=&quot;&quot; relro=&quot;&quot;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">section</span></code> directive obeys the following rules:</p>
<ul class="simple">
<li><p>The pragma applies to all global variable, statics and function declarations
from the pragma to the end of the translation unit.</p></li>
<li><p>The pragma clang section is enabled automatically, without need of any flags.</p></li>
<li><p>This feature is only defined to work sensibly for ELF targets.</p></li>
<li><p>If section name is specified through _attribute_((section(“myname”))), then
the attribute name gains precedence.</p></li>
<li><p>Global variables that are initialized to zero will be placed in the named
bss section, if one is present.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">section</span></code> directive does not does try to infer section-kind
from the name. For example, naming a section “<code class="docutils literal notranslate"><span class="pre">.bss.mySec</span></code>” does NOT mean
it will be a bss section name.</p></li>
<li><p>The decision about which section-kind applies to each global is taken in the back-end.
Once the section-kind is known, appropriate section name, as specified by the user using
<code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">section</span></code> directive, is applied to that global.</p></li>
</ul>
</div>
<div class="section" id="specifying-linker-options-on-elf-targets">
<h2><a class="toc-backref" href="#id40">Specifying Linker Options on ELF Targets</a><a class="headerlink" href="#specifying-linker-options-on-elf-targets" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">comment(lib,</span> <span class="pre">...)</span></code> directive is supported on all ELF targets.
The second parameter is the library name (without the traditional Unix prefix of
<code class="docutils literal notranslate"><span class="pre">lib</span></code>).  This allows you to provide an implicit link of dependent libraries.</p>
</div>
<div class="section" id="evaluating-object-size-dynamically">
<h2><a class="toc-backref" href="#id41">Evaluating Object Size Dynamically</a><a class="headerlink" href="#evaluating-object-size-dynamically" title="Permalink to this headline">¶</a></h2>
<p>Clang supports the builtin <code class="docutils literal notranslate"><span class="pre">__builtin_dynamic_object_size</span></code>, the semantics are
the same as GCC’s <code class="docutils literal notranslate"><span class="pre">__builtin_object_size</span></code> (which Clang also supports), but
<code class="docutils literal notranslate"><span class="pre">__builtin_dynamic_object_size</span></code> can evaluate the object’s size at runtime.
<code class="docutils literal notranslate"><span class="pre">__builtin_dynamic_object_size</span></code> is meant to be used as a drop-in replacement
for <code class="docutils literal notranslate"><span class="pre">__builtin_object_size</span></code> in libraries that support it.</p>
<p>For instance, here is a program that <code class="docutils literal notranslate"><span class="pre">__builtin_dynamic_object_size</span></code> will make
safer:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">copy_into_buffer</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">strlcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;some string&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="s">&quot;some string&quot;</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Previous line preprocesses to:</span>
<span class="w">  </span><span class="c1">// __builtin___strlcpy_chk(buffer, &quot;some string&quot;, strlen(&quot;some string&quot;), __builtin_object_size(buffer, 0))</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Since the size of <code class="docutils literal notranslate"><span class="pre">buffer</span></code> can’t be known at compile time, Clang will fold
<code class="docutils literal notranslate"><span class="pre">__builtin_object_size(buffer,</span> <span class="pre">0)</span></code> into <code class="docutils literal notranslate"><span class="pre">-1</span></code>. However, if this was written
as <code class="docutils literal notranslate"><span class="pre">__builtin_dynamic_object_size(buffer,</span> <span class="pre">0)</span></code>, Clang will fold it into
<code class="docutils literal notranslate"><span class="pre">size</span></code>, providing some extra runtime safety.</p>
</div>
<div class="section" id="deprecating-macros">
<h2><a class="toc-backref" href="#id42">Deprecating Macros</a><a class="headerlink" href="#deprecating-macros" title="Permalink to this headline">¶</a></h2>
<p>Clang supports the pragma <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">deprecated</span></code>, which can be used to
provide deprecation warnings for macro uses. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define MIN(x, y) x &lt; y ? x : y</span>
<span class="cp">#pragma clang deprecated(MIN, &quot;use std::min instead&quot;)</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">min</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">MIN</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="c1">// warning: MIN is deprecated: use std::min instead</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">deprecated</span></code> should be preferred for this purpose over
<code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">GCC</span> <span class="pre">warning</span></code> because the warning can be controlled with
<code class="docutils literal notranslate"><span class="pre">-Wdeprecated</span></code>.</p>
</div>
<div class="section" id="restricted-expansion-macros">
<h2><a class="toc-backref" href="#id43">Restricted Expansion Macros</a><a class="headerlink" href="#restricted-expansion-macros" title="Permalink to this headline">¶</a></h2>
<p>Clang supports the pragma <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">restrict_expansion</span></code>, which can be
used restrict macro expansion in headers. This can be valuable when providing
headers with ABI stability requirements. Any expansion of the annotated macro
processed by the preprocessor after the <code class="docutils literal notranslate"><span class="pre">#pragma</span></code> annotation will log a
warning. Redefining the macro or undefining the macro will not be diagnosed, nor
will expansion of the macro within the main source file. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define TARGET_ARM 1</span>
<span class="cp">#pragma clang restrict_expansion(TARGET_ARM, &quot;&lt;reason&gt;&quot;)</span>

<span class="c1">/// Foo.h</span>
<span class="k">struct</span> <span class="nc">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="cp">#if TARGET_ARM </span><span class="c1">// warning: TARGET_ARM is marked unsafe in headers: &lt;reason&gt;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">X</span><span class="p">;</span><span class="w"></span>
<span class="cp">#else</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">X</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="p">};</span><span class="w"></span>

<span class="c1">/// main.c</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;foo.h&quot;</span><span class="cp"></span>
<span class="cp">#if TARGET_ARM </span><span class="c1">// No warning in main source file</span>
<span class="n">X_TYPE</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"></span>
<span class="cp">#else</span>
<span class="n">X_TYPE</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"></span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>This warning is controlled by <code class="docutils literal notranslate"><span class="pre">-Wpedantic-macros</span></code>.</p>
</div>
<div class="section" id="final-macros">
<h2><a class="toc-backref" href="#id44">Final Macros</a><a class="headerlink" href="#final-macros" title="Permalink to this headline">¶</a></h2>
<p>Clang supports the pragma <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">final</span></code>, which can be used to
mark macros as final, meaning they cannot be undef’d or re-defined. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define FINAL_MACRO 1</span>
<span class="cp">#pragma clang final(FINAL_MACRO)</span>

<span class="cp">#define FINAL_MACRO </span><span class="c1">// warning: FINAL_MACRO is marked final and should not be redefined</span>
<span class="cp">#undef FINAL_MACRO  </span><span class="c1">// warning: FINAL_MACRO is marked final and should not be undefined</span>
</pre></div>
</div>
<p>This is useful for enforcing system-provided macros that should not be altered
in user headers or code. This is controlled by <code class="docutils literal notranslate"><span class="pre">-Wpedantic-macros</span></code>. Final
macros will always warn on redefinition, including situations with identical
bodies and in system headers.</p>
</div>
<div class="section" id="line-control">
<h2><a class="toc-backref" href="#id45">Line Control</a><a class="headerlink" href="#line-control" title="Permalink to this headline">¶</a></h2>
<p>Clang supports an extension for source line control, which takes the
form of a preprocessor directive starting with an unsigned integral
constant. In addition to the standard <code class="docutils literal notranslate"><span class="pre">#line</span></code> directive, this form
allows control of an include stack and header file type, which is used
in issuing diagnostics. These lines are emitted in preprocessed
output.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp"># &lt;line:number&gt; &lt;filename:string&gt; &lt;header-type:numbers&gt;</span>
</pre></div>
</div>
<p>The filename is optional, and if unspecified indicates no change in
source filename. The header-type is an optional, whitespace-delimited,
sequence of magic numbers as follows.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Push the current source file name onto the include stack and
enter a new file.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code>: Pop the include stack and return to the specified file. If
the filename is <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>, the name popped from the include stack is
used. Otherwise there is no requirement that the specified filename
matches the current source when originally pushed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3</span></code>: Enter a system-header region. System headers often contain
implementation-specific source that would normally emit a diagnostic.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">4</span></code>: Enter an implicit <code class="docutils literal notranslate"><span class="pre">extern</span> <span class="pre">&quot;C&quot;</span></code> region. This is not required on
modern systems where system headers are C++-aware.</p></li>
</ul>
<p>At most a single <code class="docutils literal notranslate"><span class="pre">1</span></code> or <code class="docutils literal notranslate"><span class="pre">2</span></code> can be present, and values must be in
ascending order.</p>
<p>Examples are:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp"># 57 </span><span class="c1">// Advance (or return) to line 57 of the current source file</span>
<span class="cp"># 57 &quot;frob&quot; </span><span class="c1">// Set to line 57 of &quot;frob&quot;</span>
<span class="cp"># 1 &quot;foo.h&quot; 1 </span><span class="c1">// Enter &quot;foo.h&quot; at line 1</span>
<span class="cp"># 59 &quot;main.c&quot; 2 </span><span class="c1">// Leave current include and return to &quot;main.c&quot;</span>
<span class="cp"># 1 &quot;/usr/include/stdio.h&quot; 1 3 </span><span class="c1">// Enter a system header</span>
<span class="cp"># 60 &quot;&quot; 2 </span><span class="c1">// return to &quot;main.c&quot;</span>
<span class="cp"># 1 &quot;/usr/ancient/header.h&quot; 1 4 </span><span class="c1">// Enter an implicit extern &quot;C&quot; header</span>
</pre></div>
</div>
</div>
<div class="section" id="extended-integer-types">
<h2><a class="toc-backref" href="#id46">Extended Integer Types</a><a class="headerlink" href="#extended-integer-types" title="Permalink to this headline">¶</a></h2>
<p>Clang supports the C23 <code class="docutils literal notranslate"><span class="pre">_BitInt(N)</span></code> feature as an extension in older C modes
and in C++. This type was previously implemented in Clang with the same
semantics, but spelled <code class="docutils literal notranslate"><span class="pre">_ExtInt(N)</span></code>. This spelling has been deprecated in
favor of the standard type.</p>
<p>Note: the ABI for <code class="docutils literal notranslate"><span class="pre">_BitInt(N)</span></code> is still in the process of being stabilized,
so this type should not yet be used in interfaces that require ABI stability.</p>
</div>
<div class="section" id="intrinsics-support-within-constant-expressions">
<h2><a class="toc-backref" href="#id47">Intrinsics Support within Constant Expressions</a><a class="headerlink" href="#intrinsics-support-within-constant-expressions" title="Permalink to this headline">¶</a></h2>
<p>The following builtin intrinsics can be used in constant expressions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_bitreverse8</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_bitreverse16</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_bitreverse32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_bitreverse64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_bswap16</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_bswap32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_bswap64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_clrsb</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_clrsbl</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_clrsbll</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_clz</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_clzl</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_clzll</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_clzs</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_ctz</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_ctzl</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_ctzll</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_ctzs</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_ffs</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_ffsl</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_ffsll</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_fpclassify</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_inf</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_isinf</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_isinf_sign</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_isfinite</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_isnan</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_isnormal</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_nan</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_nans</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_parity</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_parityl</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_parityll</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_popcount</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_popcountl</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_popcountll</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateleft8</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateleft16</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateleft32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateleft64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateright8</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateright16</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateright32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateright64</span></code></p></li>
</ul>
<p>The following x86-specific intrinsics can be used in constant expressions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">_bit_scan_forward</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_bit_scan_reverse</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__bsfd</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__bsfq</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__bsrd</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__bsrq</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__bswap</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__bswapd</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__bswap64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__bswapq</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_castf32_u32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_castf64_u64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_castu32_f32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_castu64_f64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_mm_popcnt_u32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_mm_popcnt_u64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_popcnt32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_popcnt64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__popcntd</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__popcntq</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rolb</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rolw</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rold</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rolq</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rorb</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rorw</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rord</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rorq</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_rotl</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_rotr</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_rotwl</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_rotwr</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_lrotl</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_lrotr</span></code></p></li>
</ul>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="Toolchain.html">Assembling a Complete Toolchain</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="ObjectiveCLiterals.html">Objective-C Literals</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2007-2022, The Clang Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>
  </body>
</html>