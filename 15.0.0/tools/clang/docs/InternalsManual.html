
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>“Clang” CFE Internals Manual &#8212; Clang 15.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Driver Design &amp; Internals" href="DriverInternals.html" />
    <link rel="prev" title="Clang Offload Packager" href="ClangOffloadPackager.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Clang 15.0.0 documentation</span></a></h1>
        <h2 class="heading"><span>“Clang” CFE Internals Manual</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="ClangOffloadPackager.html">Clang Offload Packager</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="DriverInternals.html">Driver Design &amp; Internals</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <div class="section" id="clang-cfe-internals-manual">
<h1>“Clang” CFE Internals Manual<a class="headerlink" href="#clang-cfe-internals-manual" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id4">Introduction</a></p></li>
<li><p><a class="reference internal" href="#llvm-support-library" id="id5">LLVM Support Library</a></p></li>
<li><p><a class="reference internal" href="#the-clang-basic-library" id="id6">The Clang “Basic” Library</a></p>
<ul>
<li><p><a class="reference internal" href="#the-diagnostics-subsystem" id="id7">The Diagnostics Subsystem</a></p>
<ul>
<li><p><a class="reference internal" href="#the-diagnostic-kinds-td-files" id="id8">The <code class="docutils literal notranslate"><span class="pre">Diagnostic*Kinds.td</span></code> files</a></p></li>
<li><p><a class="reference internal" href="#the-format-string" id="id9">The Format String</a></p></li>
<li><p><a class="reference internal" href="#formatting-a-diagnostic-argument" id="id10">Formatting a Diagnostic Argument</a></p></li>
<li><p><a class="reference internal" href="#producing-the-diagnostic" id="id11">Producing the Diagnostic</a></p></li>
<li><p><a class="reference internal" href="#fix-it-hints" id="id12">Fix-It Hints</a></p></li>
<li><p><a class="reference internal" href="#the-diagnosticconsumer-interface" id="id13">The <code class="docutils literal notranslate"><span class="pre">DiagnosticConsumer</span></code> Interface</a></p></li>
<li><p><a class="reference internal" href="#adding-translations-to-clang" id="id14">Adding Translations to Clang</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-sourcelocation-and-sourcemanager-classes" id="id15">The <code class="docutils literal notranslate"><span class="pre">SourceLocation</span></code> and <code class="docutils literal notranslate"><span class="pre">SourceManager</span></code> classes</a></p></li>
<li><p><a class="reference internal" href="#sourcerange-and-charsourcerange" id="id16"><code class="docutils literal notranslate"><span class="pre">SourceRange</span></code> and <code class="docutils literal notranslate"><span class="pre">CharSourceRange</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-driver-library" id="id17">The Driver Library</a></p></li>
<li><p><a class="reference internal" href="#precompiled-headers" id="id18">Precompiled Headers</a></p></li>
<li><p><a class="reference internal" href="#the-frontend-library" id="id19">The Frontend Library</a></p>
<ul>
<li><p><a class="reference internal" href="#compiler-invocation" id="id20">Compiler Invocation</a></p></li>
<li><p><a class="reference internal" href="#command-line-interface" id="id21">Command Line Interface</a></p></li>
<li><p><a class="reference internal" href="#command-line-parsing" id="id22">Command Line Parsing</a></p></li>
<li><p><a class="reference internal" href="#command-line-generation" id="id23">Command Line Generation</a></p></li>
<li><p><a class="reference internal" href="#adding-new-command-line-option" id="id24">Adding new Command Line Option</a></p></li>
<li><p><a class="reference internal" href="#option-marshalling-infrastructure" id="id25">Option Marshalling Infrastructure</a></p></li>
<li><p><a class="reference internal" href="#option-marshalling-annotations" id="id26">Option Marshalling Annotations</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-lexer-and-preprocessor-library" id="id27">The Lexer and Preprocessor Library</a></p>
<ul>
<li><p><a class="reference internal" href="#the-token-class" id="id28">The Token class</a></p></li>
<li><p><a class="reference internal" href="#annotation-tokens" id="id29">Annotation Tokens</a></p></li>
<li><p><a class="reference internal" href="#the-lexer-class" id="id30">The <code class="docutils literal notranslate"><span class="pre">Lexer</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#the-tokenlexer-class" id="id31">The <code class="docutils literal notranslate"><span class="pre">TokenLexer</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#the-multipleincludeopt-class" id="id32">The <code class="docutils literal notranslate"><span class="pre">MultipleIncludeOpt</span></code> class</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-parser-library" id="id33">The Parser Library</a></p></li>
<li><p><a class="reference internal" href="#the-ast-library" id="id34">The AST Library</a></p>
<ul>
<li><p><a class="reference internal" href="#design-philosophy" id="id35">Design philosophy</a></p>
<ul>
<li><p><a class="reference internal" href="#immutability" id="id36">Immutability</a></p></li>
<li><p><a class="reference internal" href="#faithfulness" id="id37">Faithfulness</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-type-class-and-its-subclasses" id="id38">The <code class="docutils literal notranslate"><span class="pre">Type</span></code> class and its subclasses</a></p>
<ul>
<li><p><a class="reference internal" href="#canonical-types" id="id39">Canonical Types</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-qualtype-class" id="id40">The <code class="docutils literal notranslate"><span class="pre">QualType</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#declaration-names" id="id41">Declaration names</a></p></li>
<li><p><a class="reference internal" href="#declaration-contexts" id="id42">Declaration contexts</a></p>
<ul>
<li><p><a class="reference internal" href="#redeclarations-and-overloads" id="id43">Redeclarations and Overloads</a></p></li>
<li><p><a class="reference internal" href="#lexical-and-semantic-contexts" id="id44">Lexical and Semantic Contexts</a></p></li>
<li><p><a class="reference internal" href="#transparent-declaration-contexts" id="id45">Transparent Declaration Contexts</a></p></li>
<li><p><a class="reference internal" href="#multiply-defined-declaration-contexts" id="id46">Multiply-Defined Declaration Contexts</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#error-handling" id="id47">Error Handling</a></p>
<ul>
<li><p><a class="reference internal" href="#recovery-ast" id="id48">Recovery AST</a></p></li>
<li><p><a class="reference internal" href="#types-and-dependence" id="id49">Types and dependence</a></p></li>
<li><p><a class="reference internal" href="#containserrors-bit" id="id50">ContainsErrors bit</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-astimporter" id="id51">The ASTImporter</a></p>
<ul>
<li><p><a class="reference internal" href="#abstract-syntax-graph" id="id52">Abstract Syntax Graph</a></p></li>
<li><p><a class="reference internal" href="#structural-equivalency" id="id53">Structural Equivalency</a></p></li>
<li><p><a class="reference internal" href="#redeclaration-chains" id="id54">Redeclaration Chains</a></p></li>
<li><p><a class="reference internal" href="#traversal-during-the-import" id="id55">Traversal during the Import</a></p></li>
<li><p><a class="reference internal" href="#id1" id="id56">Error Handling</a></p></li>
<li><p><a class="reference internal" href="#lookup-problems" id="id57">Lookup Problems</a></p>
<ul>
<li><p><a class="reference internal" href="#externalastsource" id="id58">ExternalASTSource</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#class-template-instantiations" id="id59">Class Template Instantiations</a></p></li>
<li><p><a class="reference internal" href="#visibility-of-declarations" id="id60">Visibility of Declarations</a></p></li>
<li><p><a class="reference internal" href="#strategies-to-handle-conflicting-names" id="id61">Strategies to Handle Conflicting Names</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-cfg-class" id="id62">The <code class="docutils literal notranslate"><span class="pre">CFG</span></code> class</a></p>
<ul>
<li><p><a class="reference internal" href="#basic-blocks" id="id63">Basic Blocks</a></p></li>
<li><p><a class="reference internal" href="#entry-and-exit-blocks" id="id64">Entry and Exit Blocks</a></p></li>
<li><p><a class="reference internal" href="#conditional-control-flow" id="id65">Conditional Control-Flow</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#constant-folding-in-the-clang-ast" id="id66">Constant Folding in the Clang AST</a></p>
<ul>
<li><p><a class="reference internal" href="#implementation-approach" id="id67">Implementation Approach</a></p></li>
<li><p><a class="reference internal" href="#extensions" id="id68">Extensions</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-sema-library" id="id69">The Sema Library</a></p></li>
<li><p><a class="reference internal" href="#the-codegen-library" id="id70">The CodeGen Library</a></p></li>
<li><p><a class="reference internal" href="#how-to-change-clang" id="id71">How to change Clang</a></p>
<ul>
<li><p><a class="reference internal" href="#how-to-add-an-attribute" id="id72">How to add an attribute</a></p>
<ul>
<li><p><a class="reference internal" href="#attribute-basics" id="id73">Attribute Basics</a></p></li>
<li><p><a class="reference internal" href="#include-clang-basic-attr-td" id="id74"><code class="docutils literal notranslate"><span class="pre">include/clang/Basic/Attr.td</span></code></a></p>
<ul>
<li><p><a class="reference internal" href="#spellings" id="id75">Spellings</a></p></li>
<li><p><a class="reference internal" href="#subjects" id="id76">Subjects</a></p></li>
<li><p><a class="reference internal" href="#documentation" id="id77">Documentation</a></p></li>
<li><p><a class="reference internal" href="#arguments" id="id78">Arguments</a></p></li>
<li><p><a class="reference internal" href="#other-properties" id="id79">Other Properties</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#boilerplate" id="id80">Boilerplate</a></p></li>
<li><p><a class="reference internal" href="#semantic-handling" id="id81">Semantic handling</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#how-to-add-an-expression-or-statement" id="id82">How to add an expression or statement</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id4">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document describes some of the more important APIs and internal design
decisions made in the Clang C front-end.  The purpose of this document is to
both capture some of this high level information and also describe some of the
design decisions behind it.  This is meant for people interested in hacking on
Clang, not for end-users.  The description below is categorized by libraries,
and does not describe any of the clients of the libraries.</p>
</div>
<div class="section" id="llvm-support-library">
<h2><a class="toc-backref" href="#id5">LLVM Support Library</a><a class="headerlink" href="#llvm-support-library" title="Permalink to this headline">¶</a></h2>
<p>The LLVM <code class="docutils literal notranslate"><span class="pre">libSupport</span></code> library provides many underlying libraries and
<a class="reference external" href="https://llvm.org/docs/ProgrammersManual.html">data-structures</a>, including
command line option processing, various containers and a system abstraction
layer, which is used for file system access.</p>
</div>
<div class="section" id="the-clang-basic-library">
<h2><a class="toc-backref" href="#id6">The Clang “Basic” Library</a><a class="headerlink" href="#the-clang-basic-library" title="Permalink to this headline">¶</a></h2>
<p>This library certainly needs a better name.  The “basic” library contains a
number of low-level utilities for tracking and manipulating source buffers,
locations within the source buffers, diagnostics, tokens, target abstraction,
and information about the subset of the language being compiled for.</p>
<p>Part of this infrastructure is specific to C (such as the <code class="docutils literal notranslate"><span class="pre">TargetInfo</span></code>
class), other parts could be reused for other non-C-based languages
(<code class="docutils literal notranslate"><span class="pre">SourceLocation</span></code>, <code class="docutils literal notranslate"><span class="pre">SourceManager</span></code>, <code class="docutils literal notranslate"><span class="pre">Diagnostics</span></code>, <code class="docutils literal notranslate"><span class="pre">FileManager</span></code>).
When and if there is future demand we can figure out if it makes sense to
introduce a new library, move the general classes somewhere else, or introduce
some other solution.</p>
<p>We describe the roles of these classes in order of their dependencies.</p>
<div class="section" id="the-diagnostics-subsystem">
<h3><a class="toc-backref" href="#id7">The Diagnostics Subsystem</a><a class="headerlink" href="#the-diagnostics-subsystem" title="Permalink to this headline">¶</a></h3>
<p>The Clang Diagnostics subsystem is an important part of how the compiler
communicates with the human.  Diagnostics are the warnings and errors produced
when the code is incorrect or dubious.  In Clang, each diagnostic produced has
(at the minimum) a unique ID, an English translation associated with it, a
<a class="reference internal" href="#sourcelocation"><span class="std std-ref">SourceLocation</span></a> to “put the caret”, and a severity
(e.g., <code class="docutils literal notranslate"><span class="pre">WARNING</span></code> or <code class="docutils literal notranslate"><span class="pre">ERROR</span></code>).  They can also optionally include a number of
arguments to the diagnostic (which fill in “%0“‘s in the string) as well as a
number of source ranges that related to the diagnostic.</p>
<p>In this section, we’ll be giving examples produced by the Clang command line
driver, but diagnostics can be <a class="reference internal" href="#diagnosticconsumer"><span class="std std-ref">rendered in many different ways</span></a> depending on how the <code class="docutils literal notranslate"><span class="pre">DiagnosticConsumer</span></code> interface is
implemented.  A representative example of a diagnostic is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>t.c:38:15: error: invalid operands to binary expression (&#39;int *&#39; and &#39;_Complex float&#39;)
P = (P-42) + Gamma*4;
    ~~~~~~ ^ ~~~~~~~
</pre></div>
</div>
<p>In this example, you can see the English translation, the severity (error), you
can see the source location (the caret (“<code class="docutils literal notranslate"><span class="pre">^</span></code>”) and file/line/column info),
the source ranges “<code class="docutils literal notranslate"><span class="pre">~~~~</span></code>”, arguments to the diagnostic (“<code class="docutils literal notranslate"><span class="pre">int*</span></code>” and
“<code class="docutils literal notranslate"><span class="pre">_Complex</span> <span class="pre">float</span></code>”).  You’ll have to believe me that there is a unique ID
backing the diagnostic :).</p>
<p>Getting all of this to happen has several steps and involves many moving
pieces, this section describes them and talks about best practices when adding
a new diagnostic.</p>
<div class="section" id="the-diagnostic-kinds-td-files">
<h4><a class="toc-backref" href="#id8">The <code class="docutils literal notranslate"><span class="pre">Diagnostic*Kinds.td</span></code> files</a><a class="headerlink" href="#the-diagnostic-kinds-td-files" title="Permalink to this headline">¶</a></h4>
<p>Diagnostics are created by adding an entry to one of the
<code class="docutils literal notranslate"><span class="pre">clang/Basic/Diagnostic*Kinds.td</span></code> files, depending on what library will be
using it.  From this file, <strong class="program">tblgen</strong> generates the unique ID of the
diagnostic, the severity of the diagnostic and the English translation + format
string.</p>
<p>There is little sanity with the naming of the unique ID’s right now.  Some
start with <code class="docutils literal notranslate"><span class="pre">err_</span></code>, <code class="docutils literal notranslate"><span class="pre">warn_</span></code>, <code class="docutils literal notranslate"><span class="pre">ext_</span></code> to encode the severity into the name.
Since the enum is referenced in the C++ code that produces the diagnostic, it
is somewhat useful for it to be reasonably short.</p>
<p>The severity of the diagnostic comes from the set {<code class="docutils literal notranslate"><span class="pre">NOTE</span></code>, <code class="docutils literal notranslate"><span class="pre">REMARK</span></code>,
<code class="docutils literal notranslate"><span class="pre">WARNING</span></code>,
<code class="docutils literal notranslate"><span class="pre">EXTENSION</span></code>, <code class="docutils literal notranslate"><span class="pre">EXTWARN</span></code>, <code class="docutils literal notranslate"><span class="pre">ERROR</span></code>}.  The <code class="docutils literal notranslate"><span class="pre">ERROR</span></code> severity is used for
diagnostics indicating the program is never acceptable under any circumstances.
When an error is emitted, the AST for the input code may not be fully built.
The <code class="docutils literal notranslate"><span class="pre">EXTENSION</span></code> and <code class="docutils literal notranslate"><span class="pre">EXTWARN</span></code> severities are used for extensions to the
language that Clang accepts.  This means that Clang fully understands and can
represent them in the AST, but we produce diagnostics to tell the user their
code is non-portable.  The difference is that the former are ignored by
default, and the later warn by default.  The <code class="docutils literal notranslate"><span class="pre">WARNING</span></code> severity is used for
constructs that are valid in the currently selected source language but that
are dubious in some way.  The <code class="docutils literal notranslate"><span class="pre">REMARK</span></code> severity provides generic information
about the compilation that is not necessarily related to any dubious code.  The
<code class="docutils literal notranslate"><span class="pre">NOTE</span></code> level is used to staple more information onto previous diagnostics.</p>
<p>These <em>severities</em> are mapped into a smaller set (the <code class="docutils literal notranslate"><span class="pre">Diagnostic::Level</span></code>
enum, {<code class="docutils literal notranslate"><span class="pre">Ignored</span></code>, <code class="docutils literal notranslate"><span class="pre">Note</span></code>, <code class="docutils literal notranslate"><span class="pre">Remark</span></code>, <code class="docutils literal notranslate"><span class="pre">Warning</span></code>, <code class="docutils literal notranslate"><span class="pre">Error</span></code>, <code class="docutils literal notranslate"><span class="pre">Fatal</span></code>}) of
output
<em>levels</em> by the diagnostics subsystem based on various configuration options.
Clang internally supports a fully fine grained mapping mechanism that allows
you to map almost any diagnostic to the output level that you want.  The only
diagnostics that cannot be mapped are <code class="docutils literal notranslate"><span class="pre">NOTE</span></code>s, which always follow the
severity of the previously emitted diagnostic and <code class="docutils literal notranslate"><span class="pre">ERROR</span></code>s, which can only
be mapped to <code class="docutils literal notranslate"><span class="pre">Fatal</span></code> (it is not possible to turn an error into a warning, for
example).</p>
<p>Diagnostic mappings are used in many ways.  For example, if the user specifies
<code class="docutils literal notranslate"><span class="pre">-pedantic</span></code>, <code class="docutils literal notranslate"><span class="pre">EXTENSION</span></code> maps to <code class="docutils literal notranslate"><span class="pre">Warning</span></code>, if they specify
<code class="docutils literal notranslate"><span class="pre">-pedantic-errors</span></code>, it turns into <code class="docutils literal notranslate"><span class="pre">Error</span></code>.  This is used to implement
options like <code class="docutils literal notranslate"><span class="pre">-Wunused_macros</span></code>, <code class="docutils literal notranslate"><span class="pre">-Wundef</span></code> etc.</p>
<p>Mapping to <code class="docutils literal notranslate"><span class="pre">Fatal</span></code> should only be used for diagnostics that are considered so
severe that error recovery won’t be able to recover sensibly from them (thus
spewing a ton of bogus errors).  One example of this class of error are failure
to <code class="docutils literal notranslate"><span class="pre">#include</span></code> a file.</p>
</div>
<div class="section" id="the-format-string">
<h4><a class="toc-backref" href="#id9">The Format String</a><a class="headerlink" href="#the-format-string" title="Permalink to this headline">¶</a></h4>
<p>The format string for the diagnostic is very simple, but it has some power.  It
takes the form of a string in English with markers that indicate where and how
arguments to the diagnostic are inserted and formatted.  For example, here are
some simple format strings:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;binary integer literals are an extension&quot;</span><span class="w"></span>
<span class="s">&quot;format string contains &#39;</span><span class="se">\\</span><span class="s">0&#39; within the string body&quot;</span><span class="w"></span>
<span class="s">&quot;more &#39;%%&#39; conversions than data arguments&quot;</span><span class="w"></span>
<span class="s">&quot;invalid operands to binary expression (%0 and %1)&quot;</span><span class="w"></span>
<span class="s">&quot;overloaded &#39;%0&#39; must be a %select{unary|binary|unary or binary}2 operator&quot;</span><span class="w"></span>
<span class="w">     </span><span class="s">&quot; (has %1 parameter%s1)&quot;</span><span class="w"></span>
</pre></div>
</div>
<p>These examples show some important points of format strings.  You can use any
plain ASCII character in the diagnostic string except “<code class="docutils literal notranslate"><span class="pre">%</span></code>” without a
problem, but these are C strings, so you have to use and be aware of all the C
escape sequences (as in the second example).  If you want to produce a “<code class="docutils literal notranslate"><span class="pre">%</span></code>”
in the output, use the “<code class="docutils literal notranslate"><span class="pre">%%</span></code>” escape sequence, like the third diagnostic.
Finally, Clang uses the “<code class="docutils literal notranslate"><span class="pre">%...[digit]</span></code>” sequences to specify where and how
arguments to the diagnostic are formatted.</p>
<p>Arguments to the diagnostic are numbered according to how they are specified by
the C++ code that <a class="reference internal" href="#internals-producing-diag"><span class="std std-ref">produces them</span></a>, and are
referenced by <code class="docutils literal notranslate"><span class="pre">%0</span></code> .. <code class="docutils literal notranslate"><span class="pre">%9</span></code>.  If you have more than 10 arguments to your
diagnostic, you are doing something wrong :).  Unlike <code class="docutils literal notranslate"><span class="pre">printf</span></code>, there is no
requirement that arguments to the diagnostic end up in the output in the same
order as they are specified, you could have a format string with “<code class="docutils literal notranslate"><span class="pre">%1</span> <span class="pre">%0</span></code>”
that swaps them, for example.  The text in between the percent and digit are
formatting instructions.  If there are no instructions, the argument is just
turned into a string and substituted in.</p>
<p>Here are some “best practices” for writing the English format string:</p>
<ul class="simple">
<li><p>Keep the string short.  It should ideally fit in the 80 column limit of the
<code class="docutils literal notranslate"><span class="pre">DiagnosticKinds.td</span></code> file.  This avoids the diagnostic wrapping when
printed, and forces you to think about the important point you are conveying
with the diagnostic.</p></li>
<li><p>Take advantage of location information.  The user will be able to see the
line and location of the caret, so you don’t need to tell them that the
problem is with the 4th argument to the function: just point to it.</p></li>
<li><p>Do not capitalize the diagnostic string, and do not end it with a period.</p></li>
<li><p>If you need to quote something in the diagnostic string, use single quotes.</p></li>
</ul>
<p>Diagnostics should never take random English strings as arguments: you
shouldn’t use “<code class="docutils literal notranslate"><span class="pre">you</span> <span class="pre">have</span> <span class="pre">a</span> <span class="pre">problem</span> <span class="pre">with</span> <span class="pre">%0</span></code>” and pass in things like “<code class="docutils literal notranslate"><span class="pre">your</span>
<span class="pre">argument</span></code>” or “<code class="docutils literal notranslate"><span class="pre">your</span> <span class="pre">return</span> <span class="pre">value</span></code>” as arguments.  Doing this prevents
<a class="reference internal" href="#internals-diag-translation"><span class="std std-ref">translating</span></a> the Clang diagnostics to other
languages (because they’ll get random English words in their otherwise
localized diagnostic).  The exceptions to this are C/C++ language keywords
(e.g., <code class="docutils literal notranslate"><span class="pre">auto</span></code>, <code class="docutils literal notranslate"><span class="pre">const</span></code>, <code class="docutils literal notranslate"><span class="pre">mutable</span></code>, etc) and C/C++ operators (<code class="docutils literal notranslate"><span class="pre">/=</span></code>).
Note that things like “pointer” and “reference” are not keywords.  On the other
hand, you <em>can</em> include anything that comes from the user’s source code,
including variable names, types, labels, etc.  The “<code class="docutils literal notranslate"><span class="pre">select</span></code>” format can be
used to achieve this sort of thing in a localizable way, see below.</p>
</div>
<div class="section" id="formatting-a-diagnostic-argument">
<h4><a class="toc-backref" href="#id10">Formatting a Diagnostic Argument</a><a class="headerlink" href="#formatting-a-diagnostic-argument" title="Permalink to this headline">¶</a></h4>
<p>Arguments to diagnostics are fully typed internally, and come from a couple
different classes: integers, types, names, and random strings.  Depending on
the class of the argument, it can be optionally formatted in different ways.
This gives the <code class="docutils literal notranslate"><span class="pre">DiagnosticConsumer</span></code> information about what the argument means
without requiring it to use a specific presentation (consider this MVC for
Clang :).</p>
<p>Here are the different diagnostic argument formats currently supported by
Clang:</p>
<p><strong>“s” format</strong></p>
<dl class="simple">
<dt>Example:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">&quot;requires</span> <span class="pre">%1</span> <span class="pre">parameter%s1&quot;</span></code></p>
</dd>
<dt>Class:</dt><dd><p>Integers</p>
</dd>
<dt>Description:</dt><dd><p>This is a simple formatter for integers that is useful when producing English
diagnostics.  When the integer is 1, it prints as nothing.  When the integer
is not 1, it prints as “<code class="docutils literal notranslate"><span class="pre">s</span></code>”.  This allows some simple grammatical forms to
be to be handled correctly, and eliminates the need to use gross things like
<code class="docutils literal notranslate"><span class="pre">&quot;requires</span> <span class="pre">%1</span> <span class="pre">parameter(s)&quot;</span></code>.</p>
</dd>
</dl>
<p><strong>“select” format</strong></p>
<dl class="simple">
<dt>Example:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">&quot;must</span> <span class="pre">be</span> <span class="pre">a</span> <span class="pre">%select{unary|binary|unary</span> <span class="pre">or</span> <span class="pre">binary}2</span> <span class="pre">operator&quot;</span></code></p>
</dd>
<dt>Class:</dt><dd><p>Integers</p>
</dd>
<dt>Description:</dt><dd><p>This format specifier is used to merge multiple related diagnostics together
into one common one, without requiring the difference to be specified as an
English string argument.  Instead of specifying the string, the diagnostic
gets an integer argument and the format string selects the numbered option.
In this case, the “<code class="docutils literal notranslate"><span class="pre">%2</span></code>” value must be an integer in the range [0..2].  If
it is 0, it prints “unary”, if it is 1 it prints “binary” if it is 2, it
prints “unary or binary”.  This allows other language translations to
substitute reasonable words (or entire phrases) based on the semantics of the
diagnostic instead of having to do things textually.  The selected string
does undergo formatting.</p>
</dd>
</dl>
<p><strong>“plural” format</strong></p>
<dl>
<dt>Example:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">&quot;you</span> <span class="pre">have</span> <span class="pre">%1</span> <span class="pre">%plural{1:mouse|:mice}1</span> <span class="pre">connected</span> <span class="pre">to</span> <span class="pre">your</span> <span class="pre">computer&quot;</span></code></p>
</dd>
<dt>Class:</dt><dd><p>Integers</p>
</dd>
<dt>Description:</dt><dd><p>This is a formatter for complex plural forms.  It is designed to handle even
the requirements of languages with very complex plural forms, as many Baltic
languages have.  The argument consists of a series of expression/form pairs,
separated by “:”, where the first form whose expression evaluates to true is
the result of the modifier.</p>
<p>An expression can be empty, in which case it is always true.  See the example
at the top.  Otherwise, it is a series of one or more numeric conditions,
separated by “,”.  If any condition matches, the expression matches.  Each
numeric condition can take one of three forms.</p>
<ul class="simple">
<li><p>number: A simple decimal number matches if the argument is the same as the
number.  Example: <code class="docutils literal notranslate"><span class="pre">&quot;%plural{1:mouse|:mice}4&quot;</span></code></p></li>
<li><p>range: A range in square brackets matches if the argument is within the
range.  Then range is inclusive on both ends.  Example:
<code class="docutils literal notranslate"><span class="pre">&quot;%plural{0:none|1:one|[2,5]:some|:many}2&quot;</span></code></p></li>
<li><p>modulo: A modulo operator is followed by a number, and equals sign and
either a number or a range.  The tests are the same as for plain numbers
and ranges, but the argument is taken modulo the number first.  Example:
<code class="docutils literal notranslate"><span class="pre">&quot;%plural{%100=0:even</span> <span class="pre">hundred|%100=[1,50]:lower</span> <span class="pre">half|:everything</span> <span class="pre">else}1&quot;</span></code></p></li>
</ul>
<p>The parser is very unforgiving.  A syntax error, even whitespace, will abort,
as will a failure to match the argument against any expression.</p>
</dd>
</dl>
<p><strong>“ordinal” format</strong></p>
<dl class="simple">
<dt>Example:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">&quot;ambiguity</span> <span class="pre">in</span> <span class="pre">%ordinal0</span> <span class="pre">argument&quot;</span></code></p>
</dd>
<dt>Class:</dt><dd><p>Integers</p>
</dd>
<dt>Description:</dt><dd><p>This is a formatter which represents the argument number as an ordinal: the
value <code class="docutils literal notranslate"><span class="pre">1</span></code> becomes <code class="docutils literal notranslate"><span class="pre">1st</span></code>, <code class="docutils literal notranslate"><span class="pre">3</span></code> becomes <code class="docutils literal notranslate"><span class="pre">3rd</span></code>, and so on.  Values less
than <code class="docutils literal notranslate"><span class="pre">1</span></code> are not supported.  This formatter is currently hard-coded to use
English ordinals.</p>
</dd>
</dl>
<p><strong>“objcclass” format</strong></p>
<dl class="simple">
<dt>Example:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">&quot;method</span> <span class="pre">%objcclass0</span> <span class="pre">not</span> <span class="pre">found&quot;</span></code></p>
</dd>
<dt>Class:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">DeclarationName</span></code></p>
</dd>
<dt>Description:</dt><dd><p>This is a simple formatter that indicates the <code class="docutils literal notranslate"><span class="pre">DeclarationName</span></code> corresponds
to an Objective-C class method selector.  As such, it prints the selector
with a leading “<code class="docutils literal notranslate"><span class="pre">+</span></code>”.</p>
</dd>
</dl>
<p><strong>“objcinstance” format</strong></p>
<dl class="simple">
<dt>Example:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">&quot;method</span> <span class="pre">%objcinstance0</span> <span class="pre">not</span> <span class="pre">found&quot;</span></code></p>
</dd>
<dt>Class:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">DeclarationName</span></code></p>
</dd>
<dt>Description:</dt><dd><p>This is a simple formatter that indicates the <code class="docutils literal notranslate"><span class="pre">DeclarationName</span></code> corresponds
to an Objective-C instance method selector.  As such, it prints the selector
with a leading “<code class="docutils literal notranslate"><span class="pre">-</span></code>“.</p>
</dd>
</dl>
<p><strong>“q” format</strong></p>
<dl class="simple">
<dt>Example:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">&quot;candidate</span> <span class="pre">found</span> <span class="pre">by</span> <span class="pre">name</span> <span class="pre">lookup</span> <span class="pre">is</span> <span class="pre">%q0&quot;</span></code></p>
</dd>
<dt>Class:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">NamedDecl</span> <span class="pre">*</span></code></p>
</dd>
<dt>Description:</dt><dd><p>This formatter indicates that the fully-qualified name of the declaration
should be printed, e.g., “<code class="docutils literal notranslate"><span class="pre">std::vector</span></code>” rather than “<code class="docutils literal notranslate"><span class="pre">vector</span></code>”.</p>
</dd>
</dl>
<p><strong>“diff” format</strong></p>
<dl class="simple">
<dt>Example:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">&quot;no</span> <span class="pre">known</span> <span class="pre">conversion</span> <span class="pre">%diff{from</span> <span class="pre">$</span> <span class="pre">to</span> <span class="pre">$|from</span> <span class="pre">argument</span> <span class="pre">type</span> <span class="pre">to</span> <span class="pre">parameter</span> <span class="pre">type}1,2&quot;</span></code></p>
</dd>
<dt>Class:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">QualType</span></code></p>
</dd>
<dt>Description:</dt><dd><p>This formatter takes two <code class="docutils literal notranslate"><span class="pre">QualType</span></code>s and attempts to print a template
difference between the two.  If tree printing is off, the text inside the
braces before the pipe is printed, with the formatted text replacing the $.
If tree printing is on, the text after the pipe is printed and a type tree is
printed after the diagnostic message.</p>
</dd>
</dl>
<p>It is really easy to add format specifiers to the Clang diagnostics system, but
they should be discussed before they are added.  If you are creating a lot of
repetitive diagnostics and/or have an idea for a useful formatter, please bring
it up on the cfe-dev mailing list.</p>
<p><strong>“sub” format</strong></p>
<dl>
<dt>Example:</dt><dd><p>Given the following record definition of type <code class="docutils literal notranslate"><span class="pre">TextSubstitution</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def select_ovl_candidate : TextSubstitution&lt;
  &quot;%select{function|constructor}0%select{| template| %2}1&quot;&gt;;
</pre></div>
</div>
<p>which can be used as</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def note_ovl_candidate : Note&lt;
  &quot;candidate %sub{select_ovl_candidate}3,2,1 not viable&quot;&gt;;
</pre></div>
</div>
<p>and will act as if it was written
<code class="docutils literal notranslate"><span class="pre">&quot;candidate</span> <span class="pre">%select{function|constructor}3%select{|</span> <span class="pre">template|</span> <span class="pre">%1}2</span> <span class="pre">not</span> <span class="pre">viable&quot;</span></code>.</p>
</dd>
<dt>Description:</dt><dd><p>This format specifier is used to avoid repeating strings verbatim in multiple
diagnostics. The argument to <code class="docutils literal notranslate"><span class="pre">%sub</span></code> must name a <code class="docutils literal notranslate"><span class="pre">TextSubstitution</span></code> tblgen
record. The substitution must specify all arguments used by the substitution,
and the modifier indexes in the substitution are re-numbered accordingly. The
substituted text must itself be a valid format string before substitution.</p>
</dd>
</dl>
</div>
<div class="section" id="producing-the-diagnostic">
<span id="internals-producing-diag"></span><h4><a class="toc-backref" href="#id11">Producing the Diagnostic</a><a class="headerlink" href="#producing-the-diagnostic" title="Permalink to this headline">¶</a></h4>
<p>Now that you’ve created the diagnostic in the <code class="docutils literal notranslate"><span class="pre">Diagnostic*Kinds.td</span></code> file, you
need to write the code that detects the condition in question and emits the new
diagnostic.  Various components of Clang (e.g., the preprocessor, <code class="docutils literal notranslate"><span class="pre">Sema</span></code>,
etc.) provide a helper function named “<code class="docutils literal notranslate"><span class="pre">Diag</span></code>”.  It creates a diagnostic and
accepts the arguments, ranges, and other information that goes along with it.</p>
<p>For example, the binary expression error comes from code like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">various</span><span class="w"> </span><span class="n">things</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">bad</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">Diag</span><span class="p">(</span><span class="n">Loc</span><span class="p">,</span><span class="w"> </span><span class="n">diag</span><span class="o">::</span><span class="n">err_typecheck_invalid_operands</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">lex</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">rex</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">lex</span><span class="o">-&gt;</span><span class="n">getSourceRange</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">rex</span><span class="o">-&gt;</span><span class="n">getSourceRange</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>This shows that use of the <code class="docutils literal notranslate"><span class="pre">Diag</span></code> method: it takes a location (a
<a class="reference internal" href="#sourcelocation"><span class="std std-ref">SourceLocation</span></a> object) and a diagnostic enum value
(which matches the name from <code class="docutils literal notranslate"><span class="pre">Diagnostic*Kinds.td</span></code>).  If the diagnostic takes
arguments, they are specified with the <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> operator: the first argument
becomes <code class="docutils literal notranslate"><span class="pre">%0</span></code>, the second becomes <code class="docutils literal notranslate"><span class="pre">%1</span></code>, etc.  The diagnostic interface
allows you to specify arguments of many different types, including <code class="docutils literal notranslate"><span class="pre">int</span></code> and
<code class="docutils literal notranslate"><span class="pre">unsigned</span></code> for integer arguments, <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char*</span></code> and <code class="docutils literal notranslate"><span class="pre">std::string</span></code> for
string arguments, <code class="docutils literal notranslate"><span class="pre">DeclarationName</span></code> and <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">IdentifierInfo</span> <span class="pre">*</span></code> for names,
<code class="docutils literal notranslate"><span class="pre">QualType</span></code> for types, etc.  <code class="docutils literal notranslate"><span class="pre">SourceRange</span></code>s are also specified with the
<code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> operator, but do not have a specific ordering requirement.</p>
<p>As you can see, adding and producing a diagnostic is pretty straightforward.
The hard part is deciding exactly what you need to say to help the user,
picking a suitable wording, and providing the information needed to format it
correctly.  The good news is that the call site that issues a diagnostic should
be completely independent of how the diagnostic is formatted and in what
language it is rendered.</p>
</div>
<div class="section" id="fix-it-hints">
<h4><a class="toc-backref" href="#id12">Fix-It Hints</a><a class="headerlink" href="#fix-it-hints" title="Permalink to this headline">¶</a></h4>
<p>In some cases, the front end emits diagnostics when it is clear that some small
change to the source code would fix the problem.  For example, a missing
semicolon at the end of a statement or a use of deprecated syntax that is
easily rewritten into a more modern form.  Clang tries very hard to emit the
diagnostic and recover gracefully in these and other cases.</p>
<p>However, for these cases where the fix is obvious, the diagnostic can be
annotated with a hint (referred to as a “fix-it hint”) that describes how to
change the code referenced by the diagnostic to fix the problem.  For example,
it might add the missing semicolon at the end of the statement or rewrite the
use of a deprecated construct into something more palatable.  Here is one such
example from the C++ front end, where we warn about the right-shift operator
changing meaning from C++98 to C++11:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>test.cpp:3:7: warning: use of right-shift operator (&#39;&gt;&gt;&#39;) in template argument
                       will require parentheses in C++11
A&lt;100 &gt;&gt; 2&gt; *a;
      ^
  (       )
</pre></div>
</div>
<p>Here, the fix-it hint is suggesting that parentheses be added, and showing
exactly where those parentheses would be inserted into the source code.  The
fix-it hints themselves describe what changes to make to the source code in an
abstract manner, which the text diagnostic printer renders as a line of
“insertions” below the caret line.  <a class="reference internal" href="#diagnosticconsumer"><span class="std std-ref">Other diagnostic clients</span></a> might choose to render the code differently (e.g., as
markup inline) or even give the user the ability to automatically fix the
problem.</p>
<p>Fix-it hints on errors and warnings need to obey these rules:</p>
<ul class="simple">
<li><p>Since they are automatically applied if <code class="docutils literal notranslate"><span class="pre">-Xclang</span> <span class="pre">-fixit</span></code> is passed to the
driver, they should only be used when it’s very likely they match the user’s
intent.</p></li>
<li><p>Clang must recover from errors as if the fix-it had been applied.</p></li>
<li><p>Fix-it hints on a warning must not change the meaning of the code.
However, a hint may clarify the meaning as intentional, for example by adding
parentheses when the precedence of operators isn’t obvious.</p></li>
</ul>
<p>If a fix-it can’t obey these rules, put the fix-it on a note.  Fix-its on notes
are not applied automatically.</p>
<p>All fix-it hints are described by the <code class="docutils literal notranslate"><span class="pre">FixItHint</span></code> class, instances of which
should be attached to the diagnostic using the <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> operator in the same way
that highlighted source ranges and arguments are passed to the diagnostic.
Fix-it hints can be created with one of three constructors:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">FixItHint::CreateInsertion(Loc,</span> <span class="pre">Code)</span></code></p>
<blockquote>
<div><p>Specifies that the given <code class="docutils literal notranslate"><span class="pre">Code</span></code> (a string) should be inserted before the
source location <code class="docutils literal notranslate"><span class="pre">Loc</span></code>.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">FixItHint::CreateRemoval(Range)</span></code></p>
<blockquote>
<div><p>Specifies that the code in the given source <code class="docutils literal notranslate"><span class="pre">Range</span></code> should be removed.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">FixItHint::CreateReplacement(Range,</span> <span class="pre">Code)</span></code></p>
<blockquote>
<div><p>Specifies that the code in the given source <code class="docutils literal notranslate"><span class="pre">Range</span></code> should be removed,
and replaced with the given <code class="docutils literal notranslate"><span class="pre">Code</span></code> string.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="the-diagnosticconsumer-interface">
<span id="diagnosticconsumer"></span><h4><a class="toc-backref" href="#id13">The <code class="docutils literal notranslate"><span class="pre">DiagnosticConsumer</span></code> Interface</a><a class="headerlink" href="#the-diagnosticconsumer-interface" title="Permalink to this headline">¶</a></h4>
<p>Once code generates a diagnostic with all of the arguments and the rest of the
relevant information, Clang needs to know what to do with it.  As previously
mentioned, the diagnostic machinery goes through some filtering to map a
severity onto a diagnostic level, then (assuming the diagnostic is not mapped
to “<code class="docutils literal notranslate"><span class="pre">Ignore</span></code>”) it invokes an object that implements the <code class="docutils literal notranslate"><span class="pre">DiagnosticConsumer</span></code>
interface with the information.</p>
<p>It is possible to implement this interface in many different ways.  For
example, the normal Clang <code class="docutils literal notranslate"><span class="pre">DiagnosticConsumer</span></code> (named
<code class="docutils literal notranslate"><span class="pre">TextDiagnosticPrinter</span></code>) turns the arguments into strings (according to the
various formatting rules), prints out the file/line/column information and the
string, then prints out the line of code, the source ranges, and the caret.
However, this behavior isn’t required.</p>
<p>Another implementation of the <code class="docutils literal notranslate"><span class="pre">DiagnosticConsumer</span></code> interface is the
<code class="docutils literal notranslate"><span class="pre">TextDiagnosticBuffer</span></code> class, which is used when Clang is in <code class="docutils literal notranslate"><span class="pre">-verify</span></code>
mode.  Instead of formatting and printing out the diagnostics, this
implementation just captures and remembers the diagnostics as they fly by.
Then <code class="docutils literal notranslate"><span class="pre">-verify</span></code> compares the list of produced diagnostics to the list of
expected ones.  If they disagree, it prints out its own output.  Full
documentation for the <code class="docutils literal notranslate"><span class="pre">-verify</span></code> mode can be found in the Clang API
documentation for <a class="reference external" href="/doxygen/classclang_1_1VerifyDiagnosticConsumer.html#details">VerifyDiagnosticConsumer</a>.</p>
<p>There are many other possible implementations of this interface, and this is
why we prefer diagnostics to pass down rich structured information in
arguments.  For example, an HTML output might want declaration names be
linkified to where they come from in the source.  Another example is that a GUI
might let you click on typedefs to expand them.  This application would want to
pass significantly more information about types through to the GUI than a
simple flat string.  The interface allows this to happen.</p>
</div>
<div class="section" id="adding-translations-to-clang">
<span id="internals-diag-translation"></span><h4><a class="toc-backref" href="#id14">Adding Translations to Clang</a><a class="headerlink" href="#adding-translations-to-clang" title="Permalink to this headline">¶</a></h4>
<p>Not possible yet! Diagnostic strings should be written in UTF-8, the client can
translate to the relevant code page if needed.  Each translation completely
replaces the format string for the diagnostic.</p>
</div>
</div>
<div class="section" id="the-sourcelocation-and-sourcemanager-classes">
<span id="sourcemanager"></span><span id="sourcelocation"></span><h3><a class="toc-backref" href="#id15">The <code class="docutils literal notranslate"><span class="pre">SourceLocation</span></code> and <code class="docutils literal notranslate"><span class="pre">SourceManager</span></code> classes</a><a class="headerlink" href="#the-sourcelocation-and-sourcemanager-classes" title="Permalink to this headline">¶</a></h3>
<p>Strangely enough, the <code class="docutils literal notranslate"><span class="pre">SourceLocation</span></code> class represents a location within the
source code of the program.  Important design points include:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sizeof(SourceLocation)</span></code> must be extremely small, as these are embedded
into many AST nodes and are passed around often.  Currently it is 32 bits.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SourceLocation</span></code> must be a simple value object that can be efficiently
copied.</p></li>
<li><p>We should be able to represent a source location for any byte of any input
file.  This includes in the middle of tokens, in whitespace, in trigraphs,
etc.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">SourceLocation</span></code> must encode the current <code class="docutils literal notranslate"><span class="pre">#include</span></code> stack that was
active when the location was processed.  For example, if the location
corresponds to a token, it should contain the set of <code class="docutils literal notranslate"><span class="pre">#include</span></code>s active
when the token was lexed.  This allows us to print the <code class="docutils literal notranslate"><span class="pre">#include</span></code> stack
for a diagnostic.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SourceLocation</span></code> must be able to describe macro expansions, capturing both
the ultimate instantiation point and the source of the original character
data.</p></li>
</ol>
<p>In practice, the <code class="docutils literal notranslate"><span class="pre">SourceLocation</span></code> works together with the <code class="docutils literal notranslate"><span class="pre">SourceManager</span></code>
class to encode two pieces of information about a location: its spelling
location and its expansion location.  For most tokens, these will be the
same.  However, for a macro expansion (or tokens that came from a <code class="docutils literal notranslate"><span class="pre">_Pragma</span></code>
directive) these will describe the location of the characters corresponding to
the token and the location where the token was used (i.e., the macro
expansion point or the location of the <code class="docutils literal notranslate"><span class="pre">_Pragma</span></code> itself).</p>
<p>The Clang front-end inherently depends on the location of a token being tracked
correctly.  If it is ever incorrect, the front-end may get confused and die.
The reason for this is that the notion of the “spelling” of a <code class="docutils literal notranslate"><span class="pre">Token</span></code> in
Clang depends on being able to find the original input characters for the
token.  This concept maps directly to the “spelling location” for the token.</p>
</div>
<div class="section" id="sourcerange-and-charsourcerange">
<h3><a class="toc-backref" href="#id16"><code class="docutils literal notranslate"><span class="pre">SourceRange</span></code> and <code class="docutils literal notranslate"><span class="pre">CharSourceRange</span></code></a><a class="headerlink" href="#sourcerange-and-charsourcerange" title="Permalink to this headline">¶</a></h3>
<p>Clang represents most source ranges by [first, last], where “first” and “last”
each point to the beginning of their respective tokens.  For example consider
the <code class="docutils literal notranslate"><span class="pre">SourceRange</span></code> of the following statement:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>x = foo + bar;
^first    ^last
</pre></div>
</div>
<p>To map from this representation to a character-based representation, the “last”
location needs to be adjusted to point to (or past) the end of that token with
either <code class="docutils literal notranslate"><span class="pre">Lexer::MeasureTokenLength()</span></code> or <code class="docutils literal notranslate"><span class="pre">Lexer::getLocForEndOfToken()</span></code>.  For
the rare cases where character-level source ranges information is needed we use
the <code class="docutils literal notranslate"><span class="pre">CharSourceRange</span></code> class.</p>
</div>
</div>
<div class="section" id="the-driver-library">
<h2><a class="toc-backref" href="#id17">The Driver Library</a><a class="headerlink" href="#the-driver-library" title="Permalink to this headline">¶</a></h2>
<p>The clang Driver and library are documented <a class="reference internal" href="DriverInternals.html"><span class="doc">here</span></a>.</p>
</div>
<div class="section" id="precompiled-headers">
<h2><a class="toc-backref" href="#id18">Precompiled Headers</a><a class="headerlink" href="#precompiled-headers" title="Permalink to this headline">¶</a></h2>
<p>Clang supports precompiled headers (<a class="reference internal" href="PCHInternals.html"><span class="doc">PCH</span></a>), which  uses a
serialized representation of Clang’s internal data structures, encoded with the
<a class="reference external" href="https://llvm.org/docs/BitCodeFormat.html">LLVM bitstream format</a>.</p>
</div>
<div class="section" id="the-frontend-library">
<h2><a class="toc-backref" href="#id19">The Frontend Library</a><a class="headerlink" href="#the-frontend-library" title="Permalink to this headline">¶</a></h2>
<p>The Frontend library contains functionality useful for building tools on top of
the Clang libraries, for example several methods for outputting diagnostics.</p>
<div class="section" id="compiler-invocation">
<h3><a class="toc-backref" href="#id20">Compiler Invocation</a><a class="headerlink" href="#compiler-invocation" title="Permalink to this headline">¶</a></h3>
<p>One of the classes provided by the Frontend library is <code class="docutils literal notranslate"><span class="pre">CompilerInvocation</span></code>,
which holds information that describe current invocation of the Clang <code class="docutils literal notranslate"><span class="pre">-cc1</span></code>
frontend. The information typically comes from the command line constructed by
the Clang driver or from clients performing custom initialization. The data
structure is split into logical units used by different parts of the compiler,
for example <code class="docutils literal notranslate"><span class="pre">PreprocessorOptions</span></code>, <code class="docutils literal notranslate"><span class="pre">LanguageOptions</span></code> or <code class="docutils literal notranslate"><span class="pre">CodeGenOptions</span></code>.</p>
</div>
<div class="section" id="command-line-interface">
<h3><a class="toc-backref" href="#id21">Command Line Interface</a><a class="headerlink" href="#command-line-interface" title="Permalink to this headline">¶</a></h3>
<p>The command line interface of the Clang <code class="docutils literal notranslate"><span class="pre">-cc1</span></code> frontend is defined alongside
the driver options in <code class="docutils literal notranslate"><span class="pre">clang/Driver/Options.td</span></code>. The information making up an
option definition includes its prefix and name (for example <code class="docutils literal notranslate"><span class="pre">-std=</span></code>), form and
position of the option value, help text, aliases and more. Each option may
belong to a certain group and can be marked with zero or more flags. Options
accepted by the <code class="docutils literal notranslate"><span class="pre">-cc1</span></code> frontend are marked with the <code class="docutils literal notranslate"><span class="pre">CC1Option</span></code> flag.</p>
</div>
<div class="section" id="command-line-parsing">
<h3><a class="toc-backref" href="#id22">Command Line Parsing</a><a class="headerlink" href="#command-line-parsing" title="Permalink to this headline">¶</a></h3>
<p>Option definitions are processed by the <code class="docutils literal notranslate"><span class="pre">-gen-opt-parser-defs</span></code> tablegen
backend during early stages of the build. Options are then used for querying an
instance <code class="docutils literal notranslate"><span class="pre">llvm::opt::ArgList</span></code>, a wrapper around the command line arguments.
This is done in the Clang driver to construct individual jobs based on the
driver arguments and also in the <code class="docutils literal notranslate"><span class="pre">CompilerInvocation::CreateFromArgs</span></code> function
that parses the <code class="docutils literal notranslate"><span class="pre">-cc1</span></code> frontend arguments.</p>
</div>
<div class="section" id="command-line-generation">
<h3><a class="toc-backref" href="#id23">Command Line Generation</a><a class="headerlink" href="#command-line-generation" title="Permalink to this headline">¶</a></h3>
<p>Any valid <code class="docutils literal notranslate"><span class="pre">CompilerInvocation</span></code> created from a <code class="docutils literal notranslate"><span class="pre">-cc1</span></code> command line  can be
also serialized back into semantically equivalent command line in a
deterministic manner. This enables features such as implicitly discovered,
explicitly built modules.</p>
</div>
<div class="section" id="adding-new-command-line-option">
<h3><a class="toc-backref" href="#id24">Adding new Command Line Option</a><a class="headerlink" href="#adding-new-command-line-option" title="Permalink to this headline">¶</a></h3>
<p>When adding a new command line option, the first place of interest is the header
file declaring the corresponding options class (e.g. <code class="docutils literal notranslate"><span class="pre">CodeGenOptions.h</span></code> for
command line option that affects the code generation). Create new member
variable for the option value:</p>
<div class="highlight-diff notranslate"><div class="highlight"><pre><span></span>  class CodeGenOptions : public CodeGenOptionsBase {

<span class="gi">+   /// List of dynamic shared object files to be loaded as pass plugins.</span>
<span class="gi">+   std::vector&lt;std::string&gt; PassPlugins;</span>

  }
</pre></div>
</div>
<p>Next, declare the command line interface of the option in the tablegen file
<code class="docutils literal notranslate"><span class="pre">clang/include/clang/Driver/Options.td</span></code>. This is done by instantiating the
<code class="docutils literal notranslate"><span class="pre">Option</span></code> class (defined in <code class="docutils literal notranslate"><span class="pre">llvm/include/llvm/Option/OptParser.td</span></code>). The
instance is typically created through one of the helper classes that encode the
acceptable ways to specify the option value on the command line:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Flag</span></code> - the option does not accept any value,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Joined</span></code> - the value must immediately follow the option name within the same
argument,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Separate</span></code> - the value must follow the option name in the next command line
argument,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">JoinedOrSeparate</span></code> - the value can be specified either as <code class="docutils literal notranslate"><span class="pre">Joined</span></code> or
<code class="docutils literal notranslate"><span class="pre">Separate</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CommaJoined</span></code> - the values are comma-separated and must immediately follow
the option name within the same argument (see <code class="docutils literal notranslate"><span class="pre">Wl,</span></code> for an example).</p></li>
</ul>
<p>The helper classes take a list of acceptable prefixes of the option (e.g.
<code class="docutils literal notranslate"><span class="pre">&quot;-&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;--&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;/&quot;</span></code>) and the option name:</p>
<div class="highlight-diff notranslate"><div class="highlight"><pre><span></span>  // Options.td

<span class="gi">+ def fpass_plugin_EQ : Joined&lt;[&quot;-&quot;], &quot;fpass-plugin=&quot;&gt;;</span>
</pre></div>
</div>
<p>Then, specify additional attributes via mix-ins:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">HelpText</span></code> holds the text that will be printed besides the option name when
the user requests help (e.g. via <code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">--help</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Group</span></code> specifies the “category” of options this option belongs to. This is
used by various tools to filter certain options of interest.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Flags</span></code> may contain a number of “tags” associated with the option. This
enables more granular filtering than the <code class="docutils literal notranslate"><span class="pre">Group</span></code> attribute.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Alias</span></code> denotes that the option is an alias of another option. This may be
combined with <code class="docutils literal notranslate"><span class="pre">AliasArgs</span></code> that holds the implied value.</p></li>
</ul>
<div class="highlight-diff notranslate"><div class="highlight"><pre><span></span>  // Options.td

  def fpass_plugin_EQ : Joined&lt;[&quot;-&quot;], &quot;fpass-plugin=&quot;&gt;,
<span class="gi">+   Group&lt;f_Group&gt;, Flags&lt;[CC1Option]&gt;,</span>
<span class="gi">+   HelpText&lt;&quot;Load pass plugin from a dynamic shared object file.&quot;&gt;;</span>
</pre></div>
</div>
<p>New options are recognized by the Clang driver unless marked with the
<code class="docutils literal notranslate"><span class="pre">NoDriverOption</span></code> flag. On the other hand, options intended for the <code class="docutils literal notranslate"><span class="pre">-cc1</span></code>
frontend must be explicitly marked with the <code class="docutils literal notranslate"><span class="pre">CC1Option</span></code> flag.</p>
<p>Next, parse (or manufacture) the command line arguments in the Clang driver and
use them to construct the <code class="docutils literal notranslate"><span class="pre">-cc1</span></code> job:</p>
<div class="highlight-diff notranslate"><div class="highlight"><pre><span></span>  void Clang::ConstructJob(const ArgList &amp;Args /*...*/) const {
    ArgStringList CmdArgs;
    // ...

<span class="gi">+   for (const Arg *A : Args.filtered(OPT_fpass_plugin_EQ)) {</span>
<span class="gi">+     CmdArgs.push_back(Args.MakeArgString(Twine(&quot;-fpass-plugin=&quot;) + A-&gt;getValue()));</span>
<span class="gi">+     A-&gt;claim();</span>
<span class="gi">+   }</span>
  }
</pre></div>
</div>
<p>The last step is implementing the <code class="docutils literal notranslate"><span class="pre">-cc1</span></code> command line argument
parsing/generation that initializes/serializes the option class (in our case
<code class="docutils literal notranslate"><span class="pre">CodeGenOptions</span></code>) stored within <code class="docutils literal notranslate"><span class="pre">CompilerInvocation</span></code>. This can be done
automatically by using the marshalling annotations on the option definition:</p>
<div class="highlight-diff notranslate"><div class="highlight"><pre><span></span>  // Options.td

  def fpass_plugin_EQ : Joined&lt;[&quot;-&quot;], &quot;fpass-plugin=&quot;&gt;,
    Group&lt;f_Group&gt;, Flags&lt;[CC1Option]&gt;,
    HelpText&lt;&quot;Load pass plugin from a dynamic shared object file.&quot;&gt;,
<span class="gi">+   MarshallingInfoStringVector&lt;CodeGenOpts&lt;&quot;PassPlugins&quot;&gt;&gt;;</span>
</pre></div>
</div>
<p>Inner workings of the system are introduced in the <a class="reference internal" href="#optionmarshalling"><span class="std std-ref">marshalling
infrastructure</span></a> section and the available annotations are
listed <a class="reference internal" href="#optionmarshallingannotations"><span class="std std-ref">here</span></a>.</p>
<p>In case the marshalling infrastructure does not support the desired semantics,
consider simplifying it to fit the existing model. This makes the command line
more uniform and reduces the amount of custom, manually written code. Remember
that the <code class="docutils literal notranslate"><span class="pre">-cc1</span></code> command line interface is intended only for Clang developers,
meaning it does not need to mirror the driver interface, maintain backward
compatibility or be compatible with GCC.</p>
<p>If the option semantics cannot be encoded via marshalling annotations, you can
resort to parsing/serializing the command line arguments manually:</p>
<div class="highlight-diff notranslate"><div class="highlight"><pre><span></span>  // CompilerInvocation.cpp

  static bool ParseCodeGenArgs(CodeGenOptions &amp;Opts, ArgList &amp;Args /*...*/) {
    // ...

<span class="gi">+   Opts.PassPlugins = Args.getAllArgValues(OPT_fpass_plugin_EQ);</span>
  }

  static void GenerateCodeGenArgs(const CodeGenOptions &amp;Opts,
                                  SmallVectorImpl&lt;const char *&gt; &amp;Args,
                                  CompilerInvocation::StringAllocator SA /*...*/) {
    // ...

<span class="gi">+   for (const std::string &amp;PassPlugin : Opts.PassPlugins)</span>
<span class="gi">+     GenerateArg(Args, OPT_fpass_plugin_EQ, PassPlugin, SA);</span>
  }
</pre></div>
</div>
<p>Finally, you can specify the argument on the command line:
<code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">-fpass-plugin=a</span> <span class="pre">-fpass-plugin=b</span></code> and use the new member variable as
desired.</p>
<div class="highlight-diff notranslate"><div class="highlight"><pre><span></span>  void EmitAssemblyHelper::EmitAssemblyWithNewPassManager(/*...*/) {
    // ...
<span class="gi">+   for (auto &amp;PluginFN : CodeGenOpts.PassPlugins)</span>
<span class="gi">+     if (auto PassPlugin = PassPlugin::Load(PluginFN))</span>
<span class="gi">+        PassPlugin-&gt;registerPassBuilderCallbacks(PB);</span>
  }
</pre></div>
</div>
</div>
<div class="section" id="option-marshalling-infrastructure">
<span id="optionmarshalling"></span><h3><a class="toc-backref" href="#id25">Option Marshalling Infrastructure</a><a class="headerlink" href="#option-marshalling-infrastructure" title="Permalink to this headline">¶</a></h3>
<p>The option marshalling infrastructure automates the parsing of the Clang
<code class="docutils literal notranslate"><span class="pre">-cc1</span></code> frontend command line arguments into <code class="docutils literal notranslate"><span class="pre">CompilerInvocation</span></code> and their
generation from <code class="docutils literal notranslate"><span class="pre">CompilerInvocation</span></code>. The system replaces lots of repetitive
C++ code with simple, declarative tablegen annotations and it’s being used for
the majority of the <code class="docutils literal notranslate"><span class="pre">-cc1</span></code> command line interface. This section provides an
overview of the system.</p>
<p><strong>Note:</strong> The marshalling infrastructure is not intended for driver-only
options. Only options of the <code class="docutils literal notranslate"><span class="pre">-cc1</span></code> frontend need to be marshalled to/from
<code class="docutils literal notranslate"><span class="pre">CompilerInvocation</span></code> instance.</p>
<p>To read and modify contents of <code class="docutils literal notranslate"><span class="pre">CompilerInvocation</span></code>, the marshalling system
uses key paths, which are declared in two steps. First, a tablegen definition
for the <code class="docutils literal notranslate"><span class="pre">CompilerInvocation</span></code> member is created by inheriting from
<code class="docutils literal notranslate"><span class="pre">KeyPathAndMacro</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>// Options.td

class LangOpts&lt;string field&gt; : KeyPathAndMacro&lt;&quot;LangOpts-&gt;&quot;, field, &quot;LANG_&quot;&gt; {}
//                   CompilerInvocation member  ^^^^^^^^^^
//                                    OPTION_WITH_MARSHALLING prefix ^^^^^
</pre></div>
</div>
<p>The first argument to the parent class is the beginning of the key path that
references the <code class="docutils literal notranslate"><span class="pre">CompilerInvocation</span></code> member. This argument ends with <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> if
the member is a pointer type or with <code class="docutils literal notranslate"><span class="pre">.</span></code> if it’s a value type. The child class
takes a single parameter <code class="docutils literal notranslate"><span class="pre">field</span></code> that is forwarded as the second argument to
the base class. The child class can then be used like so:
<code class="docutils literal notranslate"><span class="pre">LangOpts&lt;&quot;IgnoreExceptions&quot;&gt;</span></code>, constructing a key path to the field
<code class="docutils literal notranslate"><span class="pre">LangOpts-&gt;IgnoreExceptions</span></code>. The third argument passed to the parent class is
a string that the tablegen backend uses as a prefix to the
<code class="docutils literal notranslate"><span class="pre">OPTION_WITH_MARSHALLING</span></code> macro. Using the key path as a mix-in on an
<code class="docutils literal notranslate"><span class="pre">Option</span></code> instance instructs the backend to generate the following code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Options.inc</span>

<span class="cp">#ifdef LANG_OPTION_WITH_MARSHALLING</span>
<span class="n">LANG_OPTION_WITH_MARSHALLING</span><span class="p">([...],</span><span class="w"> </span><span class="n">LangOpts</span><span class="o">-&gt;</span><span class="n">IgnoreExceptions</span><span class="p">,</span><span class="w"> </span><span class="p">[...])</span><span class="w"></span>
<span class="cp">#endif </span><span class="c1">// LANG_OPTION_WITH_MARSHALLING</span>
</pre></div>
</div>
<p>Such definition can be used used in the function for parsing and generating
command line:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// clang/lib/Frontend/CompilerInvoation.cpp</span>

<span class="kt">bool</span><span class="w"> </span><span class="nf">CompilerInvocation::ParseLangArgs</span><span class="p">(</span><span class="n">LangOptions</span><span class="w"> </span><span class="o">*</span><span class="n">LangOpts</span><span class="p">,</span><span class="w"> </span><span class="n">ArgList</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Args</span><span class="p">,</span><span class="w"></span>
<span class="w">                                       </span><span class="n">DiagnosticsEngine</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Diags</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">Success</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>

<span class="cp">#define LANG_OPTION_WITH_MARSHALLING(                                          \</span>
<span class="cp">    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \</span>
<span class="cp">    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \</span>
<span class="cp">    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \</span>
<span class="cp">    MERGER, EXTRACTOR, TABLE_INDEX)                                            \</span>
<span class="cp">  PARSE_OPTION_WITH_MARSHALLING(Args, Diags, Success, ID, FLAGS, PARAM,        \</span>
<span class="cp">                                SHOULD_PARSE, KEYPATH, DEFAULT_VALUE,          \</span>
<span class="cp">                                IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER,      \</span>
<span class="cp">                                MERGER, TABLE_INDEX)</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;clang/Driver/Options.inc&quot;</span><span class="cp"></span>
<span class="cp">#undef LANG_OPTION_WITH_MARSHALLING</span>

<span class="w">  </span><span class="c1">// ...</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Success</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">CompilerInvocation::GenerateLangArgs</span><span class="p">(</span><span class="n">LangOptions</span><span class="w"> </span><span class="o">*</span><span class="n">LangOpts</span><span class="p">,</span><span class="w"></span>
<span class="w">                                          </span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Args</span><span class="p">,</span><span class="w"></span>
<span class="w">                                          </span><span class="n">StringAllocator</span><span class="w"> </span><span class="n">SA</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="cp">#define LANG_OPTION_WITH_MARSHALLING(                                          \</span>
<span class="cp">    PREFIX_TYPE, NAME, ID, KIND, GROUP, ALIAS, ALIASARGS, FLAGS, PARAM,        \</span>
<span class="cp">    HELPTEXT, METAVAR, VALUES, SPELLING, SHOULD_PARSE, ALWAYS_EMIT, KEYPATH,   \</span>
<span class="cp">    DEFAULT_VALUE, IMPLIED_CHECK, IMPLIED_VALUE, NORMALIZER, DENORMALIZER,     \</span>
<span class="cp">    MERGER, EXTRACTOR, TABLE_INDEX)                                            \</span>
<span class="cp">  GENERATE_OPTION_WITH_MARSHALLING(                                            \</span>
<span class="cp">      Args, SA, KIND, FLAGS, SPELLING, ALWAYS_EMIT, KEYPATH, DEFAULT_VALUE,    \</span>
<span class="cp">      IMPLIED_CHECK, IMPLIED_VALUE, DENORMALIZER, EXTRACTOR, TABLE_INDEX)</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;clang/Driver/Options.inc&quot;</span><span class="cp"></span>
<span class="cp">#undef LANG_OPTION_WITH_MARSHALLING</span>

<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">PARSE_OPTION_WITH_MARSHALLING</span></code> and <code class="docutils literal notranslate"><span class="pre">GENERATE_OPTION_WITH_MARSHALLING</span></code>
macros are defined in <code class="docutils literal notranslate"><span class="pre">CompilerInvocation.cpp</span></code> and they implement the generic
algorithm for parsing and generating command line arguments.</p>
</div>
<div class="section" id="option-marshalling-annotations">
<span id="optionmarshallingannotations"></span><h3><a class="toc-backref" href="#id26">Option Marshalling Annotations</a><a class="headerlink" href="#option-marshalling-annotations" title="Permalink to this headline">¶</a></h3>
<p>How does the tablegen backend know what to put in place of <code class="docutils literal notranslate"><span class="pre">[...]</span></code> in the
generated <code class="docutils literal notranslate"><span class="pre">Options.inc</span></code>? This is specified by the <code class="docutils literal notranslate"><span class="pre">Marshalling</span></code> utilities
described below. All of them take a key path argument and possibly other
information required for parsing or generating the command line argument.</p>
<p><strong>Note:</strong> The marshalling infrastructure is not intended for driver-only
options. Only options of the <code class="docutils literal notranslate"><span class="pre">-cc1</span></code> frontend need to be marshalled to/from
<code class="docutils literal notranslate"><span class="pre">CompilerInvocation</span></code> instance.</p>
<p><strong>Positive Flag</strong></p>
<p>The key path defaults to <code class="docutils literal notranslate"><span class="pre">false</span></code> and is set to <code class="docutils literal notranslate"><span class="pre">true</span></code> when the flag is
present on command line.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def fignore_exceptions : Flag&lt;[&quot;-&quot;], &quot;fignore-exceptions&quot;&gt;, Flags&lt;[CC1Option]&gt;,
  MarshallingInfoFlag&lt;LangOpts&lt;&quot;IgnoreExceptions&quot;&gt;&gt;;
</pre></div>
</div>
<p><strong>Negative Flag</strong></p>
<p>The key path defaults to <code class="docutils literal notranslate"><span class="pre">true</span></code> and is set to <code class="docutils literal notranslate"><span class="pre">false</span></code> when the flag is
present on command line.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def fno_verbose_asm : Flag&lt;[&quot;-&quot;], &quot;fno-verbose-asm&quot;&gt;, Flags&lt;[CC1Option]&gt;,
  MarshallingInfoNegativeFlag&lt;CodeGenOpts&lt;&quot;AsmVerbose&quot;&gt;&gt;;
</pre></div>
</div>
<p><strong>Negative and Positive Flag</strong></p>
<p>The key path defaults to the specified value (<code class="docutils literal notranslate"><span class="pre">false</span></code>, <code class="docutils literal notranslate"><span class="pre">true</span></code> or some
boolean value that’s statically unknown in the tablegen file). Then, the key
path is set to the value associated with the flag that appears last on command
line.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>defm legacy_pass_manager : BoolOption&lt;&quot;f&quot;, &quot;legacy-pass-manager&quot;,
  CodeGenOpts&lt;&quot;LegacyPassManager&quot;&gt;, DefaultFalse,
  PosFlag&lt;SetTrue, [], &quot;Use the legacy pass manager in LLVM&quot;&gt;,
  NegFlag&lt;SetFalse, [], &quot;Use the new pass manager in LLVM&quot;&gt;,
  BothFlags&lt;[CC1Option]&gt;&gt;;
</pre></div>
</div>
<p>With most such pair of flags, the <code class="docutils literal notranslate"><span class="pre">-cc1</span></code> frontend accepts only the flag that
changes the default key path value. The Clang driver is responsible for
accepting both and either forwarding the changing flag or discarding the flag
that would just set the key path to its default.</p>
<p>The first argument to <code class="docutils literal notranslate"><span class="pre">BoolOption</span></code> is a prefix that is used to construct the
full names of both flags. The positive flag would then be named
<code class="docutils literal notranslate"><span class="pre">flegacy-pass-manager</span></code> and the negative <code class="docutils literal notranslate"><span class="pre">fno-legacy-pass-manager</span></code>.
<code class="docutils literal notranslate"><span class="pre">BoolOption</span></code> also implies the <code class="docutils literal notranslate"><span class="pre">-</span></code> prefix for both flags. It’s also possible
to use <code class="docutils literal notranslate"><span class="pre">BoolFOption</span></code> that implies the <code class="docutils literal notranslate"><span class="pre">&quot;f&quot;</span></code> prefix and <code class="docutils literal notranslate"><span class="pre">Group&lt;f_Group&gt;</span></code>.
The <code class="docutils literal notranslate"><span class="pre">PosFlag</span></code> and <code class="docutils literal notranslate"><span class="pre">NegFlag</span></code> classes hold the associated boolean value, an
array of elements passed to the <code class="docutils literal notranslate"><span class="pre">Flag</span></code> class and the help text. The optional
<code class="docutils literal notranslate"><span class="pre">BothFlags</span></code> class holds an array of <code class="docutils literal notranslate"><span class="pre">Flag</span></code> elements that are common for both
the positive and negative flag and their common help text suffix.</p>
<p><strong>String</strong></p>
<p>The key path defaults to the specified string, or an empty one, if omitted. When
the option appears on the command line, the argument value is simply copied.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def isysroot : JoinedOrSeparate&lt;[&quot;-&quot;], &quot;isysroot&quot;&gt;, Flags&lt;[CC1Option]&gt;,
  MarshallingInfoString&lt;HeaderSearchOpts&lt;&quot;Sysroot&quot;&gt;, [{&quot;/&quot;}]&gt;;
</pre></div>
</div>
<p><strong>List of Strings</strong></p>
<p>The key path defaults to an empty <code class="docutils literal notranslate"><span class="pre">std::vector&lt;std::string&gt;</span></code>. Values specified
with each appearance of the option on the command line are appended to the
vector.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def frewrite_map_file : Separate&lt;[&quot;-&quot;], &quot;frewrite-map-file&quot;&gt;, Flags&lt;[CC1Option]&gt;,
  MarshallingInfoStringVector&lt;CodeGenOpts&lt;&quot;RewriteMapFiles&quot;&gt;&gt;;
</pre></div>
</div>
<p><strong>Integer</strong></p>
<p>The key path defaults to the specified integer value, or <code class="docutils literal notranslate"><span class="pre">0</span></code> if omitted. When
the option appears on the command line, its value gets parsed by <code class="docutils literal notranslate"><span class="pre">llvm::APInt</span></code>
and the result is assigned to the key path on success.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def mstack_probe_size : Joined&lt;[&quot;-&quot;], &quot;mstack-probe-size=&quot;&gt;, Flags&lt;[CC1Option]&gt;,
  MarshallingInfoInt&lt;CodeGenOpts&lt;&quot;StackProbeSize&quot;&gt;, &quot;4096&quot;&gt;;
</pre></div>
</div>
<p><strong>Enumeration</strong></p>
<p>The key path defaults to the value specified in <code class="docutils literal notranslate"><span class="pre">MarshallingInfoEnum</span></code> prefixed
by the contents of <code class="docutils literal notranslate"><span class="pre">NormalizedValuesScope</span></code> and <code class="docutils literal notranslate"><span class="pre">::</span></code>. This ensures correct
reference to an enum case is formed even if the enum resides in different
namespace or is an enum class. If the value present on command line does not
match any of the comma-separated values from <code class="docutils literal notranslate"><span class="pre">Values</span></code>, an error diagnostics is
issued. Otherwise, the corresponding element from <code class="docutils literal notranslate"><span class="pre">NormalizedValues</span></code> at the
same index is assigned to the key path (also correctly scoped). The number of
comma-separated string values and elements of the array within
<code class="docutils literal notranslate"><span class="pre">NormalizedValues</span></code> must match.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def mthread_model : Separate&lt;[&quot;-&quot;], &quot;mthread-model&quot;&gt;, Flags&lt;[CC1Option]&gt;,
  Values&lt;&quot;posix,single&quot;&gt;, NormalizedValues&lt;[&quot;POSIX&quot;, &quot;Single&quot;]&gt;,
  NormalizedValuesScope&lt;&quot;LangOptions::ThreadModelKind&quot;&gt;,
  MarshallingInfoEnum&lt;LangOpts&lt;&quot;ThreadModel&quot;&gt;, &quot;POSIX&quot;&gt;;
</pre></div>
</div>
<p>It is also possible to define relationships between options.</p>
<p><strong>Implication</strong></p>
<p>The key path defaults to the default value from the primary <code class="docutils literal notranslate"><span class="pre">Marshalling</span></code>
annotation. Then, if any of the elements of <code class="docutils literal notranslate"><span class="pre">ImpliedByAnyOf</span></code> evaluate to true,
the key path value is changed to the specified value or <code class="docutils literal notranslate"><span class="pre">true</span></code> if missing.
Finally, the command line is parsed according to the primary annotation.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def fms_extensions : Flag&lt;[&quot;-&quot;], &quot;fms-extensions&quot;&gt;, Flags&lt;[CC1Option]&gt;,
  MarshallingInfoFlag&lt;LangOpts&lt;&quot;MicrosoftExt&quot;&gt;&gt;,
  ImpliedByAnyOf&lt;[fms_compatibility.KeyPath], &quot;true&quot;&gt;;
</pre></div>
</div>
<p><strong>Condition</strong></p>
<p>The option is parsed only if the expression in <code class="docutils literal notranslate"><span class="pre">ShouldParseIf</span></code> evaluates to
true.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def fopenmp_enable_irbuilder : Flag&lt;[&quot;-&quot;], &quot;fopenmp-enable-irbuilder&quot;&gt;, Flags&lt;[CC1Option]&gt;,
  MarshallingInfoFlag&lt;LangOpts&lt;&quot;OpenMPIRBuilder&quot;&gt;&gt;,
  ShouldParseIf&lt;fopenmp.KeyPath&gt;;
</pre></div>
</div>
</div>
</div>
<div class="section" id="the-lexer-and-preprocessor-library">
<h2><a class="toc-backref" href="#id27">The Lexer and Preprocessor Library</a><a class="headerlink" href="#the-lexer-and-preprocessor-library" title="Permalink to this headline">¶</a></h2>
<p>The Lexer library contains several tightly-connected classes that are involved
with the nasty process of lexing and preprocessing C source code.  The main
interface to this library for outside clients is the large <code class="docutils literal notranslate"><span class="pre">Preprocessor</span></code>
class.  It contains the various pieces of state that are required to coherently
read tokens out of a translation unit.</p>
<p>The core interface to the <code class="docutils literal notranslate"><span class="pre">Preprocessor</span></code> object (once it is set up) is the
<code class="docutils literal notranslate"><span class="pre">Preprocessor::Lex</span></code> method, which returns the next <a class="reference internal" href="#token"><span class="std std-ref">Token</span></a> from
the preprocessor stream.  There are two types of token providers that the
preprocessor is capable of reading from: a buffer lexer (provided by the
<a class="reference internal" href="#lexer"><span class="std std-ref">Lexer</span></a> class) and a buffered token stream (provided by the
<a class="reference internal" href="#tokenlexer"><span class="std std-ref">TokenLexer</span></a> class).</p>
<div class="section" id="the-token-class">
<span id="token"></span><h3><a class="toc-backref" href="#id28">The Token class</a><a class="headerlink" href="#the-token-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">Token</span></code> class is used to represent a single lexed token.  Tokens are
intended to be used by the lexer/preprocess and parser libraries, but are not
intended to live beyond them (for example, they should not live in the ASTs).</p>
<p>Tokens most often live on the stack (or some other location that is efficient
to access) as the parser is running, but occasionally do get buffered up.  For
example, macro definitions are stored as a series of tokens, and the C++
front-end periodically needs to buffer tokens up for tentative parsing and
various pieces of look-ahead.  As such, the size of a <code class="docutils literal notranslate"><span class="pre">Token</span></code> matters.  On a
32-bit system, <code class="docutils literal notranslate"><span class="pre">sizeof(Token)</span></code> is currently 16 bytes.</p>
<p>Tokens occur in two forms: <a class="reference internal" href="#annotationtoken"><span class="std std-ref">annotation tokens</span></a> and
normal tokens.  Normal tokens are those returned by the lexer, annotation
tokens represent semantic information and are produced by the parser, replacing
normal tokens in the token stream.  Normal tokens contain the following
information:</p>
<ul class="simple">
<li><p><strong>A SourceLocation</strong> — This indicates the location of the start of the
token.</p></li>
<li><p><strong>A length</strong> — This stores the length of the token as stored in the
<code class="docutils literal notranslate"><span class="pre">SourceBuffer</span></code>.  For tokens that include them, this length includes
trigraphs and escaped newlines which are ignored by later phases of the
compiler.  By pointing into the original source buffer, it is always possible
to get the original spelling of a token completely accurately.</p></li>
<li><p><strong>IdentifierInfo</strong> — If a token takes the form of an identifier, and if
identifier lookup was enabled when the token was lexed (e.g., the lexer was
not reading in “raw” mode) this contains a pointer to the unique hash value
for the identifier.  Because the lookup happens before keyword
identification, this field is set even for language keywords like “<code class="docutils literal notranslate"><span class="pre">for</span></code>”.</p></li>
<li><p><strong>TokenKind</strong> — This indicates the kind of token as classified by the
lexer.  This includes things like <code class="docutils literal notranslate"><span class="pre">tok::starequal</span></code> (for the “<code class="docutils literal notranslate"><span class="pre">*=</span></code>”
operator), <code class="docutils literal notranslate"><span class="pre">tok::ampamp</span></code> for the “<code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>” token, and keyword values (e.g.,
<code class="docutils literal notranslate"><span class="pre">tok::kw_for</span></code>) for identifiers that correspond to keywords.  Note that
some tokens can be spelled multiple ways.  For example, C++ supports
“operator keywords”, where things like “<code class="docutils literal notranslate"><span class="pre">and</span></code>” are treated exactly like the
“<code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>” operator.  In these cases, the kind value is set to <code class="docutils literal notranslate"><span class="pre">tok::ampamp</span></code>,
which is good for the parser, which doesn’t have to consider both forms.  For
something that cares about which form is used (e.g., the preprocessor
“stringize” operator) the spelling indicates the original form.</p></li>
<li><p><strong>Flags</strong> — There are currently four flags tracked by the
lexer/preprocessor system on a per-token basis:</p>
<ol class="arabic simple">
<li><p><strong>StartOfLine</strong> — This was the first token that occurred on its input
source line.</p></li>
<li><p><strong>LeadingSpace</strong> — There was a space character either immediately before
the token or transitively before the token as it was expanded through a
macro.  The definition of this flag is very closely defined by the
stringizing requirements of the preprocessor.</p></li>
<li><p><strong>DisableExpand</strong> — This flag is used internally to the preprocessor to
represent identifier tokens which have macro expansion disabled.  This
prevents them from being considered as candidates for macro expansion ever
in the future.</p></li>
<li><p><strong>NeedsCleaning</strong> — This flag is set if the original spelling for the
token includes a trigraph or escaped newline.  Since this is uncommon,
many pieces of code can fast-path on tokens that did not need cleaning.</p></li>
</ol>
</li>
</ul>
<p>One interesting (and somewhat unusual) aspect of normal tokens is that they
don’t contain any semantic information about the lexed value.  For example, if
the token was a pp-number token, we do not represent the value of the number
that was lexed (this is left for later pieces of code to decide).
Additionally, the lexer library has no notion of typedef names vs variable
names: both are returned as identifiers, and the parser is left to decide
whether a specific identifier is a typedef or a variable (tracking this
requires scope information among other things).  The parser can do this
translation by replacing tokens returned by the preprocessor with “Annotation
Tokens”.</p>
</div>
<div class="section" id="annotation-tokens">
<span id="annotationtoken"></span><h3><a class="toc-backref" href="#id29">Annotation Tokens</a><a class="headerlink" href="#annotation-tokens" title="Permalink to this headline">¶</a></h3>
<p>Annotation tokens are tokens that are synthesized by the parser and injected
into the preprocessor’s token stream (replacing existing tokens) to record
semantic information found by the parser.  For example, if “<code class="docutils literal notranslate"><span class="pre">foo</span></code>” is found
to be a typedef, the “<code class="docutils literal notranslate"><span class="pre">foo</span></code>” <code class="docutils literal notranslate"><span class="pre">tok::identifier</span></code> token is replaced with an
<code class="docutils literal notranslate"><span class="pre">tok::annot_typename</span></code>.  This is useful for a couple of reasons: 1) this makes
it easy to handle qualified type names (e.g., “<code class="docutils literal notranslate"><span class="pre">foo::bar::baz&lt;42&gt;::t</span></code>”) in
C++ as a single “token” in the parser.  2) if the parser backtracks, the
reparse does not need to redo semantic analysis to determine whether a token
sequence is a variable, type, template, etc.</p>
<p>Annotation tokens are created by the parser and reinjected into the parser’s
token stream (when backtracking is enabled).  Because they can only exist in
tokens that the preprocessor-proper is done with, it doesn’t need to keep
around flags like “start of line” that the preprocessor uses to do its job.
Additionally, an annotation token may “cover” a sequence of preprocessor tokens
(e.g., “<code class="docutils literal notranslate"><span class="pre">a::b::c</span></code>” is five preprocessor tokens).  As such, the valid fields
of an annotation token are different than the fields for a normal token (but
they are multiplexed into the normal <code class="docutils literal notranslate"><span class="pre">Token</span></code> fields):</p>
<ul class="simple">
<li><p><strong>SourceLocation “Location”</strong> — The <code class="docutils literal notranslate"><span class="pre">SourceLocation</span></code> for the annotation
token indicates the first token replaced by the annotation token.  In the
example above, it would be the location of the “<code class="docutils literal notranslate"><span class="pre">a</span></code>” identifier.</p></li>
<li><p><strong>SourceLocation “AnnotationEndLoc”</strong> — This holds the location of the last
token replaced with the annotation token.  In the example above, it would be
the location of the “<code class="docutils literal notranslate"><span class="pre">c</span></code>” identifier.</p></li>
<li><p><strong>void* “AnnotationValue”</strong> — This contains an opaque object that the
parser gets from <code class="docutils literal notranslate"><span class="pre">Sema</span></code>.  The parser merely preserves the information for
<code class="docutils literal notranslate"><span class="pre">Sema</span></code> to later interpret based on the annotation token kind.</p></li>
<li><p><strong>TokenKind “Kind”</strong> — This indicates the kind of Annotation token this is.
See below for the different valid kinds.</p></li>
</ul>
<p>Annotation tokens currently come in three kinds:</p>
<ol class="arabic simple">
<li><p><strong>tok::annot_typename</strong>: This annotation token represents a resolved
typename token that is potentially qualified.  The <code class="docutils literal notranslate"><span class="pre">AnnotationValue</span></code> field
contains the <code class="docutils literal notranslate"><span class="pre">QualType</span></code> returned by <code class="docutils literal notranslate"><span class="pre">Sema::getTypeName()</span></code>, possibly with
source location information attached.</p></li>
<li><p><strong>tok::annot_cxxscope</strong>: This annotation token represents a C++ scope
specifier, such as “<code class="docutils literal notranslate"><span class="pre">A::B::</span></code>”.  This corresponds to the grammar
productions “<em>::</em>” and “<em>:: [opt] nested-name-specifier</em>”.  The
<code class="docutils literal notranslate"><span class="pre">AnnotationValue</span></code> pointer is a <code class="docutils literal notranslate"><span class="pre">NestedNameSpecifier</span> <span class="pre">*</span></code> returned by the
<code class="docutils literal notranslate"><span class="pre">Sema::ActOnCXXGlobalScopeSpecifier</span></code> and
<code class="docutils literal notranslate"><span class="pre">Sema::ActOnCXXNestedNameSpecifier</span></code> callbacks.</p></li>
<li><p><strong>tok::annot_template_id</strong>: This annotation token represents a C++
template-id such as “<code class="docutils literal notranslate"><span class="pre">foo&lt;int,</span> <span class="pre">4&gt;</span></code>”, where “<code class="docutils literal notranslate"><span class="pre">foo</span></code>” is the name of a
template.  The <code class="docutils literal notranslate"><span class="pre">AnnotationValue</span></code> pointer is a pointer to a <code class="docutils literal notranslate"><span class="pre">malloc</span></code>’d
<code class="docutils literal notranslate"><span class="pre">TemplateIdAnnotation</span></code> object.  Depending on the context, a parsed
template-id that names a type might become a typename annotation token (if
all we care about is the named type, e.g., because it occurs in a type
specifier) or might remain a template-id token (if we want to retain more
source location information or produce a new type, e.g., in a declaration of
a class template specialization).  template-id annotation tokens that refer
to a type can be “upgraded” to typename annotation tokens by the parser.</p></li>
</ol>
<p>As mentioned above, annotation tokens are not returned by the preprocessor,
they are formed on demand by the parser.  This means that the parser has to be
aware of cases where an annotation could occur and form it where appropriate.
This is somewhat similar to how the parser handles Translation Phase 6 of C99:
String Concatenation (see C99 5.1.1.2).  In the case of string concatenation,
the preprocessor just returns distinct <code class="docutils literal notranslate"><span class="pre">tok::string_literal</span></code> and
<code class="docutils literal notranslate"><span class="pre">tok::wide_string_literal</span></code> tokens and the parser eats a sequence of them
wherever the grammar indicates that a string literal can occur.</p>
<p>In order to do this, whenever the parser expects a <code class="docutils literal notranslate"><span class="pre">tok::identifier</span></code> or
<code class="docutils literal notranslate"><span class="pre">tok::coloncolon</span></code>, it should call the <code class="docutils literal notranslate"><span class="pre">TryAnnotateTypeOrScopeToken</span></code> or
<code class="docutils literal notranslate"><span class="pre">TryAnnotateCXXScopeToken</span></code> methods to form the annotation token.  These
methods will maximally form the specified annotation tokens and replace the
current token with them, if applicable.  If the current tokens is not valid for
an annotation token, it will remain an identifier or “<code class="docutils literal notranslate"><span class="pre">::</span></code>” token.</p>
</div>
<div class="section" id="the-lexer-class">
<span id="lexer"></span><h3><a class="toc-backref" href="#id30">The <code class="docutils literal notranslate"><span class="pre">Lexer</span></code> class</a><a class="headerlink" href="#the-lexer-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">Lexer</span></code> class provides the mechanics of lexing tokens out of a source
buffer and deciding what they mean.  The <code class="docutils literal notranslate"><span class="pre">Lexer</span></code> is complicated by the fact
that it operates on raw buffers that have not had spelling eliminated (this is
a necessity to get decent performance), but this is countered with careful
coding as well as standard performance techniques (for example, the comment
handling code is vectorized on X86 and PowerPC hosts).</p>
<p>The lexer has a couple of interesting modal features:</p>
<ul class="simple">
<li><p>The lexer can operate in “raw” mode.  This mode has several features that
make it possible to quickly lex the file (e.g., it stops identifier lookup,
doesn’t specially handle preprocessor tokens, handles EOF differently, etc).
This mode is used for lexing within an “<code class="docutils literal notranslate"><span class="pre">#if</span> <span class="pre">0</span></code>” block, for example.</p></li>
<li><p>The lexer can capture and return comments as tokens.  This is required to
support the <code class="docutils literal notranslate"><span class="pre">-C</span></code> preprocessor mode, which passes comments through, and is
used by the diagnostic checker to identifier expect-error annotations.</p></li>
<li><p>The lexer can be in <code class="docutils literal notranslate"><span class="pre">ParsingFilename</span></code> mode, which happens when
preprocessing after reading a <code class="docutils literal notranslate"><span class="pre">#include</span></code> directive.  This mode changes the
parsing of “<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>” to return an “angled string” instead of a bunch of tokens
for each thing within the filename.</p></li>
<li><p>When parsing a preprocessor directive (after “<code class="docutils literal notranslate"><span class="pre">#</span></code>”) the
<code class="docutils literal notranslate"><span class="pre">ParsingPreprocessorDirective</span></code> mode is entered.  This changes the parser to
return EOD at a newline.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">Lexer</span></code> uses a <code class="docutils literal notranslate"><span class="pre">LangOptions</span></code> object to know whether trigraphs are
enabled, whether C++ or ObjC keywords are recognized, etc.</p></li>
</ul>
<p>In addition to these modes, the lexer keeps track of a couple of other features
that are local to a lexed buffer, which change as the buffer is lexed:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">Lexer</span></code> uses <code class="docutils literal notranslate"><span class="pre">BufferPtr</span></code> to keep track of the current character being
lexed.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">Lexer</span></code> uses <code class="docutils literal notranslate"><span class="pre">IsAtStartOfLine</span></code> to keep track of whether the next
lexed token will start with its “start of line” bit set.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">Lexer</span></code> keeps track of the current “<code class="docutils literal notranslate"><span class="pre">#if</span></code>” directives that are active
(which can be nested).</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">Lexer</span></code> keeps track of an <a class="reference internal" href="#multipleincludeopt"><span class="std std-ref">MultipleIncludeOpt</span></a> object, which is used to detect whether the buffer uses
the standard “<code class="docutils literal notranslate"><span class="pre">#ifndef</span> <span class="pre">XX</span></code> / <code class="docutils literal notranslate"><span class="pre">#define</span> <span class="pre">XX</span></code>” idiom to prevent multiple
inclusion.  If a buffer does, subsequent includes can be ignored if the
“<code class="docutils literal notranslate"><span class="pre">XX</span></code>” macro is defined.</p></li>
</ul>
</div>
<div class="section" id="the-tokenlexer-class">
<span id="tokenlexer"></span><h3><a class="toc-backref" href="#id31">The <code class="docutils literal notranslate"><span class="pre">TokenLexer</span></code> class</a><a class="headerlink" href="#the-tokenlexer-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">TokenLexer</span></code> class is a token provider that returns tokens from a list of
tokens that came from somewhere else.  It typically used for two things: 1)
returning tokens from a macro definition as it is being expanded 2) returning
tokens from an arbitrary buffer of tokens.  The later use is used by
<code class="docutils literal notranslate"><span class="pre">_Pragma</span></code> and will most likely be used to handle unbounded look-ahead for the
C++ parser.</p>
</div>
<div class="section" id="the-multipleincludeopt-class">
<span id="multipleincludeopt"></span><h3><a class="toc-backref" href="#id32">The <code class="docutils literal notranslate"><span class="pre">MultipleIncludeOpt</span></code> class</a><a class="headerlink" href="#the-multipleincludeopt-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">MultipleIncludeOpt</span></code> class implements a really simple little state
machine that is used to detect the standard “<code class="docutils literal notranslate"><span class="pre">#ifndef</span> <span class="pre">XX</span></code> / <code class="docutils literal notranslate"><span class="pre">#define</span> <span class="pre">XX</span></code>”
idiom that people typically use to prevent multiple inclusion of headers.  If a
buffer uses this idiom and is subsequently <code class="docutils literal notranslate"><span class="pre">#include</span></code>’d, the preprocessor can
simply check to see whether the guarding condition is defined or not.  If so,
the preprocessor can completely ignore the include of the header.</p>
</div>
</div>
<div class="section" id="the-parser-library">
<span id="parser"></span><h2><a class="toc-backref" href="#id33">The Parser Library</a><a class="headerlink" href="#the-parser-library" title="Permalink to this headline">¶</a></h2>
<p>This library contains a recursive-descent parser that polls tokens from the
preprocessor and notifies a client of the parsing progress.</p>
<p>Historically, the parser used to talk to an abstract <code class="docutils literal notranslate"><span class="pre">Action</span></code> interface that
had virtual methods for parse events, for example <code class="docutils literal notranslate"><span class="pre">ActOnBinOp()</span></code>.  When Clang
grew C++ support, the parser stopped supporting general <code class="docutils literal notranslate"><span class="pre">Action</span></code> clients –
it now always talks to the <a class="reference internal" href="#sema"><span class="std std-ref">Sema library</span></a>.  However, the Parser
still accesses AST objects only through opaque types like <code class="docutils literal notranslate"><span class="pre">ExprResult</span></code> and
<code class="docutils literal notranslate"><span class="pre">StmtResult</span></code>.  Only <a class="reference internal" href="#sema"><span class="std std-ref">Sema</span></a> looks at the AST node contents of these
wrappers.</p>
</div>
<div class="section" id="the-ast-library">
<span id="ast"></span><h2><a class="toc-backref" href="#id34">The AST Library</a><a class="headerlink" href="#the-ast-library" title="Permalink to this headline">¶</a></h2>
<div class="section" id="design-philosophy">
<span id="astphilosophy"></span><h3><a class="toc-backref" href="#id35">Design philosophy</a><a class="headerlink" href="#design-philosophy" title="Permalink to this headline">¶</a></h3>
<div class="section" id="immutability">
<h4><a class="toc-backref" href="#id36">Immutability</a><a class="headerlink" href="#immutability" title="Permalink to this headline">¶</a></h4>
<p>Clang AST nodes (types, declarations, statements, expressions, and so on) are
generally designed to be immutable once created. This provides a number of key
benefits:</p>
<blockquote>
<div><ul class="simple">
<li><p>Canonicalization of the “meaning” of nodes is possible as soon as the nodes
are created, and is not invalidated by later addition of more information.
For example, we <a class="reference internal" href="#canonicaltype"><span class="std std-ref">canonicalize types</span></a>, and use a
canonicalized representation of expressions when determining whether two
function template declarations involving dependent expressions declare the
same entity.</p></li>
<li><p>AST nodes can be reused when they have the same meaning. For example, we
reuse <code class="docutils literal notranslate"><span class="pre">Type</span></code> nodes when representing the same type (but maintain separate
<code class="docutils literal notranslate"><span class="pre">TypeLoc</span></code>s for each instance where a type is written), and we reuse
non-dependent <code class="docutils literal notranslate"><span class="pre">Stmt</span></code> and <code class="docutils literal notranslate"><span class="pre">Expr</span></code> nodes across instantiations of a
template.</p></li>
<li><p>Serialization and deserialization of the AST to/from AST files is simpler:
we do not need to track modifications made to AST nodes imported from AST
files and serialize separate “update records”.</p></li>
</ul>
</div></blockquote>
<p>There are unfortunately exceptions to this general approach, such as:</p>
<blockquote>
<div><ul class="simple">
<li><p>The first declaration of a redeclarable entity maintains a pointer to the
most recent declaration of that entity, which naturally needs to change as
more declarations are parsed.</p></li>
<li><p>Name lookup tables in declaration contexts change after the namespace
declaration is formed.</p></li>
<li><p>We attempt to maintain only a single declaration for an instantiation of a
template, rather than having distinct declarations for an instantiation of
the declaration versus the definition, so template instantiation often
updates parts of existing declarations.</p></li>
<li><p>Some parts of declarations are required to be instantiated separately (this
includes default arguments and exception specifications), and such
instantiations update the existing declaration.</p></li>
</ul>
</div></blockquote>
<p>These cases tend to be fragile; mutable AST state should be avoided where
possible.</p>
<p>As a consequence of this design principle, we typically do not provide setters
for AST state. (Some are provided for short-term modifications intended to be
used immediately after an AST node is created and before it’s “published” as
part of the complete AST, or where language semantics require after-the-fact
updates.)</p>
</div>
<div class="section" id="faithfulness">
<h4><a class="toc-backref" href="#id37">Faithfulness</a><a class="headerlink" href="#faithfulness" title="Permalink to this headline">¶</a></h4>
<p>The AST intends to provide a representation of the program that is faithful to
the original source. We intend for it to be possible to write refactoring tools
using only information stored in, or easily reconstructible from, the Clang AST.
This means that the AST representation should either not desugar source-level
constructs to simpler forms, or – where made necessary by language semantics
or a clear engineering tradeoff – should desugar minimally and wrap the result
in a construct representing the original source form.</p>
<p>For example, <code class="docutils literal notranslate"><span class="pre">CXXForRangeStmt</span></code> directly represents the syntactic form of a
range-based for statement, but also holds a semantic representation of the
range declaration and iterator declarations. It does not contain a
fully-desugared <code class="docutils literal notranslate"><span class="pre">ForStmt</span></code>, however.</p>
<p>Some AST nodes (for example, <code class="docutils literal notranslate"><span class="pre">ParenExpr</span></code>) represent only syntax, and others
(for example, <code class="docutils literal notranslate"><span class="pre">ImplicitCastExpr</span></code>) represent only semantics, but most nodes
will represent a combination of syntax and associated semantics. Inheritance
is typically used when representing different (but related) syntaxes for nodes
with the same or similar semantics.</p>
</div>
</div>
<div class="section" id="the-type-class-and-its-subclasses">
<span id="type"></span><h3><a class="toc-backref" href="#id38">The <code class="docutils literal notranslate"><span class="pre">Type</span></code> class and its subclasses</a><a class="headerlink" href="#the-type-class-and-its-subclasses" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">Type</span></code> class (and its subclasses) are an important part of the AST.
Types are accessed through the <code class="docutils literal notranslate"><span class="pre">ASTContext</span></code> class, which implicitly creates
and uniques them as they are needed.  Types have a couple of non-obvious
features: 1) they do not capture type qualifiers like <code class="docutils literal notranslate"><span class="pre">const</span></code> or <code class="docutils literal notranslate"><span class="pre">volatile</span></code>
(see <a class="reference internal" href="#qualtype"><span class="std std-ref">QualType</span></a>), and 2) they implicitly capture typedef
information.  Once created, types are immutable (unlike decls).</p>
<p>Typedefs in C make semantic analysis a bit more complex than it would be without
them.  The issue is that we want to capture typedef information and represent it
in the AST perfectly, but the semantics of operations need to “see through”
typedefs.  For example, consider this code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">foo</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">Y</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">*</span><span class="n">bar</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">bar</span><span class="w"> </span><span class="n">Z</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">X</span><span class="p">;</span><span class="w"> </span><span class="c1">// error</span>
<span class="w">  </span><span class="o">**</span><span class="n">Y</span><span class="p">;</span><span class="w"> </span><span class="c1">// error</span>
<span class="w">  </span><span class="o">**</span><span class="n">Z</span><span class="p">;</span><span class="w"> </span><span class="c1">// error</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The code above is illegal, and thus we expect there to be diagnostics emitted
on the annotated lines.  In this example, we expect to get:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>test.c:6:1: error: indirection requires pointer operand (&#39;foo&#39; invalid)
  *X; // error
  ^~
test.c:7:1: error: indirection requires pointer operand (&#39;foo&#39; invalid)
  **Y; // error
  ^~~
test.c:8:1: error: indirection requires pointer operand (&#39;foo&#39; invalid)
  **Z; // error
  ^~~
</pre></div>
</div>
<p>While this example is somewhat silly, it illustrates the point: we want to
retain typedef information where possible, so that we can emit errors about
“<code class="docutils literal notranslate"><span class="pre">std::string</span></code>” instead of “<code class="docutils literal notranslate"><span class="pre">std::basic_string&lt;char,</span> <span class="pre">std:...</span></code>”.  Doing this
requires properly keeping typedef information (for example, the type of <code class="docutils literal notranslate"><span class="pre">X</span></code>
is “<code class="docutils literal notranslate"><span class="pre">foo</span></code>”, not “<code class="docutils literal notranslate"><span class="pre">int</span></code>”), and requires properly propagating it through the
various operators (for example, the type of <code class="docutils literal notranslate"><span class="pre">*Y</span></code> is “<code class="docutils literal notranslate"><span class="pre">foo</span></code>”, not
“<code class="docutils literal notranslate"><span class="pre">int</span></code>”).  In order to retain this information, the type of these expressions
is an instance of the <code class="docutils literal notranslate"><span class="pre">TypedefType</span></code> class, which indicates that the type of
these expressions is a typedef for “<code class="docutils literal notranslate"><span class="pre">foo</span></code>”.</p>
<p>Representing types like this is great for diagnostics, because the
user-specified type is always immediately available.  There are two problems
with this: first, various semantic checks need to make judgements about the
<em>actual structure</em> of a type, ignoring typedefs.  Second, we need an efficient
way to query whether two types are structurally identical to each other,
ignoring typedefs.  The solution to both of these problems is the idea of
canonical types.</p>
<div class="section" id="canonical-types">
<span id="canonicaltype"></span><h4><a class="toc-backref" href="#id39">Canonical Types</a><a class="headerlink" href="#canonical-types" title="Permalink to this headline">¶</a></h4>
<p>Every instance of the <code class="docutils literal notranslate"><span class="pre">Type</span></code> class contains a canonical type pointer.  For
simple types with no typedefs involved (e.g., “<code class="docutils literal notranslate"><span class="pre">int</span></code>”, “<code class="docutils literal notranslate"><span class="pre">int*</span></code>”,
“<code class="docutils literal notranslate"><span class="pre">int**</span></code>”), the type just points to itself.  For types that have a typedef
somewhere in their structure (e.g., “<code class="docutils literal notranslate"><span class="pre">foo</span></code>”, “<code class="docutils literal notranslate"><span class="pre">foo*</span></code>”, “<code class="docutils literal notranslate"><span class="pre">foo**</span></code>”,
“<code class="docutils literal notranslate"><span class="pre">bar</span></code>”), the canonical type pointer points to their structurally equivalent
type without any typedefs (e.g., “<code class="docutils literal notranslate"><span class="pre">int</span></code>”, “<code class="docutils literal notranslate"><span class="pre">int*</span></code>”, “<code class="docutils literal notranslate"><span class="pre">int**</span></code>”, and
“<code class="docutils literal notranslate"><span class="pre">int*</span></code>” respectively).</p>
<p>This design provides a constant time operation (dereferencing the canonical type
pointer) that gives us access to the structure of types.  For example, we can
trivially tell that “<code class="docutils literal notranslate"><span class="pre">bar</span></code>” and “<code class="docutils literal notranslate"><span class="pre">foo*</span></code>” are the same type by dereferencing
their canonical type pointers and doing a pointer comparison (they both point
to the single “<code class="docutils literal notranslate"><span class="pre">int*</span></code>” type).</p>
<p>Canonical types and typedef types bring up some complexities that must be
carefully managed.  Specifically, the <code class="docutils literal notranslate"><span class="pre">isa</span></code>/<code class="docutils literal notranslate"><span class="pre">cast</span></code>/<code class="docutils literal notranslate"><span class="pre">dyn_cast</span></code> operators
generally shouldn’t be used in code that is inspecting the AST.  For example,
when type checking the indirection operator (unary “<code class="docutils literal notranslate"><span class="pre">*</span></code>” on a pointer), the
type checker must verify that the operand has a pointer type.  It would not be
correct to check that with “<code class="docutils literal notranslate"><span class="pre">isa&lt;PointerType&gt;(SubExpr-&gt;getType())</span></code>”, because
this predicate would fail if the subexpression had a typedef type.</p>
<p>The solution to this problem are a set of helper methods on <code class="docutils literal notranslate"><span class="pre">Type</span></code>, used to
check their properties.  In this case, it would be correct to use
“<code class="docutils literal notranslate"><span class="pre">SubExpr-&gt;getType()-&gt;isPointerType()</span></code>” to do the check.  This predicate will
return true if the <em>canonical type is a pointer</em>, which is true any time the
type is structurally a pointer type.  The only hard part here is remembering
not to use the <code class="docutils literal notranslate"><span class="pre">isa</span></code>/<code class="docutils literal notranslate"><span class="pre">cast</span></code>/<code class="docutils literal notranslate"><span class="pre">dyn_cast</span></code> operations.</p>
<p>The second problem we face is how to get access to the pointer type once we
know it exists.  To continue the example, the result type of the indirection
operator is the pointee type of the subexpression.  In order to determine the
type, we need to get the instance of <code class="docutils literal notranslate"><span class="pre">PointerType</span></code> that best captures the
typedef information in the program.  If the type of the expression is literally
a <code class="docutils literal notranslate"><span class="pre">PointerType</span></code>, we can return that, otherwise we have to dig through the
typedefs to find the pointer type.  For example, if the subexpression had type
“<code class="docutils literal notranslate"><span class="pre">foo*</span></code>”, we could return that type as the result.  If the subexpression had
type “<code class="docutils literal notranslate"><span class="pre">bar</span></code>”, we want to return “<code class="docutils literal notranslate"><span class="pre">foo*</span></code>” (note that we do <em>not</em> want
“<code class="docutils literal notranslate"><span class="pre">int*</span></code>”).  In order to provide all of this, <code class="docutils literal notranslate"><span class="pre">Type</span></code> has a
<code class="docutils literal notranslate"><span class="pre">getAsPointerType()</span></code> method that checks whether the type is structurally a
<code class="docutils literal notranslate"><span class="pre">PointerType</span></code> and, if so, returns the best one.  If not, it returns a null
pointer.</p>
<p>This structure is somewhat mystical, but after meditating on it, it will make
sense to you :).</p>
</div>
</div>
<div class="section" id="the-qualtype-class">
<span id="qualtype"></span><h3><a class="toc-backref" href="#id40">The <code class="docutils literal notranslate"><span class="pre">QualType</span></code> class</a><a class="headerlink" href="#the-qualtype-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">QualType</span></code> class is designed as a trivial value class that is small,
passed by-value and is efficient to query.  The idea of <code class="docutils literal notranslate"><span class="pre">QualType</span></code> is that it
stores the type qualifiers (<code class="docutils literal notranslate"><span class="pre">const</span></code>, <code class="docutils literal notranslate"><span class="pre">volatile</span></code>, <code class="docutils literal notranslate"><span class="pre">restrict</span></code>, plus some
extended qualifiers required by language extensions) separately from the types
themselves.  <code class="docutils literal notranslate"><span class="pre">QualType</span></code> is conceptually a pair of “<code class="docutils literal notranslate"><span class="pre">Type*</span></code>” and the bits
for these type qualifiers.</p>
<p>By storing the type qualifiers as bits in the conceptual pair, it is extremely
efficient to get the set of qualifiers on a <code class="docutils literal notranslate"><span class="pre">QualType</span></code> (just return the field
of the pair), add a type qualifier (which is a trivial constant-time operation
that sets a bit), and remove one or more type qualifiers (just return a
<code class="docutils literal notranslate"><span class="pre">QualType</span></code> with the bitfield set to empty).</p>
<p>Further, because the bits are stored outside of the type itself, we do not need
to create duplicates of types with different sets of qualifiers (i.e. there is
only a single heap allocated “<code class="docutils literal notranslate"><span class="pre">int</span></code>” type: “<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span></code>” and “<code class="docutils literal notranslate"><span class="pre">volatile</span>
<span class="pre">const</span> <span class="pre">int</span></code>” both point to the same heap allocated “<code class="docutils literal notranslate"><span class="pre">int</span></code>” type).  This
reduces the heap size used to represent bits and also means we do not have to
consider qualifiers when uniquing types (<a class="reference internal" href="#type"><span class="std std-ref">Type</span></a> does not even
contain qualifiers).</p>
<p>In practice, the two most common type qualifiers (<code class="docutils literal notranslate"><span class="pre">const</span></code> and <code class="docutils literal notranslate"><span class="pre">restrict</span></code>)
are stored in the low bits of the pointer to the <code class="docutils literal notranslate"><span class="pre">Type</span></code> object, together with
a flag indicating whether extended qualifiers are present (which must be
heap-allocated).  This means that <code class="docutils literal notranslate"><span class="pre">QualType</span></code> is exactly the same size as a
pointer.</p>
</div>
<div class="section" id="declaration-names">
<span id="declarationname"></span><h3><a class="toc-backref" href="#id41">Declaration names</a><a class="headerlink" href="#declaration-names" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">DeclarationName</span></code> class represents the name of a declaration in Clang.
Declarations in the C family of languages can take several different forms.
Most declarations are named by simple identifiers, e.g., “<code class="docutils literal notranslate"><span class="pre">f</span></code>” and “<code class="docutils literal notranslate"><span class="pre">x</span></code>” in
the function declaration <code class="docutils literal notranslate"><span class="pre">f(int</span> <span class="pre">x)</span></code>.  In C++, declaration names can also name
class constructors (“<code class="docutils literal notranslate"><span class="pre">Class</span></code>” in <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Class</span> <span class="pre">{</span> <span class="pre">Class();</span> <span class="pre">}</span></code>), class
destructors (“<code class="docutils literal notranslate"><span class="pre">~Class</span></code>”), overloaded operator names (“<code class="docutils literal notranslate"><span class="pre">operator+</span></code>”), and
conversion functions (“<code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">void</span> <span class="pre">const</span> <span class="pre">*</span></code>”).  In Objective-C,
declaration names can refer to the names of Objective-C methods, which involve
the method name and the parameters, collectively called a <em>selector</em>, e.g.,
“<code class="docutils literal notranslate"><span class="pre">setWidth:height:</span></code>”.  Since all of these kinds of entities — variables,
functions, Objective-C methods, C++ constructors, destructors, and operators
— are represented as subclasses of Clang’s common <code class="docutils literal notranslate"><span class="pre">NamedDecl</span></code> class,
<code class="docutils literal notranslate"><span class="pre">DeclarationName</span></code> is designed to efficiently represent any kind of name.</p>
<p>Given a <code class="docutils literal notranslate"><span class="pre">DeclarationName</span></code> <code class="docutils literal notranslate"><span class="pre">N</span></code>, <code class="docutils literal notranslate"><span class="pre">N.getNameKind()</span></code> will produce a value
that describes what kind of name <code class="docutils literal notranslate"><span class="pre">N</span></code> stores.  There are 10 options (all of
the names are inside the <code class="docutils literal notranslate"><span class="pre">DeclarationName</span></code> class).</p>
<p><code class="docutils literal notranslate"><span class="pre">Identifier</span></code></p>
<blockquote>
<div><p>The name is a simple identifier.  Use <code class="docutils literal notranslate"><span class="pre">N.getAsIdentifierInfo()</span></code> to retrieve
the corresponding <code class="docutils literal notranslate"><span class="pre">IdentifierInfo*</span></code> pointing to the actual identifier.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">ObjCZeroArgSelector</span></code>, <code class="docutils literal notranslate"><span class="pre">ObjCOneArgSelector</span></code>, <code class="docutils literal notranslate"><span class="pre">ObjCMultiArgSelector</span></code></p>
<blockquote>
<div><p>The name is an Objective-C selector, which can be retrieved as a <code class="docutils literal notranslate"><span class="pre">Selector</span></code>
instance via <code class="docutils literal notranslate"><span class="pre">N.getObjCSelector()</span></code>.  The three possible name kinds for
Objective-C reflect an optimization within the <code class="docutils literal notranslate"><span class="pre">DeclarationName</span></code> class:
both zero- and one-argument selectors are stored as a masked
<code class="docutils literal notranslate"><span class="pre">IdentifierInfo</span></code> pointer, and therefore require very little space, since
zero- and one-argument selectors are far more common than multi-argument
selectors (which use a different structure).</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">CXXConstructorName</span></code></p>
<blockquote>
<div><p>The name is a C++ constructor name.  Use <code class="docutils literal notranslate"><span class="pre">N.getCXXNameType()</span></code> to retrieve
the <a class="reference internal" href="#qualtype"><span class="std std-ref">type</span></a> that this constructor is meant to construct.  The
type is always the canonical type, since all constructors for a given type
have the same name.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">CXXDestructorName</span></code></p>
<blockquote>
<div><p>The name is a C++ destructor name.  Use <code class="docutils literal notranslate"><span class="pre">N.getCXXNameType()</span></code> to retrieve
the <a class="reference internal" href="#qualtype"><span class="std std-ref">type</span></a> whose destructor is being named.  This type is
always a canonical type.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">CXXConversionFunctionName</span></code></p>
<blockquote>
<div><p>The name is a C++ conversion function.  Conversion functions are named
according to the type they convert to, e.g., “<code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">void</span> <span class="pre">const</span> <span class="pre">*</span></code>”.
Use <code class="docutils literal notranslate"><span class="pre">N.getCXXNameType()</span></code> to retrieve the type that this conversion function
converts to.  This type is always a canonical type.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">CXXOperatorName</span></code></p>
<blockquote>
<div><p>The name is a C++ overloaded operator name.  Overloaded operators are named
according to their spelling, e.g., “<code class="docutils literal notranslate"><span class="pre">operator+</span></code>” or “<code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">new</span> <span class="pre">[]</span></code>”.
Use <code class="docutils literal notranslate"><span class="pre">N.getCXXOverloadedOperator()</span></code> to retrieve the overloaded operator (a
value of type <code class="docutils literal notranslate"><span class="pre">OverloadedOperatorKind</span></code>).</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">CXXLiteralOperatorName</span></code></p>
<blockquote>
<div><p>The name is a C++11 user defined literal operator.  User defined
Literal operators are named according to the suffix they define,
e.g., “<code class="docutils literal notranslate"><span class="pre">_foo</span></code>” for “<code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">&quot;&quot;</span> <span class="pre">_foo</span></code>”.  Use
<code class="docutils literal notranslate"><span class="pre">N.getCXXLiteralIdentifier()</span></code> to retrieve the corresponding
<code class="docutils literal notranslate"><span class="pre">IdentifierInfo*</span></code> pointing to the identifier.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">CXXUsingDirective</span></code></p>
<blockquote>
<div><p>The name is a C++ using directive.  Using directives are not really
NamedDecls, in that they all have the same name, but they are
implemented as such in order to store them in DeclContext
effectively.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">DeclarationName</span></code>s are cheap to create, copy, and compare.  They require
only a single pointer’s worth of storage in the common cases (identifiers,
zero- and one-argument Objective-C selectors) and use dense, uniqued storage
for the other kinds of names.  Two <code class="docutils literal notranslate"><span class="pre">DeclarationName</span></code>s can be compared for
equality (<code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>) using a simple bitwise comparison, can be ordered
with <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, and <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> (which provide a lexicographical ordering
for normal identifiers but an unspecified ordering for other kinds of names),
and can be placed into LLVM <code class="docutils literal notranslate"><span class="pre">DenseMap</span></code>s and <code class="docutils literal notranslate"><span class="pre">DenseSet</span></code>s.</p>
<p><code class="docutils literal notranslate"><span class="pre">DeclarationName</span></code> instances can be created in different ways depending on
what kind of name the instance will store.  Normal identifiers
(<code class="docutils literal notranslate"><span class="pre">IdentifierInfo</span></code> pointers) and Objective-C selectors (<code class="docutils literal notranslate"><span class="pre">Selector</span></code>) can be
implicitly converted to <code class="docutils literal notranslate"><span class="pre">DeclarationNames</span></code>.  Names for C++ constructors,
destructors, conversion functions, and overloaded operators can be retrieved
from the <code class="docutils literal notranslate"><span class="pre">DeclarationNameTable</span></code>, an instance of which is available as
<code class="docutils literal notranslate"><span class="pre">ASTContext::DeclarationNames</span></code>.  The member functions
<code class="docutils literal notranslate"><span class="pre">getCXXConstructorName</span></code>, <code class="docutils literal notranslate"><span class="pre">getCXXDestructorName</span></code>,
<code class="docutils literal notranslate"><span class="pre">getCXXConversionFunctionName</span></code>, and <code class="docutils literal notranslate"><span class="pre">getCXXOperatorName</span></code>, respectively,
return <code class="docutils literal notranslate"><span class="pre">DeclarationName</span></code> instances for the four kinds of C++ special function
names.</p>
</div>
<div class="section" id="declaration-contexts">
<span id="declcontext"></span><h3><a class="toc-backref" href="#id42">Declaration contexts</a><a class="headerlink" href="#declaration-contexts" title="Permalink to this headline">¶</a></h3>
<p>Every declaration in a program exists within some <em>declaration context</em>, such
as a translation unit, namespace, class, or function.  Declaration contexts in
Clang are represented by the <code class="docutils literal notranslate"><span class="pre">DeclContext</span></code> class, from which the various
declaration-context AST nodes (<code class="docutils literal notranslate"><span class="pre">TranslationUnitDecl</span></code>, <code class="docutils literal notranslate"><span class="pre">NamespaceDecl</span></code>,
<code class="docutils literal notranslate"><span class="pre">RecordDecl</span></code>, <code class="docutils literal notranslate"><span class="pre">FunctionDecl</span></code>, etc.) will derive.  The <code class="docutils literal notranslate"><span class="pre">DeclContext</span></code> class
provides several facilities common to each declaration context:</p>
<p>Source-centric vs. Semantics-centric View of Declarations</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">DeclContext</span></code> provides two views of the declarations stored within a
declaration context.  The source-centric view accurately represents the
program source code as written, including multiple declarations of entities
where present (see the section <a class="reference internal" href="#redeclarations"><span class="std std-ref">Redeclarations and Overloads</span></a>), while the semantics-centric view represents the program
semantics.  The two views are kept synchronized by semantic analysis while
the ASTs are being constructed.</p>
</div></blockquote>
<p>Storage of declarations within that context</p>
<blockquote>
<div><p>Every declaration context can contain some number of declarations.  For
example, a C++ class (represented by <code class="docutils literal notranslate"><span class="pre">RecordDecl</span></code>) contains various member
functions, fields, nested types, and so on.  All of these declarations will
be stored within the <code class="docutils literal notranslate"><span class="pre">DeclContext</span></code>, and one can iterate over the
declarations via [<code class="docutils literal notranslate"><span class="pre">DeclContext::decls_begin()</span></code>,
<code class="docutils literal notranslate"><span class="pre">DeclContext::decls_end()</span></code>).  This mechanism provides the source-centric
view of declarations in the context.</p>
</div></blockquote>
<p>Lookup of declarations within that context</p>
<blockquote>
<div><p>The <code class="docutils literal notranslate"><span class="pre">DeclContext</span></code> structure provides efficient name lookup for names within
that declaration context.  For example, if <code class="docutils literal notranslate"><span class="pre">N</span></code> is a namespace we can look
for the name <code class="docutils literal notranslate"><span class="pre">N::f</span></code> using <code class="docutils literal notranslate"><span class="pre">DeclContext::lookup</span></code>.  The lookup itself is
based on a lazily-constructed array (for declaration contexts with a small
number of declarations) or hash table (for declaration contexts with more
declarations).  The lookup operation provides the semantics-centric view of
the declarations in the context.</p>
</div></blockquote>
<p>Ownership of declarations</p>
<blockquote>
<div><p>The <code class="docutils literal notranslate"><span class="pre">DeclContext</span></code> owns all of the declarations that were declared within
its declaration context, and is responsible for the management of their
memory as well as their (de-)serialization.</p>
</div></blockquote>
<p>All declarations are stored within a declaration context, and one can query
information about the context in which each declaration lives.  One can
retrieve the <code class="docutils literal notranslate"><span class="pre">DeclContext</span></code> that contains a particular <code class="docutils literal notranslate"><span class="pre">Decl</span></code> using
<code class="docutils literal notranslate"><span class="pre">Decl::getDeclContext</span></code>.  However, see the section
<a class="reference internal" href="#lexicalandsemanticcontexts"><span class="std std-ref">Lexical and Semantic Contexts</span></a> for more information about how to interpret
this context information.</p>
<div class="section" id="redeclarations-and-overloads">
<span id="redeclarations"></span><h4><a class="toc-backref" href="#id43">Redeclarations and Overloads</a><a class="headerlink" href="#redeclarations-and-overloads" title="Permalink to this headline">¶</a></h4>
<p>Within a translation unit, it is common for an entity to be declared several
times.  For example, we might declare a function “<code class="docutils literal notranslate"><span class="pre">f</span></code>” and then later
re-declare it as part of an inlined definition:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ...  */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The representation of “<code class="docutils literal notranslate"><span class="pre">f</span></code>” differs in the source-centric and
semantics-centric views of a declaration context.  In the source-centric view,
all redeclarations will be present, in the order they occurred in the source
code, making this view suitable for clients that wish to see the structure of
the source code.  In the semantics-centric view, only the most recent “<code class="docutils literal notranslate"><span class="pre">f</span></code>”
will be found by the lookup, since it effectively replaces the first
declaration of “<code class="docutils literal notranslate"><span class="pre">f</span></code>”.</p>
<p>(Note that because <code class="docutils literal notranslate"><span class="pre">f</span></code> can be redeclared at block scope, or in a friend
declaration, etc. it is possible that the declaration of <code class="docutils literal notranslate"><span class="pre">f</span></code> found by name
lookup will not be the most recent one.)</p>
<p>In the semantics-centric view, overloading of functions is represented
explicitly.  For example, given two declarations of a function “<code class="docutils literal notranslate"><span class="pre">g</span></code>” that are
overloaded, e.g.,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">g</span><span class="p">();</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>the <code class="docutils literal notranslate"><span class="pre">DeclContext::lookup</span></code> operation will return a
<code class="docutils literal notranslate"><span class="pre">DeclContext::lookup_result</span></code> that contains a range of iterators over
declarations of “<code class="docutils literal notranslate"><span class="pre">g</span></code>”.  Clients that perform semantic analysis on a program
that is not concerned with the actual source code will primarily use this
semantics-centric view.</p>
</div>
<div class="section" id="lexical-and-semantic-contexts">
<span id="lexicalandsemanticcontexts"></span><h4><a class="toc-backref" href="#id44">Lexical and Semantic Contexts</a><a class="headerlink" href="#lexical-and-semantic-contexts" title="Permalink to this headline">¶</a></h4>
<p>Each declaration has two potentially different declaration contexts: a
<em>lexical</em> context, which corresponds to the source-centric view of the
declaration context, and a <em>semantic</em> context, which corresponds to the
semantics-centric view.  The lexical context is accessible via
<code class="docutils literal notranslate"><span class="pre">Decl::getLexicalDeclContext</span></code> while the semantic context is accessible via
<code class="docutils literal notranslate"><span class="pre">Decl::getDeclContext</span></code>, both of which return <code class="docutils literal notranslate"><span class="pre">DeclContext</span></code> pointers.  For
most declarations, the two contexts are identical.  For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">X</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Here, the semantic and lexical contexts of <code class="docutils literal notranslate"><span class="pre">X::f</span></code> are the <code class="docutils literal notranslate"><span class="pre">DeclContext</span></code>
associated with the class <code class="docutils literal notranslate"><span class="pre">X</span></code> (itself stored as a <code class="docutils literal notranslate"><span class="pre">RecordDecl</span></code> AST node).
However, we can now define <code class="docutils literal notranslate"><span class="pre">X::f</span></code> out-of-line:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">X::f</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">17</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ...  */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This definition of “<code class="docutils literal notranslate"><span class="pre">f</span></code>” has different lexical and semantic contexts.  The
lexical context corresponds to the declaration context in which the actual
declaration occurred in the source code, e.g., the translation unit containing
<code class="docutils literal notranslate"><span class="pre">X</span></code>.  Thus, this declaration of <code class="docutils literal notranslate"><span class="pre">X::f</span></code> can be found by traversing the
declarations provided by [<code class="docutils literal notranslate"><span class="pre">decls_begin()</span></code>, <code class="docutils literal notranslate"><span class="pre">decls_end()</span></code>) in the
translation unit.</p>
<p>The semantic context of <code class="docutils literal notranslate"><span class="pre">X::f</span></code> corresponds to the class <code class="docutils literal notranslate"><span class="pre">X</span></code>, since this
member function is (semantically) a member of <code class="docutils literal notranslate"><span class="pre">X</span></code>.  Lookup of the name <code class="docutils literal notranslate"><span class="pre">f</span></code>
into the <code class="docutils literal notranslate"><span class="pre">DeclContext</span></code> associated with <code class="docutils literal notranslate"><span class="pre">X</span></code> will then return the definition
of <code class="docutils literal notranslate"><span class="pre">X::f</span></code> (including information about the default argument).</p>
</div>
<div class="section" id="transparent-declaration-contexts">
<h4><a class="toc-backref" href="#id45">Transparent Declaration Contexts</a><a class="headerlink" href="#transparent-declaration-contexts" title="Permalink to this headline">¶</a></h4>
<p>In C and C++, there are several contexts in which names that are logically
declared inside another declaration will actually “leak” out into the enclosing
scope from the perspective of name lookup.  The most obvious instance of this
behavior is in enumeration types, e.g.,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="nc">Color</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Red</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">Green</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">Blue</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">Color</span></code> is an enumeration, which is a declaration context that contains
the enumerators <code class="docutils literal notranslate"><span class="pre">Red</span></code>, <code class="docutils literal notranslate"><span class="pre">Green</span></code>, and <code class="docutils literal notranslate"><span class="pre">Blue</span></code>.  Thus, traversing the list of
declarations contained in the enumeration <code class="docutils literal notranslate"><span class="pre">Color</span></code> will yield <code class="docutils literal notranslate"><span class="pre">Red</span></code>,
<code class="docutils literal notranslate"><span class="pre">Green</span></code>, and <code class="docutils literal notranslate"><span class="pre">Blue</span></code>.  However, outside of the scope of <code class="docutils literal notranslate"><span class="pre">Color</span></code> one can
name the enumerator <code class="docutils literal notranslate"><span class="pre">Red</span></code> without qualifying the name, e.g.,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Color</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Red</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>There are other entities in C++ that provide similar behavior.  For example,
linkage specifications that use curly braces:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// f and g are visible here</span>
</pre></div>
</div>
<p>For source-level accuracy, we treat the linkage specification and enumeration
type as a declaration context in which its enclosed declarations (“<code class="docutils literal notranslate"><span class="pre">Red</span></code>”,
“<code class="docutils literal notranslate"><span class="pre">Green</span></code>”, and “<code class="docutils literal notranslate"><span class="pre">Blue</span></code>”; “<code class="docutils literal notranslate"><span class="pre">f</span></code>” and “<code class="docutils literal notranslate"><span class="pre">g</span></code>”) are declared.  However, these
declarations are visible outside of the scope of the declaration context.</p>
<p>These language features (and several others, described below) have roughly the
same set of requirements: declarations are declared within a particular lexical
context, but the declarations are also found via name lookup in scopes
enclosing the declaration itself.  This feature is implemented via
<em>transparent</em> declaration contexts (see
<code class="docutils literal notranslate"><span class="pre">DeclContext::isTransparentContext()</span></code>), whose declarations are visible in the
nearest enclosing non-transparent declaration context.  This means that the
lexical context of the declaration (e.g., an enumerator) will be the
transparent <code class="docutils literal notranslate"><span class="pre">DeclContext</span></code> itself, as will the semantic context, but the
declaration will be visible in every outer context up to and including the
first non-transparent declaration context (since transparent declaration
contexts can be nested).</p>
<p>The transparent <code class="docutils literal notranslate"><span class="pre">DeclContext</span></code>s are:</p>
<ul>
<li><p>Enumerations (but not C++11 “scoped enumerations”):</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="nc">Color</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Red</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">Green</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">Blue</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="c1">// Red, Green, and Blue are in scope</span>
</pre></div>
</div>
</li>
<li><p>C++ linkage specifications:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// f and g are in scope</span>
</pre></div>
</div>
</li>
<li><p>Anonymous unions and structs:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">LookupTable</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsVector</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">union</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">Vector</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">Set</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">LookupTable</span><span class="w"> </span><span class="n">LT</span><span class="p">;</span><span class="w"></span>
<span class="n">LT</span><span class="p">.</span><span class="n">Vector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Okay: finds Vector inside the unnamed union</span>
</pre></div>
</div>
</li>
<li><p>C++11 inline namespaces:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">mylib</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kr">inline</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">debug</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">class</span> <span class="nc">X</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">mylib</span><span class="o">::</span><span class="n">X</span><span class="w"> </span><span class="o">*</span><span class="n">xp</span><span class="p">;</span><span class="w"> </span><span class="c1">// okay: mylib::X refers to mylib::debug::X</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="multiply-defined-declaration-contexts">
<span id="multideclcontext"></span><h4><a class="toc-backref" href="#id46">Multiply-Defined Declaration Contexts</a><a class="headerlink" href="#multiply-defined-declaration-contexts" title="Permalink to this headline">¶</a></h4>
<p>C++ namespaces have the interesting property that
the namespace can be defined multiple times, and the declarations provided by
each namespace definition are effectively merged (from the semantic point of
view).  For example, the following two code snippets are semantically
indistinguishable:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Snippet #1:</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">N</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">N</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Snippet #2:</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">N</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In Clang’s representation, the source-centric view of declaration contexts will
actually have two separate <code class="docutils literal notranslate"><span class="pre">NamespaceDecl</span></code> nodes in Snippet #1, each of which
is a declaration context that contains a single declaration of “<code class="docutils literal notranslate"><span class="pre">f</span></code>”.
However, the semantics-centric view provided by name lookup into the namespace
<code class="docutils literal notranslate"><span class="pre">N</span></code> for “<code class="docutils literal notranslate"><span class="pre">f</span></code>” will return a <code class="docutils literal notranslate"><span class="pre">DeclContext::lookup_result</span></code> that contains a
range of iterators over declarations of “<code class="docutils literal notranslate"><span class="pre">f</span></code>”.</p>
<p><code class="docutils literal notranslate"><span class="pre">DeclContext</span></code> manages multiply-defined declaration contexts internally.  The
function <code class="docutils literal notranslate"><span class="pre">DeclContext::getPrimaryContext</span></code> retrieves the “primary” context for
a given <code class="docutils literal notranslate"><span class="pre">DeclContext</span></code> instance, which is the <code class="docutils literal notranslate"><span class="pre">DeclContext</span></code> responsible for
maintaining the lookup table used for the semantics-centric view.  Given a
DeclContext, one can obtain the set of declaration contexts that are
semantically connected to this declaration context, in source order, including
this context (which will be the only result, for non-namespace contexts) via
<code class="docutils literal notranslate"><span class="pre">DeclContext::collectAllContexts</span></code>. Note that these functions are used
internally within the lookup and insertion methods of the <code class="docutils literal notranslate"><span class="pre">DeclContext</span></code>, so
the vast majority of clients can ignore them.</p>
<p>Because the same entity can be defined multiple times in different modules,
it is also possible for there to be multiple definitions of (for instance)
a <code class="docutils literal notranslate"><span class="pre">CXXRecordDecl</span></code>, all of which describe a definition of the same class.
In such a case, only one of those “definitions” is considered by Clang to be
the definition of the class, and the others are treated as non-defining
declarations that happen to also contain member declarations. Corresponding
members in each definition of such multiply-defined classes are identified
either by redeclaration chains (if the members are <code class="docutils literal notranslate"><span class="pre">Redeclarable</span></code>)
or by simply a pointer to the canonical declaration (if the declarations
are not <code class="docutils literal notranslate"><span class="pre">Redeclarable</span></code> – in that case, a <code class="docutils literal notranslate"><span class="pre">Mergeable</span></code> base class is used
instead).</p>
</div>
</div>
<div class="section" id="error-handling">
<h3><a class="toc-backref" href="#id47">Error Handling</a><a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h3>
<p>Clang produces an AST even when the code contains errors. Clang won’t generate
and optimize code for it, but it’s used as parsing continues to detect further
errors in the input. Clang-based tools also depend on such ASTs, and IDEs in
particular benefit from a high-quality AST for broken code.</p>
<p>In presence of errors, clang uses a few error-recovery strategies to present the
broken code in the AST:</p>
<ul class="simple">
<li><p>correcting errors: in cases where clang is confident about the fix, it
provides a FixIt attaching to the error diagnostic and emits a corrected AST
(reflecting the written code with FixIts applied). The advantage of that is to
provide more accurate subsequent diagnostics. Typo correction is a typical
example.</p></li>
<li><p>representing invalid node: the invalid node is preserved in the AST in some
form, e.g. when the “declaration” part of the declaration contains semantic
errors, the Decl node is marked as invalid.</p></li>
<li><p>dropping invalid node: this often happens for errors that we don’t have
graceful recovery. Prior to Recovery AST, a mismatched-argument function call
expression was dropped though a CallExpr was created for semantic analysis.</p></li>
</ul>
<p>With these strategies, clang surfaces better diagnostics, and provides AST
consumers a rich AST reflecting the written source code as much as possible even
for broken code.</p>
<div class="section" id="recovery-ast">
<h4><a class="toc-backref" href="#id48">Recovery AST</a><a class="headerlink" href="#recovery-ast" title="Permalink to this headline">¶</a></h4>
<p>The idea of Recovery AST is to use recovery nodes which act as a placeholder to
maintain the rough structure of the parsing tree, preserve locations and
children but have no language semantics attached to them.</p>
<p>For example, consider the following mismatched function call:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">NoArg</span><span class="p">();</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">test</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">NoArg</span><span class="p">(</span><span class="n">abc</span><span class="p">);</span><span class="w"> </span><span class="c1">// oops, mismatched function arguments.</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Without Recovery AST, the invalid function call expression (and its child
expressions) would be dropped in the AST:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>|-FunctionDecl &lt;line:1:1, col:11&gt; NoArg &#39;int ()&#39;
`-FunctionDecl &lt;line:2:1, line:4:1&gt; test &#39;void (int)&#39;
 |-ParmVarDecl &lt;col:11, col:15&gt; col:15 used abc &#39;int&#39;
 `-CompoundStmt &lt;col:20, line:4:1&gt;
</pre></div>
</div>
<p>With Recovery AST, the AST looks like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>|-FunctionDecl &lt;line:1:1, col:11&gt; NoArg &#39;int ()&#39;
`-FunctionDecl &lt;line:2:1, line:4:1&gt; test &#39;void (int)&#39;
  |-ParmVarDecl &lt;col:11, col:15&gt; used abc &#39;int&#39;
  `-CompoundStmt &lt;col:20, line:4:1&gt;
    `-RecoveryExpr &lt;line:3:3, col:12&gt; &#39;int&#39; contains-errors
      |-UnresolvedLookupExpr &lt;col:3&gt; &#39;&lt;overloaded function type&gt;&#39; lvalue (ADL) = &#39;NoArg&#39;
      `-DeclRefExpr &lt;col:9&gt; &#39;int&#39; lvalue ParmVar &#39;abc&#39; &#39;int&#39;
</pre></div>
</div>
<p>An alternative is to use existing Exprs, e.g. CallExpr for the above example.
This would capture more call details (e.g. locations of parentheses) and allow
it to be treated uniformly with valid CallExprs. However, jamming the data we
have into CallExpr forces us to weaken its invariants, e.g. arg count may be
wrong. This would introduce a huge burden on consumers of the AST to handle such
“impossible” cases. So when we’re representing (rather than correcting) errors,
we use a distinct recovery node type with extremely weak invariants instead.</p>
<p><code class="docutils literal notranslate"><span class="pre">RecoveryExpr</span></code> is the only recovery node so far. In practice, broken decls
need more detailed semantics preserved (the current <code class="docutils literal notranslate"><span class="pre">Invalid</span></code> flag works
fairly well), and completely broken statements with interesting internal
structure are rare (so dropping the statements is OK).</p>
</div>
<div class="section" id="types-and-dependence">
<h4><a class="toc-backref" href="#id49">Types and dependence</a><a class="headerlink" href="#types-and-dependence" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">RecoveryExpr</span></code> is an <code class="docutils literal notranslate"><span class="pre">Expr</span></code>, so it must have a type. In many cases the true
type can’t really be known until the code is corrected (e.g. a call to a
function that doesn’t exist). And it means that we can’t properly perform type
checks on some containing constructs, such as <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">42</span> <span class="pre">+</span> <span class="pre">unknownFunction()</span></code>.</p>
<p>To model this, we generalize the concept of dependence from C++ templates to
mean dependence on a template parameter or how an error is repaired. The
<code class="docutils literal notranslate"><span class="pre">RecoveryExpr</span></code> <code class="docutils literal notranslate"><span class="pre">unknownFunction()</span></code> has the totally unknown type
<code class="docutils literal notranslate"><span class="pre">DependentTy</span></code>, and this suppresses type-based analysis in the same way it
would inside a template.</p>
<p>In cases where we are confident about the concrete type (e.g. the return type
for a broken non-overloaded function call), the <code class="docutils literal notranslate"><span class="pre">RecoveryExpr</span></code> will have this
type. This allows more code to be typechecked, and produces a better AST and
more diagnostics. For example:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">unknownFunction</span><span class="p">().</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="c1">// .size() is a CXXDependentScopeMemberExpr</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="mi">42</span><span class="p">).</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="c1">// .size() is a resolved MemberExpr</span>
</pre></div>
</div>
<p>Whether or not the <code class="docutils literal notranslate"><span class="pre">RecoveryExpr</span></code> has a dependent type, it is always
considered value-dependent, because its value isn’t well-defined until the error
is resolved. Among other things, this means that clang doesn’t emit more errors
where a RecoveryExpr is used as a constant (e.g. array size), but also won’t try
to evaluate it.</p>
</div>
<div class="section" id="containserrors-bit">
<h4><a class="toc-backref" href="#id50">ContainsErrors bit</a><a class="headerlink" href="#containserrors-bit" title="Permalink to this headline">¶</a></h4>
<p>Beyond the template dependence bits, we add a new “ContainsErrors” bit to
express “Does this expression or anything within it contain errors” semantic,
this bit is always set for RecoveryExpr, and propagated to other related nodes.
This provides a fast way to query whether any (recursive) child of an expression
had an error, which is often used to improve diagnostics.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// C++</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">recoveryExpr</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="n">unknownFunction</span><span class="p">();</span><span class="w"> </span><span class="c1">// type-dependent, value-dependent, contains-errors</span>

<span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="mi">42</span><span class="p">).</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="c1">// value-dependent, contains-errors,</span>
<span class="w">                         </span><span class="c1">// not type-dependent, as we know the type is std::string</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// C</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">recoveryExpr</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">abc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">unknownVar</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">abc</span><span class="p">;</span><span class="w"> </span><span class="c1">// type-dependent, value-dependent, contains-errors</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="the-astimporter">
<h3><a class="toc-backref" href="#id51">The ASTImporter</a><a class="headerlink" href="#the-astimporter" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">ASTImporter</span></code> class imports nodes of an <code class="docutils literal notranslate"><span class="pre">ASTContext</span></code> into another
<code class="docutils literal notranslate"><span class="pre">ASTContext</span></code>. Please refer to the document <a class="reference internal" href="LibASTImporter.html"><span class="doc">ASTImporter: Merging Clang
ASTs</span></a> for an introduction. And please read through the
high-level <a class="reference external" href="LibASTImporter.html#algorithm-of-the-import">description of the import algorithm</a>, this is essential for
understanding further implementation details of the importer.</p>
<div class="section" id="abstract-syntax-graph">
<span id="templated"></span><h4><a class="toc-backref" href="#id52">Abstract Syntax Graph</a><a class="headerlink" href="#abstract-syntax-graph" title="Permalink to this headline">¶</a></h4>
<p>Despite the name, the Clang AST is not a tree. It is a directed graph with
cycles. One example of a cycle is the connection between a
<code class="docutils literal notranslate"><span class="pre">ClassTemplateDecl</span></code> and its “templated” <code class="docutils literal notranslate"><span class="pre">CXXRecordDecl</span></code>. The <em>templated</em>
<code class="docutils literal notranslate"><span class="pre">CXXRecordDecl</span></code> represents all the fields and methods inside the class
template, while the <code class="docutils literal notranslate"><span class="pre">ClassTemplateDecl</span></code> holds the information which is
related to being a template, i.e. template arguments, etc. We can get the
<em>templated</em> class (the <code class="docutils literal notranslate"><span class="pre">CXXRecordDecl</span></code>) of a <code class="docutils literal notranslate"><span class="pre">ClassTemplateDecl</span></code> with
<code class="docutils literal notranslate"><span class="pre">ClassTemplateDecl::getTemplatedDecl()</span></code>. And we can get back a pointer of the
“described” class template from the <em>templated</em> class:
<code class="docutils literal notranslate"><span class="pre">CXXRecordDecl::getDescribedTemplate()</span></code>. So, this is a cycle between two
nodes: between the <em>templated</em> and the <em>described</em> node. There may be various
other kinds of cycles in the AST especially in case of declarations.</p>
</div>
<div class="section" id="structural-equivalency">
<span id="structural-eq"></span><h4><a class="toc-backref" href="#id53">Structural Equivalency</a><a class="headerlink" href="#structural-equivalency" title="Permalink to this headline">¶</a></h4>
<p>Importing one AST node copies that node into the destination <code class="docutils literal notranslate"><span class="pre">ASTContext</span></code>. To
copy one node means that we create a new node in the “to” context then we set
its properties to be equal to the properties of the source node. Before the
copy, we make sure that the source node is not <em>structurally equivalent</em> to any
existing node in the destination context. If it happens to be equivalent then
we skip the copy.</p>
<p>The informal definition of structural equivalency is the following:
Two nodes are <strong>structurally equivalent</strong> if they are</p>
<ul class="simple">
<li><p>builtin types and refer to the same type, e.g. <code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">int</span></code> are
structurally equivalent,</p></li>
<li><p>function types and all their parameters have structurally equivalent types,</p></li>
<li><p>record types and all their fields in order of their definition have the same
identifier names and structurally equivalent types,</p></li>
<li><p>variable or function declarations and they have the same identifier name and
their types are structurally equivalent.</p></li>
</ul>
<p>In C, two types are structurally equivalent if they are <em>compatible types</em>. For
a formal definition of <em>compatible types</em>, please refer to 6.2.7/1 in the C11
standard. However, there is no definition for <em>compatible types</em> in the C++
standard. Still, we extend the definition of structural equivalency to
templates and their instantiations similarly: besides checking the previously
mentioned properties, we have to check for equivalent template
parameters/arguments, etc.</p>
<p>The structural equivalent check can be and is used independently from the
ASTImporter, e.g. the <code class="docutils literal notranslate"><span class="pre">clang::Sema</span></code> class uses it also.</p>
<p>The equivalence of nodes may depend on the equivalency of other pairs of nodes.
Thus, the check is implemented as a parallel graph traversal. We traverse
through the nodes of both graphs at the same time. The actual implementation is
similar to breadth-first-search. Let’s say we start the traverse with the &lt;A,B&gt;
pair of nodes. Whenever the traversal reaches a pair &lt;X,Y&gt; then the following
statements are true:</p>
<ul class="simple">
<li><p>A and X are nodes from the same ASTContext.</p></li>
<li><p>B and Y are nodes from the same ASTContext.</p></li>
<li><p>A and B may or may not be from the same ASTContext.</p></li>
<li><p>if A == X and B == Y (pointer equivalency) then (there is a cycle during the
traverse)</p>
<ul>
<li><p>A and B are structurally equivalent if and only if</p>
<ul>
<li><p>All dependent nodes on the path from &lt;A,B&gt; to &lt;X,Y&gt; are structurally
equivalent.</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>When we compare two classes or enums and one of them is incomplete or has
unloaded external lexical declarations then we cannot descend to compare their
contained declarations. So in these cases they are considered equal if they
have the same names. This is the way how we compare forward declarations with
definitions.</p>
</div>
<div class="section" id="redeclaration-chains">
<h4><a class="toc-backref" href="#id54">Redeclaration Chains</a><a class="headerlink" href="#redeclaration-chains" title="Permalink to this headline">¶</a></h4>
<p>The early version of the <code class="docutils literal notranslate"><span class="pre">ASTImporter</span></code>’s merge mechanism squashed the
declarations, i.e. it aimed to have only one declaration instead of maintaining
a whole redeclaration chain. This early approach simply skipped importing a
function prototype, but it imported a definition. To demonstrate the problem
with this approach let’s consider an empty “to” context and the following
<code class="docutils literal notranslate"><span class="pre">virtual</span></code> function declarations of <code class="docutils literal notranslate"><span class="pre">f</span></code> in the “from” context:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">B</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">();</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">B::f</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// &lt;-- let&#39;s import this definition</span>
</pre></div>
</div>
<p>If we imported the definition with the “squashing” approach then we would
end-up having one declaration which is indeed a definition, but <code class="docutils literal notranslate"><span class="pre">isVirtual()</span></code>
returns <code class="docutils literal notranslate"><span class="pre">false</span></code> for it. The reason is that the definition is indeed not
virtual, it is the property of the prototype!</p>
<p>Consequently, we must either set the virtual flag for the definition (but then
we create a malformed AST which the parser would never create), or we import
the whole redeclaration chain of the function. The most recent version of the
<code class="docutils literal notranslate"><span class="pre">ASTImporter</span></code> uses the latter mechanism. We do import all function
declarations - regardless if they are definitions or prototypes - in the order
as they appear in the “from” context.</p>
<p>If we have an existing definition in the “to” context, then we cannot import
another definition, we will use the existing definition. However, we can import
prototype(s): we chain the newly imported prototype(s) to the existing
definition. Whenever we import a new prototype from a third context, that will
be added to the end of the redeclaration chain. This may result in long
redeclaration chains in certain cases, e.g. if we import from several
translation units which include the same header with the prototype.</p>
<p>To mitigate the problem of long redeclaration chains of free functions, we
could compare prototypes to see if they have the same properties and if yes
then we could merge these prototypes. The implementation of squashing of
prototypes for free functions is future work.</p>
<p>Chaining functions this way ensures that we do copy all information from the
source AST. Nonetheless, there is a problem with member functions: While we can
have many prototypes for free functions, we must have only one prototype for a
member function.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">();</span><span class="w"> </span><span class="c1">// OK</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">();</span><span class="w"> </span><span class="c1">// OK</span>

<span class="k">struct</span> <span class="nc">X</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">();</span><span class="w"> </span><span class="c1">// OK</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">();</span><span class="w"> </span><span class="c1">// ERROR</span>
<span class="p">};</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">X::f</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// OK</span>
</pre></div>
</div>
<p>Thus, prototypes of member functions must be squashed, we cannot just simply
attach a new prototype to the existing in-class prototype. Consider the
following contexts:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// &quot;to&quot; context</span>
<span class="k">struct</span> <span class="nc">X</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">();</span><span class="w"> </span><span class="c1">// D0</span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// &quot;from&quot; context</span>
<span class="k">struct</span> <span class="nc">X</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">();</span><span class="w"> </span><span class="c1">// D1</span>
<span class="p">};</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">X::f</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// D2</span>
</pre></div>
</div>
<p>When we import the prototype and the definition of <code class="docutils literal notranslate"><span class="pre">f</span></code> from the “from”
context, then the resulting redecl chain will look like this <code class="docutils literal notranslate"><span class="pre">D0</span> <span class="pre">-&gt;</span> <span class="pre">D2'</span></code>,
where <code class="docutils literal notranslate"><span class="pre">D2'</span></code> is the copy of <code class="docutils literal notranslate"><span class="pre">D2</span></code> in the “to” context.</p>
<p>Generally speaking, when we import declarations (like enums and classes) we do
attach the newly imported declaration to the existing redeclaration chain (if
there is structural equivalency). We do not import, however, the whole
redeclaration chain as we do in case of functions. Up till now, we haven’t
found any essential property of forward declarations which is similar to the
case of the virtual flag in a member function prototype. In the future, this
may change, though.</p>
</div>
<div class="section" id="traversal-during-the-import">
<h4><a class="toc-backref" href="#id55">Traversal during the Import</a><a class="headerlink" href="#traversal-during-the-import" title="Permalink to this headline">¶</a></h4>
<p>The node specific import mechanisms are implemented in
<code class="docutils literal notranslate"><span class="pre">ASTNodeImporter::VisitNode()</span></code> functions, e.g. <code class="docutils literal notranslate"><span class="pre">VisitFunctionDecl()</span></code>.
When we import a declaration then first we import everything which is needed to
call the constructor of that declaration node. Everything which can be set
later is set after the node is created. For example, in case of  a
<code class="docutils literal notranslate"><span class="pre">FunctionDecl</span></code> we first import the declaration context in which the function
is declared, then we create the <code class="docutils literal notranslate"><span class="pre">FunctionDecl</span></code> and only then we import the
body of the function. This means there are implicit dependencies between AST
nodes. These dependencies determine the order in which we visit nodes in the
“from” context. As with the regular graph traversal algorithms like DFS, we
keep track which nodes we have already visited in
<code class="docutils literal notranslate"><span class="pre">ASTImporter::ImportedDecls</span></code>. Whenever we create a node then we immediately
add that to the <code class="docutils literal notranslate"><span class="pre">ImportedDecls</span></code>. We must not start the import of any other
declarations before we keep track of the newly created one. This is essential,
otherwise, we would not be able to handle circular dependencies. To enforce
this, we wrap all constructor calls of all AST nodes in
<code class="docutils literal notranslate"><span class="pre">GetImportedOrCreateDecl()</span></code>. This wrapper ensures that all newly created
declarations are immediately marked as imported; also, if a declaration is
already marked as imported then we just return its counterpart in the “to”
context. Consequently, calling a declaration’s <code class="docutils literal notranslate"><span class="pre">::Create()</span></code> function directly
would lead to errors, please don’t do that!</p>
<p>Even with the use of <code class="docutils literal notranslate"><span class="pre">GetImportedOrCreateDecl()</span></code> there is still a
probability of having an infinite import recursion if things are imported from
each other in wrong way. Imagine that during the import of <code class="docutils literal notranslate"><span class="pre">A</span></code>, the import of
<code class="docutils literal notranslate"><span class="pre">B</span></code> is requested before we could create the node for <code class="docutils literal notranslate"><span class="pre">A</span></code> (the constructor
needs a reference to <code class="docutils literal notranslate"><span class="pre">B</span></code>). And the same could be true for the import of <code class="docutils literal notranslate"><span class="pre">B</span></code>
(<code class="docutils literal notranslate"><span class="pre">A</span></code> is requested to be imported before we could create the node for <code class="docutils literal notranslate"><span class="pre">B</span></code>).
In case of the <a class="reference internal" href="#templated"><span class="std std-ref">templated-described swing</span></a> we take
extra attention to break the cyclical dependency: we import and set the
described template only after the <code class="docutils literal notranslate"><span class="pre">CXXRecordDecl</span></code> is created. As a best
practice, before creating the node in the “to” context, avoid importing of
other nodes which are not needed for the constructor of node <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</div>
<div class="section" id="id1">
<h4><a class="toc-backref" href="#id56">Error Handling</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>Every import function returns with either an <code class="docutils literal notranslate"><span class="pre">llvm::Error</span></code> or an
<code class="docutils literal notranslate"><span class="pre">llvm::Expected&lt;T&gt;</span></code> object. This enforces to check the return value of the
import functions. If there was an error during one import then we return with
that error. (Exception: when we import the members of a class, we collect the
individual errors with each member and we concatenate them in one Error
object.) We cache these errors in cases of declarations. During the next import
call if there is an existing error we just return with that. So, clients of the
library receive an Error object, which they must check.</p>
<p>During import of a specific declaration, it may happen that some AST nodes had
already been created before we recognize an error. In this case, we signal back
the error to the caller, but the “to” context remains polluted with those nodes
which had been created. Ideally, those nodes should not had been created, but
that time we did not know about the error, the error happened later. Since the
AST is immutable (most of the cases we can’t remove existing nodes) we choose
to mark these nodes as erroneous.</p>
<p>We cache the errors associated with declarations in the “from” context in
<code class="docutils literal notranslate"><span class="pre">ASTImporter::ImportDeclErrors</span></code> and the ones which are associated with the
“to” context in <code class="docutils literal notranslate"><span class="pre">ASTImporterSharedState::ImportErrors</span></code>. Note that, there may
be several ASTImporter objects which import into the same “to” context but from
different “from” contexts; in this case, they have to share the associated
errors of the “to” context.</p>
<p>When an error happens, that propagates through the call stack, through all the
dependant nodes. However, in case of dependency cycles, this is not enough,
because we strive to mark the erroneous nodes so clients can act upon. In those
cases, we have to keep track of the errors for those nodes which are
intermediate nodes of a cycle.</p>
<p>An <strong>import path</strong> is the list of the AST nodes which we visit during an Import
call. If node <code class="docutils literal notranslate"><span class="pre">A</span></code> depends on node <code class="docutils literal notranslate"><span class="pre">B</span></code> then the path contains an <code class="docutils literal notranslate"><span class="pre">A-&gt;B</span></code>
edge. From the call stack of the import functions, we can read the very same
path.</p>
<p>Now imagine the following AST, where the <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> represents dependency in terms
of the import (all nodes are declarations).</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>A-&gt;B-&gt;C-&gt;D
   `-&gt;E
</pre></div>
</div>
<p>We would like to import A.
The import behaves like a DFS, so we will visit the nodes in this order: ABCDE.
During the visitation we will have the following import paths:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>A
AB
ABC
ABCD
ABC
AB
ABE
AB
A
</pre></div>
</div>
<p>If during the visit of E there is an error then we set an error for E, then as
the call stack shrinks for B, then for A:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>A
AB
ABC
ABCD
ABC
AB
ABE // Error! Set an error to E
AB  // Set an error to B
A   // Set an error to A
</pre></div>
</div>
<p>However, during the import we could import C and D without any error and they
are independent of A,B and E. We must not set up an error for C and D. So, at
the end of the import we have an entry in <code class="docutils literal notranslate"><span class="pre">ImportDeclErrors</span></code> for A,B,E but
not for C,D.</p>
<p>Now, what happens if there is a cycle in the import path? Let’s consider this
AST:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>A-&gt;B-&gt;C-&gt;A
   `-&gt;E
</pre></div>
</div>
<p>During the visitation, we will have the below import paths and if during the
visit of E there is an error then we will set up an error for E,B,A. But what’s
up with C?</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>A
AB
ABC
ABCA
ABC
AB
ABE // Error! Set an error to E
AB  // Set an error to B
A   // Set an error to A
</pre></div>
</div>
<p>This time we know that both B and C are dependent on A. This means we must set
up an error for C too. As the call stack reverses back we get to A and we must
set up an error to all nodes which depend on A (this includes C). But C is no
longer on the import path, it just had been previously. Such a situation can
happen only if during the visitation we had a cycle. If we didn’t have any
cycle, then the normal way of passing an Error object through the call stack
could handle the situation. This is why we must track cycles during the import
process for each visited declaration.</p>
</div>
<div class="section" id="lookup-problems">
<h4><a class="toc-backref" href="#id57">Lookup Problems</a><a class="headerlink" href="#lookup-problems" title="Permalink to this headline">¶</a></h4>
<p>When we import a declaration from the source context then we check whether we
already have a structurally equivalent node with the same name in the “to”
context. If the “from” node is a definition and the found one is also a
definition, then we do not create a new node, instead, we mark the found node
as the imported node. If the found definition and the one we want to import
have the same name but they are structurally in-equivalent, then we have an ODR
violation in case of C++. If the “from” node is not a definition then we add
that to the redeclaration chain of the found node. This behaviour is essential
when we merge ASTs from different translation units which include the same
header file(s). For example, we want to have only one definition for the class
template <code class="docutils literal notranslate"><span class="pre">std::vector</span></code>, even if we included <code class="docutils literal notranslate"><span class="pre">&lt;vector&gt;</span></code> in several
translation units.</p>
<p>To find a structurally equivalent node we can use the regular C/C++ lookup
functions: <code class="docutils literal notranslate"><span class="pre">DeclContext::noload_lookup()</span></code> and
<code class="docutils literal notranslate"><span class="pre">DeclContext::localUncachedLookup()</span></code>. These functions do respect the C/C++
name hiding rules, thus you cannot find certain declarations in a given
declaration context. For instance, unnamed declarations (anonymous structs),
non-first <code class="docutils literal notranslate"><span class="pre">friend</span></code> declarations and template specializations are hidden. This
is a problem, because if we use the regular C/C++ lookup then we create
redundant AST nodes during the merge! Also, having two instances of the same
node could result in false <a class="reference internal" href="#structural-eq"><span class="std std-ref">structural in-equivalencies</span></a>
of other nodes which depend on the duplicated node. Because of these reasons,
we created a lookup class which has the sole purpose to register all
declarations, so later they can be looked up by subsequent import requests.
This is the <code class="docutils literal notranslate"><span class="pre">ASTImporterLookupTable</span></code> class. This lookup table should be
shared amongst the different <code class="docutils literal notranslate"><span class="pre">ASTImporter</span></code> instances if they happen to import
to the very same “to” context. This is why we can use the importer specific
lookup only via the <code class="docutils literal notranslate"><span class="pre">ASTImporterSharedState</span></code> class.</p>
<div class="section" id="externalastsource">
<h5><a class="toc-backref" href="#id58">ExternalASTSource</a><a class="headerlink" href="#externalastsource" title="Permalink to this headline">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">ExternalASTSource</span></code> is an abstract interface associated with the
<code class="docutils literal notranslate"><span class="pre">ASTContext</span></code> class. It provides the ability to read the declarations stored
within a declaration context either for iteration or for name lookup. A
declaration context with an external AST source may load its declarations
on-demand. This means that the list of declarations (represented as a linked
list, the head is <code class="docutils literal notranslate"><span class="pre">DeclContext::FirstDecl</span></code>) could be empty. However, member
functions like <code class="docutils literal notranslate"><span class="pre">DeclContext::lookup()</span></code> may initiate a load.</p>
<p>Usually, external sources are associated with precompiled headers. For example,
when we load a class from a PCH then the members are loaded only if we do want
to look up something in the class’ context.</p>
<p>In case of LLDB, an implementation of the <code class="docutils literal notranslate"><span class="pre">ExternalASTSource</span></code> interface is
attached to the AST context which is related to the parsed expression. This
implementation of the <code class="docutils literal notranslate"><span class="pre">ExternalASTSource</span></code> interface is realized with the help
of the <code class="docutils literal notranslate"><span class="pre">ASTImporter</span></code> class. This way, LLDB can reuse Clang’s parsing
machinery while synthesizing the underlying AST from the debug data (e.g. from
DWARF). From the view of the <code class="docutils literal notranslate"><span class="pre">ASTImporter</span></code> this means both the “to” and the
“from” context may have declaration contexts with external lexical storage. If
a <code class="docutils literal notranslate"><span class="pre">DeclContext</span></code> in the “to” AST context has external lexical storage then we
must take extra attention to work only with the already loaded declarations!
Otherwise, we would end up with an uncontrolled import process. For instance,
if we used the regular <code class="docutils literal notranslate"><span class="pre">DeclContext::lookup()</span></code> to find the existing
declarations in the “to” context then the <code class="docutils literal notranslate"><span class="pre">lookup()</span></code> call itself would
initiate a new import while we are in the middle of importing a declaration!
(By the time we initiate the lookup we haven’t registered yet that we already
started to import the node of the “from” context.) This is why we use
<code class="docutils literal notranslate"><span class="pre">DeclContext::noload_lookup()</span></code> instead.</p>
</div>
</div>
<div class="section" id="class-template-instantiations">
<h4><a class="toc-backref" href="#id59">Class Template Instantiations</a><a class="headerlink" href="#class-template-instantiations" title="Permalink to this headline">¶</a></h4>
<p>Different translation units may have class template instantiations with the
same template arguments, but with a different set of instantiated
<code class="docutils literal notranslate"><span class="pre">MethodDecls</span></code> and <code class="docutils literal notranslate"><span class="pre">FieldDecls</span></code>. Consider the following files:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// x.h</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">X</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"> </span><span class="c1">// FieldDecl with InitListExpr</span>
<span class="w">    </span><span class="n">X</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">     </span><span class="c1">// (1)</span>
<span class="w">    </span><span class="n">X</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">             </span><span class="c1">// (2)</span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// foo.cpp</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ClassTemplateSpec with ctor (1): FieldDecl without InitlistExpr</span>
<span class="w">    </span><span class="n">X</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="n">xc</span><span class="p">(</span><span class="sc">&#39;c&#39;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// bar.cpp</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ClassTemplateSpec with ctor (2): FieldDecl WITH InitlistExpr</span>
<span class="w">    </span><span class="n">X</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="n">xc</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">foo.cpp</span></code> we use the constructor with number <code class="docutils literal notranslate"><span class="pre">(1)</span></code>, which explicitly
initializes the member <code class="docutils literal notranslate"><span class="pre">a</span></code> to <code class="docutils literal notranslate"><span class="pre">3</span></code>, thus the <code class="docutils literal notranslate"><span class="pre">InitListExpr</span></code> <code class="docutils literal notranslate"><span class="pre">{0}</span></code> is not
used here and the AST node is not instantiated. However, in the case of
<code class="docutils literal notranslate"><span class="pre">bar.cpp</span></code> we use the constructor with number <code class="docutils literal notranslate"><span class="pre">(2)</span></code>, which does not
explicitly initialize the <code class="docutils literal notranslate"><span class="pre">a</span></code> member, so the default <code class="docutils literal notranslate"><span class="pre">InitListExpr</span></code> is
needed and thus instantiated. When we merge the AST of <code class="docutils literal notranslate"><span class="pre">foo.cpp</span></code> and
<code class="docutils literal notranslate"><span class="pre">bar.cpp</span></code> we must create an AST node for the class template instantiation of
<code class="docutils literal notranslate"><span class="pre">X&lt;char&gt;</span></code> which has all the required nodes. Therefore, when we find an
existing <code class="docutils literal notranslate"><span class="pre">ClassTemplateSpecializationDecl</span></code> then we merge the fields of the
<code class="docutils literal notranslate"><span class="pre">ClassTemplateSpecializationDecl</span></code> in the “from” context in a way that the
<code class="docutils literal notranslate"><span class="pre">InitListExpr</span></code> is copied if not existent yet. The same merge mechanism should
be done in the cases of instantiated default arguments and exception
specifications of functions.</p>
</div>
<div class="section" id="visibility-of-declarations">
<span id="visibility"></span><h4><a class="toc-backref" href="#id60">Visibility of Declarations</a><a class="headerlink" href="#visibility-of-declarations" title="Permalink to this headline">¶</a></h4>
<p>During import of a global variable with external visibility, the lookup will
find variables (with the same name) but with static visibility (linkage).
Clearly, we cannot put them into the same redeclaration chain. The same is true
the in case of functions. Also, we have to take care of other kinds of
declarations like enums, classes, etc. if they are in anonymous namespaces.
Therefore, we filter the lookup results and consider only those which have the
same visibility as the declaration we currently import.</p>
<p>We consider two declarations in two anonymous namespaces to have the same
visibility only if they are imported from the same AST context.</p>
</div>
<div class="section" id="strategies-to-handle-conflicting-names">
<h4><a class="toc-backref" href="#id61">Strategies to Handle Conflicting Names</a><a class="headerlink" href="#strategies-to-handle-conflicting-names" title="Permalink to this headline">¶</a></h4>
<p>During the import we lookup existing declarations with the same name. We filter
the lookup results based on their <a class="reference internal" href="#visibility"><span class="std std-ref">visibility</span></a>. If any of the
found declarations are not structurally equivalent then we bumped to a name
conflict error (ODR violation in C++). In this case, we return with an
<code class="docutils literal notranslate"><span class="pre">Error</span></code> and we set up the <code class="docutils literal notranslate"><span class="pre">Error</span></code> object for the declaration. However, some
clients of the <code class="docutils literal notranslate"><span class="pre">ASTImporter</span></code> may require a different, perhaps less
conservative and more liberal error handling strategy.</p>
<p>E.g. static analysis clients may benefit if the node is created even if there
is a name conflict. During the CTU analysis of certain projects, we recognized
that there are global declarations which collide with declarations from other
translation units, but they are not referenced outside from their translation
unit. These declarations should be in an unnamed namespace ideally. If we treat
these collisions liberally then CTU analysis can find more results. Note, the
feature be able to choose between name conflict handling strategies is still an
ongoing work.</p>
</div>
</div>
<div class="section" id="the-cfg-class">
<span id="cfg"></span><h3><a class="toc-backref" href="#id62">The <code class="docutils literal notranslate"><span class="pre">CFG</span></code> class</a><a class="headerlink" href="#the-cfg-class" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">CFG</span></code> class is designed to represent a source-level control-flow graph
for a single statement (<code class="docutils literal notranslate"><span class="pre">Stmt*</span></code>).  Typically instances of <code class="docutils literal notranslate"><span class="pre">CFG</span></code> are
constructed for function bodies (usually an instance of <code class="docutils literal notranslate"><span class="pre">CompoundStmt</span></code>), but
can also be instantiated to represent the control-flow of any class that
subclasses <code class="docutils literal notranslate"><span class="pre">Stmt</span></code>, which includes simple expressions.  Control-flow graphs
are especially useful for performing <a class="reference external" href="https://en.wikipedia.org/wiki/Data_flow_analysis#Sensitivities">flow- or path-sensitive</a> program
analyses on a given function.</p>
<div class="section" id="basic-blocks">
<h4><a class="toc-backref" href="#id63">Basic Blocks</a><a class="headerlink" href="#basic-blocks" title="Permalink to this headline">¶</a></h4>
<p>Concretely, an instance of <code class="docutils literal notranslate"><span class="pre">CFG</span></code> is a collection of basic blocks.  Each basic
block is an instance of <code class="docutils literal notranslate"><span class="pre">CFGBlock</span></code>, which simply contains an ordered sequence
of <code class="docutils literal notranslate"><span class="pre">Stmt*</span></code> (each referring to statements in the AST).  The ordering of
statements within a block indicates unconditional flow of control from one
statement to the next.  <a class="reference internal" href="#conditionalcontrolflow"><span class="std std-ref">Conditional control-flow</span></a> is represented using edges between basic blocks.  The
statements within a given <code class="docutils literal notranslate"><span class="pre">CFGBlock</span></code> can be traversed using the
<code class="docutils literal notranslate"><span class="pre">CFGBlock::*iterator</span></code> interface.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">CFG</span></code> object owns the instances of <code class="docutils literal notranslate"><span class="pre">CFGBlock</span></code> within the control-flow
graph it represents.  Each <code class="docutils literal notranslate"><span class="pre">CFGBlock</span></code> within a CFG is also uniquely numbered
(accessible via <code class="docutils literal notranslate"><span class="pre">CFGBlock::getBlockID()</span></code>).  Currently the number is based on
the ordering the blocks were created, but no assumptions should be made on how
<code class="docutils literal notranslate"><span class="pre">CFGBlocks</span></code> are numbered other than their numbers are unique and that they
are numbered from 0..N-1 (where N is the number of basic blocks in the CFG).</p>
</div>
<div class="section" id="entry-and-exit-blocks">
<h4><a class="toc-backref" href="#id64">Entry and Exit Blocks</a><a class="headerlink" href="#entry-and-exit-blocks" title="Permalink to this headline">¶</a></h4>
<p>Each instance of <code class="docutils literal notranslate"><span class="pre">CFG</span></code> contains two special blocks: an <em>entry</em> block
(accessible via <code class="docutils literal notranslate"><span class="pre">CFG::getEntry()</span></code>), which has no incoming edges, and an
<em>exit</em> block (accessible via <code class="docutils literal notranslate"><span class="pre">CFG::getExit()</span></code>), which has no outgoing edges.
Neither block contains any statements, and they serve the role of providing a
clear entrance and exit for a body of code such as a function body.  The
presence of these empty blocks greatly simplifies the implementation of many
analyses built on top of CFGs.</p>
</div>
<div class="section" id="conditional-control-flow">
<span id="conditionalcontrolflow"></span><h4><a class="toc-backref" href="#id65">Conditional Control-Flow</a><a class="headerlink" href="#conditional-control-flow" title="Permalink to this headline">¶</a></h4>
<p>Conditional control-flow (such as those induced by if-statements and loops) is
represented as edges between <code class="docutils literal notranslate"><span class="pre">CFGBlocks</span></code>.  Because different C language
constructs can induce control-flow, each <code class="docutils literal notranslate"><span class="pre">CFGBlock</span></code> also records an extra
<code class="docutils literal notranslate"><span class="pre">Stmt*</span></code> that represents the <em>terminator</em> of the block.  A terminator is
simply the statement that caused the control-flow, and is used to identify the
nature of the conditional control-flow between blocks.  For example, in the
case of an if-statement, the terminator refers to the <code class="docutils literal notranslate"><span class="pre">IfStmt</span></code> object in the
AST that represented the given branch.</p>
<p>To illustrate, consider the following code example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>After invoking the parser+semantic analyzer on this code fragment, the AST of
the body of <code class="docutils literal notranslate"><span class="pre">foo</span></code> is referenced by a single <code class="docutils literal notranslate"><span class="pre">Stmt*</span></code>.  We can then construct
an instance of <code class="docutils literal notranslate"><span class="pre">CFG</span></code> representing the control-flow graph of this function
body by single call to a static class method:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Stmt</span><span class="w"> </span><span class="o">*</span><span class="n">FooBody</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">CFG</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FooCFG</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CFG</span><span class="o">::</span><span class="n">buildCFG</span><span class="p">(</span><span class="n">FooBody</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Along with providing an interface to iterate over its <code class="docutils literal notranslate"><span class="pre">CFGBlocks</span></code>, the
<code class="docutils literal notranslate"><span class="pre">CFG</span></code> class also provides methods that are useful for debugging and
visualizing CFGs.  For example, the method <code class="docutils literal notranslate"><span class="pre">CFG::dump()</span></code> dumps a
pretty-printed version of the CFG to standard error.  This is especially useful
when one is using a debugger such as gdb.  For example, here is the output of
<code class="docutils literal notranslate"><span class="pre">FooCFG-&gt;dump()</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>[ B5 (ENTRY) ]
   Predecessors (0):
   Successors (1): B4

[ B4 ]
   1: x = x + 1
   2: (x &gt; 2)
   T: if [B4.2]
   Predecessors (1): B5
   Successors (2): B3 B2

[ B3 ]
   1: x++
   Predecessors (1): B4
   Successors (1): B1

[ B2 ]
   1: x += 2
   2: x *= 2
   Predecessors (1): B4
   Successors (1): B1

[ B1 ]
   1: return x;
   Predecessors (2): B2 B3
   Successors (1): B0

[ B0 (EXIT) ]
   Predecessors (1): B1
   Successors (0):
</pre></div>
</div>
<p>For each block, the pretty-printed output displays for each block the number of
<em>predecessor</em> blocks (blocks that have outgoing control-flow to the given
block) and <em>successor</em> blocks (blocks that have control-flow that have incoming
control-flow from the given block).  We can also clearly see the special entry
and exit blocks at the beginning and end of the pretty-printed output.  For the
entry block (block B5), the number of predecessor blocks is 0, while for the
exit block (block B0) the number of successor blocks is 0.</p>
<p>The most interesting block here is B4, whose outgoing control-flow represents
the branching caused by the sole if-statement in <code class="docutils literal notranslate"><span class="pre">foo</span></code>.  Of particular
interest is the second statement in the block, <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">&gt;</span> <span class="pre">2)</span></code>, and the terminator,
printed as <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">[B4.2]</span></code>.  The second statement represents the evaluation of
the condition of the if-statement, which occurs before the actual branching of
control-flow.  Within the <code class="docutils literal notranslate"><span class="pre">CFGBlock</span></code> for B4, the <code class="docutils literal notranslate"><span class="pre">Stmt*</span></code> for the second
statement refers to the actual expression in the AST for <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">&gt;</span> <span class="pre">2)</span></code>.  Thus
pointers to subclasses of <code class="docutils literal notranslate"><span class="pre">Expr</span></code> can appear in the list of statements in a
block, and not just subclasses of <code class="docutils literal notranslate"><span class="pre">Stmt</span></code> that refer to proper C statements.</p>
<p>The terminator of block B4 is a pointer to the <code class="docutils literal notranslate"><span class="pre">IfStmt</span></code> object in the AST.
The pretty-printer outputs <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">[B4.2]</span></code> because the condition expression of
the if-statement has an actual place in the basic block, and thus the
terminator is essentially <em>referring</em> to the expression that is the second
statement of block B4 (i.e., B4.2).  In this manner, conditions for
control-flow (which also includes conditions for loops and switch statements)
are hoisted into the actual basic block.</p>
</div>
</div>
<div class="section" id="constant-folding-in-the-clang-ast">
<h3><a class="toc-backref" href="#id66">Constant Folding in the Clang AST</a><a class="headerlink" href="#constant-folding-in-the-clang-ast" title="Permalink to this headline">¶</a></h3>
<p>There are several places where constants and constant folding matter a lot to
the Clang front-end.  First, in general, we prefer the AST to retain the source
code as close to how the user wrote it as possible.  This means that if they
wrote “<code class="docutils literal notranslate"><span class="pre">5+4</span></code>”, we want to keep the addition and two constants in the AST, we
don’t want to fold to “<code class="docutils literal notranslate"><span class="pre">9</span></code>”.  This means that constant folding in various
ways turns into a tree walk that needs to handle the various cases.</p>
<p>However, there are places in both C and C++ that require constants to be
folded.  For example, the C standard defines what an “integer constant
expression” (i-c-e) is with very precise and specific requirements.  The
language then requires i-c-e’s in a lot of places (for example, the size of a
bitfield, the value for a case statement, etc).  For these, we have to be able
to constant fold the constants, to do semantic checks (e.g., verify bitfield
size is non-negative and that case statements aren’t duplicated).  We aim for
Clang to be very pedantic about this, diagnosing cases when the code does not
use an i-c-e where one is required, but accepting the code unless running with
<code class="docutils literal notranslate"><span class="pre">-pedantic-errors</span></code>.</p>
<p>Things get a little bit more tricky when it comes to compatibility with
real-world source code.  Specifically, GCC has historically accepted a huge
superset of expressions as i-c-e’s, and a lot of real world code depends on
this unfortunate accident of history (including, e.g., the glibc system
headers).  GCC accepts anything its “fold” optimizer is capable of reducing to
an integer constant, which means that the definition of what it accepts changes
as its optimizer does.  One example is that GCC accepts things like “<code class="docutils literal notranslate"><span class="pre">case</span>
<span class="pre">X-X:</span></code>” even when <code class="docutils literal notranslate"><span class="pre">X</span></code> is a variable, because it can fold this to 0.</p>
<p>Another issue are how constants interact with the extensions we support, such
as <code class="docutils literal notranslate"><span class="pre">__builtin_constant_p</span></code>, <code class="docutils literal notranslate"><span class="pre">__builtin_inf</span></code>, <code class="docutils literal notranslate"><span class="pre">__extension__</span></code> and many
others.  C99 obviously does not specify the semantics of any of these
extensions, and the definition of i-c-e does not include them.  However, these
extensions are often used in real code, and we have to have a way to reason
about them.</p>
<p>Finally, this is not just a problem for semantic analysis.  The code generator
and other clients have to be able to fold constants (e.g., to initialize global
variables) and have to handle a superset of what C99 allows.  Further, these
clients can benefit from extended information.  For example, we know that
“<code class="docutils literal notranslate"><span class="pre">foo()</span> <span class="pre">||</span> <span class="pre">1</span></code>” always evaluates to <code class="docutils literal notranslate"><span class="pre">true</span></code>, but we can’t replace the
expression with <code class="docutils literal notranslate"><span class="pre">true</span></code> because it has side effects.</p>
<div class="section" id="implementation-approach">
<h4><a class="toc-backref" href="#id67">Implementation Approach</a><a class="headerlink" href="#implementation-approach" title="Permalink to this headline">¶</a></h4>
<p>After trying several different approaches, we’ve finally converged on a design
(Note, at the time of this writing, not all of this has been implemented,
consider this a design goal!).  Our basic approach is to define a single
recursive evaluation method (<code class="docutils literal notranslate"><span class="pre">Expr::Evaluate</span></code>), which is implemented
in <code class="docutils literal notranslate"><span class="pre">AST/ExprConstant.cpp</span></code>.  Given an expression with “scalar” type (integer,
fp, complex, or pointer) this method returns the following information:</p>
<ul class="simple">
<li><p>Whether the expression is an integer constant expression, a general constant
that was folded but has no side effects, a general constant that was folded
but that does have side effects, or an uncomputable/unfoldable value.</p></li>
<li><p>If the expression was computable in any way, this method returns the
<code class="docutils literal notranslate"><span class="pre">APValue</span></code> for the result of the expression.</p></li>
<li><p>If the expression is not evaluatable at all, this method returns information
on one of the problems with the expression.  This includes a
<code class="docutils literal notranslate"><span class="pre">SourceLocation</span></code> for where the problem is, and a diagnostic ID that explains
the problem.  The diagnostic should have <code class="docutils literal notranslate"><span class="pre">ERROR</span></code> type.</p></li>
<li><p>If the expression is not an integer constant expression, this method returns
information on one of the problems with the expression.  This includes a
<code class="docutils literal notranslate"><span class="pre">SourceLocation</span></code> for where the problem is, and a diagnostic ID that
explains the problem.  The diagnostic should have <code class="docutils literal notranslate"><span class="pre">EXTENSION</span></code> type.</p></li>
</ul>
<p>This information gives various clients the flexibility that they want, and we
will eventually have some helper methods for various extensions.  For example,
<code class="docutils literal notranslate"><span class="pre">Sema</span></code> should have a <code class="docutils literal notranslate"><span class="pre">Sema::VerifyIntegerConstantExpression</span></code> method, which
calls <code class="docutils literal notranslate"><span class="pre">Evaluate</span></code> on the expression.  If the expression is not foldable, the
error is emitted, and it would return <code class="docutils literal notranslate"><span class="pre">true</span></code>.  If the expression is not an
i-c-e, the <code class="docutils literal notranslate"><span class="pre">EXTENSION</span></code> diagnostic is emitted.  Finally it would return
<code class="docutils literal notranslate"><span class="pre">false</span></code> to indicate that the AST is OK.</p>
<p>Other clients can use the information in other ways, for example, codegen can
just use expressions that are foldable in any way.</p>
</div>
<div class="section" id="extensions">
<h4><a class="toc-backref" href="#id68">Extensions</a><a class="headerlink" href="#extensions" title="Permalink to this headline">¶</a></h4>
<p>This section describes how some of the various extensions Clang supports
interacts with constant evaluation:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__extension__</span></code>: The expression form of this extension causes any
evaluatable subexpression to be accepted as an integer constant expression.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_constant_p</span></code>: This returns true (as an integer constant
expression) if the operand evaluates to either a numeric value (that is, not
a pointer cast to integral type) of integral, enumeration, floating or
complex type, or if it evaluates to the address of the first character of a
string literal (possibly cast to some other type).  As a special case, if
<code class="docutils literal notranslate"><span class="pre">__builtin_constant_p</span></code> is the (potentially parenthesized) condition of a
conditional operator expression (“<code class="docutils literal notranslate"><span class="pre">?:</span></code>”), only the true side of the
conditional operator is considered, and it is evaluated with full constant
folding.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_choose_expr</span></code>: The condition is required to be an integer
constant expression, but we accept any constant as an “extension of an
extension”.  This only evaluates one operand depending on which way the
condition evaluates.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_classify_type</span></code>: This always returns an integer constant
expression.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_inf,</span> <span class="pre">nan,</span> <span class="pre">...</span></code>: These are treated just like a floating-point
literal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_abs,</span> <span class="pre">copysign,</span> <span class="pre">...</span></code>: These are constant folded as general
constant expressions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_strlen</span></code> and <code class="docutils literal notranslate"><span class="pre">strlen</span></code>: These are constant folded as integer
constant expressions if the argument is a string literal.</p></li>
</ul>
</div>
</div>
</div>
<div class="section" id="the-sema-library">
<span id="sema"></span><h2><a class="toc-backref" href="#id69">The Sema Library</a><a class="headerlink" href="#the-sema-library" title="Permalink to this headline">¶</a></h2>
<p>This library is called by the <a class="reference internal" href="#parser"><span class="std std-ref">Parser library</span></a> during parsing to
do semantic analysis of the input.  For valid programs, Sema builds an AST for
parsed constructs.</p>
</div>
<div class="section" id="the-codegen-library">
<span id="codegen"></span><h2><a class="toc-backref" href="#id70">The CodeGen Library</a><a class="headerlink" href="#the-codegen-library" title="Permalink to this headline">¶</a></h2>
<p>CodeGen takes an <a class="reference internal" href="#ast"><span class="std std-ref">AST</span></a> as input and produces <a class="reference external" href="//llvm.org/docs/LangRef.html">LLVM IR code</a> from it.</p>
</div>
<div class="section" id="how-to-change-clang">
<h2><a class="toc-backref" href="#id71">How to change Clang</a><a class="headerlink" href="#how-to-change-clang" title="Permalink to this headline">¶</a></h2>
<div class="section" id="how-to-add-an-attribute">
<h3><a class="toc-backref" href="#id72">How to add an attribute</a><a class="headerlink" href="#how-to-add-an-attribute" title="Permalink to this headline">¶</a></h3>
<p>Attributes are a form of metadata that can be attached to a program construct,
allowing the programmer to pass semantic information along to the compiler for
various uses. For example, attributes may be used to alter the code generation
for a program construct, or to provide extra semantic information for static
analysis. This document explains how to add a custom attribute to Clang.
Documentation on existing attributes can be found <a class="reference external" href="//clang.llvm.org/docs/AttributeReference.html">here</a>.</p>
<div class="section" id="attribute-basics">
<h4><a class="toc-backref" href="#id73">Attribute Basics</a><a class="headerlink" href="#attribute-basics" title="Permalink to this headline">¶</a></h4>
<p>Attributes in Clang are handled in three stages: parsing into a parsed attribute
representation, conversion from a parsed attribute into a semantic attribute,
and then the semantic handling of the attribute.</p>
<p>Parsing of the attribute is determined by the various syntactic forms attributes
can take, such as GNU, C++11, and Microsoft style attributes, as well as other
information provided by the table definition of the attribute. Ultimately, the
parsed representation of an attribute object is an <code class="docutils literal notranslate"><span class="pre">ParsedAttr</span></code> object.
These parsed attributes chain together as a list of parsed attributes attached
to a declarator or declaration specifier. The parsing of attributes is handled
automatically by Clang, except for attributes spelled as keywords. When
implementing a keyword attribute, the parsing of the keyword and creation of the
<code class="docutils literal notranslate"><span class="pre">ParsedAttr</span></code> object must be done manually.</p>
<p>Eventually, <code class="docutils literal notranslate"><span class="pre">Sema::ProcessDeclAttributeList()</span></code> is called with a <code class="docutils literal notranslate"><span class="pre">Decl</span></code> and
a <code class="docutils literal notranslate"><span class="pre">ParsedAttr</span></code>, at which point the parsed attribute can be transformed
into a semantic attribute. The process by which a parsed attribute is converted
into a semantic attribute depends on the attribute definition and semantic
requirements of the attribute. The end result, however, is that the semantic
attribute object is attached to the <code class="docutils literal notranslate"><span class="pre">Decl</span></code> object, and can be obtained by a
call to <code class="docutils literal notranslate"><span class="pre">Decl::getAttr&lt;T&gt;()</span></code>. Similarly, for statement attributes,
<code class="docutils literal notranslate"><span class="pre">Sema::ProcessStmtAttributes()</span></code> is called with a <code class="docutils literal notranslate"><span class="pre">Stmt</span></code> a list of
<code class="docutils literal notranslate"><span class="pre">ParsedAttr</span></code> objects to be converted into a semantic attribute.</p>
<p>The structure of the semantic attribute is also governed by the attribute
definition given in Attr.td. This definition is used to automatically generate
functionality used for the implementation of the attribute, such as a class
derived from <code class="docutils literal notranslate"><span class="pre">clang::Attr</span></code>, information for the parser to use, automated
semantic checking for some attributes, etc.</p>
</div>
<div class="section" id="include-clang-basic-attr-td">
<h4><a class="toc-backref" href="#id74"><code class="docutils literal notranslate"><span class="pre">include/clang/Basic/Attr.td</span></code></a><a class="headerlink" href="#include-clang-basic-attr-td" title="Permalink to this headline">¶</a></h4>
<p>The first step to adding a new attribute to Clang is to add its definition to
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/Attr.td">include/clang/Basic/Attr.td</a>.
This tablegen definition must derive from the <code class="docutils literal notranslate"><span class="pre">Attr</span></code> (tablegen, not
semantic) type, or one of its derivatives. Most attributes will derive from the
<code class="docutils literal notranslate"><span class="pre">InheritableAttr</span></code> type, which specifies that the attribute can be inherited by
later redeclarations of the <code class="docutils literal notranslate"><span class="pre">Decl</span></code> it is associated with.
<code class="docutils literal notranslate"><span class="pre">InheritableParamAttr</span></code> is similar to <code class="docutils literal notranslate"><span class="pre">InheritableAttr</span></code>, except that the
attribute is written on a parameter instead of a declaration. If the attribute
applies to statements, it should inherit from <code class="docutils literal notranslate"><span class="pre">StmtAttr</span></code>. If the attribute is
intended to apply to a type instead of a declaration, such an attribute should
derive from <code class="docutils literal notranslate"><span class="pre">TypeAttr</span></code>, and will generally not be given an AST representation.
(Note that this document does not cover the creation of type attributes.) An
attribute that inherits from <code class="docutils literal notranslate"><span class="pre">IgnoredAttr</span></code> is parsed, but will generate an
ignored attribute diagnostic when used, which may be useful when an attribute is
supported by another vendor but not supported by clang.</p>
<p>The definition will specify several key pieces of information, such as the
semantic name of the attribute, the spellings the attribute supports, the
arguments the attribute expects, and more. Most members of the <code class="docutils literal notranslate"><span class="pre">Attr</span></code> tablegen
type do not require definitions in the derived definition as the default
suffice. However, every attribute must specify at least a spelling list, a
subject list, and a documentation list.</p>
<div class="section" id="spellings">
<h5><a class="toc-backref" href="#id75">Spellings</a><a class="headerlink" href="#spellings" title="Permalink to this headline">¶</a></h5>
<p>All attributes are required to specify a spelling list that denotes the ways in
which the attribute can be spelled. For instance, a single semantic attribute
may have a keyword spelling, as well as a C++11 spelling and a GNU spelling. An
empty spelling list is also permissible and may be useful for attributes which
are created implicitly. The following spellings are accepted:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Spelling</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">GNU</span></code></p></td>
<td><p>Spelled with a GNU-style <code class="docutils literal notranslate"><span class="pre">__attribute__((attr))</span></code> syntax and
placement.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">CXX11</span></code></p></td>
<td><p>Spelled with a C++-style <code class="docutils literal notranslate"><span class="pre">[[attr]]</span></code> syntax with an optional
vendor-specific namespace.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">C2x</span></code></p></td>
<td><p>Spelled with a C-style <code class="docutils literal notranslate"><span class="pre">[[attr]]</span></code> syntax with an optional
vendor-specific namespace.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">Declspec</span></code></p></td>
<td><p>Spelled with a Microsoft-style <code class="docutils literal notranslate"><span class="pre">__declspec(attr)</span></code> syntax.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">Keyword</span></code></p></td>
<td><p>The attribute is spelled as a keyword, and required custom
parsing.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">GCC</span></code></p></td>
<td><p>Specifies two or three spellings: the first is a GNU-style
spelling, the second is a C++-style spelling with the <code class="docutils literal notranslate"><span class="pre">gnu</span></code>
namespace, and the third is an optional C-style spelling with
the <code class="docutils literal notranslate"><span class="pre">gnu</span></code> namespace. Attributes should only specify this
spelling for attributes supported by GCC.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">Clang</span></code></p></td>
<td><p>Specifies two or three spellings: the first is a GNU-style
spelling, the second is a C++-style spelling with the <code class="docutils literal notranslate"><span class="pre">clang</span></code>
namespace, and the third is an optional C-style spelling with
the <code class="docutils literal notranslate"><span class="pre">clang</span></code> namespace. By default, a C-style spelling is
provided.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">Pragma</span></code></p></td>
<td><p>The attribute is spelled as a <code class="docutils literal notranslate"><span class="pre">#pragma</span></code>, and requires custom
processing within the preprocessor. If the attribute is meant to
be used by Clang, it should set the namespace to <code class="docutils literal notranslate"><span class="pre">&quot;clang&quot;</span></code>.
Note that this spelling is not used for declaration attributes.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="subjects">
<h5><a class="toc-backref" href="#id76">Subjects</a><a class="headerlink" href="#subjects" title="Permalink to this headline">¶</a></h5>
<p>Attributes appertain to one or more subjects. If the attribute attempts to
attach to a subject that is not in the subject list, a diagnostic is issued
automatically. Whether the diagnostic is a warning or an error depends on how
the attribute’s <code class="docutils literal notranslate"><span class="pre">SubjectList</span></code> is defined, but the default behavior is to warn.
The diagnostics displayed to the user are automatically determined based on the
subjects in the list, but a custom diagnostic parameter can also be specified in
the <code class="docutils literal notranslate"><span class="pre">SubjectList</span></code>. The diagnostics generated for subject list violations are
calculated automatically or specified by the subject list itself. If a
previously unused Decl node is added to the <code class="docutils literal notranslate"><span class="pre">SubjectList</span></code>, the logic used to
automatically determine the diagnostic parameter in <a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/clang/utils/TableGen/ClangAttrEmitter.cpp">utils/TableGen/ClangAttrEmitter.cpp</a>
may need to be updated.</p>
<p>By default, all subjects in the SubjectList must either be a Decl node defined
in <code class="docutils literal notranslate"><span class="pre">DeclNodes.td</span></code>, or a statement node defined in <code class="docutils literal notranslate"><span class="pre">StmtNodes.td</span></code>. However,
more complex subjects can be created by creating a <code class="docutils literal notranslate"><span class="pre">SubsetSubject</span></code> object.
Each such object has a base subject which it appertains to (which must be a
Decl or Stmt node, and not a SubsetSubject node), and some custom code which is
called when determining whether an attribute appertains to the subject. For
instance, a <code class="docutils literal notranslate"><span class="pre">NonBitField</span></code> SubsetSubject appertains to a <code class="docutils literal notranslate"><span class="pre">FieldDecl</span></code>, and
tests whether the given FieldDecl is a bit field. When a SubsetSubject is
specified in a SubjectList, a custom diagnostic parameter must also be provided.</p>
<p>Diagnostic checking for attribute subject lists for declaration and statement
attributes is automated except when <code class="docutils literal notranslate"><span class="pre">HasCustomParsing</span></code> is set to <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</div>
<div class="section" id="documentation">
<h5><a class="toc-backref" href="#id77">Documentation</a><a class="headerlink" href="#documentation" title="Permalink to this headline">¶</a></h5>
<p>All attributes must have some form of documentation associated with them.
Documentation is table generated on the public web server by a server-side
process that runs daily. Generally, the documentation for an attribute is a
stand-alone definition in <a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/AttrDocs.td">include/clang/Basic/AttrDocs.td</a>
that is named after the attribute being documented.</p>
<p>If the attribute is not for public consumption, or is an implicitly-created
attribute that has no visible spelling, the documentation list can specify the
<code class="docutils literal notranslate"><span class="pre">InternalOnly</span></code> object. Otherwise, the attribute should have its documentation
added to AttrDocs.td.</p>
<p>Documentation derives from the <code class="docutils literal notranslate"><span class="pre">Documentation</span></code> tablegen type. All derived
types must specify a documentation category and the actual documentation itself.
Additionally, it can specify a custom heading for the attribute, though a
default heading will be chosen when possible.</p>
<p>There are four predefined documentation categories: <code class="docutils literal notranslate"><span class="pre">DocCatFunction</span></code> for
attributes that appertain to function-like subjects, <code class="docutils literal notranslate"><span class="pre">DocCatVariable</span></code> for
attributes that appertain to variable-like subjects, <code class="docutils literal notranslate"><span class="pre">DocCatType</span></code> for type
attributes, and <code class="docutils literal notranslate"><span class="pre">DocCatStmt</span></code> for statement attributes. A custom documentation
category should be used for groups of attributes with similar functionality.
Custom categories are good for providing overview information for the attributes
grouped under it. For instance, the consumed annotation attributes define a
custom category, <code class="docutils literal notranslate"><span class="pre">DocCatConsumed</span></code>, that explains what consumed annotations are
at a high level.</p>
<p>Documentation content (whether it is for an attribute or a category) is written
using reStructuredText (RST) syntax.</p>
<p>After writing the documentation for the attribute, it should be locally tested
to ensure that there are no issues generating the documentation on the server.
Local testing requires a fresh build of clang-tblgen. To generate the attribute
documentation, execute the following command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">clang</span><span class="o">-</span><span class="n">tblgen</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">attr</span><span class="o">-</span><span class="n">docs</span> <span class="o">-</span><span class="n">I</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">clang</span><span class="o">/</span><span class="n">include</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">clang</span><span class="o">/</span><span class="n">include</span><span class="o">/</span><span class="n">clang</span><span class="o">/</span><span class="n">Basic</span><span class="o">/</span><span class="n">Attr</span><span class="o">.</span><span class="n">td</span> <span class="o">-</span><span class="n">o</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">clang</span><span class="o">/</span><span class="n">docs</span><span class="o">/</span><span class="n">AttributeReference</span><span class="o">.</span><span class="n">rst</span>
</pre></div>
</div>
<p>When testing locally, <em>do not</em> commit changes to <code class="docutils literal notranslate"><span class="pre">AttributeReference.rst</span></code>.
This file is generated by the server automatically, and any changes made to this
file will be overwritten.</p>
</div>
<div class="section" id="arguments">
<h5><a class="toc-backref" href="#id78">Arguments</a><a class="headerlink" href="#arguments" title="Permalink to this headline">¶</a></h5>
<p>Attributes may optionally specify a list of arguments that can be passed to the
attribute. Attribute arguments specify both the parsed form and the semantic
form of the attribute. For example, if <code class="docutils literal notranslate"><span class="pre">Args</span></code> is
<code class="docutils literal notranslate"><span class="pre">[StringArgument&lt;&quot;Arg1&quot;&gt;,</span> <span class="pre">IntArgument&lt;&quot;Arg2&quot;&gt;]</span></code> then
<code class="docutils literal notranslate"><span class="pre">__attribute__((myattribute(&quot;Hello&quot;,</span> <span class="pre">3)))</span></code> will be a valid use; it requires
two arguments while parsing, and the Attr subclass’ constructor for the
semantic attribute will require a string and integer argument.</p>
<p>All arguments have a name and a flag that specifies whether the argument is
optional. The associated C++ type of the argument is determined by the argument
definition type. If the existing argument types are insufficient, new types can
be created, but it requires modifying <a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/clang/utils/TableGen/ClangAttrEmitter.cpp">utils/TableGen/ClangAttrEmitter.cpp</a>
to properly support the type.</p>
</div>
<div class="section" id="other-properties">
<h5><a class="toc-backref" href="#id79">Other Properties</a><a class="headerlink" href="#other-properties" title="Permalink to this headline">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">Attr</span></code> definition has other members which control the behavior of the
attribute. Many of them are special-purpose and beyond the scope of this
document, however a few deserve mention.</p>
<p>If the parsed form of the attribute is more complex, or differs from the
semantic form, the <code class="docutils literal notranslate"><span class="pre">HasCustomParsing</span></code> bit can be set to <code class="docutils literal notranslate"><span class="pre">1</span></code> for the class,
and the parsing code in <a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/clang/lib/Parse/ParseDecl.cpp">Parser::ParseGNUAttributeArgs()</a>
can be updated for the special case. Note that this only applies to arguments
with a GNU spelling – attributes with a __declspec spelling currently ignore
this flag and are handled by <code class="docutils literal notranslate"><span class="pre">Parser::ParseMicrosoftDeclSpec</span></code>.</p>
<p>Note that setting this member to 1 will opt out of common attribute semantic
handling, requiring extra implementation efforts to ensure the attribute
appertains to the appropriate subject, etc.</p>
<p>If the attribute should not be propagated from a template declaration to an
instantiation of the template, set the <code class="docutils literal notranslate"><span class="pre">Clone</span></code> member to 0. By default, all
attributes will be cloned to template instantiations.</p>
<p>Attributes that do not require an AST node should set the <code class="docutils literal notranslate"><span class="pre">ASTNode</span></code> field to
<code class="docutils literal notranslate"><span class="pre">0</span></code> to avoid polluting the AST. Note that anything inheriting from
<code class="docutils literal notranslate"><span class="pre">TypeAttr</span></code> or <code class="docutils literal notranslate"><span class="pre">IgnoredAttr</span></code> automatically do not generate an AST node. All
other attributes generate an AST node by default. The AST node is the semantic
representation of the attribute.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">LangOpts</span></code> field specifies a list of language options required by the
attribute.  For instance, all of the CUDA-specific attributes specify <code class="docutils literal notranslate"><span class="pre">[CUDA]</span></code>
for the <code class="docutils literal notranslate"><span class="pre">LangOpts</span></code> field, and when the CUDA language option is not enabled, an
“attribute ignored” warning diagnostic is emitted. Since language options are
not table generated nodes, new language options must be created manually and
should specify the spelling used by <code class="docutils literal notranslate"><span class="pre">LangOptions</span></code> class.</p>
<p>Custom accessors can be generated for an attribute based on the spelling list
for that attribute. For instance, if an attribute has two different spellings:
‘Foo’ and ‘Bar’, accessors can be created:
<code class="docutils literal notranslate"><span class="pre">[Accessor&lt;&quot;isFoo&quot;,</span> <span class="pre">[GNU&lt;&quot;Foo&quot;&gt;]&gt;,</span> <span class="pre">Accessor&lt;&quot;isBar&quot;,</span> <span class="pre">[GNU&lt;&quot;Bar&quot;&gt;]&gt;]</span></code>
These accessors will be generated on the semantic form of the attribute,
accepting no arguments and returning a <code class="docutils literal notranslate"><span class="pre">bool</span></code>.</p>
<p>Attributes that do not require custom semantic handling should set the
<code class="docutils literal notranslate"><span class="pre">SemaHandler</span></code> field to <code class="docutils literal notranslate"><span class="pre">0</span></code>. Note that anything inheriting from
<code class="docutils literal notranslate"><span class="pre">IgnoredAttr</span></code> automatically do not get a semantic handler. All other
attributes are assumed to use a semantic handler by default. Attributes
without a semantic handler are not given a parsed attribute <code class="docutils literal notranslate"><span class="pre">Kind</span></code> enumerator.</p>
<p>“Simple” attributes, that require no custom semantic processing aside from what
is automatically provided, should set the <code class="docutils literal notranslate"><span class="pre">SimpleHandler</span></code> field to <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<p>Target-specific attributes may share a spelling with other attributes in
different targets. For instance, the ARM and MSP430 targets both have an
attribute spelled <code class="docutils literal notranslate"><span class="pre">GNU&lt;&quot;interrupt&quot;&gt;</span></code>, but with different parsing and semantic
requirements. To support this feature, an attribute inheriting from
<code class="docutils literal notranslate"><span class="pre">TargetSpecificAttribute</span></code> may specify a <code class="docutils literal notranslate"><span class="pre">ParseKind</span></code> field. This field
should be the same value between all arguments sharing a spelling, and
corresponds to the parsed attribute’s <code class="docutils literal notranslate"><span class="pre">Kind</span></code> enumerator. This allows
attributes to share a parsed attribute kind, but have distinct semantic
attribute classes. For instance, <code class="docutils literal notranslate"><span class="pre">ParsedAttr</span></code> is the shared
parsed attribute kind, but ARMInterruptAttr and MSP430InterruptAttr are the
semantic attributes generated.</p>
<p>By default, attribute arguments are parsed in an evaluated context. If the
arguments for an attribute should be parsed in an unevaluated context (akin to
the way the argument to a <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> expression is parsed), set
<code class="docutils literal notranslate"><span class="pre">ParseArgumentsAsUnevaluated</span></code> to <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<p>If additional functionality is desired for the semantic form of the attribute,
the <code class="docutils literal notranslate"><span class="pre">AdditionalMembers</span></code> field specifies code to be copied verbatim into the
semantic attribute class object, with <code class="docutils literal notranslate"><span class="pre">public</span></code> access.</p>
<p>If two or more attributes cannot be used in combination on the same declaration
or statement, a <code class="docutils literal notranslate"><span class="pre">MutualExclusions</span></code> definition can be supplied to automatically
generate diagnostic code. This will disallow the attribute combinations
regardless of spellings used. Additionally, it will diagnose combinations within
the same attribute list, different attribute list, and redeclarations, as
appropriate.</p>
</div>
</div>
<div class="section" id="boilerplate">
<h4><a class="toc-backref" href="#id80">Boilerplate</a><a class="headerlink" href="#boilerplate" title="Permalink to this headline">¶</a></h4>
<p>All semantic processing of declaration attributes happens in <a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/clang/lib/Sema/SemaDeclAttr.cpp">lib/Sema/SemaDeclAttr.cpp</a>,
and generally starts in the <code class="docutils literal notranslate"><span class="pre">ProcessDeclAttribute()</span></code> function. If the
attribute has the <code class="docutils literal notranslate"><span class="pre">SimpleHandler</span></code> field set to <code class="docutils literal notranslate"><span class="pre">1</span></code> then the function to
process the attribute will be automatically generated, and nothing needs to be
done here. Otherwise, write a new <code class="docutils literal notranslate"><span class="pre">handleYourAttr()</span></code> function, and add that to
the switch statement. Please do not implement handling logic directly in the
<code class="docutils literal notranslate"><span class="pre">case</span></code> for the attribute.</p>
<p>Unless otherwise specified by the attribute definition, common semantic checking
of the parsed attribute is handled automatically. This includes diagnosing
parsed attributes that do not appertain to the given <code class="docutils literal notranslate"><span class="pre">Decl</span></code> or <code class="docutils literal notranslate"><span class="pre">Stmt</span></code>,
ensuring the correct minimum number of arguments are passed, etc.</p>
<p>If the attribute adds additional warnings, define a <code class="docutils literal notranslate"><span class="pre">DiagGroup</span></code> in
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/DiagnosticGroups.td">include/clang/Basic/DiagnosticGroups.td</a>
named after the attribute’s <code class="docutils literal notranslate"><span class="pre">Spelling</span></code> with “_”s replaced by “-“s. If there
is only a single diagnostic, it is permissible to use <code class="docutils literal notranslate"><span class="pre">InGroup&lt;DiagGroup&lt;&quot;your-attribute&quot;&gt;&gt;</span></code>
directly in <a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/DiagnosticSemaKinds.td">DiagnosticSemaKinds.td</a></p>
<p>All semantic diagnostics generated for your attribute, including automatically-
generated ones (such as subjects and argument counts), should have a
corresponding test case.</p>
</div>
<div class="section" id="semantic-handling">
<h4><a class="toc-backref" href="#id81">Semantic handling</a><a class="headerlink" href="#semantic-handling" title="Permalink to this headline">¶</a></h4>
<p>Most attributes are implemented to have some effect on the compiler. For
instance, to modify the way code is generated, or to add extra semantic checks
for an analysis pass, etc. Having added the attribute definition and conversion
to the semantic representation for the attribute, what remains is to implement
the custom logic requiring use of the attribute.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">clang::Decl</span></code> object can be queried for the presence or absence of an
attribute using <code class="docutils literal notranslate"><span class="pre">hasAttr&lt;T&gt;()</span></code>. To obtain a pointer to the semantic
representation of the attribute, <code class="docutils literal notranslate"><span class="pre">getAttr&lt;T&gt;</span></code> may be used.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">clang::AttributedStmt</span></code> object can  be queried for the presence or absence
of an attribute by calling <code class="docutils literal notranslate"><span class="pre">getAttrs()</span></code> and looping over the list of
attributes.</p>
</div>
</div>
<div class="section" id="how-to-add-an-expression-or-statement">
<h3><a class="toc-backref" href="#id82">How to add an expression or statement</a><a class="headerlink" href="#how-to-add-an-expression-or-statement" title="Permalink to this headline">¶</a></h3>
<p>Expressions and statements are one of the most fundamental constructs within a
compiler, because they interact with many different parts of the AST, semantic
analysis, and IR generation.  Therefore, adding a new expression or statement
kind into Clang requires some care.  The following list details the various
places in Clang where an expression or statement needs to be introduced, along
with patterns to follow to ensure that the new expression or statement works
well across all of the C languages.  We focus on expressions, but statements
are similar.</p>
<ol class="arabic simple">
<li><p>Introduce parsing actions into the parser.  Recursive-descent parsing is
mostly self-explanatory, but there are a few things that are worth keeping
in mind:</p>
<ul class="simple">
<li><p>Keep as much source location information as possible! You’ll want it later
to produce great diagnostics and support Clang’s various features that map
between source code and the AST.</p></li>
<li><p>Write tests for all of the “bad” parsing cases, to make sure your recovery
is good.  If you have matched delimiters (e.g., parentheses, square
brackets, etc.), use <code class="docutils literal notranslate"><span class="pre">Parser::BalancedDelimiterTracker</span></code> to give nice
diagnostics when things go wrong.</p></li>
</ul>
</li>
<li><p>Introduce semantic analysis actions into <code class="docutils literal notranslate"><span class="pre">Sema</span></code>.  Semantic analysis should
always involve two functions: an <code class="docutils literal notranslate"><span class="pre">ActOnXXX</span></code> function that will be called
directly from the parser, and a <code class="docutils literal notranslate"><span class="pre">BuildXXX</span></code> function that performs the
actual semantic analysis and will (eventually!) build the AST node.  It’s
fairly common for the <code class="docutils literal notranslate"><span class="pre">ActOnCXX</span></code> function to do very little (often just
some minor translation from the parser’s representation to <code class="docutils literal notranslate"><span class="pre">Sema</span></code>’s
representation of the same thing), but the separation is still important:
C++ template instantiation, for example, should always call the <code class="docutils literal notranslate"><span class="pre">BuildXXX</span></code>
variant.  Several notes on semantic analysis before we get into construction
of the AST:</p>
<ul class="simple">
<li><p>Your expression probably involves some types and some subexpressions.
Make sure to fully check that those types, and the types of those
subexpressions, meet your expectations.  Add implicit conversions where
necessary to make sure that all of the types line up exactly the way you
want them.  Write extensive tests to check that you’re getting good
diagnostics for mistakes and that you can use various forms of
subexpressions with your expression.</p></li>
<li><p>When type-checking a type or subexpression, make sure to first check
whether the type is “dependent” (<code class="docutils literal notranslate"><span class="pre">Type::isDependentType()</span></code>) or whether a
subexpression is type-dependent (<code class="docutils literal notranslate"><span class="pre">Expr::isTypeDependent()</span></code>).  If any of
these return <code class="docutils literal notranslate"><span class="pre">true</span></code>, then you’re inside a template and you can’t do much
type-checking now.  That’s normal, and your AST node (when you get there)
will have to deal with this case.  At this point, you can write tests that
use your expression within templates, but don’t try to instantiate the
templates.</p></li>
<li><p>For each subexpression, be sure to call <code class="docutils literal notranslate"><span class="pre">Sema::CheckPlaceholderExpr()</span></code>
to deal with “weird” expressions that don’t behave well as subexpressions.
Then, determine whether you need to perform lvalue-to-rvalue conversions
(<code class="docutils literal notranslate"><span class="pre">Sema::DefaultLvalueConversions</span></code>) or the usual unary conversions
(<code class="docutils literal notranslate"><span class="pre">Sema::UsualUnaryConversions</span></code>), for places where the subexpression is
producing a value you intend to use.</p></li>
<li><p>Your <code class="docutils literal notranslate"><span class="pre">BuildXXX</span></code> function will probably just return <code class="docutils literal notranslate"><span class="pre">ExprError()</span></code> at
this point, since you don’t have an AST.  That’s perfectly fine, and
shouldn’t impact your testing.</p></li>
</ul>
</li>
<li><p>Introduce an AST node for your new expression.  This starts with declaring
the node in <code class="docutils literal notranslate"><span class="pre">include/Basic/StmtNodes.td</span></code> and creating a new class for your
expression in the appropriate <code class="docutils literal notranslate"><span class="pre">include/AST/Expr*.h</span></code> header.  It’s best to
look at the class for a similar expression to get ideas, and there are some
specific things to watch for:</p>
<ul class="simple">
<li><p>If you need to allocate memory, use the <code class="docutils literal notranslate"><span class="pre">ASTContext</span></code> allocator to
allocate memory.  Never use raw <code class="docutils literal notranslate"><span class="pre">malloc</span></code> or <code class="docutils literal notranslate"><span class="pre">new</span></code>, and never hold any
resources in an AST node, because the destructor of an AST node is never
called.</p></li>
<li><p>Make sure that <code class="docutils literal notranslate"><span class="pre">getSourceRange()</span></code> covers the exact source range of your
expression.  This is needed for diagnostics and for IDE support.</p></li>
<li><p>Make sure that <code class="docutils literal notranslate"><span class="pre">children()</span></code> visits all of the subexpressions.  This is
important for a number of features (e.g., IDE support, C++ variadic
templates).  If you have sub-types, you’ll also need to visit those
sub-types in <code class="docutils literal notranslate"><span class="pre">RecursiveASTVisitor</span></code>.</p></li>
<li><p>Add printing support (<code class="docutils literal notranslate"><span class="pre">StmtPrinter.cpp</span></code>) for your expression.</p></li>
<li><p>Add profiling support (<code class="docutils literal notranslate"><span class="pre">StmtProfile.cpp</span></code>) for your AST node, noting the
distinguishing (non-source location) characteristics of an instance of
your expression.  Omitting this step will lead to hard-to-diagnose
failures regarding matching of template declarations.</p></li>
<li><p>Add serialization support (<code class="docutils literal notranslate"><span class="pre">ASTReaderStmt.cpp</span></code>, <code class="docutils literal notranslate"><span class="pre">ASTWriterStmt.cpp</span></code>)
for your AST node.</p></li>
</ul>
</li>
<li><p>Teach semantic analysis to build your AST node.  At this point, you can wire
up your <code class="docutils literal notranslate"><span class="pre">Sema::BuildXXX</span></code> function to actually create your AST.  A few
things to check at this point:</p>
<ul class="simple">
<li><p>If your expression can construct a new C++ class or return a new
Objective-C object, be sure to update and then call
<code class="docutils literal notranslate"><span class="pre">Sema::MaybeBindToTemporary</span></code> for your just-created AST node to be sure
that the object gets properly destructed.  An easy way to test this is to
return a C++ class with a private destructor: semantic analysis should
flag an error here with the attempt to call the destructor.</p></li>
<li><p>Inspect the generated AST by printing it using <code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">-cc1</span> <span class="pre">-ast-print</span></code>,
to make sure you’re capturing all of the important information about how
the AST was written.</p></li>
<li><p>Inspect the generated AST under <code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">-cc1</span> <span class="pre">-ast-dump</span></code> to verify that
all of the types in the generated AST line up the way you want them.
Remember that clients of the AST should never have to “think” to
understand what’s going on.  For example, all implicit conversions should
show up explicitly in the AST.</p></li>
<li><p>Write tests that use your expression as a subexpression of other,
well-known expressions.  Can you call a function using your expression as
an argument?  Can you use the ternary operator?</p></li>
</ul>
</li>
<li><p>Teach code generation to create IR to your AST node.  This step is the first
(and only) that requires knowledge of LLVM IR.  There are several things to
keep in mind:</p>
<ul class="simple">
<li><p>Code generation is separated into scalar/aggregate/complex and
lvalue/rvalue paths, depending on what kind of result your expression
produces.  On occasion, this requires some careful factoring of code to
avoid duplication.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CodeGenFunction</span></code> contains functions <code class="docutils literal notranslate"><span class="pre">ConvertType</span></code> and
<code class="docutils literal notranslate"><span class="pre">ConvertTypeForMem</span></code> that convert Clang’s types (<code class="docutils literal notranslate"><span class="pre">clang::Type*</span></code> or
<code class="docutils literal notranslate"><span class="pre">clang::QualType</span></code>) to LLVM types.  Use the former for values, and the
latter for memory locations: test with the C++ “<code class="docutils literal notranslate"><span class="pre">bool</span></code>” type to check
this.  If you find that you are having to use LLVM bitcasts to make the
subexpressions of your expression have the type that your expression
expects, STOP!  Go fix semantic analysis and the AST so that you don’t
need these bitcasts.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">CodeGenFunction</span></code> class has a number of helper functions to make
certain operations easy, such as generating code to produce an lvalue or
an rvalue, or to initialize a memory location with a given value.  Prefer
to use these functions rather than directly writing loads and stores,
because these functions take care of some of the tricky details for you
(e.g., for exceptions).</p></li>
<li><p>If your expression requires some special behavior in the event of an
exception, look at the <code class="docutils literal notranslate"><span class="pre">push*Cleanup</span></code> functions in <code class="docutils literal notranslate"><span class="pre">CodeGenFunction</span></code>
to introduce a cleanup.  You shouldn’t have to deal with
exception-handling directly.</p></li>
<li><p>Testing is extremely important in IR generation.  Use <code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">-cc1</span>
<span class="pre">-emit-llvm</span></code> and <a class="reference external" href="https://llvm.org/docs/CommandGuide/FileCheck.html">FileCheck</a> to verify that you’re
generating the right IR.</p></li>
</ul>
</li>
<li><p>Teach template instantiation how to cope with your AST node, which requires
some fairly simple code:</p>
<ul class="simple">
<li><p>Make sure that your expression’s constructor properly computes the flags
for type dependence (i.e., the type your expression produces can change
from one instantiation to the next), value dependence (i.e., the constant
value your expression produces can change from one instantiation to the
next), instantiation dependence (i.e., a template parameter occurs
anywhere in your expression), and whether your expression contains a
parameter pack (for variadic templates).  Often, computing these flags
just means combining the results from the various types and
subexpressions.</p></li>
<li><p>Add <code class="docutils literal notranslate"><span class="pre">TransformXXX</span></code> and <code class="docutils literal notranslate"><span class="pre">RebuildXXX</span></code> functions to the <code class="docutils literal notranslate"><span class="pre">TreeTransform</span></code>
class template in <code class="docutils literal notranslate"><span class="pre">Sema</span></code>.  <code class="docutils literal notranslate"><span class="pre">TransformXXX</span></code> should (recursively)
transform all of the subexpressions and types within your expression,
using <code class="docutils literal notranslate"><span class="pre">getDerived().TransformYYY</span></code>.  If all of the subexpressions and
types transform without error, it will then call the <code class="docutils literal notranslate"><span class="pre">RebuildXXX</span></code>
function, which will in turn call <code class="docutils literal notranslate"><span class="pre">getSema().BuildXXX</span></code> to perform
semantic analysis and build your expression.</p></li>
<li><p>To test template instantiation, take those tests you wrote to make sure
that you were type checking with type-dependent expressions and dependent
types (from step #2) and instantiate those templates with various types,
some of which type-check and some that don’t, and test the error messages
in each case.</p></li>
</ul>
</li>
<li><p>There are some “extras” that make other features work better.  It’s worth
handling these extras to give your expression complete integration into
Clang:</p>
<ul class="simple">
<li><p>Add code completion support for your expression in
<code class="docutils literal notranslate"><span class="pre">SemaCodeComplete.cpp</span></code>.</p></li>
<li><p>If your expression has types in it, or has any “interesting” features
other than subexpressions, extend libclang’s <code class="docutils literal notranslate"><span class="pre">CursorVisitor</span></code> to provide
proper visitation for your expression, enabling various IDE features such
as syntax highlighting, cross-referencing, and so on.  The
<code class="docutils literal notranslate"><span class="pre">c-index-test</span></code> helper program can be used to test these features.</p></li>
</ul>
</li>
</ol>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="ClangOffloadPackager.html">Clang Offload Packager</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="DriverInternals.html">Driver Design &amp; Internals</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2007-2022, The Clang Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>
  </body>
</html>