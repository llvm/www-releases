
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clang Offload Packager &#8212; Clang 15.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="“Clang” CFE Internals Manual" href="InternalsManual.html" />
    <link rel="prev" title="Clang Offload Wrapper" href="ClangOffloadWrapper.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Clang 15.0.0 documentation</span></a></h1>
        <h2 class="heading"><span>Clang Offload Packager</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="ClangOffloadWrapper.html">Clang Offload Wrapper</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="InternalsManual.html">“Clang” CFE Internals Manual</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <div class="section" id="clang-offload-packager">
<h1>Clang Offload Packager<a class="headerlink" href="#clang-offload-packager" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id2">Introduction</a></p></li>
<li><p><a class="reference internal" href="#binary-format" id="id3">Binary Format</a></p></li>
<li><p><a class="reference internal" href="#usage" id="id4">Usage</a></p></li>
<li><p><a class="reference internal" href="#example" id="id5">Example</a></p></li>
</ul>
</div>
<div class="section" id="introduction">
<span id="id1"></span><h2><a class="toc-backref" href="#id2">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This tool bundles device files into a single image containing necessary
metadata. We use a custom binary format for bundling all the device images
together. The image format is a small header wrapping around a string map. This
tool creates bundled binaries so that they can be embedded into the host to
create a fat-binary.</p>
</div>
<div class="section" id="binary-format">
<h2><a class="toc-backref" href="#id3">Binary Format</a><a class="headerlink" href="#binary-format" title="Permalink to this headline">¶</a></h2>
<p>The binary format is marked by the <code class="docutils literal notranslate"><span class="pre">0x10FF10AD</span></code> magic bytes, followed by a
version. Each created binary contains its own magic bytes. This allows us to
locate all the embedded offloading sections even after they may have been merged
by the linker, such as when using relocatable linking. Conceptually, this binary
format is a serialization of a string map and an image buffer. The binary header
is described in the following <a class="reference internal" href="#table-binary-header"><span class="std std-ref">table</span></a>.</p>
<table class="docutils align-default" id="table-binary-header">
<caption><span class="caption-text">Offloading Binary Header</span><a class="headerlink" href="#table-binary-header" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 13%" />
<col style="width: 18%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Type</p></th>
<th class="head"><p>Identifier</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint8_t</p></td>
<td><p>magic</p></td>
<td><p>The magic bytes for the binary format (0x10FF10AD)</p></td>
</tr>
<tr class="row-odd"><td><p>uint32_t</p></td>
<td><p>version</p></td>
<td><p>Version of this format (currently version 1)</p></td>
</tr>
<tr class="row-even"><td><p>uint64_t</p></td>
<td><p>size</p></td>
<td><p>Size of this binary in bytes</p></td>
</tr>
<tr class="row-odd"><td><p>uint64_t</p></td>
<td><p>entry offset</p></td>
<td><p>Absolute offset of the offload entries in bytes</p></td>
</tr>
<tr class="row-even"><td><p>uint64_t</p></td>
<td><p>entry size</p></td>
<td><p>Size of the offload entries in bytes</p></td>
</tr>
</tbody>
</table>
<p>Once identified through the magic bytes, we use the size field to take a slice
of the binary blob containing the information for a single offloading image. We
can then use the offset field to find the actual offloading entries containing
the image and metadata. The offload entry contains information about the device
image. It contains the fields shown in the following
<a class="reference internal" href="#table-binary-entry"><span class="std std-ref">table</span></a>.</p>
<table class="docutils align-default" id="table-binary-entry">
<caption><span class="caption-text">Offloading Entry Table</span><a class="headerlink" href="#table-binary-entry" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 13%" />
<col style="width: 19%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Type</p></th>
<th class="head"><p>Identifier</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint16_t</p></td>
<td><p>image kind</p></td>
<td><p>The kind of the device image (e.g. bc, cubin)</p></td>
</tr>
<tr class="row-odd"><td><p>uint16_t</p></td>
<td><p>offload kind</p></td>
<td><p>The producer of the image (e.g. openmp, cuda)</p></td>
</tr>
<tr class="row-even"><td><p>uint32_t</p></td>
<td><p>flags</p></td>
<td><p>Generic flags for the image</p></td>
</tr>
<tr class="row-odd"><td><p>uint64_t</p></td>
<td><p>string offset</p></td>
<td><p>Absolute offset of the string metadata table</p></td>
</tr>
<tr class="row-even"><td><p>uint64_t</p></td>
<td><p>num strings</p></td>
<td><p>Number of string entries in the table</p></td>
</tr>
<tr class="row-odd"><td><p>uint64_t</p></td>
<td><p>image offset</p></td>
<td><p>Absolute offset of the device image in bytes</p></td>
</tr>
<tr class="row-even"><td><p>uint64_t</p></td>
<td><p>image size</p></td>
<td><p>Size of the device image in bytes</p></td>
</tr>
</tbody>
</table>
<p>This table contains the offsets of the string table and the device image itself
along with some other integer information. The image kind lets us easily
identify the type of image stored here without needing to inspect the binary.
The offloading kind is used to determine which registration code or linking
semantics are necessary for this image. These are stored as enumerations with
the following values for the <a class="reference internal" href="#table-offload-kind"><span class="std std-ref">offload kind</span></a> and the
<a class="reference internal" href="#table-image-kind"><span class="std std-ref">image kind</span></a>.</p>
<table class="docutils align-default" id="table-image-kind">
<caption><span class="caption-text">Image Kind</span><a class="headerlink" href="#table-image-kind" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 11%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>IMG_None</p></td>
<td><p>0x00</p></td>
<td><p>No image information provided</p></td>
</tr>
<tr class="row-odd"><td><p>IMG_Object</p></td>
<td><p>0x01</p></td>
<td><p>The image is a generic object file</p></td>
</tr>
<tr class="row-even"><td><p>IMG_Bitcode</p></td>
<td><p>0x02</p></td>
<td><p>The image is an LLVM-IR bitcode file</p></td>
</tr>
<tr class="row-odd"><td><p>IMG_Cubin</p></td>
<td><p>0x03</p></td>
<td><p>The image is a CUDA object file</p></td>
</tr>
<tr class="row-even"><td><p>IMG_Fatbinary</p></td>
<td><p>0x04</p></td>
<td><p>The image is a CUDA fatbinary file</p></td>
</tr>
<tr class="row-odd"><td><p>IMG_PTX</p></td>
<td><p>0x05</p></td>
<td><p>The image is a CUDA PTX file</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="table-offload-kind">
<caption><span class="caption-text">Offload Kind</span><a class="headerlink" href="#table-offload-kind" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 12%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>OFK_None</p></td>
<td><p>0x00</p></td>
<td><p>No offloading information provided</p></td>
</tr>
<tr class="row-odd"><td><p>OFK_OpenMP</p></td>
<td><p>0x01</p></td>
<td><p>The producer was OpenMP offloading</p></td>
</tr>
<tr class="row-even"><td><p>OFK_CUDA</p></td>
<td><p>0x02</p></td>
<td><p>The producer was CUDA</p></td>
</tr>
<tr class="row-odd"><td><p>OFK_HIP</p></td>
<td><p>0x03</p></td>
<td><p>The producer was HIP</p></td>
</tr>
</tbody>
</table>
<p>The flags are used to signify certain conditions, such as the presence of
debugging information or whether or not LTO was used. The string entry table is
used to generically contain any arbitrary key-value pair. This is stored as an
array of the <a class="reference internal" href="#table-binary-string"><span class="std std-ref">string entry</span></a> format.</p>
<table class="docutils align-default" id="table-binary-string">
<caption><span class="caption-text">Offloading String Entry</span><a class="headerlink" href="#table-binary-string" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 13%" />
<col style="width: 18%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Type</p></th>
<th class="head"><p>Identifier</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>uint64_t</p></td>
<td><p>key offset</p></td>
<td><p>Absolute byte offset of the key in th string table</p></td>
</tr>
<tr class="row-odd"><td><p>uint64_t</p></td>
<td><p>value offset</p></td>
<td><p>Absolute byte offset of the value in the string table</p></td>
</tr>
</tbody>
</table>
<p>The string entries simply provide offsets to a key and value pair in the
binary images string table. The string table is simply a collection of null
terminated strings with defined offsets in the image. The string entry allows us
to create a key-value pair from this string table. This is used for passing
arbitrary arguments to the image, such as the triple and architecture.</p>
<p>All of these structures are combined to form a single binary blob, the order
does not matter because of the use of absolute offsets. This makes it easier to
extend in the future. As mentioned previously, multiple offloading images are
bundled together by simply concatenating them in this format. Because we have
the magic bytes and size of each image, we can extract them as-needed.</p>
</div>
<div class="section" id="usage">
<h2><a class="toc-backref" href="#id4">Usage</a><a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<p>This tool can be used with the following arguments. Generally information is
passed as a key-value pair to the <code class="docutils literal notranslate"><span class="pre">image=</span></code> argument. The <code class="docutils literal notranslate"><span class="pre">file</span></code>, <code class="docutils literal notranslate"><span class="pre">triple</span></code>,
and <code class="docutils literal notranslate"><span class="pre">arch</span></code> arguments are considered mandatory to make a valid image.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">OVERVIEW: A utility for bundling several object files into a single binary.</span>
<span class="go">The output binary can then be embedded into the host section table</span>
<span class="go">to create a fatbinary containing offloading code.</span>

<span class="go">USAGE: clang-offload-packager [options]</span>

<span class="go">OPTIONS:</span>

<span class="go">Generic Options:</span>

<span class="go">  --help                      - Display available options (--help-hidden for more)</span>
<span class="go">  --help-list                 - Display list of available options (--help-list-hidden for more)</span>
<span class="go">  --version                   - Display the version of this program</span>

<span class="go">clang-offload-packager options:</span>

<span class="go">  --image=&lt;&lt;key&gt;=&lt;value&gt;,...&gt; - List of key and value arguments. Required</span>
<span class="go">                                keywords are &#39;file&#39; and &#39;triple&#39;.</span>
<span class="go">  -o &lt;file&gt;                   - Write output to &lt;file&gt;.</span>
</pre></div>
</div>
</div>
<div class="section" id="example">
<h2><a class="toc-backref" href="#id5">Example</a><a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h2>
<p>This tool simply takes many input files from the <code class="docutils literal notranslate"><span class="pre">image</span></code> option and creates a
single output file with all the images combined.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">clang-offload-packager -o out.bin --image=file=input.o,triple=nvptx64,arch=sm_70</span>
</pre></div>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="ClangOffloadWrapper.html">Clang Offload Wrapper</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="InternalsManual.html">“Clang” CFE Internals Manual</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2007-2022, The Clang Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>
  </body>
</html>