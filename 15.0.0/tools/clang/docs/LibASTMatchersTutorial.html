
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tutorial for building tools using LibTooling and LibASTMatchers &#8212; Clang 15.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Matching the Clang AST" href="LibASTMatchers.html" />
    <link rel="prev" title="How to write RecursiveASTVisitor based ASTFrontendActions." href="RAVFrontendAction.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Clang 15.0.0 documentation</span></a></h1>
        <h2 class="heading"><span>Tutorial for building tools using LibTooling and LibASTMatchers</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="RAVFrontendAction.html">How to write RecursiveASTVisitor based ASTFrontendActions.</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="LibASTMatchers.html">Matching the Clang AST</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <div class="section" id="tutorial-for-building-tools-using-libtooling-and-libastmatchers">
<h1>Tutorial for building tools using LibTooling and LibASTMatchers<a class="headerlink" href="#tutorial-for-building-tools-using-libtooling-and-libastmatchers" title="Permalink to this headline">¶</a></h1>
<p>This document is intended to show how to build a useful source-to-source
translation tool based on Clang’s <a class="reference external" href="LibTooling.html">LibTooling</a>. It is
explicitly aimed at people who are new to Clang, so all you should need
is a working knowledge of C++ and the command line.</p>
<p>In order to work on the compiler, you need some basic knowledge of the
abstract syntax tree (AST). To this end, the reader is encouraged to
skim the <a class="reference internal" href="IntroductionToTheClangAST.html"><span class="doc">Introduction to the Clang
AST</span></a></p>
<div class="section" id="step-0-obtaining-clang">
<h2>Step 0: Obtaining Clang<a class="headerlink" href="#step-0-obtaining-clang" title="Permalink to this headline">¶</a></h2>
<p>As Clang is part of the LLVM project, you’ll need to download LLVM’s
source code first. Both Clang and LLVM are in the same git repository,
under different directories. For further information, see the <a class="reference external" href="https://llvm.org/docs/GettingStarted.html">getting
started guide</a>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">cd ~/clang-llvm</span>
<span class="go">git clone https://github.com/llvm/llvm-project.git</span>
</pre></div>
</div>
<p>Next you need to obtain the CMake build system and Ninja build tool.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">cd ~/clang-llvm</span>
<span class="go">git clone https://github.com/martine/ninja.git</span>
<span class="go">cd ninja</span>
<span class="go">git checkout release</span>
<span class="go">./bootstrap.py</span>
<span class="go">sudo cp ninja /usr/bin/</span>

<span class="go">cd ~/clang-llvm</span>
<span class="go">git clone git://cmake.org/stage/cmake.git</span>
<span class="go">cd cmake</span>
<span class="go">git checkout next</span>
<span class="go">./bootstrap</span>
<span class="go">make</span>
<span class="go">sudo make install</span>
</pre></div>
</div>
<p>Okay. Now we’ll build Clang!</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">cd ~/clang-llvm</span>
<span class="go">mkdir build &amp;&amp; cd build</span>
<span class="go">cmake -G Ninja ../llvm -DLLVM_ENABLE_PROJECTS=&quot;clang;clang-tools-extra&quot; -DLLVM_BUILD_TESTS=ON  # Enable tests; default is off.</span>
<span class="go">ninja</span>
<span class="go">ninja check       # Test LLVM only.</span>
<span class="go">ninja clang-test  # Test Clang only.</span>
<span class="go">ninja install</span>
</pre></div>
</div>
<p>And we’re live.</p>
<p>All of the tests should pass.</p>
<p>Finally, we want to set Clang as its own compiler.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">cd ~/clang-llvm/build</span>
<span class="go">ccmake ../llvm</span>
</pre></div>
</div>
<p>The second command will bring up a GUI for configuring Clang. You need
to set the entry for <code class="docutils literal notranslate"><span class="pre">CMAKE_CXX_COMPILER</span></code>. Press <code class="docutils literal notranslate"><span class="pre">'t'</span></code> to turn on
advanced mode. Scroll down to <code class="docutils literal notranslate"><span class="pre">CMAKE_CXX_COMPILER</span></code>, and set it to
<code class="docutils literal notranslate"><span class="pre">/usr/bin/clang++</span></code>, or wherever you installed it. Press <code class="docutils literal notranslate"><span class="pre">'c'</span></code> to
configure, then <code class="docutils literal notranslate"><span class="pre">'g'</span></code> to generate CMake’s files.</p>
<p>Finally, run ninja one last time, and you’re done.</p>
</div>
<div class="section" id="step-1-create-a-clangtool">
<h2>Step 1: Create a ClangTool<a class="headerlink" href="#step-1-create-a-clangtool" title="Permalink to this headline">¶</a></h2>
<p>Now that we have enough background knowledge, it’s time to create the
simplest productive ClangTool in existence: a syntax checker. While this
already exists as <code class="docutils literal notranslate"><span class="pre">clang-check</span></code>, it’s important to understand what’s
going on.</p>
<p>First, we’ll need to create a new directory for our tool and tell CMake
that it exists. As this is not going to be a core clang tool, it will
live in the <code class="docutils literal notranslate"><span class="pre">clang-tools-extra</span></code> repository.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">cd ~/clang-llvm</span>
<span class="go">mkdir clang-tools-extra/loop-convert</span>
<span class="go">echo &#39;add_subdirectory(loop-convert)&#39; &gt;&gt; clang-tools-extra/CMakeLists.txt</span>
<span class="go">vim clang-tools-extra/loop-convert/CMakeLists.txt</span>
</pre></div>
</div>
<p>CMakeLists.txt should have the following contents:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span><span class="p">(</span><span class="n">LLVM_LINK_COMPONENTS</span> <span class="n">support</span><span class="p">)</span>

<span class="n">add_clang_executable</span><span class="p">(</span><span class="n">loop</span><span class="o">-</span><span class="n">convert</span>
  <span class="n">LoopConvert</span><span class="o">.</span><span class="n">cpp</span>
  <span class="p">)</span>
<span class="n">target_link_libraries</span><span class="p">(</span><span class="n">loop</span><span class="o">-</span><span class="n">convert</span>
  <span class="n">PRIVATE</span>
  <span class="n">clangAST</span>
  <span class="n">clangASTMatchers</span>
  <span class="n">clangBasic</span>
  <span class="n">clangFrontend</span>
  <span class="n">clangSerialization</span>
  <span class="n">clangTooling</span>
  <span class="p">)</span>
</pre></div>
</div>
<p>With that done, Ninja will be able to compile our tool. Let’s give it
something to compile! Put the following into
<code class="docutils literal notranslate"><span class="pre">clang-tools-extra/loop-convert/LoopConvert.cpp</span></code>. A detailed explanation of
why the different parts are needed can be found in the <a class="reference external" href="LibTooling.html">LibTooling
documentation</a>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Declares clang::SyntaxOnlyAction.</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;clang/Frontend/FrontendActions.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;clang/Tooling/CommonOptionsParser.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;clang/Tooling/Tooling.h&quot;</span><span class="cp"></span>
<span class="c1">// Declares llvm::cl::extrahelp.</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;llvm/Support/CommandLine.h&quot;</span><span class="cp"></span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">clang</span><span class="o">::</span><span class="nn">tooling</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">llvm</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Apply a custom category to all command-line options so that they are the</span>
<span class="c1">// only ones displayed.</span>
<span class="k">static</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">cl</span><span class="o">::</span><span class="n">OptionCategory</span><span class="w"> </span><span class="nf">MyToolCategory</span><span class="p">(</span><span class="s">&quot;my-tool options&quot;</span><span class="p">);</span><span class="w"></span>

<span class="c1">// CommonOptionsParser declares HelpMessage with a description of the common</span>
<span class="c1">// command-line options related to the compilation database and input files.</span>
<span class="c1">// It&#39;s nice to have this help message in all tools.</span>
<span class="k">static</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">extrahelp</span><span class="w"> </span><span class="nf">CommonHelp</span><span class="p">(</span><span class="n">CommonOptionsParser</span><span class="o">::</span><span class="n">HelpMessage</span><span class="p">);</span><span class="w"></span>

<span class="c1">// A help message for this specific tool can be added afterwards.</span>
<span class="k">static</span><span class="w"> </span><span class="n">cl</span><span class="o">::</span><span class="n">extrahelp</span><span class="w"> </span><span class="nf">MoreHelp</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">More help text...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">ExpectedParser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CommonOptionsParser</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">,</span><span class="w"> </span><span class="n">MyToolCategory</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ExpectedParser</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Fail gracefully for unsupported options.</span>
<span class="w">    </span><span class="n">llvm</span><span class="o">::</span><span class="n">errs</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ExpectedParser</span><span class="p">.</span><span class="n">takeError</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">CommonOptionsParser</span><span class="o">&amp;</span><span class="w"> </span><span class="n">OptionsParser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExpectedParser</span><span class="p">.</span><span class="n">get</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">ClangTool</span><span class="w"> </span><span class="n">Tool</span><span class="p">(</span><span class="n">OptionsParser</span><span class="p">.</span><span class="n">getCompilations</span><span class="p">(),</span><span class="w"></span>
<span class="w">                 </span><span class="n">OptionsParser</span><span class="p">.</span><span class="n">getSourcePathList</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Tool</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">newFrontendActionFactory</span><span class="o">&lt;</span><span class="n">clang</span><span class="o">::</span><span class="n">SyntaxOnlyAction</span><span class="o">&gt;</span><span class="p">().</span><span class="n">get</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>And that’s it! You can compile our new tool by running ninja from the
<code class="docutils literal notranslate"><span class="pre">build</span></code> directory.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">cd ~/clang-llvm/build</span>
<span class="go">ninja</span>
</pre></div>
</div>
<p>You should now be able to run the syntax checker, which is located in
<code class="docutils literal notranslate"><span class="pre">~/clang-llvm/build/bin</span></code>, on any source file. Try it!</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">echo &quot;int main() { return 0; }&quot; &gt; test.cpp</span>
<span class="go">bin/loop-convert test.cpp --</span>
</pre></div>
</div>
<p>Note the two dashes after we specify the source file. The additional
options for the compiler are passed after the dashes rather than loading
them from a compilation database - there just aren’t any options needed
right now.</p>
</div>
<div class="section" id="intermezzo-learn-ast-matcher-basics">
<h2>Intermezzo: Learn AST matcher basics<a class="headerlink" href="#intermezzo-learn-ast-matcher-basics" title="Permalink to this headline">¶</a></h2>
<p>Clang recently introduced the <a class="reference internal" href="LibASTMatchers.html"><span class="doc">ASTMatcher
library</span></a> to provide a simple, powerful, and
concise way to describe specific patterns in the AST. Implemented as a
DSL powered by macros and templates (see
<a class="reference external" href="../doxygen/ASTMatchers_8h_source.html">ASTMatchers.h</a> if you’re
curious), matchers offer the feel of algebraic data types common to
functional programming languages.</p>
<p>For example, suppose you wanted to examine only binary operators. There
is a matcher to do exactly that, conveniently named <code class="docutils literal notranslate"><span class="pre">binaryOperator</span></code>.
I’ll give you one guess what this matcher does:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">binaryOperator</span><span class="p">(</span><span class="n">hasOperatorName</span><span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">hasLHS</span><span class="p">(</span><span class="n">integerLiteral</span><span class="p">(</span><span class="n">equals</span><span class="p">(</span><span class="mi">0</span><span class="p">))))</span><span class="w"></span>
</pre></div>
</div>
<p>Shockingly, it will match against addition expressions whose left hand
side is exactly the literal 0. It will not match against other forms of
0, such as <code class="docutils literal notranslate"><span class="pre">'\0'</span></code> or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, but it will match against macros that
expand to 0. The matcher will also not match against calls to the
overloaded operator <code class="docutils literal notranslate"><span class="pre">'+'</span></code>, as there is a separate <code class="docutils literal notranslate"><span class="pre">operatorCallExpr</span></code>
matcher to handle overloaded operators.</p>
<p>There are AST matchers to match all the different nodes of the AST,
narrowing matchers to only match AST nodes fulfilling specific criteria,
and traversal matchers to get from one kind of AST node to another. For
a complete list of AST matchers, take a look at the <a class="reference external" href="LibASTMatchersReference.html">AST Matcher
References</a></p>
<p>All matcher that are nouns describe entities in the AST and can be
bound, so that they can be referred to whenever a match is found. To do
so, simply call the method <code class="docutils literal notranslate"><span class="pre">bind</span></code> on these matchers, e.g.:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">variable</span><span class="p">(</span><span class="n">hasType</span><span class="p">(</span><span class="n">isInteger</span><span class="p">())).</span><span class="n">bind</span><span class="p">(</span><span class="s">&quot;intvar&quot;</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="step-2-using-ast-matchers">
<h2>Step 2: Using AST matchers<a class="headerlink" href="#step-2-using-ast-matchers" title="Permalink to this headline">¶</a></h2>
<p>Okay, on to using matchers for real. Let’s start by defining a matcher
which will capture all <code class="docutils literal notranslate"><span class="pre">for</span></code> statements that define a new variable
initialized to zero. Let’s start with matching all <code class="docutils literal notranslate"><span class="pre">for</span></code> loops:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">forStmt</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>Next, we want to specify that a single variable is declared in the first
portion of the loop, so we can extend the matcher to</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">forStmt</span><span class="p">(</span><span class="n">hasLoopInit</span><span class="p">(</span><span class="n">declStmt</span><span class="p">(</span><span class="n">hasSingleDecl</span><span class="p">(</span><span class="n">varDecl</span><span class="p">()))))</span><span class="w"></span>
</pre></div>
</div>
<p>Finally, we can add the condition that the variable is initialized to
zero.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">forStmt</span><span class="p">(</span><span class="n">hasLoopInit</span><span class="p">(</span><span class="n">declStmt</span><span class="p">(</span><span class="n">hasSingleDecl</span><span class="p">(</span><span class="n">varDecl</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="n">hasInitializer</span><span class="p">(</span><span class="n">integerLiteral</span><span class="p">(</span><span class="n">equals</span><span class="p">(</span><span class="mi">0</span><span class="p">))))))))</span><span class="w"></span>
</pre></div>
</div>
<p>It is fairly easy to read and understand the matcher definition (“match
loops whose init portion declares a single variable which is initialized
to the integer literal 0”), but deciding that every piece is necessary
is more difficult. Note that this matcher will not match loops whose
variables are initialized to <code class="docutils literal notranslate"><span class="pre">'\0'</span></code>, <code class="docutils literal notranslate"><span class="pre">0.0</span></code>, <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, or any form of
zero besides the integer 0.</p>
<p>The last step is giving the matcher a name and binding the <code class="docutils literal notranslate"><span class="pre">ForStmt</span></code>
as we will want to do something with it:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">StatementMatcher</span><span class="w"> </span><span class="n">LoopMatcher</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="n">forStmt</span><span class="p">(</span><span class="n">hasLoopInit</span><span class="p">(</span><span class="n">declStmt</span><span class="p">(</span><span class="n">hasSingleDecl</span><span class="p">(</span><span class="n">varDecl</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">hasInitializer</span><span class="p">(</span><span class="n">integerLiteral</span><span class="p">(</span><span class="n">equals</span><span class="p">(</span><span class="mi">0</span><span class="p">)))))))).</span><span class="n">bind</span><span class="p">(</span><span class="s">&quot;forLoop&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Once you have defined your matchers, you will need to add a little more
scaffolding in order to run them. Matchers are paired with a
<code class="docutils literal notranslate"><span class="pre">MatchCallback</span></code> and registered with a <code class="docutils literal notranslate"><span class="pre">MatchFinder</span></code> object, then run
from a <code class="docutils literal notranslate"><span class="pre">ClangTool</span></code>. More code!</p>
<p>Add the following to <code class="docutils literal notranslate"><span class="pre">LoopConvert.cpp</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;clang/ASTMatchers/ASTMatchers.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;clang/ASTMatchers/ASTMatchFinder.h&quot;</span><span class="cp"></span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">clang</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">clang</span><span class="o">::</span><span class="nn">ast_matchers</span><span class="p">;</span><span class="w"></span>

<span class="n">StatementMatcher</span><span class="w"> </span><span class="n">LoopMatcher</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="n">forStmt</span><span class="p">(</span><span class="n">hasLoopInit</span><span class="p">(</span><span class="n">declStmt</span><span class="p">(</span><span class="n">hasSingleDecl</span><span class="p">(</span><span class="n">varDecl</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">hasInitializer</span><span class="p">(</span><span class="n">integerLiteral</span><span class="p">(</span><span class="n">equals</span><span class="p">(</span><span class="mi">0</span><span class="p">)))))))).</span><span class="n">bind</span><span class="p">(</span><span class="s">&quot;forLoop&quot;</span><span class="p">);</span><span class="w"></span>

<span class="k">class</span> <span class="nc">LoopPrinter</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">MatchFinder</span><span class="o">::</span><span class="n">MatchCallback</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="w"> </span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">run</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MatchFinder</span><span class="o">::</span><span class="n">MatchResult</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ForStmt</span><span class="w"> </span><span class="o">*</span><span class="n">FS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Result</span><span class="p">.</span><span class="n">Nodes</span><span class="p">.</span><span class="n">getNodeAs</span><span class="o">&lt;</span><span class="n">clang</span><span class="o">::</span><span class="n">ForStmt</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;forLoop&quot;</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="n">FS</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>And change <code class="docutils literal notranslate"><span class="pre">main()</span></code> to:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">ExpectedParser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CommonOptionsParser</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">,</span><span class="w"> </span><span class="n">MyToolCategory</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ExpectedParser</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Fail gracefully for unsupported options.</span>
<span class="w">    </span><span class="n">llvm</span><span class="o">::</span><span class="n">errs</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ExpectedParser</span><span class="p">.</span><span class="n">takeError</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">CommonOptionsParser</span><span class="o">&amp;</span><span class="w"> </span><span class="n">OptionsParser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExpectedParser</span><span class="p">.</span><span class="n">get</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">ClangTool</span><span class="w"> </span><span class="n">Tool</span><span class="p">(</span><span class="n">OptionsParser</span><span class="p">.</span><span class="n">getCompilations</span><span class="p">(),</span><span class="w"></span>
<span class="w">                 </span><span class="n">OptionsParser</span><span class="p">.</span><span class="n">getSourcePathList</span><span class="p">());</span><span class="w"></span>

<span class="w">  </span><span class="n">LoopPrinter</span><span class="w"> </span><span class="n">Printer</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">MatchFinder</span><span class="w"> </span><span class="n">Finder</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">Finder</span><span class="p">.</span><span class="n">addMatcher</span><span class="p">(</span><span class="n">LoopMatcher</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Printer</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Tool</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">newFrontendActionFactory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Finder</span><span class="p">).</span><span class="n">get</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Now, you should be able to recompile and run the code to discover for
loops. Create a new file with a few examples, and test out our new
handiwork:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">cd ~/clang-llvm/llvm/llvm_build/</span>
<span class="go">ninja loop-convert</span>
<span class="go">vim ~/test-files/simple-loops.cc</span>
<span class="go">bin/loop-convert ~/test-files/simple-loops.cc</span>
</pre></div>
</div>
</div>
<div class="section" id="step-3-5-more-complicated-matchers">
<h2>Step 3.5: More Complicated Matchers<a class="headerlink" href="#step-3-5-more-complicated-matchers" title="Permalink to this headline">¶</a></h2>
<p>Our simple matcher is capable of discovering for loops, but we would
still need to filter out many more ourselves. We can do a good portion
of the remaining work with some cleverly chosen matchers, but first we
need to decide exactly which properties we want to allow.</p>
<p>How can we characterize for loops over arrays which would be eligible
for translation to range-based syntax? Range based loops over arrays of
size <code class="docutils literal notranslate"><span class="pre">N</span></code> that:</p>
<ul class="simple">
<li><p>start at index <code class="docutils literal notranslate"><span class="pre">0</span></code></p></li>
<li><p>iterate consecutively</p></li>
<li><p>end at index <code class="docutils literal notranslate"><span class="pre">N-1</span></code></p></li>
</ul>
<p>We already check for (1), so all we need to add is a check to the loop’s
condition to ensure that the loop’s index variable is compared against
<code class="docutils literal notranslate"><span class="pre">N</span></code> and another check to ensure that the increment step just
increments this same variable. The matcher for (2) is straightforward:
require a pre- or post-increment of the same variable declared in the
init portion.</p>
<p>Unfortunately, such a matcher is impossible to write. Matchers contain
no logic for comparing two arbitrary AST nodes and determining whether
or not they are equal, so the best we can do is matching more than we
would like to allow, and punting extra comparisons to the callback.</p>
<p>In any case, we can start building this sub-matcher. We can require that
the increment step be a unary increment like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">hasIncrement</span><span class="p">(</span><span class="n">unaryOperator</span><span class="p">(</span><span class="n">hasOperatorName</span><span class="p">(</span><span class="s">&quot;++&quot;</span><span class="p">)))</span><span class="w"></span>
</pre></div>
</div>
<p>Specifying what is incremented introduces another quirk of Clang’s AST:
Usages of variables are represented as <code class="docutils literal notranslate"><span class="pre">DeclRefExpr</span></code>’s (“declaration
reference expressions”) because they are expressions which refer to
variable declarations. To find a <code class="docutils literal notranslate"><span class="pre">unaryOperator</span></code> that refers to a
specific declaration, we can simply add a second condition to it:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">hasIncrement</span><span class="p">(</span><span class="n">unaryOperator</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="n">hasOperatorName</span><span class="p">(</span><span class="s">&quot;++&quot;</span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="n">hasUnaryOperand</span><span class="p">(</span><span class="n">declRefExpr</span><span class="p">())))</span><span class="w"></span>
</pre></div>
</div>
<p>Furthermore, we can restrict our matcher to only match if the
incremented variable is an integer:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">hasIncrement</span><span class="p">(</span><span class="n">unaryOperator</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="n">hasOperatorName</span><span class="p">(</span><span class="s">&quot;++&quot;</span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="n">hasUnaryOperand</span><span class="p">(</span><span class="n">declRefExpr</span><span class="p">(</span><span class="n">to</span><span class="p">(</span><span class="n">varDecl</span><span class="p">(</span><span class="n">hasType</span><span class="p">(</span><span class="n">isInteger</span><span class="p">())))))))</span><span class="w"></span>
</pre></div>
</div>
<p>And the last step will be to attach an identifier to this variable, so
that we can retrieve it in the callback:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">hasIncrement</span><span class="p">(</span><span class="n">unaryOperator</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="n">hasOperatorName</span><span class="p">(</span><span class="s">&quot;++&quot;</span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="n">hasUnaryOperand</span><span class="p">(</span><span class="n">declRefExpr</span><span class="p">(</span><span class="n">to</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">varDecl</span><span class="p">(</span><span class="n">hasType</span><span class="p">(</span><span class="n">isInteger</span><span class="p">())).</span><span class="n">bind</span><span class="p">(</span><span class="s">&quot;incrementVariable&quot;</span><span class="p">))))))</span><span class="w"></span>
</pre></div>
</div>
<p>We can add this code to the definition of <code class="docutils literal notranslate"><span class="pre">LoopMatcher</span></code> and make sure
that our program, outfitted with the new matcher, only prints out loops
that declare a single variable initialized to zero and have an increment
step consisting of a unary increment of some variable.</p>
<p>Now, we just need to add a matcher to check if the condition part of the
<code class="docutils literal notranslate"><span class="pre">for</span></code> loop compares a variable against the size of the array. There is
only one problem - we don’t know which array we’re iterating over
without looking at the body of the loop! We are again restricted to
approximating the result we want with matchers, filling in the details
in the callback. So we start with:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">hasCondition</span><span class="p">(</span><span class="n">binaryOperator</span><span class="p">(</span><span class="n">hasOperatorName</span><span class="p">(</span><span class="s">&quot;&lt;&quot;</span><span class="p">)))</span><span class="w"></span>
</pre></div>
</div>
<p>It makes sense to ensure that the left-hand side is a reference to a
variable, and that the right-hand side has integer type.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">hasCondition</span><span class="p">(</span><span class="n">binaryOperator</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="n">hasOperatorName</span><span class="p">(</span><span class="s">&quot;&lt;&quot;</span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="n">hasLHS</span><span class="p">(</span><span class="n">declRefExpr</span><span class="p">(</span><span class="n">to</span><span class="p">(</span><span class="n">varDecl</span><span class="p">(</span><span class="n">hasType</span><span class="p">(</span><span class="n">isInteger</span><span class="p">()))))),</span><span class="w"></span>
<span class="w">  </span><span class="n">hasRHS</span><span class="p">(</span><span class="n">expr</span><span class="p">(</span><span class="n">hasType</span><span class="p">(</span><span class="n">isInteger</span><span class="p">())))))</span><span class="w"></span>
</pre></div>
</div>
<p>Why? Because it doesn’t work. Of the three loops provided in
<code class="docutils literal notranslate"><span class="pre">test-files/simple.cpp</span></code>, zero of them have a matching condition. A
quick look at the AST dump of the first for loop, produced by the
previous iteration of loop-convert, shows us the answer:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">ForStmt</span> <span class="mh">0x173b240</span>
  <span class="p">(</span><span class="n">DeclStmt</span> <span class="mh">0x173afc8</span>
    <span class="mh">0x173af50</span> <span class="s2">&quot;int i =</span>
      <span class="p">(</span><span class="n">IntegerLiteral</span> <span class="mh">0x173afa8</span> <span class="s1">&#39;int&#39;</span> <span class="mi">0</span><span class="p">)</span><span class="s2">&quot;)</span>
  <span class="o">&lt;&lt;&gt;&gt;</span>
  <span class="p">(</span><span class="n">BinaryOperator</span> <span class="mh">0x173b060</span> <span class="s1">&#39;_Bool&#39;</span> <span class="s1">&#39;&lt;&#39;</span>
    <span class="p">(</span><span class="n">ImplicitCastExpr</span> <span class="mh">0x173b030</span> <span class="s1">&#39;int&#39;</span>
      <span class="p">(</span><span class="n">DeclRefExpr</span> <span class="mh">0x173afe0</span> <span class="s1">&#39;int&#39;</span> <span class="n">lvalue</span> <span class="n">Var</span> <span class="mh">0x173af50</span> <span class="s1">&#39;i&#39;</span> <span class="s1">&#39;int&#39;</span><span class="p">))</span>
    <span class="p">(</span><span class="n">ImplicitCastExpr</span> <span class="mh">0x173b048</span> <span class="s1">&#39;int&#39;</span>
      <span class="p">(</span><span class="n">DeclRefExpr</span> <span class="mh">0x173b008</span> <span class="s1">&#39;const int&#39;</span> <span class="n">lvalue</span> <span class="n">Var</span> <span class="mh">0x170fa80</span> <span class="s1">&#39;N&#39;</span> <span class="s1">&#39;const int&#39;</span><span class="p">)))</span>
  <span class="p">(</span><span class="n">UnaryOperator</span> <span class="mh">0x173b0b0</span> <span class="s1">&#39;int&#39;</span> <span class="n">lvalue</span> <span class="n">prefix</span> <span class="s1">&#39;++&#39;</span>
    <span class="p">(</span><span class="n">DeclRefExpr</span> <span class="mh">0x173b088</span> <span class="s1">&#39;int&#39;</span> <span class="n">lvalue</span> <span class="n">Var</span> <span class="mh">0x173af50</span> <span class="s1">&#39;i&#39;</span> <span class="s1">&#39;int&#39;</span><span class="p">))</span>
  <span class="p">(</span><span class="n">CompoundStatement</span> <span class="o">...</span>
</pre></div>
</div>
<p>We already know that the declaration and increments both match, or this
loop wouldn’t have been dumped. The culprit lies in the implicit cast
applied to the first operand (i.e. the LHS) of the less-than operator,
an L-value to R-value conversion applied to the expression referencing
<code class="docutils literal notranslate"><span class="pre">i</span></code>. Thankfully, the matcher library offers a solution to this problem
in the form of <code class="docutils literal notranslate"><span class="pre">ignoringParenImpCasts</span></code>, which instructs the matcher to
ignore implicit casts and parentheses before continuing to match.
Adjusting the condition operator will restore the desired match.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">hasCondition</span><span class="p">(</span><span class="n">binaryOperator</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="n">hasOperatorName</span><span class="p">(</span><span class="s">&quot;&lt;&quot;</span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="n">hasLHS</span><span class="p">(</span><span class="n">ignoringParenImpCasts</span><span class="p">(</span><span class="n">declRefExpr</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">to</span><span class="p">(</span><span class="n">varDecl</span><span class="p">(</span><span class="n">hasType</span><span class="p">(</span><span class="n">isInteger</span><span class="p">())))))),</span><span class="w"></span>
<span class="w">  </span><span class="n">hasRHS</span><span class="p">(</span><span class="n">expr</span><span class="p">(</span><span class="n">hasType</span><span class="p">(</span><span class="n">isInteger</span><span class="p">())))))</span><span class="w"></span>
</pre></div>
</div>
<p>After adding binds to the expressions we wished to capture and
extracting the identifier strings into variables, we have array-step-2
completed.</p>
</div>
<div class="section" id="step-4-retrieving-matched-nodes">
<h2>Step 4: Retrieving Matched Nodes<a class="headerlink" href="#step-4-retrieving-matched-nodes" title="Permalink to this headline">¶</a></h2>
<p>So far, the matcher callback isn’t very interesting: it just dumps the
loop’s AST. At some point, we will need to make changes to the input
source code. Next, we’ll work on using the nodes we bound in the
previous step.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">MatchFinder::run()</span></code> callback takes a
<code class="docutils literal notranslate"><span class="pre">MatchFinder::MatchResult&amp;</span></code> as its parameter. We’re most interested in
its <code class="docutils literal notranslate"><span class="pre">Context</span></code> and <code class="docutils literal notranslate"><span class="pre">Nodes</span></code> members. Clang uses the <code class="docutils literal notranslate"><span class="pre">ASTContext</span></code>
class to represent contextual information about the AST, as the name
implies, though the most functionally important detail is that several
operations require an <code class="docutils literal notranslate"><span class="pre">ASTContext*</span></code> parameter. More immediately useful
is the set of matched nodes, and how we retrieve them.</p>
<p>Since we bind three variables (identified by ConditionVarName,
InitVarName, and IncrementVarName), we can obtain the matched nodes by
using the <code class="docutils literal notranslate"><span class="pre">getNodeAs()</span></code> member function.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">LoopConvert.cpp</span></code> add</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;clang/AST/ASTContext.h&quot;</span><span class="cp"></span>
</pre></div>
</div>
<p>Change <code class="docutils literal notranslate"><span class="pre">LoopMatcher</span></code> to</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">StatementMatcher</span><span class="w"> </span><span class="n">LoopMatcher</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">forStmt</span><span class="p">(</span><span class="n">hasLoopInit</span><span class="p">(</span><span class="n">declStmt</span><span class="p">(</span><span class="w"></span>
<span class="w">                </span><span class="n">hasSingleDecl</span><span class="p">(</span><span class="n">varDecl</span><span class="p">(</span><span class="n">hasInitializer</span><span class="p">(</span><span class="n">integerLiteral</span><span class="p">(</span><span class="n">equals</span><span class="p">(</span><span class="mi">0</span><span class="p">))))</span><span class="w"></span>
<span class="w">                                  </span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="s">&quot;initVarName&quot;</span><span class="p">)))),</span><span class="w"></span>
<span class="w">            </span><span class="n">hasIncrement</span><span class="p">(</span><span class="n">unaryOperator</span><span class="p">(</span><span class="w"></span>
<span class="w">                </span><span class="n">hasOperatorName</span><span class="p">(</span><span class="s">&quot;++&quot;</span><span class="p">),</span><span class="w"></span>
<span class="w">                </span><span class="n">hasUnaryOperand</span><span class="p">(</span><span class="n">declRefExpr</span><span class="p">(</span><span class="w"></span>
<span class="w">                    </span><span class="n">to</span><span class="p">(</span><span class="n">varDecl</span><span class="p">(</span><span class="n">hasType</span><span class="p">(</span><span class="n">isInteger</span><span class="p">())).</span><span class="n">bind</span><span class="p">(</span><span class="s">&quot;incVarName&quot;</span><span class="p">)))))),</span><span class="w"></span>
<span class="w">            </span><span class="n">hasCondition</span><span class="p">(</span><span class="n">binaryOperator</span><span class="p">(</span><span class="w"></span>
<span class="w">                </span><span class="n">hasOperatorName</span><span class="p">(</span><span class="s">&quot;&lt;&quot;</span><span class="p">),</span><span class="w"></span>
<span class="w">                </span><span class="n">hasLHS</span><span class="p">(</span><span class="n">ignoringParenImpCasts</span><span class="p">(</span><span class="n">declRefExpr</span><span class="p">(</span><span class="w"></span>
<span class="w">                    </span><span class="n">to</span><span class="p">(</span><span class="n">varDecl</span><span class="p">(</span><span class="n">hasType</span><span class="p">(</span><span class="n">isInteger</span><span class="p">())).</span><span class="n">bind</span><span class="p">(</span><span class="s">&quot;condVarName&quot;</span><span class="p">))))),</span><span class="w"></span>
<span class="w">                </span><span class="n">hasRHS</span><span class="p">(</span><span class="n">expr</span><span class="p">(</span><span class="n">hasType</span><span class="p">(</span><span class="n">isInteger</span><span class="p">())))))).</span><span class="n">bind</span><span class="p">(</span><span class="s">&quot;forLoop&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>And change <code class="docutils literal notranslate"><span class="pre">LoopPrinter::run</span></code> to</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">LoopPrinter::run</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MatchFinder</span><span class="o">::</span><span class="n">MatchResult</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">ASTContext</span><span class="w"> </span><span class="o">*</span><span class="n">Context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Result</span><span class="p">.</span><span class="n">Context</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">ForStmt</span><span class="w"> </span><span class="o">*</span><span class="n">FS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Result</span><span class="p">.</span><span class="n">Nodes</span><span class="p">.</span><span class="n">getNodeAs</span><span class="o">&lt;</span><span class="n">ForStmt</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;forLoop&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// We do not want to convert header files!</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">FS</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">Context</span><span class="o">-&gt;</span><span class="n">getSourceManager</span><span class="p">().</span><span class="n">isWrittenInMainFile</span><span class="p">(</span><span class="n">FS</span><span class="o">-&gt;</span><span class="n">getForLoc</span><span class="p">()))</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">VarDecl</span><span class="w"> </span><span class="o">*</span><span class="n">IncVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Result</span><span class="p">.</span><span class="n">Nodes</span><span class="p">.</span><span class="n">getNodeAs</span><span class="o">&lt;</span><span class="n">VarDecl</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;incVarName&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">VarDecl</span><span class="w"> </span><span class="o">*</span><span class="n">CondVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Result</span><span class="p">.</span><span class="n">Nodes</span><span class="p">.</span><span class="n">getNodeAs</span><span class="o">&lt;</span><span class="n">VarDecl</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;condVarName&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">VarDecl</span><span class="w"> </span><span class="o">*</span><span class="n">InitVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Result</span><span class="p">.</span><span class="n">Nodes</span><span class="p">.</span><span class="n">getNodeAs</span><span class="o">&lt;</span><span class="n">VarDecl</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;initVarName&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">areSameVariable</span><span class="p">(</span><span class="n">IncVar</span><span class="p">,</span><span class="w"> </span><span class="n">CondVar</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">areSameVariable</span><span class="p">(</span><span class="n">IncVar</span><span class="p">,</span><span class="w"> </span><span class="n">InitVar</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">llvm</span><span class="o">::</span><span class="n">outs</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Potential array-based loop discovered.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Clang associates a <code class="docutils literal notranslate"><span class="pre">VarDecl</span></code> with each variable to represent the variable’s
declaration. Since the “canonical” form of each declaration is unique by
address, all we need to do is make sure neither <code class="docutils literal notranslate"><span class="pre">ValueDecl</span></code> (base class of
<code class="docutils literal notranslate"><span class="pre">VarDecl</span></code>) is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> and compare the canonical Decls.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">areSameVariable</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueDecl</span><span class="w"> </span><span class="o">*</span><span class="n">First</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueDecl</span><span class="w"> </span><span class="o">*</span><span class="n">Second</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">First</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">Second</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">         </span><span class="n">First</span><span class="o">-&gt;</span><span class="n">getCanonicalDecl</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Second</span><span class="o">-&gt;</span><span class="n">getCanonicalDecl</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>If execution reaches the end of <code class="docutils literal notranslate"><span class="pre">LoopPrinter::run()</span></code>, we know that the
loop shell looks like</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">expr</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>For now, we will just print a message explaining that we found a loop.
The next section will deal with recursively traversing the AST to
discover all changes needed.</p>
<p>As a side note, it’s not as trivial to test if two expressions are the same,
though Clang has already done the hard work for us by providing a way to
canonicalize expressions:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">areSameExpr</span><span class="p">(</span><span class="n">ASTContext</span><span class="w"> </span><span class="o">*</span><span class="n">Context</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Expr</span><span class="w"> </span><span class="o">*</span><span class="n">First</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="k">const</span><span class="w"> </span><span class="n">Expr</span><span class="w"> </span><span class="o">*</span><span class="n">Second</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">First</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">Second</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">llvm</span><span class="o">::</span><span class="n">FoldingSetNodeID</span><span class="w"> </span><span class="n">FirstID</span><span class="p">,</span><span class="w"> </span><span class="n">SecondID</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">First</span><span class="o">-&gt;</span><span class="n">Profile</span><span class="p">(</span><span class="n">FirstID</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">Context</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">Second</span><span class="o">-&gt;</span><span class="n">Profile</span><span class="p">(</span><span class="n">SecondID</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">Context</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">FirstID</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SecondID</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This code relies on the comparison between two
<code class="docutils literal notranslate"><span class="pre">llvm::FoldingSetNodeIDs</span></code>. As the documentation for
<code class="docutils literal notranslate"><span class="pre">Stmt::Profile()</span></code> indicates, the <code class="docutils literal notranslate"><span class="pre">Profile()</span></code> member function builds
a description of a node in the AST, based on its properties, along with
those of its children. <code class="docutils literal notranslate"><span class="pre">FoldingSetNodeID</span></code> then serves as a hash we can
use to compare expressions. We will need <code class="docutils literal notranslate"><span class="pre">areSameExpr</span></code> later. Before
you run the new code on the additional loops added to
test-files/simple.cpp, try to figure out which ones will be considered
potentially convertible.</p>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="RAVFrontendAction.html">How to write RecursiveASTVisitor based ASTFrontendActions.</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="LibASTMatchers.html">Matching the Clang AST</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2007-2022, The Clang Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>
  </body>
</html>