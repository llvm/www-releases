
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>How To Setup Clang Tooling For LLVM &#8212; Clang 15.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="JSON Compilation Database Format Specification" href="JSONCompilationDatabase.html" />
    <link rel="prev" title="ASTImporter: Merging Clang ASTs" href="LibASTImporter.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Clang 15.0.0 documentation</span></a></h1>
        <h2 class="heading"><span>How To Setup Clang Tooling For LLVM</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="LibASTImporter.html">ASTImporter: Merging Clang ASTs</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="JSONCompilationDatabase.html">JSON Compilation Database Format Specification</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <div class="section" id="how-to-setup-clang-tooling-for-llvm">
<h1>How To Setup Clang Tooling For LLVM<a class="headerlink" href="#how-to-setup-clang-tooling-for-llvm" title="Permalink to this headline">¶</a></h1>
<p>Clang Tooling provides infrastructure to write tools that need syntactic
and semantic information about a program. This term also relates to a set
of specific tools using this infrastructure (e.g. <code class="docutils literal notranslate"><span class="pre">clang-check</span></code>). This
document provides information on how to set up and use Clang Tooling for
the LLVM source code.</p>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Clang Tooling needs a compilation database to figure out specific build
options for each file. Currently it can create a compilation database
from the <code class="docutils literal notranslate"><span class="pre">compile_commands.json</span></code> file, generated by CMake. When
invoking clang tools, you can either specify a path to a build directory
using a command line parameter <code class="docutils literal notranslate"><span class="pre">-p</span></code> or let Clang Tooling find this
file in your source tree. In either case you need to configure your
build using CMake to use clang tools.</p>
</div>
<div class="section" id="setup-clang-tooling-using-cmake-and-make">
<h2>Setup Clang Tooling Using CMake and Make<a class="headerlink" href="#setup-clang-tooling-using-cmake-and-make" title="Permalink to this headline">¶</a></h2>
<p>If you intend to use make to build LLVM, you should have CMake 2.8.6 or
later installed (can be found <a class="reference external" href="https://cmake.org">here</a>).</p>
<p>First, you need to generate Makefiles for LLVM with CMake. You need to
make a build directory and run CMake from it:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>mkdir your/build/directory
<span class="gp">$ </span><span class="nb">cd</span> your/build/directory
<span class="gp">$ </span>cmake -DCMAKE_EXPORT_COMPILE_COMMANDS<span class="o">=</span>ON path/to/llvm/sources
</pre></div>
</div>
<p>If you want to use clang instead of GCC, you can add
<code class="docutils literal notranslate"><span class="pre">-DCMAKE_C_COMPILER=/path/to/clang</span> <span class="pre">-DCMAKE_CXX_COMPILER=/path/to/clang++</span></code>.
You can also use <code class="docutils literal notranslate"><span class="pre">ccmake</span></code>, which provides a curses interface to configure
CMake variables.</p>
<p>As a result, the new <code class="docutils literal notranslate"><span class="pre">compile_commands.json</span></code> file should appear in the
current directory. You should link it to the LLVM source tree so that
Clang Tooling is able to use it:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ln -s <span class="nv">$PWD</span>/compile_commands.json path/to/llvm/source/
</pre></div>
</div>
<p>Now you are ready to build and test LLVM using make:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>make check-all
</pre></div>
</div>
</div>
<div class="section" id="setup-clang-tooling-using-cmake-on-windows">
<h2>Setup Clang Tooling Using CMake on Windows<a class="headerlink" href="#setup-clang-tooling-using-cmake-on-windows" title="Permalink to this headline">¶</a></h2>
<p>For Windows developers, the Visual Studio project generators in CMake do
not support <a class="reference external" href="https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html">CMAKE_EXPORT_COMPILE_COMMANDS</a>.
However, the Ninja generator does support this variable and can be used
on Windows to generate a suitable <code class="docutils literal notranslate"><span class="pre">compile_commands.json</span></code> that invokes
the MSVC compiler.</p>
<p>First, you will need to install <a class="reference external" href="https://ninja-build.org/">Ninja</a>.  Once installed, the Ninja
executable will need to be in your search path for CMake to locate it.</p>
<p>Next, assuming you already have Visual Studio installed on your machine, you
need to have the appropriate environment variables configured so that CMake
will locate the MSVC compiler for the Ninja generator.  The <a class="reference external" href="https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#path_and_environment">documentation</a>
describes the necessary environment variable settings, but the simplest thing
is to use a <a class="reference external" href="https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_prompt_shortcuts">developer command-prompt window</a>
or call a <a class="reference external" href="https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_file_locations">developer command file</a>
to set the environment variables appropriately.</p>
<p>Now you can run CMake with the Ninja generator to export a compilation
database:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">C:\&gt; mkdir build-ninja</span>
<span class="go">C:\&gt; cd build-ninja</span>
<span class="go">C:\build-ninja&gt; cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources</span>
</pre></div>
</div>
<p>It is best to keep your Visual Studio IDE build folder separate from the
Ninja build folder.  This prevents the two build systems from negatively
interacting with each other.</p>
<p>Once the <code class="docutils literal notranslate"><span class="pre">compile_commands.json</span></code> file has been created by Ninja, you can
use that compilation database with Clang Tooling.  One caveat is that because
there are indirect settings obtained through the environment variables,
you may need to run any Clang Tooling executables through a command prompt
window created for use with Visual Studio as described above.  An
alternative, e.g. for using the Visual Studio debugger on a Clang Tooling
executable, is to ensure that the environment variables are also visible
to the debugger settings.  This can be done locally in Visual Studio’s
debugger configuration locally or globally by launching the Visual Studio
IDE from a suitable command-prompt window.</p>
</div>
<div class="section" id="using-clang-tools">
<h2>Using Clang Tools<a class="headerlink" href="#using-clang-tools" title="Permalink to this headline">¶</a></h2>
<p>After you completed the previous steps, you are ready to run clang tools. If
you have a recent clang installed, you should have <code class="docutils literal notranslate"><span class="pre">clang-check</span></code> in
<code class="docutils literal notranslate"><span class="pre">$PATH</span></code>. Try to run it on any <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> file inside the LLVM source tree:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang-check tools/clang/lib/Tooling/CompilationDatabase.cpp
</pre></div>
</div>
<p>If you’re using vim, it’s convenient to have clang-check integrated. Put
this into your <code class="docutils literal notranslate"><span class="pre">.vimrc</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>function! ClangCheckImpl(cmd)
  if &amp;autowrite | wall | endif
  echo &quot;Running &quot; . a:cmd . &quot; ...&quot;
  let l:output = system(a:cmd)
  cexpr l:output
  cwindow
  let w:quickfix_title = a:cmd
  if v:shell_error != 0
    cc
  endif
  let g:clang_check_last_cmd = a:cmd
endfunction

function! ClangCheck()
  let l:filename = expand(&#39;%&#39;)
  if l:filename =~ &#39;\.\(cpp\|cxx\|cc\|c\)$&#39;
    call ClangCheckImpl(&quot;clang-check &quot; . l:filename)
  elseif exists(&quot;g:clang_check_last_cmd&quot;)
    call ClangCheckImpl(g:clang_check_last_cmd)
  else
    echo &quot;Can&#39;t detect file&#39;s compilation arguments and no previous clang-check invocation!&quot;
  endif
endfunction

nmap &lt;silent&gt; &lt;F5&gt; :call ClangCheck()&lt;CR&gt;&lt;CR&gt;
</pre></div>
</div>
<p>When editing a .cpp/.cxx/.cc/.c file, hit F5 to reparse the file. In
case the current file has a different extension (for example, .h), F5
will re-run the last clang-check invocation made from this vim instance
(if any). The output will go into the error window, which is opened
automatically when clang-check finds errors, and can be re-opened with
<code class="docutils literal notranslate"><span class="pre">:cope</span></code>.</p>
<p>Other <code class="docutils literal notranslate"><span class="pre">clang-check</span></code> options that can be useful when working with clang
AST:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-ast-print</span></code> — Build ASTs and then pretty-print them.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-ast-dump</span></code> — Build ASTs and then debug dump them.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-ast-dump-filter=&lt;string&gt;</span></code> — Use with <code class="docutils literal notranslate"><span class="pre">-ast-dump</span></code> or <code class="docutils literal notranslate"><span class="pre">-ast-print</span></code> to
dump/print only AST declaration nodes having a certain substring in a
qualified name. Use <code class="docutils literal notranslate"><span class="pre">-ast-list</span></code> to list all filterable declaration node
names.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-ast-list</span></code> — Build ASTs and print the list of declaration node qualified
names.</p></li>
</ul>
<p>Examples:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang-check tools/clang/tools/clang-check/ClangCheck.cpp -ast-dump -ast-dump-filter ActionFactory::newASTConsumer
<span class="go">Processing: tools/clang/tools/clang-check/ClangCheck.cpp.</span>
<span class="go">Dumping ::ActionFactory::newASTConsumer:</span>
<span class="go">clang::ASTConsumer *newASTConsumer() (CompoundStmt 0x44da290 &lt;/home/alexfh/local/llvm/tools/clang/tools/clang-check/ClangCheck.cpp:64:40, line:72:3&gt;</span>
<span class="go">  (IfStmt 0x44d97c8 &lt;line:65:5, line:66:45&gt;</span>
<span class="go">    &lt;&lt;&lt;NULL&gt;&gt;&gt;</span>
<span class="go">      (ImplicitCastExpr 0x44d96d0 &lt;line:65:9&gt; &#39;_Bool&#39;:&#39;_Bool&#39; &lt;UserDefinedConversion&gt;</span>
<span class="go">...</span>
<span class="gp">$ </span>clang-check tools/clang/tools/clang-check/ClangCheck.cpp -ast-print -ast-dump-filter ActionFactory::newASTConsumer
<span class="go">Processing: tools/clang/tools/clang-check/ClangCheck.cpp.</span>
<span class="go">Printing &lt;anonymous namespace&gt;::ActionFactory::newASTConsumer:</span>
<span class="go">clang::ASTConsumer *newASTConsumer() {</span>
<span class="go">    if (this-&gt;ASTList.operator _Bool())</span>
<span class="go">        return clang::CreateASTDeclNodeLister();</span>
<span class="go">    if (this-&gt;ASTDump.operator _Bool())</span>
<span class="go">        return clang::CreateASTDumper(nullptr /*Dump to stdout.*/,</span>
<span class="go">                                      this-&gt;ASTDumpFilter);</span>
<span class="go">    if (this-&gt;ASTPrint.operator _Bool())</span>
<span class="go">        return clang::CreateASTPrinter(&amp;llvm::outs(), this-&gt;ASTDumpFilter);</span>
<span class="go">    return new clang::ASTConsumer();</span>
<span class="go">}</span>
</pre></div>
</div>
</div>
<div class="section" id="using-ninja-build-system">
<h2>Using Ninja Build System<a class="headerlink" href="#using-ninja-build-system" title="Permalink to this headline">¶</a></h2>
<p>Optionally you can use the <a class="reference external" href="https://ninja-build.org/">Ninja</a> build system instead of make. It is
aimed at making your builds faster.  Currently this step will require
building Ninja from sources.</p>
<p>To take advantage of using Clang Tools along with Ninja build you need
at least CMake 2.8.9.</p>
<p>Clone the Ninja git repository and build Ninja from sources:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>git clone git://github.com/martine/ninja.git
<span class="gp">$ </span><span class="nb">cd</span> ninja/
<span class="gp">$ </span>./bootstrap.py
</pre></div>
</div>
<p>This will result in a single binary <code class="docutils literal notranslate"><span class="pre">ninja</span></code> in the current directory.
It doesn’t require installation and can just be copied to any location
inside <code class="docutils literal notranslate"><span class="pre">$PATH</span></code>, say <code class="docutils literal notranslate"><span class="pre">/usr/local/bin/</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>sudo cp ninja /usr/local/bin/
<span class="gp">$ </span>sudo chmod a+rx /usr/local/bin/ninja
</pre></div>
</div>
<p>After doing all of this, you’ll need to generate Ninja build files for
LLVM with CMake. You need to make a build directory and run CMake from
it:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>mkdir your/build/directory
<span class="gp">$ </span><span class="nb">cd</span> your/build/directory
<span class="gp">$ </span>cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS<span class="o">=</span>ON path/to/llvm/sources
</pre></div>
</div>
<p>If you want to use clang instead of GCC, you can add
<code class="docutils literal notranslate"><span class="pre">-DCMAKE_C_COMPILER=/path/to/clang</span> <span class="pre">-DCMAKE_CXX_COMPILER=/path/to/clang++</span></code>.
You can also use <code class="docutils literal notranslate"><span class="pre">ccmake</span></code>, which provides a curses interface to configure
CMake variables in an interactive manner.</p>
<p>As a result, the new <code class="docutils literal notranslate"><span class="pre">compile_commands.json</span></code> file should appear in the
current directory. You should link it to the LLVM source tree so that
Clang Tooling is able to use it:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ln -s <span class="nv">$PWD</span>/compile_commands.json path/to/llvm/source/
</pre></div>
</div>
<p>Now you are ready to build and test LLVM using Ninja:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>ninja check-all
</pre></div>
</div>
<p>Other target names can be used in the same way as with make.</p>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="LibASTImporter.html">ASTImporter: Merging Clang ASTs</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="JSONCompilationDatabase.html">JSON Compilation Database Format Specification</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2007-2022, The Clang Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>
  </body>
</html>