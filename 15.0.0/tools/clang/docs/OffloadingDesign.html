
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Offloading Design &amp; Internals &#8212; Clang 15.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Precompiled Header and Modules Internals" href="PCHInternals.html" />
    <link rel="prev" title="Driver Design &amp; Internals" href="DriverInternals.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Clang 15.0.0 documentation</span></a></h1>
        <h2 class="heading"><span>Offloading Design &amp; Internals</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="DriverInternals.html">Driver Design &amp; Internals</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="PCHInternals.html">Precompiled Header and Modules Internals</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <div class="section" id="offloading-design-internals">
<h1>Offloading Design &amp; Internals<a class="headerlink" href="#offloading-design-internals" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id5">Introduction</a></p></li>
<li><p><a class="reference internal" href="#openmp-offloading" id="id6">OpenMP Offloading</a></p>
<ul>
<li><p><a class="reference internal" href="#offloading-overview" id="id7">Offloading Overview</a></p>
<ul>
<li><p><a class="reference internal" href="#compilation-process" id="id8">Compilation Process</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#generating-offloading-entries" id="id9">Generating Offloading Entries</a></p>
<ul>
<li><p><a class="reference internal" href="#accessing-entries-on-the-device" id="id10">Accessing Entries on the Device</a></p></li>
<li><p><a class="reference internal" href="#debugging-information" id="id11">Debugging Information</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#offload-device-compilation" id="id12">Offload Device Compilation</a></p></li>
<li><p><a class="reference internal" href="#creating-fat-objects" id="id13">Creating Fat Objects</a></p></li>
<li><p><a class="reference internal" href="#linking-target-device-code" id="id14">Linking Target Device Code</a></p></li>
<li><p><a class="reference internal" href="#device-binary-wrapping" id="id15">Device Binary Wrapping</a></p>
<ul>
<li><p><a class="reference internal" href="#structure-types" id="id16">Structure Types</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#global-variables" id="id17">Global Variables</a></p>
<ul>
<li><p><a class="reference internal" href="#binary-descriptor-for-device-images" id="id18">Binary Descriptor for Device Images</a></p></li>
<li><p><a class="reference internal" href="#global-constructor-and-destructor" id="id19">Global Constructor and Destructor</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#offloading-example" id="id20">Offloading Example</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id5">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document describes the Clang driver and code generation steps for creating
offloading applications. Clang supports offloading to various architectures
using programming models like CUDA, HIP, and OpenMP. The purpose of this
document is to illustrate the steps necessary to create an offloading
application using Clang.</p>
</div>
<div class="section" id="openmp-offloading">
<h2><a class="toc-backref" href="#id6">OpenMP Offloading</a><a class="headerlink" href="#openmp-offloading" title="Permalink to this headline">¶</a></h2>
<p>Clang supports OpenMP target offloading to several different architectures such
as NVPTX, AMDGPU, X86_64, Arm, and PowerPC. Offloading code is generated by
Clang and then executed using the <code class="docutils literal notranslate"><span class="pre">libomptarget</span></code> runtime and the associated
plugin for the target architecture, e.g. <code class="docutils literal notranslate"><span class="pre">libomptarget.rtl.cuda</span></code>. This section
describes the steps necessary to create a functioning device image that can be
loaded by the OpenMP runtime.  More information on the OpenMP runtimes can be
found at the <a class="reference external" href="https://openmp.llvm.org">OpenMP documentation page</a>.</p>
<div class="section" id="offloading-overview">
<span id="id1"></span><h3><a class="toc-backref" href="#id7">Offloading Overview</a><a class="headerlink" href="#offloading-overview" title="Permalink to this headline">¶</a></h3>
<p>The goal of offloading compilation is to create an executable device image that
can be run on the target device. OpenMP offloading creates executable images by
compiling the input file for both the host and the target device. The output
from the device phase then needs to be embedded into the host to create a fat
object. A special tool then needs to extract the device code from the fat
objects, run the device linking step, and embed the final image in a symbol the
host runtime library can use to register the library and access the symbols on
the device.</p>
<div class="section" id="compilation-process">
<h4><a class="toc-backref" href="#id8">Compilation Process</a><a class="headerlink" href="#compilation-process" title="Permalink to this headline">¶</a></h4>
<p>The compiler performs the following high-level actions to generate OpenMP
offloading code:</p>
<ul>
<li><p>Compile the input file for the host to produce a bitcode file. Lower <code class="docutils literal notranslate"><span class="pre">#pragma</span>
<span class="pre">omp</span> <span class="pre">target</span></code> declarations to <a class="reference internal" href="#generating-offloading-entries"><span class="std std-ref">offloading entries</span></a> and create metadata to indicate which entries are on the device.</p></li>
<li><p>Compile the input file for the target <a class="reference internal" href="#device-compilation"><span class="std std-ref">device</span></a> using
the <a class="reference internal" href="#generating-offloading-entries"><span class="std std-ref">offloading entry</span></a> metadata created
by the host.</p></li>
<li><p>Link the OpenMP device runtime library and run the backend to create a device
object file.</p></li>
<li><p>Run the backend on the host bitcode file and create a <a class="reference internal" href="#creating-fat-objects"><span class="std std-ref">fat object file</span></a> using the device object file.</p></li>
<li><p>Pass the fat object file to the <a class="reference internal" href="#device-linking"><span class="std std-ref">linker wrapper tool</span></a>
and extract the device objects. Run the device linking action on the extracted
objects.</p></li>
<li><p><a class="reference internal" href="#device-binary-wrapping"><span class="std std-ref">Wrap</span></a> the <a class="reference internal" href="#device-linking"><span class="std std-ref">device images</span></a>
and <a class="reference internal" href="#generating-offloading-entries"><span class="std std-ref">offload entries</span></a> in a symbol that
can be accessed by the host.</p></li>
<li><p>Add the <a class="reference internal" href="#device-binary-wrapping"><span class="std std-ref">wrapped binary</span></a> to the linker input and
run the host linking action. Link with <code class="docutils literal notranslate"><span class="pre">libomptarget</span></code> to register and
execute the images.</p>
<blockquote>
<div></div></blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="generating-offloading-entries">
<span id="id2"></span><h3><a class="toc-backref" href="#id9">Generating Offloading Entries</a><a class="headerlink" href="#generating-offloading-entries" title="Permalink to this headline">¶</a></h3>
<p>The first step in compilation is to generate offloading entries for the host.
This information is used to identify function kernels or global values that will
be provided by the device. Blocks contained in a <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">omp</span> <span class="pre">target</span></code> or
symbols inside a <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">omp</span> <span class="pre">declare</span> <span class="pre">target</span></code> directive will have offloading
entries generated. The following table shows the <a class="reference internal" href="#table-tgt-offload-entry-structure"><span class="std std-ref">offload entry structure</span></a>.</p>
<blockquote>
<div><table class="docutils align-default" id="table-tgt-offload-entry-structure">
<caption><span class="caption-text">__tgt_offload_entry Structure</span><a class="headerlink" href="#table-tgt-offload-entry-structure" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Type</p></th>
<th class="head"><p>Identifier</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>void*</p></td>
<td><p>addr</p></td>
<td><p>Address of global symbol within device image (function or global)</p></td>
</tr>
<tr class="row-odd"><td><p>char*</p></td>
<td><p>name</p></td>
<td><p>Name of the symbol</p></td>
</tr>
<tr class="row-even"><td><p>size_t</p></td>
<td><p>size</p></td>
<td><p>Size of the entry info (0 if it is a function)</p></td>
</tr>
<tr class="row-odd"><td><p>int32_t</p></td>
<td><p>flags</p></td>
<td><p>Flags associated with the entry (see <a class="reference internal" href="#table-offload-entry-flags"><span class="std std-ref">Target Region Entry Flags</span></a>)</p></td>
</tr>
<tr class="row-even"><td><p>int32_t</p></td>
<td><p>reserved</p></td>
<td><p>Reserved, to be used by the runtime library.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The address of the global symbol will be set to the device pointer value by the
runtime once the device image is loaded. The flags are set to indicate the
handling required for the offloading entry. If the offloading entry is an entry
to a target region it can have one of the following <a class="reference internal" href="#table-offload-entry-flags"><span class="std std-ref">entry flags</span></a>.</p>
<blockquote>
<div><table class="docutils align-default" id="table-offload-entry-flags">
<caption><span class="caption-text">Target Region Entry Flags</span><a class="headerlink" href="#table-offload-entry-flags" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 41%" />
<col style="width: 9%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>OMPTargetRegionEntryTargetRegion</p></td>
<td><p>0x00</p></td>
<td><p>Mark the entry as generic target region</p></td>
</tr>
<tr class="row-odd"><td><p>OMPTargetRegionEntryCtor</p></td>
<td><p>0x02</p></td>
<td><p>Mark the entry as a global constructor</p></td>
</tr>
<tr class="row-even"><td><p>OMPTargetRegionEntryDtor</p></td>
<td><p>0x04</p></td>
<td><p>Mark the entry as a global destructor</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If the offloading entry is a global variable, indicated by a non-zero size, it
will instead have one of the following <a class="reference internal" href="#table-offload-global-flags"><span class="std std-ref">global</span></a> flags.</p>
<blockquote>
<div><table class="docutils align-default" id="table-offload-global-flags">
<caption><span class="caption-text">Target Region Global</span><a class="headerlink" href="#table-offload-global-flags" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 29%" />
<col style="width: 7%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>OMPTargetGlobalVarEntryTo</p></td>
<td><p>0x00</p></td>
<td><p>Mark the entry as a ‘to’ attribute (w.r.t. the to clause)</p></td>
</tr>
<tr class="row-odd"><td><p>OMPTargetGlobalVarEntryLink</p></td>
<td><p>0x01</p></td>
<td><p>Mark the entry as a ‘link’ attribute (w.r.t. the link clause)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The target offload entries are used by the runtime to access the device kernels
and globals that will be provided by the final device image. Each offloading
entry is set to use the <code class="docutils literal notranslate"><span class="pre">omp_offloading_entries</span></code> section. When the final
application is created the linker will provide the
<code class="docutils literal notranslate"><span class="pre">__start_omp_offloading_entries</span></code> and <code class="docutils literal notranslate"><span class="pre">__stop_omp_offloading_entries</span></code> symbols
which are used to create the <a class="reference internal" href="#device-binary-wrapping"><span class="std std-ref">final image</span></a>.</p>
<p>This information is used by the device compilation stage to determine which
symbols need to be exported from the device. We use the <code class="docutils literal notranslate"><span class="pre">omp_offload.info</span></code>
metadata node to pass this information device compilation stage.</p>
<div class="section" id="accessing-entries-on-the-device">
<h4><a class="toc-backref" href="#id10">Accessing Entries on the Device</a><a class="headerlink" href="#accessing-entries-on-the-device" title="Permalink to this headline">¶</a></h4>
<p>Accessing the entries in the device is done using the address field in the
<a class="reference internal" href="#table-tgt-offload-entry-structure"><span class="std std-ref">offload entry</span></a>. The runtime will set
the address to the pointer associated with the device image during runtime
initialization. This is used to call the corresponding kernel function when
entering a <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">omp</span> <span class="pre">target</span></code> region. For variables, the runtime maintains a
table mapping host pointers to device pointers. Global variables inside a
<code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">omp</span> <span class="pre">target</span> <span class="pre">declare</span></code> directive are first initialized to the host’s
address. Once the device address is initialized we insert it into the table to
map the host address to the device address.</p>
</div>
<div class="section" id="debugging-information">
<h4><a class="toc-backref" href="#id11">Debugging Information</a><a class="headerlink" href="#debugging-information" title="Permalink to this headline">¶</a></h4>
<p>We generate structures to hold debugging information that is passed to
<code class="docutils literal notranslate"><span class="pre">libomptarget</span></code>. This allows the front-end to generate information the runtime
library uses for more informative error messages. This is done using the
standard <a class="reference internal" href="#table-ident-t-structure"><span class="std std-ref">identifier structure</span></a> used in
<code class="docutils literal notranslate"><span class="pre">libomp</span></code> and <code class="docutils literal notranslate"><span class="pre">libomptarget</span></code>. This is used to pass information and source
locations to the runtime.</p>
<blockquote>
<div><table class="docutils align-default" id="table-ident-t-structure">
<caption><span class="caption-text">ident_t Structure</span><a class="headerlink" href="#table-ident-t-structure" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 9%" />
<col style="width: 12%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Type</p></th>
<th class="head"><p>Identifier</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>int32_t</p></td>
<td><p>reserved</p></td>
<td><p>Reserved, to be used by the runtime library.</p></td>
</tr>
<tr class="row-odd"><td><p>int32_t</p></td>
<td><p>flags</p></td>
<td><p>Flags used to indicate some features, mostly unused.</p></td>
</tr>
<tr class="row-even"><td><p>int32_t</p></td>
<td><p>reserved</p></td>
<td><p>Reserved, to be used by the runtime library.</p></td>
</tr>
<tr class="row-odd"><td><p>int32_t</p></td>
<td><p>reserved</p></td>
<td><p>Reserved, to be used by the runtime library.</p></td>
</tr>
<tr class="row-even"><td><p>char*</p></td>
<td><p>psource</p></td>
<td><p>Program source information, stored as “;filename;function;line;column;;\0”</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If debugging information is enabled, we will also create strings to indicate the
names and declarations of variables mapped in target regions. These have the
same format as the source location in the <a class="reference internal" href="#table-ident-t-structure"><span class="std std-ref">identifier structure</span></a>, but the function name is replaced with the variable
name.</p>
</div>
</div>
<div class="section" id="offload-device-compilation">
<span id="device-compilation"></span><h3><a class="toc-backref" href="#id12">Offload Device Compilation</a><a class="headerlink" href="#offload-device-compilation" title="Permalink to this headline">¶</a></h3>
<p>The input file is compiled for each active device toolchain. The device
compilation stage is performed differently from the host stage. Namely, we do
not generate any offloading entries. This is set by passing the
<code class="docutils literal notranslate"><span class="pre">-fopenmp-is-device</span></code> flag to the front-end. We use the host bitcode to
determine which symbols to export from the device. The bitcode file is passed in
from the previous stage using the <code class="docutils literal notranslate"><span class="pre">-fopenmp-host-ir-file-path</span></code> flag.
Compilation is otherwise performed as it would be for any other target triple.</p>
<p>When compiling for the OpenMP device, we set the visibility of all device
symbols to be <code class="docutils literal notranslate"><span class="pre">protected</span></code> by default. This improves performance and prevents a
class of errors where a symbol in the target device could preempt a host
library.</p>
<p>The OpenMP runtime library is linked in during compilation to provide the
implementations for standard OpenMP functionality. For GPU targets this is done
by linking in a special bitcode library during compilation, (e.g.
<code class="docutils literal notranslate"><span class="pre">libomptarget-nvptx64-sm_70.bc</span></code>) using the <code class="docutils literal notranslate"><span class="pre">-mlink-builtin-bitcode</span></code> flag.
Other device libraries, such as CUDA’s libdevice, are also linked this way. If
the target is a standard architecture with an existing <code class="docutils literal notranslate"><span class="pre">libomp</span></code>
implementation, that will be linked instead. Finally, device tools are used to
create a relocatable device object file that can be embedded in the host.</p>
</div>
<div class="section" id="creating-fat-objects">
<span id="id3"></span><h3><a class="toc-backref" href="#id13">Creating Fat Objects</a><a class="headerlink" href="#creating-fat-objects" title="Permalink to this headline">¶</a></h3>
<p>A fat binary is a binary file that contains information intended for another
device. We create a fat object by embedding the output of the device compilation
stage into the host as a named section. The output from the device compilation
is passed to the host backend using the <code class="docutils literal notranslate"><span class="pre">-fembed-offload-object</span></code> flag. This
embeds the device image into the <code class="docutils literal notranslate"><span class="pre">.llvm.offloading</span></code> section using a special
binary format that behaves like a string map. This binary format is used to
bundle metadata about the image so the linker can associate the proper device
linking action with the image. Each device image will start with the magic bytes
<code class="docutils literal notranslate"><span class="pre">0x10FF10AD</span></code>.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="vg">@llvm.embedded.object</span> <span class="p">=</span> <span class="k">private</span> <span class="k">constant</span> <span class="p">[</span><span class="m">1</span> <span class="k">x</span> <span class="kt">i8</span><span class="p">]</span> <span class="k">c</span><span class="s">&quot;\00&quot;</span><span class="p">,</span> <span class="k">section</span> <span class="s">&quot;.llvm.offloading&quot;</span>
</pre></div>
</div>
<p>The device code will then be placed in the corresponding section one the backend
is run on the host, creating a fat object. Using fat objects allows us to treat
offloading objects as standard host objects. The final object file should
contain the following <a class="reference internal" href="#table-offloading-sections"><span class="std std-ref">offloading sections</span></a>. We
will use this information when <a class="reference internal" href="#device-linking"><span class="std std-ref">Linking Target Device Code</span></a>.</p>
<blockquote>
<div><table class="docutils align-default" id="table-offloading-sections">
<caption><span class="caption-text">Offloading Sections</span><a class="headerlink" href="#table-offloading-sections" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Section</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>omp_offloading_entries</p></td>
<td><p>Offloading entry information (see <a class="reference internal" href="ClangOffloadWrapper.html#table-tgt-offload-entry"><span class="std std-ref">__tgt_offload_entry structure</span></a>)</p></td>
</tr>
<tr class="row-odd"><td><p>.llvm.offloading</p></td>
<td><p>Embedded device object file for the target device and architecture</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="linking-target-device-code">
<span id="device-linking"></span><h3><a class="toc-backref" href="#id14">Linking Target Device Code</a><a class="headerlink" href="#linking-target-device-code" title="Permalink to this headline">¶</a></h3>
<p>Objects containing <a class="reference internal" href="#table-offloading-sections"><span class="std std-ref">Offloading Sections</span></a> require special handling to
create an executable device image. This is done using a Clang tool, see
<a class="reference internal" href="ClangLinkerWrapper.html"><span class="doc">Clang Linker Wrapper</span></a> for more information. This tool works as a wrapper
over the host linking job. It scans the input object files for the offloading
section <code class="docutils literal notranslate"><span class="pre">.llvm.offloading</span></code>. The device files stored in this section are then
extracted and passed to the appropriate linking job. The linked device image is
then <a class="reference internal" href="#device-binary-wrapping"><span class="std std-ref">wrapped</span></a> to create the symbols used to load
the device image and link it with the host.</p>
<p>The linker wrapper tool supports linking bitcode files through link time
optimization (LTO). This is used whenever the object files embedded in the host
contain LLVM bitcode. Bitcode will be embedded for architectures that do not
support a relocatable object format, such as AMDGPU or SPIR-V, or if the user
requested it using the <code class="docutils literal notranslate"><span class="pre">-foffload-lto</span></code> flag.</p>
</div>
<div class="section" id="device-binary-wrapping">
<span id="id4"></span><h3><a class="toc-backref" href="#id15">Device Binary Wrapping</a><a class="headerlink" href="#device-binary-wrapping" title="Permalink to this headline">¶</a></h3>
<p>Various structures and functions are used to create the information necessary to
offload code on the device. We use the <a class="reference internal" href="#device-linking"><span class="std std-ref">linked device executable</span></a> with the corresponding offloading entries to create the symbols
necessary to load and execute the device image.</p>
<div class="section" id="structure-types">
<h4><a class="toc-backref" href="#id16">Structure Types</a><a class="headerlink" href="#structure-types" title="Permalink to this headline">¶</a></h4>
<p>Several different structures are used to store offloading information. The
<a class="reference internal" href="#table-device-image-structure"><span class="std std-ref">device image structure</span></a> stores a single
linked device image and its associated offloading entries. The offloading
entries are stored using the <code class="docutils literal notranslate"><span class="pre">__start_omp_offloading_entries</span></code> and
<code class="docutils literal notranslate"><span class="pre">__stop_omp_offloading_entries</span></code> symbols generated by the linker using the
<a class="reference internal" href="ClangOffloadWrapper.html#table-tgt-offload-entry"><span class="std std-ref">__tgt_offload_entry structure</span></a>.</p>
<blockquote>
<div><table class="docutils align-default" id="table-device-image-structure">
<caption><span class="caption-text">__tgt_device_image Structure</span><a class="headerlink" href="#table-device-image-structure" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 29%" />
<col style="width: 18%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Type</p></th>
<th class="head"><p>Identifier</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>void*</p></td>
<td><p>ImageStart</p></td>
<td><p>Pointer to the target code start</p></td>
</tr>
<tr class="row-odd"><td><p>void*</p></td>
<td><p>ImageEnd</p></td>
<td><p>Pointer to the target code end</p></td>
</tr>
<tr class="row-even"><td><p>__tgt_offload_entry*</p></td>
<td><p>EntriesBegin</p></td>
<td><p>Begin of table with all target entries</p></td>
</tr>
<tr class="row-odd"><td><p>__tgt_offload_entry*</p></td>
<td><p>EntriesEnd</p></td>
<td><p>End of table (non inclusive)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The target <a class="reference internal" href="#table-target-binary-descriptor"><span class="std std-ref">target binary descriptor</span></a> is
used to store all binary images and offloading entries in an array.</p>
<blockquote>
<div><table class="docutils align-default" id="table-target-binary-descriptor">
<caption><span class="caption-text">__tgt_bin_desc Structure</span><a class="headerlink" href="#table-target-binary-descriptor" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 27%" />
<col style="width: 22%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Type</p></th>
<th class="head"><p>Identifier</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>int32_t</p></td>
<td><p>NumDeviceImages</p></td>
<td><p>Number of device types supported</p></td>
</tr>
<tr class="row-odd"><td><p>__tgt_device_image*</p></td>
<td><p>DeviceImages</p></td>
<td><p>Array of device images (1 per dev. type)</p></td>
</tr>
<tr class="row-even"><td><p>__tgt_offload_entry*</p></td>
<td><p>HostEntriesBegin</p></td>
<td><p>Begin of table with all host entries</p></td>
</tr>
<tr class="row-odd"><td><p>__tgt_offload_entry*</p></td>
<td><p>HostEntriesEnd</p></td>
<td><p>End of table (non inclusive)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
</div>
<div class="section" id="global-variables">
<h3><a class="toc-backref" href="#id17">Global Variables</a><a class="headerlink" href="#global-variables" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#table-global-variables"><span class="std std-ref">Global Variables</span></a> lists various global variables, along with their
type and their explicit ELF sections, which are used to store device images and
related symbols.</p>
<blockquote>
<div><table class="docutils align-default" id="table-global-variables">
<caption><span class="caption-text">Global Variables</span><a class="headerlink" href="#table-global-variables" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 24%" />
<col style="width: 16%" />
<col style="width: 19%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Variable</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>ELF Section</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>__start_omp_offloading_entries</p></td>
<td><p>__tgt_offload_entry</p></td>
<td><p>.omp_offloading_entries</p></td>
<td><p>Begin symbol for the offload entries table.</p></td>
</tr>
<tr class="row-odd"><td><p>__stop_omp_offloading_entries</p></td>
<td><p>__tgt_offload_entry</p></td>
<td><p>.omp_offloading_entries</p></td>
<td><p>End symbol for the offload entries table.</p></td>
</tr>
<tr class="row-even"><td><p>__dummy.omp_offloading.entry</p></td>
<td><p>__tgt_offload_entry</p></td>
<td><p>.omp_offloading_entries</p></td>
<td><p>Dummy zero-sized object in the offload entries
section to force linker to define begin/end
symbols defined above.</p></td>
</tr>
<tr class="row-odd"><td><p>.omp_offloading.device_image</p></td>
<td><p>__tgt_device_image</p></td>
<td><p>.omp_offloading_entries</p></td>
<td><p>ELF device code object of the first image.</p></td>
</tr>
<tr class="row-even"><td><p>.omp_offloading.device_image.N</p></td>
<td><p>__tgt_device_image</p></td>
<td><p>.omp_offloading_entries</p></td>
<td><p>ELF device code object of the (N+1)th image.</p></td>
</tr>
<tr class="row-odd"><td><p>.omp_offloading.device_images</p></td>
<td><p>__tgt_device_image</p></td>
<td><p>.omp_offloading_entries</p></td>
<td><p>Array of images.</p></td>
</tr>
<tr class="row-even"><td><p>.omp_offloading.descriptor</p></td>
<td><p>__tgt_bin_desc</p></td>
<td><p>.omp_offloading_entries</p></td>
<td><p>Binary descriptor object (see <a class="reference internal" href="#binary-descriptor"><span class="std std-ref">Binary Descriptor for Device Images</span></a>)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<div class="section" id="binary-descriptor-for-device-images">
<span id="binary-descriptor"></span><h4><a class="toc-backref" href="#id18">Binary Descriptor for Device Images</a><a class="headerlink" href="#binary-descriptor-for-device-images" title="Permalink to this headline">¶</a></h4>
<p>This object is passed to the offloading runtime at program startup and it
describes all device images available in the executable or shared library. It
is defined as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">__attribute__</span><span class="p">((</span><span class="n">visibility</span><span class="p">(</span><span class="s">&quot;hidden&quot;</span><span class="p">)))</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="n">__tgt_offload_entry</span><span class="w"> </span><span class="o">*</span><span class="n">__start_omp_offloading_entries</span><span class="p">;</span><span class="w"></span>
<span class="n">__attribute__</span><span class="p">((</span><span class="n">visibility</span><span class="p">(</span><span class="s">&quot;hidden&quot;</span><span class="p">)))</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="n">__tgt_offload_entry</span><span class="w"> </span><span class="o">*</span><span class="n">__stop_omp_offloading_entries</span><span class="p">;</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">Image0</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Bufs</span><span class="p">.</span><span class="n">front</span><span class="p">()</span><span class="w"> </span><span class="n">contents</span><span class="o">&gt;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">ImageN</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Bufs</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="w"> </span><span class="n">contents</span><span class="o">&gt;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">__tgt_device_image</span><span class="w"> </span><span class="n">Images</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Image0</span><span class="p">,</span><span class="w">                            </span><span class="cm">/*ImageStart*/</span><span class="w"></span>
<span class="w">    </span><span class="n">Image0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">Image0</span><span class="p">),</span><span class="w">           </span><span class="cm">/*ImageEnd*/</span><span class="w"></span>
<span class="w">    </span><span class="n">__start_omp_offloading_entries</span><span class="p">,</span><span class="w">    </span><span class="cm">/*EntriesBegin*/</span><span class="w"></span>
<span class="w">    </span><span class="n">__stop_omp_offloading_entries</span><span class="w">      </span><span class="cm">/*EntriesEnd*/</span><span class="w"></span>
<span class="w">  </span><span class="p">},</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ImageN</span><span class="p">,</span><span class="w">                            </span><span class="cm">/*ImageStart*/</span><span class="w"></span>
<span class="w">    </span><span class="n">ImageN</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ImageN</span><span class="p">),</span><span class="w">           </span><span class="cm">/*ImageEnd*/</span><span class="w"></span>
<span class="w">    </span><span class="n">__start_omp_offloading_entries</span><span class="p">,</span><span class="w">    </span><span class="cm">/*EntriesBegin*/</span><span class="w"></span>
<span class="w">    </span><span class="n">__stop_omp_offloading_entries</span><span class="w">      </span><span class="cm">/*EntriesEnd*/</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">__tgt_bin_desc</span><span class="w"> </span><span class="n">BinDesc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">sizeof</span><span class="p">(</span><span class="n">Images</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">Images</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="w">  </span><span class="cm">/*NumDeviceImages*/</span><span class="w"></span>
<span class="w">  </span><span class="n">Images</span><span class="p">,</span><span class="w">                              </span><span class="cm">/*DeviceImages*/</span><span class="w"></span>
<span class="w">  </span><span class="n">__start_omp_offloading_entries</span><span class="p">,</span><span class="w">      </span><span class="cm">/*HostEntriesBegin*/</span><span class="w"></span>
<span class="w">  </span><span class="n">__stop_omp_offloading_entries</span><span class="w">        </span><span class="cm">/*HostEntriesEnd*/</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="global-constructor-and-destructor">
<h4><a class="toc-backref" href="#id19">Global Constructor and Destructor</a><a class="headerlink" href="#global-constructor-and-destructor" title="Permalink to this headline">¶</a></h4>
<p>The global constructor (<code class="docutils literal notranslate"><span class="pre">.omp_offloading.descriptor_reg()</span></code>) registers the
device images with the runtime by calling the <code class="docutils literal notranslate"><span class="pre">__tgt_register_lib()</span></code> runtime
function. The constructor is explicitly defined in <code class="docutils literal notranslate"><span class="pre">.text.startup</span></code> section and
is run once when the program starts. Similarly, the global destructor
(<code class="docutils literal notranslate"><span class="pre">.omp_offloading.descriptor_unreg()</span></code>) calls <code class="docutils literal notranslate"><span class="pre">__tgt_unregister_lib()</span></code> for
the destructor and is also defined in <code class="docutils literal notranslate"><span class="pre">.text.startup</span></code> section and run when the
program exits.</p>
</div>
</div>
<div class="section" id="offloading-example">
<h3><a class="toc-backref" href="#id20">Offloading Example</a><a class="headerlink" href="#offloading-example" title="Permalink to this headline">¶</a></h3>
<p>This section contains a simple example of generating offloading code using
OpenMP offloading. We will use a simple <code class="docutils literal notranslate"><span class="pre">ZAXPY</span></code> BLAS routine.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;complex&gt;</span><span class="cp"></span>

<span class="k">using</span><span class="w"> </span><span class="n">complex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">zaxpy</span><span class="p">(</span><span class="n">complex</span><span class="w"> </span><span class="o">*</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">complex</span><span class="w"> </span><span class="o">*</span><span class="n">Y</span><span class="p">,</span><span class="w"> </span><span class="n">complex</span><span class="w"> </span><span class="n">D</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="cp">#pragma omp target teams distribute parallel for</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">complex</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">Y</span><span class="p">[</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="n">D</span><span class="p">;</span><span class="w"></span>
<span class="cp">#pragma omp target data map(to:X[0 : N]) map(tofrom:Y[0 : N])</span>
<span class="w">  </span><span class="n">zaxpy</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">Y</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This code is compiled using the following Clang flags.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++ -fopenmp -fopenmp-targets<span class="o">=</span>nvptx64 -O3 zaxpy.cpp -c
</pre></div>
</div>
<p>The output section in the object file can be seen using the <code class="docutils literal notranslate"><span class="pre">readelf</span></code> utility.
The <code class="docutils literal notranslate"><span class="pre">.llvm.offloading</span></code> section has the <code class="docutils literal notranslate"><span class="pre">SHF_EXCLUDE</span></code> flag so it will be
removed from the final executable or shared library by the linker.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ llvm-readelf -WS zaxpy.o
Section Headers:
[Nr] Name                   Type     Address          Off    Size   ES Flg Lk Inf Al
[11] omp_offloading_entries PROGBITS 0000000000000000 0001f0 000040 00   A  0   0  1
[12] .llvm.offloading       PROGBITS 0000000000000000 000260 030950 00   E  0   0  8
</pre></div>
</div>
<p>Compiling this file again will invoke the <code class="docutils literal notranslate"><span class="pre">clang-linker-wrapper</span></code> utility to
extract and link the device code stored at the section named
<code class="docutils literal notranslate"><span class="pre">.llvm.offloading</span></code> and then use entries stored in
the section named <code class="docutils literal notranslate"><span class="pre">omp_offloading_entries</span></code> to create the symbols necessary for
<code class="docutils literal notranslate"><span class="pre">libomptarget</span></code> to register the device image and call the entry function.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++ -fopenmp -fopenmp-targets<span class="o">=</span>nvptx64 zaxpy.o -o zaxpy
<span class="gp">$ </span>./zaxpy
</pre></div>
</div>
<p>We can see the steps created by clang to generate the offloading code using the
<code class="docutils literal notranslate"><span class="pre">-ccc-print-phases</span></code> option in Clang. This matches the description in
<a class="reference internal" href="#offloading-overview"><span class="std std-ref">Offloading Overview</span></a>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++ -fopenmp -fopenmp-targets<span class="o">=</span>nvptx64 -ccc-print-phases zaxpy.cpp
<span class="gp"># </span><span class="s2">&quot;x86_64-unknown-linux-gnu&quot;</span> - <span class="s2">&quot;clang&quot;</span>, inputs: <span class="o">[</span><span class="s2">&quot;zaxpy.cpp&quot;</span><span class="o">]</span>, output: <span class="s2">&quot;/tmp/zaxpy-host.bc&quot;</span>
<span class="gp"># </span><span class="s2">&quot;nvptx64-nvidia-cuda&quot;</span> - <span class="s2">&quot;clang&quot;</span>, inputs: <span class="o">[</span><span class="s2">&quot;zaxpy.cpp&quot;</span>, <span class="s2">&quot;/tmp/zaxpy-e6a41b.bc&quot;</span><span class="o">]</span>, output: <span class="s2">&quot;/tmp/zaxpy-07f434.s&quot;</span>
<span class="gp"># </span><span class="s2">&quot;nvptx64-nvidia-cuda&quot;</span> - <span class="s2">&quot;NVPTX::Assembler&quot;</span>, inputs: <span class="o">[</span><span class="s2">&quot;/tmp/zaxpy-07f434.s&quot;</span><span class="o">]</span>, output: <span class="s2">&quot;/tmp/zaxpy-0af7b7.o&quot;</span>
<span class="gp"># </span><span class="s2">&quot;x86_64-unknown-linux-gnu&quot;</span> - <span class="s2">&quot;clang&quot;</span>, inputs: <span class="o">[</span><span class="s2">&quot;/tmp/zaxpy-e6a41b.bc&quot;</span>, <span class="s2">&quot;/tmp/zaxpy-0af7b7.o&quot;</span><span class="o">]</span>, output: <span class="s2">&quot;/tmp/zaxpy-416cad.o&quot;</span>
<span class="gp"># </span><span class="s2">&quot;x86_64-unknown-linux-gnu&quot;</span> - <span class="s2">&quot;Offload::Linker&quot;</span>, inputs: <span class="o">[</span><span class="s2">&quot;/tmp/zaxpy-416cad.o&quot;</span><span class="o">]</span>, output: <span class="s2">&quot;a.out&quot;</span>
</pre></div>
</div>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="DriverInternals.html">Driver Design &amp; Internals</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="PCHInternals.html">Precompiled Header and Modules Internals</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2007-2022, The Clang Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>
  </body>
</html>