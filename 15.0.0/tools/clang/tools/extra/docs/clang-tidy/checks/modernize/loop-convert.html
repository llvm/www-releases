
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>clang-tidy - modernize-loop-convert &#8212; Extra Clang Tools 15.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/haiku.css" />
    <link rel="stylesheet" href="../../../_static/clang-tools-extra-styles.css" type="text/css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="modernize-macro-to-enum" href="macro-to-enum.html" />
    <link rel="prev" title="modernize-deprecated-ios-base-aliases" href="deprecated-ios-base-aliases.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../../index.html">
          <span>Extra Clang Tools 15.0.0 documentation</span></a></h1>
        <h2 class="heading"><span>clang-tidy - modernize-loop-convert</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="deprecated-ios-base-aliases.html">modernize-deprecated-ios-base-aliases</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="macro-to-enum.html">modernize-macro-to-enum</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <div class="section" id="modernize-loop-convert">
<h1>modernize-loop-convert<a class="headerlink" href="#modernize-loop-convert" title="Permalink to this headline">¶</a></h1>
<p>This check converts <code class="docutils literal notranslate"><span class="pre">for(...;</span> <span class="pre">...;</span> <span class="pre">...)</span></code> loops to use the new range-based
loops in C++11.</p>
<p>Three kinds of loops can be converted:</p>
<ul class="simple">
<li><p>Loops over statically allocated arrays.</p></li>
<li><p>Loops over containers, using iterators.</p></li>
<li><p>Loops over array-like containers, using <code class="docutils literal notranslate"><span class="pre">operator[]</span></code> and <code class="docutils literal notranslate"><span class="pre">at()</span></code>.</p></li>
</ul>
<div class="section" id="minconfidence-option">
<h2>MinConfidence option<a class="headerlink" href="#minconfidence-option" title="Permalink to this headline">¶</a></h2>
<div class="section" id="risky">
<h3>risky<a class="headerlink" href="#risky" title="Permalink to this headline">¶</a></h3>
<p>In loops where the container expression is more complex than just a
reference to a declared expression (a variable, function, enum, etc.),
and some part of it appears elsewhere in the loop, we lower our confidence
in the transformation due to the increased risk of changing semantics.
Transformations for these loops are marked as <cite>risky</cite>, and thus will only
be converted if the minimum required confidence level is set to <cite>risky</cite>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">20</span><span class="p">];</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">l</span><span class="p">;</span><span class="w"> </span><span class="c1">// using l outside arr[l] is considered risky</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="n">getVector</span><span class="p">().</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">obj</span><span class="p">.</span><span class="n">foo</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c1">// using &#39;obj&#39; is considered risky</span>
</pre></div>
</div>
<p>See
<a class="reference internal" href="#incorrectriskytransformation"><span class="std std-ref">Range-based loops evaluate end() only once</span></a>
for an example of an incorrect transformation when the minimum required confidence
level is set to <cite>risky</cite>.</p>
</div>
<div class="section" id="reasonable-default">
<h3>reasonable (Default)<a class="headerlink" href="#reasonable-default" title="Permalink to this headline">¶</a></h3>
<p>If a loop calls <code class="docutils literal notranslate"><span class="pre">.end()</span></code> or <code class="docutils literal notranslate"><span class="pre">.size()</span></code> after each iteration, the
transformation for that loop is marked as <cite>reasonable</cite>, and thus will
be converted if the required confidence level is set to <cite>reasonable</cite>
(default) or lower.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// using size() is considered reasonable</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">container</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">container</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="safe">
<h3>safe<a class="headerlink" href="#safe" title="Permalink to this headline">¶</a></h3>
<p>Any other loops that do not match the above criteria to be marked as
<cite>risky</cite> or <cite>reasonable</cite> are marked <cite>safe</cite>, and thus will be converted
if the required confidence level is set to <cite>safe</cite> or lower.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="example">
<h2>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h2>
<p>Original:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span><span class="w"></span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"></span>

<span class="c1">// safe conversion</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>

<span class="c1">// reasonable conversion</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="p">;</span><span class="w"></span>

<span class="c1">// reasonable conversion</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<p>After applying the check with minimum confidence level set to <cite>reasonable</cite> (default):</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span><span class="w"></span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"></span>

<span class="c1">// safe conversion</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nl">elem</span> <span class="p">:</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">elem</span><span class="p">;</span><span class="w"></span>

<span class="c1">// reasonable conversion</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nl">elem</span> <span class="p">:</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">elem</span><span class="p">;</span><span class="w"></span>

<span class="c1">// reasonable conversion</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nl">elem</span> <span class="p">:</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">elem</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="reverse-iterator-support">
<h2>Reverse Iterator Support<a class="headerlink" href="#reverse-iterator-support" title="Permalink to this headline">¶</a></h2>
<p>The converter is also capable of transforming iterator loops which use
<code class="docutils literal notranslate"><span class="pre">rbegin</span></code> and <code class="docutils literal notranslate"><span class="pre">rend</span></code> for looping backwards over a container. Out of the box
this will automatically happen in C++20 mode using the <code class="docutils literal notranslate"><span class="pre">ranges</span></code> library,
however the check can be configured to work without C++20 by specifying a
function to reverse a range and optionally the header file where that function
lives.</p>
<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-arg-UseCxx20ReverseRanges">
<span id="cmdoption-arg-usecxx20reverseranges"></span><span class="sig-name descname"><span class="pre">UseCxx20ReverseRanges</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-arg-UseCxx20ReverseRanges" title="Permalink to this definition">¶</a></dt>
<dd><p>When set to true convert loops when in C++20 or later mode using
<code class="docutils literal notranslate"><span class="pre">std::ranges::reverse_view</span></code>.
Default value is <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-arg-MakeReverseRangeFunction">
<span id="cmdoption-arg-makereverserangefunction"></span><span class="sig-name descname"><span class="pre">MakeReverseRangeFunction</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-arg-MakeReverseRangeFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Specify the function used to reverse an iterator pair, the function should
accept a class with <code class="docutils literal notranslate"><span class="pre">rbegin</span></code> and <code class="docutils literal notranslate"><span class="pre">rend</span></code> methods and return a
class with <code class="docutils literal notranslate"><span class="pre">begin</span></code> and <code class="docutils literal notranslate"><span class="pre">end</span></code> methods that call the <code class="docutils literal notranslate"><span class="pre">rbegin</span></code> and
<code class="docutils literal notranslate"><span class="pre">rend</span></code> methods respectively. Common examples are <code class="docutils literal notranslate"><span class="pre">ranges::reverse_view</span></code>
and <code class="docutils literal notranslate"><span class="pre">llvm::reverse</span></code>.
Default value is an empty string.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-arg-MakeReverseRangeHeader">
<span id="cmdoption-arg-makereverserangeheader"></span><span class="sig-name descname"><span class="pre">MakeReverseRangeHeader</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-arg-MakeReverseRangeHeader" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies the header file where <a class="reference internal" href="#cmdoption-arg-MakeReverseRangeFunction"><code class="xref std std-option docutils literal notranslate"><span class="pre">MakeReverseRangeFunction</span></code></a> is
declared. For the previous examples this option would be set to
<code class="docutils literal notranslate"><span class="pre">range/v3/view/reverse.hpp</span></code> and <code class="docutils literal notranslate"><span class="pre">llvm/ADT/STLExtras.h</span></code> respectively.
If this is an empty string and <a class="reference internal" href="#cmdoption-arg-MakeReverseRangeFunction"><code class="xref std std-option docutils literal notranslate"><span class="pre">MakeReverseRangeFunction</span></code></a> is set,
the check will proceed on the assumption that the function is already
available in the translation unit.
This can be wrapped in angle brackets to signify to add the include as a
system include.
Default value is an empty string.</p>
</dd></dl>

<dl class="std option">
<dt class="sig sig-object std" id="cmdoption-arg-IncludeStyle">
<span id="cmdoption-arg-includestyle"></span><span class="sig-name descname"><span class="pre">IncludeStyle</span></span><span class="sig-prename descclassname"></span><a class="headerlink" href="#cmdoption-arg-IncludeStyle" title="Permalink to this definition">¶</a></dt>
<dd><p>A string specifying which include-style is used, <cite>llvm</cite> or <cite>google</cite>. Default
is <cite>llvm</cite>.</p>
</dd></dl>

</div>
<div class="section" id="limitations">
<h2>Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h2>
<p>There are certain situations where the tool may erroneously perform
transformations that remove information and change semantics. Users of the tool
should be aware of the behavior and limitations of the check outlined by
the cases below.</p>
<div class="section" id="comments-inside-loop-headers">
<h3>Comments inside loop headers<a class="headerlink" href="#comments-inside-loop-headers" title="Permalink to this headline">¶</a></h3>
<p>Comments inside the original loop header are ignored and deleted when
transformed.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="cm">/* This will be deleted */</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="range-based-loops-evaluate-end-only-once">
<h3>Range-based loops evaluate end() only once<a class="headerlink" href="#range-based-loops-evaluate-end-only-once" title="Permalink to this headline">¶</a></h3>
<p>The C++11 range-based for loop calls <code class="docutils literal notranslate"><span class="pre">.end()</span></code> only once during the
initialization of the loop. If in the original loop <code class="docutils literal notranslate"><span class="pre">.end()</span></code> is called after
each iteration the semantics of the transformed loop may differ.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// The following is semantically equivalent to the C++11 range-based for loop,</span>
<span class="c1">// therefore the semantics of the header will not change.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="c1">// Instead of calling .end() after each iteration, this loop will be</span>
<span class="c1">// transformed to call .end() only once during the initialization of the loop,</span>
<span class="c1">// which may affect semantics.</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">container</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p id="incorrectriskytransformation">As explained above, calling member functions of the container in the body
of the loop is considered <cite>risky</cite>. If the called member function modifies the
container the semantics of the converted loop will differ due to <code class="docutils literal notranslate"><span class="pre">.end()</span></code>
being called only once.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Add a copy of the first element to the end of the vector.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// This line makes this transformation &#39;risky&#39;.</span>
<span class="w">    </span><span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The original code above prints out the contents of the container including the
newly added element while the converted loop, shown below, will only print the
original contents and not the newly added element.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nl">elem</span> <span class="p">:</span><span class="w"> </span><span class="n">vec</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Add a copy of the first element to the end of the vector.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// This line makes this transformation &#39;risky&#39;</span>
<span class="w">    </span><span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">elem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Semantics will also be affected if <code class="docutils literal notranslate"><span class="pre">.end()</span></code> has side effects. For example, in
the case where calls to <code class="docutils literal notranslate"><span class="pre">.end()</span></code> are logged the semantics will change in the
transformed loop if <code class="docutils literal notranslate"><span class="pre">.end()</span></code> was originally called after each iteration.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">iterator</span><span class="w"> </span><span class="nf">end</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">num_of_end_calls</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">container</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="overloaded-operator-with-side-effects">
<h3>Overloaded operator-&gt;() with side effects<a class="headerlink" href="#overloaded-operator-with-side-effects" title="Permalink to this headline">¶</a></h3>
<p>Similarly, if <code class="docutils literal notranslate"><span class="pre">operator-&gt;()</span></code> was overloaded to have side effects, such as
logging, the semantics will change. If the iterator’s <code class="docutils literal notranslate"><span class="pre">operator-&gt;()</span></code> was used
in the original loop it will be replaced with <code class="docutils literal notranslate"><span class="pre">&lt;container</span> <span class="pre">element&gt;.&lt;member&gt;</span></code>
instead due to the implicit dereference as part of the range-based for loop.
Therefore any side effect of the overloaded <code class="docutils literal notranslate"><span class="pre">operator-&gt;()</span></code> will no longer be
performed.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">();</span><span class="w"> </span><span class="c1">// Using operator-&gt;()</span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// Will be transformed to:</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nl">elem</span> <span class="p">:</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">elem</span><span class="p">.</span><span class="n">func</span><span class="p">();</span><span class="w"> </span><span class="c1">// No longer using operator-&gt;()</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="pointers-and-references-to-containers">
<h3>Pointers and references to containers<a class="headerlink" href="#pointers-and-references-to-containers" title="Permalink to this headline">¶</a></h3>
<p>While most of the check’s risk analysis is dedicated to determining whether
the iterator or container was modified within the loop, it is possible to
circumvent the analysis by accessing and modifying the container through a
pointer or reference.</p>
<p>If the container were directly used instead of using the pointer or reference
the following transformation would have only been applied at the <cite>risky</cite>
level since calling a member function of the container is considered <cite>risky</cite>.
The check cannot identify expressions associated with the container that are
different than the one used in the loop header, therefore the transformation
below ends up being performed at the <cite>safe</cite> level.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="p">;</span><span class="w"></span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vec</span><span class="p">;</span><span class="w"></span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">;</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Accessing and modifying the container is considered risky, but the risk</span>
<span class="w">    </span><span class="c1">// level is not raised here.</span>
<span class="w">    </span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">ref</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="openmp">
<h3>OpenMP<a class="headerlink" href="#openmp" title="Permalink to this headline">¶</a></h3>
<p>As range-based for loops are only available since OpenMP 5, this check should
not be used on code with a compatibility requirement of OpenMP prior to
version 5. It is <strong>intentional</strong> that this check does not make any attempts to
exclude incorrect diagnostics on OpenMP for loops prior to OpenMP 5.</p>
<p>To prevent this check to be applied (and to break) OpenMP for loops but still be
applied to non-OpenMP for loops the usage of <code class="docutils literal notranslate"><span class="pre">NOLINT</span></code> (see
<a class="reference internal" href="../../index.html#clang-tidy-nolint"><span class="std std-ref">Suppressing Undesired Diagnostics</span></a>) on the specific for loops is recommended.</p>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="deprecated-ios-base-aliases.html">modernize-deprecated-ios-base-aliases</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="macro-to-enum.html">modernize-macro-to-enum</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2007-2022, The Clang Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>
  </body>
</html>