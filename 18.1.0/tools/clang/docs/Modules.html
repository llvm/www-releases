<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Modules &#8212; Clang 18.1.0rc documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=d31ea6cb" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=eafc0fe6" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=f0e7387b"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="MSVC compatibility" href="MSVCCompatibility.html" />
    <link rel="prev" title="Standard C++ Modules" href="StandardCPlusPlusModules.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Clang 18.1.0rc documentation</span></a></h1>
        <h2 class="heading"><span>Modules</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="StandardCPlusPlusModules.html">Standard C++ Modules</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="MSVCCompatibility.html">MSVC compatibility</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="modules">
<h1>Modules<a class="headerlink" href="#modules" title="Permalink to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id9">Introduction</a></p>
<ul>
<li><p><a class="reference internal" href="#problems-with-the-current-model" id="id10">Problems with the current model</a></p></li>
<li><p><a class="reference internal" href="#semantic-import" id="id11">Semantic import</a></p></li>
<li><p><a class="reference internal" href="#problems-modules-do-not-solve" id="id12">Problems modules do not solve</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#using-modules" id="id13">Using Modules</a></p>
<ul>
<li><p><a class="reference internal" href="#standard-c-modules" id="id14">Standard C++ Modules</a></p></li>
<li><p><a class="reference internal" href="#objective-c-import-declaration" id="id15">Objective-C Import declaration</a></p></li>
<li><p><a class="reference internal" href="#includes-as-imports" id="id16">Includes as imports</a></p></li>
<li><p><a class="reference internal" href="#module-maps" id="id17">Module maps</a></p></li>
<li><p><a class="reference internal" href="#compilation-model" id="id18">Compilation model</a></p></li>
<li><p><a class="reference internal" href="#command-line-parameters" id="id19">Command-line parameters</a></p>
<ul>
<li><p><a class="reference internal" href="#cc1-options" id="id20">-cc1 Options</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#using-prebuilt-modules" id="id21">Using Prebuilt Modules</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#module-semantics" id="id22">Module Semantics</a></p>
<ul>
<li><p><a class="reference internal" href="#macros" id="id23">Macros</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#module-map-language" id="id24">Module Map Language</a></p>
<ul>
<li><p><a class="reference internal" href="#lexical-structure" id="id25">Lexical structure</a></p></li>
<li><p><a class="reference internal" href="#module-map-file" id="id26">Module map file</a></p></li>
<li><p><a class="reference internal" href="#module-declaration" id="id27">Module declaration</a></p>
<ul>
<li><p><a class="reference internal" href="#requires-declaration" id="id28">Requires declaration</a></p></li>
<li><p><a class="reference internal" href="#header-declaration" id="id29">Header declaration</a></p></li>
<li><p><a class="reference internal" href="#umbrella-directory-declaration" id="id30">Umbrella directory declaration</a></p></li>
<li><p><a class="reference internal" href="#submodule-declaration" id="id31">Submodule declaration</a></p></li>
<li><p><a class="reference internal" href="#export-declaration" id="id32">Export declaration</a></p></li>
<li><p><a class="reference internal" href="#re-export-declaration" id="id33">Re-export Declaration</a></p></li>
<li><p><a class="reference internal" href="#use-declaration" id="id34">Use declaration</a></p></li>
<li><p><a class="reference internal" href="#link-declaration" id="id35">Link declaration</a></p></li>
<li><p><a class="reference internal" href="#configuration-macros-declaration" id="id36">Configuration macros declaration</a></p></li>
<li><p><a class="reference internal" href="#conflict-declarations" id="id37">Conflict declarations</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#attributes" id="id38">Attributes</a></p></li>
<li><p><a class="reference internal" href="#private-module-map-files" id="id39">Private Module Map Files</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#modularizing-a-platform" id="id40">Modularizing a Platform</a></p></li>
<li><p><a class="reference internal" href="#future-directions" id="id41">Future Directions</a></p></li>
<li><p><a class="reference internal" href="#where-to-learn-more-about-modules" id="id42">Where To Learn More About Modules</a></p></li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this heading">¶</a></h2>
<p>Most software is built using a number of software libraries, including libraries supplied by the platform, internal libraries built as part of the software itself to provide structure, and third-party libraries. For each library, one needs to access both its interface (API) and its implementation. In the C family of languages, the interface to a library is accessed by including the appropriate header files(s):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;SomeLib.h&gt;</span>
</pre></div>
</div>
<p>The implementation is handled separately by linking against the appropriate library. For example, by passing <code class="docutils literal notranslate"><span class="pre">-lSomeLib</span></code> to the linker.</p>
<p>Modules provide an alternative, simpler way to use software libraries that provides better compile-time scalability and eliminates many of the problems inherent to using the C preprocessor to access the API of a library.</p>
<section id="problems-with-the-current-model">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Problems with the current model</a><a class="headerlink" href="#problems-with-the-current-model" title="Permalink to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">#include</span></code> mechanism provided by the C preprocessor is a very poor way to access the API of a library, for a number of reasons:</p>
<ul class="simple">
<li><p><strong>Compile-time scalability</strong>: Each time a header is included, the
compiler must preprocess and parse the text in that header and every
header it includes, transitively. This process must be repeated for
every translation unit in the application, which involves a huge
amount of redundant work. In a project with <em>N</em> translation units
and <em>M</em> headers included in each translation unit, the compiler is
performing <em>M x N</em> work even though most of the <em>M</em> headers are
shared among multiple translation units. C++ is particularly bad,
because the compilation model for templates forces a huge amount of
code into headers.</p></li>
<li><p><strong>Fragility</strong>: <code class="docutils literal notranslate"><span class="pre">#include</span></code> directives are treated as textual
inclusion by the preprocessor, and are therefore subject to any
active macro definitions at the time of inclusion. If any of the
active macro definitions happens to collide with a name in the
library, it can break the library API or cause compilation failures
in the library header itself. For an extreme example,
<code class="docutils literal notranslate"><span class="pre">#define</span> <span class="pre">std</span> <span class="pre">&quot;The</span> <span class="pre">C++</span> <span class="pre">Standard&quot;</span></code> and then include a standard
library header: the result is a horrific cascade of failures in the
C++ Standard Library’s implementation. More subtle real-world
problems occur when the headers for two different libraries interact
due to macro collisions, and users are forced to reorder
<code class="docutils literal notranslate"><span class="pre">#include</span></code> directives or introduce <code class="docutils literal notranslate"><span class="pre">#undef</span></code> directives to break
the (unintended) dependency.</p></li>
<li><p><strong>Conventional workarounds</strong>: C programmers have
adopted a number of conventions to work around the fragility of the
C preprocessor model. Include guards, for example, are required for
the vast majority of headers to ensure that multiple inclusion
doesn’t break the compile. Macro names are written with
<code class="docutils literal notranslate"><span class="pre">LONG_PREFIXED_UPPERCASE_IDENTIFIERS</span></code> to avoid collisions, and some
library/framework developers even use <code class="docutils literal notranslate"><span class="pre">__underscored</span></code> names
in headers to avoid collisions with “normal” names that (by
convention) shouldn’t even be macros. These conventions are a
barrier to entry for developers coming from non-C languages, are
boilerplate for more experienced developers, and make our headers
far uglier than they should be.</p></li>
<li><p><strong>Tool confusion</strong>: In a C-based language, it is hard to build tools
that work well with software libraries, because the boundaries of
the libraries are not clear. Which headers belong to a particular
library, and in what order should those headers be included to
guarantee that they compile correctly? Are the headers C, C++,
Objective-C++, or one of the variants of these languages? What
declarations in those headers are actually meant to be part of the
API, and what declarations are present only because they had to be
written as part of the header file?</p></li>
</ul>
</section>
<section id="semantic-import">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Semantic import</a><a class="headerlink" href="#semantic-import" title="Permalink to this heading">¶</a></h3>
<p>Modules improve access to the API of software libraries by replacing the textual preprocessor inclusion model with a more robust, more efficient semantic model. From the user’s perspective, the code looks only slightly different, because one uses an <code class="docutils literal notranslate"><span class="pre">import</span></code> declaration rather than a <code class="docutils literal notranslate"><span class="pre">#include</span></code> preprocessor directive:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">import</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">io</span><span class="p">;</span><span class="w"> </span><span class="c1">// pseudo-code; see below for syntax discussion</span>
</pre></div>
</div>
<p>However, this module import behaves quite differently from the corresponding <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;stdio.h&gt;</span></code>: when the compiler sees the module import above, it loads a binary representation of the <code class="docutils literal notranslate"><span class="pre">std.io</span></code> module and makes its API available to the application directly. Preprocessor definitions that precede the import declaration have no impact on the API provided by <code class="docutils literal notranslate"><span class="pre">std.io</span></code>, because the module itself was compiled as a separate, standalone module. Additionally, any linker flags required to use the <code class="docutils literal notranslate"><span class="pre">std.io</span></code> module will automatically be provided when the module is imported <a class="footnote-reference brackets" href="#id5" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>
This semantic import model addresses many of the problems of the preprocessor inclusion model:</p>
<ul class="simple">
<li><p><strong>Compile-time scalability</strong>: The <code class="docutils literal notranslate"><span class="pre">std.io</span></code> module is only compiled once, and importing the module into a translation unit is a constant-time operation (independent of module system). Thus, the API of each software library is only parsed once, reducing the <em>M x N</em> compilation problem to an <em>M + N</em> problem.</p></li>
<li><p><strong>Fragility</strong>: Each module is parsed as a standalone entity, so it has a consistent preprocessor environment. This completely eliminates the need for <code class="docutils literal notranslate"><span class="pre">__underscored</span></code> names and similarly defensive tricks. Moreover, the current preprocessor definitions when an import declaration is encountered are ignored, so one software library can not affect how another software library is compiled, eliminating include-order dependencies.</p></li>
<li><p><strong>Tool confusion</strong>: Modules describe the API of software libraries, and tools can reason about and present a module as a representation of that API. Because modules can only be built standalone, tools can rely on the module definition to ensure that they get the complete API for the library. Moreover, modules can specify which languages they work with, so, e.g., one can not accidentally attempt to load a C++ module into a C program.</p></li>
</ul>
</section>
<section id="problems-modules-do-not-solve">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Problems modules do not solve</a><a class="headerlink" href="#problems-modules-do-not-solve" title="Permalink to this heading">¶</a></h3>
<p>Many programming languages have a module or package system, and because of the variety of features provided by these languages it is important to define what modules do <em>not</em> do. In particular, all of the following are considered out-of-scope for modules:</p>
<ul class="simple">
<li><p><strong>Rewrite the world’s code</strong>: It is not realistic to require applications or software libraries to make drastic or non-backward-compatible changes, nor is it feasible to completely eliminate headers. Modules must interoperate with existing software libraries and allow a gradual transition.</p></li>
<li><p><strong>Versioning</strong>: Modules have no notion of version information. Programmers must still rely on the existing versioning mechanisms of the underlying language (if any exist) to version software libraries.</p></li>
<li><p><strong>Namespaces</strong>: Unlike in some languages, modules do not imply any notion of namespaces. Thus, a struct declared in one module will still conflict with a struct of the same name declared in a different module, just as they would if declared in two different headers. This aspect is important for backward compatibility, because (for example) the mangled names of entities in software libraries must not change when introducing modules.</p></li>
<li><p><strong>Binary distribution of modules</strong>: Headers (particularly C++ headers) expose the full complexity of the language. Maintaining a stable binary module format across architectures, compiler versions, and compiler vendors is technically infeasible.</p></li>
</ul>
</section>
</section>
<section id="using-modules">
<h2><a class="toc-backref" href="#id13" role="doc-backlink">Using Modules</a><a class="headerlink" href="#using-modules" title="Permalink to this heading">¶</a></h2>
<p>To enable modules, pass the command-line flag <code class="docutils literal notranslate"><span class="pre">-fmodules</span></code>. This will make any modules-enabled software libraries available as modules as well as introducing any modules-specific syntax. Additional <a class="reference internal" href="#command-line-parameters">command-line parameters</a> are described in a separate section later.</p>
<section id="standard-c-modules">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Standard C++ Modules</a><a class="headerlink" href="#standard-c-modules" title="Permalink to this heading">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Modules are adopted into C++20 Standard. And its semantic and command line interface are very different from the Clang C++ modules. See <a class="reference external" href="StandardCPlusPlusModules.html">StandardCPlusPlusModules</a> for details.</p>
</div>
</section>
<section id="objective-c-import-declaration">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">Objective-C Import declaration</a><a class="headerlink" href="#objective-c-import-declaration" title="Permalink to this heading">¶</a></h3>
<p>Objective-C provides syntax for importing a module via an <em>&#64;import declaration</em>, which imports the named module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@import</span> <span class="n">std</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">&#64;import</span></code> declaration above imports the entire contents of the <code class="docutils literal notranslate"><span class="pre">std</span></code> module (which would contain, e.g., the entire C or C++ standard library) and make its API available within the current translation unit. To import only part of a module, one may use dot syntax to specific a particular submodule, e.g.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@import</span> <span class="n">std</span><span class="o">.</span><span class="n">io</span><span class="p">;</span>
</pre></div>
</div>
<p>Redundant import declarations are ignored, and one is free to import modules at any point within the translation unit, so long as the import declaration is at global scope.</p>
<p>At present, there is no C or C++ syntax for import declarations. Clang
will track the modules proposal in the C++ committee. See the section
<a class="reference internal" href="#includes-as-imports">Includes as imports</a> to see how modules get imported today.</p>
</section>
<section id="includes-as-imports">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">Includes as imports</a><a class="headerlink" href="#includes-as-imports" title="Permalink to this heading">¶</a></h3>
<p>The primary user-level feature of modules is the import operation, which provides access to the API of software libraries. However, today’s programs make extensive use of <code class="docutils literal notranslate"><span class="pre">#include</span></code>, and it is unrealistic to assume that all of this code will change overnight. Instead, modules automatically translate <code class="docutils literal notranslate"><span class="pre">#include</span></code> directives into the corresponding module import. For example, the include directive</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
</pre></div>
</div>
<p>will be automatically mapped to an import of the module <code class="docutils literal notranslate"><span class="pre">std.io</span></code>. Even with specific <code class="docutils literal notranslate"><span class="pre">import</span></code> syntax in the language, this particular feature is important for both adoption and backward compatibility: automatic translation of <code class="docutils literal notranslate"><span class="pre">#include</span></code> to <code class="docutils literal notranslate"><span class="pre">import</span></code> allows an application to get the benefits of modules (for all modules-enabled libraries) without any changes to the application itself. Thus, users can easily use modules with one compiler while falling back to the preprocessor-inclusion mechanism with other compilers.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The automatic mapping of <code class="docutils literal notranslate"><span class="pre">#include</span></code> to <code class="docutils literal notranslate"><span class="pre">import</span></code> also solves an implementation problem: importing a module with a definition of some entity (say, a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Point</span></code>) and then parsing a header containing another definition of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Point</span></code> would cause a redefinition error, even if it is the same <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Point</span></code>. By mapping <code class="docutils literal notranslate"><span class="pre">#include</span></code> to <code class="docutils literal notranslate"><span class="pre">import</span></code>, the compiler can guarantee that it always sees just the already-parsed definition from the module.</p>
</div>
<p>While building a module, <code class="docutils literal notranslate"><span class="pre">#include_next</span></code> is also supported, with one caveat.
The usual behavior of <code class="docutils literal notranslate"><span class="pre">#include_next</span></code> is to search for the specified filename
in the list of include paths, starting from the path <em>after</em> the one
in which the current file was found.
Because files listed in module maps are not found through include paths, a
different strategy is used for <code class="docutils literal notranslate"><span class="pre">#include_next</span></code> directives in such files: the
list of include paths is searched for the specified header name, to find the
first include path that would refer to the current file. <code class="docutils literal notranslate"><span class="pre">#include_next</span></code> is
interpreted as if the current file had been found in that path.
If this search finds a file named by a module map, the <code class="docutils literal notranslate"><span class="pre">#include_next</span></code>
directive is translated into an import, just like for a <code class="docutils literal notranslate"><span class="pre">#include</span></code>
directive.``</p>
</section>
<section id="module-maps">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">Module maps</a><a class="headerlink" href="#module-maps" title="Permalink to this heading">¶</a></h3>
<p>The crucial link between modules and headers is described by a <em>module map</em>, which describes how a collection of existing headers maps on to the (logical) structure of a module. For example, one could imagine a module <code class="docutils literal notranslate"><span class="pre">std</span></code> covering the C standard library. Each of the C standard library headers (<code class="docutils literal notranslate"><span class="pre">&lt;stdio.h&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;stdlib.h&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;math.h&gt;</span></code>, etc.) would contribute to the <code class="docutils literal notranslate"><span class="pre">std</span></code> module, by placing their respective APIs into the corresponding submodule (<code class="docutils literal notranslate"><span class="pre">std.io</span></code>, <code class="docutils literal notranslate"><span class="pre">std.lib</span></code>, <code class="docutils literal notranslate"><span class="pre">std.math</span></code>, etc.). Having a list of the headers that are part of the <code class="docutils literal notranslate"><span class="pre">std</span></code> module allows the compiler to build the <code class="docutils literal notranslate"><span class="pre">std</span></code> module as a standalone entity, and having the mapping from header names to (sub)modules allows the automatic translation of <code class="docutils literal notranslate"><span class="pre">#include</span></code> directives to module imports.</p>
<p>Module maps are specified as separate files (each named <code class="docutils literal notranslate"><span class="pre">module.modulemap</span></code>) alongside the headers they describe, which allows them to be added to existing software libraries without having to change the library headers themselves (in most cases <a class="footnote-reference brackets" href="#id6" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>). The actual <a class="reference internal" href="#module-map-language">Module map language</a> is described in a later section.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To actually see any benefits from modules, one first has to introduce module maps for the underlying C standard library and the libraries and headers on which it depends. The section <a class="reference internal" href="#modularizing-a-platform">Modularizing a Platform</a> describes the steps one must take to write these module maps.</p>
</div>
<p>One can use module maps without modules to check the integrity of the use of header files. To do this, use the <code class="docutils literal notranslate"><span class="pre">-fimplicit-module-maps</span></code> option instead of the <code class="docutils literal notranslate"><span class="pre">-fmodules</span></code> option, or use <code class="docutils literal notranslate"><span class="pre">-fmodule-map-file=</span></code> option to explicitly specify the module map files to load.</p>
</section>
<section id="compilation-model">
<h3><a class="toc-backref" href="#id18" role="doc-backlink">Compilation model</a><a class="headerlink" href="#compilation-model" title="Permalink to this heading">¶</a></h3>
<p>The binary representation of modules is automatically generated by the compiler on an as-needed basis. When a module is imported (e.g., by an <code class="docutils literal notranslate"><span class="pre">#include</span></code> of one of the module’s headers), the compiler will spawn a second instance of itself <a class="footnote-reference brackets" href="#id7" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>, with a fresh preprocessing context <a class="footnote-reference brackets" href="#id8" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>, to parse just the headers in that module. The resulting Abstract Syntax Tree (AST) is then persisted into the binary representation of the module that is then loaded into translation unit where the module import was encountered.</p>
<p>The binary representation of modules is persisted in the <em>module cache</em>. Imports of a module will first query the module cache and, if a binary representation of the required module is already available, will load that representation directly. Thus, a module’s headers will only be parsed once per language configuration, rather than once per translation unit that uses the module.</p>
<p>Modules maintain references to each of the headers that were part of the module build. If any of those headers changes, or if any of the modules on which a module depends change, then the module will be (automatically) recompiled. The process should never require any user intervention.</p>
</section>
<section id="command-line-parameters">
<h3><a class="toc-backref" href="#id19" role="doc-backlink">Command-line parameters</a><a class="headerlink" href="#command-line-parameters" title="Permalink to this heading">¶</a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">-fmodules</span></code></dt><dd><p>Enable the modules feature.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-fbuiltin-module-map</span></code></dt><dd><p>Load the Clang builtins module map file. (Equivalent to <code class="docutils literal notranslate"><span class="pre">-fmodule-map-file=&lt;resource</span> <span class="pre">dir&gt;/include/module.modulemap</span></code>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-fimplicit-module-maps</span></code></dt><dd><p>Enable implicit search for module map files named <code class="docutils literal notranslate"><span class="pre">module.modulemap</span></code> and similar. This option is implied by <code class="docutils literal notranslate"><span class="pre">-fmodules</span></code>. If this is disabled with <code class="docutils literal notranslate"><span class="pre">-fno-implicit-module-maps</span></code>, module map files will only be loaded if they are explicitly specified via <code class="docutils literal notranslate"><span class="pre">-fmodule-map-file</span></code> or transitively used by another module map file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-fmodules-cache-path=&lt;directory&gt;</span></code></dt><dd><p>Specify the path to the modules cache. If not provided, Clang will select a system-appropriate default.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-fno-autolink</span></code></dt><dd><p>Disable automatic linking against the libraries associated with imported modules.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-fmodules-ignore-macro=macroname</span></code></dt><dd><p>Instruct modules to ignore the named macro when selecting an appropriate module variant. Use this for macros defined on the command line that don’t affect how modules are built, to improve sharing of compiled module files.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-fmodules-prune-interval=seconds</span></code></dt><dd><p>Specify the minimum delay (in seconds) between attempts to prune the module cache. Module cache pruning attempts to clear out old, unused module files so that the module cache itself does not grow without bound. The default delay is large (604,800 seconds, or 7 days) because this is an expensive operation. Set this value to 0 to turn off pruning.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-fmodules-prune-after=seconds</span></code></dt><dd><p>Specify the minimum time (in seconds) for which a file in the module cache must be unused (according to access time) before module pruning will remove it. The default delay is large (2,678,400 seconds, or 31 days) to avoid excessive module rebuilding.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-module-file-info</span> <span class="pre">&lt;module</span> <span class="pre">file</span> <span class="pre">name&gt;</span></code></dt><dd><p>Debugging aid that prints information about a given module file (with a <code class="docutils literal notranslate"><span class="pre">.pcm</span></code> extension), including the language and preprocessor options that particular module variant was built with.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-fmodules-decluse</span></code></dt><dd><p>Enable checking of module <code class="docutils literal notranslate"><span class="pre">use</span></code> declarations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-fmodule-name=module-id</span></code></dt><dd><p>Consider a source file as a part of the given module.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-fmodule-map-file=&lt;file&gt;</span></code></dt><dd><p>Load the given module map file if a header from its directory or one of its subdirectories is loaded.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-fmodules-search-all</span></code></dt><dd><p>If a symbol is not found, search modules referenced in the current module maps but not imported for symbols, so the error message can reference the module by name.  Note that if the global module index has not been built before, this might take some time as it needs to build all the modules.  Note that this option doesn’t apply in module builds, to avoid the recursion.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-fno-implicit-modules</span></code></dt><dd><p>All modules used by the build must be specified with <code class="docutils literal notranslate"><span class="pre">-fmodule-file</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-fmodule-file=[&lt;name&gt;=]&lt;file&gt;</span></code></dt><dd><p>Specify the mapping of module names to precompiled module files. If the
name is omitted, then the module file is loaded whether actually required
or not. If the name is specified, then the mapping is treated as another
prebuilt module search mechanism (in addition to <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code>)
and the module is only loaded if required. Note that in this case the
specified file also overrides this module’s paths that might be embedded
in other precompiled module files.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path=&lt;directory&gt;</span></code></dt><dd><p>Specify the path to the prebuilt modules. If specified, we will look for modules in this directory for a given top-level module name. We don’t need a module map for loading prebuilt modules in this directory and the compiler will not try to rebuild these modules. This can be specified multiple times.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-fprebuilt-implicit-modules</span></code></dt><dd><p>Enable prebuilt implicit modules. If a prebuilt module is not found in the
prebuilt modules paths (specified via <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code>), we will
look for a matching implicit module in the prebuilt modules paths.</p>
</dd>
</dl>
<section id="cc1-options">
<h4><a class="toc-backref" href="#id20" role="doc-backlink">-cc1 Options</a><a class="headerlink" href="#cc1-options" title="Permalink to this heading">¶</a></h4>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">-fmodules-strict-context-hash</span></code></dt><dd><p>Enables hashing of all compiler options that could impact the semantics of a
module in an implicit build. This includes things such as header search paths
and diagnostics. Using this option may lead to an excessive number of modules
being built if the command line arguments are not homogeneous across your
build.</p>
</dd>
</dl>
</section>
</section>
<section id="using-prebuilt-modules">
<h3><a class="toc-backref" href="#id21" role="doc-backlink">Using Prebuilt Modules</a><a class="headerlink" href="#using-prebuilt-modules" title="Permalink to this heading">¶</a></h3>
<p>Below are a few examples illustrating uses of prebuilt modules via the different options.</p>
<p>First, let’s set up files for our examples.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* A.h */</span>
<span class="cp">#ifdef ENABLE_A</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">a</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* B.h */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;A.h&quot;</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* use.c */</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;B.h&quot;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">use</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#ifdef ENABLE_A</span>
<span class="w">  </span><span class="n">a</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* module.modulemap */</span>
<span class="n">module</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">header</span><span class="w"> </span><span class="s">&quot;A.h&quot;</span>
<span class="p">}</span>
<span class="n">module</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">header</span><span class="w"> </span><span class="s">&quot;B.h&quot;</span>
<span class="w">  </span><span class="n">export</span><span class="w"> </span><span class="o">*</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the examples below, the compilation of <code class="docutils literal notranslate"><span class="pre">use.c</span></code> can be done without <code class="docutils literal notranslate"><span class="pre">-cc1</span></code>, but the commands used to prebuild the modules would need to be updated to take into account the default options passed to <code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">-cc1</span></code>. (See <code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">use.c</span> <span class="pre">-v</span></code>)
Note also that, since we use <code class="docutils literal notranslate"><span class="pre">-cc1</span></code>, we specify the <code class="docutils literal notranslate"><span class="pre">-fmodule-map-file=</span></code> or <code class="docutils literal notranslate"><span class="pre">-fimplicit-module-maps</span></code> options explicitly. When using the clang driver, <code class="docutils literal notranslate"><span class="pre">-fimplicit-module-maps</span></code> is implied by <code class="docutils literal notranslate"><span class="pre">-fmodules</span></code>.</p>
<p>First let us use an explicit mapping from modules to files.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>rm<span class="w"> </span>-rf<span class="w"> </span>prebuilt<span class="w"> </span><span class="p">;</span><span class="w"> </span>mkdir<span class="w"> </span>prebuilt
clang<span class="w"> </span>-cc1<span class="w"> </span>-emit-module<span class="w"> </span>-o<span class="w"> </span>prebuilt/A.pcm<span class="w"> </span>-fmodules<span class="w"> </span>module.modulemap<span class="w"> </span>-fmodule-name<span class="o">=</span>A
clang<span class="w"> </span>-cc1<span class="w"> </span>-emit-module<span class="w"> </span>-o<span class="w"> </span>prebuilt/B.pcm<span class="w"> </span>-fmodules<span class="w"> </span>module.modulemap<span class="w"> </span>-fmodule-name<span class="o">=</span>B<span class="w"> </span>-fmodule-file<span class="o">=</span><span class="nv">A</span><span class="o">=</span>prebuilt/A.pcm
clang<span class="w"> </span>-cc1<span class="w"> </span>-emit-obj<span class="w"> </span>use.c<span class="w"> </span>-fmodules<span class="w"> </span>-fmodule-map-file<span class="o">=</span>module.modulemap<span class="w"> </span>-fmodule-file<span class="o">=</span><span class="nv">A</span><span class="o">=</span>prebuilt/A.pcm<span class="w"> </span>-fmodule-file<span class="o">=</span><span class="nv">B</span><span class="o">=</span>prebuilt/B.pcm
</pre></div>
</div>
<p>Instead of of specifying the mappings manually, it can be convenient to use the <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code> option. Let’s also use <code class="docutils literal notranslate"><span class="pre">-fimplicit-module-maps</span></code> instead of manually pointing to our module map.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>rm<span class="w"> </span>-rf<span class="w"> </span>prebuilt<span class="p">;</span><span class="w"> </span>mkdir<span class="w"> </span>prebuilt
clang<span class="w"> </span>-cc1<span class="w"> </span>-emit-module<span class="w"> </span>-o<span class="w"> </span>prebuilt/A.pcm<span class="w"> </span>-fmodules<span class="w"> </span>module.modulemap<span class="w"> </span>-fmodule-name<span class="o">=</span>A
clang<span class="w"> </span>-cc1<span class="w"> </span>-emit-module<span class="w"> </span>-o<span class="w"> </span>prebuilt/B.pcm<span class="w"> </span>-fmodules<span class="w"> </span>module.modulemap<span class="w"> </span>-fmodule-name<span class="o">=</span>B<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>prebuilt
clang<span class="w"> </span>-cc1<span class="w"> </span>-emit-obj<span class="w"> </span>use.c<span class="w"> </span>-fmodules<span class="w"> </span>-fimplicit-module-maps<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>prebuilt
</pre></div>
</div>
<p>A trick to prebuild all modules required for our source file in one command is to generate implicit modules while using the <code class="docutils literal notranslate"><span class="pre">-fdisable-module-hash</span></code> option.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>rm<span class="w"> </span>-rf<span class="w"> </span>prebuilt<span class="w"> </span><span class="p">;</span><span class="w"> </span>mkdir<span class="w"> </span>prebuilt
clang<span class="w"> </span>-cc1<span class="w"> </span>-emit-obj<span class="w"> </span>use.c<span class="w"> </span>-fmodules<span class="w"> </span>-fimplicit-module-maps<span class="w"> </span>-fmodules-cache-path<span class="o">=</span>prebuilt<span class="w"> </span>-fdisable-module-hash
ls<span class="w"> </span>prebuilt/*.pcm
<span class="c1"># prebuilt/A.pcm  prebuilt/B.pcm</span>
</pre></div>
</div>
<p>Note that with explicit or prebuilt modules, we are responsible for, and should be particularly careful about the compatibility of our modules.
Using mismatching compilation options and modules may lead to issues.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>clang<span class="w"> </span>-cc1<span class="w"> </span>-emit-obj<span class="w"> </span>use.c<span class="w"> </span>-fmodules<span class="w"> </span>-fimplicit-module-maps<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>prebuilt<span class="w"> </span>-DENABLE_A
<span class="c1"># use.c:4:10: warning: implicit declaration of function &#39;a&#39; is invalid in C99 [-Wimplicit-function-declaration]</span>
<span class="c1">#   return a(x);</span>
<span class="c1">#          ^</span>
<span class="c1"># 1 warning generated.</span>
</pre></div>
</div>
<p>So we need to maintain multiple versions of prebuilt modules. We can do so using a manual module mapping, or pointing to a different prebuilt module cache path. For example:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>rm<span class="w"> </span>-rf<span class="w"> </span>prebuilt<span class="w"> </span><span class="p">;</span><span class="w"> </span>mkdir<span class="w"> </span>prebuilt<span class="w"> </span><span class="p">;</span><span class="w"> </span>rm<span class="w"> </span>-rf<span class="w"> </span>prebuilt_a<span class="w"> </span><span class="p">;</span><span class="w"> </span>mkdir<span class="w"> </span>prebuilt_a
clang<span class="w"> </span>-cc1<span class="w"> </span>-emit-obj<span class="w"> </span>use.c<span class="w"> </span>-fmodules<span class="w"> </span>-fimplicit-module-maps<span class="w"> </span>-fmodules-cache-path<span class="o">=</span>prebuilt<span class="w"> </span>-fdisable-module-hash
clang<span class="w"> </span>-cc1<span class="w"> </span>-emit-obj<span class="w"> </span>use.c<span class="w"> </span>-fmodules<span class="w"> </span>-fimplicit-module-maps<span class="w"> </span>-fmodules-cache-path<span class="o">=</span>prebuilt_a<span class="w"> </span>-fdisable-module-hash<span class="w"> </span>-DENABLE_A
clang<span class="w"> </span>-cc1<span class="w"> </span>-emit-obj<span class="w"> </span>use.c<span class="w"> </span>-fmodules<span class="w"> </span>-fimplicit-module-maps<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>prebuilt
clang<span class="w"> </span>-cc1<span class="w"> </span>-emit-obj<span class="w"> </span>use.c<span class="w"> </span>-fmodules<span class="w"> </span>-fimplicit-module-maps<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>prebuilt_a<span class="w"> </span>-DENABLE_A
</pre></div>
</div>
<p>Instead of managing the different module versions manually, we can build implicit modules in a given cache path (using <code class="docutils literal notranslate"><span class="pre">-fmodules-cache-path</span></code>), and reuse them as prebuilt implicit modules by passing <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code> and <code class="docutils literal notranslate"><span class="pre">-fprebuilt-implicit-modules</span></code>.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>rm<span class="w"> </span>-rf<span class="w"> </span>prebuilt<span class="p">;</span><span class="w"> </span>mkdir<span class="w"> </span>prebuilt
clang<span class="w"> </span>-cc1<span class="w"> </span>-emit-obj<span class="w"> </span>-o<span class="w"> </span>use.o<span class="w"> </span>use.c<span class="w"> </span>-fmodules<span class="w"> </span>-fimplicit-module-maps<span class="w"> </span>-fmodules-cache-path<span class="o">=</span>prebuilt
clang<span class="w"> </span>-cc1<span class="w"> </span>-emit-obj<span class="w"> </span>-o<span class="w"> </span>use.o<span class="w"> </span>use.c<span class="w"> </span>-fmodules<span class="w"> </span>-fimplicit-module-maps<span class="w"> </span>-fmodules-cache-path<span class="o">=</span>prebuilt<span class="w"> </span>-DENABLE_A
find<span class="w"> </span>prebuilt<span class="w"> </span>-name<span class="w"> </span><span class="s2">&quot;*.pcm&quot;</span>
<span class="c1"># prebuilt/1AYBIGPM8R2GA/A-3L1K4LUA6O31.pcm</span>
<span class="c1"># prebuilt/1AYBIGPM8R2GA/B-3L1K4LUA6O31.pcm</span>
<span class="c1"># prebuilt/VH0YZMF1OIRK/A-3L1K4LUA6O31.pcm</span>
<span class="c1"># prebuilt/VH0YZMF1OIRK/B-3L1K4LUA6O31.pcm</span>
clang<span class="w"> </span>-cc1<span class="w"> </span>-emit-obj<span class="w"> </span>-o<span class="w"> </span>use.o<span class="w"> </span>use.c<span class="w"> </span>-fmodules<span class="w"> </span>-fimplicit-module-maps<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>prebuilt<span class="w"> </span>-fprebuilt-implicit-modules
clang<span class="w"> </span>-cc1<span class="w"> </span>-emit-obj<span class="w"> </span>-o<span class="w"> </span>use.o<span class="w"> </span>use.c<span class="w"> </span>-fmodules<span class="w"> </span>-fimplicit-module-maps<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>prebuilt<span class="w"> </span>-fprebuilt-implicit-modules<span class="w"> </span>-DENABLE_A
</pre></div>
</div>
<p>Finally we want to allow implicit modules for configurations that were not prebuilt. When using the clang driver a module cache path is implicitly selected. Using <code class="docutils literal notranslate"><span class="pre">-cc1</span></code>, we simply add use the <code class="docutils literal notranslate"><span class="pre">-fmodules-cache-path</span></code> option.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>clang<span class="w"> </span>-cc1<span class="w"> </span>-emit-obj<span class="w"> </span>-o<span class="w"> </span>use.o<span class="w"> </span>use.c<span class="w"> </span>-fmodules<span class="w"> </span>-fimplicit-module-maps<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>prebuilt<span class="w"> </span>-fprebuilt-implicit-modules<span class="w"> </span>-fmodules-cache-path<span class="o">=</span>cache
clang<span class="w"> </span>-cc1<span class="w"> </span>-emit-obj<span class="w"> </span>-o<span class="w"> </span>use.o<span class="w"> </span>use.c<span class="w"> </span>-fmodules<span class="w"> </span>-fimplicit-module-maps<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>prebuilt<span class="w"> </span>-fprebuilt-implicit-modules<span class="w"> </span>-fmodules-cache-path<span class="o">=</span>cache<span class="w"> </span>-DENABLE_A
clang<span class="w"> </span>-cc1<span class="w"> </span>-emit-obj<span class="w"> </span>-o<span class="w"> </span>use.o<span class="w"> </span>use.c<span class="w"> </span>-fmodules<span class="w"> </span>-fimplicit-module-maps<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>prebuilt<span class="w"> </span>-fprebuilt-implicit-modules<span class="w"> </span>-fmodules-cache-path<span class="o">=</span>cache<span class="w"> </span>-DENABLE_A<span class="w"> </span>-DOTHER_OPTIONS
</pre></div>
</div>
<p>This way, a single directory containing multiple variants of modules can be prepared and reused. The options configuring the module cache are independent of other options.</p>
</section>
</section>
<section id="module-semantics">
<h2><a class="toc-backref" href="#id22" role="doc-backlink">Module Semantics</a><a class="headerlink" href="#module-semantics" title="Permalink to this heading">¶</a></h2>
<p>Modules are modeled as if each submodule were a separate translation unit, and a module import makes names from the other translation unit visible. Each submodule starts with a new preprocessor state and an empty translation unit.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This behavior is currently only approximated when building a module with submodules. Entities within a submodule that has already been built are visible when building later submodules in that module. This can lead to fragile modules that depend on the build order used for the submodules of the module, and should not be relied upon. This behavior is subject to change.</p>
</div>
<p>As an example, in C, this implies that if two structs are defined in different submodules with the same name, those two types are distinct types (but may be <em>compatible</em> types if their definitions match). In C++, two structs defined with the same name in different submodules are the <em>same</em> type, and must be equivalent under C++’s One Definition Rule.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Clang currently only performs minimal checking for violations of the One Definition Rule.</p>
</div>
<p>If any submodule of a module is imported into any part of a program, the entire top-level module is considered to be part of the program. As a consequence of this, Clang may diagnose conflicts between an entity declared in an unimported submodule and an entity declared in the current translation unit, and Clang may inline or devirtualize based on knowledge from unimported submodules.</p>
<section id="macros">
<h3><a class="toc-backref" href="#id23" role="doc-backlink">Macros</a><a class="headerlink" href="#macros" title="Permalink to this heading">¶</a></h3>
<p>The C and C++ preprocessor assumes that the input text is a single linear buffer, but with modules this is not the case. It is possible to import two modules that have conflicting definitions for a macro (or where one <code class="docutils literal notranslate"><span class="pre">#define</span></code>s a macro and the other <code class="docutils literal notranslate"><span class="pre">#undef</span></code>ines it). The rules for handling macro definitions in the presence of modules are as follows:</p>
<ul class="simple">
<li><p>Each definition and undefinition of a macro is considered to be a distinct entity.</p></li>
<li><p>Such entities are <em>visible</em> if they are from the current submodule or translation unit, or if they were exported from a submodule that has been imported.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">#define</span> <span class="pre">X</span></code> or <code class="docutils literal notranslate"><span class="pre">#undef</span> <span class="pre">X</span></code> directive <em>overrides</em> all definitions of <code class="docutils literal notranslate"><span class="pre">X</span></code> that are visible at the point of the directive.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">#define</span></code> or <code class="docutils literal notranslate"><span class="pre">#undef</span></code> directive is <em>active</em> if it is visible and no visible directive overrides it.</p></li>
<li><p>A set of macro directives is <em>consistent</em> if it consists of only <code class="docutils literal notranslate"><span class="pre">#undef</span></code> directives, or if all <code class="docutils literal notranslate"><span class="pre">#define</span></code> directives in the set define the macro name to the same sequence of tokens (following the usual rules for macro redefinitions).</p></li>
<li><p>If a macro name is used and the set of active directives is not consistent, the program is ill-formed. Otherwise, the (unique) meaning of the macro name is used.</p></li>
</ul>
<p>For example, suppose:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;stdio.h&gt;</span></code> defines a macro <code class="docutils literal notranslate"><span class="pre">getc</span></code> (and exports its <code class="docutils literal notranslate"><span class="pre">#define</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;cstdio&gt;</span></code> imports the <code class="docutils literal notranslate"><span class="pre">&lt;stdio.h&gt;</span></code> module and undefines the macro (and exports its <code class="docutils literal notranslate"><span class="pre">#undef</span></code>)</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">#undef</span></code> overrides the <code class="docutils literal notranslate"><span class="pre">#define</span></code>, and a source file that imports both modules <em>in any order</em> will not see <code class="docutils literal notranslate"><span class="pre">getc</span></code> defined as a macro.</p>
</section>
</section>
<section id="module-map-language">
<h2><a class="toc-backref" href="#id24" role="doc-backlink">Module Map Language</a><a class="headerlink" href="#module-map-language" title="Permalink to this heading">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The module map language is not currently guaranteed to be stable between major revisions of Clang.</p>
</div>
<p>The module map language describes the mapping from header files to the
logical structure of modules. To enable support for using a library as
a module, one must write a <code class="docutils literal notranslate"><span class="pre">module.modulemap</span></code> file for that library. The
<code class="docutils literal notranslate"><span class="pre">module.modulemap</span></code> file is placed alongside the header files themselves,
and is written in the module map language described below.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For compatibility with previous releases, if a module map file named
<code class="docutils literal notranslate"><span class="pre">module.modulemap</span></code> is not found, Clang will also search for a file named
<code class="docutils literal notranslate"><span class="pre">module.map</span></code>. This behavior is deprecated and we plan to eventually
remove it.</p>
</div>
<p>As an example, the module map file for the C standard library might look a bit like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">std</span> <span class="p">[</span><span class="n">system</span><span class="p">]</span> <span class="p">[</span><span class="n">extern_c</span><span class="p">]</span> <span class="p">{</span>
  <span class="n">module</span> <span class="k">assert</span> <span class="p">{</span>
    <span class="n">textual</span> <span class="n">header</span> <span class="s2">&quot;assert.h&quot;</span>
    <span class="n">header</span> <span class="s2">&quot;bits/assert-decls.h&quot;</span>
    <span class="n">export</span> <span class="o">*</span>
  <span class="p">}</span>

  <span class="n">module</span> <span class="nb">complex</span> <span class="p">{</span>
    <span class="n">header</span> <span class="s2">&quot;complex.h&quot;</span>
    <span class="n">export</span> <span class="o">*</span>
  <span class="p">}</span>

  <span class="n">module</span> <span class="n">ctype</span> <span class="p">{</span>
    <span class="n">header</span> <span class="s2">&quot;ctype.h&quot;</span>
    <span class="n">export</span> <span class="o">*</span>
  <span class="p">}</span>

  <span class="n">module</span> <span class="n">errno</span> <span class="p">{</span>
    <span class="n">header</span> <span class="s2">&quot;errno.h&quot;</span>
    <span class="n">header</span> <span class="s2">&quot;sys/errno.h&quot;</span>
    <span class="n">export</span> <span class="o">*</span>
  <span class="p">}</span>

  <span class="n">module</span> <span class="n">fenv</span> <span class="p">{</span>
    <span class="n">header</span> <span class="s2">&quot;fenv.h&quot;</span>
    <span class="n">export</span> <span class="o">*</span>
  <span class="p">}</span>

  <span class="o">//</span> <span class="o">...</span><span class="n">more</span> <span class="n">headers</span> <span class="n">follow</span><span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, the top-level module <code class="docutils literal notranslate"><span class="pre">std</span></code> encompasses the whole C standard library. It has a number of submodules containing different parts of the standard library: <code class="docutils literal notranslate"><span class="pre">complex</span></code> for complex numbers, <code class="docutils literal notranslate"><span class="pre">ctype</span></code> for character types, etc. Each submodule lists one of more headers that provide the contents for that submodule. Finally, the <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">*</span></code> command specifies that anything included by that submodule will be automatically re-exported.</p>
<section id="lexical-structure">
<h3><a class="toc-backref" href="#id25" role="doc-backlink">Lexical structure</a><a class="headerlink" href="#lexical-structure" title="Permalink to this heading">¶</a></h3>
<p>Module map files use a simplified form of the C99 lexer, with the same rules for identifiers, tokens, string literals, <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">*/</span></code> and <code class="docutils literal notranslate"><span class="pre">//</span></code> comments. The module map language has the following reserved words; all other C identifiers are valid identifiers.</p>
<pre class="literal-block"><code class="docutils literal notranslate"><span class="pre">config_macros</span></code> <code class="docutils literal notranslate"><span class="pre">export_as</span></code>  <code class="docutils literal notranslate"><span class="pre">private</span></code>
<code class="docutils literal notranslate"><span class="pre">conflict</span></code>      <code class="docutils literal notranslate"><span class="pre">framework</span></code>  <code class="docutils literal notranslate"><span class="pre">requires</span></code>
<code class="docutils literal notranslate"><span class="pre">exclude</span></code>       <code class="docutils literal notranslate"><span class="pre">header</span></code>     <code class="docutils literal notranslate"><span class="pre">textual</span></code>
<code class="docutils literal notranslate"><span class="pre">explicit</span></code>      <code class="docutils literal notranslate"><span class="pre">link</span></code>       <code class="docutils literal notranslate"><span class="pre">umbrella</span></code>
<code class="docutils literal notranslate"><span class="pre">extern</span></code>        <code class="docutils literal notranslate"><span class="pre">module</span></code>     <code class="docutils literal notranslate"><span class="pre">use</span></code>
<code class="docutils literal notranslate"><span class="pre">export</span></code></pre>
</section>
<section id="module-map-file">
<h3><a class="toc-backref" href="#id26" role="doc-backlink">Module map file</a><a class="headerlink" href="#module-map-file" title="Permalink to this heading">¶</a></h3>
<p>A module map file consists of a series of module declarations:</p>
<pre class="literal-block"><em>module-map-file</em>:
  <em>module-declaration*</em></pre>
<p>Within a module map file, modules are referred to by a <em>module-id</em>, which uses periods to separate each part of a module’s name:</p>
<pre class="literal-block"><em>module-id</em>:
  <em>identifier</em> ('.' <em>identifier</em>)*</pre>
</section>
<section id="module-declaration">
<h3><a class="toc-backref" href="#id27" role="doc-backlink">Module declaration</a><a class="headerlink" href="#module-declaration" title="Permalink to this heading">¶</a></h3>
<p>A module declaration describes a module, including the headers that contribute to that module, its submodules, and other aspects of the module.</p>
<pre class="literal-block"><em>module-declaration</em>:
  <code class="docutils literal notranslate"><span class="pre">explicit</span></code><sub>opt</sub> <code class="docutils literal notranslate"><span class="pre">framework</span></code><sub>opt</sub> <code class="docutils literal notranslate"><span class="pre">module</span></code> <em>module-id</em> <em>attributes</em><sub>opt</sub> '{' <em>module-member*</em> '}'
  <code class="docutils literal notranslate"><span class="pre">extern</span></code> <code class="docutils literal notranslate"><span class="pre">module</span></code> <em>module-id</em> <em>string-literal</em></pre>
<p>The <em>module-id</em> should consist of only a single <em>identifier</em>, which provides the name of the module being defined. Each module shall have a single definition.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">explicit</span></code> qualifier can only be applied to a submodule, i.e., a module that is nested within another module. The contents of explicit submodules are only made available when the submodule itself was explicitly named in an import declaration or was re-exported from an imported module.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">framework</span></code> qualifier specifies that this module corresponds to a Darwin-style framework. A Darwin-style framework (used primarily on macOS and iOS) is contained entirely in directory <code class="docutils literal notranslate"><span class="pre">Name.framework</span></code>, where <code class="docutils literal notranslate"><span class="pre">Name</span></code> is the name of the framework (and, therefore, the name of the module). That directory has the following layout:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Name</span><span class="o">.</span><span class="n">framework</span><span class="o">/</span>
  <span class="n">Modules</span><span class="o">/</span><span class="n">module</span><span class="o">.</span><span class="n">modulemap</span>  <span class="n">Module</span> <span class="nb">map</span> <span class="k">for</span> <span class="n">the</span> <span class="n">framework</span>
  <span class="n">Headers</span><span class="o">/</span>                  <span class="n">Subdirectory</span> <span class="n">containing</span> <span class="n">framework</span> <span class="n">headers</span>
  <span class="n">PrivateHeaders</span><span class="o">/</span>           <span class="n">Subdirectory</span> <span class="n">containing</span> <span class="n">framework</span> <span class="n">private</span> <span class="n">headers</span>
  <span class="n">Frameworks</span><span class="o">/</span>               <span class="n">Subdirectory</span> <span class="n">containing</span> <span class="n">embedded</span> <span class="n">frameworks</span>
  <span class="n">Resources</span><span class="o">/</span>                <span class="n">Subdirectory</span> <span class="n">containing</span> <span class="n">additional</span> <span class="n">resources</span>
  <span class="n">Name</span>                      <span class="n">Symbolic</span> <span class="n">link</span> <span class="n">to</span> <span class="n">the</span> <span class="n">shared</span> <span class="n">library</span> <span class="k">for</span> <span class="n">the</span> <span class="n">framework</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">system</span></code> attribute specifies that the module is a system module. When a system module is rebuilt, all of the module’s headers will be considered system headers, which suppresses warnings. This is equivalent to placing <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">GCC</span> <span class="pre">system_header</span></code> in each of the module’s headers. The form of attributes is described in the section <a class="reference internal" href="#attributes">Attributes</a>, below.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">extern_c</span></code> attribute specifies that the module contains C code that can be used from within C++. When such a module is built for use in C++ code, all of the module’s headers will be treated as if they were contained within an implicit <code class="docutils literal notranslate"><span class="pre">extern</span> <span class="pre">&quot;C&quot;</span></code> block. An import for a module with this attribute can appear within an <code class="docutils literal notranslate"><span class="pre">extern</span> <span class="pre">&quot;C&quot;</span></code> block. No other restrictions are lifted, however: the module currently cannot be imported within an <code class="docutils literal notranslate"><span class="pre">extern</span> <span class="pre">&quot;C&quot;</span></code> block in a namespace.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">no_undeclared_includes</span></code> attribute specifies that the module can only reach non-modular headers and headers from used modules. Since some headers could be present in more than one search path and map to different modules in each path, this mechanism helps clang to find the right header, i.e., prefer the one for the current module or in a submodule instead of the first usual match in the search paths.</p>
<p>Modules can have a number of different kinds of members, each of which is described below:</p>
<pre class="literal-block"><em>module-member</em>:
  <em>requires-declaration</em>
  <em>header-declaration</em>
  <em>umbrella-dir-declaration</em>
  <em>submodule-declaration</em>
  <em>export-declaration</em>
  <em>export-as-declaration</em>
  <em>use-declaration</em>
  <em>link-declaration</em>
  <em>config-macros-declaration</em>
  <em>conflict-declaration</em></pre>
<p>An extern module references a module defined by the <em>module-id</em> in a file given by the <em>string-literal</em>. The file can be referenced either by an absolute path or by a path relative to the current map file.</p>
<section id="requires-declaration">
<h4><a class="toc-backref" href="#id28" role="doc-backlink">Requires declaration</a><a class="headerlink" href="#requires-declaration" title="Permalink to this heading">¶</a></h4>
<p>A <em>requires-declaration</em> specifies the requirements that an importing translation unit must satisfy to use the module.</p>
<pre class="literal-block"><em>requires-declaration</em>:
  <code class="docutils literal notranslate"><span class="pre">requires</span></code> <em>feature-list</em>

<em>feature-list</em>:
  <em>feature</em> (',' <em>feature</em>)*

<em>feature</em>:
  <code class="docutils literal notranslate"><span class="pre">!</span></code><sub>opt</sub> <em>identifier</em></pre>
<p>The requirements clause allows specific modules or submodules to specify that they are only accessible with certain language dialects, platforms, environments and target specific features. The feature list is a set of identifiers, defined below. If any of the features is not available in a given translation unit, that translation unit shall not import the module. When building a module for use by a compilation, submodules requiring unavailable features are ignored. The optional <code class="docutils literal notranslate"><span class="pre">!</span></code> indicates that a feature is incompatible with the module.</p>
<p>The following features are defined:</p>
<dl class="simple">
<dt>altivec</dt><dd><p>The target supports AltiVec.</p>
</dd>
<dt>blocks</dt><dd><p>The “blocks” language feature is available.</p>
</dd>
<dt>coroutines</dt><dd><p>Support for the coroutines TS is available.</p>
</dd>
<dt>cplusplus</dt><dd><p>C++ support is available.</p>
</dd>
<dt>cplusplus11</dt><dd><p>C++11 support is available.</p>
</dd>
<dt>cplusplus14</dt><dd><p>C++14 support is available.</p>
</dd>
<dt>cplusplus17</dt><dd><p>C++17 support is available.</p>
</dd>
<dt>cplusplus20</dt><dd><p>C++20 support is available.</p>
</dd>
<dt>cplusplus23</dt><dd><p>C++23 support is available.</p>
</dd>
<dt>c99</dt><dd><p>C99 support is available.</p>
</dd>
<dt>c11</dt><dd><p>C11 support is available.</p>
</dd>
<dt>c17</dt><dd><p>C17 support is available.</p>
</dd>
<dt>c23</dt><dd><p>C23 support is available.</p>
</dd>
<dt>freestanding</dt><dd><p>A freestanding environment is available.</p>
</dd>
<dt>gnuinlineasm</dt><dd><p>GNU inline ASM is available.</p>
</dd>
<dt>objc</dt><dd><p>Objective-C support is available.</p>
</dd>
<dt>objc_arc</dt><dd><p>Objective-C Automatic Reference Counting (ARC) is available</p>
</dd>
<dt>opencl</dt><dd><p>OpenCL is available</p>
</dd>
<dt>tls</dt><dd><p>Thread local storage is available.</p>
</dd>
<dt><em>target feature</em></dt><dd><p>A specific target feature (e.g., <code class="docutils literal notranslate"><span class="pre">sse4</span></code>, <code class="docutils literal notranslate"><span class="pre">avx</span></code>, <code class="docutils literal notranslate"><span class="pre">neon</span></code>) is available.</p>
</dd>
<dt><em>platform/os</em></dt><dd><p>A os/platform variant (e.g. <code class="docutils literal notranslate"><span class="pre">freebsd</span></code>, <code class="docutils literal notranslate"><span class="pre">win32</span></code>, <code class="docutils literal notranslate"><span class="pre">windows</span></code>, <code class="docutils literal notranslate"><span class="pre">linux</span></code>, <code class="docutils literal notranslate"><span class="pre">ios</span></code>, <code class="docutils literal notranslate"><span class="pre">macos</span></code>, <code class="docutils literal notranslate"><span class="pre">iossimulator</span></code>) is available.</p>
</dd>
<dt><em>environment</em></dt><dd><p>A environment variant (e.g. <code class="docutils literal notranslate"><span class="pre">gnu</span></code>, <code class="docutils literal notranslate"><span class="pre">gnueabi</span></code>, <code class="docutils literal notranslate"><span class="pre">android</span></code>, <code class="docutils literal notranslate"><span class="pre">msvc</span></code>) is available.</p>
</dd>
</dl>
<p><strong>Example:</strong> The <code class="docutils literal notranslate"><span class="pre">std</span></code> module can be extended to also include C++ and C++11 headers using a <em>requires-declaration</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">std</span> <span class="p">{</span>
   <span class="o">//</span> <span class="n">C</span> <span class="n">standard</span> <span class="n">library</span><span class="o">...</span>

   <span class="n">module</span> <span class="n">vector</span> <span class="p">{</span>
     <span class="n">requires</span> <span class="n">cplusplus</span>
     <span class="n">header</span> <span class="s2">&quot;vector&quot;</span>
   <span class="p">}</span>

   <span class="n">module</span> <span class="n">type_traits</span> <span class="p">{</span>
     <span class="n">requires</span> <span class="n">cplusplus11</span>
     <span class="n">header</span> <span class="s2">&quot;type_traits&quot;</span>
   <span class="p">}</span>
 <span class="p">}</span>
</pre></div>
</div>
</section>
<section id="header-declaration">
<h4><a class="toc-backref" href="#id29" role="doc-backlink">Header declaration</a><a class="headerlink" href="#header-declaration" title="Permalink to this heading">¶</a></h4>
<p>A header declaration specifies that a particular header is associated with the enclosing module.</p>
<pre class="literal-block"><em>header-declaration</em>:
  <code class="docutils literal notranslate"><span class="pre">private</span></code><sub>opt</sub> <code class="docutils literal notranslate"><span class="pre">textual</span></code><sub>opt</sub> <code class="docutils literal notranslate"><span class="pre">header</span></code> <em>string-literal</em> <em>header-attrs</em><sub>opt</sub>
  <code class="docutils literal notranslate"><span class="pre">umbrella</span></code> <code class="docutils literal notranslate"><span class="pre">header</span></code> <em>string-literal</em> <em>header-attrs</em><sub>opt</sub>
  <code class="docutils literal notranslate"><span class="pre">exclude</span></code> <code class="docutils literal notranslate"><span class="pre">header</span></code> <em>string-literal</em> <em>header-attrs</em><sub>opt</sub>

<em>header-attrs</em>:
  '{' <em>header-attr*</em> '}'

<em>header-attr</em>:
  <code class="docutils literal notranslate"><span class="pre">size</span></code> <em>integer-literal</em>
  <code class="docutils literal notranslate"><span class="pre">mtime</span></code> <em>integer-literal</em></pre>
<p>A header declaration that does not contain <code class="docutils literal notranslate"><span class="pre">exclude</span></code> nor <code class="docutils literal notranslate"><span class="pre">textual</span></code> specifies a header that contributes to the enclosing module. Specifically, when the module is built, the named header will be parsed and its declarations will be (logically) placed into the enclosing submodule.</p>
<p>A header with the <code class="docutils literal notranslate"><span class="pre">umbrella</span></code> specifier is called an umbrella header. An umbrella header includes all of the headers within its directory (and any subdirectories), and is typically used (in the <code class="docutils literal notranslate"><span class="pre">#include</span></code> world) to easily access the full API provided by a particular library. With modules, an umbrella header is a convenient shortcut that eliminates the need to write out <code class="docutils literal notranslate"><span class="pre">header</span></code> declarations for every library header. A given directory can only contain a single umbrella header.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Any headers not included by the umbrella header should have
explicit <code class="docutils literal notranslate"><span class="pre">header</span></code> declarations. Use the
<code class="docutils literal notranslate"><span class="pre">-Wincomplete-umbrella</span></code> warning option to ask Clang to complain
about headers not covered by the umbrella header or the module map.</p>
</div>
<p>A header with the <code class="docutils literal notranslate"><span class="pre">private</span></code> specifier may not be included from outside the module itself.</p>
<p>A header with the <code class="docutils literal notranslate"><span class="pre">textual</span></code> specifier will not be compiled when the module is
built, and will be textually included if it is named by a <code class="docutils literal notranslate"><span class="pre">#include</span></code>
directive. However, it is considered to be part of the module for the purpose
of checking <em>use-declaration</em>s, and must still be a lexically-valid header
file. In the future, we intend to pre-tokenize such headers and include the
token sequence within the prebuilt module representation.</p>
<p>A header with the <code class="docutils literal notranslate"><span class="pre">exclude</span></code> specifier is excluded from the module. It will not be included when the module is built, nor will it be considered to be part of the module, even if an <code class="docutils literal notranslate"><span class="pre">umbrella</span></code> header or directory would otherwise make it part of the module.</p>
<p><strong>Example:</strong> The C header <code class="docutils literal notranslate"><span class="pre">assert.h</span></code> is an excellent candidate for a textual header, because it is meant to be included multiple times (possibly with different <code class="docutils literal notranslate"><span class="pre">NDEBUG</span></code> settings). However, declarations within it should typically be split into a separate modular header.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">std</span> <span class="p">[</span><span class="n">system</span><span class="p">]</span> <span class="p">{</span>
  <span class="n">textual</span> <span class="n">header</span> <span class="s2">&quot;assert.h&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A given header shall not be referenced by more than one <em>header-declaration</em>.</p>
<p>Two <em>header-declaration</em>s, or a <em>header-declaration</em> and a <code class="docutils literal notranslate"><span class="pre">#include</span></code>, are
considered to refer to the same file if the paths resolve to the same file
and the specified <em>header-attr</em>s (if any) match the attributes of that file,
even if the file is named differently (for instance, by a relative path or
via symlinks).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The use of <em>header-attr</em>s avoids the need for Clang to speculatively
<code class="docutils literal notranslate"><span class="pre">stat</span></code> every header referenced by a module map. It is recommended that
<em>header-attr</em>s only be used in machine-generated module maps, to avoid
mismatches between attribute values and the corresponding files.</p>
</div>
</section>
<section id="umbrella-directory-declaration">
<h4><a class="toc-backref" href="#id30" role="doc-backlink">Umbrella directory declaration</a><a class="headerlink" href="#umbrella-directory-declaration" title="Permalink to this heading">¶</a></h4>
<p>An umbrella directory declaration specifies that all of the headers in the specified directory should be included within the module.</p>
<pre class="literal-block"><em>umbrella-dir-declaration</em>:
  <code class="docutils literal notranslate"><span class="pre">umbrella</span></code> <em>string-literal</em></pre>
<p>The <em>string-literal</em> refers to a directory. When the module is built, all of the header files in that directory (and its subdirectories) are included in the module.</p>
<p>An <em>umbrella-dir-declaration</em> shall not refer to the same directory as the location of an umbrella <em>header-declaration</em>. In other words, only a single kind of umbrella can be specified for a given directory.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Umbrella directories are useful for libraries that have a large number of headers but do not have an umbrella header.</p>
</div>
</section>
<section id="submodule-declaration">
<h4><a class="toc-backref" href="#id31" role="doc-backlink">Submodule declaration</a><a class="headerlink" href="#submodule-declaration" title="Permalink to this heading">¶</a></h4>
<p>Submodule declarations describe modules that are nested within their enclosing module.</p>
<pre class="literal-block"><em>submodule-declaration</em>:
  <em>module-declaration</em>
  <em>inferred-submodule-declaration</em></pre>
<p>A <em>submodule-declaration</em> that is a <em>module-declaration</em> is a nested module. If the <em>module-declaration</em> has a <code class="docutils literal notranslate"><span class="pre">framework</span></code> specifier, the enclosing module shall have a <code class="docutils literal notranslate"><span class="pre">framework</span></code> specifier; the submodule’s contents shall be contained within the subdirectory <code class="docutils literal notranslate"><span class="pre">Frameworks/SubName.framework</span></code>, where <code class="docutils literal notranslate"><span class="pre">SubName</span></code> is the name of the submodule.</p>
<p>A <em>submodule-declaration</em> that is an <em>inferred-submodule-declaration</em> describes a set of submodules that correspond to any headers that are part of the module but are not explicitly described by a <em>header-declaration</em>.</p>
<pre class="literal-block"><em>inferred-submodule-declaration</em>:
  <code class="docutils literal notranslate"><span class="pre">explicit</span></code><sub>opt</sub> <code class="docutils literal notranslate"><span class="pre">framework</span></code><sub>opt</sub> <code class="docutils literal notranslate"><span class="pre">module</span></code> '*' <em>attributes</em><sub>opt</sub> '{' <em>inferred-submodule-member*</em> '}'

<em>inferred-submodule-member</em>:
  <code class="docutils literal notranslate"><span class="pre">export</span></code> '*'</pre>
<p>A module containing an <em>inferred-submodule-declaration</em> shall have either an umbrella header or an umbrella directory. The headers to which the <em>inferred-submodule-declaration</em> applies are exactly those headers included by the umbrella header (transitively) or included in the module because they reside within the umbrella directory (or its subdirectories).</p>
<p>For each header included by the umbrella header or in the umbrella directory that is not named by a <em>header-declaration</em>, a module declaration is implicitly generated from the <em>inferred-submodule-declaration</em>. The module will:</p>
<ul class="simple">
<li><p>Have the same name as the header (without the file extension)</p></li>
<li><p>Have the <code class="docutils literal notranslate"><span class="pre">explicit</span></code> specifier, if the <em>inferred-submodule-declaration</em> has the <code class="docutils literal notranslate"><span class="pre">explicit</span></code> specifier</p></li>
<li><p>Have the <code class="docutils literal notranslate"><span class="pre">framework</span></code> specifier, if the
<em>inferred-submodule-declaration</em> has the <code class="docutils literal notranslate"><span class="pre">framework</span></code> specifier</p></li>
<li><p>Have the attributes specified by the <em>inferred-submodule-declaration</em></p></li>
<li><p>Contain a single <em>header-declaration</em> naming that header</p></li>
<li><p>Contain a single <em>export-declaration</em> <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">*</span></code>, if the <em>inferred-submodule-declaration</em> contains the <em>inferred-submodule-member</em> <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">*</span></code></p></li>
</ul>
<p><strong>Example:</strong> If the subdirectory “MyLib” contains the headers <code class="docutils literal notranslate"><span class="pre">A.h</span></code> and <code class="docutils literal notranslate"><span class="pre">B.h</span></code>, then the following module map:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">MyLib</span> <span class="p">{</span>
  <span class="n">umbrella</span> <span class="s2">&quot;MyLib&quot;</span>
  <span class="n">explicit</span> <span class="n">module</span> <span class="o">*</span> <span class="p">{</span>
    <span class="n">export</span> <span class="o">*</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>is equivalent to the (more verbose) module map:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">MyLib</span> <span class="p">{</span>
  <span class="n">explicit</span> <span class="n">module</span> <span class="n">A</span> <span class="p">{</span>
    <span class="n">header</span> <span class="s2">&quot;A.h&quot;</span>
    <span class="n">export</span> <span class="o">*</span>
  <span class="p">}</span>

  <span class="n">explicit</span> <span class="n">module</span> <span class="n">B</span> <span class="p">{</span>
    <span class="n">header</span> <span class="s2">&quot;B.h&quot;</span>
    <span class="n">export</span> <span class="o">*</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="export-declaration">
<h4><a class="toc-backref" href="#id32" role="doc-backlink">Export declaration</a><a class="headerlink" href="#export-declaration" title="Permalink to this heading">¶</a></h4>
<p>An <em>export-declaration</em> specifies which imported modules will automatically be re-exported as part of a given module’s API.</p>
<pre class="literal-block"><em>export-declaration</em>:
  <code class="docutils literal notranslate"><span class="pre">export</span></code> <em>wildcard-module-id</em>

<em>wildcard-module-id</em>:
  <em>identifier</em>
  '*'
  <em>identifier</em> '.' <em>wildcard-module-id</em></pre>
<p>The <em>export-declaration</em> names a module or a set of modules that will be re-exported to any translation unit that imports the enclosing module. Each imported module that matches the <em>wildcard-module-id</em> up to, but not including, the first <code class="docutils literal notranslate"><span class="pre">*</span></code> will be re-exported.</p>
<p><strong>Example:</strong> In the following example, importing <code class="docutils literal notranslate"><span class="pre">MyLib.Derived</span></code> also provides the API for <code class="docutils literal notranslate"><span class="pre">MyLib.Base</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">MyLib</span> <span class="p">{</span>
  <span class="n">module</span> <span class="n">Base</span> <span class="p">{</span>
    <span class="n">header</span> <span class="s2">&quot;Base.h&quot;</span>
  <span class="p">}</span>

  <span class="n">module</span> <span class="n">Derived</span> <span class="p">{</span>
    <span class="n">header</span> <span class="s2">&quot;Derived.h&quot;</span>
    <span class="n">export</span> <span class="n">Base</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that, if <code class="docutils literal notranslate"><span class="pre">Derived.h</span></code> includes <code class="docutils literal notranslate"><span class="pre">Base.h</span></code>, one can simply use a wildcard export to re-export everything <code class="docutils literal notranslate"><span class="pre">Derived.h</span></code> includes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">MyLib</span> <span class="p">{</span>
  <span class="n">module</span> <span class="n">Base</span> <span class="p">{</span>
    <span class="n">header</span> <span class="s2">&quot;Base.h&quot;</span>
  <span class="p">}</span>

  <span class="n">module</span> <span class="n">Derived</span> <span class="p">{</span>
    <span class="n">header</span> <span class="s2">&quot;Derived.h&quot;</span>
    <span class="n">export</span> <span class="o">*</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The wildcard export syntax <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">*</span></code> re-exports all of the
modules that were imported in the actual header file. Because
<code class="docutils literal notranslate"><span class="pre">#include</span></code> directives are automatically mapped to module imports,
<code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">*</span></code> provides the same transitive-inclusion behavior
provided by the C preprocessor, e.g., importing a given module
implicitly imports all of the modules on which it depends.
Therefore, liberal use of <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">*</span></code> provides excellent backward
compatibility for programs that rely on transitive inclusion (i.e.,
all of them).</p>
</div>
</section>
<section id="re-export-declaration">
<h4><a class="toc-backref" href="#id33" role="doc-backlink">Re-export Declaration</a><a class="headerlink" href="#re-export-declaration" title="Permalink to this heading">¶</a></h4>
<p>An <em>export-as-declaration</em> specifies that the current module will have
its interface re-exported by the named module.</p>
<pre class="literal-block"><em>export-as-declaration</em>:
  <code class="docutils literal notranslate"><span class="pre">export_as</span></code> <em>identifier</em></pre>
<p>The <em>export-as-declaration</em> names the module that the current
module will be re-exported through. Only top-level modules
can be re-exported, and any given module may only be re-exported
through a single module.</p>
<p><strong>Example:</strong> In the following example, the module <code class="docutils literal notranslate"><span class="pre">MyFrameworkCore</span></code>
will be re-exported via the module <code class="docutils literal notranslate"><span class="pre">MyFramework</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">MyFrameworkCore</span> <span class="p">{</span>
  <span class="n">export_as</span> <span class="n">MyFramework</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="use-declaration">
<h4><a class="toc-backref" href="#id34" role="doc-backlink">Use declaration</a><a class="headerlink" href="#use-declaration" title="Permalink to this heading">¶</a></h4>
<p>A <em>use-declaration</em> specifies another module that the current top-level module
intends to use. When the option <em>-fmodules-decluse</em> is specified, a module can
only use other modules that are explicitly specified in this way.</p>
<pre class="literal-block"><em>use-declaration</em>:
  <code class="docutils literal notranslate"><span class="pre">use</span></code> <em>module-id</em></pre>
<p><strong>Example:</strong> In the following example, use of A from C is not declared, so will trigger a warning.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">A</span> <span class="p">{</span>
  <span class="n">header</span> <span class="s2">&quot;a.h&quot;</span>
<span class="p">}</span>

<span class="n">module</span> <span class="n">B</span> <span class="p">{</span>
  <span class="n">header</span> <span class="s2">&quot;b.h&quot;</span>
<span class="p">}</span>

<span class="n">module</span> <span class="n">C</span> <span class="p">{</span>
  <span class="n">header</span> <span class="s2">&quot;c.h&quot;</span>
  <span class="n">use</span> <span class="n">B</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When compiling a source file that implements a module, use the option
<code class="docutils literal notranslate"><span class="pre">-fmodule-name=module-id</span></code> to indicate that the source file is logically part
of that module.</p>
<p>The compiler at present only applies restrictions to the module directly being built.</p>
</section>
<section id="link-declaration">
<h4><a class="toc-backref" href="#id35" role="doc-backlink">Link declaration</a><a class="headerlink" href="#link-declaration" title="Permalink to this heading">¶</a></h4>
<p>A <em>link-declaration</em> specifies a library or framework against which a program should be linked if the enclosing module is imported in any translation unit in that program.</p>
<pre class="literal-block"><em>link-declaration</em>:
  <code class="docutils literal notranslate"><span class="pre">link</span></code> <code class="docutils literal notranslate"><span class="pre">framework</span></code><sub>opt</sub> <em>string-literal</em></pre>
<p>The <em>string-literal</em> specifies the name of the library or framework against which the program should be linked. For example, specifying “clangBasic” would instruct the linker to link with <code class="docutils literal notranslate"><span class="pre">-lclangBasic</span></code> for a Unix-style linker.</p>
<p>A <em>link-declaration</em> with the <code class="docutils literal notranslate"><span class="pre">framework</span></code> specifies that the linker should link against the named framework, e.g., with <code class="docutils literal notranslate"><span class="pre">-framework</span> <span class="pre">MyFramework</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Automatic linking with the <code class="docutils literal notranslate"><span class="pre">link</span></code> directive is not yet widely
implemented, because it requires support from both the object file
format and the linker. The notion is similar to Microsoft Visual
Studio’s <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">comment(lib...)</span></code>.</p>
</div>
</section>
<section id="configuration-macros-declaration">
<h4><a class="toc-backref" href="#id36" role="doc-backlink">Configuration macros declaration</a><a class="headerlink" href="#configuration-macros-declaration" title="Permalink to this heading">¶</a></h4>
<p>The <em>config-macros-declaration</em> specifies the set of configuration macros that have an effect on the API of the enclosing module.</p>
<pre class="literal-block"><em>config-macros-declaration</em>:
  <code class="docutils literal notranslate"><span class="pre">config_macros</span></code> <em>attributes</em><sub>opt</sub> <em>config-macro-list</em><sub>opt</sub>

<em>config-macro-list</em>:
  <em>identifier</em> (',' <em>identifier</em>)*</pre>
<p>Each <em>identifier</em> in the <em>config-macro-list</em> specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros.</p>
<p>A <em>config-macros-declaration</em> shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">exhaustive</span></code> attribute specifies that the list of macros in the <em>config-macros-declaration</em> is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">exhaustive</span></code> attribute implies that any macro definitions
for macros not listed as configuration macros should be ignored
completely when building the module. As an optimization, the
compiler could reduce the number of unique module variants by not
considering these non-configuration macros. This optimization is not
yet implemented in Clang.</p>
</div>
<p>A translation unit shall not import the same module under different definitions of the configuration macros.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Clang implements a weak form of this requirement: the definitions
used for configuration macros are fixed based on the definitions
provided by the command line. If an import occurs and the definition
of any configuration macro has changed, the compiler will produce a
warning (under the control of <code class="docutils literal notranslate"><span class="pre">-Wconfig-macros</span></code>).</p>
</div>
<p><strong>Example:</strong> A logging library might provide different API (e.g., in the form of different definitions for a logging macro) based on the <code class="docutils literal notranslate"><span class="pre">NDEBUG</span></code> macro setting:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">MyLogger</span> <span class="p">{</span>
  <span class="n">umbrella</span> <span class="n">header</span> <span class="s2">&quot;MyLogger.h&quot;</span>
  <span class="n">config_macros</span> <span class="p">[</span><span class="n">exhaustive</span><span class="p">]</span> <span class="n">NDEBUG</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="conflict-declarations">
<h4><a class="toc-backref" href="#id37" role="doc-backlink">Conflict declarations</a><a class="headerlink" href="#conflict-declarations" title="Permalink to this heading">¶</a></h4>
<p>A <em>conflict-declaration</em> describes a case where the presence of two different modules in the same translation unit is likely to cause a problem. For example, two modules may provide similar-but-incompatible functionality.</p>
<pre class="literal-block"><em>conflict-declaration</em>:
  <code class="docutils literal notranslate"><span class="pre">conflict</span></code> <em>module-id</em> ',' <em>string-literal</em></pre>
<p>The <em>module-id</em> of the <em>conflict-declaration</em> specifies the module with which the enclosing module conflicts. The specified module shall not have been imported in the translation unit when the enclosing module is imported.</p>
<p>The <em>string-literal</em> provides a message to be provided as part of the compiler diagnostic when two modules conflict.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Clang emits a warning (under the control of <code class="docutils literal notranslate"><span class="pre">-Wmodule-conflict</span></code>)
when a module conflict is discovered.</p>
</div>
<p><strong>Example:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">Conflicts</span> <span class="p">{</span>
  <span class="n">explicit</span> <span class="n">module</span> <span class="n">A</span> <span class="p">{</span>
    <span class="n">header</span> <span class="s2">&quot;conflict_a.h&quot;</span>
    <span class="n">conflict</span> <span class="n">B</span><span class="p">,</span> <span class="s2">&quot;we just don&#39;t like B&quot;</span>
  <span class="p">}</span>

  <span class="n">module</span> <span class="n">B</span> <span class="p">{</span>
    <span class="n">header</span> <span class="s2">&quot;conflict_b.h&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="attributes">
<h3><a class="toc-backref" href="#id38" role="doc-backlink">Attributes</a><a class="headerlink" href="#attributes" title="Permalink to this heading">¶</a></h3>
<p>Attributes are used in a number of places in the grammar to describe specific behavior of other declarations. The format of attributes is fairly simple.</p>
<pre class="literal-block"><em>attributes</em>:
  <em>attribute</em> <em>attributes</em><sub>opt</sub>

<em>attribute</em>:
  '[' <em>identifier</em> ']'</pre>
<p>Any <em>identifier</em> can be used as an attribute, and each declaration specifies what attributes can be applied to it.</p>
</section>
<section id="private-module-map-files">
<h3><a class="toc-backref" href="#id39" role="doc-backlink">Private Module Map Files</a><a class="headerlink" href="#private-module-map-files" title="Permalink to this heading">¶</a></h3>
<p>Module map files are typically named <code class="docutils literal notranslate"><span class="pre">module.modulemap</span></code> and live
either alongside the headers they describe or in a parent directory of
the headers they describe. These module maps typically describe all of
the API for the library.</p>
<p>However, in some cases, the presence or absence of particular headers
is used to distinguish between the “public” and “private” APIs of a
particular library. For example, a library may contain the headers
<code class="docutils literal notranslate"><span class="pre">Foo.h</span></code> and <code class="docutils literal notranslate"><span class="pre">Foo_Private.h</span></code>, providing public and private APIs,
respectively. Additionally, <code class="docutils literal notranslate"><span class="pre">Foo_Private.h</span></code> may only be available on
some versions of library, and absent in others. One cannot easily
express this with a single module map file in the library:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="n">header</span> <span class="s2">&quot;Foo.h&quot;</span>
  <span class="o">...</span>
<span class="p">}</span>

<span class="n">module</span> <span class="n">Foo_Private</span> <span class="p">{</span>
  <span class="n">header</span> <span class="s2">&quot;Foo_Private.h&quot;</span>
  <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>because the header <code class="docutils literal notranslate"><span class="pre">Foo_Private.h</span></code> won’t always be available. The
module map file could be customized based on whether
<code class="docutils literal notranslate"><span class="pre">Foo_Private.h</span></code> is available or not, but doing so requires custom
build machinery.</p>
<p>Private module map files, which are named <code class="docutils literal notranslate"><span class="pre">module.private.modulemap</span></code>
(or, for backward compatibility, <code class="docutils literal notranslate"><span class="pre">module_private.map</span></code>), allow one to
augment the primary module map file with an additional modules. For
example, we would split the module map file above into two module map
files:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* module.modulemap */</span>
<span class="n">module</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">header</span><span class="w"> </span><span class="s">&quot;Foo.h&quot;</span>
<span class="p">}</span>

<span class="cm">/* module.private.modulemap */</span>
<span class="n">module</span><span class="w"> </span><span class="n">Foo_Private</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">header</span><span class="w"> </span><span class="s">&quot;Foo_Private.h&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When a <code class="docutils literal notranslate"><span class="pre">module.private.modulemap</span></code> file is found alongside a
<code class="docutils literal notranslate"><span class="pre">module.modulemap</span></code> file, it is loaded after the <code class="docutils literal notranslate"><span class="pre">module.modulemap</span></code>
file. In our example library, the <code class="docutils literal notranslate"><span class="pre">module.private.modulemap</span></code> file
would be available when <code class="docutils literal notranslate"><span class="pre">Foo_Private.h</span></code> is available, making it
easier to split a library’s public and private APIs along header
boundaries.</p>
<p>When writing a private module as part of a <em>framework</em>, it’s recommended that:</p>
<ul class="simple">
<li><p>Headers for this module are present in the <code class="docutils literal notranslate"><span class="pre">PrivateHeaders</span></code> framework
subdirectory.</p></li>
<li><p>The private module is defined as a <em>top level module</em> with the name of the
public framework prefixed, like <code class="docutils literal notranslate"><span class="pre">Foo_Private</span></code> above. Clang has extra logic
to work with this naming, using <code class="docutils literal notranslate"><span class="pre">FooPrivate</span></code> or <code class="docutils literal notranslate"><span class="pre">Foo.Private</span></code> (submodule)
trigger warnings and might not work as expected.</p></li>
</ul>
</section>
</section>
<section id="modularizing-a-platform">
<h2><a class="toc-backref" href="#id40" role="doc-backlink">Modularizing a Platform</a><a class="headerlink" href="#modularizing-a-platform" title="Permalink to this heading">¶</a></h2>
<p>To get any benefit out of modules, one needs to introduce module maps for software libraries starting at the bottom of the stack. This typically means introducing a module map covering the operating system’s headers and the C standard library headers (in <code class="docutils literal notranslate"><span class="pre">/usr/include</span></code>, for a Unix system).</p>
<p>The module maps will be written using the <a class="reference internal" href="#module-map-language">module map language</a>, which provides the tools necessary to describe the mapping between headers and modules. Because the set of headers differs from one system to the next, the module map will likely have to be somewhat customized for, e.g., a particular distribution and version of the operating system. Moreover, the system headers themselves may require some modification, if they exhibit any anti-patterns that break modules. Such common patterns are described below.</p>
<dl>
<dt><strong>Macro-guarded copy-and-pasted definitions</strong></dt><dd><p>System headers vend core types such as <code class="docutils literal notranslate"><span class="pre">size_t</span></code> for users. These types are often needed in a number of system headers, and are almost trivial to write. Hence, it is fairly common to see a definition such as the following copy-and-pasted throughout the headers:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#ifndef _SIZE_T</span>
<span class="c1">#define _SIZE_T</span>
<span class="n">typedef</span> <span class="n">__SIZE_TYPE__</span> <span class="n">size_t</span><span class="p">;</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p>Unfortunately, when modules compiles all of the C library headers together into a single module, only the first actual type definition of <code class="docutils literal notranslate"><span class="pre">size_t</span></code> will be visible, and then only in the submodule corresponding to the lucky first header. Any other headers that have copy-and-pasted versions of this pattern will <em>not</em> have a definition of <code class="docutils literal notranslate"><span class="pre">size_t</span></code>. Importing the submodule corresponding to one of those headers will therefore not yield <code class="docutils literal notranslate"><span class="pre">size_t</span></code> as part of the API, because it wasn’t there when the header was parsed. The fix for this problem is either to pull the copied declarations into a common header that gets included everywhere <code class="docutils literal notranslate"><span class="pre">size_t</span></code> is part of the API, or to eliminate the <code class="docutils literal notranslate"><span class="pre">#ifndef</span></code> and redefine the <code class="docutils literal notranslate"><span class="pre">size_t</span></code> type. The latter works for C++ headers and C11, but will cause an error for non-modules C90/C99, where redefinition of <code class="docutils literal notranslate"><span class="pre">typedefs</span></code> is not permitted.</p>
</dd>
<dt><strong>Conflicting definitions</strong></dt><dd><p>Different system headers may provide conflicting definitions for various macros, functions, or types. These conflicting definitions don’t tend to cause problems in a pre-modules world unless someone happens to include both headers in one translation unit. Since the fix is often simply “don’t do that”, such problems persist. Modules requires that the conflicting definitions be eliminated or that they be placed in separate modules (the former is generally the better answer).</p>
</dd>
<dt><strong>Missing includes</strong></dt><dd><p>Headers are often missing <code class="docutils literal notranslate"><span class="pre">#include</span></code> directives for headers that they actually depend on. As with the problem of conflicting definitions, this only affects unlucky users who don’t happen to include headers in the right order. With modules, the headers of a particular module will be parsed in isolation, so the module may fail to build if there are missing includes.</p>
</dd>
<dt><strong>Headers that vend multiple APIs at different times</strong></dt><dd><p>Some systems have headers that contain a number of different kinds of API definitions, only some of which are made available with a given include. For example, the header may vend <code class="docutils literal notranslate"><span class="pre">size_t</span></code> only when the macro <code class="docutils literal notranslate"><span class="pre">__need_size_t</span></code> is defined before that header is included, and also vend <code class="docutils literal notranslate"><span class="pre">wchar_t</span></code> only when the macro <code class="docutils literal notranslate"><span class="pre">__need_wchar_t</span></code> is defined. Such headers are often included many times in a single translation unit, and will have no include guards. There is no sane way to map this header to a submodule. One can either eliminate the header (e.g., by splitting it into separate headers, one per actual API) or simply <code class="docutils literal notranslate"><span class="pre">exclude</span></code> it in the module map.</p>
</dd>
</dl>
<p>To detect and help address some of these problems, the <code class="docutils literal notranslate"><span class="pre">clang-tools-extra</span></code> repository contains a <code class="docutils literal notranslate"><span class="pre">modularize</span></code> tool that parses a set of given headers and attempts to detect these problems and produce a report. See the tool’s in-source documentation for information on how to check your system or library headers.</p>
</section>
<section id="future-directions">
<h2><a class="toc-backref" href="#id41" role="doc-backlink">Future Directions</a><a class="headerlink" href="#future-directions" title="Permalink to this heading">¶</a></h2>
<p>Modules support is under active development, and there are many opportunities remaining to improve it. Here are a few ideas:</p>
<dl class="simple">
<dt><strong>Detect unused module imports</strong></dt><dd><p>Unlike with <code class="docutils literal notranslate"><span class="pre">#include</span></code> directives, it should be fairly simple to track whether a directly-imported module has ever been used. By doing so, Clang can emit <code class="docutils literal notranslate"><span class="pre">unused</span> <span class="pre">import</span></code> or <code class="docutils literal notranslate"><span class="pre">unused</span> <span class="pre">#include</span></code> diagnostics, including Fix-Its to remove the useless imports/includes.</p>
</dd>
<dt><strong>Fix-Its for missing imports</strong></dt><dd><p>It’s fairly common for one to make use of some API while writing code, only to get a compiler error about “unknown type” or “no function named” because the corresponding header has not been included. Clang can detect such cases and auto-import the required module, but should provide a Fix-It to add the import.</p>
</dd>
<dt><strong>Improve modularize</strong></dt><dd><p>The modularize tool is both extremely important (for deployment) and extremely crude. It needs better UI, better detection of problems (especially for C++), and perhaps an assistant mode to help write module maps for you.</p>
</dd>
</dl>
</section>
<section id="where-to-learn-more-about-modules">
<h2><a class="toc-backref" href="#id42" role="doc-backlink">Where To Learn More About Modules</a><a class="headerlink" href="#where-to-learn-more-about-modules" title="Permalink to this heading">¶</a></h2>
<p>The Clang source code provides additional information about modules:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">clang/lib/Headers/module.modulemap</span></code></dt><dd><p>Module map for Clang’s compiler-specific header files.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clang/test/Modules/</span></code></dt><dd><p>Tests specifically related to modules functionality.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clang/include/clang/Basic/Module.h</span></code></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">Module</span></code> class in this header describes a module, and is used throughout the compiler to implement modules.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">clang/include/clang/Lex/ModuleMap.h</span></code></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">ModuleMap</span></code> class in this header describes the full module map, consisting of all of the module map files that have been parsed, and providing facilities for looking up module maps and mapping between modules and headers (in both directions).</p>
</dd>
<dt><a class="reference external" href="PCHInternals.html">PCHInternals</a></dt><dd><p>Information about the serialized AST format used for precompiled headers and modules. The actual implementation is in the <code class="docutils literal notranslate"><span class="pre">clangSerialization</span></code> library.</p>
</dd>
</dl>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id5" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Automatic linking against the libraries of modules requires specific linker support, which is not widely available.</p>
</aside>
<aside class="footnote brackets" id="id6" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>There are certain anti-patterns that occur in headers, particularly system headers, that cause problems for modules. The section <a class="reference internal" href="#modularizing-a-platform">Modularizing a Platform</a> describes some of them.</p>
</aside>
<aside class="footnote brackets" id="id7" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p>The second instance is actually a new thread within the current process, not a separate process. However, the original compiler instance is blocked on the execution of this thread.</p>
</aside>
<aside class="footnote brackets" id="id8" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p>The preprocessing context in which the modules are parsed is actually dependent on the command-line options provided to the compiler, including the language dialect and any <code class="docutils literal notranslate"><span class="pre">-D</span></code> options. However, the compiled modules for different command-line options are kept distinct, and any preprocessor directives that occur within the translation unit are ignored. See the section on the <a class="reference internal" href="#configuration-macros-declaration">Configuration macros declaration</a> for more information.</p>
</aside>
</aside>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="StandardCPlusPlusModules.html">Standard C++ Modules</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="MSVCCompatibility.html">MSVC compatibility</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2007-2024, The Clang Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.1.2.
    </div>
  </body>
</html>