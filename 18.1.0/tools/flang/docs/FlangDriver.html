
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Flang drivers &#8212; The Flang Compiler</title>
    <link rel="stylesheet" href="_static/llvm.css" type="text/css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=bc9a48f6"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="A Fortran feature history cheat sheet" href="FortranFeatureHistory.html" />
    <link rel="prev" title="Flang command line argument reference" href="FlangCommandLineReference.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="FortranFeatureHistory.html" title="A Fortran feature history cheat sheet"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="FlangCommandLineReference.html" title="Flang command line argument reference"
             accesskey="P">previous</a> |</li>
<! TODO: Change the webpage  >
  <li><a href="https://flang.llvm.org">Flang Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

        <li class="nav-item nav-item-this"><a href="">Flang drivers</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://github.com/llvm/llvm-project/blob/main/flang/README.md#getting-started">Getting Started</a></li>
</ul>

<h3>Getting Involved</h3>
<! TODO: Point links to website(flang.llvm.org) and not github once webpage comes up.>
<ul class="want-points">
    <li><a href="https://github.com/llvm/llvm-project/blob/main/flang/docs/GettingInvolved.md#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://github.com/llvm/llvm-project/blob/main/flang/docs/GettingInvolved.md#chat">Slack</a></li>
    <li><a href="https://github.com/llvm/llvm-project/blob/main/flang/docs/GettingInvolved.md#calls">Calls</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://github.com/llvm/llvm-project/tree/main/flang/">Github Repository</a></li>
    <li><a href="https://github.com/llvm/llvm-project/issues">Bug Reports</a></li>
    <li><a href="https://reviews.llvm.org/">Code Review</a></li>
    <li><a href="https://flang.llvm.org/doxygen/">Doxygen API</a></li>
</ul>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <!--===- docs/FlangDriver.md

   Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
   See https://llvm.org/LICENSE.txt for license information.
   SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

-->
<section id="flang-drivers">
<h1>Flang drivers<a class="headerlink" href="#flang-drivers" title="Permalink to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#why-do-we-need-two-drivers" id="id1">Why Do We Need Two Drivers?</a></p></li>
<li><p><a class="reference internal" href="#compiler-driver" id="id2">Compiler Driver</a></p></li>
<li><p><a class="reference internal" href="#linker-driver" id="id3">Linker Driver</a></p></li>
<li><p><a class="reference internal" href="#frontend-driver" id="id4">Frontend Driver</a></p></li>
<li><p><a class="reference internal" href="#the-flang-to-external-fc-script" id="id5">The <code class="docutils literal notranslate"><span class="pre">flang-to-external-fc</span></code> script</a></p></li>
<li><p><a class="reference internal" href="#adding-new-compiler-options" id="id6">Adding new Compiler Options</a></p>
<ul>
<li><p><a class="reference internal" href="#option-definition" id="id7">Option Definition</a></p></li>
<li><p><a class="reference internal" href="#option-implementation" id="id8">Option Implementation</a></p></li>
<li><p><a class="reference internal" href="#action-options" id="id9">Action Options</a></p></li>
</ul>
</li>
</ul>
</nav>
<p>There are two main drivers in Flang:</p>
<ul class="simple">
<li><p>the compiler driver, <code class="docutils literal notranslate"><span class="pre">flang-new</span></code></p></li>
<li><p>the frontend driver, <code class="docutils literal notranslate"><span class="pre">flang-new</span> <span class="pre">-fc1</span></code></p></li>
</ul>
<blockquote>
<div><p><strong><em>NOTE:</em></strong> The diagrams in this document refer to <code class="docutils literal notranslate"><span class="pre">flang</span></code> as opposed to
<code class="docutils literal notranslate"><span class="pre">flang-new</span></code>. Eventually, <code class="docutils literal notranslate"><span class="pre">flang-new</span></code> will be renamed as <code class="docutils literal notranslate"><span class="pre">flang</span></code> and the
diagrams reflect the final design that we are still working towards.</p>
</div></blockquote>
<p>The <strong>compiler driver</strong> will allow you to control all compilation phases (e.g.
preprocessing, semantic checks, code-generation, code-optimisation, lowering
and linking). For frontend specific tasks, the compiler driver creates a
Fortran compilation job and delegates it to <code class="docutils literal notranslate"><span class="pre">flang-new</span> <span class="pre">-fc1</span></code>, the frontend
driver. For linking, it creates a linker job and calls an external linker (e.g.
LLVM’s <a class="reference external" href="https://lld.llvm.org/"><code class="docutils literal notranslate"><span class="pre">lld</span></code></a>). It can also call other tools such as
external assemblers (e.g. <a class="reference external" href="https://www.gnu.org/software/binutils/"><code class="docutils literal notranslate"><span class="pre">as</span></code></a>). In
Clang, the compiler driver can also link the generated binaries with LLVM’s
static analysis/sanitizer libraries (e.g.
<a class="reference external" href="https://clang.llvm.org/docs/MemorySanitizer.html">MemorySanitizer</a>). This is
not yet available in Flang, but will be relatively easy to support once such
libraries become available. Flang’s compiler driver is intended for Flang’s
end-users - its interface needs to remain stable. Otherwise, Flang’s users will
have to adjust their build scripts every time a compiler flag is changed.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p><img alt="Compiler Driver" src="_images/compiler_driver.png" /></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><em>Flang’s compiler driver and the <strong>tools</strong> that it runs</em></p></td>
</tr>
</tbody>
</table>
<p>The <strong>frontend driver</strong> glues together and drives all of the Flang’s frontend
libraries. As such, it provides an easy-to-use and intuitive interface to the
frontend. It uses MLIR and LLVM for code-generation and can be viewed as a
driver for Flang, LLVM and MLIR libraries. Contrary to the compiler driver, it
is not capable of calling any external tools (including linkers).  It is aware
of all the frontend internals that are “hidden” from the compiler driver. It
accepts many frontend-specific options not available in <code class="docutils literal notranslate"><span class="pre">flang-new</span></code> and as such
it provides a finer control over the frontend. Note that this tool is mostly
intended for Flang developers. In particular, there are no guarantees about the
stability of its interface and compiler developers can use it to experiment
with new flags.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p><img alt="Frontend Driver" src="_images/frontend_driver.png" /></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><em>Flang’s frontend driver and the <strong>libraries</strong> that it drives</em></p></td>
</tr>
</tbody>
</table>
<p>Note that similarly to <code class="docutils literal notranslate"><span class="pre">-Xclang</span></code> in <code class="docutils literal notranslate"><span class="pre">clang</span></code>, you can use <code class="docutils literal notranslate"><span class="pre">-Xflang</span></code> to forward a
frontend specific flag from the <em>compiler</em> directly to the <em>frontend</em> driver,
e.g.:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>flang-new<span class="w"> </span>-Xflang<span class="w"> </span>-fdebug-dump-parse-tree<span class="w"> </span>input.f95
</pre></div>
</div>
<p>In the invocation above, <code class="docutils literal notranslate"><span class="pre">-fdebug-dump-parse-tree</span></code> is forwarded to <code class="docutils literal notranslate"><span class="pre">flang-new</span> <span class="pre">-fc1</span></code>. Without the forwarding flag, <code class="docutils literal notranslate"><span class="pre">-Xflang</span></code>, you would see the following
warning:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>flang-new:<span class="w"> </span>warning:<span class="w"> </span>argument<span class="w"> </span>unused<span class="w"> </span>during<span class="w"> </span>compilation:
</pre></div>
</div>
<p>As <code class="docutils literal notranslate"><span class="pre">-fdebug-dump-parse-tree</span></code> is only supported by <code class="docutils literal notranslate"><span class="pre">flang-new</span> <span class="pre">-fc1</span></code>, <code class="docutils literal notranslate"><span class="pre">flang-new</span></code>
will ignore it when used without <code class="docutils literal notranslate"><span class="pre">Xflang</span></code>.</p>
<section id="why-do-we-need-two-drivers">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">Why Do We Need Two Drivers?</a><a class="headerlink" href="#why-do-we-need-two-drivers" title="Permalink to this heading">¶</a></h2>
<p>As hinted above, <code class="docutils literal notranslate"><span class="pre">flang-new</span></code> and <code class="docutils literal notranslate"><span class="pre">flang-new</span> <span class="pre">-fc1</span></code> are two separate tools. The
fact that these tools are accessed through one binary, <code class="docutils literal notranslate"><span class="pre">flang-new</span></code>, is just an
implementation detail. Each tool has a separate list of options, albeit defined
in the same file: <code class="docutils literal notranslate"><span class="pre">clang/include/clang/Driver/Options.td</span></code>.</p>
<p>The separation helps us split various tasks and allows us to implement more
specialised tools. In particular, <code class="docutils literal notranslate"><span class="pre">flang-new</span></code> is not aware of various
compilation phases within the frontend (e.g. scanning, parsing or semantic
checks). It does not have to be. Conversely, the frontend driver, <code class="docutils literal notranslate"><span class="pre">flang-new</span> <span class="pre">-fc1</span></code>, needs not to be concerned with linkers or other external tools like
assemblers. Nor does it need to know where to look for various systems
libraries, which is usually OS and platform specific.</p>
<p>One helpful way of differentiating these tools is to keep in mind that:</p>
<ul class="simple">
<li><p>the compiler driver is an end-user tool</p></li>
<li><p>frontend driver is a compiler developer tool with many additional options,</p></li>
</ul>
<p>Also, Since the compiler driver can call external tools, e.g. linkers, it can
be used to generate <strong>executables</strong>. The frontend driver cannot call external
tools and hence can only generate <strong>object files</strong>. A similar model is
implemented in Clang (<code class="docutils literal notranslate"><span class="pre">clang</span></code> vs <code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">-cc1</span></code> vs <code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">-cc1as</span></code>), which is
based on the <a class="reference external" href="https://en.wikibooks.org/wiki/GNU_C_Compiler_Internals/GNU_C_Compiler_Architecture">architecture of
GCC</a>.
In fact, Flang needs to adhere to this model in order to be able to re-use
Clang’s driver library. If you are more familiar with the <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc-4.7.4/gfortran/About-GNU-Fortran.html">architecture of
GFortran</a>
than Clang, then <code class="docutils literal notranslate"><span class="pre">flang-new</span></code> corresponds to <code class="docutils literal notranslate"><span class="pre">gfortran</span></code> and <code class="docutils literal notranslate"><span class="pre">flang-new</span> <span class="pre">-fc1</span></code> to
<code class="docutils literal notranslate"><span class="pre">f951</span></code>.</p>
</section>
<section id="compiler-driver">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Compiler Driver</a><a class="headerlink" href="#compiler-driver" title="Permalink to this heading">¶</a></h2>
<p>The main entry point for Flang’s compiler driver is implemented in
<code class="docutils literal notranslate"><span class="pre">flang/tools/flang-driver/driver.cpp</span></code>.  Flang’s compiler driver is implemented
in terms of Clang’s driver library, <code class="docutils literal notranslate"><span class="pre">clangDriver</span></code>. This approach allows us to:</p>
<ul class="simple">
<li><p>benefit from Clang’s support for various targets, platforms and operating systems</p></li>
<li><p>leverage Clang’s ability to drive various backends available in LLVM, as well
as linkers and assemblers.
One implication of this dependency on Clang is that all of Flang’s compiler
options are defined alongside Clang’s options in
<code class="docutils literal notranslate"><span class="pre">clang/include/clang/Driver/Options.td</span></code>. For options that are common for both
Flang and Clang, the corresponding definitions are shared.</p></li>
</ul>
<p>Internally, a <code class="docutils literal notranslate"><span class="pre">clangDriver</span></code> based compiler driver works by creating actions
that correspond to various compilation phases, e.g. <code class="docutils literal notranslate"><span class="pre">PreprocessJobClass</span></code>,
<code class="docutils literal notranslate"><span class="pre">CompileJobClass</span></code>, <code class="docutils literal notranslate"><span class="pre">BackendJobClass</span></code> or <code class="docutils literal notranslate"><span class="pre">LinkJobClass</span></code> from the
<code class="docutils literal notranslate"><span class="pre">clang::driver::Action::ActionClass</span></code> enum. There are also other, more
specialised actions, e.g. <code class="docutils literal notranslate"><span class="pre">MigrateJobClass</span></code> or <code class="docutils literal notranslate"><span class="pre">InputClass</span></code>, that do not map
directly to common compilation steps. The actions to run are determined from
the supplied compiler flags, e.g.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-E</span></code> for <code class="docutils literal notranslate"><span class="pre">PreprocessJobClass</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-c</span></code> for <code class="docutils literal notranslate"><span class="pre">CompileJobClass</span></code>.</p></li>
</ul>
<p>In most cases, the driver creates a chain of actions/jobs/phases where the
output from one action is the input for the subsequent one. You can use the
<code class="docutils literal notranslate"><span class="pre">-ccc-print-phases</span></code> flag to see the sequence of actions that the driver will
create for your compiler invocation:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>flang-new<span class="w"> </span>-ccc-print-phases<span class="w"> </span>-E<span class="w"> </span>file.f
+-<span class="w"> </span><span class="m">0</span>:<span class="w"> </span>input,<span class="w"> </span><span class="s2">&quot;file.f&quot;</span>,<span class="w"> </span>f95-cpp-input
<span class="m">1</span>:<span class="w"> </span>preprocessor,<span class="w"> </span><span class="o">{</span><span class="m">0</span><span class="o">}</span>,<span class="w"> </span>f95
</pre></div>
</div>
<p>As you can see, for <code class="docutils literal notranslate"><span class="pre">-E</span></code> the driver creates only two jobs and stops immediately
after preprocessing. The first job simply prepares the input. For <code class="docutils literal notranslate"><span class="pre">-c</span></code>, the
pipeline of the created jobs is more complex:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>flang-new<span class="w"> </span>-ccc-print-phases<span class="w"> </span>-c<span class="w"> </span>file.f
<span class="w">         </span>+-<span class="w"> </span><span class="m">0</span>:<span class="w"> </span>input,<span class="w"> </span><span class="s2">&quot;file.f&quot;</span>,<span class="w"> </span>f95-cpp-input
<span class="w">      </span>+-<span class="w"> </span><span class="m">1</span>:<span class="w"> </span>preprocessor,<span class="w"> </span><span class="o">{</span><span class="m">0</span><span class="o">}</span>,<span class="w"> </span>f95
<span class="w">   </span>+-<span class="w"> </span><span class="m">2</span>:<span class="w"> </span>compiler,<span class="w"> </span><span class="o">{</span><span class="m">1</span><span class="o">}</span>,<span class="w"> </span>ir
+-<span class="w"> </span><span class="m">3</span>:<span class="w"> </span>backend,<span class="w"> </span><span class="o">{</span><span class="m">2</span><span class="o">}</span>,<span class="w"> </span>assembler
<span class="m">4</span>:<span class="w"> </span>assembler,<span class="w"> </span><span class="o">{</span><span class="m">3</span><span class="o">}</span>,<span class="w"> </span>object
</pre></div>
</div>
<p>The other phases are printed nonetheless when using <code class="docutils literal notranslate"><span class="pre">-ccc-print-phases</span></code>, as
that reflects what <code class="docutils literal notranslate"><span class="pre">clangDriver</span></code>, the library, will try to create and run.</p>
<p>For actions specific to the frontend (e.g. preprocessing or code generation), a
command to call the frontend driver is generated (more specifically, an
instance of <code class="docutils literal notranslate"><span class="pre">clang::driver::Command</span></code>). Every command is bound to an instance of
<code class="docutils literal notranslate"><span class="pre">clang::driver::Tool</span></code>. For Flang we introduced a specialisation of this class:
<code class="docutils literal notranslate"><span class="pre">clang::driver::Flang</span></code>. This class implements the logic to either translate or
forward compiler options to the frontend driver, <code class="docutils literal notranslate"><span class="pre">flang-new</span> <span class="pre">-fc1</span></code>.</p>
<p>You can read more on the design of <code class="docutils literal notranslate"><span class="pre">clangDriver</span></code> in Clang’s <a class="reference external" href="https://clang.llvm.org/docs/DriverInternals.html">Driver Design &amp;
Internals</a>.</p>
</section>
<section id="linker-driver">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">Linker Driver</a><a class="headerlink" href="#linker-driver" title="Permalink to this heading">¶</a></h2>
<p>When used as a linker, Flang’s frontend driver assembles the command line for an
external linker command (e.g., LLVM’s <code class="docutils literal notranslate"><span class="pre">lld</span></code>) and invokes it to create the final
executable by linking static and shared libraries together with all the
translation units supplied as object files.</p>
<p>By default, the Flang linker driver adds several libraries to the linker
invocation to make sure that all entrypoints for program start
(Fortran’s program unit) and runtime routines can be resolved by the linker.</p>
<p>An abridged example (only showing the Fortran specific linker flags, omission
indicated by <code class="docutils literal notranslate"><span class="pre">[...]</span></code>) for such a linker invocation on a Linux system would look
like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ flang -v -o example example.o
&quot;/usr/bin/ld&quot; [...] example.o [...] &quot;--whole-archive&quot; &quot;-lFortran_main&quot;
&quot;--no-whole-archive&quot; &quot;-lFortranRuntime&quot; &quot;-lFortranDecimal&quot; [...]
</pre></div>
</div>
<p>The automatically added libraries are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Fortran_main</span></code>: Provides the main entry point <code class="docutils literal notranslate"><span class="pre">main</span></code> that then invokes
<code class="docutils literal notranslate"><span class="pre">_QQmain</span></code> with the Fortran program unit.  This library has a dependency to
the <code class="docutils literal notranslate"><span class="pre">FortranRuntime</span></code> library.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FortranRuntime</span></code>: Provides most of the Flang runtime library.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FortranDecimal</span></code>: Provides operations for decimal numbers.</p></li>
</ul>
<p>The default is that, when using Flang as the linker, one of the Fortran
translation units provides the program unit and therefore it is assumed that
Fortran is the main code part (calling into C/C++ routines via <code class="docutils literal notranslate"><span class="pre">BIND</span> <span class="pre">(C)</span></code>
interfaces).  When composing the linker commandline, Flang uses
<code class="docutils literal notranslate"><span class="pre">--whole-archive</span></code> and <code class="docutils literal notranslate"><span class="pre">--no-whole-archive</span></code> (Windows: <code class="docutils literal notranslate"><span class="pre">/WHOLEARCHIVE:</span></code>,
Darwin &amp; AIX: <em>not implemented yet</em>) to make sure that all for <code class="docutils literal notranslate"><span class="pre">Fortran_main</span></code>
is processed by the linker.  This is done to issue a proper error message when
multiple definitions of <code class="docutils literal notranslate"><span class="pre">main</span></code> occur.  This happens, for instance, when linking
a code that has a Fortran program unit with a C/C++ code that also defines a
<code class="docutils literal notranslate"><span class="pre">main</span></code> function.  A user may be required to explicitly provide the C++ runtime
libraries at link time (e.g., via <code class="docutils literal notranslate"><span class="pre">-lstdc++</span></code> for STL)</p>
<p>If the code is C/C++ based and invokes Fortran routines, one can either use Clang
or Flang as the linker driver.  If Clang is used, it will automatically all
required runtime libraries needed by C++ (e.g., for STL) to the linker invocation.
In this case, one has to explicitly provide the Fortran runtime libraries
<code class="docutils literal notranslate"><span class="pre">FortranRuntime</span></code> and/or <code class="docutils literal notranslate"><span class="pre">FortranDecimal</span></code>.  An alternative is to use Flang to link
and use the <code class="docutils literal notranslate"><span class="pre">-fno-fortran-main</span></code> flag.  This flag removes
<code class="docutils literal notranslate"><span class="pre">Fortran_main</span></code> from the linker stage and hence requires one of the C/C++
translation units to provide a definition of the <code class="docutils literal notranslate"><span class="pre">main</span></code> function. In this case,
it may be required to explicitly supply C++ runtime libraries as mentioned above.</p>
<p>When creating shared or static libraries using Flang with <code class="docutils literal notranslate"><span class="pre">-shared</span></code> or <code class="docutils literal notranslate"><span class="pre">-static</span></code>
flag, Fortran_main is automatically removed from the linker stage (i.e.,
<code class="docutils literal notranslate"><span class="pre">-fno-fortran-main</span></code> is on by default).  It is assumed that when creating a
static or shared library, the generated library does not need a <code class="docutils literal notranslate"><span class="pre">main</span></code>
function, as a final link stage will occur that will provide the <code class="docutils literal notranslate"><span class="pre">Fortran_main</span></code>
library when creating the final executable.</p>
<p>On Darwin, the logical root where the system libraries are located (sysroot)
must be specified. This can be done with the CMake build flag <code class="docutils literal notranslate"><span class="pre">DEFAULT_SYSROOT</span></code>
or by using the <code class="docutils literal notranslate"><span class="pre">-isysroot</span></code> flag when linking a binary. On other targets
<code class="docutils literal notranslate"><span class="pre">-isysroot</span></code> doesn’t change the linker command line (it only affects the header
search path). While with Clang <code class="docutils literal notranslate"><span class="pre">-isysroot</span></code> also changes the sysroot for
includes, with Flang (and Fortran in general) it only affects Darwin libraries’
sysroot.</p>
</section>
<section id="frontend-driver">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">Frontend Driver</a><a class="headerlink" href="#frontend-driver" title="Permalink to this heading">¶</a></h2>
<p>Flang’s frontend driver is the main interface between compiler developers and
the Flang frontend. The high-level design is similar to Clang’s frontend
driver, <code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">-cc1</span></code> and consists of the following classes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">CompilerInstance</span></code>, which is a helper class that encapsulates and manages
various objects that are always required by the frontend (e.g. <code class="docutils literal notranslate"><span class="pre">AllSources</span></code>,
<code class="docutils literal notranslate"><span class="pre">AllCookedSources,</span> </code>Parsing<code class="docutils literal notranslate"><span class="pre">,</span> </code>CompilerInvocation<code class="docutils literal notranslate"><span class="pre">,</span> <span class="pre">etc.).</span> <span class="pre">In</span> <span class="pre">most</span> <span class="pre">cases</span> </code>CompilerInstance` owns these objects, but it also can share them with its
clients when required. It also implements utility methods to construct and
manipulate them.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CompilerInvocation</span></code> encapsulates the configuration of the current
invocation of the compiler as derived from the command-line options and the
input files (in particular, file extensions). Among other things, it holds an
instance of <code class="docutils literal notranslate"><span class="pre">FrontendOptions</span></code>. Like <code class="docutils literal notranslate"><span class="pre">CompilerInstance</span></code>, it owns the objects
that it manages. It can share them with its clients that want to access them
even after the corresponding <code class="docutils literal notranslate"><span class="pre">CompilerInvocation</span></code> has been destructed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FrontendOptions</span></code> holds options that control the behaviour of the frontend,
as well as e.g. the list of the input files. These options come either
directly from the users (through command-line flags) or are derived from
e.g. the host system configuration.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FrontendAction</span></code> and <code class="docutils literal notranslate"><span class="pre">FrontendActions</span></code> (the former being the base class for
the latter) implement the actual actions to perform by the frontend. Usually
there is one specialisation of <code class="docutils literal notranslate"><span class="pre">FrontendActions</span></code> for every compiler action flag
(e.g. <code class="docutils literal notranslate"><span class="pre">-E</span></code>, <code class="docutils literal notranslate"><span class="pre">-fdebug-unparse</span></code>). These classes also contain various hooks that
allow you to e.g. fine-tune the configuration of the frontend based on the
input.</p></li>
</ul>
<p>This list is not exhaustive and only covers the main classes that implement the
driver. The main entry point for the frontend driver, <code class="docutils literal notranslate"><span class="pre">fc1_main</span></code>, is
implemented in <code class="docutils literal notranslate"><span class="pre">flang/tools/flang-driver/driver.cpp</span></code>. It can be accessed by
invoking the compiler driver, <code class="docutils literal notranslate"><span class="pre">flang-new</span></code>, with the <code class="docutils literal notranslate"><span class="pre">-fc1</span></code> flag.</p>
<p>The frontend driver will only run one action at a time. If you specify multiple
action flags, only the last one will be taken into account. The default action
is <code class="docutils literal notranslate"><span class="pre">ParseSyntaxOnlyAction</span></code>, which corresponds to <code class="docutils literal notranslate"><span class="pre">-fsyntax-only</span></code>. In other
words, <code class="docutils literal notranslate"><span class="pre">flang-new</span> <span class="pre">-fc1</span> <span class="pre">&lt;input-file&gt;</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">flang-new</span> <span class="pre">-fc1</span> <span class="pre">-fsyntax-only</span> <span class="pre">&lt;input-file&gt;</span></code>.</p>
</section>
<section id="the-flang-to-external-fc-script">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">flang-to-external-fc</span></code> script</a><a class="headerlink" href="#the-flang-to-external-fc-script" title="Permalink to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">flang-to-external-fc</span></code> wrapper script for <code class="docutils literal notranslate"><span class="pre">flang-new</span></code> was introduced as a
development tool and to facilitate testing. The <code class="docutils literal notranslate"><span class="pre">flang-to-external-fc</span></code> wrapper
script will:</p>
<ul class="simple">
<li><p>use <code class="docutils literal notranslate"><span class="pre">flang-new</span></code> to unparse the input source file (i.e. it will run <code class="docutils literal notranslate"><span class="pre">flang-new</span> <span class="pre">-fc1</span> <span class="pre">-fdebug-unparse</span> <span class="pre">&lt;input-file&gt;</span></code>), and then</p></li>
<li><p>call a host Fortran compiler, e.g. <code class="docutils literal notranslate"><span class="pre">gfortran</span></code>, to compile the unparsed file.</p></li>
</ul>
<p>Here’s a basic breakdown of what happens inside <code class="docutils literal notranslate"><span class="pre">flang-to-external-fc</span></code> when you
run <code class="docutils literal notranslate"><span class="pre">flang-to-external-fc</span> <span class="pre">file.f90</span></code>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>flang-new<span class="w"> </span>-fc1<span class="w"> </span>-fdebug-unparse<span class="w"> </span>file.f90<span class="w"> </span>-o<span class="w"> </span>file-unparsed.f90
gfortran<span class="w"> </span>file-unparsed.f90
</pre></div>
</div>
<p>This is a simplified version for illustration purposes only. In practice,
<code class="docutils literal notranslate"><span class="pre">flang-to-external-fc</span></code> adds a few more frontend options and it also supports
various other use cases (e.g. compiling C files, linking existing object
files). <code class="docutils literal notranslate"><span class="pre">gfortran</span></code> is the default host compiler used by <code class="docutils literal notranslate"><span class="pre">flang-to-external-fc</span></code>.
You can change it by setting the <code class="docutils literal notranslate"><span class="pre">FLANG_FC</span></code> environment variable.</p>
</section>
<section id="adding-new-compiler-options">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">Adding new Compiler Options</a><a class="headerlink" href="#adding-new-compiler-options" title="Permalink to this heading">¶</a></h2>
<p>Adding a new compiler option in Flang consists of two steps:</p>
<ul class="simple">
<li><p>define the new option in a dedicated TableGen file,</p></li>
<li><p>parse and implement the option in the relevant drivers that support it.</p></li>
</ul>
<section id="option-definition">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Option Definition</a><a class="headerlink" href="#option-definition" title="Permalink to this heading">¶</a></h3>
<p>All of Flang’s compiler and frontend driver options are defined in
<code class="docutils literal notranslate"><span class="pre">clang/include/clang/Driver/Options.td</span></code> in Clang. When adding a new option to
Flang, you will either:</p>
<ul class="simple">
<li><p>extend the existing definition for an option that is already available
in one of Clang’s drivers (e.g.  <code class="docutils literal notranslate"><span class="pre">clang</span></code>), but not yet available in Flang, or</p></li>
<li><p>add a completely new definition if the option that you are adding has not
been defined yet.</p></li>
</ul>
<p>There are many predefined TableGen classes and records that you can use to fine
tune your new option. The list of available configurations can be overwhelming
at times. Sometimes the easiest approach is to find an existing option that has
similar semantics to your new option and start by copying that.</p>
<p>For every new option, you will also have to define the visibility of the new
option. This is controlled through the <code class="docutils literal notranslate"><span class="pre">Visibility</span></code> field. You can use the
following Flang specific visibility flags to control this:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">FlangOption</span></code> - this option will be available in the <code class="docutils literal notranslate"><span class="pre">flang-new</span></code> compiler driver,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FC1Option</span></code> - this option will be available in the <code class="docutils literal notranslate"><span class="pre">flang-new</span> <span class="pre">-fc1</span></code> frontend driver,</p></li>
</ul>
<p>Options that are supported by clang should explicitly specify <code class="docutils literal notranslate"><span class="pre">ClangOption</span></code> in
<code class="docutils literal notranslate"><span class="pre">Visibility</span></code>, and options that are only supported in Flang should not specify
<code class="docutils literal notranslate"><span class="pre">ClangOption</span></code>.</p>
<p>When deciding what <code class="docutils literal notranslate"><span class="pre">OptionGroup</span></code> to use when defining a new option in the
<code class="docutils literal notranslate"><span class="pre">Options.td</span></code> file, many new options fall into one of the following two
categories:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Action_Group</span></code> - options that define an action to run (e.g.
<code class="docutils literal notranslate"><span class="pre">-fsyntax-only</span></code>, <code class="docutils literal notranslate"><span class="pre">-E</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f_Group</span></code> - target independent compiler flags (e.g. <code class="docutils literal notranslate"><span class="pre">-ffixed-form</span></code>,
<code class="docutils literal notranslate"><span class="pre">-fopenmp</span></code>)
There are also other groups and occasionally you will use them instead of the
groups listed above.</p></li>
</ul>
</section>
<section id="option-implementation">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Option Implementation</a><a class="headerlink" href="#option-implementation" title="Permalink to this heading">¶</a></h3>
<p>First, every option needs to be parsed. Flang compiler options are parsed in
two different places, depending on which driver they belong to:</p>
<ul class="simple">
<li><p>frontend driver: <code class="docutils literal notranslate"><span class="pre">flang/lib/Frontend/CompilerInvocation.cpp</span></code>,</p></li>
<li><p>compiler driver: <code class="docutils literal notranslate"><span class="pre">clang/lib/Driver/ToolChains/Flang.cpp</span></code>.</p></li>
</ul>
<p>The parsing will depend on the semantics encoded in the TableGen definition.</p>
<p>When adding a compiler driver option (i.e. an option that contains
<code class="docutils literal notranslate"><span class="pre">FlangOption</span></code> among in it’s <code class="docutils literal notranslate"><span class="pre">Visibility</span></code>) that you also intend to be understood
by the frontend, make sure that it is either forwarded to <code class="docutils literal notranslate"><span class="pre">flang-new</span> <span class="pre">-fc1</span></code> or
translated into some other option that is accepted by the frontend driver. In
the case of options that contain both <code class="docutils literal notranslate"><span class="pre">FlangOption</span></code> and <code class="docutils literal notranslate"><span class="pre">FC1Option</span></code> among its
flags, we usually just forward from <code class="docutils literal notranslate"><span class="pre">flang-new</span></code> to <code class="docutils literal notranslate"><span class="pre">flang-new</span> <span class="pre">-fc1</span></code>. This is
then tested in <code class="docutils literal notranslate"><span class="pre">flang/test/Driver/frontend-forward.F90</span></code>.</p>
<p>What follows is usually very dependant on the meaning of the corresponding
option. In general, regular compiler flags (e.g. <code class="docutils literal notranslate"><span class="pre">-ffree-form</span></code>) are mapped to
some state within the driver. A lot of this state is stored within an instance
of <code class="docutils literal notranslate"><span class="pre">FrontendOptions</span></code>, but there are other more specialised classes too. Action
flags (e.g. <code class="docutils literal notranslate"><span class="pre">-fsyntax-only</span></code>) are usually more complex overall, but also more
structured in terms of the implementation.</p>
</section>
<section id="action-options">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">Action Options</a><a class="headerlink" href="#action-options" title="Permalink to this heading">¶</a></h3>
<p>For options that correspond to an action (i.e. marked as <code class="docutils literal notranslate"><span class="pre">Action_Group</span></code>), you
will have to define a dedicated instance of <code class="docutils literal notranslate"><span class="pre">FrontendActions</span></code> in
<code class="docutils literal notranslate"><span class="pre">flang/include/flang/Frontend/FrontendOptions.h</span></code>. For example, for
<code class="docutils literal notranslate"><span class="pre">-fsyntax-only</span></code> we defined:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">ParseSyntaxOnlyAction</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">PrescanAndSemaAction</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">ExecuteAction</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Command line options are mapped to frontend actions through the
<code class="docutils literal notranslate"><span class="pre">Fortran::frontend::ActionKind</span></code> enum.  For every new action option that you
add, you will have to add a dedicated entry in that enum (e.g.
<code class="docutils literal notranslate"><span class="pre">ParseSyntaxOnly</span></code> for <code class="docutils literal notranslate"><span class="pre">-fsyntax-only</span></code>) and a corresponding <code class="docutils literal notranslate"><span class="pre">case</span></code> in
<code class="docutils literal notranslate"><span class="pre">ParseFrontendArgs</span></code> function in the <code class="docutils literal notranslate"><span class="pre">CompilerInvocation.cpp</span></code> file, e.g.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">clang</span><span class="o">::</span><span class="no">driver</span><span class="o">::</span><span class="no">options</span><span class="o">::</span><span class="no">OPT_fsyntax_only</span><span class="p">:</span>
<span class="w">      </span><span class="n">opts</span><span class="p">.</span><span class="n">programAction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ParseSyntaxOnly</span><span class="p">;</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that this simply sets the program/frontend action within the frontend
driver. You still have make sure that the corresponding frontend action class
is instantiated when your new action option is used. The relevant <code class="docutils literal notranslate"><span class="pre">switch</span></code>
statement is implemented in <code class="docutils literal notranslate"><span class="pre">Fortran::frontend::CreatedFrontendBaseAction</span></code> in
the <code class="docutils literal notranslate"><span class="pre">ExecuteCompilerInvocation.cpp</span></code> file. Here’s an example for
<code class="docutils literal notranslate"><span class="pre">-fsyntax-only</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">ParseSyntaxOnly</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">ParseSyntaxOnlyAction</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<p>At this point you should be able to trigger that frontend action that you have
just added using your new frontend option.</p>
</section>
</section>
</section>
<section id="cmake-support">
<h1>CMake Support<a class="headerlink" href="#cmake-support" title="Permalink to this heading">¶</a></h1>
<p>As of <a class="reference external" href="https://gitlab.kitware.com/cmake/cmake/-/merge_requests/7246">#7246</a>
(and soon to be released CMake 3.24.0), <code class="docutils literal notranslate"><span class="pre">cmake</span></code> can detect <code class="docutils literal notranslate"><span class="pre">flang-new</span></code> as a
supported Fortran compiler. You can configure your CMake projects to use
<code class="docutils literal notranslate"><span class="pre">flang-new</span></code> as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>cmake<span class="w"> </span>-DCMAKE_Fortran_COMPILER<span class="o">=</span>&lt;path/to/flang-new&gt;<span class="w"> </span>&lt;src/dir&gt;
</pre></div>
</div>
<p>You should see the following in the output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">--</span> <span class="n">The</span> <span class="n">Fortran</span> <span class="n">compiler</span> <span class="n">identification</span> <span class="ow">is</span> <span class="n">LLVMFlang</span> <span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">&lt;version&gt;</span></code> corresponds to the LLVM Flang version.</p>
</section>
<section id="testing">
<h1>Testing<a class="headerlink" href="#testing" title="Permalink to this heading">¶</a></h1>
<p>In LIT, we define two variables that you can use to invoke Flang’s drivers:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">%flang</span></code> is expanded as <code class="docutils literal notranslate"><span class="pre">flang-new</span></code> (i.e. the compiler driver)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%flang_fc1</span></code> is expanded as <code class="docutils literal notranslate"><span class="pre">flang-new</span> <span class="pre">-fc1</span></code> (i.e. the frontend driver)</p></li>
</ul>
<p>For most regression tests for the frontend, you will want to use <code class="docutils literal notranslate"><span class="pre">%flang_fc1</span></code>.
In some cases, the observable behaviour will be identical regardless of whether
<code class="docutils literal notranslate"><span class="pre">%flang</span></code> or <code class="docutils literal notranslate"><span class="pre">%flang_fc1</span></code> is used. However, when you are using <code class="docutils literal notranslate"><span class="pre">%flang</span></code> instead
of <code class="docutils literal notranslate"><span class="pre">%flang_fc1</span></code>, the compiler driver will add extra flags to the frontend
driver invocation (i.e. <code class="docutils literal notranslate"><span class="pre">flang-new</span> <span class="pre">-fc1</span> <span class="pre">-&lt;extra-flags&gt;</span></code>). In some cases that might
be exactly what you want to test.  In fact, you can check these additional
flags by using the <code class="docutils literal notranslate"><span class="pre">-###</span></code> compiler driver command line option.</p>
<p>Lastly, you can use <code class="docutils literal notranslate"><span class="pre">!</span> <span class="pre">REQUIRES:</span> <span class="pre">&lt;feature&gt;</span></code> for tests that will only work when
<code class="docutils literal notranslate"><span class="pre">&lt;feature&gt;</span></code> is available. For example, you can use<code class="docutils literal notranslate"><span class="pre">!</span> <span class="pre">REQUIRES:</span> <span class="pre">shell</span></code> to mark a
test as only available on Unix-like systems (i.e. systems that contain a Unix
shell). In practice this means that the corresponding test is skipped on
Windows.</p>
</section>
<section id="frontend-driver-plugins">
<h1>Frontend Driver Plugins<a class="headerlink" href="#frontend-driver-plugins" title="Permalink to this heading">¶</a></h1>
<p>Plugins are an extension to the frontend driver that make it possible to run
extra user defined frontend actions, in the form of a specialization of a
<code class="docutils literal notranslate"><span class="pre">PluginParseTreeAction</span></code>. These actions are run during compilation, after
semantic checks. Similarly to Clang, Flang leverages <code class="docutils literal notranslate"><span class="pre">LoadLibraryPermanently</span></code>
from LLVM’s <code class="docutils literal notranslate"><span class="pre">llvm::sys::DynamicLibrary</span></code> to load dynamic objects that implement
plugins. The process for using plugins includes:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#creating-a-plugin">Creating a plugin</a></p></li>
<li><p><a class="reference internal" href="#loading-and-running-a-plugin">Loading and running a plugin</a></p></li>
</ul>
<p>Flang plugins are limited to <code class="docutils literal notranslate"><span class="pre">flang-new</span> <span class="pre">-fc1</span></code> and are currently only available /
been tested on Linux.</p>
<section id="creating-a-plugin">
<h2>Creating a Plugin<a class="headerlink" href="#creating-a-plugin" title="Permalink to this heading">¶</a></h2>
<p>There are three parts required for plugins to work:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#a-pluginparsetreeaction-subclass"><code class="docutils literal notranslate"><span class="pre">PluginParseTreeAction</span></code> subclass</a></p></li>
<li><p><a class="reference internal" href="#implementation-of-executeaction">Implementation of <code class="docutils literal notranslate"><span class="pre">ExecuteAction</span></code></a></p></li>
<li><p><a class="reference internal" href="#plugin-registration">Plugin registration</a></p></li>
</ol>
<p>There is an example plugin located in <code class="docutils literal notranslate"><span class="pre">flang/example/PrintFlangFunctionNames</span></code>
that demonstrates these points by using the <code class="docutils literal notranslate"><span class="pre">ParseTree</span></code> API to print out
function and subroutine names declared in the input file.</p>
<section id="a-pluginparsetreeaction-subclass">
<h3>A <code class="docutils literal notranslate"><span class="pre">PluginParseTreeAction</span></code> Subclass<a class="headerlink" href="#a-pluginparsetreeaction-subclass" title="Permalink to this heading">¶</a></h3>
<p>This subclass will wrap everything together and represent the <code class="docutils literal notranslate"><span class="pre">FrontendAction</span></code>
corresponding to your plugin. It will need to inherit from
<code class="docutils literal notranslate"><span class="pre">PluginParseTreeAction</span></code> (defined in <code class="docutils literal notranslate"><span class="pre">flang/include/flang/FrontendActions.h</span></code>), in
order to have access to the parse tree post semantic checks, and also so that it
can be registered, e.g.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">PrintFunctionNamesAction</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">PluginParseTreeAction</span>
</pre></div>
</div>
</section>
<section id="implementation-of-executeaction">
<h3>Implementation of <code class="docutils literal notranslate"><span class="pre">ExecuteAction</span></code><a class="headerlink" href="#implementation-of-executeaction" title="Permalink to this heading">¶</a></h3>
<p>Like in other frontend actions, the driver looks for an <code class="docutils literal notranslate"><span class="pre">ExecuteAction</span></code> function
to run, so in order for your plugin to do something, you will need to implement
the <code class="docutils literal notranslate"><span class="pre">ExecuteAction</span></code> method in your plugin class. This method will contain the
implementation of what the plugin actually does, for example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Forward declaration</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ParseTreeVisitor</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">ExecuteAction</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ParseTreeVisitor</span><span class="w"> </span><span class="n">visitor</span><span class="p">;</span>
<span class="w">  </span><span class="n">Fortran</span><span class="o">::</span><span class="n">parser</span><span class="o">::</span><span class="n">Walk</span><span class="p">(</span><span class="n">getParsing</span><span class="p">().</span><span class="n">parseTree</span><span class="p">(),</span><span class="w"> </span><span class="n">visitor</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the example plugin, the <code class="docutils literal notranslate"><span class="pre">ExecuteAction</span></code> method first creates an instance of
<code class="docutils literal notranslate"><span class="pre">visitor</span></code> struct, before passing it together with the parse tree to the
<code class="docutils literal notranslate"><span class="pre">Fortran::parser::Walk</span></code> function that will traverse the parse tree. The parse
tree will normally be generated by the frontend driver and can be retrieved in
your plugin through the <code class="docutils literal notranslate"><span class="pre">getParsing()</span></code> member method. Implementation and
details of the <code class="docutils literal notranslate"><span class="pre">Walk</span></code> function can be found in
<code class="docutils literal notranslate"><span class="pre">flang/include/flang/Parser/parse-tree-visitor.h</span></code>.</p>
<p>You will have to define your own <code class="docutils literal notranslate"><span class="pre">visitor</span></code> struct. It should define different
<code class="docutils literal notranslate"><span class="pre">Pre</span></code> and <code class="docutils literal notranslate"><span class="pre">Post</span></code> functions that take the type of a specific <code class="docutils literal notranslate"><span class="pre">ParseTree</span></code> node as
an argument. When the <code class="docutils literal notranslate"><span class="pre">Walk</span></code> function is traversing the parse tree, these
functions will be run before/after a node of that type is visited. Template
functions for <code class="docutils literal notranslate"><span class="pre">Pre</span></code>/<code class="docutils literal notranslate"><span class="pre">Post</span></code> are defined so that when a node is visited that you
have not defined a function for, it will still be able to continue. <code class="docutils literal notranslate"><span class="pre">Pre</span></code>
returns a <code class="docutils literal notranslate"><span class="pre">bool</span></code> indicating whether to visit that node’s children or not. For
example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">ParseTreeVisitor</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">A</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">Pre</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">A</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">A</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Post</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">A</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">Post</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Fortran</span><span class="o">::</span><span class="n">parser</span><span class="o">::</span><span class="n">FunctionStmt</span><span class="w"> </span><span class="o">&amp;</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">llvm</span><span class="o">::</span><span class="n">outs</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">Fortran</span><span class="o">::</span><span class="n">parser</span><span class="o">::</span><span class="n">Name</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">t</span><span class="p">).</span><span class="n">ToString</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The different types of nodes and also what each node structure contains are
defined in <code class="docutils literal notranslate"><span class="pre">flang/include/flang/Parser/parse-tree.h</span></code>. In the example, there is a
<code class="docutils literal notranslate"><span class="pre">Post</span></code> function, with a line that gets the <code class="docutils literal notranslate"><span class="pre">Name</span></code> element from a tuple <code class="docutils literal notranslate"><span class="pre">t</span></code> in
the <code class="docutils literal notranslate"><span class="pre">FunctionStmt</span></code> struct and prints it. This function will be run after every
<code class="docutils literal notranslate"><span class="pre">FunctionStmt</span></code> node is visited in the parse tree.</p>
</section>
<section id="plugin-registration">
<h3>Plugin Registration<a class="headerlink" href="#plugin-registration" title="Permalink to this heading">¶</a></h3>
<p>A plugin registry is used to store names and descriptions of a collection of
plugins. The Flang plugin registry, defined in
<code class="docutils literal notranslate"><span class="pre">flang/include/flang/Frontend/FrontendPluginRegistry.h</span></code>, is an alias of
<code class="docutils literal notranslate"><span class="pre">llvm::Registry</span></code> of type <code class="docutils literal notranslate"><span class="pre">PluginParseTreeAction</span></code>.</p>
<p>The plugin will need to be registered, which will add the Plugin to the registry
and allow it to be used. The format is as follows, with <code class="docutils literal notranslate"><span class="pre">print-fns</span></code> being the
plugin name that is used later to call the plugin and <code class="docutils literal notranslate"><span class="pre">Print</span> <span class="pre">Function</span> <span class="pre">names</span></code>
being the description:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">FrontendPluginRegistry</span><span class="o">::</span><span class="n">Add</span><span class="o">&lt;</span><span class="n">PrintFunctionNamesAction</span><span class="o">&gt;</span><span class="w"> </span><span class="n">X</span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;print-fns&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Print Function names&quot;</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="loading-and-running-a-plugin">
<h2>Loading and Running a Plugin<a class="headerlink" href="#loading-and-running-a-plugin" title="Permalink to this heading">¶</a></h2>
<p>In order to use plugins, there are 2 command line options made available to the
frontend driver, <code class="docutils literal notranslate"><span class="pre">flang-new</span> <span class="pre">-fc1</span></code>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#the-load-dsopath-option"><code class="docutils literal notranslate"><span class="pre">-load</span> <span class="pre">&lt;dsopath&gt;</span></code></a> for loading the dynamic shared
object of the plugin</p></li>
<li><p><a class="reference internal" href="#the-plugin-name-option"><code class="docutils literal notranslate"><span class="pre">-plugin</span> <span class="pre">&lt;name&gt;</span></code></a> for calling the registered plugin</p></li>
</ul>
<p>Invocation of the example plugin is done through:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>flang-new<span class="w"> </span>-fc1<span class="w"> </span>-load<span class="w"> </span>flangPrintFunctionNames.so<span class="w"> </span>-plugin<span class="w"> </span>print-fns<span class="w"> </span>file.f90
</pre></div>
</div>
<p>Both these options are parsed in <code class="docutils literal notranslate"><span class="pre">flang/lib/Frontend/CompilerInvocation.cpp</span></code> and
fulfil their actions in
<code class="docutils literal notranslate"><span class="pre">flang/lib/FrontendTool/ExecuteCompilerInvocation.cpp</span></code></p>
<section id="the-load-dsopath-option">
<h3>The <code class="docutils literal notranslate"><span class="pre">-load</span> <span class="pre">&lt;dsopath&gt;</span></code> option<a class="headerlink" href="#the-load-dsopath-option" title="Permalink to this heading">¶</a></h3>
<p>This loads the plugin shared object library, with the path given at <code class="docutils literal notranslate"><span class="pre">&lt;dsopath&gt;</span></code>,
using <code class="docutils literal notranslate"><span class="pre">LoadLibraryPermantly</span></code> from LLVM’s <code class="docutils literal notranslate"><span class="pre">llvm::sys::DynamicLibrary</span></code>, which
itself uses <code class="docutils literal notranslate"><span class="pre">dlopen</span></code>. During this stage, the plugin is registered with the
registration line from the plugin, storing the name and description.</p>
</section>
<section id="the-plugin-name-option">
<h3>The <code class="docutils literal notranslate"><span class="pre">-plugin</span> <span class="pre">&lt;name&gt;</span></code> option<a class="headerlink" href="#the-plugin-name-option" title="Permalink to this heading">¶</a></h3>
<p>This sets <code class="docutils literal notranslate"><span class="pre">frontend::ActionKind</span> <span class="pre">programAction</span></code> in <code class="docutils literal notranslate"><span class="pre">FrontendOptions</span></code> to
<code class="docutils literal notranslate"><span class="pre">PluginAction</span></code>, through which it searches the plugin registry for the plugin
name from <code class="docutils literal notranslate"><span class="pre">&lt;name&gt;</span></code>. If found, it returns the instantiated plugin, otherwise it
reports an error diagnostic and returns <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>.</p>
</section>
</section>
<section id="enabling-in-tree-plugins">
<h2>Enabling In-Tree Plugins<a class="headerlink" href="#enabling-in-tree-plugins" title="Permalink to this heading">¶</a></h2>
<p>For in-tree plugins, there is the CMake flag <code class="docutils literal notranslate"><span class="pre">FLANG_PLUGIN_SUPPORT</span></code>, enabled by
default, that controls the exporting of executable symbols from <code class="docutils literal notranslate"><span class="pre">flang-new</span></code>,
which plugins need access to. Additionally, there is the CMake flag
<code class="docutils literal notranslate"><span class="pre">LLVM_BUILD_EXAMPLES</span></code>, turned off by default, that is used to control if the
example programs are built. This includes plugins that are in the
<code class="docutils literal notranslate"><span class="pre">flang/example</span></code> directory and added as a <code class="docutils literal notranslate"><span class="pre">sub_directory</span></code> to the
<code class="docutils literal notranslate"><span class="pre">flang/examples/CMakeLists.txt</span></code>, for example, the <code class="docutils literal notranslate"><span class="pre">PrintFlangFunctionNames</span></code>
plugin. It is also possible to develop plugins out-of-tree.</p>
</section>
<section id="limitations">
<h2>Limitations<a class="headerlink" href="#limitations" title="Permalink to this heading">¶</a></h2>
<p>Note that the traversal API presented here is under active development and
might change in the future. We expect it to evolve as support for new
language features are added. This document and the examples will be updated
accordingly.</p>
<p>The current <code class="docutils literal notranslate"><span class="pre">ParseTree</span></code> structure is not suitable for modifications. The
copy constructors are not available and hence duplicating code might not be
trivial. Please take this into consideration when designing your plugin. In
particular, creating a transformation plugin will be noticeably harder than
analysis plugins that just consume (rather than edit) <code class="docutils literal notranslate"><span class="pre">ParseTree</span></code>.</p>
<p>Lastly, if <code class="docutils literal notranslate"><span class="pre">ParseTree</span></code> modifications are performed, then it might be necessary
to re-analyze expressions and modify scope or symbols. You can check
<a class="reference internal" href="Semantics.html"><span class="std std-doc">Semantics.md</span></a> for more details on how <code class="docutils literal notranslate"><span class="pre">ParseTree</span></code> is edited
e.g. during the semantic checks.</p>
</section>
</section>
<section id="llvm-pass-plugins">
<h1>LLVM Pass Plugins<a class="headerlink" href="#llvm-pass-plugins" title="Permalink to this heading">¶</a></h1>
<p>Pass plugins are dynamic shared objects that consist of one or more LLVM IR
passes. The <code class="docutils literal notranslate"><span class="pre">-fpass-plugin</span></code> option enables these passes to be passed to the
middle-end where they are added to the optimization pass pipeline and run after
lowering to LLVM IR.The exact position of the pass in the pipeline will depend
on how it has been registered with the <code class="docutils literal notranslate"><span class="pre">llvm::PassBuilder</span></code>. See the
documentation for
<a class="reference external" href="https://llvm.org/doxygen/classllvm_1_1PassBuilder.html"><code class="docutils literal notranslate"><span class="pre">llvm::PassBuilder</span></code></a>
for details.</p>
<p>The framework to enable pass plugins in <code class="docutils literal notranslate"><span class="pre">flang-new</span></code> uses the exact same
machinery as that used by <code class="docutils literal notranslate"><span class="pre">clang</span></code> and thus has the same capabilities and
limitations.</p>
<p>In order to use a pass plugin, the pass(es) must be compiled into a dynamic
shared object which is then loaded using the <code class="docutils literal notranslate"><span class="pre">-fpass-plugin</span></code> option.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">flang</span><span class="o">-</span><span class="n">new</span> <span class="o">-</span><span class="n">fpass</span><span class="o">-</span><span class="n">plugin</span><span class="o">=/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">plugin</span><span class="o">.</span><span class="n">so</span> <span class="o">&lt;</span><span class="n">file</span><span class="o">.</span><span class="n">f90</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>This option is available in both the compiler driver and the frontend driver.
Note that LLVM plugins are not officially supported on Windows.</p>
<section id="llvm-pass-extensions">
<h2>LLVM Pass Extensions<a class="headerlink" href="#llvm-pass-extensions" title="Permalink to this heading">¶</a></h2>
<p>Pass extensions are similar to plugins, except that they can also be linked
statically. Setting <code class="docutils literal notranslate"><span class="pre">-DLLVM_${NAME}_LINK_INTO_TOOLS</span></code> to <code class="docutils literal notranslate"><span class="pre">ON</span></code> in the cmake
command turns the project into a statically linked extension. An example would
be Polly, e.g., using <code class="docutils literal notranslate"><span class="pre">-DLLVM_POLLY_LINK_INTO_TOOLS=ON</span></code> would link Polly passes
into <code class="docutils literal notranslate"><span class="pre">flang-new</span></code> as built-in middle-end passes.</p>
<p>See the
<a class="reference external" href="https://llvm.org/docs/WritingAnLLVMNewPMPass.html#id9"><code class="docutils literal notranslate"><span class="pre">WritingAnLLVMNewPMPass</span></code></a>
documentation for more details.</p>
</section>
<section id="ofast-and-fast-math">
<h2>Ofast and Fast Math<a class="headerlink" href="#ofast-and-fast-math" title="Permalink to this heading">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">-Ofast</span></code> in Flang means <code class="docutils literal notranslate"><span class="pre">-O3</span> <span class="pre">-ffast-math</span> <span class="pre">-fstack-arrays</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">-ffast-math</span></code> means the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-fno-honor-infinities</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-fno-honor-nans</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-fassociative-math</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-freciprocal-math</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-fapprox-func</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-fno-signed-zeros</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-ffp-contract=fast</span></code></p></li>
</ul>
<p>These correspond to LLVM IR Fast Math attributes:
https://llvm.org/docs/LangRef.html#fast-math-flags</p>
<p>When <code class="docutils literal notranslate"><span class="pre">-ffast-math</span></code> is specified, any linker steps generated by the compiler
driver will also link to <code class="docutils literal notranslate"><span class="pre">crtfastmath.o</span></code>, which adds a static constructor
that sets the FTZ/DAZ bits in MXCSR, affecting not only the current only the
current compilation unit but all static and shared libraries included in the
program. Setting these bits causes denormal floating point numbers to be flushed
to zero.</p>
<section id="comparison-with-gcc-gfortran">
<h3>Comparison with GCC/GFortran<a class="headerlink" href="#comparison-with-gcc-gfortran" title="Permalink to this heading">¶</a></h3>
<p>GCC/GFortran translate <code class="docutils literal notranslate"><span class="pre">-Ofast</span></code> to
<code class="docutils literal notranslate"><span class="pre">-O3</span> <span class="pre">-ffast-math</span> <span class="pre">-fstack-arrays</span> <span class="pre">-fno-semantic-interposition</span></code>.
<code class="docutils literal notranslate"><span class="pre">-fno-semantic-interposition</span></code> is not used because Clang does not enable this as
part of <code class="docutils literal notranslate"><span class="pre">-Ofast</span></code> as the default behaviour is similar.</p>
<p>GCC/GFortran has a wider definition of <code class="docutils literal notranslate"><span class="pre">-ffast-math</span></code>: also including
<code class="docutils literal notranslate"><span class="pre">-fno-trapping-math</span></code>,  <code class="docutils literal notranslate"><span class="pre">-fno-rounding-math</span></code>, and  <code class="docutils literal notranslate"><span class="pre">-fsignaling-nans</span></code>; these
aren’t included in Flang because Flang currently has no support for strict
floating point and so always acts as though these flags were specified.</p>
<p>GCC/GFortran will also set flush-to-zero mode: linking <code class="docutils literal notranslate"><span class="pre">crtfastmath.o</span></code>, the same
as Flang.</p>
<p>The only GCC/GFortran warning option currently supported is <code class="docutils literal notranslate"><span class="pre">-Werror</span></code>.  Passing
any unsupported GCC/GFortran warning flags into Flang’s compiler driver will
result in warnings being emitted.</p>
</section>
<section id="comparison-with-nvfortran">
<h3>Comparison with nvfortran<a class="headerlink" href="#comparison-with-nvfortran" title="Permalink to this heading">¶</a></h3>
<p>nvfortran defines <code class="docutils literal notranslate"><span class="pre">-fast</span></code> as
<code class="docutils literal notranslate"><span class="pre">-O2</span> <span class="pre">-Munroll=c:1</span> <span class="pre">-Mnoframe</span> <span class="pre">-Mlre</span> <span class="pre">-Mpre</span> <span class="pre">-Mvect=simd</span> <span class="pre">-Mcache_align</span> <span class="pre">-Mflushz</span> <span class="pre">-Mvect</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-O2</span> <span class="pre">-Munroll=c:1</span> <span class="pre">-Mlre</span> <span class="pre">-Mautoinline</span> <span class="pre">-Mpre</span> <span class="pre">-Mvect-simd</span></code> affect code
optimization. <code class="docutils literal notranslate"><span class="pre">flang</span> <span class="pre">-O3</span></code> should enable all optimizations for execution time,
similarly to <code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">-O3</span></code>. The <code class="docutils literal notranslate"><span class="pre">-O3</span></code> pipeline has passes that perform
transformations like inlining, vectorisation, unrolling, etc. Additionally,
the GVN and LICM passes perform redundancy elimination like <code class="docutils literal notranslate"><span class="pre">Mpre</span></code> and <code class="docutils literal notranslate"><span class="pre">Mlre</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-Mnoframe</span></code>: the equivalent flag would be <code class="docutils literal notranslate"><span class="pre">-fomit-frame-pointer</span></code>. This flag
is not yet supported in Flang and so Flang follows GFortran in not including
this in <code class="docutils literal notranslate"><span class="pre">-Ofast</span></code>. There is no plan to include this flag as part of <code class="docutils literal notranslate"><span class="pre">-Ofast</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-Mcache_align</span></code>: there is no equivalent flag in Flang or Clang.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-Mflushz</span></code>: flush-to-zero mode - when <code class="docutils literal notranslate"><span class="pre">-ffast-math</span></code> is specified, Flang will
link to <code class="docutils literal notranslate"><span class="pre">crtfastmath.o</span></code> to ensure denormal numbers are flushed to zero.</p></li>
</ul>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="FortranFeatureHistory.html" title="A Fortran feature history cheat sheet"
             >next</a> |</li>
        <li class="right" >
          <a href="FlangCommandLineReference.html" title="Flang command line argument reference"
             >previous</a> |</li>
<! TODO: Change the webpage  >
  <li><a href="https://flang.llvm.org">Flang Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

        <li class="nav-item nav-item-this"><a href="">Flang drivers</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2017-2024, The Flang Team.
      Last updated on Mar 06, 2024.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.1.2.
    </div>
  </body>
</html>