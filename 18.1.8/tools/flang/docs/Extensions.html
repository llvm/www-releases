
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Fortran Extensions supported by Flang &#8212; The Flang Compiler</title>
    <link rel="stylesheet" href="_static/llvm.css" type="text/css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=bc9a48f6"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="A first take on Fortran 202X features for LLVM Flang" href="F202X.html" />
    <link rel="prev" title="DO CONCURRENT isn’t necessarily concurrent" href="DoConcurrent.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="F202X.html" title="A first take on Fortran 202X features for LLVM Flang"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="DoConcurrent.html" title="DO CONCURRENT isn’t necessarily concurrent"
             accesskey="P">previous</a> |</li>
<! TODO: Change the webpage  >
  <li><a href="https://flang.llvm.org">Flang Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

        <li class="nav-item nav-item-this"><a href="">Fortran Extensions supported by Flang</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://github.com/llvm/llvm-project/blob/main/flang/README.md#getting-started">Getting Started</a></li>
</ul>

<h3>Getting Involved</h3>
<! TODO: Point links to website(flang.llvm.org) and not github once webpage comes up.>
<ul class="want-points">
    <li><a href="https://github.com/llvm/llvm-project/blob/main/flang/docs/GettingInvolved.md#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://github.com/llvm/llvm-project/blob/main/flang/docs/GettingInvolved.md#chat">Slack</a></li>
    <li><a href="https://github.com/llvm/llvm-project/blob/main/flang/docs/GettingInvolved.md#calls">Calls</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://github.com/llvm/llvm-project/tree/main/flang/">Github Repository</a></li>
    <li><a href="https://github.com/llvm/llvm-project/issues">Bug Reports</a></li>
    <li><a href="https://reviews.llvm.org/">Code Review</a></li>
    <li><a href="https://flang.llvm.org/doxygen/">Doxygen API</a></li>
</ul>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <!--===- docs/Extensions.md 
  
   Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
   See https://llvm.org/LICENSE.txt for license information.
   SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
  
-->
<section id="fortran-extensions-supported-by-flang">
<h1>Fortran Extensions supported by Flang<a class="headerlink" href="#fortran-extensions-supported-by-flang" title="Permalink to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#intentional-violations-of-the-standard" id="id1">Intentional violations of the standard</a></p></li>
<li><p><a class="reference internal" href="#extensions-deletions-and-legacy-features-supported-by-default" id="id2">Extensions, deletions, and legacy features supported by default</a></p>
<ul>
<li><p><a class="reference internal" href="#extensions-supported-when-enabled-by-options" id="id3">Extensions supported when enabled by options</a></p></li>
<li><p><a class="reference internal" href="#extensions-and-legacy-features-deliberately-not-supported" id="id4">Extensions and legacy features deliberately not supported</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#preprocessing-behavior" id="id5">Preprocessing behavior</a></p></li>
<li><p><a class="reference internal" href="#standard-features-not-silently-accepted" id="id6">Standard features not silently accepted</a></p></li>
<li><p><a class="reference internal" href="#standard-features-that-might-as-well-not-be" id="id7">Standard features that might as well not be</a></p></li>
<li><p><a class="reference internal" href="#behavior-in-cases-where-the-standard-is-ambiguous-or-indefinite" id="id8">Behavior in cases where the standard is ambiguous or indefinite</a></p></li>
<li><p><a class="reference internal" href="#de-facto-standard-features" id="id9">De Facto Standard Features</a></p></li>
</ul>
</nav>
<p>As a general principle, this compiler will accept by default and
without complaint many legacy features, extensions to the standard
language, and features that have been deleted from the standard,
so long as the recognition of those features would not cause a
standard-conforming program to be rejected or misinterpreted.</p>
<p>Other non-standard features, which do conflict with the current
standard specification of the Fortran programming language, are
accepted if enabled by command-line options.</p>
<section id="intentional-violations-of-the-standard">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">Intentional violations of the standard</a><a class="headerlink" href="#intentional-violations-of-the-standard" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p>Scalar <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code> actual argument expressions (not variables!)
are converted to the kinds of scalar <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code> dummy arguments
when the interface is explicit and the kinds differ.
This conversion allows the results of the intrinsics like
<code class="docutils literal notranslate"><span class="pre">SIZE</span></code> that (as mentioned below) may return non-default
<code class="docutils literal notranslate"><span class="pre">INTEGER</span></code> results by default to be passed.  A warning is
emitted when truncation is possible.  These conversions
are not applied in calls to non-intrinsic generic procedures.</p></li>
<li><p>We are not strict on the contents of <code class="docutils literal notranslate"><span class="pre">BLOCK</span> <span class="pre">DATA</span></code> subprograms
so long as they contain no executable code, no internal subprograms,
and allocate no storage outside a named <code class="docutils literal notranslate"><span class="pre">COMMON</span></code> block.  (C1415)</p></li>
<li><p>Delimited list-directed (and NAMELIST) character output is required
to emit contiguous doubled instances of the delimiter character
when it appears in the output value.  When fixed-size records
are being emitted, as is the case with internal output, this
is not possible when the problematic character falls on the last
position of a record.  No two other Fortran compilers do the same
thing in this situation so there is no good precedent to follow.
Because it seems least wrong, we emit one copy of the delimiter as
the last character of the current record and another as the first
character of the next record.  (The second-least-wrong alternative
might be to flag a runtime error, but that seems harsh since it’s
not an explicit error in the standard, and the output may not have
to be usable later as input anyway.)
Consequently, the output is not suitable for use as list-directed or
NAMELIST input.  If a later standard were to clarify this case, this
behavior will change as needed to conform.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">character</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="p">::</span> <span class="n">buffer</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">character</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="p">::</span> <span class="n">quotes</span> <span class="o">=</span> <span class="s1">&#39;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&#39;</span>
<span class="n">write</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="o">*</span><span class="p">,</span><span class="n">delim</span><span class="o">=</span><span class="s2">&quot;QUOTE&quot;</span><span class="p">)</span> <span class="n">quotes</span>
<span class="nb">print</span> <span class="s2">&quot;(&#39;&gt;&#39;,a10,&#39;&lt;&#39;)&quot;</span><span class="p">,</span> <span class="n">buffer</span>
<span class="n">end</span>
</pre></div>
</div>
<ul class="simple">
<li><p>The name of the control variable in an implied DO loop in an array
constructor or DATA statement has a scope over the value-list only,
not the bounds of the implied DO loop.  It is not advisable to use
an object of the same name as the index variable in a bounds
expression, but it will work, instead of being needlessly undefined.</p></li>
<li><p>If both the <code class="docutils literal notranslate"><span class="pre">COUNT=</span></code> and the <code class="docutils literal notranslate"><span class="pre">COUNT_MAX=</span></code> optional arguments are
present on the same call to the intrinsic subroutine <code class="docutils literal notranslate"><span class="pre">SYSTEM_CLOCK</span></code>,
we require that their types have the same integer kind, since the
kind of these arguments is used to select the clock rate.  In common
with some other compilers, the clock rate varies from tenths of a
second to nanoseconds depending on argument kind and platform support.</p></li>
<li><p>If a dimension of a descriptor has zero extent in a call to
<code class="docutils literal notranslate"><span class="pre">CFI_section</span></code>, <code class="docutils literal notranslate"><span class="pre">CFI_setpointer</span></code> or <code class="docutils literal notranslate"><span class="pre">CFI_allocate</span></code>, the lower
bound on that dimension will be set to 1 for consistency with
the <code class="docutils literal notranslate"><span class="pre">LBOUND()</span></code> intrinsic function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-2147483648_4</span></code> is, strictly speaking, a non-conforming literal
constant on a machine with 32-bit two’s-complement integers as
kind 4, because the grammar of Fortran expressions parses it as a
negation of a literal constant, not a negative literal constant.
This compiler accepts it with a portability warning.</p></li>
<li><p>Construct names like <code class="docutils literal notranslate"><span class="pre">loop</span></code> in <code class="docutils literal notranslate"><span class="pre">loop:</span> <span class="pre">do</span> <span class="pre">j=1,n</span></code> are defined to
be “local identifiers” and should be distinct in the “inclusive
scope” – i.e., not scoped by <code class="docutils literal notranslate"><span class="pre">BLOCK</span></code> constructs.
As most (but not all) compilers implement <code class="docutils literal notranslate"><span class="pre">BLOCK</span></code> scoping of construct
names, so does f18, with a portability warning.</p></li>
<li><p>15.6.4 paragraph 2 prohibits an implicitly typed statement function
from sharing the same name as a symbol in its scope’s host, if it
has one.
We accept this usage with a portability warning.</p></li>
<li><p>A module name from a <code class="docutils literal notranslate"><span class="pre">USE</span></code> statement can also be used as a
non-global name in the same scope.  This is not conforming,
but it is useful and unambiguous.</p></li>
<li><p>The argument to <code class="docutils literal notranslate"><span class="pre">RANDOM_NUMBER</span></code> may not be an assumed-size array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NULL()</span></code> without <code class="docutils literal notranslate"><span class="pre">MOLD=</span></code> is not allowed to be associated as an
actual argument corresponding to an assumed-rank dummy argument;
its rank in the called procedure would not be well-defined.</p></li>
<li><p>When an index variable of a <code class="docutils literal notranslate"><span class="pre">FORALL</span></code> or <code class="docutils literal notranslate"><span class="pre">DO</span> <span class="pre">CONCURRENT</span></code> is present
in the enclosing scope, and the construct does not have an explicit
type specification for its index variables, some weird restrictions
in F’2023 subclause 19.4 paragraphs 6 &amp; 8 should apply.  Since this
compiler properly scopes these names, violations of these restrictions
elicit only portability warnings by default.</p></li>
<li><p>The standard defines the intrinsic functions <code class="docutils literal notranslate"><span class="pre">MOD</span></code> and <code class="docutils literal notranslate"><span class="pre">MODULO</span></code>
for real arguments using expressions in terms of <code class="docutils literal notranslate"><span class="pre">AINT</span></code> and <code class="docutils literal notranslate"><span class="pre">FLOOR</span></code>.
These definitions yield fairly poor results due to floating-point
cancellation, and every Fortran compiler (including this one)
uses better algorithms.</p></li>
<li><p>When an index variable of a <code class="docutils literal notranslate"><span class="pre">FORALL</span></code> or <code class="docutils literal notranslate"><span class="pre">DO</span> <span class="pre">CONCURRENT</span></code> is present
in the enclosing scope, and the construct does not have an explicit
type specification for its index variables, some weird restrictions
in F’2023 subclause 19.4 paragraphs 6 &amp; 8 should apply.  Since this
compiler properly scopes these names, violations of these restrictions
elicit only portability warnings by default.</p></li>
</ul>
</section>
<section id="extensions-deletions-and-legacy-features-supported-by-default">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Extensions, deletions, and legacy features supported by default</a><a class="headerlink" href="#extensions-deletions-and-legacy-features-supported-by-default" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p>Tabs in source</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code> as synonym for <code class="docutils literal notranslate"><span class="pre">.NE.</span></code> and <code class="docutils literal notranslate"><span class="pre">/=</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">$</span></code> and <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> as legal characters in names</p></li>
<li><p>Initialization in type declaration statements using <code class="docutils literal notranslate"><span class="pre">/values/</span></code></p></li>
<li><p>Saved variables without explicit or default initializers are zero initialized.</p></li>
<li><p>In a saved entity of a type with a default initializer, components without default
values are zero initialized.</p></li>
<li><p>Kind specification with <code class="docutils literal notranslate"><span class="pre">*</span></code>, e.g. <code class="docutils literal notranslate"><span class="pre">REAL*4</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DOUBLE</span> <span class="pre">COMPLEX</span></code> as a synonym for <code class="docutils literal notranslate"><span class="pre">COMPLEX(KIND(0.D0))</span></code> –
but not when spelled <code class="docutils literal notranslate"><span class="pre">TYPE(DOUBLECOMPLEX)</span></code>.</p></li>
<li><p>Signed complex literal constants</p></li>
<li><p>DEC <code class="docutils literal notranslate"><span class="pre">STRUCTURE</span></code>, <code class="docutils literal notranslate"><span class="pre">RECORD</span></code>, with ‘%FILL’; but <code class="docutils literal notranslate"><span class="pre">UNION</span></code>, and <code class="docutils literal notranslate"><span class="pre">MAP</span></code>
are not yet supported throughout compilation, and elicit a
“not yet implemented” message.</p></li>
<li><p>Structure field access with <code class="docutils literal notranslate"><span class="pre">.field</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BYTE</span></code> as synonym for <code class="docutils literal notranslate"><span class="pre">INTEGER(KIND=1)</span></code>; but not when spelled <code class="docutils literal notranslate"><span class="pre">TYPE(BYTE)</span></code>.</p></li>
<li><p>When kind-param is used for REAL literals, allow a matching exponent letter</p></li>
<li><p>Quad precision REAL literals with <code class="docutils literal notranslate"><span class="pre">Q</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">X</span></code> prefix/suffix as synonym for <code class="docutils literal notranslate"><span class="pre">Z</span></code> on hexadecimal literals</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">O</span></code>, <code class="docutils literal notranslate"><span class="pre">Z</span></code>, and <code class="docutils literal notranslate"><span class="pre">X</span></code> accepted as suffixes as well as prefixes</p></li>
<li><p>Support for using bare <code class="docutils literal notranslate"><span class="pre">L</span></code> in FORMAT statement</p></li>
<li><p>Triplets allowed in array constructors</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%LOC</span></code>, <code class="docutils literal notranslate"><span class="pre">%VAL</span></code>, and <code class="docutils literal notranslate"><span class="pre">%REF</span></code></p></li>
<li><p>Leading comma allowed before I/O item list</p></li>
<li><p>Empty parentheses allowed in <code class="docutils literal notranslate"><span class="pre">PROGRAM</span> <span class="pre">P()</span></code></p></li>
<li><p>Missing parentheses allowed in <code class="docutils literal notranslate"><span class="pre">FUNCTION</span> <span class="pre">F</span></code></p></li>
<li><p>Cray based <code class="docutils literal notranslate"><span class="pre">POINTER(p,x)</span></code> and <code class="docutils literal notranslate"><span class="pre">LOC()</span></code> intrinsic (with <code class="docutils literal notranslate"><span class="pre">%LOC()</span></code> as
an alias)</p></li>
<li><p>Arithmetic <code class="docutils literal notranslate"><span class="pre">IF</span></code>.  (Which branch should NaN take? Fall through?)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ASSIGN</span></code> statement, assigned <code class="docutils literal notranslate"><span class="pre">GO</span> <span class="pre">TO</span></code>, and assigned format</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PAUSE</span></code> statement</p></li>
<li><p>Hollerith literals and edit descriptors</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NAMELIST</span></code> allowed in the execution part</p></li>
<li><p>Omitted colons on type declaration statements with attributes</p></li>
<li><p>COMPLEX constructor expression, e.g. <code class="docutils literal notranslate"><span class="pre">(x+y,z)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">+</span></code> and <code class="docutils literal notranslate"><span class="pre">-</span></code> before all primary expressions, e.g. <code class="docutils literal notranslate"><span class="pre">x*-y</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.NOT.</span> <span class="pre">.NOT.</span></code> accepted</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NAME=</span></code> as synonym for <code class="docutils literal notranslate"><span class="pre">FILE=</span></code></p></li>
<li><p>Data edit descriptors without width or other details</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">D</span></code> lines in fixed form as comments or debug code</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CARRIAGECONTROL=</span></code> on the OPEN and INQUIRE statements</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CONVERT=</span></code> on the OPEN and INQUIRE statements</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DISPOSE=</span></code> on the OPEN and INQUIRE statements</p></li>
<li><p>Leading semicolons are ignored before any statement that
could have a label</p></li>
<li><p>The character <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> in column 1 in fixed form source is a variant form
of continuation line.</p></li>
<li><p>Character literals as elements of an array constructor without an explicit
type specifier need not have the same length; the longest literal determines
the length parameter of the implicit type, not the first.</p></li>
<li><p>Outside a character literal, a comment after a continuation marker (&amp;)
need not begin with a comment marker (!).</p></li>
<li><p>Classic C-style /<em>comments</em>/ are skipped, so multi-language header
files are easier to write and use.</p></li>
<li><p>$ and \ edit descriptors are supported in FORMAT to suppress newline
output on user prompts.</p></li>
<li><p>Tabs in format strings (not <code class="docutils literal notranslate"><span class="pre">FORMAT</span></code> statements) are allowed on output.</p></li>
<li><p>REAL and DOUBLE PRECISION variable and bounds in DO loops</p></li>
<li><p>Integer literals without explicit kind specifiers that are out of range
for the default kind of INTEGER are assumed to have the least larger kind
that can hold them, if one exists.</p></li>
<li><p>BOZ literals can be used as INTEGER values in contexts where the type is
unambiguous: the right hand sides of assignments and initializations
of INTEGER entities, as actual arguments to a few intrinsic functions
(ACHAR, BTEST, CHAR), and as actual arguments of references to
procedures with explicit interfaces whose corresponding dummy
argument has a numeric type to which the BOZ literal may be
converted.  BOZ literals are interpreted as default INTEGER only
when they appear as the first items of array constructors with no
explicit type.  Otherwise, they generally cannot be used if the type would
not be known (e.g., <code class="docutils literal notranslate"><span class="pre">IAND(X'1',X'2')</span></code>).</p></li>
<li><p>BOZ literals can also be used as REAL values in some contexts where the
type is unambiguous, such as initializations of REAL parameters.</p></li>
<li><p>EQUIVALENCE of numeric and character sequences (a ubiquitous extension),
as well as of sequences of non-default kinds of numeric types
with each other.</p></li>
<li><p>Values for whole anonymous parent components in structure constructors
(e.g., <code class="docutils literal notranslate"><span class="pre">EXTENDEDTYPE(PARENTTYPE(1,2,3))</span></code> rather than <code class="docutils literal notranslate"><span class="pre">EXTENDEDTYPE(1,2,3)</span></code>
or <code class="docutils literal notranslate"><span class="pre">EXTENDEDTYPE(PARENTTYPE=PARENTTYPE(1,2,3))</span></code>).</p></li>
<li><p>Some intrinsic functions are specified in the standard as requiring the
same type and kind for their arguments (viz., ATAN with two arguments,
ATAN2, DIM, HYPOT, IAND, IEOR, IOR, MAX, MIN, MOD, and MODULO);
we allow distinct types to be used, promoting
the arguments as if they were operands to an intrinsic <code class="docutils literal notranslate"><span class="pre">+</span></code> operator,
and defining the result type accordingly.</p></li>
<li><p>DOUBLE COMPLEX intrinsics DREAL, DCMPLX, DCONJG, and DIMAG.</p></li>
<li><p>The DFLOAT intrinsic function.</p></li>
<li><p>INT_PTR_KIND intrinsic returns the kind of c_intptr_t.</p></li>
<li><p>Restricted specific conversion intrinsics FLOAT, SNGL, IDINT, IFIX, DREAL,
and DCMPLX accept arguments of any kind instead of only the default kind or
double precision kind. Their result kinds remain as specified.</p></li>
<li><p>Specific intrinsics AMAX0, AMAX1, AMIN0, AMIN1, DMAX1, DMIN1, MAX0, MAX1,
MIN0, and MIN1 accept more argument types than specified. They are replaced by
the related generics followed by conversions to the specified result types.</p></li>
<li><p>When a scalar CHARACTER actual argument of the same kind is known to
have a length shorter than the associated dummy argument, it is extended
on the right with blanks, similar to assignment.</p></li>
<li><p>When a dummy argument is <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> or <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> and is <code class="docutils literal notranslate"><span class="pre">INTENT(IN)</span></code>, we
relax enforcement of some requirements on actual arguments that must otherwise
hold true for definable arguments.</p></li>
<li><p>Assignment of <code class="docutils literal notranslate"><span class="pre">LOGICAL</span></code> to <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code> and vice versa (but not other types) is
allowed.  The values are normalized to canonical <code class="docutils literal notranslate"><span class="pre">.TRUE.</span></code>/<code class="docutils literal notranslate"><span class="pre">.FALSE.</span></code>.
The values are also normalized for assignments of <code class="docutils literal notranslate"><span class="pre">LOGICAL(KIND=K1)</span></code> to
<code class="docutils literal notranslate"><span class="pre">LOGICAL(KIND=K2)</span></code>, when <code class="docutils literal notranslate"><span class="pre">K1</span> <span class="pre">!=</span> <span class="pre">K2</span></code>.</p></li>
<li><p>Static initialization of <code class="docutils literal notranslate"><span class="pre">LOGICAL</span></code> with <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code> is allowed in <code class="docutils literal notranslate"><span class="pre">DATA</span></code> statements
and object initializers.
The results are <em>not</em> normalized to canonical <code class="docutils literal notranslate"><span class="pre">.TRUE.</span></code>/<code class="docutils literal notranslate"><span class="pre">.FALSE.</span></code>.
Static initialization of <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code> with <code class="docutils literal notranslate"><span class="pre">LOGICAL</span></code> is also permitted.</p></li>
<li><p>An effectively empty source file (no program unit) is accepted and
produces an empty relocatable output file.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">RETURN</span></code> statement may appear in a main program.</p></li>
<li><p>DATA statement initialization is allowed for procedure pointers outside
structure constructors.</p></li>
<li><p>Nonstandard intrinsic functions: ISNAN, SIZEOF</p></li>
<li><p>A forward reference to a default INTEGER scalar dummy argument or
<code class="docutils literal notranslate"><span class="pre">COMMON</span></code> block variable is permitted to appear in a specification
expression, such as an array bound, in a scope with IMPLICIT NONE(TYPE)
if the name of the variable would have caused it to be implicitly typed
as default INTEGER if IMPLICIT NONE(TYPE) were absent.</p></li>
<li><p>OPEN(ACCESS=’APPEND’) is interpreted as OPEN(POSITION=’APPEND’)
to ease porting from Sun Fortran.</p></li>
<li><p>Intrinsic subroutines EXIT([status]) and ABORT()</p></li>
<li><p>The definition of simple contiguity in 9.5.4 applies only to arrays;
we also treat scalars as being trivially contiguous, so that they
can be used in contexts like data targets in pointer assignments
with bounds remapping.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">CONTIGUOUS</span></code> attribute can be redundantly applied to simply
contiguous objects, including scalars, with a portability warning.</p></li>
<li><p>We support some combinations of specific procedures in generic
interfaces that a strict reading of the standard would preclude
when their calls must nonetheless be distinguishable.
Specifically, <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> dummy arguments are distinguishing
if an actual argument acceptable to one could not be passed to
the other &amp; vice versa because exactly one is polymorphic or
exactly one is unlimited polymorphic).</p></li>
<li><p>External unit 0 is predefined and connected to the standard error output,
and defined as <code class="docutils literal notranslate"><span class="pre">ERROR_UNIT</span></code> in the intrinsic <code class="docutils literal notranslate"><span class="pre">ISO_FORTRAN_ENV</span></code> module.</p></li>
<li><p>Objects in blank COMMON may be initialized.</p></li>
<li><p>Initialization of COMMON blocks outside of BLOCK DATA subprograms.</p></li>
<li><p>Multiple specifications of the SAVE attribute on the same object
are allowed, with a warning.</p></li>
<li><p>Specific intrinsic functions BABS, IIABS, JIABS, KIABS, ZABS, and CDABS.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> component’s type need not be a sequence type when
the component appears in a derived type with <code class="docutils literal notranslate"><span class="pre">SEQUENCE</span></code>.
(This case should probably be an exception to constraint C740 in
the standard.)</p></li>
<li><p>Format expressions that have type but are not character and not
integer scalars are accepted so long as they are simply contiguous.
This legacy extension supports pre-Fortran’77 usage in which
variables initialized in DATA statements with Hollerith literals
as modifiable formats.</p></li>
<li><p>At runtime, <code class="docutils literal notranslate"><span class="pre">NAMELIST</span></code> input will skip over <code class="docutils literal notranslate"><span class="pre">NAMELIST</span></code> groups
with other names, and will treat text before and between groups
as if they were comment lines, even if not begun with <code class="docutils literal notranslate"><span class="pre">!</span></code>.</p></li>
<li><p>Commas are required in FORMAT statements and character variables
only when they prevent ambiguity.</p></li>
<li><p>Legacy names <code class="docutils literal notranslate"><span class="pre">AND</span></code>, <code class="docutils literal notranslate"><span class="pre">OR</span></code>, and <code class="docutils literal notranslate"><span class="pre">XOR</span></code> are accepted as aliases for
the standard intrinsic functions <code class="docutils literal notranslate"><span class="pre">IAND</span></code>, <code class="docutils literal notranslate"><span class="pre">IOR</span></code>, and <code class="docutils literal notranslate"><span class="pre">IEOR</span></code>
respectively.</p></li>
<li><p>A digit count of d=0 is accepted in Ew.0, Dw.0, and Gw.0 output
editing if no nonzero scale factor (kP) is in effect.</p></li>
<li><p>The name <code class="docutils literal notranslate"><span class="pre">IMAG</span></code> is accepted as an alias for the generic intrinsic
function <code class="docutils literal notranslate"><span class="pre">AIMAG</span></code>.</p></li>
<li><p>The legacy extension intrinsic functions <code class="docutils literal notranslate"><span class="pre">IZEXT</span></code> and <code class="docutils literal notranslate"><span class="pre">JZEXT</span></code>
are supported; <code class="docutils literal notranslate"><span class="pre">ZEXT</span></code> has different behavior with various older
compilers, so it is not supported.</p></li>
<li><p>f18 doesn’t impose a limit on the number of continuation lines
allowed for a single statement.</p></li>
<li><p>When a type-bound procedure declaration statement has neither interface
nor attributes, the “::” before the bindings is optional, even
if a binding has renaming with “=&gt; proc”.
The colons are not necessary for an unambiguous parse, C768
notwithstanding.</p></li>
<li><p>A type-bound procedure binding can be passed as an actual
argument corresponding to a dummy procedure and can be used as
the target of a procedure pointer assignment statement.</p></li>
<li><p>An explicit <code class="docutils literal notranslate"><span class="pre">INTERFACE</span></code> can declare the interface of a
procedure pointer even if it is not a dummy argument.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">NOPASS</span></code> type-bound procedure binding is required by C1529
to apply only to a scalar data-ref, but most compilers don’t
enforce it and the constraint is not necessary for a correct
implementation.</p></li>
<li><p>A label may follow a semicolon in fixed form source.</p></li>
<li><p>A scalar logical dummy argument to a <code class="docutils literal notranslate"><span class="pre">BIND(C)</span></code> procedure does
not have to have <code class="docutils literal notranslate"><span class="pre">KIND=C_BOOL</span></code> since it can be converted to/from
<code class="docutils literal notranslate"><span class="pre">_Bool</span></code> without loss of information.</p></li>
<li><p>The character length of the <code class="docutils literal notranslate"><span class="pre">SOURCE=</span></code> or <code class="docutils literal notranslate"><span class="pre">MOLD=</span></code> in <code class="docutils literal notranslate"><span class="pre">ALLOCATE</span></code>
may be distinct from the constant character length, if any,
of an allocated object.</p></li>
<li><p>When a name is brought into a scope by multiple ways,
such as USE-association as well as an <code class="docutils literal notranslate"><span class="pre">IMPORT</span></code> from its host,
it’s an error only if the resolution is ambiguous.</p></li>
<li><p>An entity may appear in a <code class="docutils literal notranslate"><span class="pre">DATA</span></code> statement before its explicit
type declaration under <code class="docutils literal notranslate"><span class="pre">IMPLICIT</span> <span class="pre">NONE(TYPE)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">INCLUDE</span></code> lines can start in any column, can be preceded in
fixed form source by a ‘0’ in column 6, can contain spaces
between the letters of the word INCLUDE, and can have a
numeric character literal kind prefix on the file name.</p></li>
<li><p>Intrinsic procedures TAND and ATAND. Constant folding is currently
not supported for these procedures but this is planned.</p></li>
<li><p>When a pair of quotation marks in a character literal are split
by a line continuation in free form, the second quotation mark
may appear at the beginning of the continuation line without an
ampersand, althought one is required by the standard.</p></li>
<li><p>Unrestricted <code class="docutils literal notranslate"><span class="pre">INTRINSIC</span></code> functions are accepted for use in
<code class="docutils literal notranslate"><span class="pre">PROCEDURE</span></code> statements in generic interfaces, as in some other
compilers.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">NULL()</span></code> pointer is treated as an unallocated allocatable
when associated with an <code class="docutils literal notranslate"><span class="pre">INTENT(IN)</span></code> allocatable dummy argument.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">READ(...,</span> <span class="pre">SIZE=n)</span></code> is accepted with <code class="docutils literal notranslate"><span class="pre">NML=</span></code> and <code class="docutils literal notranslate"><span class="pre">FMT=*</span></code> with
a portability warning.
The Fortran standard doesn’t allow <code class="docutils literal notranslate"><span class="pre">SIZE=</span></code> with formatted input
modes that might require look-ahead, perhaps to ease implementations.</p></li>
<li><p>When a file included via an <code class="docutils literal notranslate"><span class="pre">INCLUDE</span></code> line or <code class="docutils literal notranslate"><span class="pre">#include</span></code> directive
has a continuation marker at the end of its last line in free form,
Fortran line continuation works.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">NAMELIST</span></code> input group may omit its trailing <code class="docutils literal notranslate"><span class="pre">/</span></code> character if
it is followed by another <code class="docutils literal notranslate"><span class="pre">NAMELIST</span></code> input group.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">NAMELIST</span></code> input group may begin with either <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> or <code class="docutils literal notranslate"><span class="pre">$</span></code>.</p></li>
<li><p>A comma in a fixed-width numeric input field terminates the
field rather than signaling an invalid character error.</p></li>
</ul>
<section id="extensions-supported-when-enabled-by-options">
<h3><a class="toc-backref" href="#id3" role="doc-backlink">Extensions supported when enabled by options</a><a class="headerlink" href="#extensions-supported-when-enabled-by-options" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>C-style backslash escape sequences in quoted CHARACTER literals
(but not Hollerith) [-fbackslash], including Unicode escapes
with <code class="docutils literal notranslate"><span class="pre">\U</span></code>.</p></li>
<li><p>Logical abbreviations <code class="docutils literal notranslate"><span class="pre">.T.</span></code>, <code class="docutils literal notranslate"><span class="pre">.F.</span></code>, <code class="docutils literal notranslate"><span class="pre">.N.</span></code>, <code class="docutils literal notranslate"><span class="pre">.A.</span></code>, <code class="docutils literal notranslate"><span class="pre">.O.</span></code>, and <code class="docutils literal notranslate"><span class="pre">.X.</span></code>
[-flogical-abbreviations]</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.XOR.</span></code> as a synonym for <code class="docutils literal notranslate"><span class="pre">.NEQV.</span></code> [-fxor-operator]</p></li>
<li><p>The default <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code> type is required by the standard to occupy
the same amount of storage as the default <code class="docutils literal notranslate"><span class="pre">REAL</span></code> type.  Default
<code class="docutils literal notranslate"><span class="pre">REAL</span></code> is of course 32-bit IEEE-754 floating-point today.  This legacy
rule imposes an artificially small constraint in some cases
where Fortran mandates that something have the default <code class="docutils literal notranslate"><span class="pre">INTEGER</span></code>
type: specifically, the results of references to the intrinsic functions
<code class="docutils literal notranslate"><span class="pre">SIZE</span></code>, <code class="docutils literal notranslate"><span class="pre">STORAGE_SIZE</span></code>,<code class="docutils literal notranslate"><span class="pre">LBOUND</span></code>, <code class="docutils literal notranslate"><span class="pre">UBOUND</span></code>, <code class="docutils literal notranslate"><span class="pre">SHAPE</span></code>, and the location reductions
<code class="docutils literal notranslate"><span class="pre">FINDLOC</span></code>, <code class="docutils literal notranslate"><span class="pre">MAXLOC</span></code>, and <code class="docutils literal notranslate"><span class="pre">MINLOC</span></code> in the absence of an explicit
<code class="docutils literal notranslate"><span class="pre">KIND=</span></code> actual argument.  We return <code class="docutils literal notranslate"><span class="pre">INTEGER(KIND=8)</span></code> by default in
these cases when the <code class="docutils literal notranslate"><span class="pre">-flarge-sizes</span></code> option is enabled.
<code class="docutils literal notranslate"><span class="pre">SIZEOF</span></code> and <code class="docutils literal notranslate"><span class="pre">C_SIZEOF</span></code> always return <code class="docutils literal notranslate"><span class="pre">INTEGER(KIND=8)</span></code>.</p></li>
<li><p>Treat each specification-part like is has <code class="docutils literal notranslate"><span class="pre">IMPLICIT</span> <span class="pre">NONE</span></code>
[-fimplicit-none-type-always]</p></li>
<li><p>Ignore occurrences of <code class="docutils literal notranslate"><span class="pre">IMPLICIT</span> <span class="pre">NONE</span></code> and <code class="docutils literal notranslate"><span class="pre">IMPLICIT</span> <span class="pre">NONE(TYPE)</span></code>
[-fimplicit-none-type-never]</p></li>
<li><p>Old-style <code class="docutils literal notranslate"><span class="pre">PARAMETER</span> <span class="pre">pi=3.14</span></code> statement without parentheses
[-falternative-parameter-statement]</p></li>
</ul>
</section>
<section id="extensions-and-legacy-features-deliberately-not-supported">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">Extensions and legacy features deliberately not supported</a><a class="headerlink" href="#extensions-and-legacy-features-deliberately-not-supported" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">.LG.</span></code> as synonym for <code class="docutils literal notranslate"><span class="pre">.NE.</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">REDIMENSION</span></code></p></li>
<li><p>Allocatable <code class="docutils literal notranslate"><span class="pre">COMMON</span></code></p></li>
<li><p>Expressions in formats</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ACCEPT</span></code> as synonym for <code class="docutils literal notranslate"><span class="pre">READ</span> <span class="pre">*</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TYPE</span></code> as synonym for <code class="docutils literal notranslate"><span class="pre">PRINT</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ARRAY</span></code> as synonym for <code class="docutils literal notranslate"><span class="pre">DIMENSION</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VIRTUAL</span></code> as synonym for <code class="docutils literal notranslate"><span class="pre">DIMENSION</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENCODE</span></code> and <code class="docutils literal notranslate"><span class="pre">DECODE</span></code> as synonyms for internal I/O</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IMPLICIT</span> <span class="pre">AUTOMATIC</span></code>, <code class="docutils literal notranslate"><span class="pre">IMPLICIT</span> <span class="pre">STATIC</span></code></p></li>
<li><p>Default exponent of zero, e.g. <code class="docutils literal notranslate"><span class="pre">3.14159E</span></code></p></li>
<li><p>Characters in defined operators that are neither letters nor digits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">B</span></code> suffix on unquoted octal constants</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Z</span></code> prefix on unquoted hexadecimal constants (dangerous)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">F</span></code> as abbreviations for <code class="docutils literal notranslate"><span class="pre">.TRUE.</span></code> and <code class="docutils literal notranslate"><span class="pre">.FALSE.</span></code> in DATA (PGI/XLF)</p></li>
<li><p>Use of host FORMAT labels in internal subprograms (PGI-only feature)</p></li>
<li><p>ALLOCATE(TYPE(derived)::…) as variant of correct ALLOCATE(derived::…) (PGI only)</p></li>
<li><p>Defining an explicit interface for a subprogram within itself (PGI only)</p></li>
<li><p>USE association of a procedure interface within that same procedure’s definition</p></li>
<li><p>NULL() as a structure constructor expression for an ALLOCATABLE component (PGI).</p></li>
<li><p>Conversion of LOGICAL to INTEGER in expressions.</p></li>
<li><p>Use of INTEGER data with the intrinsic logical operators <code class="docutils literal notranslate"><span class="pre">.NOT.</span></code>, <code class="docutils literal notranslate"><span class="pre">.AND.</span></code>, <code class="docutils literal notranslate"><span class="pre">.OR.</span></code>,
and <code class="docutils literal notranslate"><span class="pre">.XOR.</span></code>.</p></li>
<li><p>IF (integer expression) THEN … END IF  (PGI/Intel)</p></li>
<li><p>Comparison of LOGICAL with ==/.EQ. rather than .EQV. (also .NEQV.) (PGI/Intel)</p></li>
<li><p>Procedure pointers in COMMON blocks (PGI/Intel)</p></li>
<li><p>Underindexing multi-dimensional arrays (e.g., A(1) rather than A(1,1)) (PGI only)</p></li>
<li><p>Legacy PGI <code class="docutils literal notranslate"><span class="pre">NCHARACTER</span></code> type and <code class="docutils literal notranslate"><span class="pre">NC</span></code> Kanji character literals</p></li>
<li><p>Using non-integer expressions for array bounds (e.g., REAL A(3.14159)) (PGI/Intel)</p></li>
<li><p>Mixing INTEGER types as operands to bit intrinsics (e.g., IAND); only two
compilers support it, and they disagree on sign extension.</p></li>
<li><p>Module &amp; program names that conflict with an object inside the unit (PGI only).</p></li>
<li><p>When the same name is brought into scope via USE association from
multiple modules, the name must refer to a generic interface; PGI
allows a name to be a procedure from one module and a generic interface
from another.</p></li>
<li><p>Type parameter declarations must come first in a derived type definition;
some compilers allow them to follow <code class="docutils literal notranslate"><span class="pre">PRIVATE</span></code>, or be intermixed with the
component declarations.</p></li>
<li><p>Wrong argument types in calls to specific intrinsics that have different names than the
related generics. Some accepted exceptions are listed above in the allowed extensions.
PGI, Intel, and XLF support this in ways that are not numerically equivalent.
PGI converts the arguments while Intel and XLF replace the specific by the related generic.</p></li>
<li><p>VMS listing control directives (<code class="docutils literal notranslate"><span class="pre">%LIST</span></code>, <code class="docutils literal notranslate"><span class="pre">%NOLIST</span></code>, <code class="docutils literal notranslate"><span class="pre">%EJECT</span></code>)</p></li>
<li><p>Continuation lines on <code class="docutils literal notranslate"><span class="pre">INCLUDE</span></code> lines</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NULL()</span></code> actual argument corresponding to an <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> dummy data object</p></li>
<li><p>User (non-intrinsic) <code class="docutils literal notranslate"><span class="pre">ELEMENTAL</span></code> procedures may not be passed as actual
arguments, in accordance with the standard; some Fortran compilers
permit such usage.</p></li>
<li><p>Constraint C1406, which prohibits the same module name from being used
in a scope for both an intrinsic and a non-intrinsic module, is implemented
as a portability warning only, not a hard error.</p></li>
<li><p>IBM &#64;PROCESS directive is accepted but ignored.</p></li>
</ul>
</section>
</section>
<section id="preprocessing-behavior">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">Preprocessing behavior</a><a class="headerlink" href="#preprocessing-behavior" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p>The preprocessor is always run, whatever the filename extension may be.</p></li>
<li><p>We respect Fortran comments in macro actual arguments (like GNU, Intel, NAG;
unlike PGI and XLF) on the principle that macro calls should be treated
like function references.  Fortran’s line continuation methods also work.</p></li>
</ul>
</section>
<section id="standard-features-not-silently-accepted">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">Standard features not silently accepted</a><a class="headerlink" href="#standard-features-not-silently-accepted" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p>Fortran explicitly ignores type declaration statements when they
attempt to type the name of a generic intrinsic function (8.2 p3).
One can declare <code class="docutils literal notranslate"><span class="pre">CHARACTER::COS</span></code> and still get a real result
from <code class="docutils literal notranslate"><span class="pre">COS(3.14159)</span></code>, for example.  f18 will complain when a
generic intrinsic function’s inferred result type does not
match an explicit declaration.  This message is a warning.</p></li>
</ul>
</section>
<section id="standard-features-that-might-as-well-not-be">
<h2><a class="toc-backref" href="#id7" role="doc-backlink">Standard features that might as well not be</a><a class="headerlink" href="#standard-features-that-might-as-well-not-be" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p>f18 supports designators with constant expressions, properly
constrained, as initial data targets for data pointers in
initializers of variable and component declarations and in
<code class="docutils literal notranslate"><span class="pre">DATA</span></code> statements; e.g., <code class="docutils literal notranslate"><span class="pre">REAL,</span> <span class="pre">POINTER</span> <span class="pre">::</span> <span class="pre">P</span> <span class="pre">=&gt;</span> <span class="pre">T(1:10:2)</span></code>.
This Fortran 2008 feature might as well be viewed like an
extension; no other compiler that we’ve tested can handle
it yet.</p></li>
<li><p>According to 11.1.3.3p1, if a selector of an <code class="docutils literal notranslate"><span class="pre">ASSOCIATE</span></code> or
related construct is defined by a variable, it has the <code class="docutils literal notranslate"><span class="pre">TARGET</span></code>
attribute if the variable was a <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> or <code class="docutils literal notranslate"><span class="pre">TARGET</span></code>.
We read this to include the case of the variable being a
pointer-valued function reference.
No other Fortran compiler seems to handle this correctly for
<code class="docutils literal notranslate"><span class="pre">ASSOCIATE</span></code>, though NAG gets it right for <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">TYPE</span></code>.</p></li>
<li><p>The standard doesn’t explicitly require that a named constant that
appears as part of a complex-literal-constant be a scalar, but
most compilers emit an error when an array appears.
f18 supports them with a portability warning.</p></li>
<li><p>f18 does not enforce a blanket prohibition against generic
interfaces containing a mixture of functions and subroutines.
Apart from some contexts in which the standard requires all of
a particular generic interface to have only all functions or
all subroutines as its specific procedures, we allow both to
appear, unlike several other Fortran compilers.
This is especially desirable when two generics of the same
name are combined due to USE association and the mixture may
be inadvertent.</p></li>
<li><p>Since Fortran 90, <code class="docutils literal notranslate"><span class="pre">INCLUDE</span></code> lines have been allowed to have
a numeric kind parameter prefix on the file name.  No other
Fortran compiler supports them that I can find.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">SEQUENCE</span></code> derived type is required (F’2023 C745) to have
at least one component.  No compiler enforces this constraint;
this compiler emits a warning.</p></li>
<li><p>Many compilers disallow a <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> assumed-length character dummy
argument, which has been standard since F’2008.
We accept this usage with an optional portability warning.</p></li>
</ul>
</section>
<section id="behavior-in-cases-where-the-standard-is-ambiguous-or-indefinite">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">Behavior in cases where the standard is ambiguous or indefinite</a><a class="headerlink" href="#behavior-in-cases-where-the-standard-is-ambiguous-or-indefinite" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p>When an inner procedure of a subprogram uses the value or an attribute
of an undeclared name in a specification expression and that name does
not appear in the host, it is not clear in the standard whether that
name is an implicitly typed local variable of the inner procedure or a
host association with an implicitly typed local variable of the host.
For example:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>module module
 contains
  subroutine host(j)
    ! Although &quot;m&quot; never appears in the specification or executable
    ! parts of this subroutine, both of its contained subroutines
    ! might be accessing it via host association.
    integer, intent(in out) :: j
    call inner1(j)
    call inner2(j)
   contains
    subroutine inner1(n)
      integer(kind(m)), intent(in) :: n
      m = n + 1
    end subroutine
    subroutine inner2(n)
      integer(kind(m)), intent(out) :: n
      n = m + 2
    end subroutine
  end subroutine
end module

program demo
  use module
  integer :: k
  k = 0
  call host(k)
  print *, k, &quot; should be 3&quot;
end

</pre></div>
</div>
<p>Other Fortran compilers disagree in their interpretations of this example;
some seem to treat the references to <code class="docutils literal notranslate"><span class="pre">m</span></code> as if they were host associations
to an implicitly typed variable (and print <code class="docutils literal notranslate"><span class="pre">3</span></code>), while others seem to
treat them as references to implicitly typed local variables, and
load uninitialized values.</p>
<p>In f18, we chose to emit an error message for this case since the standard
is unclear, the usage is not portable, and the issue can be easily resolved
by adding a declaration.</p>
<ul class="simple">
<li><p>In subclause 7.5.6.2 of Fortran 2018 the standard defines a partial ordering
of the final subroutine calls for finalizable objects, their non-parent
components, and then their parent components.
(The object is finalized, then the non-parent components of each element,
and then the parent component.)
Some have argued that the standard permits an implementation
to finalize the parent component before finalizing an allocatable component in
the context of deallocation, and the next revision of the language may codify
this option.
In the interest of avoiding needless confusion, this compiler implements what
we believe to be the least surprising order of finalization.
Specifically: all non-parent components are finalized before
the parent, allocatable or not;
all finalization takes place before any deallocation;
and no object or subobject will be finalized more than once.</p></li>
<li><p>When <code class="docutils literal notranslate"><span class="pre">RECL=</span></code> is set via the <code class="docutils literal notranslate"><span class="pre">OPEN</span></code> statement for a sequential formatted input
file, it functions as an effective maximum record length.
Longer records, if any, will appear as if they had been truncated to
the value of <code class="docutils literal notranslate"><span class="pre">RECL=</span></code>.
(Other compilers ignore <code class="docutils literal notranslate"><span class="pre">RECL=</span></code>, signal an error, or apply effective truncation
to some forms of input in this situation.)
For sequential formatted output, RECL= serves as a limit on record lengths
that raises an error when it is exceeded.</p></li>
<li><p>When a <code class="docutils literal notranslate"><span class="pre">DATA</span></code> statement in a <code class="docutils literal notranslate"><span class="pre">BLOCK</span></code> construct could be construed as
either initializing a host-associated object or declaring a new local
initialized object, f18 interprets the standard’s classification of
a <code class="docutils literal notranslate"><span class="pre">DATA</span></code> statement as being a “declaration” rather than a “specification”
construct, and notes that the <code class="docutils literal notranslate"><span class="pre">BLOCK</span></code> construct is defined as localizing
names that have specifications in the <code class="docutils literal notranslate"><span class="pre">BLOCK</span></code> construct.
So this example will elicit an error about multiple initialization:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">subroutine</span> <span class="n">subr</span>
  <span class="n">integer</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">block</span>
    <span class="n">data</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span>
  <span class="n">end</span> <span class="n">block</span>
<span class="n">end</span> <span class="n">subroutine</span>
</pre></div>
</div>
<p>Other Fortran compilers disagree with each other in their interpretations
of this example.
The precedent among the most commonly used compilers
agrees with f18’s interpretation: a <code class="docutils literal notranslate"><span class="pre">DATA</span></code> statement without any other
specification of the name refers to the host-associated object.</p>
<ul class="simple">
<li><p>Many Fortran compilers allow a non-generic procedure to be <code class="docutils literal notranslate"><span class="pre">USE</span></code>-associated
into a scope that also contains a generic interface of the same name
but does not have the <code class="docutils literal notranslate"><span class="pre">USE</span></code>-associated non-generic procedure as a
specific procedure.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">m1</span>
 <span class="n">contains</span>
  <span class="n">subroutine</span> <span class="n">foo</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">integer</span><span class="p">,</span> <span class="n">intent</span><span class="p">(</span><span class="ow">in</span><span class="p">)</span> <span class="p">::</span> <span class="n">n</span>
  <span class="n">end</span> <span class="n">subroutine</span>
<span class="n">end</span> <span class="n">module</span>

<span class="n">module</span> <span class="n">m2</span>
  <span class="n">use</span> <span class="n">m1</span><span class="p">,</span> <span class="n">only</span><span class="p">:</span> <span class="n">foo</span>
  <span class="n">interface</span> <span class="n">foo</span>
    <span class="n">module</span> <span class="n">procedure</span> <span class="n">noargs</span>
  <span class="n">end</span> <span class="n">interface</span>
 <span class="n">contains</span>
  <span class="n">subroutine</span> <span class="n">noargs</span>
  <span class="n">end</span> <span class="n">subroutine</span>
<span class="n">end</span> <span class="n">module</span>
</pre></div>
</div>
<p>This case elicits a warning from f18, as it should not be treated
any differently than the same case with the non-generic procedure of
the same name being defined in the same scope rather than being
<code class="docutils literal notranslate"><span class="pre">USE</span></code>-associated into it, which is explicitly non-conforming in the
standard and not allowed by most other compilers.
If the <code class="docutils literal notranslate"><span class="pre">USE</span></code>-associated entity of the same name is not a procedure,
most compilers disallow it as well.</p>
<ul class="simple">
<li><p>Fortran 2018 19.3.4p1: “A component name has the scope of its derived-type
definition.  Outside the type definition, it may also appear …” which
seems to imply that within its derived-type definition, a component
name is in its scope, and at least shadows any entity of the same name
in the enclosing scope and might be read, thanks to the “also”, to mean
that a “bare” reference to the name could be used in a specification inquiry.
However, most other compilers do not allow a component to shadow exterior
symbols, much less appear in specification inquiries, and there are
application codes that expect exterior symbols whose names match
components to be visible in a derived-type definition’s default initialization
expressions, and so f18 follows that precedent.</p></li>
<li><p>19.3.1p1 “Within its scope, a local identifier of an entity of class (1)
or class (4) shall not be the same as a global identifier used in that scope…”
is read so as to allow the name of a module, submodule, main program,
or <code class="docutils literal notranslate"><span class="pre">BLOCK</span> <span class="pre">DATA</span></code> subprogram to also be the name of an local entity in its
scope, with a portability warning, since that global name is not actually
capable of being “used” in its scope.</p></li>
<li><p>In the definition of the <code class="docutils literal notranslate"><span class="pre">ASSOCIATED</span></code> intrinsic function (16.9.16), its optional
second argument <code class="docutils literal notranslate"><span class="pre">TARGET=</span></code> is required to be “allowable as the data-target or
proc-target in a pointer assignment statement (10.2.2) in which POINTER is
data-pointer-object or proc-pointer-object.”  Some Fortran compilers
interpret this to require that the first argument (<code class="docutils literal notranslate"><span class="pre">POINTER=</span></code>) be a valid
left-hand side for a pointer assignment statement – in particular, it
cannot be <code class="docutils literal notranslate"><span class="pre">NULL()</span></code>, but also it is required to be modifiable.
As there is  no good reason to disallow (say) an <code class="docutils literal notranslate"><span class="pre">INTENT(IN)</span></code> pointer here,
or even <code class="docutils literal notranslate"><span class="pre">NULL()</span></code> as a well-defined case that is always <code class="docutils literal notranslate"><span class="pre">.FALSE.</span></code>,
this compiler doesn’t require the <code class="docutils literal notranslate"><span class="pre">POINTER=</span></code> argument to be a valid
left-hand side for a pointer assignment statement, and we emit a
portability warning when it is not.</p></li>
<li><p>F18 allows a <code class="docutils literal notranslate"><span class="pre">USE</span></code> statement to reference a module that is defined later
in the same compilation unit, so long as mutual dependencies do not form
a cycle.
This feature forestalls any risk of such a <code class="docutils literal notranslate"><span class="pre">USE</span></code> statement reading an
obsolete module file from a previous compilation and then overwriting
that file later.</p></li>
<li><p>F18 allows <code class="docutils literal notranslate"><span class="pre">OPTIONAL</span></code> dummy arguments to interoperable procedures
unless they are <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> (C865).</p></li>
<li><p>F18 processes the <code class="docutils literal notranslate"><span class="pre">NAMELIST</span></code> group declarations in a scope after it
has resolved all of the names in that scope.  This means that names
that appear before their local declarations do not resolve to host
associated objects and do not elicit errors about improper redeclarations
of implicitly typed entities.</p></li>
<li><p>Standard Fortran allows forward references to derived types, which
can lead to ambiguity when combined with host association.
Some Fortran compilers resolve the type name to the host type,
others to the forward-referenced local type; this compiler diagnoses
an error.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">m</span>
  <span class="nb">type</span> <span class="n">ambiguous</span><span class="p">;</span> <span class="n">integer</span> <span class="n">n</span><span class="p">;</span> <span class="n">end</span> <span class="nb">type</span>
 <span class="n">contains</span>
  <span class="n">subroutine</span> <span class="n">s</span>
    <span class="nb">type</span><span class="p">(</span><span class="n">ambiguous</span><span class="p">),</span> <span class="n">pointer</span> <span class="p">::</span> <span class="n">ptr</span>
    <span class="nb">type</span> <span class="n">ambiguous</span><span class="p">;</span> <span class="n">real</span> <span class="n">a</span><span class="p">;</span> <span class="n">end</span> <span class="nb">type</span>
  <span class="n">end</span>
<span class="n">end</span>
</pre></div>
</div>
<ul class="simple">
<li><p>When an intrinsic procedure appears in the specification part of a module
only in function references, but not an explicit <code class="docutils literal notranslate"><span class="pre">INTRINSIC</span></code> statement,
its name is not brought into other scopes by a <code class="docutils literal notranslate"><span class="pre">USE</span></code> statement.</p></li>
<li><p>The subclause on rounding in formatted I/O (13.7.2.3.8 in F’2023)
only discusses rounding for decimal-to/from-binary conversions,
omitting any mention of rounding for hexadecimal conversions.
As other compilers do apply rounding, so does this one.</p></li>
<li><p>For real <code class="docutils literal notranslate"><span class="pre">MAXVAL</span></code>, <code class="docutils literal notranslate"><span class="pre">MINVAL</span></code>, <code class="docutils literal notranslate"><span class="pre">MAXLOC</span></code>, and <code class="docutils literal notranslate"><span class="pre">MINLOC</span></code>, NaN values are
essentially ignored unless there are some unmasked array entries and
<em>all</em> of them are NaNs.</p></li>
</ul>
</section>
<section id="de-facto-standard-features">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">De Facto Standard Features</a><a class="headerlink" href="#de-facto-standard-features" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">EXTENDS_TYPE_OF()</span></code> returns <code class="docutils literal notranslate"><span class="pre">.TRUE.</span></code> if both of its arguments have the
same type, a case that is technically implementation-defined.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENCODING=</span></code> is not in the list of changeable modes on an I/O unit,
but every Fortran compiler allows the encoding to be changed on an
open unit.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">NAMELIST</span></code> input item that references a scalar element of a vector
or contiguous array can be used as the initial element of a storage
sequence.  For example, “&amp;GRP A(1)=1. 2. 3./” is treated as if had been
“&amp;GRP A(1:)=1. 2. 3./”.</p></li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="F202X.html" title="A first take on Fortran 202X features for LLVM Flang"
             >next</a> |</li>
        <li class="right" >
          <a href="DoConcurrent.html" title="DO CONCURRENT isn’t necessarily concurrent"
             >previous</a> |</li>
<! TODO: Change the webpage  >
  <li><a href="https://flang.llvm.org">Flang Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

        <li class="nav-item nav-item-this"><a href="">Fortran Extensions supported by Flang</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2017-2024, The Flang Team.
      Last updated on Jun 19, 2024.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.1.2.
    </div>
  </body>
</html>