

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>FIR Language Reference &#8212; The Flang Compiler</title>
    <link rel="stylesheet" href="_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/llvm.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Flang command line argument reference" href="FlangCommandLineReference.html" />
    <link rel="prev" title="Fortran Extensions supported by Flang" href="Extensions.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="FlangCommandLineReference.html" title="Flang command line argument reference"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Extensions.html" title="Fortran Extensions supported by Flang"
             accesskey="P">previous</a> |</li>
<! TODO: Change the webpage  >
  <li><a href="https://flang.llvm.org">Flang Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://github.com/llvm/llvm-project/blob/main/flang/README.md#getting-started">Getting Started</a></li>
</ul>

<h3>Getting Involved</h3>
<! TODO: Point links to website(flang.llvm.org) and not github once webpage comes up.>
<ul class="want-points">
    <li><a href="https://github.com/llvm/llvm-project/blob/main/flang/docs/GettingInvolved.md#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://github.com/llvm/llvm-project/blob/main/flang/docs/GettingInvolved.md#chat">Slack</a></li>
    <li><a href="https://github.com/llvm/llvm-project/blob/main/flang/docs/GettingInvolved.md#calls">Calls</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://github.com/llvm/llvm-project/tree/main/flang/">Github Repository</a></li>
    <li><a href="https://bugs.llvm.org/">Bug Reports</a></li>
    <li><a href="https://reviews.llvm.org/">Code Review</a></li>
<! TODO: Have the bots setup first>
    <li><a href="#">Doxygen API</a></li>
</ul>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <!-- Autogenerated by mlir-tblgen; don't manually edit --><div class="section" id="fir-language-reference">
<h1>FIR Language Reference<a class="headerlink" href="#fir-language-reference" title="Permalink to this headline">¶</a></h1>
<p>This page contains an overview of the Fortran IR operations, their syntax, and example usages.</p>
<div class="section" id="fir-absent-fir-absentop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.absent</span></code> (::fir::AbsentOp)<a class="headerlink" href="#fir-absent-fir-absentop" title="Permalink to this headline">¶</a></h2>
<p>create value to be passed for absent optional function argument</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.absent` type($intype) attr-dict
</pre></div>
</div>
<p>Given the type of a function argument, create a value that will signal that
an optional argument is absent in the call. On the caller side, fir.is_present
can be used to query if the value of an optional argument was created with
a fir.absent operation.
It is undefined to use a value that was created by a fir.absent op in any other
operation than fir.call and fir.is_present.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %1 = fir.absent fir.box&lt;fir.array&lt;?xf32&gt;&gt;
  fir.call @_QPfoo(%1) : (fir.box&lt;fir.array&lt;?xf32&gt;&gt;) -&gt; ()
</pre></div>
</div>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="results">
<h3>Results:<a class="headerlink" href="#results" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>intype</code></td>
<td>any reference or box like</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-addc-fir-addcop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.addc</span></code> (::fir::AddcOp)<a class="headerlink" href="#fir-addc-fir-addcop" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.addc` operands attr-dict `:` type($result)
</pre></div>
</div>
<p>Traits: Commutative, SameOperandsAndResultType</p>
<p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="operands">
<h3>Operands:<a class="headerlink" href="#operands" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>lhs</code></td>
<td>Complex type</td>
</tr>
<tr>
<td align="center"><code>rhs</code></td>
<td>Complex type</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id1">
<h3>Results:<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-address-of-fir-addrofop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.address_of</span></code> (::fir::AddrOfOp)<a class="headerlink" href="#fir-address-of-fir-addrofop" title="Permalink to this headline">¶</a></h2>
<p>convert a symbol to an SSA value</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.address_of` `(` $symbol `)` attr-dict `:` type($resTy)
</pre></div>
</div>
<p>Convert a symbol (a function or global reference) to an SSA-value to be
used in other Operations. References to Fortran symbols are distinguished
via this operation from other arbitrary constant values.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %p = fir.address_of(@symbol) : !fir.ref&lt;f64&gt;
</pre></div>
</div>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="attributes">
<h3>Attributes:<a class="headerlink" href="#attributes" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Attribute</th>
<th align="center">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>symbol</code></td>
<td align="center">::mlir::SymbolRefAttr</td>
<td>symbol reference attribute</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id2">
<h3>Results:<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>resTy</code></td>
<td>any addressable</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-allocmem-fir-allocmemop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.allocmem</span></code> (::fir::AllocMemOp)<a class="headerlink" href="#fir-allocmem-fir-allocmemop" title="Permalink to this headline">¶</a></h2>
<p>allocate storage on the heap for an object of a given type</p>
<p>Creates a heap memory reference suitable for storing a value of the
given type, T.  The heap refernce returned has type <code class="docutils literal notranslate"><span class="pre">!fir.heap&lt;T&gt;</span></code>.
The memory object is in an undefined state.  <code class="docutils literal notranslate"><span class="pre">allocmem</span></code> operations must
be paired with <code class="docutils literal notranslate"><span class="pre">freemem</span></code> operations to avoid memory leaks.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %0 = fir.allocmem !fir.array&lt;10 x f32&gt;
  fir.freemem %0 : !fir.heap&lt;!fir.array&lt;10 x f32&gt;&gt;
</pre></div>
</div>
<p>Traits: AttrSizedOperandSegments</p>
<p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}</p>
<div class="section" id="id3">
<h3>Attributes:<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Attribute</th>
<th align="center">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>in_type</code></td>
<td align="center">::mlir::TypeAttr</td>
<td>any type attribute</td>
</tr>
<tr>
<td align="center"><code>uniq_name</code></td>
<td align="center">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
<tr>
<td align="center"><code>bindc_name</code></td>
<td align="center">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id4">
<h3>Operands:<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>typeparams</code></td>
<td>any integer</td>
</tr>
<tr>
<td align="center"><code>shape</code></td>
<td>any integer</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id5">
<h3>Results:<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>Reference to an ALLOCATABLE attribute type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-alloca-fir-allocaop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.alloca</span></code> (::fir::AllocaOp)<a class="headerlink" href="#fir-alloca-fir-allocaop" title="Permalink to this headline">¶</a></h2>
<p>allocate storage for a temporary on the stack given a type</p>
<p>This primitive operation is used to allocate an object on the stack.  A
reference to the object of type <code class="docutils literal notranslate"><span class="pre">!fir.ref&lt;T&gt;</span></code> is returned.  The returned
object has an undefined/uninitialized state.  The allocation can be given
an optional name.  The allocation may have a dynamic repetition count
for allocating a sequence of locations for the specified type.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %c = ... : i64
  %x = fir.alloca i32
  %y = fir.alloca !fir.array&lt;8 x i64&gt;
  %z = fir.alloca f32, %c

  %i = ... : i16
  %j = ... : i32
  %w = fir.alloca !fir.type&lt;PT(len1:i16, len2:i32)&gt; (%i, %j : i16, i32)
</pre></div>
</div>
<p>Note that in the case of <code class="docutils literal notranslate"><span class="pre">%z</span></code>, a contiguous block of memory is allocated
and its size is a runtime multiple of a 32-bit REAL value.</p>
<p>In the case of <code class="docutils literal notranslate"><span class="pre">%w</span></code>, the arguments <code class="docutils literal notranslate"><span class="pre">%i</span></code> and <code class="docutils literal notranslate"><span class="pre">%j</span></code> are LEN parameters
(<code class="docutils literal notranslate"><span class="pre">len1</span></code>, <code class="docutils literal notranslate"><span class="pre">len2</span></code>) to the type <code class="docutils literal notranslate"><span class="pre">PT</span></code>.</p>
<p>Finally, the operation is undefined if the ssa-value <code class="docutils literal notranslate"><span class="pre">%c</span></code> is negative.</p>
<p>Fortran Semantics:
There is no language mechanism in Fortran to allocate space on the stack
like C’s <code class="docutils literal notranslate"><span class="pre">alloca()</span></code> function. Therefore fir.alloca is not control-flow
dependent. However, the lifetime of a stack allocation is often limited to
a small region and a legal implementation may reuse stack storage in other
regions when there is no conflict. For example, take the following code
fragment.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span>  <span class="k">CALL </span><span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">CALL </span><span class="n">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
  <span class="k">CALL </span><span class="n">foo</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>A legal implementation can allocate a stack slot and initialize it with the
constant <code class="docutils literal notranslate"><span class="pre">1</span></code>, then pass that by reference to foo. Likewise for the second
and third calls to foo, each stack slot being initialized accordingly. It is
also a conforming implementation to reuse the same stack slot for all three
calls, just initializing each in turn. This is possible  as the lifetime of
the copy of each constant need not exceed that of the CALL statement.
Indeed, a user would likely expect a good Fortran compiler to perform such
an optimization.</p>
<p>Until Fortran 2018, procedures defaulted to non-recursive. A legal
implementation could therefore convert stack allocations to global
allocations. Such a conversion effectively adds the SAVE attribute to all
variables.</p>
<p>Some temporary entities (large arrays) probably should not be stack
allocated as stack space can often be limited. A legal implementation can
convert these large stack allocations to heap allocations regardless of
whether the procedure is recursive or not.</p>
<p>The pinned attribute is used to flag fir.alloca operation in a specific
region and avoid them being hoisted in an alloca hoisting pass.</p>
<p>Traits: AttrSizedOperandSegments</p>
<p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::AutomaticAllocationScopeResource}</p>
<div class="section" id="id6">
<h3>Attributes:<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Attribute</th>
<th align="center">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>in_type</code></td>
<td align="center">::mlir::TypeAttr</td>
<td>any type attribute</td>
</tr>
<tr>
<td align="center"><code>uniq_name</code></td>
<td align="center">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
<tr>
<td align="center"><code>bindc_name</code></td>
<td align="center">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
<tr>
<td align="center"><code>pinned</code></td>
<td align="center">::mlir::UnitAttr</td>
<td>unit attribute</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id7">
<h3>Operands:<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>typeparams</code></td>
<td>any integer</td>
</tr>
<tr>
<td align="center"><code>shape</code></td>
<td>any integer</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id8">
<h3>Results:<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>Reference to an entity type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-array-access-fir-arrayaccessop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.array_access</span></code> (::fir::ArrayAccessOp)<a class="headerlink" href="#fir-array-access-fir-arrayaccessop" title="Permalink to this headline">¶</a></h2>
<p>Fetch the reference of an element of an array value</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.array_access` $sequence `,` $indices (`typeparams` $typeparams^)? attr-dict `:`
              functional-type(operands, results)
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">array_access</span></code> provides a reference to a single element from an array
value. This is <em>not</em> a view in the immutable array, otherwise it couldn’t
be stored to. It can be see as a logical copy of the element and its
position in the array. This reference can be written to and modified without
changing the original array.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">array_access</span></code> operation is used to fetch the memory reference of an
element in an array value.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span>  <span class="kt">real</span> <span class="kd">::</span> <span class="n">a</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
  <span class="p">...</span>
  <span class="p">...</span> <span class="n">a</span> <span class="p">...</span>
  <span class="p">...</span> <span class="n">a</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">...</span>
</pre></div>
</div>
<p>One can use <code class="docutils literal notranslate"><span class="pre">fir.array_access</span></code> to recover the implied memory reference to
the element <code class="docutils literal notranslate"><span class="pre">a(i,j)</span></code> in an array expression <code class="docutils literal notranslate"><span class="pre">a</span></code> as shown above. It can also
be used to recover the reference element <code class="docutils literal notranslate"><span class="pre">a(r,s+1)</span></code> in the second
expression.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %s = fir.shape %n, %m : (index, index) -&gt; !fir.shape&lt;2&gt;
  // load the entire array &#39;a&#39;
  %v = fir.array_load %a(%s) : (!fir.ref&lt;!fir.array&lt;?x?xf32&gt;&gt;, !fir.shape&lt;2&gt;) -&gt; !fir.array&lt;?x?xf32&gt;
  // fetch the value of one of the array value&#39;s elements
  %1 = fir.array_access %v, %i, %j : (!fir.array&lt;?x?xf32&gt;, index, index) -&gt; !fir.ref&lt;f32&gt;
</pre></div>
</div>
<p>It is only possible to use <code class="docutils literal notranslate"><span class="pre">array_access</span></code> on an <code class="docutils literal notranslate"><span class="pre">array_load</span></code> result value or
a value that can be trace back transitively to an <code class="docutils literal notranslate"><span class="pre">array_load</span></code> as the
dominating source. Other array operation such as <code class="docutils literal notranslate"><span class="pre">array_amend</span></code> can be in
between.</p>
<p>TODO: The above restriction is not enforced. The design of the operation
might need to be revisited to avoid such restructions.</p>
<p>More information about <code class="docutils literal notranslate"><span class="pre">array_access</span></code> and other array operations can be
found in flang/docs/FIRArrayOperations.md.</p>
<p>Traits: AttrSizedOperandSegments</p>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id9">
<h3>Operands:<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>sequence</code></td>
<td>FIR array type</td>
</tr>
<tr>
<td align="center"><code>indices</code></td>
<td>coordinate type</td>
</tr>
<tr>
<td align="center"><code>typeparams</code></td>
<td>any integer</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id10">
<h3>Results:<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>element</code></td>
<td>Reference to an entity type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-array-amend-fir-arrayamendop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.array_amend</span></code> (::fir::ArrayAmendOp)<a class="headerlink" href="#fir-array-amend-fir-arrayamendop" title="Permalink to this headline">¶</a></h2>
<p>Mark an array value as having been changed by reference.</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.array_amend` $sequence `,` $memref attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">array_amend</span></code> operation marks an array value as having been changed via
a reference obtained by an <code class="docutils literal notranslate"><span class="pre">array_access</span></code>. It acts as a logical transaction
log that is used to merge the final result back with an <code class="docutils literal notranslate"><span class="pre">array_merge_store</span></code>
operation.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  // fetch the value of one of the array value&#39;s elements
  %1 = fir.array_access %v, %i, %j : (!fir.array&lt;?x?xT&gt;, index, index) -&gt; !fir.ref&lt;T&gt;
  // modify the element by storing data using %1 as a reference
  %2 = ... %1 ...
  // mark the array value
  %new_v = fir.array_amend %v, %2 : (!fir.array&lt;?x?xT&gt;, !fir.ref&lt;T&gt;) -&gt; !fir.array&lt;?x?xT&gt;
</pre></div>
</div>
<p>More information about <code class="docutils literal notranslate"><span class="pre">array_amend</span></code> and other array operations can be
found in flang/docs/FIRArrayOperations.md.</p>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id11">
<h3>Operands:<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>sequence</code></td>
<td>FIR array type</td>
</tr>
<tr>
<td align="center"><code>memref</code></td>
<td>Reference to an entity type</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id12">
<h3>Results:<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>FIR array type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-array-coor-fir-arraycoorop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.array_coor</span></code> (::fir::ArrayCoorOp)<a class="headerlink" href="#fir-array-coor-fir-arraycoorop" title="Permalink to this headline">¶</a></h2>
<p>Find the coordinate of an element of an array</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.array_coor` $memref (`(`$shape^`)`)? (`[`$slice^`]`)? $indices (`typeparams`
              $typeparams^)? attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Compute the location of an element in an array when the shape of the
array is only known at runtime.</p>
<p>This operation is intended to capture all the runtime values needed to
compute the address of an array reference in a single high-level op. Given
the following Fortran input:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span>  <span class="kt">real</span> <span class="kd">::</span> <span class="n">a</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
  <span class="p">...</span>
  <span class="p">...</span> <span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="p">...</span>
</pre></div>
</div>
<p>One can use <code class="docutils literal notranslate"><span class="pre">fir.array_coor</span></code> to determine the address of <code class="docutils literal notranslate"><span class="pre">a(i,j)</span></code>.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %s = fir.shape %n, %m : (index, index) -&gt; !fir.shape&lt;2&gt;
  %1 = fir.array_coor %a(%s) %i, %j : (!fir.ref&lt;!fir.array&lt;?x?xf32&gt;&gt;, !fir.shape&lt;2&gt;, index, index) -&gt; !fir.ref&lt;f32&gt;
</pre></div>
</div>
<p>Traits: AttrSizedOperandSegments</p>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id13">
<h3>Operands:<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>memref</code></td>
<td>any reference or box</td>
</tr>
<tr>
<td align="center"><code>shape</code></td>
<td>any legal shape or shift type</td>
</tr>
<tr>
<td align="center"><code>slice</code></td>
<td>FIR slice</td>
</tr>
<tr>
<td align="center"><code>indices</code></td>
<td>coordinate type</td>
</tr>
<tr>
<td align="center"><code>typeparams</code></td>
<td>any integer</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id14">
<h3>Results:<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>Reference to an entity type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-array-fetch-fir-arrayfetchop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.array_fetch</span></code> (::fir::ArrayFetchOp)<a class="headerlink" href="#fir-array-fetch-fir-arrayfetchop" title="Permalink to this headline">¶</a></h2>
<p>Fetch the value of an element of an array value</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.array_fetch` $sequence `,` $indices (`typeparams` $typeparams^)? attr-dict `:`
              functional-type(operands, results)
</pre></div>
</div>
<p>Fetch the value of an element in an array value.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span>  <span class="kt">real</span> <span class="kd">::</span> <span class="n">a</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
  <span class="p">...</span>
  <span class="p">...</span> <span class="n">a</span> <span class="p">...</span>
  <span class="p">...</span> <span class="n">a</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">...</span>
</pre></div>
</div>
<p>One can use <code class="docutils literal notranslate"><span class="pre">fir.array_fetch</span></code> to fetch the (implied) value of <code class="docutils literal notranslate"><span class="pre">a(i,j)</span></code> in
an array expression as shown above. It can also be used to extract the
element <code class="docutils literal notranslate"><span class="pre">a(r,s+1)</span></code> in the second expression.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %s = fir.shape %n, %m : (index, index) -&gt; !fir.shape&lt;2&gt;
  // load the entire array &#39;a&#39;
  %v = fir.array_load %a(%s) : (!fir.ref&lt;!fir.array&lt;?x?xf32&gt;&gt;, !fir.shape&lt;2&gt;) -&gt; !fir.array&lt;?x?xf32&gt;
  // fetch the value of one of the array value&#39;s elements
  %1 = fir.array_fetch %v, %i, %j : (!fir.array&lt;?x?xf32&gt;, index, index) -&gt; f32
</pre></div>
</div>
<p>It is only possible to use <code class="docutils literal notranslate"><span class="pre">array_fetch</span></code> on an <code class="docutils literal notranslate"><span class="pre">array_load</span></code> result value.</p>
<p>Traits: AttrSizedOperandSegments</p>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id15">
<h3>Operands:<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>sequence</code></td>
<td>FIR array type</td>
</tr>
<tr>
<td align="center"><code>indices</code></td>
<td>coordinate type</td>
</tr>
<tr>
<td align="center"><code>typeparams</code></td>
<td>any integer</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id16">
<h3>Results:<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>element</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-array-load-fir-arrayloadop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.array_load</span></code> (::fir::ArrayLoadOp)<a class="headerlink" href="#fir-array-load-fir-arrayloadop" title="Permalink to this headline">¶</a></h2>
<p>Load an array as a value.</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.array_load` $memref (`(`$shape^`)`)? (`[`$slice^`]`)? (`typeparams` $typeparams^)?
              attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>This operation taken with array_merge_store captures Fortran’s
copy-in/copy-out semantics. One way to think of this is that array_load
creates a snapshot copy of the entire array. This copy can then be used
as the “original value” of the array while the array’s new value is
computed. The array_merge_store operation is the copy-out semantics, which
merge the updates with the original array value to produce the final array
result. This abstracts the copy operations as opposed to always creating
copies or requiring dependence analysis be performed on the syntax trees
and before lowering to the IR.</p>
<p>Load an entire array as a single SSA value.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span>  <span class="kt">real</span> <span class="kd">::</span> <span class="n">a</span><span class="p">(</span><span class="n">o</span><span class="p">:</span><span class="n">n</span><span class="p">,</span><span class="n">p</span><span class="p">:</span><span class="n">m</span><span class="p">)</span>
  <span class="p">...</span>
  <span class="p">...</span> <span class="o">=</span> <span class="p">...</span> <span class="n">a</span> <span class="p">...</span>
</pre></div>
</div>
<p>One can use <code class="docutils literal notranslate"><span class="pre">fir.array_load</span></code> to produce an ssa-value that captures an
immutable value of the entire array <code class="docutils literal notranslate"><span class="pre">a</span></code>, as in the Fortran array expression
shown above. Subsequent changes to the memory containing the array do not
alter its composite value. This operation let’s one load an array as a
value while applying a runtime shape, shift, or slice to the memory
reference, and its semantics guarantee immutability.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %s = fir.shape_shift %o, %n, %p, %m : (index, index, index, index) -&gt; !fir.shape&lt;2&gt;
  // load the entire array &#39;a&#39;
  %v = fir.array_load %a(%s) : (!fir.ref&lt;!fir.array&lt;?x?xf32&gt;&gt;, !fir.shape&lt;2&gt;) -&gt; !fir.array&lt;?x?xf32&gt;
  // a fir.store here into array %a does not change %v
</pre></div>
</div>
<p>Traits: AttrSizedOperandSegments</p>
<div class="section" id="id17">
<h3>Operands:<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>memref</code></td>
<td>any reference or box</td>
</tr>
<tr>
<td align="center"><code>shape</code></td>
<td>any legal shape or shift type</td>
</tr>
<tr>
<td align="center"><code>slice</code></td>
<td>FIR slice</td>
</tr>
<tr>
<td align="center"><code>typeparams</code></td>
<td>any integer</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id18">
<h3>Results:<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>FIR array type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-array-merge-store-fir-arraymergestoreop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.array_merge_store</span></code> (::fir::ArrayMergeStoreOp)<a class="headerlink" href="#fir-array-merge-store-fir-arraymergestoreop" title="Permalink to this headline">¶</a></h2>
<p>Store merged array value to memory.</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.array_merge_store` $original `,` $sequence `to` $memref (`[` $slice^ `]`)? (`typeparams`
              $typeparams^)? attr-dict `:` type(operands)
</pre></div>
</div>
<p>Store a merged array value to memory.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span>  <span class="kt">real</span> <span class="kd">::</span> <span class="n">a</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
  <span class="p">...</span>
  <span class="n">a</span> <span class="o">=</span> <span class="p">...</span>
</pre></div>
</div>
<p>One can use <code class="docutils literal notranslate"><span class="pre">fir.array_merge_store</span></code> to merge/copy the value of <code class="docutils literal notranslate"><span class="pre">a</span></code> in an
array expression as shown above.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %v = fir.array_load %a(%shape) : ...
  %r = fir.array_update %v, %f, %i, %j : (!fir.array&lt;?x?xf32&gt;, f32, index, index) -&gt; !fir.array&lt;?x?xf32&gt;
  fir.array_merge_store %v, %r to %a : !fir.ref&lt;!fir.array&lt;?x?xf32&gt;&gt;
</pre></div>
</div>
<p>This operation merges the original loaded array value, <code class="docutils literal notranslate"><span class="pre">%v</span></code>, with the
chained updates, <code class="docutils literal notranslate"><span class="pre">%r</span></code>, and stores the result to the array at address, <code class="docutils literal notranslate"><span class="pre">%a</span></code>.</p>
<p>Traits: AttrSizedOperandSegments</p>
<div class="section" id="id19">
<h3>Operands:<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>original</code></td>
<td>FIR array type</td>
</tr>
<tr>
<td align="center"><code>sequence</code></td>
<td>FIR array type</td>
</tr>
<tr>
<td align="center"><code>memref</code></td>
<td>any reference or box</td>
</tr>
<tr>
<td align="center"><code>slice</code></td>
<td>FIR slice</td>
</tr>
<tr>
<td align="center"><code>typeparams</code></td>
<td>any integer</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-array-modify-fir-arraymodifyop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.array_modify</span></code> (::fir::ArrayModifyOp)<a class="headerlink" href="#fir-array-modify-fir-arraymodifyop" title="Permalink to this headline">¶</a></h2>
<p>Get an address for an array value to modify it.</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.array_modify` $sequence `,` $indices (`typeparams` $typeparams^)? attr-dict
              `:` functional-type(operands, results)
</pre></div>
</div>
<p>Modify the value of an element in an array value through actions done
on the returned address. A new array value is also
returned where all element values of the input array are identical except
for the selected element which is the value after the modification done
on the element address.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span>  <span class="kt">real</span> <span class="kd">::</span> <span class="n">a</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="p">...</span>
  <span class="c">! Elemental user defined assignment from type(SomeType) to real.</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">value_of_some_type</span>
</pre></div>
</div>
<p>One can use <code class="docutils literal notranslate"><span class="pre">fir.array_modify</span></code> to update the (implied) value of <code class="docutils literal notranslate"><span class="pre">a(i)</span></code>
in an array expression as shown above.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %s = fir.shape %n : (index) -&gt; !fir.shape&lt;1&gt;
  // Load the entire array &#39;a&#39;.
  %v = fir.array_load %a(%s) : (!fir.ref&lt;!fir.array&lt;?xf32&gt;&gt;, !fir.shape&lt;1&gt;)
      -&gt; !fir.array&lt;?xf32&gt;
  // Update the value of one of the array value&#39;s elements with a user
  // defined assignment from %rhs.
  %new = fir.do_loop %i = ... (%inner = %v) {
    %rhs = ...
    %addr, %r = fir.array_modify %inner, %i, %j : (!fir.array&lt;?xf32&gt;,
 index) -&gt; fir.ref&lt;f32&gt;, !fir.array&lt;?xf32&gt;
    fir.call @user_def_assign(%addr, %rhs) (fir.ref&lt;f32&gt;,
 fir.ref&lt;!fir.type&lt;SomeType&gt;&gt;) -&gt; ()
    fir.result %r : !fir.ref&lt;!fir.array&lt;?xf32&gt;&gt;
  }
  fir.array_merge_store %v, %new to %a : !fir.ref&lt;!fir.array&lt;?xf32&gt;&gt;
</pre></div>
</div>
<p>An array value modification behaves as if a mapping function from the indices
to the new value has been added, replacing the previous mapping. These
mappings can be added to the ssa-value, but will not be materialized in
memory until the <code class="docutils literal notranslate"><span class="pre">fir.array_merge_store</span></code> is performed.</p>
<p>Traits: AttrSizedOperandSegments</p>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id20">
<h3>Operands:<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>sequence</code></td>
<td>FIR array type</td>
</tr>
<tr>
<td align="center"><code>indices</code></td>
<td>coordinate type</td>
</tr>
<tr>
<td align="center"><code>typeparams</code></td>
<td>any integer</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id21">
<h3>Results:<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>Reference to an entity type</td>
</tr>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>FIR array type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-array-update-fir-arrayupdateop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.array_update</span></code> (::fir::ArrayUpdateOp)<a class="headerlink" href="#fir-array-update-fir-arrayupdateop" title="Permalink to this headline">¶</a></h2>
<p>Update the value of an element of an array value</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.array_update` $sequence `,` $merge `,` $indices (`typeparams` $typeparams^)? attr-dict
              `:` functional-type(operands, results)
</pre></div>
</div>
<p>Updates the value of an element in an array value. A new array value is
returned where all element values of the input array are identical except
for the selected element which is the value passed in the update.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span>  <span class="kt">real</span> <span class="kd">::</span> <span class="n">a</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
  <span class="p">...</span>
  <span class="n">a</span> <span class="o">=</span> <span class="p">...</span>
</pre></div>
</div>
<p>One can use <code class="docutils literal notranslate"><span class="pre">fir.array_update</span></code> to update the (implied) value of <code class="docutils literal notranslate"><span class="pre">a(i,j)</span></code>
in an array expression as shown above.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %s = fir.shape %n, %m : (index, index) -&gt; !fir.shape&lt;2&gt;
  // load the entire array &#39;a&#39;
  %v = fir.array_load %a(%s) : (!fir.ref&lt;!fir.array&lt;?x?xf32&gt;&gt;, !fir.shape&lt;2&gt;) -&gt; !fir.array&lt;?x?xf32&gt;
  // update the value of one of the array value&#39;s elements
  // %r_{ij} = %f  if (i,j) = (%i,%j),   %v_{ij} otherwise
  %r = fir.array_update %v, %f, %i, %j : (!fir.array&lt;?x?xf32&gt;, f32, index, index) -&gt; !fir.array&lt;?x?xf32&gt;
  fir.array_merge_store %v, %r to %a : !fir.ref&lt;!fir.array&lt;?x?xf32&gt;&gt;
</pre></div>
</div>
<p>An array value update behaves as if a mapping function from the indices
to the new value has been added, replacing the previous mapping. These
mappings can be added to the ssa-value, but will not be materialized in
memory until the <code class="docutils literal notranslate"><span class="pre">fir.array_merge_store</span></code> is performed.</p>
<p>Traits: AttrSizedOperandSegments</p>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id22">
<h3>Operands:<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>sequence</code></td>
<td>FIR array type</td>
</tr>
<tr>
<td align="center"><code>merge</code></td>
<td>any type</td>
</tr>
<tr>
<td align="center"><code>indices</code></td>
<td>coordinate type</td>
</tr>
<tr>
<td align="center"><code>typeparams</code></td>
<td>any integer</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id23">
<h3>Results:<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>FIR array type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-box-addr-fir-boxaddrop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.box_addr</span></code> (::fir::BoxAddrOp)<a class="headerlink" href="#fir-box-addr-fir-boxaddrop" title="Permalink to this headline">¶</a></h2>
<p>return a memory reference to the boxed value</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.box_addr` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>This operator is overloaded to work with values of type <code class="docutils literal notranslate"><span class="pre">box</span></code>,
<code class="docutils literal notranslate"><span class="pre">boxchar</span></code>, and <code class="docutils literal notranslate"><span class="pre">boxproc</span></code>.  The result for each of these
cases, respectively, is the address of the data, the address of the
<code class="docutils literal notranslate"><span class="pre">CHARACTER</span></code> data, and the address of the procedure.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %51 = fir.box_addr %box : (!fir.box&lt;f64&gt;) -&gt; !fir.ref&lt;f64&gt;
  %52 = fir.box_addr %boxchar : (!fir.boxchar&lt;1&gt;) -&gt; !fir.ref&lt;!fir.char&lt;1&gt;&gt;
  %53 = fir.box_addr %boxproc : (!fir.boxproc&lt;!P&gt;) -&gt; !P
</pre></div>
</div>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id24">
<h3>Operands:<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>val</code></td>
<td>any box</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id25">
<h3>Results:<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>any code or data reference</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-boxchar-len-fir-boxcharlenop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.boxchar_len</span></code> (::fir::BoxCharLenOp)<a class="headerlink" href="#fir-boxchar-len-fir-boxcharlenop" title="Permalink to this headline">¶</a></h2>
<p>return the LEN type parameter from a boxchar value</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.boxchar_len` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Extracts the LEN type parameter from a <code class="docutils literal notranslate"><span class="pre">boxchar</span></code> value.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %45 = ... : !boxchar&lt;1&gt;  // CHARACTER(20)
  %59 = fir.boxchar_len %45 : (!fir.boxchar&lt;1&gt;) -&gt; i64  // len=20
</pre></div>
</div>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id26">
<h3>Operands:<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>val</code></td>
<td>CHARACTER type descriptor.</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id27">
<h3>Results:<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>any integer</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-box-dims-fir-boxdimsop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.box_dims</span></code> (::fir::BoxDimsOp)<a class="headerlink" href="#fir-box-dims-fir-boxdimsop" title="Permalink to this headline">¶</a></h2>
<p>return the dynamic dimension information for the boxed value</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.box_dims` $val `,` $dim attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Returns the triple of lower bound, extent, and stride for <code class="docutils literal notranslate"><span class="pre">dim</span></code> dimension
of <code class="docutils literal notranslate"><span class="pre">val</span></code>, which must have a <code class="docutils literal notranslate"><span class="pre">box</span></code> type.  The dimensions are enumerated from
left to right from 0 to rank-1. This operation has undefined behavior if
<code class="docutils literal notranslate"><span class="pre">dim</span></code> is out of bounds.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %c1   = arith.constant 0 : i32
  %52:3 = fir.box_dims %40, %c1 : (!fir.box&lt;!fir.array&lt;*:f64&gt;&gt;, i32) -&gt; (index, index, index)
</pre></div>
</div>
<p>The above is a request to return the left most row (at index 0) triple from
the box. The triple will be the lower bound, extent, and byte-stride, which
are the values encoded in a standard descriptor.</p>
<p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id28">
<h3>Operands:<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>val</code></td>
<td>The type of a Fortran descriptor</td>
</tr>
<tr>
<td align="center"><code>dim</code></td>
<td>any integer</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id29">
<h3>Results:<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>index</td>
</tr>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>index</td>
</tr>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>index</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-box-elesize-fir-boxelesizeop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.box_elesize</span></code> (::fir::BoxEleSizeOp)<a class="headerlink" href="#fir-box-elesize-fir-boxelesizeop" title="Permalink to this headline">¶</a></h2>
<p>return the size of an element of the boxed value</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.box_elesize` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Returns the size of an element in an entity of <code class="docutils literal notranslate"><span class="pre">box</span></code> type.  This size may
not be known until runtime.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %53 = fir.box_elesize %40 : (!fir.box&lt;f32&gt;, i32) -&gt; i32  // size=4
  %54 = fir.box_elesize %40 : (!fir.box&lt;!fir.array&lt;*:f32&gt;&gt;, i32) -&gt; i32
</pre></div>
</div>
<p>In the above example, <code class="docutils literal notranslate"><span class="pre">%53</span></code> may box an array of REAL values while <code class="docutils literal notranslate"><span class="pre">%54</span></code>
must box an array of REAL values (with dynamic rank and extent).</p>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id30">
<h3>Operands:<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>val</code></td>
<td>The type of a Fortran descriptor</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id31">
<h3>Results:<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>any integer</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-box-isalloc-fir-boxisallocop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.box_isalloc</span></code> (::fir::BoxIsAllocOp)<a class="headerlink" href="#fir-box-isalloc-fir-boxisallocop" title="Permalink to this headline">¶</a></h2>
<p>is the boxed value an ALLOCATABLE?</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.box_isalloc` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Determine if the boxed value was from an ALLOCATABLE entity. This will
return true if the originating box value was from a <code class="docutils literal notranslate"><span class="pre">fir.embox</span></code> op
with a mem-ref value that had the type !fir.heap<T>.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %r = ... : !fir.heap&lt;i64&gt;
  %b = fir.embox %r : (!fir.heap&lt;i64&gt;) -&gt; !fir.box&lt;i64&gt;
  %a = fir.box_isalloc %b : (!fir.box&lt;i64&gt;) -&gt; i1  // true
</pre></div>
</div>
<p>The canonical descriptor implementation will carry a flag to record if the
variable is an <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code>.</p>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id32">
<h3>Operands:<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>val</code></td>
<td>The type of a Fortran descriptor</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id33">
<h3>Results:<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>bool-like</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-box-isarray-fir-boxisarrayop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.box_isarray</span></code> (::fir::BoxIsArrayOp)<a class="headerlink" href="#fir-box-isarray-fir-boxisarrayop" title="Permalink to this headline">¶</a></h2>
<p>is the boxed value an array?</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.box_isarray` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Determine if the boxed value has a positive (&gt; 0) rank. This will return
true if the originating box value was from a fir.embox with a memory
reference value that had the type !fir.array<T> and/or a shape argument.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %r = ... : !fir.ref&lt;i64&gt;
  %c_100 = arith.constant 100 : index
  %d = fir.shape %c_100 : (index) -&gt; !fir.shape&lt;1&gt;
  %b = fir.embox %r(%d) : (!fir.ref&lt;i64&gt;, !fir.shape&lt;1&gt;) -&gt; !fir.box&lt;i64&gt;
  %a = fir.box_isarray %b : (!fir.box&lt;i64&gt;) -&gt; i1  // true
</pre></div>
</div>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id34">
<h3>Operands:<a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>val</code></td>
<td>The type of a Fortran descriptor</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id35">
<h3>Results:<a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>bool-like</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-box-isptr-fir-boxisptrop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.box_isptr</span></code> (::fir::BoxIsPtrOp)<a class="headerlink" href="#fir-box-isptr-fir-boxisptrop" title="Permalink to this headline">¶</a></h2>
<p>is the boxed value a POINTER?</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.box_isptr` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Determine if the boxed value was from a POINTER entity.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %p = ... : !fir.ptr&lt;i64&gt;
  %b = fir.embox %p : (!fir.ptr&lt;i64&gt;) -&gt; !fir.box&lt;i64&gt;
  %a = fir.box_isptr %b : (!fir.box&lt;i64&gt;) -&gt; i1  // true
</pre></div>
</div>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id36">
<h3>Operands:<a class="headerlink" href="#id36" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>val</code></td>
<td>The type of a Fortran descriptor</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id37">
<h3>Results:<a class="headerlink" href="#id37" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>bool-like</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-boxproc-host-fir-boxprochostop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.boxproc_host</span></code> (::fir::BoxProcHostOp)<a class="headerlink" href="#fir-boxproc-host-fir-boxprochostop" title="Permalink to this headline">¶</a></h2>
<p>returns the host instance pointer (or null)</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.boxproc_host` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Extract the host context pointer from a boxproc value.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %8 = ... : !fir.boxproc&lt;(!fir.ref&lt;!fir.type&lt;T&gt;&gt;) -&gt; i32&gt;
  %9 = fir.boxproc_host %8 : (!fir.boxproc&lt;(!fir.ref&lt;!fir.type&lt;T&gt;&gt;) -&gt; i32&gt;) -&gt; !fir.ref&lt;tuple&lt;i32, i32&gt;&gt;
</pre></div>
</div>
<p>In the example, the reference to the closure over the host procedure’s
variables is returned. This allows an internal procedure to access the
host’s variables. It is up to lowering to determine the contract between
the host and the internal procedure.</p>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id38">
<h3>Operands:<a class="headerlink" href="#id38" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>val</code></td>
<td></td>
</tr>
</tbody>
</table></div>
<div class="section" id="id39">
<h3>Results:<a class="headerlink" href="#id39" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>Reference to an entity type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-box-rank-fir-boxrankop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.box_rank</span></code> (::fir::BoxRankOp)<a class="headerlink" href="#fir-box-rank-fir-boxrankop" title="Permalink to this headline">¶</a></h2>
<p>return the number of dimensions for the boxed value</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.box_rank` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Return the rank of a value of <code class="docutils literal notranslate"><span class="pre">box</span></code> type.  If the value is scalar, the
rank is 0.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %57 = fir.box_rank %40 : (!fir.box&lt;!fir.array&lt;*:f64&gt;&gt;) -&gt; i32
  %58 = fir.box_rank %41 : (!fir.box&lt;f64&gt;) -&gt; i32
</pre></div>
</div>
<p>The example <code class="docutils literal notranslate"><span class="pre">%57</span></code> shows how one would determine the rank of an array that
has deferred rank at runtime. This rank should be at least 1. In %58, the
descriptor may be either an array or a scalar, so the value is nonnegative.</p>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id40">
<h3>Operands:<a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>val</code></td>
<td>The type of a Fortran descriptor</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id41">
<h3>Results:<a class="headerlink" href="#id41" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>any integer</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-box-tdesc-fir-boxtypedescop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.box_tdesc</span></code> (::fir::BoxTypeDescOp)<a class="headerlink" href="#fir-box-tdesc-fir-boxtypedescop" title="Permalink to this headline">¶</a></h2>
<p>return the type descriptor for the boxed value</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.box_tdesc` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Return the opaque type descriptor of a value of <code class="docutils literal notranslate"><span class="pre">box</span></code> type. A type
descriptor is an implementation defined value that fully describes a type
to the Fortran runtime.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %7 = fir.box_tdesc %41 : (!fir.box&lt;f64&gt;) -&gt; !fir.tdesc&lt;f64&gt;
</pre></div>
</div>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id42">
<h3>Operands:<a class="headerlink" href="#id42" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>val</code></td>
<td>The type of a Fortran descriptor</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id43">
<h3>Results:<a class="headerlink" href="#id43" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>FIR Type descriptor type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-call-fir-callop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.call</span></code> (::fir::CallOp)<a class="headerlink" href="#fir-call-fir-callop" title="Permalink to this headline">¶</a></h2>
<p>call a procedure</p>
<p>Call the specified function or function reference.</p>
<p>Provides a custom parser and pretty printer to allow a more readable syntax
in the FIR dialect, e.g. <code class="docutils literal notranslate"><span class="pre">fir.call</span> <span class="pre">&#64;sub(%12)</span></code> or <code class="docutils literal notranslate"><span class="pre">fir.call</span> <span class="pre">%20(%22,%23)</span></code>.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %a = fir.call %funcref(%arg0) : (!fir.ref&lt;f32&gt;) -&gt; f32
  %b = fir.call @function(%arg1, %arg2) : (!fir.ref&lt;f32&gt;, !fir.ref&lt;f32&gt;) -&gt; f32
</pre></div>
</div>
<p>Interfaces: CallOpInterface</p>
<div class="section" id="id44">
<h3>Attributes:<a class="headerlink" href="#id44" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Attribute</th>
<th align="center">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>callee</code></td>
<td align="center">::mlir::SymbolRefAttr</td>
<td>symbol reference attribute</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id45">
<h3>Operands:<a class="headerlink" href="#id45" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>args</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id46">
<h3>Results:<a class="headerlink" href="#id46" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>any type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-char-convert-fir-charconvertop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.char_convert</span></code> (::fir::CharConvertOp)<a class="headerlink" href="#fir-char-convert-fir-charconvertop" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Primitive</span> <span class="n">to</span> <span class="n">convert</span> <span class="n">an</span> <span class="n">entity</span> <span class="n">of</span> <span class="nb">type</span> <span class="n">CHARACTER</span> <span class="kn">from</span> <span class="nn">one</span> <span class="n">KIND</span> <span class="n">to</span> <span class="n">a</span>
<span class="n">different</span> <span class="n">KIND</span><span class="o">.</span>
</pre></div>
</div>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.char_convert` $from `for` $count `to` $to attr-dict `:` type(operands)
</pre></div>
</div>
<p>Copy a CHARACTER (must be in memory) of KIND <em>k1</em> to a CHARACTER (also must
be in memory) of KIND <em>k2</em> where <em>k1</em> != <em>k2</em> and the buffers do not
overlap. This latter restriction is unchecked, as the Fortran language
definition eliminates the overlapping in memory case.</p>
<p>The number of code points copied is specified explicitly as the second
argument. The length of the !fir.char type is ignored.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  fir.char_convert %1 for %2 to %3 : !fir.ref&lt;!fir.char&lt;1,?&gt;&gt;, i32,
      !fir.ref&lt;!fir.char&lt;2,20&gt;&gt;
</pre></div>
</div>
<p>Should future support for encodings other than ASCII be supported, codegen
can generate a call to a runtime helper routine which will map the code
points from UTF-8 to UCS-2, for example. Such remappings may not always
be possible as they may involve the creation of more code points than the
<code class="docutils literal notranslate"><span class="pre">count</span></code> limit. These details are left as future to-dos.</p>
<div class="section" id="id47">
<h3>Operands:<a class="headerlink" href="#id47" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>from</code></td>
<td>any reference</td>
</tr>
<tr>
<td align="center"><code>count</code></td>
<td>any integer</td>
</tr>
<tr>
<td align="center"><code>to</code></td>
<td>any reference</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-cmpc-fir-cmpcop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.cmpc</span></code> (::fir::CmpcOp)<a class="headerlink" href="#fir-cmpc-fir-cmpcop" title="Permalink to this headline">¶</a></h2>
<p>complex floating-point comparison operator</p>
<p>A complex comparison to handle complex types found in FIR.</p>
<p>Traits: SameOperandsAndResultShape, SameTypeOperands</p>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id48">
<h3>Operands:<a class="headerlink" href="#id48" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>lhs</code></td>
<td>Complex type</td>
</tr>
<tr>
<td align="center"><code>rhs</code></td>
<td>Complex type</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id49">
<h3>Results:<a class="headerlink" href="#id49" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>any logical</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-constc-fir-constcop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.constc</span></code> (::fir::ConstcOp)<a class="headerlink" href="#fir-constc-fir-constcop" title="Permalink to this headline">¶</a></h2>
<p>create a complex constant</p>
<p>A complex constant. Similar to the standard dialect complex type, but this
extension allows constants with APFloat values that are not supported in
the standard dialect.</p>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id50">
<h3>Results:<a class="headerlink" href="#id50" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>Complex type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-convert-fir-convertop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.convert</span></code> (::fir::ConvertOp)<a class="headerlink" href="#fir-convert-fir-convertop" title="Permalink to this headline">¶</a></h2>
<p>encapsulates all Fortran scalar type conversions</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.convert` $value attr-dict `:` functional-type($value, results)
</pre></div>
</div>
<p>Generalized type conversion. Convert the ssa value from type T to type U.
Not all pairs of types have conversions. When types T and U are the same
type, this instruction is a NOP and may be folded away.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %v = ... : i64
  %w = fir.convert %v : (i64) -&gt; i32
</pre></div>
</div>
<p>The example truncates the value <code class="docutils literal notranslate"><span class="pre">%v</span></code> from an i64 to an i32.</p>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id51">
<h3>Operands:<a class="headerlink" href="#id51" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>value</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id52">
<h3>Results:<a class="headerlink" href="#id52" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>res</code></td>
<td>FIR dialect type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-coordinate-of-fir-coordinateop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.coordinate_of</span></code> (::fir::CoordinateOp)<a class="headerlink" href="#fir-coordinate-of-fir-coordinateop" title="Permalink to this headline">¶</a></h2>
<p>Finds the coordinate (location) of a value in memory</p>
<p>Compute the internal coordinate address starting from a boxed value or
unboxed memory reference. Returns a memory reference. When computing the
coordinate of an array element, the rank of the array must be known and
the number of indexing expressions must not exceed the rank of the array.</p>
<p>This operation will apply the access map from a boxed value implicitly.</p>
<p>Unlike LLVM’s GEP instruction, one cannot stride over the outermost
reference; therefore, the leading 0 index must be omitted.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %i = ... : index
  %h = ... : !fir.heap&lt;!fir.array&lt;100 x f32&gt;&gt;
  %p = fir.coordinate_of %h, %i : (!fir.heap&lt;!fir.array&lt;100 x f32&gt;&gt;, index) -&gt; !fir.ref&lt;f32&gt;
</pre></div>
</div>
<p>In the example, <code class="docutils literal notranslate"><span class="pre">%p</span></code> will be a pointer to the <code class="docutils literal notranslate"><span class="pre">%i</span></code>-th f32 value in the
array <code class="docutils literal notranslate"><span class="pre">%h</span></code>.</p>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id53">
<h3>Attributes:<a class="headerlink" href="#id53" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Attribute</th>
<th align="center">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>baseType</code></td>
<td align="center">::mlir::TypeAttr</td>
<td>any type attribute</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id54">
<h3>Operands:<a class="headerlink" href="#id54" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>ref</code></td>
<td>any reference or box</td>
</tr>
<tr>
<td align="center"><code>coor</code></td>
<td>coordinate type</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id55">
<h3>Results:<a class="headerlink" href="#id55" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>fir.ref or fir.llvm_ptr</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-dt-entry-fir-dtentryop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.dt_entry</span></code> (::fir::DTEntryOp)<a class="headerlink" href="#fir-dt-entry-fir-dtentryop" title="Permalink to this headline">¶</a></h2>
<p>map entry in a dispatch table</p>
<p>An entry in a dispatch table.  Allows a function symbol to be bound
to a specifier method identifier.  A dispatch operation uses the dynamic
type of a distinguished argument to determine an exact dispatch table
and uses the method identifier to select the type-bound procedure to
be called.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  fir.dt_entry method_name, @uniquedProcedure
</pre></div>
</div>
<p>Traits: HasParent<DispatchTableOp></p>
<div class="section" id="id56">
<h3>Attributes:<a class="headerlink" href="#id56" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Attribute</th>
<th align="center">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>method</code></td>
<td align="center">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
<tr>
<td align="center"><code>proc</code></td>
<td align="center">::mlir::SymbolRefAttr</td>
<td>symbol reference attribute</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-dispatch-fir-dispatchop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.dispatch</span></code> (::fir::DispatchOp)<a class="headerlink" href="#fir-dispatch-fir-dispatchop" title="Permalink to this headline">¶</a></h2>
<p>call a type-bound procedure</p>
<p>Perform a dynamic dispatch on the method name via the dispatch table
associated with the first argument.  The attribute ‘pass_arg_pos’ can be
used to select a dispatch argument other than the first one.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %r = fir.dispatch methodA(%o) : (!fir.box&lt;none&gt;) -&gt; i32
</pre></div>
</div>
<div class="section" id="id57">
<h3>Attributes:<a class="headerlink" href="#id57" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Attribute</th>
<th align="center">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>method</code></td>
<td align="center">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id58">
<h3>Operands:<a class="headerlink" href="#id58" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>object</code></td>
<td>The type of a Fortran descriptor</td>
</tr>
<tr>
<td align="center"><code>args</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id59">
<h3>Results:<a class="headerlink" href="#id59" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>any type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-dispatch-table-fir-dispatchtableop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.dispatch_table</span></code> (::fir::DispatchTableOp)<a class="headerlink" href="#fir-dispatch-table-fir-dispatchtableop" title="Permalink to this headline">¶</a></h2>
<p>Dispatch table definition</p>
<p>Define a dispatch table for a derived type with type-bound procedures.</p>
<p>A dispatch table is an untyped symbol that contains a list of associations
between method identifiers and corresponding <code class="docutils literal notranslate"><span class="pre">FuncOp</span></code> symbols.</p>
<p>The ordering of associations in the map is determined by the front end.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  fir.dispatch_table @_QDTMquuzTfoo {
    fir.dt_entry method1, @_QFNMquuzTfooPmethod1AfooR
    fir.dt_entry method2, @_QFNMquuzTfooPmethod2AfooII
  }
</pre></div>
</div>
<p>Traits: ImplicitFirTerminator, IsolatedFromAbove</p>
<p>Interfaces: Symbol</p>
</div>
<div class="section" id="fir-divc-fir-divcop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.divc</span></code> (::fir::DivcOp)<a class="headerlink" href="#fir-divc-fir-divcop" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.divc` operands attr-dict `:` type($result)
</pre></div>
</div>
<p>Traits: SameOperandsAndResultType</p>
<p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id60">
<h3>Operands:<a class="headerlink" href="#id60" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>lhs</code></td>
<td>Complex type</td>
</tr>
<tr>
<td align="center"><code>rhs</code></td>
<td>Complex type</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id61">
<h3>Results:<a class="headerlink" href="#id61" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-do-loop-fir-doloopop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.do_loop</span></code> (::fir::DoLoopOp)<a class="headerlink" href="#fir-do-loop-fir-doloopop" title="Permalink to this headline">¶</a></h2>
<p>generalized loop operation</p>
<p>Generalized high-level looping construct. This operation is similar to
MLIR’s <code class="docutils literal notranslate"><span class="pre">scf.for</span></code>.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %l = arith.constant 0 : index
  %u = arith.constant 9 : index
  %s = arith.constant 1 : index
  fir.do_loop %i = %l to %u step %s unordered {
    %x = fir.convert %i : (index) -&gt; i32
    %v = fir.call @compute(%x) : (i32) -&gt; f32
    %p = fir.coordinate_of %A, %i : (!fir.ref&lt;!fir.array&lt;?xf32&gt;&gt;, index) -&gt; !fir.ref&lt;f32&gt;
    fir.store %v to %p : !fir.ref&lt;f32&gt;
  }
</pre></div>
</div>
<p>The above example iterates over the interval <code class="docutils literal notranslate"><span class="pre">[%l,</span> <span class="pre">%u]</span></code>. The unordered
keyword indicates that the iterations can be executed in any order.</p>
<p>Traits: FirRegionTerminator, RecursiveSideEffects</p>
<p>Interfaces: LoopLikeOpInterface</p>
<div class="section" id="id62">
<h3>Attributes:<a class="headerlink" href="#id62" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Attribute</th>
<th align="center">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>unordered</code></td>
<td align="center">::mlir::UnitAttr</td>
<td>unit attribute</td>
</tr>
<tr>
<td align="center"><code>finalValue</code></td>
<td align="center">::mlir::UnitAttr</td>
<td>unit attribute</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id63">
<h3>Operands:<a class="headerlink" href="#id63" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>lowerBound</code></td>
<td>index</td>
</tr>
<tr>
<td align="center"><code>upperBound</code></td>
<td>index</td>
</tr>
<tr>
<td align="center"><code>step</code></td>
<td>index</td>
</tr>
<tr>
<td align="center"><code>initArgs</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id64">
<h3>Results:<a class="headerlink" href="#id64" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>results</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-emboxchar-fir-emboxcharop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.emboxchar</span></code> (::fir::EmboxCharOp)<a class="headerlink" href="#fir-emboxchar-fir-emboxcharop" title="Permalink to this headline">¶</a></h2>
<p>boxes a given CHARACTER reference and its LEN parameter</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.emboxchar` $memref `,` $len attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Create a boxed CHARACTER value. The CHARACTER type has the LEN type
parameter, the value of which may only be known at runtime.  Therefore,
a variable of type CHARACTER has both its data reference as well as a
LEN type parameter.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span>  <span class="kt">CHARACTER</span><span class="p">(</span><span class="nb">LEN</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="kd">::</span> <span class="n">var</span>
</pre></div>
</div>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %4 = ...         : !fir.ref&lt;!fir.array&lt;10 x !fir.char&lt;1&gt;&gt;&gt;
  %5 = arith.constant 10 : i32
  %6 = fir.emboxchar %4, %5 : (!fir.ref&lt;!fir.array&lt;10 x !fir.char&lt;1&gt;&gt;&gt;, i32) -&gt; !fir.boxchar&lt;1&gt;
</pre></div>
</div>
<p>In the above <code class="docutils literal notranslate"><span class="pre">%4</span></code> is a memory reference to a buffer of 10 CHARACTER units.
This buffer and its LEN value (10) are wrapped into a pair in <code class="docutils literal notranslate"><span class="pre">%6</span></code>.</p>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id65">
<h3>Operands:<a class="headerlink" href="#id65" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>memref</code></td>
<td>any reference</td>
</tr>
<tr>
<td align="center"><code>len</code></td>
<td>any integer</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id66">
<h3>Results:<a class="headerlink" href="#id66" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>CHARACTER type descriptor.</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-embox-fir-emboxop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.embox</span></code> (::fir::EmboxOp)<a class="headerlink" href="#fir-embox-fir-emboxop" title="Permalink to this headline">¶</a></h2>
<p>boxes a given reference and (optional) dimension information</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.embox` $memref (`(` $shape^ `)`)? (`[` $slice^ `]`)? (`typeparams` $typeparams^)?
              (`map` $accessMap^)? attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Create a boxed reference value. In Fortran, the implementation can require
extra information about an entity, such as its type, rank, etc.  This
auxilliary information is packaged and abstracted as a value with box type
by the calling routine. (In Fortran, these are called descriptors.)</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %c1 = arith.constant 1 : index
  %c10 = arith.constant 10 : index
  %5 = ... : !fir.ref&lt;!fir.array&lt;10 x i32&gt;&gt;
  %6 = fir.embox %5 : (!fir.ref&lt;!fir.array&lt;10 x i32&gt;&gt;) -&gt; !fir.box&lt;!fir.array&lt;10 x i32&gt;&gt;
</pre></div>
</div>
<p>The descriptor tuple may contain additional implementation-specific
information through the use of additional attributes.
Specifically,
- shape: emboxing an array may require shape information (an array’s
lower bounds and extents may not be known until runtime),
- slice: an array section can be described with a slice triple,
- typeparams: for emboxing a derived type with LEN type parameters,
- accessMap: unused/experimental.</p>
<p>Traits: AttrSizedOperandSegments</p>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id67">
<h3>Attributes:<a class="headerlink" href="#id67" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Attribute</th>
<th align="center">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>accessMap</code></td>
<td align="center">::mlir::AffineMapAttr</td>
<td>AffineMap attribute</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id68">
<h3>Operands:<a class="headerlink" href="#id68" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>memref</code></td>
<td>any reference</td>
</tr>
<tr>
<td align="center"><code>shape</code></td>
<td>any legal shape type</td>
</tr>
<tr>
<td align="center"><code>slice</code></td>
<td>FIR slice</td>
</tr>
<tr>
<td align="center"><code>typeparams</code></td>
<td>any integer</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id69">
<h3>Results:<a class="headerlink" href="#id69" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>The type of a Fortran descriptor</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-emboxproc-fir-emboxprocop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.emboxproc</span></code> (::fir::EmboxProcOp)<a class="headerlink" href="#fir-emboxproc-fir-emboxprocop" title="Permalink to this headline">¶</a></h2>
<p>boxes a given procedure and optional host context</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.emboxproc` $func (`,` $host^)? attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Creates an abstract encapsulation of a PROCEDURE POINTER along with an
optional pointer to a host instance context. If the pointer is not to an
internal procedure or the internal procedure does not need a host context
then the form takes only the procedure’s symbol.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %f = ... : (i32) -&gt; i32
  %0 = fir.emboxproc %f : ((i32) -&gt; i32) -&gt; !fir.boxproc&lt;(i32) -&gt; i32&gt;
</pre></div>
</div>
<p>An internal procedure requiring a host instance for correct execution uses
the second form. The closure of the host procedure’s state is passed as a
reference to a tuple. It is the responsibility of the host to manage the
context’s values accordingly, up to and including inhibiting register
promotion of local values.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %4 = ... : !fir.ref&lt;tuple&lt;!fir.ref&lt;i32&gt;, !fir.ref&lt;i32&gt;&gt;&gt;
  %g = ... : (i32) -&gt; i32
  %5 = fir.emboxproc %g, %4 : ((i32) -&gt; i32, !fir.ref&lt;tuple&lt;!fir.ref&lt;i32&gt;, !fir.ref&lt;i32&gt;&gt;&gt;) -&gt; !fir.boxproc&lt;(i32) -&gt; i32&gt;
</pre></div>
</div>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id70">
<h3>Operands:<a class="headerlink" href="#id70" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>func</code></td>
<td>function type</td>
</tr>
<tr>
<td align="center"><code>host</code></td>
<td>Reference to an entity type</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id71">
<h3>Results:<a class="headerlink" href="#id71" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td></td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-extract-value-fir-extractvalueop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.extract_value</span></code> (::fir::ExtractValueOp)<a class="headerlink" href="#fir-extract-value-fir-extractvalueop" title="Permalink to this headline">¶</a></h2>
<p>Extract a value from an aggregate SSA-value</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.extract_value` $adt `,` $coor attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Extract a value from an entity with a type composed of tuples, arrays,
and/or derived types. Returns the value from entity with the type of the
specified component. Cannot be used on values of <code class="docutils literal notranslate"><span class="pre">!fir.box</span></code> type.
It can also be used to access complex parts and elements of a character
string.</p>
<p>Note that the entity ssa-value must be of compile-time known size in order
to use this operation.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %f = fir.field_index field, !fir.type&lt;X{field:i32}&gt;
  %s = ... : !fir.type&lt;X&gt;
  %v = fir.extract_value %s, %f : (!fir.type&lt;X&gt;, !fir.field) -&gt; i32
</pre></div>
</div>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id72">
<h3>Attributes:<a class="headerlink" href="#id72" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Attribute</th>
<th align="center">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>coor</code></td>
<td align="center">::mlir::ArrayAttr</td>
<td>array attribute</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id73">
<h3>Operands:<a class="headerlink" href="#id73" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>adt</code></td>
<td>any composite</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id74">
<h3>Results:<a class="headerlink" href="#id74" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>res</code></td>
<td>FIR dialect type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-field-index-fir-fieldindexop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.field_index</span></code> (::fir::FieldIndexOp)<a class="headerlink" href="#fir-field-index-fir-fieldindexop" title="Permalink to this headline">¶</a></h2>
<p>create a field index value from a field identifier</p>
<p>Generate a field (offset) value from an identifier.  Field values may be
lowered into exact offsets when the layout of a Fortran derived type is
known at compile-time. The type of a field value is <code class="docutils literal notranslate"><span class="pre">!fir.field</span></code> and
these values can be used with the <code class="docutils literal notranslate"><span class="pre">fir.coordinate_of</span></code>, <code class="docutils literal notranslate"><span class="pre">fir.extract_value</span></code>,
or <code class="docutils literal notranslate"><span class="pre">fir.insert_value</span></code> instructions to compute (abstract) addresses of
subobjects.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %f = fir.field_index field, !fir.type&lt;X{field:i32}&gt;
</pre></div>
</div>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id75">
<h3>Attributes:<a class="headerlink" href="#id75" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Attribute</th>
<th align="center">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>field_id</code></td>
<td align="center">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
<tr>
<td align="center"><code>on_type</code></td>
<td align="center">::mlir::TypeAttr</td>
<td>any type attribute</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id76">
<h3>Operands:<a class="headerlink" href="#id76" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>typeparams</code></td>
<td>any integer</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id77">
<h3>Results:<a class="headerlink" href="#id77" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>res</code></td>
<td>FIR dialect type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-end-fir-firendop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.end</span></code> (::fir::FirEndOp)<a class="headerlink" href="#fir-end-fir-firendop" title="Permalink to this headline">¶</a></h2>
<p>the end instruction</p>
<p>The end terminator is a special terminator used inside various FIR
operations that have regions.  End is thus the custom invisible terminator
for these operations.  It is implicit and need not appear in the textual
representation.</p>
<p>Traits: Terminator</p>
</div>
<div class="section" id="fir-freemem-fir-freememop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.freemem</span></code> (::fir::FreeMemOp)<a class="headerlink" href="#fir-freemem-fir-freememop" title="Permalink to this headline">¶</a></h2>
<p>free a heap object</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.freemem` $heapref attr-dict `:` qualified(type($heapref))
</pre></div>
</div>
<p>Deallocates a heap memory reference that was allocated by an <code class="docutils literal notranslate"><span class="pre">allocmem</span></code>.
The memory object that is deallocated is placed in an undefined state
after <code class="docutils literal notranslate"><span class="pre">fir.freemem</span></code>.  Optimizations may treat the loading of an object
in the undefined state as undefined behavior.  This includes aliasing
references, such as the result of an <code class="docutils literal notranslate"><span class="pre">fir.embox</span></code>.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %21 = fir.allocmem !fir.type&lt;ZT(p:i32){field:i32}&gt;
  ...
  fir.freemem %21 : !fir.heap&lt;!fir.type&lt;ZT&gt;&gt;
</pre></div>
</div>
<p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{MemoryEffects::Free on ::mlir::SideEffects::DefaultResource}</p>
<div class="section" id="id78">
<h3>Operands:<a class="headerlink" href="#id78" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>heapref</code></td>
<td>Reference to an ALLOCATABLE attribute type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-gentypedesc-fir-gentypedescop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.gentypedesc</span></code> (::fir::GenTypeDescOp)<a class="headerlink" href="#fir-gentypedesc-fir-gentypedescop" title="Permalink to this headline">¶</a></h2>
<p>generate a type descriptor for a given type</p>
<p>Generates a constant object that is an abstract type descriptor of the
specified type.  The meta-type of a type descriptor for the type <code class="docutils literal notranslate"><span class="pre">T</span></code>
is <code class="docutils literal notranslate"><span class="pre">!fir.tdesc&lt;T&gt;</span></code>.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  !T = !fir.type&lt;T{...}&gt;
  %t = fir.gentypedesc !T  // returns value of !fir.tdesc&lt;!T&gt;
</pre></div>
</div>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id79">
<h3>Attributes:<a class="headerlink" href="#id79" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Attribute</th>
<th align="center">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>in_type</code></td>
<td align="center">::mlir::TypeAttr</td>
<td>Fortran surface type</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id80">
<h3>Results:<a class="headerlink" href="#id80" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>res</code></td>
<td>FIR dialect type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-global-len-fir-globallenop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.global_len</span></code> (::fir::GlobalLenOp)<a class="headerlink" href="#fir-global-len-fir-globallenop" title="Permalink to this headline">¶</a></h2>
<p>map a LEN parameter to a global</p>
<p>A global entity (that is not an automatic data object) can have extra LEN
parameter (compile-time) constants associated with the instance’s type.
These values can be bound to the global instance used <code class="docutils literal notranslate"><span class="pre">fir.global_len</span></code>.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  global @g : !fir.type&lt;t(len1:i32)&gt; {
    fir.global_len len1, 10 : i32
    %1 = fir.undefined !fir.type&lt;t(len1:i32)&gt;
    fir.has_value %1 : !fir.type&lt;t(len1:i32)&gt;
  }
</pre></div>
</div>
<div class="section" id="id81">
<h3>Attributes:<a class="headerlink" href="#id81" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Attribute</th>
<th align="center">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>lenparam</code></td>
<td align="center">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
<tr>
<td align="center"><code>intval</code></td>
<td align="center">::mlir::IntegerAttr</td>
<td>arbitrary integer attribute</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-global-fir-globalop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.global</span></code> (::fir::GlobalOp)<a class="headerlink" href="#fir-global-fir-globalop" title="Permalink to this headline">¶</a></h2>
<p>Global data</p>
<p>A global variable or constant with initial values.</p>
<p>The example creates a global variable (writable) named
<code class="docutils literal notranslate"><span class="pre">&#64;_QV_Mquark_Vvarble</span></code> with some initial values. The initializer should
conform to the variable’s type.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  fir.global @_QV_Mquark_Vvarble : tuple&lt;i32, f32&gt; {
    %1 = arith.constant 1 : i32
    %2 = arith.constant 2.0 : f32
    %3 = fir.undefined tuple&lt;i32, f32&gt;
    %z = arith.constant 0 : index
    %o = arith.constant 1 : index
    %4 = fir.insert_value %3, %1, %z : (tuple&lt;i32, f32&gt;, i32, index) -&gt; tuple&lt;i32, f32&gt;
    %5 = fir.insert_value %4, %2, %o : (tuple&lt;i32, f32&gt;, f32, index) -&gt; tuple&lt;i32, f32&gt;
    fir.has_value %5 : tuple&lt;i32, f32&gt;
  }
</pre></div>
</div>
<p>Traits: IsolatedFromAbove</p>
<p>Interfaces: Symbol</p>
<div class="section" id="id82">
<h3>Attributes:<a class="headerlink" href="#id82" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Attribute</th>
<th align="center">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>sym_name</code></td>
<td align="center">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
<tr>
<td align="center"><code>symref</code></td>
<td align="center">::mlir::SymbolRefAttr</td>
<td>symbol reference attribute</td>
</tr>
<tr>
<td align="center"><code>type</code></td>
<td align="center">::mlir::TypeAttr</td>
<td>any type attribute</td>
</tr>
<tr>
<td align="center"><code>initVal</code></td>
<td align="center">::mlir::Attribute</td>
<td>any attribute</td>
</tr>
<tr>
<td align="center"><code>constant</code></td>
<td align="center">::mlir::UnitAttr</td>
<td>unit attribute</td>
</tr>
<tr>
<td align="center"><code>linkName</code></td>
<td align="center">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-has-value-fir-hasvalueop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.has_value</span></code> (::fir::HasValueOp)<a class="headerlink" href="#fir-has-value-fir-hasvalueop" title="Permalink to this headline">¶</a></h2>
<p>terminator for GlobalOp</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.has_value` $resval attr-dict `:` type($resval)
</pre></div>
</div>
<p>The terminator for a GlobalOp with a body.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  global @variable : tuple&lt;i32, f32&gt; {
    %0 = arith.constant 45 : i32
    %1 = arith.constant 100.0 : f32
    %2 = fir.undefined tuple&lt;i32, f32&gt;
    %3 = arith.constant 0 : index
    %4 = fir.insert_value %2, %0, %3 : (tuple&lt;i32, f32&gt;, i32, index) -&gt; tuple&lt;i32, f32&gt;
    %5 = arith.constant 1 : index
    %6 = fir.insert_value %4, %1, %5 : (tuple&lt;i32, f32&gt;, f32, index) -&gt; tuple&lt;i32, f32&gt;
    fir.has_value %6 : tuple&lt;i32, f32&gt;
  }
</pre></div>
</div>
<p>Traits: HasParent<GlobalOp>, Terminator</p>
<div class="section" id="id83">
<h3>Operands:<a class="headerlink" href="#id83" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>resval</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-if-fir-ifop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.if</span></code> (::fir::IfOp)<a class="headerlink" href="#fir-if-fir-ifop" title="Permalink to this headline">¶</a></h2>
<p>if-then-else conditional operation</p>
<p>Used to conditionally execute operations. This operation is the FIR
dialect’s version of <code class="docutils literal notranslate"><span class="pre">loop.if</span></code>.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %56 = ... : i1
  %78 = ... : !fir.ref&lt;!T&gt;
  fir.if %56 {
    fir.store %76 to %78 : !fir.ref&lt;!T&gt;
  } else {
    fir.store %77 to %78 : !fir.ref&lt;!T&gt;
  }
</pre></div>
</div>
<p>Traits: FirRegionTerminator, NoRegionArguments, RecursiveSideEffects</p>
<div class="section" id="id84">
<h3>Operands:<a class="headerlink" href="#id84" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>condition</code></td>
<td>1-bit signless integer</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id85">
<h3>Results:<a class="headerlink" href="#id85" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>results</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-insert-on-range-fir-insertonrangeop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.insert_on_range</span></code> (::fir::InsertOnRangeOp)<a class="headerlink" href="#fir-insert-on-range-fir-insertonrangeop" title="Permalink to this headline">¶</a></h2>
<p>insert sub-value into a range on an existing sequence</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.insert_on_range` $seq `,` $val custom&lt;CustomRangeSubscript&gt;($coor) attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Insert copies of a value into an entity with an array type of constant shape
and size.
Returns a new ssa value with the same type as the original entity.
The values are inserted at a contiguous range of indices in Fortran
row-to-column element order as specified by lower and upper bound
coordinates.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %a = fir.undefined !fir.array&lt;10x10xf32&gt;
  %c = arith.constant 3.0 : f32
  %1 = fir.insert_on_range %a, %c from (0, 0) to (7, 2) : (!fir.array&lt;10x10xf32&gt;, f32) -&gt; !fir.array&lt;10x10xf32&gt;
</pre></div>
</div>
<p>The first 28 elements of %1, with coordinates from (0,0) to (7,2), have
the value 3.0.</p>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id86">
<h3>Attributes:<a class="headerlink" href="#id86" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Attribute</th>
<th align="center">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>coor</code></td>
<td align="center">::mlir::DenseIntElementsAttr</td>
<td>index elements attribute</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id87">
<h3>Operands:<a class="headerlink" href="#id87" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>seq</code></td>
<td>FIR array type</td>
</tr>
<tr>
<td align="center"><code>val</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id88">
<h3>Results:<a class="headerlink" href="#id88" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>FIR array type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-insert-value-fir-insertvalueop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.insert_value</span></code> (::fir::InsertValueOp)<a class="headerlink" href="#fir-insert-value-fir-insertvalueop" title="Permalink to this headline">¶</a></h2>
<p>insert a new sub-value into a copy of an existing aggregate</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.insert_value` $adt `,` $val `,` $coor attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Insert a value into an entity with a type composed of tuples, arrays,
and/or derived types. Returns a new ssa value with the same type as the
original entity. Cannot be used on values of <code class="docutils literal notranslate"><span class="pre">!fir.box</span></code> type.
It can also be used to set complex parts and elements of a character
string.</p>
<p>Note that the entity ssa-value must be of compile-time known size in order
to use this operation.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %a = ... : !fir.array&lt;10xtuple&lt;i32, f32&gt;&gt;
  %f = ... : f32
  %o = ... : i32
  %c = arith.constant 1 : i32
  %b = fir.insert_value %a, %f, %o, %c : (!fir.array&lt;10x20xtuple&lt;i32, f32&gt;&gt;, f32, i32, i32) -&gt; !fir.array&lt;10x20xtuple&lt;i32, f32&gt;&gt;
</pre></div>
</div>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id89">
<h3>Attributes:<a class="headerlink" href="#id89" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Attribute</th>
<th align="center">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>coor</code></td>
<td align="center">::mlir::ArrayAttr</td>
<td>array attribute</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id90">
<h3>Operands:<a class="headerlink" href="#id90" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>adt</code></td>
<td>any composite</td>
</tr>
<tr>
<td align="center"><code>val</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id91">
<h3>Results:<a class="headerlink" href="#id91" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>any composite</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-is-present-fir-ispresentop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.is_present</span></code> (::fir::IsPresentOp)<a class="headerlink" href="#fir-is-present-fir-ispresentop" title="Permalink to this headline">¶</a></h2>
<p>is this optional function argument present?</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.is_present` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Determine if an optional function argument is PRESENT (i.e. that it was not
created by a fir.absent op on the caller side).</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  func @_QPfoo(%arg0: !fir.box&lt;!fir.array&lt;?xf32&gt;&gt;) {
    %0 = fir.is_present %arg0 : (!fir.box&lt;!fir.array&lt;?xf32&gt;&gt;) -&gt; i1
    ...
</pre></div>
</div>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id92">
<h3>Operands:<a class="headerlink" href="#id92" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>val</code></td>
<td>any reference or box like</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id93">
<h3>Results:<a class="headerlink" href="#id93" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>bool-like</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-iterate-while-fir-iterwhileop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.iterate_while</span></code> (::fir::IterWhileOp)<a class="headerlink" href="#fir-iterate-while-fir-iterwhileop" title="Permalink to this headline">¶</a></h2>
<p>DO loop with early exit condition</p>
<p>This single-entry, single-exit looping construct is useful for lowering
counted loops that can exit early such as, for instance, implied-DO loops.
It is very similar to <code class="docutils literal notranslate"><span class="pre">fir::DoLoopOp</span></code> with the addition that it requires
a single loop-carried bool value that signals an early exit condition to
the operation. A <code class="docutils literal notranslate"><span class="pre">true</span></code> disposition means the next loop iteration should
proceed. A <code class="docutils literal notranslate"><span class="pre">false</span></code> indicates that the <code class="docutils literal notranslate"><span class="pre">fir.iterate_while</span></code> operation should
terminate and return its iteration arguments. This is a degenerate counted
loop in that the loop is not guaranteed to execute all iterations.</p>
<p>An example iterate_while that returns the counter value, the early
termination condition, and an extra loop-carried value is shown here. This
loop counts from %lo to %up (inclusive), stepping by %c1, so long as the
early exit (%ok) is true. The iter_args %sh value is also carried by the
loop. The result triple is the values of %i=phi(%lo,%i+%c1),
%ok=phi(%okIn,%okNew), and %sh=phi(%shIn,%shNew) from the last executed
iteration.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %v:3 = fir.iterate_while (%i = %lo to %up step %c1) and (%ok = %okIn) iter_args(%sh = %shIn) -&gt; (index, i1, i16) {
    %shNew = fir.call @bar(%sh) : (i16) -&gt; i16
    %okNew = fir.call @foo(%sh) : (i16) -&gt; i1
    fir.result %i, %okNew, %shNew : index, i1, i16
  }
</pre></div>
</div>
<p>Traits: FirRegionTerminator, RecursiveSideEffects</p>
<p>Interfaces: LoopLikeOpInterface</p>
<div class="section" id="id94">
<h3>Attributes:<a class="headerlink" href="#id94" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Attribute</th>
<th align="center">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>finalValue</code></td>
<td align="center">::mlir::UnitAttr</td>
<td>unit attribute</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id95">
<h3>Operands:<a class="headerlink" href="#id95" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>lowerBound</code></td>
<td>index</td>
</tr>
<tr>
<td align="center"><code>upperBound</code></td>
<td>index</td>
</tr>
<tr>
<td align="center"><code>step</code></td>
<td>index</td>
</tr>
<tr>
<td align="center"><code>iterateIn</code></td>
<td>1-bit signless integer</td>
</tr>
<tr>
<td align="center"><code>initArgs</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id96">
<h3>Results:<a class="headerlink" href="#id96" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>results</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-len-param-index-fir-lenparamindexop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.len_param_index</span></code> (::fir::LenParamIndexOp)<a class="headerlink" href="#fir-len-param-index-fir-lenparamindexop" title="Permalink to this headline">¶</a></h2>
<p>create a field index value from a LEN type parameter identifier</p>
<p>Generate a LEN parameter (offset) value from an LEN parameter identifier.
The type of a LEN parameter value is <code class="docutils literal notranslate"><span class="pre">!fir.len</span></code> and these values can be
used with the <code class="docutils literal notranslate"><span class="pre">fir.coordinate_of</span></code> instructions to compute (abstract)
addresses of LEN parameters.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %e = fir.len_param_index len1, !fir.type&lt;X(len1:i32)&gt;
  %p = ... : !fir.box&lt;!fir.type&lt;X&gt;&gt;
  %q = fir.coordinate_of %p, %e : (!fir.box&lt;!fir.type&lt;X&gt;&gt;, !fir.len) -&gt; !fir.ref&lt;i32&gt;
</pre></div>
</div>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id97">
<h3>Attributes:<a class="headerlink" href="#id97" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Attribute</th>
<th align="center">MLIR Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>field_id</code></td>
<td align="center">::mlir::StringAttr</td>
<td>string attribute</td>
</tr>
<tr>
<td align="center"><code>on_type</code></td>
<td align="center">::mlir::TypeAttr</td>
<td>any type attribute</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id98">
<h3>Operands:<a class="headerlink" href="#id98" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>typeparams</code></td>
<td>any integer</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id99">
<h3>Results:<a class="headerlink" href="#id99" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>res</code></td>
<td>FIR dialect type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-load-fir-loadop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.load</span></code> (::fir::LoadOp)<a class="headerlink" href="#fir-load-fir-loadop" title="Permalink to this headline">¶</a></h2>
<p>load a value from a memory reference</p>
<p>Load a value from a memory reference into an ssa-value (virtual register).
Produces an immutable ssa-value of the referent type. A memory reference
has type <code class="docutils literal notranslate"><span class="pre">!fir.ref&lt;T&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">!fir.heap&lt;T&gt;</span></code>, or <code class="docutils literal notranslate"><span class="pre">!fir.ptr&lt;T&gt;</span></code>.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %a = fir.alloca i32
  %l = fir.load %a : !fir.ref&lt;i32&gt;
</pre></div>
</div>
<p>The ssa-value has an undefined value if the memory reference is undefined
or null.</p>
<p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p>
<div class="section" id="id100">
<h3>Operands:<a class="headerlink" href="#id100" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>memref</code></td>
<td>any reference</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id101">
<h3>Results:<a class="headerlink" href="#id101" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>res</code></td>
<td>FIR dialect type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-mulc-fir-mulcop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.mulc</span></code> (::fir::MulcOp)<a class="headerlink" href="#fir-mulc-fir-mulcop" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.mulc` operands attr-dict `:` type($result)
</pre></div>
</div>
<p>Traits: Commutative, SameOperandsAndResultType</p>
<p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id102">
<h3>Operands:<a class="headerlink" href="#id102" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>lhs</code></td>
<td>Complex type</td>
</tr>
<tr>
<td align="center"><code>rhs</code></td>
<td>Complex type</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id103">
<h3>Results:<a class="headerlink" href="#id103" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-negc-fir-negcop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.negc</span></code> (::fir::NegcOp)<a class="headerlink" href="#fir-negc-fir-negcop" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.negc` operands attr-dict `:` type($result)
</pre></div>
</div>
<p>Traits: SameOperandsAndResultType</p>
<p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id104">
<h3>Operands:<a class="headerlink" href="#id104" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>operand</code></td>
<td>Complex type</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id105">
<h3>Results:<a class="headerlink" href="#id105" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-no-reassoc-fir-noreassocop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.no_reassoc</span></code> (::fir::NoReassocOp)<a class="headerlink" href="#fir-no-reassoc-fir-noreassocop" title="Permalink to this headline">¶</a></h2>
<p>synthetic op to prevent reassociation</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.no_reassoc` $val attr-dict `:` type($val)
</pre></div>
</div>
<p>Primitive operation meant to intrusively prevent operator reassociation.
The operation is otherwise a nop and the value returned is the same as the
argument.</p>
<p>The presence of this operation prevents any local optimizations. In the
example below, this would prevent possibly replacing the multiply and add
operations with a single FMA operation.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %98 = arith.mulf %96, %97 : f32
  %99 = fir.no_reassoc %98 : f32
  %a0 = arith.addf %99, %95 : f32
</pre></div>
</div>
<p>Traits: SameOperandsAndResultType</p>
<p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id106">
<h3>Operands:<a class="headerlink" href="#id106" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>val</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id107">
<h3>Results:<a class="headerlink" href="#id107" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>res</code></td>
<td>FIR dialect type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-rebox-fir-reboxop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.rebox</span></code> (::fir::ReboxOp)<a class="headerlink" href="#fir-rebox-fir-reboxop" title="Permalink to this headline">¶</a></h2>
<p>create a box given another box and (optional) dimension information</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.rebox` $box (`(` $shape^ `)`)? (`[` $slice^ `]`)? attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Create a new boxed reference value from another box. This is meant to be
used when the taking a reference to part of a boxed value, or to an entire
boxed value with new shape or type information.</p>
<p>The new extra information can be:</p>
<ul class="simple">
<li><p>new shape information (new lower bounds, new rank, or new extents.
New rank/extents can only be provided if the original fir.box is
contiguous in all dimension but maybe the first row). The shape
operand must be provided to set new shape information.</p></li>
<li><p>new type (only for derived types). It is possible to set the dynamic
type of the new box to one of the parent types of the input box dynamic
type. Type parameters cannot be changed. This change is reflected in
the requested result type of the new box.</p></li>
</ul>
<p>A slice argument can be provided to build a reference to part of a boxed
value. In this case, the shape operand must be absent or be a fir.shift
that can be used to provide a non default origin for the slice.</p>
<p>The following example illustrates creating a fir.box for x(10:33:2)
where x is described by a fir.box and has non default lower bounds,
and then applying a new 2-dimension shape to this fir.box.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %0 = fir.slice %c10, %c33, %c2 : (index, index, index) -&gt; !fir.slice&lt;1&gt;
  %1 = fir.shift %c0 : (index) -&gt; !fir.shift&lt;1&gt;
  %2 = fir.rebox %x(%1) [%0] : (!fir.box&lt;!fir.array&lt;?xf32&gt;&gt;, !fir.shift&lt;1&gt;, !fir.slice&lt;1&gt;) -&gt; !fir.box&lt;!fir.array&lt;?xf32&gt;&gt;
  %3 = fir.shape %c3, %c4 : (index, index) -&gt; !fir.shape&lt;2&gt;
  %4 = fir.rebox %2(%3) : (!fir.box&lt;!fir.array&lt;?xf32&gt;&gt;, !fir.shape&lt;2&gt;) -&gt; !fir.box&lt;!fir.array&lt;?x?xf32&gt;&gt;
</pre></div>
</div>
<p>Traits: AttrSizedOperandSegments</p>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id108">
<h3>Operands:<a class="headerlink" href="#id108" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>box</code></td>
<td>The type of a Fortran descriptor</td>
</tr>
<tr>
<td align="center"><code>shape</code></td>
<td>any legal shape or shift type</td>
</tr>
<tr>
<td align="center"><code>slice</code></td>
<td>FIR slice</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id109">
<h3>Results:<a class="headerlink" href="#id109" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>The type of a Fortran descriptor</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-result-fir-resultop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.result</span></code> (::fir::ResultOp)<a class="headerlink" href="#fir-result-fir-resultop" title="Permalink to this headline">¶</a></h2>
<p>special terminator for use in fir region operations</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.result` ($results^ `:` type($results))? attr-dict
</pre></div>
</div>
<p>Result takes a list of ssa-values produced in the block and forwards them
as a result to the operation that owns the region of the block. The
operation can retain the values or return them to its parent block
depending upon its semantics.</p>
<p>Traits: HasParent&lt;IfOp, DoLoopOp, IterWhileOp&gt;, ReturnLike, Terminator</p>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id110">
<h3>Operands:<a class="headerlink" href="#id110" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>results</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-save-result-fir-saveresultop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.save_result</span></code> (::fir::SaveResultOp)<a class="headerlink" href="#fir-save-result-fir-saveresultop" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">save</span> <span class="n">an</span> <span class="n">array</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="ow">or</span> <span class="n">record</span> <span class="n">function</span> <span class="n">result</span> <span class="n">SSA</span><span class="o">-</span><span class="n">value</span> <span class="n">to</span> <span class="n">a</span> <span class="n">memory</span> <span class="n">location</span>
</pre></div>
</div>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.save_result` $value `to` $memref (`(` $shape^ `)`)? (`typeparams` $typeparams^)?
              attr-dict `:` type(operands)
</pre></div>
</div>
<p>Save the result of a function returning an array, box, or record type value
into a memory location given the shape and LEN parameters of the result.</p>
<p>Function results of type fir.box, fir.array, or fir.rec are abstract values
that require a storage to be manipulated on the caller side. This operation
allows associating such abstract result to a storage. In later lowering of
the function interfaces, this storage might be used to pass the result in
memory.</p>
<p>For arrays, result, it is required to provide the shape of the result. For
character arrays and derived types with LEN parameters, the LEN parameter
values must be provided.</p>
<p>The fir.save_result associated to a function call must immediately follow
the call and be in the same block.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %buffer = fir.alloca fir.array&lt;?xf32&gt;, %c100
  %shape = fir.shape %c100
  %array_result = fir.call @foo() : () -&gt; fir.array&lt;?xf32&gt;
  fir.save_result %array_result to %buffer(%shape)
  %coor = fir.array_coor %buffer%(%shape), %c5
  %fifth_element = fir.load %coor : f32
</pre></div>
</div>
<p>The above fir.save_result allows saving a fir.array function result into
a buffer to later access its 5th element.</p>
<p>Traits: AttrSizedOperandSegments</p>
<div class="section" id="id111">
<h3>Operands:<a class="headerlink" href="#id111" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>value</code></td>
<td>fir.box, fir.array or fir.type</td>
</tr>
<tr>
<td align="center"><code>memref</code></td>
<td>any reference</td>
</tr>
<tr>
<td align="center"><code>shape</code></td>
<td>any legal shape type</td>
</tr>
<tr>
<td align="center"><code>typeparams</code></td>
<td>any integer</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-select-case-fir-selectcaseop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.select_case</span></code> (::fir::SelectCaseOp)<a class="headerlink" href="#fir-select-case-fir-selectcaseop" title="Permalink to this headline">¶</a></h2>
<p>Fortran’s SELECT CASE statement</p>
<p>Similar to <code class="docutils literal notranslate"><span class="pre">select</span></code>, <code class="docutils literal notranslate"><span class="pre">select_case</span></code> provides a way to express Fortran’s
SELECT CASE construct.  In this case, the selector value is matched
against variables (not just constants) and ranges.  The structure is
the same as <code class="docutils literal notranslate"><span class="pre">select</span></code>, but <code class="docutils literal notranslate"><span class="pre">select_case</span></code> allows for the expression of
more complex match conditions.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  fir.select_case %arg : i32 [
        #fir.point, %0, ^bb1(%0 : i32),
        #fir.lower, %1, ^bb2(%2,%arg,%arg2,%1 : i32,i32,i32,i32),
        #fir.interval, %2, %3, ^bb3(%2,%arg2 : i32,i32),
        #fir.upper, %arg, ^bb4(%1 : i32),
        unit, ^bb5]
</pre></div>
</div>
<p>Traits: AttrSizedOperandSegments, Terminator</p>
<p>Interfaces: BranchOpInterface</p>
<div class="section" id="id112">
<h3>Operands:<a class="headerlink" href="#id112" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>selector</code></td>
<td>any type</td>
</tr>
<tr>
<td align="center"><code>compareArgs</code></td>
<td>any type</td>
</tr>
<tr>
<td align="center"><code>targetArgs</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
<div class="section" id="successors">
<h3>Successors:<a class="headerlink" href="#successors" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Successor</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>targets</code></td>
<td>any successor</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-select-fir-selectop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.select</span></code> (::fir::SelectOp)<a class="headerlink" href="#fir-select-fir-selectop" title="Permalink to this headline">¶</a></h2>
<p>a multiway branch</p>
<p>A multiway branch terminator with similar semantics to C’s <code class="docutils literal notranslate"><span class="pre">switch</span></code>
statement.  A selector value is matched against a list of constants
of the same type for a match.  When a match is found, control is
transferred to the corresponding basic block.  A <code class="docutils literal notranslate"><span class="pre">select</span></code> must have
at least one basic block with a corresponding <code class="docutils literal notranslate"><span class="pre">unit</span></code> match, and
that block will be selected when all other conditions fail to match.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  fir.select %arg:i32 [1, ^bb1(%0 : i32),
                       2, ^bb2(%2,%arg,%arg2 : i32,i32,i32),
                      -3, ^bb3(%arg2,%2 : i32,i32),
                       4, ^bb4(%1 : i32),
                    unit, ^bb5]
</pre></div>
</div>
<p>Traits: AttrSizedOperandSegments, Terminator</p>
<p>Interfaces: BranchOpInterface</p>
<div class="section" id="id113">
<h3>Operands:<a class="headerlink" href="#id113" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>selector</code></td>
<td>any type</td>
</tr>
<tr>
<td align="center"><code>compareArgs</code></td>
<td>any type</td>
</tr>
<tr>
<td align="center"><code>targetArgs</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id114">
<h3>Successors:<a class="headerlink" href="#id114" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Successor</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>targets</code></td>
<td>any successor</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-select-rank-fir-selectrankop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.select_rank</span></code> (::fir::SelectRankOp)<a class="headerlink" href="#fir-select-rank-fir-selectrankop" title="Permalink to this headline">¶</a></h2>
<p>Fortran’s SELECT RANK statement</p>
<p>Similar to <code class="docutils literal notranslate"><span class="pre">select</span></code>, <code class="docutils literal notranslate"><span class="pre">select_rank</span></code> provides a way to express Fortran’s
SELECT RANK construct.  In this case, the rank of the selector value
is matched against constants of integer type.  The structure is the
same as <code class="docutils literal notranslate"><span class="pre">select</span></code>, but <code class="docutils literal notranslate"><span class="pre">select_rank</span></code> determines the rank of the selector
variable at runtime to determine the best match.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  fir.select_rank %arg:i32 [1, ^bb1(%0 : i32),
                            2, ^bb2(%2,%arg,%arg2 : i32,i32,i32),
                            3, ^bb3(%arg2,%2 : i32,i32),
                           -1, ^bb4(%1 : i32),
                         unit, ^bb5]
</pre></div>
</div>
<p>Traits: AttrSizedOperandSegments, Terminator</p>
<p>Interfaces: BranchOpInterface</p>
<div class="section" id="id115">
<h3>Operands:<a class="headerlink" href="#id115" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>selector</code></td>
<td>any type</td>
</tr>
<tr>
<td align="center"><code>compareArgs</code></td>
<td>any type</td>
</tr>
<tr>
<td align="center"><code>targetArgs</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id116">
<h3>Successors:<a class="headerlink" href="#id116" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Successor</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>targets</code></td>
<td>any successor</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-select-type-fir-selecttypeop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.select_type</span></code> (::fir::SelectTypeOp)<a class="headerlink" href="#fir-select-type-fir-selecttypeop" title="Permalink to this headline">¶</a></h2>
<p>Fortran’s SELECT TYPE statement</p>
<p>Similar to <code class="docutils literal notranslate"><span class="pre">select</span></code>, <code class="docutils literal notranslate"><span class="pre">select_type</span></code> provides a way to express Fortran’s
SELECT TYPE construct.  In this case, the type of the selector value
is matched against a list of type descriptors.  The structure is the
same as <code class="docutils literal notranslate"><span class="pre">select</span></code>, but <code class="docutils literal notranslate"><span class="pre">select_type</span></code> determines the type of the selector
variable at runtime to determine the best match.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  fir.select_type %arg : !fir.box&lt;()&gt; [
      #fir.instance&lt;!fir.type&lt;type1&gt;&gt;, ^bb1(%0 : i32),
      #fir.instance&lt;!fir.type&lt;type2&gt;&gt;, ^bb2(%2 : i32),
      #fir.subsumed&lt;!fir.type&lt;type3&gt;&gt;, ^bb3(%2 : i32),
      #fir.instance&lt;!fir.type&lt;type4&gt;&gt;, ^bb4(%1,%3 : i32,f32),
      unit, ^bb5]
</pre></div>
</div>
<p>Traits: AttrSizedOperandSegments, Terminator</p>
<p>Interfaces: BranchOpInterface</p>
<div class="section" id="id117">
<h3>Operands:<a class="headerlink" href="#id117" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>selector</code></td>
<td>any type</td>
</tr>
<tr>
<td align="center"><code>compareArgs</code></td>
<td>any type</td>
</tr>
<tr>
<td align="center"><code>targetArgs</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id118">
<h3>Successors:<a class="headerlink" href="#id118" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Successor</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>targets</code></td>
<td>any successor</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-shape-fir-shapeop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.shape</span></code> (::fir::ShapeOp)<a class="headerlink" href="#fir-shape-fir-shapeop" title="Permalink to this headline">¶</a></h2>
<p>generate an abstract shape vector of type <code class="docutils literal notranslate"><span class="pre">!fir.shape</span></code></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.shape` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>The arguments are an ordered list of integral type values that define the
runtime extent of each dimension of an array. The shape information is
given in the same row-to-column order as Fortran. This abstract shape value
must be applied to a reified object, so all shape information must be
specified.  The extent must be nonnegative.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %d = fir.shape %row_sz, %col_sz : (index, index) -&gt; !fir.shape&lt;2&gt;
</pre></div>
</div>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id119">
<h3>Operands:<a class="headerlink" href="#id119" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>extents</code></td>
<td>any integer</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id120">
<h3>Results:<a class="headerlink" href="#id120" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>shape of a multidimensional array object</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-shape-shift-fir-shapeshiftop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.shape_shift</span></code> (::fir::ShapeShiftOp)<a class="headerlink" href="#fir-shape-shift-fir-shapeshiftop" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>generate an abstract shape and shift vector of type `!fir.shapeshift`
</pre></div>
</div>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.shape_shift` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>The arguments are an ordered list of integral type values that is a multiple
of 2 in length. Each such pair is defined as: the lower bound and the
extent for that dimension. The shifted shape information is given in the
same row-to-column order as Fortran. This abstract shifted shape value must
be applied to a reified object, so all shifted shape information must be
specified.  The extent must be nonnegative.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %d = fir.shape_shift %lo, %extent : (index, index) -&gt; !fir.shapeshift&lt;1&gt;
</pre></div>
</div>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id121">
<h3>Operands:<a class="headerlink" href="#id121" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>pairs</code></td>
<td>any integer</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id122">
<h3>Results:<a class="headerlink" href="#id122" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>shape and origin of a multidimensional array object</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-shift-fir-shiftop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.shift</span></code> (::fir::ShiftOp)<a class="headerlink" href="#fir-shift-fir-shiftop" title="Permalink to this headline">¶</a></h2>
<p>generate an abstract shift vector of type <code class="docutils literal notranslate"><span class="pre">!fir.shift</span></code></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.shift` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>The arguments are an ordered list of integral type values that define the
runtime lower bound of each dimension of an array. The shape information is
given in the same row-to-column order as Fortran. This abstract shift value
must be applied to a reified object, so all shift information must be
specified.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %d = fir.shift %row_lb, %col_lb : (index, index) -&gt; !fir.shift&lt;2&gt;
</pre></div>
</div>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id123">
<h3>Operands:<a class="headerlink" href="#id123" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>origins</code></td>
<td>any integer</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id124">
<h3>Results:<a class="headerlink" href="#id124" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>lower bounds of a multidimensional array object</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-slice-fir-sliceop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.slice</span></code> (::fir::SliceOp)<a class="headerlink" href="#fir-slice-fir-sliceop" title="Permalink to this headline">¶</a></h2>
<p>generate an abstract slice vector of type <code class="docutils literal notranslate"><span class="pre">!fir.slice</span></code></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.slice` $triples (`path` $fields^)? (`substr` $substr^)? attr-dict `:`
              functional-type(operands, results)
</pre></div>
</div>
<p>The array slicing arguments are an ordered list of integral type values
that must be a multiple of 3 in length.  Each such triple is defined as:
the lower bound, the upper bound, and the stride for that dimension, as in
Fortran syntax. Both bounds are inclusive. The array slice information is
given in the same row-to-column order as Fortran. This abstract slice value
must be applied to a reified object, so all slice information must be
specified.  The extent must be nonnegative and the stride must not be zero.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %d = fir.slice %lo, %hi, %step : (index, index, index) -&gt; !fir.slice&lt;1&gt;
</pre></div>
</div>
<p>To support generalized slicing of Fortran’s dynamic derived types, a slice
op can be given a component path (narrowing from the product type of the
original array to the specific elemental type of the sliced projection).</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %fld = fir.field_index component, !fir.type&lt;t{...component:ct...}&gt;
  %d = fir.slice %lo, %hi, %step path %fld :
      (index, index, index, !fir.field) -&gt; !fir.slice&lt;1&gt;
</pre></div>
</div>
<p>Projections of <code class="docutils literal notranslate"><span class="pre">!fir.char</span></code> type can be further narrowed to invariant
substrings.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %d = fir.slice %lo, %hi, %step substr %offset, %width :
      (index, index, index, index, index) -&gt; !fir.slice&lt;1&gt;
</pre></div>
</div>
<p>Traits: AttrSizedOperandSegments</p>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id125">
<h3>Operands:<a class="headerlink" href="#id125" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>triples</code></td>
<td>any integer</td>
</tr>
<tr>
<td align="center"><code>fields</code></td>
<td>coordinate type</td>
</tr>
<tr>
<td align="center"><code>substr</code></td>
<td>any integer</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id126">
<h3>Results:<a class="headerlink" href="#id126" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>FIR slice</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-store-fir-storeop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.store</span></code> (::fir::StoreOp)<a class="headerlink" href="#fir-store-fir-storeop" title="Permalink to this headline">¶</a></h2>
<p>store an SSA-value to a memory location</p>
<p>Store an ssa-value (virtual register) to a memory reference.  The stored
value must be of the same type as the referent type of the memory
reference.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %v = ... : f64
  %p = ... : !fir.ptr&lt;f64&gt;
  fir.store %v to %p : !fir.ptr&lt;f64&gt;
</pre></div>
</div>
<p>The above store changes the value to which the pointer is pointing and not
the pointer itself. The operation is undefined if the memory reference,
<code class="docutils literal notranslate"><span class="pre">%p</span></code>, is undefined or null.</p>
<p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>
<div class="section" id="id127">
<h3>Operands:<a class="headerlink" href="#id127" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>value</code></td>
<td>any type</td>
</tr>
<tr>
<td align="center"><code>memref</code></td>
<td>any reference</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-string-lit-fir-stringlitop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.string_lit</span></code> (::fir::StringLitOp)<a class="headerlink" href="#fir-string-lit-fir-stringlitop" title="Permalink to this headline">¶</a></h2>
<p>create a string literal constant</p>
<p>An FIR constant that represents a sequence of characters that correspond
to Fortran’s CHARACTER type, including a LEN.  We support CHARACTER values
of different KINDs (different constant sizes).</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %1 = fir.string_lit &quot;Hello, World!&quot;(13) : !fir.char&lt;1&gt; // ASCII
  %2 = fir.string_lit [158, 2345](2) : !fir.char&lt;2&gt;      // Wide chars
</pre></div>
</div>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id128">
<h3>Results:<a class="headerlink" href="#id128" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>FIR character type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-subc-fir-subcop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.subc</span></code> (::fir::SubcOp)<a class="headerlink" href="#fir-subc-fir-subcop" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.subc` operands attr-dict `:` type($result)
</pre></div>
</div>
<p>Traits: SameOperandsAndResultType</p>
<p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id129">
<h3>Operands:<a class="headerlink" href="#id129" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>lhs</code></td>
<td>Complex type</td>
</tr>
<tr>
<td align="center"><code>rhs</code></td>
<td>Complex type</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id130">
<h3>Results:<a class="headerlink" href="#id130" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>result</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-unboxchar-fir-unboxcharop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.unboxchar</span></code> (::fir::UnboxCharOp)<a class="headerlink" href="#fir-unboxchar-fir-unboxcharop" title="Permalink to this headline">¶</a></h2>
<p>unbox a boxchar value into a pair value</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.unboxchar` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Unboxes a value of <code class="docutils literal notranslate"><span class="pre">boxchar</span></code> type into a pair consisting of a memory
reference to the CHARACTER data and the LEN type parameter.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %45   = ... : !fir.boxchar&lt;1&gt;
  %46:2 = fir.unboxchar %45 : (!fir.boxchar&lt;1&gt;) -&gt; (!fir.ref&lt;!fir.char&lt;1&gt;&gt;, i32)
</pre></div>
</div>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id131">
<h3>Operands:<a class="headerlink" href="#id131" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>boxchar</code></td>
<td>CHARACTER type descriptor.</td>
</tr>
</tbody>
</table></div>
<div class="section" id="id132">
<h3>Results:<a class="headerlink" href="#id132" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>Reference to an entity type</td>
</tr>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>any integer</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-unboxproc-fir-unboxprocop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.unboxproc</span></code> (::fir::UnboxProcOp)<a class="headerlink" href="#fir-unboxproc-fir-unboxprocop" title="Permalink to this headline">¶</a></h2>
<p>unbox a boxproc value into a pair value</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.unboxproc` operands attr-dict `:` functional-type(operands, results)
</pre></div>
</div>
<p>Unboxes a value of <code class="docutils literal notranslate"><span class="pre">boxproc</span></code> type into a pair consisting of a procedure
pointer and a pointer to a host context.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %47   = ... : !fir.boxproc&lt;() -&gt; i32&gt;
  %48:2 = fir.unboxproc %47 : (!fir.ref&lt;() -&gt; i32&gt;, !fir.ref&lt;tuple&lt;f32, i32&gt;&gt;)
</pre></div>
</div>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id133">
<h3>Operands:<a class="headerlink" href="#id133" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Operand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>boxproc</code></td>
<td></td>
</tr>
</tbody>
</table></div>
<div class="section" id="id134">
<h3>Results:<a class="headerlink" href="#id134" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">&laquo;unnamed&raquo;</td>
<td>function type</td>
</tr>
<tr>
<td align="center"><code>refTuple</code></td>
<td>Reference to an entity type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-undefined-fir-undefop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.undefined</span></code> (::fir::UndefOp)<a class="headerlink" href="#fir-undefined-fir-undefop" title="Permalink to this headline">¶</a></h2>
<p>explicit undefined value of some type</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.undefined` type($intype) attr-dict
</pre></div>
</div>
<p>Constructs an ssa-value of the specified type with an undefined value.
This operation is typically created internally by the mem2reg conversion
pass. An undefined value can be of any type except <code class="docutils literal notranslate"><span class="pre">!fir.ref&lt;T&gt;</span></code>.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %a = fir.undefined !fir.array&lt;10 x !fir.type&lt;T&gt;&gt;
</pre></div>
</div>
<p>The example creates an array shaped ssa value. The array is rank 1, extent
10, and each element has type <code class="docutils literal notranslate"><span class="pre">!fir.type&lt;T&gt;</span></code>.</p>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id135">
<h3>Results:<a class="headerlink" href="#id135" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>intype</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="fir-unreachable-fir-unreachableop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.unreachable</span></code> (::fir::UnreachableOp)<a class="headerlink" href="#fir-unreachable-fir-unreachableop" title="Permalink to this headline">¶</a></h2>
<p>the unreachable instruction</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.unreachable` attr-dict
</pre></div>
</div>
<p>Terminates a basic block with the assertion that the end of the block
will never be reached at runtime.  This instruction can be used
immediately after a call to the Fortran runtime to terminate the
program, for example.  This instruction corresponds to the LLVM IR
instruction <code class="docutils literal notranslate"><span class="pre">unreachable</span></code>.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  fir.unreachable
</pre></div>
</div>
<p>Traits: Terminator</p>
</div>
<div class="section" id="fir-zero-bits-fir-zeroop">
<h2><code class="docutils literal notranslate"><span class="pre">fir.zero_bits</span></code> (::fir::ZeroOp)<a class="headerlink" href="#fir-zero-bits-fir-zeroop" title="Permalink to this headline">¶</a></h2>
<p>explicit polymorphic zero value of some type</p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `fir.zero_bits` type($intype) attr-dict
</pre></div>
</div>
<p>Constructs an ssa-value of the specified type with a value of zero for all
bits.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %a = fir.zero_bits !fir.box&lt;!fir.array&lt;10 x !fir.type&lt;T&gt;&gt;&gt;
</pre></div>
</div>
<p>The example creates a value of type box where all bits are zero.</p>
<p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p>
<p>Effects: MemoryEffects::Effect{}</p>
<div class="section" id="id136">
<h3>Results:<a class="headerlink" href="#id136" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th align="center">Result</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>intype</code></td>
<td>any type</td>
</tr>
</tbody>
</table></div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="FlangCommandLineReference.html" title="Flang command line argument reference"
             >next</a> |</li>
        <li class="right" >
          <a href="Extensions.html" title="Fortran Extensions supported by Flang"
             >previous</a> |</li>
<! TODO: Change the webpage  >
  <li><a href="https://flang.llvm.org">Flang Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017-2022, The Flang Team.
      Last updated on Aug 10, 2022.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.2.
    </div>
  </body>
</html>