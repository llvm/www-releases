
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Standard C++ Modules &#8212; Clang 16.0.0 documentation</title>
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Modules" href="Modules.html" />
    <link rel="prev" title="Source-based Code Coverage" href="SourceBasedCodeCoverage.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Clang 16.0.0 documentation</span></a></h1>
        <h2 class="heading"><span>Standard C++ Modules</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="SourceBasedCodeCoverage.html">Source-based Code Coverage</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="Modules.html">Modules</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <div class="section" id="standard-c-modules">
<h1>Standard C++ Modules<a class="headerlink" href="#standard-c-modules" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id5">Introduction</a></p></li>
<li><p><a class="reference internal" href="#standard-c-named-modules" id="id6">Standard C++ Named modules</a></p>
<ul>
<li><p><a class="reference internal" href="#background-and-terminology" id="id7">Background and terminology</a></p>
<ul>
<li><p><a class="reference internal" href="#modules" id="id8">Modules</a></p></li>
<li><p><a class="reference internal" href="#id2" id="id9">Clang Modules</a></p></li>
<li><p><a class="reference internal" href="#module-and-module-unit" id="id10">Module and module unit</a></p></li>
<li><p><a class="reference internal" href="#built-module-interface-file" id="id11">Built Module Interface file</a></p></li>
<li><p><a class="reference internal" href="#global-module-fragment" id="id12">Global module fragment</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#how-to-build-projects-using-modules" id="id13">How to build projects using modules</a></p>
<ul>
<li><p><a class="reference internal" href="#quick-start" id="id14">Quick Start</a></p></li>
<li><p><a class="reference internal" href="#how-to-enable-standard-c-modules" id="id15">How to enable standard C++ modules</a></p></li>
<li><p><a class="reference internal" href="#how-to-produce-a-bmi" id="id16">How to produce a BMI</a></p></li>
<li><p><a class="reference internal" href="#file-name-requirement" id="id17">File name requirement</a></p></li>
<li><p><a class="reference internal" href="#module-name-requirement" id="id18">Module name requirement</a></p></li>
<li><p><a class="reference internal" href="#how-to-specify-the-dependent-bmis" id="id19">How to specify the dependent BMIs</a></p></li>
<li><p><a class="reference internal" href="#remember-that-module-units-still-have-an-object-counterpart-to-the-bmi" id="id20">Remember that module units still have an object counterpart to the BMI</a></p></li>
<li><p><a class="reference internal" href="#consistency-requirement" id="id21">Consistency Requirement</a></p>
<ul>
<li><p><a class="reference internal" href="#options-consistency" id="id22">Options consistency</a></p></li>
<li><p><a class="reference internal" href="#source-content-consistency" id="id23">Source content consistency</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#abi-impacts" id="id24">ABI Impacts</a></p></li>
<li><p><a class="reference internal" href="#known-problems" id="id25">Known Problems</a></p>
<ul>
<li><p><a class="reference internal" href="#support-for-clang-scan-deps" id="id26">Support for clang-scan-deps</a></p></li>
<li><p><a class="reference internal" href="#ambiguous-deduction-guide" id="id27">Ambiguous deduction guide</a></p></li>
<li><p><a class="reference internal" href="#ignored-preferredname-attribute" id="id28">Ignored PreferredName Attribute</a></p></li>
<li><p><a class="reference internal" href="#don-t-emit-macros-about-module-declaration" id="id29">Don’t emit macros about module declaration</a></p></li>
<li><p><a class="reference internal" href="#in-consistent-filename-suffix-requirement-for-importable-module-units" id="id30">In consistent filename suffix requirement for importable module units</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#header-units" id="id31">Header Units</a></p>
<ul>
<li><p><a class="reference internal" href="#how-to-build-projects-using-header-unit" id="id32">How to build projects using header unit</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id33">Quick Start</a></p></li>
<li><p><a class="reference internal" href="#how-to-produce-bmis" id="id34">How to produce BMIs</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id35">How to specify the dependent BMIs</a></p></li>
<li><p><a class="reference internal" href="#don-t-compile-the-bmi" id="id36">Don’t compile the BMI</a></p></li>
<li><p><a class="reference internal" href="#include-translation" id="id37">Include translation</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#relationships-between-clang-modules" id="id38">Relationships between Clang modules</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#possible-questions" id="id39">Possible Questions</a></p>
<ul>
<li><p><a class="reference internal" href="#how-modules-speed-up-compilation" id="id40">How modules speed up compilation</a></p></li>
<li><p><a class="reference internal" href="#interoperability-with-clang-modules" id="id41">Interoperability with Clang Modules</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id5">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The term <code class="docutils literal notranslate"><span class="pre">modules</span></code> has a lot of meanings. For the users of Clang, modules may
refer to <code class="docutils literal notranslate"><span class="pre">Objective-C</span> <span class="pre">Modules</span></code>, <code class="docutils literal notranslate"><span class="pre">Clang</span> <span class="pre">C++</span> <span class="pre">Modules</span></code> (or <code class="docutils literal notranslate"><span class="pre">Clang</span> <span class="pre">Header</span> <span class="pre">Modules</span></code>,
etc.) or <code class="docutils literal notranslate"><span class="pre">Standard</span> <span class="pre">C++</span> <span class="pre">Modules</span></code>. The implementation of all these kinds of modules in Clang
has a lot of shared code, but from the perspective of users, their semantics and
command line interfaces are very different. This document focuses on
an introduction of how to use standard C++ modules in Clang.</p>
<p>There is already a detailed document about <a class="reference external" href="Modules.html">Clang modules</a>, it
should be helpful to read <a class="reference external" href="Modules.html">Clang modules</a> if you want to know
more about the general idea of modules. Since standard C++ modules have different semantics
(and work flows) from <cite>Clang modules</cite>, this page describes the background and use of
Clang with standard C++ modules.</p>
<p>Modules exist in two forms in the C++ Language Specification. They can refer to
either “Named Modules” or to “Header Units”. This document covers both forms.</p>
</div>
<div class="section" id="standard-c-named-modules">
<h2><a class="toc-backref" href="#id6">Standard C++ Named modules</a><a class="headerlink" href="#standard-c-named-modules" title="Permalink to this headline">¶</a></h2>
<p>This document was intended to be a manual first and foremost, however, we consider it helpful to
introduce some language background here for readers who are not familiar with
the new language feature. This document is not intended to be a language
tutorial; it will only introduce necessary concepts about the
structure and building of the project.</p>
<div class="section" id="background-and-terminology">
<h3><a class="toc-backref" href="#id7">Background and terminology</a><a class="headerlink" href="#background-and-terminology" title="Permalink to this headline">¶</a></h3>
<div class="section" id="modules">
<h4><a class="toc-backref" href="#id8">Modules</a><a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h4>
<p>In this document, the term <code class="docutils literal notranslate"><span class="pre">Modules</span></code>/<code class="docutils literal notranslate"><span class="pre">modules</span></code> refers to standard C++ modules
feature if it is not decorated by <code class="docutils literal notranslate"><span class="pre">Clang</span></code>.</p>
</div>
<div class="section" id="id2">
<h4><a class="toc-backref" href="#id9">Clang Modules</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>In this document, the term <code class="docutils literal notranslate"><span class="pre">Clang</span> <span class="pre">Modules</span></code>/<code class="docutils literal notranslate"><span class="pre">Clang</span> <span class="pre">modules</span></code> refer to Clang
c++ modules extension. These are also known as <code class="docutils literal notranslate"><span class="pre">Clang</span> <span class="pre">header</span> <span class="pre">modules</span></code>,
<code class="docutils literal notranslate"><span class="pre">Clang</span> <span class="pre">module</span> <span class="pre">map</span> <span class="pre">modules</span></code> or <code class="docutils literal notranslate"><span class="pre">Clang</span> <span class="pre">c++</span> <span class="pre">modules</span></code>.</p>
</div>
<div class="section" id="module-and-module-unit">
<h4><a class="toc-backref" href="#id10">Module and module unit</a><a class="headerlink" href="#module-and-module-unit" title="Permalink to this headline">¶</a></h4>
<p>A module consists of one or more module units. A module unit is a special
translation unit. Every module unit must have a module declaration. The syntax
of the module declaration is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="k">export</span><span class="p">]</span> <span class="n">module</span> <span class="n">module_name</span><span class="p">[</span><span class="o">:</span><span class="n">partition_name</span><span class="p">];</span>
</pre></div>
</div>
<p>Terms enclosed in <code class="docutils literal notranslate"><span class="pre">[]</span></code> are optional. The syntax of <code class="docutils literal notranslate"><span class="pre">module_name</span></code> and <code class="docutils literal notranslate"><span class="pre">partition_name</span></code>
in regex form corresponds to <code class="docutils literal notranslate"><span class="pre">[a-zA-Z_][a-zA-Z_0-9\.]*</span></code>. In particular, a literal dot <code class="docutils literal notranslate"><span class="pre">.</span></code>
in the name has no semantic meaning (e.g. implying a hierarchy).</p>
<p>In this document, module units are classified into:</p>
<ul class="simple">
<li><p>Primary module interface unit.</p></li>
<li><p>Module implementation unit.</p></li>
<li><p>Module interface partition unit.</p></li>
<li><p>Internal module partition unit.</p></li>
</ul>
<p>A primary module interface unit is a module unit whose module declaration is
<code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">module</span> <span class="pre">module_name;</span></code>. The <code class="docutils literal notranslate"><span class="pre">module_name</span></code> here denotes the name of the
module. A module should have one and only one primary module interface unit.</p>
<p>A module implementation unit is a module unit whose module declaration is
<code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">module_name;</span></code>. A module could have multiple module implementation
units with the same declaration.</p>
<p>A module interface partition unit is a module unit whose module declaration is
<code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">module</span> <span class="pre">module_name:partition_name;</span></code>. The <code class="docutils literal notranslate"><span class="pre">partition_name</span></code> should be
unique within any given module.</p>
<p>An internal module partition unit is a module unit whose module declaration
is <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">module_name:partition_name;</span></code>. The <code class="docutils literal notranslate"><span class="pre">partition_name</span></code> should be
unique within any given module.</p>
<p>In this document, we use the following umbrella terms:</p>
<ul class="simple">
<li><p>A <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">interface</span> <span class="pre">unit</span></code> refers to either a <code class="docutils literal notranslate"><span class="pre">primary</span> <span class="pre">module</span> <span class="pre">interface</span> <span class="pre">unit</span></code>
or a <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">interface</span> <span class="pre">partition</span> <span class="pre">unit</span></code>.</p></li>
<li><p>An <code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code> refers to either a <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">interface</span> <span class="pre">unit</span></code>
or a <code class="docutils literal notranslate"><span class="pre">internal</span> <span class="pre">module</span> <span class="pre">partition</span> <span class="pre">unit</span></code>.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">partition</span> <span class="pre">unit</span></code> refers to either a <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">interface</span> <span class="pre">partition</span> <span class="pre">unit</span></code>
or a <code class="docutils literal notranslate"><span class="pre">internal</span> <span class="pre">module</span> <span class="pre">partition</span> <span class="pre">unit</span></code>.</p></li>
</ul>
</div>
<div class="section" id="built-module-interface-file">
<h4><a class="toc-backref" href="#id11">Built Module Interface file</a><a class="headerlink" href="#built-module-interface-file" title="Permalink to this headline">¶</a></h4>
<p>A <code class="docutils literal notranslate"><span class="pre">Built</span> <span class="pre">Module</span> <span class="pre">Interface</span> <span class="pre">file</span></code> stands for the precompiled result of an importable module unit.
It is also called the acronym <code class="docutils literal notranslate"><span class="pre">BMI</span></code> genrally.</p>
</div>
<div class="section" id="global-module-fragment">
<h4><a class="toc-backref" href="#id12">Global module fragment</a><a class="headerlink" href="#global-module-fragment" title="Permalink to this headline">¶</a></h4>
<p>In a module unit, the section from <code class="docutils literal notranslate"><span class="pre">module;</span></code> to the module declaration is called the global module fragment.</p>
</div>
</div>
<div class="section" id="how-to-build-projects-using-modules">
<h3><a class="toc-backref" href="#id13">How to build projects using modules</a><a class="headerlink" href="#how-to-build-projects-using-modules" title="Permalink to this headline">¶</a></h3>
<div class="section" id="quick-start">
<h4><a class="toc-backref" href="#id14">Quick Start</a><a class="headerlink" href="#quick-start" title="Permalink to this headline">¶</a></h4>
<p>Let’s see a “hello world” example that uses modules.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Hello.cppm</span>
<span class="n">module</span><span class="p">;</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="k">export</span> <span class="n">module</span> <span class="n">Hello</span><span class="p">;</span>
<span class="k">export</span> <span class="kt">void</span> <span class="nf">hello</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Hello World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// use.cpp</span>
<span class="n">import</span> <span class="n">Hello</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">hello</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then we type:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 Hello.cppm --precompile -o Hello.pcm
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 use.cpp -fprebuilt-module-path<span class="o">=</span>. Hello.pcm -o Hello.out
<span class="gp">$</span> ./Hello.out
<span class="go">Hello World!</span>
</pre></div>
</div>
<p>In this example, we make and use a simple module <code class="docutils literal notranslate"><span class="pre">Hello</span></code> which contains only a
primary module interface unit <code class="docutils literal notranslate"><span class="pre">Hello.cppm</span></code>.</p>
<p>Then let’s see a little bit more complex “hello world” example which uses the 4 kinds of module units.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// M.cppm</span>
<span class="k">export</span> <span class="n">module</span> <span class="n">M</span><span class="p">;</span>
<span class="k">export</span> <span class="nl">import</span> <span class="p">:</span><span class="n">interface_part</span><span class="p">;</span>
<span class="nl">import</span> <span class="p">:</span><span class="n">impl_part</span><span class="p">;</span>
<span class="k">export</span> <span class="kt">void</span> <span class="nf">Hello</span><span class="p">();</span>

<span class="c1">// interface_part.cppm</span>
<span class="k">export</span> <span class="n">module</span> <span class="nl">M</span><span class="p">:</span><span class="n">interface_part</span><span class="p">;</span>
<span class="k">export</span> <span class="kt">void</span> <span class="nf">World</span><span class="p">();</span>

<span class="c1">// impl_part.cppm</span>
<span class="n">module</span><span class="p">;</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="n">module</span> <span class="nl">M</span><span class="p">:</span><span class="n">impl_part</span><span class="p">;</span>
<span class="nl">import</span> <span class="p">:</span><span class="n">interface_part</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">W</span> <span class="o">=</span> <span class="s">&quot;World.&quot;</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">World</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">W</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Impl.cpp</span>
<span class="n">module</span><span class="p">;</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="n">module</span> <span class="n">M</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">Hello</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Hello &quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// User.cpp</span>
<span class="n">import</span> <span class="n">M</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Hello</span><span class="p">();</span>
  <span class="n">World</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then we are able to compile the example by the following command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span> Precompiling the module
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 interface_part.cppm --precompile -o M-interface_part.pcm
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 impl_part.cppm --precompile -fprebuilt-module-path<span class="o">=</span>. -o M-impl_part.pcm
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 M.cppm --precompile -fprebuilt-module-path<span class="o">=</span>. -o M.pcm
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 Impl.cpp -fmodule-file<span class="o">=</span>M.pcm -c -o Impl.o

<span class="gp">#</span> Compiling the user
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 User.cpp -fprebuilt-module-path<span class="o">=</span>. -c -o User.o

<span class="gp">#</span> Compiling the module and linking it together
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 M-interface_part.pcm -c -o M-interface_part.o
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 M-impl_part.pcm -c -o M-impl_part.o
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 M.pcm -c -o M.o
<span class="gp">$</span> clang++ User.o M-interface_part.o  M-impl_part.o M.o Impl.o -o a.out
</pre></div>
</div>
<p>We explain the options in the following sections.</p>
</div>
<div class="section" id="how-to-enable-standard-c-modules">
<h4><a class="toc-backref" href="#id15">How to enable standard C++ modules</a><a class="headerlink" href="#how-to-enable-standard-c-modules" title="Permalink to this headline">¶</a></h4>
<p>Currently, standard C++ modules are enabled automatically
if the language standard is <code class="docutils literal notranslate"><span class="pre">-std=c++20</span></code> or newer.
The <code class="docutils literal notranslate"><span class="pre">-fmodules-ts</span></code> option is deprecated and is planned to be removed.</p>
</div>
<div class="section" id="how-to-produce-a-bmi">
<h4><a class="toc-backref" href="#id16">How to produce a BMI</a><a class="headerlink" href="#how-to-produce-a-bmi" title="Permalink to this headline">¶</a></h4>
<p>We can generate a BMI for an importable module unit by either <code class="docutils literal notranslate"><span class="pre">--precompile</span></code>
or <code class="docutils literal notranslate"><span class="pre">-fmodule-output</span></code> flags.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">--precompile</span></code> option generates the BMI as the output of the compilation and the output path
can be specified using the <code class="docutils literal notranslate"><span class="pre">-o</span></code> option.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">-fmodule-output</span></code> option generates the BMI as a by-product of the compilation.
If <code class="docutils literal notranslate"><span class="pre">-fmodule-output=</span></code> is specified, the BMI will be emitted the specified location. Then if
<code class="docutils literal notranslate"><span class="pre">-fmodule-output</span></code> and <code class="docutils literal notranslate"><span class="pre">-c</span></code> are specified, the BMI will be emitted in the directory of the
output file with the name of the input file with the new extension <code class="docutils literal notranslate"><span class="pre">.pcm</span></code>. Otherwise, the BMI
will be emitted in the working directory with the name of the input file with the new extension
<code class="docutils literal notranslate"><span class="pre">.pcm</span></code>.</p>
<p>The style to generate BMIs by <code class="docutils literal notranslate"><span class="pre">--precompile</span></code> is called two-phase compilation since it takes
2 steps to compile a source file to an object file. The style to generate BMIs by <code class="docutils literal notranslate"><span class="pre">-fmodule-output</span></code>
is called one-phase compilation respectively. The one-phase compilation model is simpler
for build systems to implement and the two-phase compilation has the potential to compile faster due
to higher parallelism. As an example, if there are two module units A and B, and B depends on A, the
one-phase compilation model would need to compile them serially, whereas the two-phase compilation
model may be able to compile them simultaneously if the compilation from A.pcm to A.o takes a long
time.</p>
</div>
<div class="section" id="file-name-requirement">
<h4><a class="toc-backref" href="#id17">File name requirement</a><a class="headerlink" href="#file-name-requirement" title="Permalink to this headline">¶</a></h4>
<p>The file name of an <code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code> should end with <code class="docutils literal notranslate"><span class="pre">.cppm</span></code>
(or <code class="docutils literal notranslate"><span class="pre">.ccm</span></code>, <code class="docutils literal notranslate"><span class="pre">.cxxm</span></code>, <code class="docutils literal notranslate"><span class="pre">.c++m</span></code>). The file name of a <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">implementation</span> <span class="pre">unit</span></code>
should end with <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> (or <code class="docutils literal notranslate"><span class="pre">.cc</span></code>, <code class="docutils literal notranslate"><span class="pre">.cxx</span></code>, <code class="docutils literal notranslate"><span class="pre">.c++</span></code>).</p>
<p>The file name of BMIs should end with <code class="docutils literal notranslate"><span class="pre">.pcm</span></code>.
The file name of the BMI of a <code class="docutils literal notranslate"><span class="pre">primary</span> <span class="pre">module</span> <span class="pre">interface</span> <span class="pre">unit</span></code> should be <code class="docutils literal notranslate"><span class="pre">module_name.pcm</span></code>.
The file name of BMIs of <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">partition</span> <span class="pre">unit</span></code> should be <code class="docutils literal notranslate"><span class="pre">module_name-partition_name.pcm</span></code>.</p>
<p>If the file names use different extensions, Clang may fail to build the module.
For example, if the filename of an <code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code> ends with <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> instead of <code class="docutils literal notranslate"><span class="pre">.cppm</span></code>,
then we can’t generate a BMI for the <code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code> by <code class="docutils literal notranslate"><span class="pre">--precompile</span></code> option
since <code class="docutils literal notranslate"><span class="pre">--precompile</span></code> option now would only run preprocessor, which is equal to <cite>-E</cite> now.
If we want the filename of an <code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code> ends with other suffixes instead of <code class="docutils literal notranslate"><span class="pre">.cppm</span></code>,
we could put <code class="docutils literal notranslate"><span class="pre">-x</span> <span class="pre">c++-module</span></code> in front of the file. For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Hello.cpp</span>
<span class="n">module</span><span class="p">;</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="k">export</span> <span class="n">module</span> <span class="n">Hello</span><span class="p">;</span>
<span class="k">export</span> <span class="kt">void</span> <span class="nf">hello</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Hello World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// use.cpp</span>
<span class="n">import</span> <span class="n">Hello</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">hello</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now the filename of the <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">interface</span></code> ends with <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> instead of <code class="docutils literal notranslate"><span class="pre">.cppm</span></code>,
we can’t compile them by the original command lines. But we are still able to do it by:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 -x c++-module Hello.cpp --precompile -o Hello.pcm
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 use.cpp -fprebuilt-module-path<span class="o">=</span>. Hello.pcm -o Hello.out
<span class="gp">$</span> ./Hello.out
<span class="go">Hello World!</span>
</pre></div>
</div>
</div>
<div class="section" id="module-name-requirement">
<h4><a class="toc-backref" href="#id18">Module name requirement</a><a class="headerlink" href="#module-name-requirement" title="Permalink to this headline">¶</a></h4>
<p>[module.unit]p1 says:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>All module-names either beginning with an identifier consisting of std followed by zero
or more digits or containing a reserved identifier ([lex.name]) are reserved and shall not
be specified in a module-declaration; no diagnostic is required. If any identifier in a reserved
module-name is a reserved identifier, the module name is reserved for use by C++ implementations;
otherwise it is reserved for future standardization.
</pre></div>
</div>
<p>So all of the following name is not valid by default:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>std
std1
std.foo
__test
// and so on ...
</pre></div>
</div>
<p>If you still want to use the reserved module names for any reason, currently you can add a special line marker
in the front of the module declaration like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp"># __LINE_NUMBER__ __FILE__ 1 3</span>
<span class="k">export</span> <span class="n">module</span> <span class="n">std</span><span class="p">;</span>
</pre></div>
</div>
<p>Here the <cite>__LINE_NUMBER__</cite> is the actual line number of the corresponding line. The <cite>__FILE__</cite> means the filename
of the translation unit. The <cite>1</cite> means the following is a new file. And <cite>3</cite> means this is a system header/file so
the certain warnings should be suppressed. You could find more details at:
<a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc-3.0.2/cpp_9.html">https://gcc.gnu.org/onlinedocs/gcc-3.0.2/cpp_9.html</a>.</p>
</div>
<div class="section" id="how-to-specify-the-dependent-bmis">
<h4><a class="toc-backref" href="#id19">How to specify the dependent BMIs</a><a class="headerlink" href="#how-to-specify-the-dependent-bmis" title="Permalink to this headline">¶</a></h4>
<p>There are 3 methods to specify the dependent BMIs:</p>
<ul class="simple">
<li><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path=&lt;path/to/direcotry&gt;</span></code>.</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li><p><code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code>.</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="3">
<li><p><code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=&lt;path/to/BMI&gt;</span></code>.</p></li>
</ol>
</li>
</ul>
<p>The option <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code> tells the compiler the path where to search for dependent BMIs.
It may be used multiple times just like <code class="docutils literal notranslate"><span class="pre">-I</span></code> for specifying paths for header files. The look up rule here is:</p>
<ul class="simple">
<li><p>(1) When we import module M. The compiler would look up M.pcm in the directories specified
by <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code>.</p></li>
<li><p>(2) When we import partition module unit M:P. The compiler would look up M-P.pcm in the
directories specified by <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code>.</p></li>
</ul>
<p>The option <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code> tells the compiler to load the specified BMI directly.
The option <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=&lt;path/to/BMI&gt;</span></code> tells the compiler to load the specified BMI
for the module specified by <code class="docutils literal notranslate"><span class="pre">&lt;module-name&gt;</span></code> when necessary. The main difference is that
<code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code> will load the BMI eagerly, whereas
<code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=&lt;path/to/BMI&gt;</span></code> will only load the BMI lazily, which is similar
with <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code>.</p>
<p>In case all <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path=&lt;path/to/direcotry&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code> and
<code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=&lt;path/to/BMI&gt;</span></code> exist, the <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code> option
takes highest precedence and <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=&lt;path/to/BMI&gt;</span></code> will take the second
highest precedence.</p>
<p>When we compile a <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">implementation</span> <span class="pre">unit</span></code>, we must specify the BMI of the corresponding
<code class="docutils literal notranslate"><span class="pre">primary</span> <span class="pre">module</span> <span class="pre">interface</span> <span class="pre">unit</span></code>.
Since the language specification says a module implementation unit implicitly imports
the primary module interface unit.</p>
<blockquote>
<div><p>[module.unit]p8</p>
<p>A module-declaration that contains neither an export-keyword nor a module-partition implicitly
imports the primary module interface unit of the module as if by a module-import-declaration.</p>
</div></blockquote>
<p>All of the 3 options <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path=&lt;path/to/direcotry&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code>
and <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=&lt;path/to/BMI&gt;</span></code> may occur multiple times.
For example, the command line to compile <code class="docutils literal notranslate"><span class="pre">M.cppm</span></code> in
the above example could be rewritten into:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 M.cppm --precompile -fmodule-file<span class="o">=</span>M-interface_part.pcm -fmodule-file<span class="o">=</span>M-impl_part.pcm -o M.pcm
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 M.cppm --precompile -fmodule-file<span class="o">=</span>M:interface_part<span class="o">=</span>M-interface_part.pcm -fmodule-file<span class="o">=</span>M:impl_part<span class="o">=</span>M-impl_part.pcm -o M.pcm
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code> is more convenient and <code class="docutils literal notranslate"><span class="pre">-fmodule-file</span></code> is faster since
it saves time for file lookup.</p>
</div>
<div class="section" id="remember-that-module-units-still-have-an-object-counterpart-to-the-bmi">
<h4><a class="toc-backref" href="#id20">Remember that module units still have an object counterpart to the BMI</a><a class="headerlink" href="#remember-that-module-units-still-have-an-object-counterpart-to-the-bmi" title="Permalink to this headline">¶</a></h4>
<p>It is easy to forget to compile BMIs at first since we may envision module interfaces like headers.
However, this is not true.
Module units are translation units. We need to compile them to object files
and link the object files like the example shows.</p>
<p>For example, the traditional compilation processes for headers are like:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>src1.cpp -+&gt; clang++ src1.cpp --&gt; src1.o ---,
hdr1.h  --&#39;                                 +-&gt; clang++ src1.o src2.o -&gt;  executable
hdr2.h  --,                                 |
src2.cpp -+&gt; clang++ src2.cpp --&gt; src2.o ---&#39;
</pre></div>
</div>
<p>And the compilation process for module units are like:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>              src1.cpp ----------------------------------------+&gt; clang++ src1.cpp -------&gt; src1.o -,
(header unit) hdr1.h    -&gt; clang++ hdr1.h ...    -&gt; hdr1.pcm --&#39;                                    +-&gt; clang++ src1.o mod1.o src2.o -&gt;  executable
              mod1.cppm -&gt; clang++ mod1.cppm ... -&gt; mod1.pcm --,--&gt; clang++ mod1.pcm ... -&gt; mod1.o -+
              src2.cpp ----------------------------------------+&gt; clang++ src2.cpp -------&gt; src2.o -&#39;
</pre></div>
</div>
<p>As the diagrams show, we need to compile the BMI from module units to object files and link the object files.
(But we can’t do this for the BMI from header units. See the later section for the definition of header units)</p>
<p>If we want to create a module library, we can’t just ship the BMIs in an archive.
We must compile these BMIs(<code class="docutils literal notranslate"><span class="pre">*.pcm</span></code>) into object files(<code class="docutils literal notranslate"><span class="pre">*.o</span></code>) and add those object files to the archive instead.</p>
</div>
<div class="section" id="consistency-requirement">
<h4><a class="toc-backref" href="#id21">Consistency Requirement</a><a class="headerlink" href="#consistency-requirement" title="Permalink to this headline">¶</a></h4>
<p>If we envision modules as a cache to speed up compilation, then - as with other caching techniques -
it is important to keep cache consistency.
So <strong>currently</strong> Clang will do very strict check for consistency.</p>
<div class="section" id="options-consistency">
<h5><a class="toc-backref" href="#id22">Options consistency</a><a class="headerlink" href="#options-consistency" title="Permalink to this headline">¶</a></h5>
<p>The language option of module units and their non-module-unit users should be consistent.
The following example is not allowed:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// M.cppm</span>
<span class="k">export</span> <span class="n">module</span> <span class="n">M</span><span class="p">;</span>

<span class="c1">// Use.cpp</span>
<span class="n">import</span> <span class="n">M</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 M.cppm --precompile -o M.pcm
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++2b Use.cpp -fprebuilt-module-path<span class="o">=</span>.
</pre></div>
</div>
<p>The compiler would reject the example due to the inconsistent language options.
Not all options are language options.
For example, the following example is allowed:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 M.cppm --precompile -o M.pcm
<span class="gp">#</span> Inconsistent optimization level.
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 -O3 Use.cpp -fprebuilt-module-path<span class="o">=</span>.
<span class="gp">#</span> Inconsistent debugging level.
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 -g Use.cpp -fprebuilt-module-path<span class="o">=</span>.
</pre></div>
</div>
<p>Although the two examples have inconsistent optimization and debugging level, both of them are accepted.</p>
<p>Note that <strong>currently</strong> the compiler doesn’t consider inconsistent macro definition a problem. For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 M.cppm --precompile -o M.pcm
<span class="gp">#</span> Inconsistent optimization level.
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 -O3 -DNDEBUG Use.cpp -fprebuilt-module-path<span class="o">=</span>.
</pre></div>
</div>
<p>Currently Clang would accept the above example. But it may produce surprising results if the
debugging code depends on consistent use of <code class="docutils literal notranslate"><span class="pre">NDEBUG</span></code> also in other translation units.</p>
</div>
<div class="section" id="source-content-consistency">
<h5><a class="toc-backref" href="#id23">Source content consistency</a><a class="headerlink" href="#source-content-consistency" title="Permalink to this headline">¶</a></h5>
<p>When the compiler reads a BMI, the compiler will check the consistency of the corresponding
source files. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// M.cppm</span>
<span class="k">export</span> <span class="n">module</span> <span class="n">M</span><span class="p">;</span>
<span class="k">export</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">foo</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Use.cpp</span>
<span class="n">import</span> <span class="n">M</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">foo</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 M.cppm --precompile -o M.pcm
<span class="gp">$</span> rm M.cppm
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 Use.cpp -fmodule-file<span class="o">=</span>M.pcm
</pre></div>
</div>
<p>The compiler would reject the example since the compiler failed to find the source file to check the consistency.
So the following example would be rejected too.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 M.cppm --precompile -o M.pcm
<span class="gp">$</span> <span class="nb">echo</span> <span class="s2">&quot;int i=0;&quot;</span> &gt;&gt; M.cppm
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 Use.cpp -fmodule-file<span class="o">=</span>M.pcm
</pre></div>
</div>
<p>The compiler would reject it too since the compiler detected the file was changed.</p>
<p>But it is OK to move the BMI as long as the source files remain:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 M.cppm --precompile -o M.pcm
<span class="gp">$</span> mkdir -p tmp
<span class="gp">$</span> mv M.pcm tmp/M.pcm
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 Use.cpp -fmodule-file<span class="o">=</span>tmp/M.pcm
</pre></div>
</div>
<p>The above example would be accepted.</p>
<p>If the user doesn’t want to follow the consistency requirement due to some reasons (e.g., distributing BMI),
the user could try to use <code class="docutils literal notranslate"><span class="pre">-Xclang</span> <span class="pre">-fmodules-embed-all-files</span></code> when producing BMI. For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 M.cppm --precompile -Xclang -fmodules-embed-all-files -o M.pcm
<span class="gp">$</span> rm M.cppm
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 Use.cpp -fmodule-file<span class="o">=</span>M.pcm
</pre></div>
</div>
<p>Now the compiler would accept the above example.
Important note: Xclang options are intended to be used by compiler internally and its semantics
are not guaranteed to be preserved in future versions.</p>
<p>Also the compiler will record the path to the header files included in the global module fragment and compare the
headers when imported. For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// foo.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">Hello</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Hello World.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// foo.cppm</span>
<span class="n">module</span><span class="p">;</span>
<span class="cp">#include</span> <span class="cpf">&quot;foo.h&quot;</span><span class="cp"></span>
<span class="k">export</span> <span class="n">module</span> <span class="n">foo</span><span class="p">;</span>
<span class="k">export</span> <span class="k">using</span> <span class="o">::</span><span class="n">Hello</span><span class="p">;</span>

<span class="c1">// Use.cpp</span>
<span class="n">import</span> <span class="n">foo</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Hello</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then it is problematic if we remove <code class="docutils literal notranslate"><span class="pre">foo.h</span></code> before import <cite>foo</cite> module.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 foo.cppm --precompile  -o foo.pcm
<span class="gp">$</span> mv foo.h foo.orig.h
<span class="gp">#</span> The following one is rejected
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 Use.cpp -fmodule-file<span class="o">=</span>foo.pcm -c
</pre></div>
</div>
<p>The above case will rejected. And we’re still able to workaround it by <code class="docutils literal notranslate"><span class="pre">-Xclang</span> <span class="pre">-fmodules-embed-all-files</span></code> option:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 foo.cppm --precompile  -Xclang -fmodules-embed-all-files -o foo.pcm
<span class="gp">$</span> mv foo.h foo.orig.h
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 Use.cpp -fmodule-file<span class="o">=</span>foo.pcm -c -o Use.o
<span class="gp">$</span> clang++ Use.o foo.pcm
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="abi-impacts">
<h3><a class="toc-backref" href="#id24">ABI Impacts</a><a class="headerlink" href="#abi-impacts" title="Permalink to this headline">¶</a></h3>
<p>The declarations in a module unit which are not in the global module fragment have new linkage names.</p>
<p>For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">export</span> <span class="n">module</span> <span class="n">M</span><span class="p">;</span>
<span class="k">namespace</span> <span class="n">NS</span> <span class="p">{</span>
  <span class="k">export</span> <span class="kt">int</span> <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The linkage name of <code class="docutils literal notranslate"><span class="pre">NS::foo()</span></code> would be <code class="docutils literal notranslate"><span class="pre">_ZN2NSW1M3fooEv</span></code>.
This couldn’t be demangled by previous versions of the debugger or demangler.
As of LLVM 15.x, users can utilize <code class="docutils literal notranslate"><span class="pre">llvm-cxxfilt</span></code> to demangle this:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> llvm-cxxfilt _ZN2NSW1M3fooEv
</pre></div>
</div>
<p>The result would be <code class="docutils literal notranslate"><span class="pre">NS::foo&#64;M()</span></code>, which reads as <code class="docutils literal notranslate"><span class="pre">NS::foo()</span></code> in module <code class="docutils literal notranslate"><span class="pre">M</span></code>.</p>
<p>The ABI implies that we can’t declare something in a module unit and define it in a non-module unit (or vice-versa),
as this would result in linking errors.</p>
</div>
<div class="section" id="known-problems">
<h3><a class="toc-backref" href="#id25">Known Problems</a><a class="headerlink" href="#known-problems" title="Permalink to this headline">¶</a></h3>
<p>The following describes issues in the current implementation of modules.
Please see <a class="reference external" href="https://github.com/llvm/llvm-project/labels/clang%3Amodules">https://github.com/llvm/llvm-project/labels/clang%3Amodules</a> for more issues
or file a new issue if you don’t find an existing one.
If you’re going to create a new issue for standard C++ modules,
please start the title with <code class="docutils literal notranslate"><span class="pre">[C++20]</span> <span class="pre">[Modules]</span></code> (or <code class="docutils literal notranslate"><span class="pre">[C++2b]</span> <span class="pre">[Modules]</span></code>, etc)
and add the label <code class="docutils literal notranslate"><span class="pre">clang:modules</span></code> (if you have permissions for that).</p>
<p>For higher level support for proposals, you could visit <a class="reference external" href="https://clang.llvm.org/cxx_status.html">https://clang.llvm.org/cxx_status.html</a>.</p>
<div class="section" id="support-for-clang-scan-deps">
<h4><a class="toc-backref" href="#id26">Support for clang-scan-deps</a><a class="headerlink" href="#support-for-clang-scan-deps" title="Permalink to this headline">¶</a></h4>
<p>The support for clang-scan-deps may be the most urgent problem for modules now.
Without the support for clang-scan-deps, it’s hard to involve build systems.
This means that users could only play with modules through makefiles or by writing a parser by hand.
It blocks more uses for modules, which will block more defect reports or requirements.</p>
<p>This is tracked in: <a class="reference external" href="https://github.com/llvm/llvm-project/issues/51792">https://github.com/llvm/llvm-project/issues/51792</a>.</p>
</div>
<div class="section" id="ambiguous-deduction-guide">
<h4><a class="toc-backref" href="#id27">Ambiguous deduction guide</a><a class="headerlink" href="#ambiguous-deduction-guide" title="Permalink to this headline">¶</a></h4>
<p>Currently, when we call deduction guides in global module fragment,
we may get incorrect diagnosing message like: <cite>ambiguous deduction</cite>.</p>
<p>So if we’re using deduction guide from global module fragment, we probably need to write:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</pre></div>
</div>
<p>instead of</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span> <span class="n">lk</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</pre></div>
</div>
<p>This is tracked in: <a class="reference external" href="https://github.com/llvm/llvm-project/issues/56916">https://github.com/llvm/llvm-project/issues/56916</a></p>
</div>
<div class="section" id="ignored-preferredname-attribute">
<h4><a class="toc-backref" href="#id28">Ignored PreferredName Attribute</a><a class="headerlink" href="#ignored-preferredname-attribute" title="Permalink to this headline">¶</a></h4>
<p>Due to a tricky problem, when Clang writes BMIs, Clang will ignore the <code class="docutils literal notranslate"><span class="pre">preferred_name</span></code> attribute, if any.
This implies that the <code class="docutils literal notranslate"><span class="pre">preferred_name</span></code> wouldn’t show in debugger or dumping.</p>
<p>This is tracked in: <a class="reference external" href="https://github.com/llvm/llvm-project/issues/56490">https://github.com/llvm/llvm-project/issues/56490</a></p>
</div>
<div class="section" id="don-t-emit-macros-about-module-declaration">
<h4><a class="toc-backref" href="#id29">Don’t emit macros about module declaration</a><a class="headerlink" href="#don-t-emit-macros-about-module-declaration" title="Permalink to this headline">¶</a></h4>
<p>This is covered by P1857R3. We mention it again here since users may abuse it before we implement it.</p>
<p>Someone may want to write code which could be compiled both by modules or non-modules.
A direct idea would be use macros like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MODULE</span>
<span class="n">IMPORT</span> <span class="n">header_name</span>
<span class="n">EXPORT_MODULE</span> <span class="n">MODULE_NAME</span><span class="p">;</span>
<span class="n">IMPORT</span> <span class="n">header_name</span>
<span class="n">EXPORT</span> <span class="p">...</span>
</pre></div>
</div>
<p>So this file could be triggered like a module unit or a non-module unit depending on the definition
of some macros.
However, this kind of usage is forbidden by P1857R3 but we haven’t implemented P1857R3 yet.
This means that is possible to write illegal modules code now, and obviously this will stop working
once P1857R3 is implemented.
A simple suggestion would be “Don’t play macro tricks with module declarations”.</p>
<p>This is tracked in: <a class="reference external" href="https://github.com/llvm/llvm-project/issues/56917">https://github.com/llvm/llvm-project/issues/56917</a></p>
</div>
<div class="section" id="in-consistent-filename-suffix-requirement-for-importable-module-units">
<h4><a class="toc-backref" href="#id30">In consistent filename suffix requirement for importable module units</a><a class="headerlink" href="#in-consistent-filename-suffix-requirement-for-importable-module-units" title="Permalink to this headline">¶</a></h4>
<p>Currently, clang requires the file name of an <code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code> should end with <code class="docutils literal notranslate"><span class="pre">.cppm</span></code>
(or <code class="docutils literal notranslate"><span class="pre">.ccm</span></code>, <code class="docutils literal notranslate"><span class="pre">.cxxm</span></code>, <code class="docutils literal notranslate"><span class="pre">.c++m</span></code>). However, the behavior is inconsistent with other compilers.</p>
<p>This is tracked in: <a class="reference external" href="https://github.com/llvm/llvm-project/issues/57416">https://github.com/llvm/llvm-project/issues/57416</a></p>
</div>
</div>
</div>
<div class="section" id="header-units">
<h2><a class="toc-backref" href="#id31">Header Units</a><a class="headerlink" href="#header-units" title="Permalink to this headline">¶</a></h2>
<div class="section" id="how-to-build-projects-using-header-unit">
<h3><a class="toc-backref" href="#id32">How to build projects using header unit</a><a class="headerlink" href="#how-to-build-projects-using-header-unit" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id3">
<h4><a class="toc-backref" href="#id33">Quick Start</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>For the following example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">import</span> <span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Hello World.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>we could compile it as</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 -xc++-system-header --precompile iostream -o iostream.pcm
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 -fmodule-file<span class="o">=</span>iostream.pcm main.cpp
</pre></div>
</div>
</div>
<div class="section" id="how-to-produce-bmis">
<h4><a class="toc-backref" href="#id34">How to produce BMIs</a><a class="headerlink" href="#how-to-produce-bmis" title="Permalink to this headline">¶</a></h4>
<p>Similar to named modules, we could use <code class="docutils literal notranslate"><span class="pre">--precompile</span></code> to produce the BMI.
But we need to specify that the input file is a header by <code class="docutils literal notranslate"><span class="pre">-xc++-system-header</span></code> or <code class="docutils literal notranslate"><span class="pre">-xc++-user-header</span></code>.</p>
<p>Also we could use <cite>-fmodule-header={user,system}</cite> option to produce the BMI for header units
which has suffix like <cite>.h</cite> or <cite>.hh</cite>.
The value of <cite>-fmodule-header</cite> means the user search path or the system search path.
The default value for <cite>-fmodule-header</cite> is <cite>user</cite>.
For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// foo.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">Hello</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Hello World.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// use.cpp</span>
<span class="n">import</span> <span class="s">&quot;foo.h&quot;</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Hello</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We could compile it as:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 -fmodule-header foo.h -o foo.pcm
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 -fmodule-file<span class="o">=</span>foo.pcm use.cpp
</pre></div>
</div>
<p>For headers which don’t have a suffix, we need to pass <code class="docutils literal notranslate"><span class="pre">-xc++-header</span></code>
(or <code class="docutils literal notranslate"><span class="pre">-xc++-system-header</span></code> or <code class="docutils literal notranslate"><span class="pre">-xc++-user-header</span></code>) to mark it as a header.
For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// use.cpp</span>
<span class="n">import</span> <span class="s">&quot;foo.h&quot;</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Hello</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 -fmodule-header<span class="o">=</span>system -xc++-header iostream -o iostream.pcm
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 -fmodule-file<span class="o">=</span>iostream.pcm use.cpp
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4><a class="toc-backref" href="#id35">How to specify the dependent BMIs</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>We could use <code class="docutils literal notranslate"><span class="pre">-fmodule-file</span></code> to specify the BMIs, and this option may occur multiple times as well.</p>
<p>With the existing implementation <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code> cannot be used for header units
(since they are nominally anonymous).
For header units, use  <code class="docutils literal notranslate"><span class="pre">-fmodule-file</span></code> to include the relevant PCM file for each header unit.</p>
<p>This is expect to be solved in future editions of the compiler either by the tooling finding and specifying
the -fmodule-file or by the use of a module-mapper that understands how to map the header name to their PCMs.</p>
</div>
<div class="section" id="don-t-compile-the-bmi">
<h4><a class="toc-backref" href="#id36">Don’t compile the BMI</a><a class="headerlink" href="#don-t-compile-the-bmi" title="Permalink to this headline">¶</a></h4>
<p>Another difference with modules is that we can’t compile the BMI from a header unit.
For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 -xc++-system-header --precompile iostream -o iostream.pcm
<span class="gp">#</span> This is not allowed!
<span class="gp">$</span> clang++ iostream.pcm -c -o iostream.o
</pre></div>
</div>
<p>It makes sense due to the semantics of header units, which are just like headers.</p>
</div>
<div class="section" id="include-translation">
<h4><a class="toc-backref" href="#id37">Include translation</a><a class="headerlink" href="#include-translation" title="Permalink to this headline">¶</a></h4>
<p>The C++ spec allows the vendors to convert <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">header-name</span></code> to <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">header-name;</span></code> when possible.
Currently, Clang would do this translation for the <code class="docutils literal notranslate"><span class="pre">#include</span></code> in the global module fragment.</p>
<p>For example, the following two examples are the same:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">module</span><span class="p">;</span>
<span class="n">import</span> <span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">export</span> <span class="n">module</span> <span class="n">M</span><span class="p">;</span>
<span class="k">export</span> <span class="kt">void</span> <span class="nf">Hello</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Hello.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>with the following one:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">module</span><span class="p">;</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="k">export</span> <span class="n">module</span> <span class="n">M</span><span class="p">;</span>
<span class="k">export</span> <span class="kt">void</span> <span class="nf">Hello</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Hello.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 -xc++-system-header --precompile iostream -o iostream.pcm
<span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 -fmodule-file<span class="o">=</span>iostream.pcm --precompile M.cppm -o M.cpp
</pre></div>
</div>
<p>In the latter example, the Clang could find the BMI for the <code class="docutils literal notranslate"><span class="pre">&lt;iostream&gt;</span></code>
so it would try to replace the <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;iostream&gt;</span></code> to <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">&lt;iostream&gt;;</span></code> automatically.</p>
</div>
</div>
<div class="section" id="relationships-between-clang-modules">
<h3><a class="toc-backref" href="#id38">Relationships between Clang modules</a><a class="headerlink" href="#relationships-between-clang-modules" title="Permalink to this headline">¶</a></h3>
<p>Header units have pretty similar semantics with Clang modules.
The semantics of both of them are like headers.</p>
<p>In fact, we could even “mimic” the sytle of header units by Clang modules:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="s">&quot;iostream&quot;</span> <span class="p">{</span>
  <span class="k">export</span> <span class="o">*</span>
  <span class="n">header</span> <span class="s">&quot;/path/to/libstdcxx/iostream&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 -fimplicit-modules -fmodule-map-file<span class="o">=</span>.modulemap main.cpp
</pre></div>
</div>
<p>It would be simpler if we are using libcxx:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> clang++ -std<span class="o">=</span>c++20 main.cpp -fimplicit-modules -fimplicit-module-maps
</pre></div>
</div>
<p>Since there is already one
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/module.modulemap.in">module map</a>
in the source of libcxx.</p>
<p>Then immediately leads to the question: why don’t we implement header units through Clang header modules?</p>
<p>The main reason for this is that Clang modules have more semantics like hierarchy or
wrapping multiple headers together as a big module.
However, these things are not part of Standard C++ Header units,
and we want to avoid the impression that these additional semantics get interpreted as Standard C++ behavior.</p>
<p>Another reason is that there are proposals to introduce module mappers to the C++ standard
(for example, <a class="reference external" href="https://wg21.link/p1184r2">https://wg21.link/p1184r2</a>).
If we decide to reuse Clang’s modulemap, we may get in trouble once we need to introduce another module mapper.</p>
<p>So the final answer for why we don’t reuse the interface of Clang modules for header units is that
there are some differences between header units and Clang modules and that ignoring those
differences now would likely become a problem in the future.</p>
</div>
</div>
<div class="section" id="possible-questions">
<h2><a class="toc-backref" href="#id39">Possible Questions</a><a class="headerlink" href="#possible-questions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="how-modules-speed-up-compilation">
<h3><a class="toc-backref" href="#id40">How modules speed up compilation</a><a class="headerlink" href="#how-modules-speed-up-compilation" title="Permalink to this headline">¶</a></h3>
<p>A classic theory for the reason why modules speed up the compilation is:
if there are <code class="docutils literal notranslate"><span class="pre">n</span></code> headers and <code class="docutils literal notranslate"><span class="pre">m</span></code> source files and each header is included by each source file,
then the complexity of the compilation is <code class="docutils literal notranslate"><span class="pre">O(n*m)</span></code>;
But if there are <code class="docutils literal notranslate"><span class="pre">n</span></code> module interfaces and <code class="docutils literal notranslate"><span class="pre">m</span></code> source files, the complexity of the compilation is
<code class="docutils literal notranslate"><span class="pre">O(n+m)</span></code>. So, using modules would be a big win when scaling.
In a simpler word, we could get rid of many redundant compilations by using modules.</p>
<p>Roughly, this theory is correct. But the problem is that it is too rough.
The behavior depends on the optimization level, as we will illustrate below.</p>
<p>First is <code class="docutils literal notranslate"><span class="pre">O0</span></code>. The compilation process is described in the following graph.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>├-------------frontend----------┼-------------middle end----------------┼----backend----┤
│                               │                                       │               │
└---parsing----sema----codegen--┴----- transformations ---- codegen ----┴---- codegen --┘

┌---------------------------------------------------------------------------------------┐
|                                                                                       │
|                                     source file                                       │
|                                                                                       │
└---------------------------------------------------------------------------------------┘

            ┌--------┐
            │        │
            │imported│
            │        │
            │  code  │
            │        │
            └--------┘
</pre></div>
</div>
<p>Here we can see that the source file (could be a non-module unit or a module unit) would get processed by the
whole pipeline.
But the imported code would only get involved in semantic analysis, which is mainly about name lookup,
overload resolution and template instantiation.
All of these processes are fast relative to the whole compilation process.
More importantly, the imported code only needs to be processed once in frontend code generation,
as well as the whole middle end and backend.
So we could get a big win for the compilation time in O0.</p>
<p>But with optimizations, things are different:</p>
<p>(we omit <code class="docutils literal notranslate"><span class="pre">code</span> <span class="pre">generation</span></code> part for each end due to the limited space)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>├-------- frontend ---------┼--------------- middle end --------------------┼------ backend ----┤
│                           │                                               │                   │
└--- parsing ---- sema -----┴--- optimizations --- IPO ---- optimizations---┴--- optimizations -┘

┌-----------------------------------------------------------------------------------------------┐
│                                                                                               │
│                                         source file                                           │
│                                                                                               │
└-----------------------------------------------------------------------------------------------┘
              ┌---------------------------------------┐
              │                                       │
              │                                       │
              │            imported code              │
              │                                       │
              │                                       │
              └---------------------------------------┘
</pre></div>
</div>
<p>It would be very unfortunate if we end up with worse performance after using modules.
The main concern is that when we compile a source file, the compiler needs to see the function body
of imported module units so that it can perform IPO (InterProcedural Optimization, primarily inlining
in practice) to optimize functions in current source file with the help of the information provided by
the imported module units.
In other words, the imported code would be processed again and again in importee units
by optimizations (including IPO itself).
The optimizations before IPO and the IPO itself are the most time-consuming part in whole compilation process.
So from this perspective, we might not be able to get the improvements described in the theory.
But we could still save the time for optimizations after IPO and the whole backend.</p>
<p>Overall, at <code class="docutils literal notranslate"><span class="pre">O0</span></code> the implementations of functions defined in a module will not impact module users,
but at higher optimization levels the definitions of such functions are provided to user compilations for the
purposes of optimization (but definitions of these functions are still not included in the use’s object file)-
this means the build speedup at higher optimization levels may be lower than expected given <code class="docutils literal notranslate"><span class="pre">O0</span></code> experience,
but does provide by more optimization opportunities.</p>
</div>
<div class="section" id="interoperability-with-clang-modules">
<h3><a class="toc-backref" href="#id41">Interoperability with Clang Modules</a><a class="headerlink" href="#interoperability-with-clang-modules" title="Permalink to this headline">¶</a></h3>
<p>We <strong>wish</strong> to support clang modules and standard c++ modules at the same time,
but the mixed using form is not well used/tested yet.</p>
<p>Please file new github issues as you find interoperability problems.</p>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="SourceBasedCodeCoverage.html">Source-based Code Coverage</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="Modules.html">Modules</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2007-2023, The Clang Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.2.
    </div>
  </body>
</html>