
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Machine IR (MIR) Format Reference Manual &#8212; LLVM 21.1.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/llvm-theme.css?v=96924833" />
    <script src="_static/documentation_options.js?v=56ca4867"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Using -opt-bisect-limit to debug optimization errors" href="OptBisect.html" />
    <link rel="prev" title="LLVM’s Optional Rich Disassembly Output" href="MarkedUpDisassembly.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="OptBisect.html" title="Using -opt-bisect-limit to debug optimization errors"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="MarkedUpDisassembly.html" title="LLVM’s Optional Rich Disassembly Output"
             accesskey="P">previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="Reference.html" accesskey="U">Reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Machine IR (MIR) Format Reference Manual</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="https://llvm.org/docs/UserGuides.html">User Guides</a></li>
    <li><a href="https://llvm.org/docs/Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/Contributing.html">Contributing to LLVM</a></li>
    <li><a href="https://llvm.org/docs/HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#discord">Discord</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/FAQ.html">FAQ</a></li>
    <li><a href="https://llvm.org/docs/Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project/">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/MIRLangRef.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="machine-ir-mir-format-reference-manual">
<h1>Machine IR (MIR) Format Reference Manual<a class="headerlink" href="#machine-ir-mir-format-reference-manual" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id11">Introduction</a></p></li>
<li><p><a class="reference internal" href="#overview" id="id12">Overview</a></p></li>
<li><p><a class="reference internal" href="#mir-testing-guide" id="id13">MIR Testing Guide</a></p>
<ul>
<li><p><a class="reference internal" href="#testing-individual-code-generation-passes" id="id14">Testing Individual Code Generation Passes</a></p>
<ul>
<li><p><a class="reference internal" href="#simplifying-mir-files" id="id15">Simplifying MIR files</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#limitations" id="id16">Limitations</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#high-level-structure" id="id17">High Level Structure</a></p>
<ul>
<li><p><a class="reference internal" href="#embedded-module" id="id18">Embedded Module</a></p></li>
<li><p><a class="reference internal" href="#machine-functions" id="id19">Machine Functions</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#machine-instructions-format-reference" id="id20">Machine Instructions Format Reference</a></p>
<ul>
<li><p><a class="reference internal" href="#machine-basic-blocks" id="id21">Machine Basic Blocks</a></p>
<ul>
<li><p><a class="reference internal" href="#block-references" id="id22">Block References</a></p></li>
<li><p><a class="reference internal" href="#successors" id="id23">Successors</a></p></li>
<li><p><a class="reference internal" href="#live-in-registers" id="id24">Live In Registers</a></p></li>
<li><p><a class="reference internal" href="#miscellaneous-attributes" id="id25">Miscellaneous Attributes</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#machine-instructions" id="id26">Machine Instructions</a></p>
<ul>
<li><p><a class="reference internal" href="#instruction-flags" id="id27">Instruction Flags</a></p></li>
<li><p><a class="reference internal" href="#bundled-instructions" id="id28">Bundled Instructions</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#mir-registers" id="id29">Registers</a></p></li>
<li><p><a class="reference internal" href="#machine-operands" id="id30">Machine Operands</a></p>
<ul>
<li><p><a class="reference internal" href="#immediate-operands" id="id31">Immediate Operands</a></p></li>
<li><p><a class="reference internal" href="#register-operands" id="id32">Register Operands</a></p>
<ul>
<li><p><a class="reference internal" href="#register-flags" id="id33">Register Flags</a></p></li>
<li><p><a class="reference internal" href="#subregister-indices" id="id34">Subregister Indices</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#constant-pool-indices" id="id35">Constant Pool Indices</a></p></li>
<li><p><a class="reference internal" href="#global-value-operands" id="id36">Global Value Operands</a></p></li>
<li><p><a class="reference internal" href="#target-dependent-index-operands" id="id37">Target-dependent Index Operands</a></p></li>
<li><p><a class="reference internal" href="#jump-table-index-operands" id="id38">Jump-table Index Operands</a></p></li>
<li><p><a class="reference internal" href="#external-symbol-operands" id="id39">External Symbol Operands</a></p></li>
<li><p><a class="reference internal" href="#mcsymbol-operands" id="id40">MCSymbol Operands</a></p></li>
<li><p><a class="reference internal" href="#debug-instruction-reference-operands" id="id41">Debug Instruction Reference Operands</a></p></li>
<li><p><a class="reference internal" href="#cfiindex-operands" id="id42">CFIIndex Operands</a></p></li>
<li><p><a class="reference internal" href="#intrinsicid-operands" id="id43">IntrinsicID Operands</a></p></li>
<li><p><a class="reference internal" href="#predicate-operands" id="id44">Predicate Operands</a></p></li>
<li><p><a class="reference internal" href="#comments" id="id45">Comments</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#debug-info-constructs" id="id46">Debug-Info constructs</a></p>
<ul>
<li><p><a class="reference internal" href="#source-locations" id="id47">Source locations</a></p></li>
<li><p><a class="reference internal" href="#fixed-variable-locations" id="id48">Fixed variable locations</a></p></li>
<li><p><a class="reference internal" href="#varying-variable-locations" id="id49">Varying variable locations</a></p></li>
<li><p><a class="reference internal" href="#instruction-referencing-locations" id="id50">Instruction referencing locations</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is a work in progress.</p>
</div>
<section id="introduction">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>This document is a reference manual for the Machine IR (MIR) serialization
format. MIR is a human readable serialization format that is used to represent
LLVM’s <a class="reference internal" href="CodeGenerator.html#machine-code-representation"><span class="std std-ref">machine specific intermediate representation</span></a>.</p>
<p>The MIR serialization format is designed to be used for testing the code
generation passes in LLVM.</p>
</section>
<section id="overview">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">Overview</a><a class="headerlink" href="#overview" title="Link to this heading">¶</a></h2>
<p>The MIR serialization format uses a YAML container. YAML is a standard
data serialization language, and the full YAML language spec can be read at
<a class="reference external" href="http://www.yaml.org/spec/1.2/spec.html#Introduction">yaml.org</a>.</p>
<p>A MIR file is split up into a series of <a class="reference external" href="http://www.yaml.org/spec/1.2/spec.html#id2800132">YAML documents</a>. The first document
can contain an optional embedded LLVM IR module, and the rest of the documents
contain the serialized machine functions.</p>
</section>
<section id="mir-testing-guide">
<h2><a class="toc-backref" href="#id13" role="doc-backlink">MIR Testing Guide</a><a class="headerlink" href="#mir-testing-guide" title="Link to this heading">¶</a></h2>
<p>You can use the MIR format for testing in two different ways:</p>
<ul class="simple">
<li><p>You can write MIR tests that invoke a single code generation pass using the
<code class="docutils literal notranslate"><span class="pre">-run-pass</span></code> option in llc.</p></li>
<li><p>You can use llc’s <code class="docutils literal notranslate"><span class="pre">-stop-after</span></code> option with existing or new LLVM assembly
tests and check the MIR output of a specific code generation pass.</p></li>
</ul>
<section id="testing-individual-code-generation-passes">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Testing Individual Code Generation Passes</a><a class="headerlink" href="#testing-individual-code-generation-passes" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">-run-pass</span></code> option in llc allows you to create MIR tests that invoke just
a single code generation pass. When this option is used, llc will parse an
input MIR file, run the specified code generation pass(es), and output the
resulting MIR code.</p>
<p>You can generate an input MIR file for the test by using the <code class="docutils literal notranslate"><span class="pre">-stop-after</span></code> or
<code class="docutils literal notranslate"><span class="pre">-stop-before</span></code> option in llc. For example, if you would like to write a test
for the post register allocation pseudo instruction expansion pass, you can
specify the machine copy propagation pass in the <code class="docutils literal notranslate"><span class="pre">-stop-after</span></code> option, as it
runs just before the pass that we are trying to test:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-stop-after=machine-cp</span> <span class="pre">bug-trigger.ll</span> <span class="pre">-o</span> <span class="pre">test.mir</span></code></p>
</div></blockquote>
<p>If the same pass is run multiple times, a run index can be included
after the name with a comma.</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-stop-after=dead-mi-elimination,1</span> <span class="pre">bug-trigger.ll</span> <span class="pre">-o</span> <span class="pre">test.mir</span></code></p>
</div></blockquote>
<p>After generating the input MIR file, you’ll have to add a run line that uses
the <code class="docutils literal notranslate"><span class="pre">-run-pass</span></code> option to it. In order to test the post register allocation
pseudo instruction expansion pass on X86-64, a run line like the one shown
below can be used:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">RUN:</span> <span class="pre">llc</span> <span class="pre">-o</span> <span class="pre">-</span> <span class="pre">%s</span> <span class="pre">-mtriple=x86_64--</span> <span class="pre">-run-pass=postrapseudos</span> <span class="pre">|</span> <span class="pre">FileCheck</span> <span class="pre">%s</span></code></p>
</div></blockquote>
<p>The MIR files are target dependent, so they have to be placed in the target
specific test directories (<code class="docutils literal notranslate"><span class="pre">lib/CodeGen/TARGETNAME</span></code>). They also need to
specify a target triple or a target architecture either in the run line or in
the embedded LLVM IR module.</p>
<section id="simplifying-mir-files">
<h4><a class="toc-backref" href="#id15" role="doc-backlink">Simplifying MIR files</a><a class="headerlink" href="#simplifying-mir-files" title="Link to this heading">¶</a></h4>
<p>The MIR code coming out of <code class="docutils literal notranslate"><span class="pre">-stop-after</span></code>/<code class="docutils literal notranslate"><span class="pre">-stop-before</span></code> is very verbose;
Tests are more accessible and future proof when simplified:</p>
<ul class="simple">
<li><p>Use the <code class="docutils literal notranslate"><span class="pre">-simplify-mir</span></code> option with llc.</p></li>
<li><p>Machine function attributes often have default values or the test works just
as well with default values. Typical candidates for this are: <cite>alignment:</cite>,
<cite>exposesReturnsTwice</cite>, <cite>legalized</cite>, <cite>regBankSelected</cite>, <cite>selected</cite>.
The whole <cite>frameInfo</cite> section is often unnecessary if there is no special
frame usage in the function. <cite>tracksRegLiveness</cite> on the other hand is often
necessary for some passes that care about block livein lists.</p></li>
<li><p>The (global) <cite>liveins:</cite> list is typically only interesting for early
instruction selection passes and can be removed when testing later passes.
The per-block <cite>liveins:</cite> on the other hand are necessary if
<cite>tracksRegLiveness</cite> is true.</p></li>
<li><p>Branch probability data in block <cite>successors:</cite> lists can be dropped if the
test doesn’t depend on it. Example:
<cite>successors: %bb.1(0x40000000), %bb.2(0x40000000)</cite> can be replaced with
<cite>successors: %bb.1, %bb.2</cite>.</p></li>
<li><p>MIR code contains a whole IR module. This is necessary because there are
no equivalents in MIR for global variables, references to external functions,
function attributes, metadata, debug info. Instead some MIR data references
the IR constructs. You can often remove them if the test doesn’t depend on
them.</p></li>
<li><p>Alias Analysis is performed on IR values. These are referenced by memory
operands in MIR. Example: <cite>:: (load 8 from %ir.foobar, !alias.scope !9)</cite>.
If the test doesn’t depend on (good) alias analysis the references can be
dropped: <cite>:: (load 8)</cite></p></li>
<li><p>MIR blocks can reference IR blocks for debug printing, profile information
or debug locations. Example: <cite>bb.42.myblock</cite> in MIR references the IR block
<cite>myblock</cite>. It is usually possible to drop the <cite>.myblock</cite> reference and simply
use <cite>bb.42</cite>.</p></li>
<li><p>If there are no memory operands or blocks referencing the IR then the
IR function can be replaced by a parameterless dummy function like
<cite>define &#64;func() { ret void }</cite>.</p></li>
<li><p>It is possible to drop the whole IR section of the MIR file if it only
contains dummy functions (see above). The .mir loader will create the
IR functions automatically in this case.</p></li>
</ul>
</section>
</section>
<section id="limitations">
<span id="id1"></span><h3><a class="toc-backref" href="#id16" role="doc-backlink">Limitations</a><a class="headerlink" href="#limitations" title="Link to this heading">¶</a></h3>
<p>Currently the MIR format has several limitations in terms of which state it
can serialize:</p>
<ul class="simple">
<li><p>The target-specific state in the target-specific <code class="docutils literal notranslate"><span class="pre">MachineFunctionInfo</span></code>
subclasses isn’t serialized at the moment.</p></li>
<li><p>The target-specific <code class="docutils literal notranslate"><span class="pre">MachineConstantPoolValue</span></code> subclasses (in the ARM and
SystemZ backends) aren’t serialized at the moment.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">MCSymbol</span></code> machine operands don’t support temporary or local symbols.</p></li>
<li><p>A lot of the state in <code class="docutils literal notranslate"><span class="pre">MachineModuleInfo</span></code> isn’t serialized - only the CFI
instructions and the variable debug information from MMI is serialized right
now.</p></li>
</ul>
<p>These limitations impose restrictions on what you can test with the MIR format.
For now, tests that would like to test some behaviour that depends on the state
of temporary or local <code class="docutils literal notranslate"><span class="pre">MCSymbol</span></code>  operands or the exception handling state in
MMI, can’t use the MIR format. As well as that, tests that test some behaviour
that depends on the state of the target specific <code class="docutils literal notranslate"><span class="pre">MachineFunctionInfo</span></code> or
<code class="docutils literal notranslate"><span class="pre">MachineConstantPoolValue</span></code> subclasses can’t use the MIR format at the moment.</p>
</section>
</section>
<section id="high-level-structure">
<h2><a class="toc-backref" href="#id17" role="doc-backlink">High Level Structure</a><a class="headerlink" href="#high-level-structure" title="Link to this heading">¶</a></h2>
<section id="embedded-module">
<span id="id2"></span><h3><a class="toc-backref" href="#id18" role="doc-backlink">Embedded Module</a><a class="headerlink" href="#embedded-module" title="Link to this heading">¶</a></h3>
<p>When the first YAML document contains a <a class="reference external" href="http://www.yaml.org/spec/1.2/spec.html#id2795688">YAML block literal string</a>, the MIR
parser will treat this string as an LLVM assembly language string that
represents an embedded LLVM IR module.
Here is an example of a YAML document that contains an LLVM module:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@inc</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv nv-Anonymous">%0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%x</span>
<span class="w">  </span><span class="nv nv-Anonymous">%1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv nv-Anonymous">%0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv nv-Anonymous">%1</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%x</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv nv-Anonymous">%1</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="machine-functions">
<h3><a class="toc-backref" href="#id19" role="doc-backlink">Machine Functions</a><a class="headerlink" href="#machine-functions" title="Link to this heading">¶</a></h3>
<p>The remaining YAML documents contain the machine functions. This is an example
of such YAML document:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>---
name:            inc
tracksRegLiveness: true
liveins:
  - { reg: &#39;$rdi&#39; }
callSites:
  - { bb: 0, offset: 3, fwdArgRegs:
      - { arg: 0, reg: &#39;$edi&#39; } }
body: |
  bb.0.entry:
    liveins: $rdi

    $eax = MOV32rm $rdi, 1, _, 0, _
    $eax = INC32r killed $eax, implicit-def dead $eflags
    MOV32mr killed $rdi, 1, _, 0, _, $eax
    CALL64pcrel32 @foo &lt;regmask...&gt;
    RETQ $eax
...
</pre></div>
</div>
<p>The document above consists of attributes that represent the various
properties and data structures in a machine function.</p>
<p>The attribute <code class="docutils literal notranslate"><span class="pre">name</span></code> is required, and its value should be identical to the
name of a function that this machine function is based on.</p>
<p>The attribute <code class="docutils literal notranslate"><span class="pre">body</span></code> is a <a class="reference external" href="http://www.yaml.org/spec/1.2/spec.html#id2795688">YAML block literal string</a>. Its value represents
the function’s machine basic blocks and their machine instructions.</p>
<p>The attribute <code class="docutils literal notranslate"><span class="pre">callSites</span></code> is a representation of call site information which
keeps track of call instructions and registers used to transfer call arguments.</p>
</section>
</section>
<section id="machine-instructions-format-reference">
<h2><a class="toc-backref" href="#id20" role="doc-backlink">Machine Instructions Format Reference</a><a class="headerlink" href="#machine-instructions-format-reference" title="Link to this heading">¶</a></h2>
<p>The machine basic blocks and their instructions are represented using a custom,
human readable serialization language. This language is used in the
<a class="reference external" href="http://www.yaml.org/spec/1.2/spec.html#id2795688">YAML block literal string</a> that corresponds to the machine function’s body.</p>
<p>A source string that uses this language contains a list of machine basic
blocks, which are described in the section below.</p>
<section id="machine-basic-blocks">
<h3><a class="toc-backref" href="#id21" role="doc-backlink">Machine Basic Blocks</a><a class="headerlink" href="#machine-basic-blocks" title="Link to this heading">¶</a></h3>
<p>A machine basic block is defined in a single block definition source construct
that contains the block’s ID.
The example below defines two blocks that have an ID of zero and one:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>bb.0:
  &lt;instructions&gt;
bb.1:
  &lt;instructions&gt;
</pre></div>
</div>
<p>A machine basic block can also have a name. It should be specified after the ID
in the block’s definition:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>bb.0.entry:       ; This block&#39;s name is &quot;entry&quot;
   &lt;instructions&gt;
</pre></div>
</div>
<p>The block’s name should be identical to the name of the IR block that this
machine block is based on.</p>
<section id="block-references">
<span id="id3"></span><h4><a class="toc-backref" href="#id22" role="doc-backlink">Block References</a><a class="headerlink" href="#block-references" title="Link to this heading">¶</a></h4>
<p>The machine basic blocks are identified by their ID numbers. Individual
blocks are referenced using the following syntax:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>%bb.&lt;id&gt;
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv">%bb.0</span>
</pre></div>
</div>
<p>The following syntax is also supported, but the former syntax is preferred for
block references:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>%bb.&lt;id&gt;[.&lt;name&gt;]
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv">%bb.1.then</span>
</pre></div>
</div>
</section>
<section id="successors">
<h4><a class="toc-backref" href="#id23" role="doc-backlink">Successors</a><a class="headerlink" href="#successors" title="Link to this heading">¶</a></h4>
<p>The machine basic block’s successors have to be specified before any of the
instructions:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>bb.0.entry:
  successors: %bb.1.then, %bb.2.else
  &lt;instructions&gt;
bb.1.then:
  &lt;instructions&gt;
bb.2.else:
  &lt;instructions&gt;
</pre></div>
</div>
<p>The branch weights can be specified in brackets after the successor blocks.
The example below defines a block that has two successors with branch weights
of 32 and 16:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>bb.0.entry:
  successors: %bb.1.then(32), %bb.2.else(16)
</pre></div>
</div>
</section>
<section id="live-in-registers">
<span id="bb-liveins"></span><h4><a class="toc-backref" href="#id24" role="doc-backlink">Live In Registers</a><a class="headerlink" href="#live-in-registers" title="Link to this heading">¶</a></h4>
<p>The machine basic block’s live in registers have to be specified before any of
the instructions:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>bb.0.entry:
  liveins: $edi, $esi
</pre></div>
</div>
<p>The list of live in registers and successors can be empty. The language also
allows multiple live in register and successor lists - they are combined into
one list by the parser.</p>
</section>
<section id="miscellaneous-attributes">
<h4><a class="toc-backref" href="#id25" role="doc-backlink">Miscellaneous Attributes</a><a class="headerlink" href="#miscellaneous-attributes" title="Link to this heading">¶</a></h4>
<p>The attributes <code class="docutils literal notranslate"><span class="pre">IsAddressTaken</span></code>, <code class="docutils literal notranslate"><span class="pre">IsLandingPad</span></code>,
<code class="docutils literal notranslate"><span class="pre">IsInlineAsmBrIndirectTarget</span></code> and <code class="docutils literal notranslate"><span class="pre">Alignment</span></code> can be specified in brackets
after the block’s definition:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>bb.0.entry (address-taken):
  &lt;instructions&gt;
bb.2.else (align 4):
  &lt;instructions&gt;
bb.3(landing-pad, align 4):
  &lt;instructions&gt;
bb.4 (inlineasm-br-indirect-target):
  &lt;instructions&gt;
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Alignment</span></code> is specified in bytes, and must be a power of two.</p>
</section>
</section>
<section id="machine-instructions">
<span id="mir-instructions"></span><h3><a class="toc-backref" href="#id26" role="doc-backlink">Machine Instructions</a><a class="headerlink" href="#machine-instructions" title="Link to this heading">¶</a></h3>
<p>A machine instruction is composed of a name,
<a class="reference internal" href="#machine-operands"><span class="std std-ref">machine operands</span></a>,
<a class="reference internal" href="#instruction-flags"><span class="std std-ref">instruction flags</span></a>, and machine memory operands.</p>
<p>The instruction’s name is usually specified before the operands. The example
below shows an instance of the X86 <code class="docutils literal notranslate"><span class="pre">RETQ</span></code> instruction with a single machine
operand:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>RETQ $eax
</pre></div>
</div>
<p>However, if the machine instruction has one or more explicitly defined register
operands, the instruction’s name has to be specified after them. The example
below shows an instance of the AArch64 <code class="docutils literal notranslate"><span class="pre">LDPXpost</span></code> instruction with three
defined register operands:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$sp, $fp, $lr = LDPXpost $sp, 2
</pre></div>
</div>
<p>The instruction names are serialized using the exact definitions from the
target’s <code class="docutils literal notranslate"><span class="pre">*InstrInfo.td</span></code> files, and they are case sensitive. This means that
similar instruction names like <code class="docutils literal notranslate"><span class="pre">TSTri</span></code> and <code class="docutils literal notranslate"><span class="pre">tSTRi</span></code> represent different
machine instructions.</p>
<section id="instruction-flags">
<span id="id4"></span><h4><a class="toc-backref" href="#id27" role="doc-backlink">Instruction Flags</a><a class="headerlink" href="#instruction-flags" title="Link to this heading">¶</a></h4>
<p>The flag <code class="docutils literal notranslate"><span class="pre">frame-setup</span></code> or <code class="docutils literal notranslate"><span class="pre">frame-destroy</span></code> can be specified before the
instruction’s name:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$fp = frame-setup ADDXri $sp, 0, 0
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$x21, $x20 = frame-destroy LDPXi $sp
</pre></div>
</div>
</section>
<section id="bundled-instructions">
<span id="registers"></span><h4><a class="toc-backref" href="#id28" role="doc-backlink">Bundled Instructions</a><a class="headerlink" href="#bundled-instructions" title="Link to this heading">¶</a></h4>
<p>The syntax for bundled instructions is the following:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>BUNDLE implicit-def $r0, implicit-def $r1, implicit $r2 {
  $r0 = SOME_OP $r2
  $r1 = ANOTHER_OP internal $r0
}
</pre></div>
</div>
<p>The first instruction is often a bundle header. The instructions between <code class="docutils literal notranslate"><span class="pre">{</span></code>
and <code class="docutils literal notranslate"><span class="pre">}</span></code> are bundled with the first instruction.</p>
</section>
</section>
<section id="mir-registers">
<span id="id5"></span><h3><a class="toc-backref" href="#id29" role="doc-backlink">Registers</a><a class="headerlink" href="#mir-registers" title="Link to this heading">¶</a></h3>
<p>Registers are one of the key primitives in the machine instructions
serialization language. They are primarily used in the
<a class="reference internal" href="#register-operands"><span class="std std-ref">register machine operands</span></a>,
but they can also be used in a number of other places, like the
<a class="reference internal" href="#bb-liveins"><span class="std std-ref">basic block’s live in list</span></a>.</p>
<p>The physical registers are identified by their name and by the ‘$’ prefix sigil.
They use the following syntax:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$&lt;name&gt;
</pre></div>
</div>
<p>The example below shows three X86 physical registers:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$eax
$r15
$eflags
</pre></div>
</div>
<p>The virtual registers are identified by their ID number and by the ‘%’ sigil.
They use the following syntax:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>%&lt;id&gt;
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>%0
</pre></div>
</div>
<p>The null registers are represented using an underscore (’<code class="docutils literal notranslate"><span class="pre">_</span></code>’). They can also be
represented using a ‘<code class="docutils literal notranslate"><span class="pre">$noreg</span></code>’ named register, although the former syntax
is preferred.</p>
</section>
<section id="machine-operands">
<span id="id6"></span><h3><a class="toc-backref" href="#id30" role="doc-backlink">Machine Operands</a><a class="headerlink" href="#machine-operands" title="Link to this heading">¶</a></h3>
<p>There are eighteen different kinds of machine operands, and all of them can be
serialized.</p>
<section id="immediate-operands">
<h4><a class="toc-backref" href="#id31" role="doc-backlink">Immediate Operands</a><a class="headerlink" href="#immediate-operands" title="Link to this heading">¶</a></h4>
<p>The immediate machine operands are untyped, 64-bit signed integers. The
example below shows an instance of the X86 <code class="docutils literal notranslate"><span class="pre">MOV32ri</span></code> instruction that has an
immediate machine operand <code class="docutils literal notranslate"><span class="pre">-42</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$eax = MOV32ri -42
</pre></div>
</div>
<p>An immediate operand is also used to represent a subregister index when the
machine instruction has one of the following opcodes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">EXTRACT_SUBREG</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">INSERT_SUBREG</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">REG_SEQUENCE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SUBREG_TO_REG</span></code></p></li>
</ul>
<p>In case this is true, the Machine Operand is printed according to the target.</p>
<p>For example:</p>
<p>In AArch64RegisterInfo.td:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def sub_32 : SubRegIndex&lt;32&gt;;
</pre></div>
</div>
<p>If the third operand is an immediate with the value <code class="docutils literal notranslate"><span class="pre">15</span></code> (target-dependent
value), based on the instruction’s opcode and the operand’s index the operand
will be printed as <code class="docutils literal notranslate"><span class="pre">%subreg.sub_32</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>%1:gpr64 = SUBREG_TO_REG 0, %0, %subreg.sub_32
</pre></div>
</div>
<p>For integers &gt; 64bit, we use a special machine operand, <code class="docutils literal notranslate"><span class="pre">MO_CImmediate</span></code>,
which stores the immediate in a <code class="docutils literal notranslate"><span class="pre">ConstantInt</span></code> using an <code class="docutils literal notranslate"><span class="pre">APInt</span></code> (LLVM’s
arbitrary precision integers).</p>
</section>
<section id="register-operands">
<span id="id7"></span><h4><a class="toc-backref" href="#id32" role="doc-backlink">Register Operands</a><a class="headerlink" href="#register-operands" title="Link to this heading">¶</a></h4>
<p>The <a class="reference internal" href="#registers"><span class="std std-ref">register</span></a> primitive is used to represent the register
machine operands. The register operands can also have optional
<a class="reference internal" href="#register-flags"><span class="std std-ref">register flags</span></a>,
<a class="reference internal" href="#subregister-indices"><span class="std std-ref">a subregister index</span></a>,
and a reference to the tied register operand.
The full syntax of a register operand is shown below:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>[&lt;flags&gt;] &lt;register&gt; [ :&lt;subregister-idx-name&gt; ] [ (tied-def &lt;tied-op&gt;) ]
</pre></div>
</div>
<p>This example shows an instance of the X86 <code class="docutils literal notranslate"><span class="pre">XOR32rr</span></code> instruction that has
5 register operands with different register flags:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>dead $eax = XOR32rr undef $eax, undef $eax, implicit-def dead $eflags, implicit-def $al
</pre></div>
</div>
<section id="register-flags">
<span id="id8"></span><h5><a class="toc-backref" href="#id33" role="doc-backlink">Register Flags</a><a class="headerlink" href="#register-flags" title="Link to this heading">¶</a></h5>
<p>The table below shows all of the possible register flags along with the
corresponding internal <code class="docutils literal notranslate"><span class="pre">llvm::RegState</span></code> representation:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Flag</p></th>
<th class="head"><p>Internal Value</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">implicit</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">RegState::Implicit</span></code></p></td>
<td><p>Not emitted register (e.g. carry, or temporary result).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">implicit-def</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">RegState::ImplicitDefine</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">implicit</span></code> and <code class="docutils literal notranslate"><span class="pre">def</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">def</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">RegState::Define</span></code></p></td>
<td><p>Register definition.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">dead</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">RegState::Dead</span></code></p></td>
<td><p>Unused definition.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">killed</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">RegState::Kill</span></code></p></td>
<td><p>The last use of a register.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">undef</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">RegState::Undef</span></code></p></td>
<td><p>Value of the register doesn’t matter.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">internal</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">RegState::InternalRead</span></code></p></td>
<td><p>Register reads a value that is defined inside the same instruction or bundle.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">early-clobber</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">RegState::EarlyClobber</span></code></p></td>
<td><p>Register definition happens before uses.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">debug-use</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">RegState::Debug</span></code></p></td>
<td><p>Register ‘use’ is for debugging purpose.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">renamable</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">RegState::Renamable</span></code></p></td>
<td><p>Register that may be renamed.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="subregister-indices">
<span id="id9"></span><h5><a class="toc-backref" href="#id34" role="doc-backlink">Subregister Indices</a><a class="headerlink" href="#subregister-indices" title="Link to this heading">¶</a></h5>
<p>The register machine operands can reference a portion of a register by using
the subregister indices. The example below shows an instance of the <code class="docutils literal notranslate"><span class="pre">COPY</span></code>
pseudo instruction that uses the X86 <code class="docutils literal notranslate"><span class="pre">sub_8bit</span></code> subregister index to copy 8
lower bits from the 32-bit virtual register 0 to the 8-bit virtual register 1:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>%1 = COPY %0:sub_8bit
</pre></div>
</div>
<p>The names of the subregister indices are target specific, and are typically
defined in the target’s <code class="docutils literal notranslate"><span class="pre">*RegisterInfo.td</span></code> file.</p>
</section>
</section>
<section id="constant-pool-indices">
<h4><a class="toc-backref" href="#id35" role="doc-backlink">Constant Pool Indices</a><a class="headerlink" href="#constant-pool-indices" title="Link to this heading">¶</a></h4>
<p>A constant pool index (CPI) operand is printed using its index in the
function’s <code class="docutils literal notranslate"><span class="pre">MachineConstantPool</span></code> and an offset.</p>
<p>For example, a CPI with the index 1 and offset 8:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>%1:gr64 = MOV64ri %const.1 + 8
</pre></div>
</div>
<p>For a CPI with the index 0 and offset -12:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>%1:gr64 = MOV64ri %const.0 - 12
</pre></div>
</div>
<p>A constant pool entry is bound to a LLVM IR <code class="docutils literal notranslate"><span class="pre">Constant</span></code> or a target-specific
<code class="docutils literal notranslate"><span class="pre">MachineConstantPoolValue</span></code>. When serializing all the function’s constants the
following format is used:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>constants:
  - id:               &lt;index&gt;
    value:            &lt;value&gt;
    alignment:        &lt;alignment&gt;
    isTargetSpecific: &lt;target-specific&gt;
</pre></div>
</div>
<dl class="simple">
<dt>where:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;index&gt;</span></code> is a 32-bit unsigned integer;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;value&gt;</span></code> is a <a class="reference external" href="https://www.llvm.org/docs/LangRef.html#constants">LLVM IR Constant</a>;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;alignment&gt;</span></code> is a 32-bit unsigned integer specified in bytes, and must be
power of two;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;target-specific&gt;</span></code> is either true or false.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>constants:
  - id:               0
    value:            &#39;double 3.250000e+00&#39;
    alignment:        8
  - id:               1
    value:            &#39;g-(LPC0+8)&#39;
    alignment:        4
    isTargetSpecific: true
</pre></div>
</div>
</section>
<section id="global-value-operands">
<h4><a class="toc-backref" href="#id36" role="doc-backlink">Global Value Operands</a><a class="headerlink" href="#global-value-operands" title="Link to this heading">¶</a></h4>
<p>The global value machine operands reference the global values from the
<a class="reference internal" href="#embedded-module"><span class="std std-ref">embedded LLVM IR module</span></a>.
The example below shows an instance of the X86 <code class="docutils literal notranslate"><span class="pre">MOV64rm</span></code> instruction that has
a global value operand named <code class="docutils literal notranslate"><span class="pre">G</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$rax = MOV64rm $rip, 1, _, @G, _
</pre></div>
</div>
<p>The named global values are represented using an identifier with the ‘&#64;’ prefix.
If the identifier doesn’t match the regular expression
<cite>[-a-zA-Z$._][-a-zA-Z$._0-9]*</cite>, then this identifier must be quoted.</p>
<p>The unnamed global values are represented using an unsigned numeric value with
the ‘&#64;’ prefix, like in the following examples: <code class="docutils literal notranslate"><span class="pre">&#64;0</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;989</span></code>.</p>
</section>
<section id="target-dependent-index-operands">
<h4><a class="toc-backref" href="#id37" role="doc-backlink">Target-dependent Index Operands</a><a class="headerlink" href="#target-dependent-index-operands" title="Link to this heading">¶</a></h4>
<p>A target index operand is a target-specific index and an offset. The
target-specific index is printed using target-specific names and a positive or
negative offset.</p>
<p>For example, the <code class="docutils literal notranslate"><span class="pre">amdgpu-constdata-start</span></code> is associated with the index <code class="docutils literal notranslate"><span class="pre">0</span></code>
in the AMDGPU backend. So if we have a target index operand with the index 0
and the offset 8:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$sgpr2 = S_ADD_U32 _, target-index(amdgpu-constdata-start) + 8, implicit-def _, implicit-def _
</pre></div>
</div>
</section>
<section id="jump-table-index-operands">
<h4><a class="toc-backref" href="#id38" role="doc-backlink">Jump-table Index Operands</a><a class="headerlink" href="#jump-table-index-operands" title="Link to this heading">¶</a></h4>
<p>A jump-table index operand with the index 0 is printed as following:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>tBR_JTr killed $r0, %jump-table.0
</pre></div>
</div>
<p>A machine jump-table entry contains a list of <code class="docutils literal notranslate"><span class="pre">MachineBasicBlocks</span></code>. When serializing all the function’s jump-table entries, the following format is used:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>jumpTable:
  kind:             &lt;kind&gt;
  entries:
    - id:             &lt;index&gt;
      blocks:         [ &lt;bbreference&gt;, &lt;bbreference&gt;, ... ]
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">&lt;kind&gt;</span></code> is describing how the jump table is represented and emitted (plain address, relocations, PIC, etc.), and each <code class="docutils literal notranslate"><span class="pre">&lt;index&gt;</span></code> is a 32-bit unsigned integer and <code class="docutils literal notranslate"><span class="pre">blocks</span></code> contains a list of <a class="reference internal" href="#block-references"><span class="std std-ref">machine basic block references</span></a>.</p>
<p>Example:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>jumpTable:
  kind:             inline
  entries:
    - id:             0
      blocks:         [ &#39;%bb.3&#39;, &#39;%bb.9&#39;, &#39;%bb.4.d3&#39; ]
    - id:             1
      blocks:         [ &#39;%bb.7&#39;, &#39;%bb.7&#39;, &#39;%bb.4.d3&#39;, &#39;%bb.5&#39; ]
</pre></div>
</div>
</section>
<section id="external-symbol-operands">
<h4><a class="toc-backref" href="#id39" role="doc-backlink">External Symbol Operands</a><a class="headerlink" href="#external-symbol-operands" title="Link to this heading">¶</a></h4>
<p>An external symbol operand is represented using an identifier with the <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>
prefix. The identifier is surrounded with ““‘s and escaped if it has any
special non-printable characters in it.</p>
<p>Example:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>CALL64pcrel32 &amp;__stack_chk_fail, csr_64, implicit $rsp, implicit-def $rsp
</pre></div>
</div>
</section>
<section id="mcsymbol-operands">
<h4><a class="toc-backref" href="#id40" role="doc-backlink">MCSymbol Operands</a><a class="headerlink" href="#mcsymbol-operands" title="Link to this heading">¶</a></h4>
<p>A MCSymbol operand is holding a pointer to a <code class="docutils literal notranslate"><span class="pre">MCSymbol</span></code>. For the limitations
of this operand in MIR, see <a class="reference internal" href="#limitations"><span class="std std-ref">limitations</span></a>.</p>
<p>The syntax is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>EH_LABEL &lt;mcsymbol Ltmp1&gt;
</pre></div>
</div>
</section>
<section id="debug-instruction-reference-operands">
<h4><a class="toc-backref" href="#id41" role="doc-backlink">Debug Instruction Reference Operands</a><a class="headerlink" href="#debug-instruction-reference-operands" title="Link to this heading">¶</a></h4>
<p>A debug instruction reference operand is a pair of indices, referring to an
instruction and an operand within that instruction respectively; see
<a class="reference internal" href="#instruction-referencing-locations"><span class="std std-ref">Instruction referencing locations</span></a>.</p>
<p>The example below uses a reference to Instruction 1, Operand 0:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DBG_INSTR_REF !123, !DIExpression(DW_OP_LLVM_arg, 0), dbg-instr-ref(1, 0), debug-location !456
</pre></div>
</div>
</section>
<section id="cfiindex-operands">
<h4><a class="toc-backref" href="#id42" role="doc-backlink">CFIIndex Operands</a><a class="headerlink" href="#cfiindex-operands" title="Link to this heading">¶</a></h4>
<p>A CFI Index operand is holding an index into a per-function side-table,
<code class="docutils literal notranslate"><span class="pre">MachineFunction::getFrameInstructions()</span></code>, which references all the frame
instructions in a <code class="docutils literal notranslate"><span class="pre">MachineFunction</span></code>. A <code class="docutils literal notranslate"><span class="pre">CFI_INSTRUCTION</span></code> may look like it
contains multiple operands, but the only operand it contains is the CFI Index.
The other operands are tracked by the <code class="docutils literal notranslate"><span class="pre">MCCFIInstruction</span></code> object.</p>
<p>The syntax is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>CFI_INSTRUCTION offset $w30, -16
</pre></div>
</div>
<p>which may be emitted later in the MC layer as:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>.cfi_offset w30, -16
</pre></div>
</div>
</section>
<section id="intrinsicid-operands">
<h4><a class="toc-backref" href="#id43" role="doc-backlink">IntrinsicID Operands</a><a class="headerlink" href="#intrinsicid-operands" title="Link to this heading">¶</a></h4>
<p>An Intrinsic ID operand contains a generic intrinsic ID or a target-specific ID.</p>
<p>The syntax for the <code class="docutils literal notranslate"><span class="pre">returnaddress</span></code> intrinsic is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$x0 = COPY intrinsic(@llvm.returnaddress)
</pre></div>
</div>
</section>
<section id="predicate-operands">
<h4><a class="toc-backref" href="#id44" role="doc-backlink">Predicate Operands</a><a class="headerlink" href="#predicate-operands" title="Link to this heading">¶</a></h4>
<p>A Predicate operand contains an IR predicate from <code class="docutils literal notranslate"><span class="pre">CmpInst::Predicate</span></code>, like
<code class="docutils literal notranslate"><span class="pre">ICMP_EQ</span></code>, etc.</p>
<p>For an int eq predicate <code class="docutils literal notranslate"><span class="pre">ICMP_EQ</span></code>, the syntax is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>%2:gpr(s32) = G_ICMP intpred(eq), %0, %1
</pre></div>
</div>
</section>
<section id="comments">
<h4><a class="toc-backref" href="#id45" role="doc-backlink">Comments</a><a class="headerlink" href="#comments" title="Link to this heading">¶</a></h4>
<p>Machine operands can have C/C++ style comments, which are annotations enclosed
between <code class="docutils literal notranslate"><span class="pre">/*</span></code> and <code class="docutils literal notranslate"><span class="pre">*/</span></code> to improve readability of e.g. immediate operands.
In the example below, ARM instructions EOR and BCC and immediate operands
<code class="docutils literal notranslate"><span class="pre">14</span></code> and <code class="docutils literal notranslate"><span class="pre">0</span></code> have been annotated with their condition codes (CC)
definitions, i.e. the <code class="docutils literal notranslate"><span class="pre">always</span></code> and <code class="docutils literal notranslate"><span class="pre">eq</span></code> condition codes:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>dead renamable $r2, $cpsr = tEOR killed renamable $r2, renamable $r1, 14 /* CC::always */, $noreg
t2Bcc %bb.4, 0 /* CC:eq */, killed $cpsr
</pre></div>
</div>
<p>As these annotations are comments, they are ignored by the MI parser.
Comments can be added or customized by overriding InstrInfo’s hook
<code class="docutils literal notranslate"><span class="pre">createMIROperandComment()</span></code>.</p>
</section>
</section>
<section id="debug-info-constructs">
<h3><a class="toc-backref" href="#id46" role="doc-backlink">Debug-Info constructs</a><a class="headerlink" href="#debug-info-constructs" title="Link to this heading">¶</a></h3>
<p>Most of the debugging information in a MIR file is to be found in the metadata
of the embedded module. Within a machine function, that metadata is referred to
by various constructs to describe source locations and variable locations.</p>
<section id="source-locations">
<h4><a class="toc-backref" href="#id47" role="doc-backlink">Source locations</a><a class="headerlink" href="#source-locations" title="Link to this heading">¶</a></h4>
<p>Every MIR instruction may optionally have a trailing reference to a
<code class="docutils literal notranslate"><span class="pre">DILocation</span></code> metadata node, after all operands and symbols, but before
memory operands:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$rbp = MOV64rr $rdi, debug-location !12
</pre></div>
</div>
<p>The source location attachment is synonymous with the <code class="docutils literal notranslate"><span class="pre">!dbg</span></code> metadata
attachment in LLVM-IR. The absence of a source location attachment will be
represented by an empty <code class="docutils literal notranslate"><span class="pre">DebugLoc</span></code> object in the machine instruction.</p>
</section>
<section id="fixed-variable-locations">
<h4><a class="toc-backref" href="#id48" role="doc-backlink">Fixed variable locations</a><a class="headerlink" href="#fixed-variable-locations" title="Link to this heading">¶</a></h4>
<p>There are several ways of specifying variable locations. The simplest is
describing a variable that is permanently located on the stack. In the stack
or fixedStack attribute of the machine function, the variable, scope, and
any qualifying location modifier are provided:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>- { id: 0, name: offset.addr, offset: -24, size: 8, alignment: 8, stack-id: default,
 4  debug-info-variable: &#39;!1&#39;, debug-info-expression: &#39;!DIExpression()&#39;,
    debug-info-location: &#39;!2&#39; }
</pre></div>
</div>
<p>Where:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">debug-info-variable</span></code> identifies a DILocalVariable metadata node,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">debug-info-expression</span></code> adds qualifiers to the variable location,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">debug-info-location</span></code> identifies a DILocation metadata node.</p></li>
</ul>
<p>These metadata attributes correspond to the operands of a <code class="docutils literal notranslate"><span class="pre">#dbg_declare</span></code>
IR debug record, see the <a class="reference internal" href="SourceLevelDebugging.html#debug-records"><span class="std std-ref">source level
debugging</span></a> documentation.</p>
</section>
<section id="varying-variable-locations">
<h4><a class="toc-backref" href="#id49" role="doc-backlink">Varying variable locations</a><a class="headerlink" href="#varying-variable-locations" title="Link to this heading">¶</a></h4>
<p>Variables that are not always on the stack or change location are specified
with the <code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code>  meta machine instruction. It is synonymous with the
<code class="docutils literal notranslate"><span class="pre">#dbg_value</span></code> IR record, and is written:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DBG_VALUE $rax, $noreg, !123, !DIExpression(), debug-location !456
</pre></div>
</div>
<p>The operands to which respectively:</p>
<ol class="arabic simple">
<li><p>Identifies a machine location such as a register, immediate, or frame index,</p></li>
<li><p>Is either $noreg, or immediate value zero if an extra level of indirection is to be added to the first operand,</p></li>
<li><p>Identifies a <code class="docutils literal notranslate"><span class="pre">DILocalVariable</span></code> metadata node,</p></li>
<li><p>Specifies an expression qualifying the variable location, either inline or as a metadata node reference,</p></li>
</ol>
<p>While the source location identifies the <code class="docutils literal notranslate"><span class="pre">DILocation</span></code> for the scope of the
variable. The second operand (<code class="docutils literal notranslate"><span class="pre">IsIndirect</span></code>) is deprecated and to be deleted.
All additional qualifiers for the variable location should be made through the
expression metadata.</p>
</section>
<section id="instruction-referencing-locations">
<span id="id10"></span><h4><a class="toc-backref" href="#id50" role="doc-backlink">Instruction referencing locations</a><a class="headerlink" href="#instruction-referencing-locations" title="Link to this heading">¶</a></h4>
<p>This experimental feature aims to separate the specification of variable
<em>values</em> from the program point where a variable takes on that value. Changes
in variable value occur in the same manner as <code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code> meta instructions
but using <code class="docutils literal notranslate"><span class="pre">DBG_INSTR_REF</span></code>. Variable values are identified by a pair of
instruction number and operand number. Consider the example below:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$rbp = MOV64ri 0, debug-instr-number 1, debug-location !12
DBG_INSTR_REF !123, !DIExpression(DW_OP_LLVM_arg, 0), dbg-instr-ref(1, 0), debug-location !456
</pre></div>
</div>
<p>Instruction numbers are directly attached to machine instructions with an
optional <code class="docutils literal notranslate"><span class="pre">debug-instr-number</span></code> attachment, before the optional
<code class="docutils literal notranslate"><span class="pre">debug-location</span></code> attachment. The value defined in <code class="docutils literal notranslate"><span class="pre">$rbp</span></code> in the code
above would be identified by the pair <code class="docutils literal notranslate"><span class="pre">&lt;1,</span> <span class="pre">0&gt;</span></code>.</p>
<p>The 3rd operand of the <code class="docutils literal notranslate"><span class="pre">DBG_INSTR_REF</span></code> above records the instruction
and operand number <code class="docutils literal notranslate"><span class="pre">&lt;1,</span> <span class="pre">0&gt;</span></code>, identifying the value defined by the <code class="docutils literal notranslate"><span class="pre">MOV64ri</span></code>.
The first two operands to <code class="docutils literal notranslate"><span class="pre">DBG_INSTR_REF</span></code> are identical to <code class="docutils literal notranslate"><span class="pre">DBG_VALUE_LIST</span></code>,
and the <code class="docutils literal notranslate"><span class="pre">DBG_INSTR_REF</span></code> s position records where the variable takes on the
designated value in the same way.</p>
<p>More information about how these constructs are used is available in
<a class="reference internal" href="InstrRefDebugInfo.html"><span class="doc">Instruction referencing for debug info</span></a>. The related documents <a class="reference internal" href="SourceLevelDebugging.html"><span class="doc">Source Level Debugging with LLVM</span></a> and
<a class="reference internal" href="HowToUpdateDebugInfo.html"><span class="doc">How to Update Debug Info: A Guide for LLVM Pass Authors</span></a> may be useful as well.</p>
</section>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="OptBisect.html" title="Using -opt-bisect-limit to debug optimization errors"
             >next</a> |</li>
        <li class="right" >
          <a href="MarkedUpDisassembly.html" title="LLVM’s Optional Rich Disassembly Output"
             >previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="Reference.html" >Reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Machine IR (MIR) Format Reference Manual</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2003-2025, LLVM Project.
      Last updated on 2025-09-23.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>