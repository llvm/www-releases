

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>User Guide for AMDGPU Backend &#8212; LLVM 13 documentation</title>
    <link rel="stylesheet" href="_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Syntax of Core GFX7 Instructions" href="AMDGPU/AMDGPUAsmGFX7.html" />
    <link rel="prev" title="LLVM Alias Analysis Infrastructure" href="AliasAnalysis.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="AMDGPU/AMDGPUAsmGFX7.html" title="Syntax of Core GFX7 Instructions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="AliasAnalysis.html" title="LLVM Alias Analysis Infrastructure"
             accesskey="P">previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" accesskey="U">User Guides</a> &#187;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="https://llvm.org/docs/UserGuides.html">User Guides</a></li>
    <li><a href="https://llvm.org/docs/Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/Contributing.html">Contributing to LLVM</a></li>
    <li><a href="https://llvm.org/docs/HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#irc">IRC</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/FAQ.html">FAQ</a></li>
    <li><a href="https://llvm.org/docs/Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project//">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/AMDGPUUsage.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="user-guide-for-amdgpu-backend">
<h1>User Guide for AMDGPU Backend<a class="headerlink" href="#user-guide-for-amdgpu-backend" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id93">Introduction</a></p></li>
<li><p><a class="reference internal" href="#llvm" id="id94">LLVM</a></p>
<ul>
<li><p><a class="reference internal" href="#target-triples" id="id95">Target Triples</a></p></li>
<li><p><a class="reference internal" href="#processors" id="id96">Processors</a></p></li>
<li><p><a class="reference internal" href="#target-features" id="id97">Target Features</a></p></li>
<li><p><a class="reference internal" href="#target-id" id="id98">Target ID</a></p>
<ul>
<li><p><a class="reference internal" href="#code-object-v2-to-v3-target-id" id="id99">Code Object V2 to V3 Target ID</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#embedding-bundled-code-objects" id="id100">Embedding Bundled Code Objects</a></p></li>
<li><p><a class="reference internal" href="#address-spaces" id="id101">Address Spaces</a></p></li>
<li><p><a class="reference internal" href="#memory-scopes" id="id102">Memory Scopes</a></p></li>
<li><p><a class="reference internal" href="#llvm-ir-intrinsics" id="id103">LLVM IR Intrinsics</a></p></li>
<li><p><a class="reference internal" href="#llvm-ir-attributes" id="id104">LLVM IR Attributes</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#elf-code-object" id="id105">ELF Code Object</a></p>
<ul>
<li><p><a class="reference internal" href="#header" id="id106">Header</a></p></li>
<li><p><a class="reference internal" href="#sections" id="id107">Sections</a></p></li>
<li><p><a class="reference internal" href="#note-records" id="id108">Note Records</a></p>
<ul>
<li><p><a class="reference internal" href="#code-object-v2-note-records" id="id109">Code Object V2 Note Records</a></p></li>
<li><p><a class="reference internal" href="#code-object-v3-to-v4-note-records" id="id110">Code Object V3 to V4 Note Records</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#symbols" id="id111">Symbols</a></p></li>
<li><p><a class="reference internal" href="#relocation-records" id="id112">Relocation Records</a></p></li>
<li><p><a class="reference internal" href="#loaded-code-object-path-uniform-resource-identifier-uri" id="id113">Loaded Code Object Path Uniform Resource Identifier (URI)</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#dwarf-debug-information" id="id114">DWARF Debug Information</a></p>
<ul>
<li><p><a class="reference internal" href="#register-identifier" id="id115">Register Identifier</a></p></li>
<li><p><a class="reference internal" href="#address-class-identifier" id="id116">Address Class Identifier</a></p></li>
<li><p><a class="reference internal" href="#address-space-identifier" id="id117">Address Space Identifier</a></p></li>
<li><p><a class="reference internal" href="#lane-identifier" id="id118">Lane identifier</a></p></li>
<li><p><a class="reference internal" href="#operation-expressions" id="id119">Operation Expressions</a></p></li>
<li><p><a class="reference internal" href="#debugger-information-entry-attributes" id="id120">Debugger Information Entry Attributes</a></p>
<ul>
<li><p><a class="reference internal" href="#dw-at-llvm-lane-pc" id="id121"><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code></a></p></li>
<li><p><a class="reference internal" href="#dw-at-llvm-active-lane" id="id122"><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_active_lane</span></code></a></p></li>
<li><p><a class="reference internal" href="#dw-at-llvm-augmentation" id="id123"><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_augmentation</span></code></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#call-frame-information" id="id124">Call Frame Information</a></p></li>
<li><p><a class="reference internal" href="#accelerated-access" id="id125">Accelerated Access</a></p>
<ul>
<li><p><a class="reference internal" href="#lookup-by-name-section-header" id="id126">Lookup By Name Section Header</a></p></li>
<li><p><a class="reference internal" href="#lookup-by-address-section-header" id="id127">Lookup By Address Section Header</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#line-number-information" id="id128">Line Number Information</a></p></li>
<li><p><a class="reference internal" href="#bit-and-64-bit-dwarf-formats" id="id129">32-Bit and 64-Bit DWARF Formats</a></p></li>
<li><p><a class="reference internal" href="#unit-headers" id="id130">Unit Headers</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#code-conventions" id="id131">Code Conventions</a></p>
<ul>
<li><p><a class="reference internal" href="#amdhsa" id="id132">AMDHSA</a></p>
<ul>
<li><p><a class="reference internal" href="#code-object-metadata" id="id133">Code Object Metadata</a></p>
<ul>
<li><p><a class="reference internal" href="#code-object-v2-metadata" id="id134">Code Object V2 Metadata</a></p></li>
<li><p><a class="reference internal" href="#code-object-v3-metadata" id="id135">Code Object V3 Metadata</a></p></li>
<li><p><a class="reference internal" href="#code-object-v4-metadata" id="id136">Code Object V4 Metadata</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#kernel-dispatch" id="id137">Kernel Dispatch</a></p></li>
<li><p><a class="reference internal" href="#memory-spaces" id="id138">Memory Spaces</a></p></li>
<li><p><a class="reference internal" href="#image-and-samplers" id="id139">Image and Samplers</a></p></li>
<li><p><a class="reference internal" href="#hsa-signals" id="id140">HSA Signals</a></p></li>
<li><p><a class="reference internal" href="#hsa-aql-queue" id="id141">HSA AQL Queue</a></p></li>
<li><p><a class="reference internal" href="#kernel-descriptor" id="id142">Kernel Descriptor</a></p>
<ul>
<li><p><a class="reference internal" href="#code-object-v3-kernel-descriptor" id="id143">Code Object V3 Kernel Descriptor</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#initial-kernel-execution-state" id="id144">Initial Kernel Execution State</a></p></li>
<li><p><a class="reference internal" href="#kernel-prolog" id="id145">Kernel Prolog</a></p>
<ul>
<li><p><a class="reference internal" href="#cfi" id="id146">CFI</a></p></li>
<li><p><a class="reference internal" href="#m0" id="id147">M0</a></p></li>
<li><p><a class="reference internal" href="#stack-pointer" id="id148">Stack Pointer</a></p></li>
<li><p><a class="reference internal" href="#frame-pointer" id="id149">Frame Pointer</a></p></li>
<li><p><a class="reference internal" href="#flat-scratch" id="id150">Flat Scratch</a></p></li>
<li><p><a class="reference internal" href="#private-segment-buffer" id="id151">Private Segment Buffer</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#memory-model" id="id152">Memory Model</a></p>
<ul>
<li><p><a class="reference internal" href="#memory-model-gfx6-gfx9" id="id153">Memory Model GFX6-GFX9</a></p></li>
<li><p><a class="reference internal" href="#memory-model-gfx90a" id="id154">Memory Model GFX90A</a></p></li>
<li><p><a class="reference internal" href="#memory-model-gfx10" id="id155">Memory Model GFX10</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#trap-handler-abi" id="id156">Trap Handler ABI</a></p></li>
<li><p><a class="reference internal" href="#call-convention" id="id157">Call Convention</a></p>
<ul>
<li><p><a class="reference internal" href="#kernel-functions" id="id158">Kernel Functions</a></p></li>
<li><p><a class="reference internal" href="#non-kernel-functions" id="id159">Non-Kernel Functions</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#amdpal" id="id160">AMDPAL</a></p>
<ul>
<li><p><a class="reference internal" href="#amdgpu-amdpal-code-object-metadata-section" id="id161">Code Object Metadata</a></p>
<ul>
<li><p><a class="reference internal" href="#user-data" id="id162">User Data</a></p>
<ul>
<li><p><a class="reference internal" href="#per-shader-table" id="id163">Per-Shader Table</a></p></li>
<li><p><a class="reference internal" href="#spill-table" id="id164">Spill Table</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#unspecified-os" id="id165">Unspecified OS</a></p>
<ul>
<li><p><a class="reference internal" href="#id82" id="id166">Trap Handler ABI</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#source-languages" id="id167">Source Languages</a></p>
<ul>
<li><p><a class="reference internal" href="#opencl" id="id168">OpenCL</a></p></li>
<li><p><a class="reference internal" href="#hcc" id="id169">HCC</a></p></li>
<li><p><a class="reference internal" href="#assembler" id="id170">Assembler</a></p>
<ul>
<li><p><a class="reference internal" href="#instructions" id="id171">Instructions</a></p></li>
<li><p><a class="reference internal" href="#operands" id="id172">Operands</a></p></li>
<li><p><a class="reference internal" href="#modifiers" id="id173">Modifiers</a></p></li>
<li><p><a class="reference internal" href="#instruction-examples" id="id174">Instruction Examples</a></p>
<ul>
<li><p><a class="reference internal" href="#ds" id="id175">DS</a></p></li>
<li><p><a class="reference internal" href="#flat" id="id176">FLAT</a></p></li>
<li><p><a class="reference internal" href="#mubuf" id="id177">MUBUF</a></p></li>
<li><p><a class="reference internal" href="#smrd-smem" id="id178">SMRD/SMEM</a></p></li>
<li><p><a class="reference internal" href="#sop1" id="id179">SOP1</a></p></li>
<li><p><a class="reference internal" href="#sop2" id="id180">SOP2</a></p></li>
<li><p><a class="reference internal" href="#sopc" id="id181">SOPC</a></p></li>
<li><p><a class="reference internal" href="#sopp" id="id182">SOPP</a></p></li>
<li><p><a class="reference internal" href="#valu" id="id183">VALU</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#code-object-v2-predefined-symbols" id="id184">Code Object V2 Predefined Symbols</a></p>
<ul>
<li><p><a class="reference internal" href="#option-machine-version-major" id="id185">.option.machine_version_major</a></p></li>
<li><p><a class="reference internal" href="#option-machine-version-minor" id="id186">.option.machine_version_minor</a></p></li>
<li><p><a class="reference internal" href="#option-machine-version-stepping" id="id187">.option.machine_version_stepping</a></p></li>
<li><p><a class="reference internal" href="#kernel-vgpr-count" id="id188">.kernel.vgpr_count</a></p></li>
<li><p><a class="reference internal" href="#kernel-sgpr-count" id="id189">.kernel.sgpr_count</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#code-object-v2-directives" id="id190">Code Object V2 Directives</a></p>
<ul>
<li><p><a class="reference internal" href="#hsa-code-object-version-major-minor" id="id191">.hsa_code_object_version major, minor</a></p></li>
<li><p><a class="reference internal" href="#hsa-code-object-isa-major-minor-stepping-vendor-arch" id="id192">.hsa_code_object_isa [major, minor, stepping, vendor, arch]</a></p></li>
<li><p><a class="reference internal" href="#amdgpu-hsa-kernel-name" id="id193">.amdgpu_hsa_kernel (name)</a></p></li>
<li><p><a class="reference internal" href="#amd-kernel-code-t" id="id194">.amd_kernel_code_t</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#code-object-v2-example-source-code" id="id195">Code Object V2 Example Source Code</a></p></li>
<li><p><a class="reference internal" href="#code-object-v3-to-v4-predefined-symbols" id="id196">Code Object V3 to V4 Predefined Symbols</a></p>
<ul>
<li><p><a class="reference internal" href="#amdgcn-gfx-generation-number" id="id197">.amdgcn.gfx_generation_number</a></p></li>
<li><p><a class="reference internal" href="#amdgcn-gfx-generation-minor" id="id198">.amdgcn.gfx_generation_minor</a></p></li>
<li><p><a class="reference internal" href="#amdgcn-gfx-generation-stepping" id="id199">.amdgcn.gfx_generation_stepping</a></p></li>
<li><p><a class="reference internal" href="#amdgcn-next-free-vgpr" id="id200">.amdgcn.next_free_vgpr</a></p></li>
<li><p><a class="reference internal" href="#amdgcn-next-free-sgpr" id="id201">.amdgcn.next_free_sgpr</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#code-object-v3-to-v4-directives" id="id202">Code Object V3 to V4 Directives</a></p>
<ul>
<li><p><a class="reference internal" href="#amdgcn-target-target-triple-target-id" id="id203">.amdgcn_target &lt;target-triple&gt; “-” &lt;target-id&gt;</a></p></li>
<li><p><a class="reference internal" href="#amdhsa-kernel-name" id="id204">.amdhsa_kernel &lt;name&gt;</a></p></li>
<li><p><a class="reference internal" href="#amdgpu-metadata" id="id205">.amdgpu_metadata</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#code-object-v3-to-v4-example-source-code" id="id206">Code Object V3 to V4 Example Source Code</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#additional-documentation" id="id207">Additional Documentation</a></p></li>
</ul>
</div>
<div class="toctree-wrapper compound">
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id93">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The AMDGPU backend provides ISA code generation for AMD GPUs, starting with the
R600 family up until the current GCN families. It lives in the
<code class="docutils literal notranslate"><span class="pre">llvm/lib/Target/AMDGPU</span></code> directory.</p>
</div>
<div class="section" id="llvm">
<h2><a class="toc-backref" href="#id94">LLVM</a><a class="headerlink" href="#llvm" title="Permalink to this headline">¶</a></h2>
<div class="section" id="target-triples">
<span id="amdgpu-target-triples"></span><h3><a class="toc-backref" href="#id95">Target Triples</a><a class="headerlink" href="#target-triples" title="Permalink to this headline">¶</a></h3>
<p>Use the Clang option <code class="docutils literal notranslate"><span class="pre">-target</span> <span class="pre">&lt;Architecture&gt;-&lt;Vendor&gt;-&lt;OS&gt;-&lt;Environment&gt;</span></code>
to specify the target triple:</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-architecture-table">
<caption><span class="caption-text">AMDGPU Architectures</span><a class="headerlink" href="#amdgpu-architecture-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 16%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Architecture</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">r600</span></code></p></td>
<td><p>AMD GPUs HD2XXX-HD6XXX for graphics and compute shaders.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>AMD GPUs GCN GFX6 onwards for graphics and compute shaders.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="amdgpu-vendor-table">
<caption><span class="caption-text">AMDGPU Vendors</span><a class="headerlink" href="#amdgpu-vendor-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 16%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Vendor</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">amd</span></code></p></td>
<td><p>Can be used for all AMD GPU usage.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">mesa3d</span></code></p></td>
<td><p>Can be used if the OS is <code class="docutils literal notranslate"><span class="pre">mesa3d</span></code>.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="amdgpu-os">
<caption><span class="caption-text">AMDGPU Operating Systems</span><a class="headerlink" href="#amdgpu-os" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 19%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>OS</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>&lt;empty&gt;</em></p></td>
<td><p>Defaults to the <em>unknown</em> OS.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">amdhsa</span></code></p></td>
<td><p>Compute kernels executed on HSA <a class="reference internal" href="#hsa" id="id1"><span>[HSA]</span></a> compatible runtimes
such as:</p>
<ul class="simple">
<li><p>AMD’s ROCm™ runtime <a class="reference internal" href="#amd-rocm" id="id2"><span>[AMD-ROCm]</span></a> using the <em>rocm-amdhsa</em>
loader on Linux. See <em>AMD ROCm Platform Release Notes</em>
<a class="reference internal" href="#amd-rocm-release-notes" id="id3"><span>[AMD-ROCm-Release-Notes]</span></a> for supported hardware and
software.</p></li>
<li><p>AMD’s PAL runtime using the <em>pal-amdhsa</em> loader on
Windows.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">amdpal</span></code></p></td>
<td><p>Graphic shaders and compute kernels executed on AMD’s PAL
runtime using the <em>pal-amdpal</em> loader on Windows and Linux
Pro.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">mesa3d</span></code></p></td>
<td><p>Graphic shaders and compute kernels executed on AMD’s Mesa
3D runtime using the <em>mesa-mesa3d</em> loader on Linux.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="amdgpu-environment-table">
<caption><span class="caption-text">AMDGPU Environments</span><a class="headerlink" href="#amdgpu-environment-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 16%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Environment</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>&lt;empty&gt;</em></p></td>
<td><p>Default.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="processors">
<span id="amdgpu-processors"></span><h3><a class="toc-backref" href="#id96">Processors</a><a class="headerlink" href="#processors" title="Permalink to this headline">¶</a></h3>
<p>Use the Clang options <code class="docutils literal notranslate"><span class="pre">-mcpu=&lt;target-id&gt;</span></code> or <code class="docutils literal notranslate"><span class="pre">--offload-arch=&lt;target-id&gt;</span></code> to
specify the AMDGPU processor together with optional target features. See
<a class="reference internal" href="#amdgpu-target-id"><span class="std std-ref">Target ID</span></a> and <a class="reference internal" href="#amdgpu-target-features"><span class="std std-ref">Target Features</span></a> for AMD GPU target
specific information.</p>
<p>Every processor supports every OS ABI (see <a class="reference internal" href="#amdgpu-os"><span class="std std-ref">AMDGPU Operating Systems</span></a>) with the following exceptions:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">amdhsa</span></code> is not supported in <code class="docutils literal notranslate"><span class="pre">r600</span></code> architecture (see <a class="reference internal" href="#amdgpu-architecture-table"><span class="std std-ref">AMDGPU Architectures</span></a>).</p>
<table class="docutils align-default" id="amdgpu-processor-table">
<caption><span class="caption-text">AMDGPU Processors</span><a class="headerlink" href="#amdgpu-processor-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 9%" />
<col style="width: 12%" />
<col style="width: 10%" />
<col style="width: 4%" />
<col style="width: 14%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 26%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Processor</p></th>
<th class="head"><p>Alternative
Processor</p></th>
<th class="head"><p>Target
Triple
Architecture</p></th>
<th class="head"><p>dGPU/
APU</p></th>
<th class="head"><p>Target
Features
Supported</p></th>
<th class="head"><p>Target
Properties</p></th>
<th class="head"><p>OS Support
<em>(see</em>
<a class="reference internal" href="#amdgpu-os">amdgpu-os</a>
<em>and
corresponding
runtime release
notes for
current
information and
level of
support)</em></p></th>
<th class="head"><p>Example
Products</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td colspan="8"><p><strong>Radeon HD 2000/3000 Series (R600)</strong> <a class="reference internal" href="#amd-radeon-hd-2000-3000" id="id4"><span>[AMD-RADEON-HD-2000-3000]</span></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">r600</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r600</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Does not
support
generic
address
space</p></li>
</ul>
</td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">r630</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r600</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Does not
support
generic
address
space</p></li>
</ul>
</td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">rs880</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r600</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Does not
support
generic
address
space</p></li>
</ul>
</td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">rv670</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r600</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Does not
support
generic
address
space</p></li>
</ul>
</td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td colspan="8"><p><strong>Radeon HD 4000 Series (R700)</strong> <a class="reference internal" href="#amd-radeon-hd-4000" id="id5"><span>[AMD-RADEON-HD-4000]</span></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">rv710</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r600</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Does not
support
generic
address
space</p></li>
</ul>
</td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">rv730</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r600</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Does not
support
generic
address
space</p></li>
</ul>
</td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">rv770</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r600</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Does not
support
generic
address
space</p></li>
</ul>
</td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td colspan="8"><p><strong>Radeon HD 5000 Series (Evergreen)</strong> <a class="reference internal" href="#amd-radeon-hd-5000" id="id6"><span>[AMD-RADEON-HD-5000]</span></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cedar</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r600</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Does not
support
generic
address
space</p></li>
</ul>
</td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cypress</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r600</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Does not
support
generic
address
space</p></li>
</ul>
</td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">juniper</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r600</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Does not
support
generic
address
space</p></li>
</ul>
</td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">redwood</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r600</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Does not
support
generic
address
space</p></li>
</ul>
</td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sumo</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r600</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Does not
support
generic
address
space</p></li>
</ul>
</td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td colspan="8"><p><strong>Radeon HD 6000 Series (Northern Islands)</strong> <a class="reference internal" href="#amd-radeon-hd-6000" id="id7"><span>[AMD-RADEON-HD-6000]</span></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">barts</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r600</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Does not
support
generic
address
space</p></li>
</ul>
</td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">caicos</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r600</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Does not
support
generic
address
space</p></li>
</ul>
</td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cayman</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r600</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Does not
support
generic
address
space</p></li>
</ul>
</td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">turks</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r600</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Does not
support
generic
address
space</p></li>
</ul>
</td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td colspan="8"><p><strong>GCN GFX6 (Southern Islands (SI))</strong> <a class="reference internal" href="#amd-gcn-gfx6" id="id8"><span>[AMD-GCN-GFX6]</span></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">gfx600</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tahiti</span></code></p></li>
</ul>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Does not
support
generic
address
space</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">gfx601</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pitcairn</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verde</span></code></p></li>
</ul>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Does not
support
generic
address
space</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">gfx602</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hainan</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">oland</span></code></p></li>
</ul>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Does not
support
generic
address
space</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td></td>
</tr>
<tr class="row-even"><td colspan="8"><p><strong>GCN GFX7 (Sea Islands (CI))</strong> <a class="reference internal" href="#amd-gcn-gfx7" id="id9"><span>[AMD-GCN-GFX7]</span></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">gfx700</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">kaveri</span></code></p></li>
</ul>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>APU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Offset
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>rocm-amdhsa</em></p></li>
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>A6-7000</p></li>
<li><p>A6 Pro-7050B</p></li>
<li><p>A8-7100</p></li>
<li><p>A8 Pro-7150B</p></li>
<li><p>A10-7300</p></li>
<li><p>A10 Pro-7350B</p></li>
<li><p>FX-7500</p></li>
<li><p>A8-7200P</p></li>
<li><p>A10-7400P</p></li>
<li><p>FX-7600P</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">gfx701</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hawaii</span></code></p></li>
</ul>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Offset
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>rocm-amdhsa</em></p></li>
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>FirePro W8100</p></li>
<li><p>FirePro W9100</p></li>
<li><p>FirePro S9150</p></li>
<li><p>FirePro S9170</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">gfx702</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Offset
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>rocm-amdhsa</em></p></li>
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Radeon R9 290</p></li>
<li><p>Radeon R9 290x</p></li>
<li><p>Radeon R390</p></li>
<li><p>Radeon R390x</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">gfx703</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">kabini</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mullins</span></code></p></li>
</ul>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>APU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Offset
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>E1-2100</p></li>
<li><p>E1-2200</p></li>
<li><p>E1-2500</p></li>
<li><p>E2-3000</p></li>
<li><p>E2-3800</p></li>
<li><p>A4-5000</p></li>
<li><p>A4-5100</p></li>
<li><p>A6-5200</p></li>
<li><p>A4 Pro-3340B</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">gfx704</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bonaire</span></code></p></li>
</ul>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Offset
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Radeon HD 7790</p></li>
<li><p>Radeon HD 8770</p></li>
<li><p>R7 260</p></li>
<li><p>R7 260X</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">gfx705</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>APU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Offset
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><p><em>TBA</em></p>
</td>
</tr>
<tr class="row-odd"><td colspan="8"><p><strong>GCN GFX8 (Volcanic Islands (VI))</strong> <a class="reference internal" href="#amd-gcn-gfx8" id="id11"><span>[AMD-GCN-GFX8]</span></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">gfx801</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">carrizo</span></code></p></li>
</ul>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>APU</p></td>
<td><ul class="simple">
<li><p>xnack</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Offset
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>rocm-amdhsa</em></p></li>
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>A6-8500P</p></li>
<li><p>Pro A6-8500B</p></li>
<li><p>A8-8600P</p></li>
<li><p>Pro A8-8600B</p></li>
<li><p>FX-8800P</p></li>
<li><p>Pro A12-8800B</p></li>
<li><p>A10-8700P</p></li>
<li><p>Pro A10-8700B</p></li>
<li><p>A10-8780P</p></li>
<li><p>A10-9600P</p></li>
<li><p>A10-9630P</p></li>
<li><p>A12-9700P</p></li>
<li><p>A12-9730P</p></li>
<li><p>FX-9800P</p></li>
<li><p>FX-9830P</p></li>
<li><p>E2-9010</p></li>
<li><p>A6-9210</p></li>
<li><p>A9-9410</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">gfx802</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">iceland</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tonga</span></code></p></li>
</ul>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Offset
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>rocm-amdhsa</em></p></li>
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Radeon R9 285</p></li>
<li><p>Radeon R9 380</p></li>
<li><p>Radeon R9 385</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">gfx803</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fiji</span></code></p></li>
</ul>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td></td>
<td><ul class="simple">
<li><p><em>rocm-amdhsa</em></p></li>
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Radeon R9 Nano</p></li>
<li><p>Radeon R9 Fury</p></li>
<li><p>Radeon R9 FuryX</p></li>
<li><p>Radeon Pro Duo</p></li>
<li><p>FirePro S9300x2</p></li>
<li><p>Radeon Instinct MI8</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">polaris10</span></code></p></li>
</ul>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Offset
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>rocm-amdhsa</em></p></li>
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Radeon RX 470</p></li>
<li><p>Radeon RX 480</p></li>
<li><p>Radeon Instinct MI6</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">polaris11</span></code></p></li>
</ul>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Offset
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>rocm-amdhsa</em></p></li>
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Radeon RX 460</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">gfx805</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tongapro</span></code></p></li>
</ul>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>dGPU</p></td>
<td></td>
<td><ul class="simple">
<li><p>Offset
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>rocm-amdhsa</em></p></li>
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>FirePro S7150</p></li>
<li><p>FirePro S7100</p></li>
<li><p>FirePro W7100</p></li>
<li><p>Mobile FirePro
M7170</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">gfx810</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">stoney</span></code></p></li>
</ul>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>APU</p></td>
<td><ul class="simple">
<li><p>xnack</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Offset
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>rocm-amdhsa</em></p></li>
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><p><em>TBA</em></p>
</td>
</tr>
<tr class="row-odd"><td colspan="8"><p><strong>GCN GFX9 (Vega)</strong> <a class="reference internal" href="#amd-gcn-gfx900-gfx904-vega" id="id13"><span>[AMD-GCN-GFX900-GFX904-VEGA]</span></a> <a class="reference internal" href="#amd-gcn-gfx906-vega7nm" id="id14"><span>[AMD-GCN-GFX906-VEGA7NM]</span></a> <a class="reference internal" href="#amd-gcn-gfx908-cdna1" id="id15"><span>[AMD-GCN-GFX908-CDNA1]</span></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">gfx900</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>dGPU</p></td>
<td><ul class="simple">
<li><p>xnack</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Absolute
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>rocm-amdhsa</em></p></li>
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Radeon Vega
Frontier Edition</p></li>
<li><p>Radeon RX Vega 56</p></li>
<li><p>Radeon RX Vega 64</p></li>
<li><p>Radeon RX Vega 64
Liquid</p></li>
<li><p>Radeon Instinct MI25</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">gfx902</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>APU</p></td>
<td><ul class="simple">
<li><p>xnack</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Absolute
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>rocm-amdhsa</em></p></li>
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Ryzen 3 2200G</p></li>
<li><p>Ryzen 5 2400G</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">gfx904</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>dGPU</p></td>
<td><ul class="simple">
<li><p>xnack</p></li>
</ul>
</td>
<td></td>
<td><ul class="simple">
<li><p><em>rocm-amdhsa</em></p></li>
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><p><em>TBA</em></p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">gfx906</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>dGPU</p></td>
<td><ul class="simple">
<li><p>sramecc</p></li>
<li><p>xnack</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Absolute
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>rocm-amdhsa</em></p></li>
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Radeon Instinct MI50</p></li>
<li><p>Radeon Instinct MI60</p></li>
<li><p>Radeon VII</p></li>
<li><p>Radeon Pro VII</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">gfx908</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>dGPU</p></td>
<td><ul class="simple">
<li><p>sramecc</p></li>
<li><p>xnack</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Absolute
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>rocm-amdhsa</em></p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>AMD Instinct MI100 Accelerator</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">gfx909</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>APU</p></td>
<td><ul class="simple">
<li><p>xnack</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Absolute
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><p><em>TBA</em></p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">gfx90a</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>dGPU</p></td>
<td><ul class="simple">
<li><p>sramecc</p></li>
<li><p>tgsplit</p></li>
<li><p>xnack</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Absolute
flat
scratch</p></li>
<li><p>Packed
work-item
IDs</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>rocm-amdhsa</em></p></li>
</ul>
</td>
<td><p><em>TBA</em></p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">gfx90c</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>APU</p></td>
<td><ul class="simple">
<li><p>xnack</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Absolute
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Ryzen 7 4700G</p></li>
<li><p>Ryzen 7 4700GE</p></li>
<li><p>Ryzen 5 4600G</p></li>
<li><p>Ryzen 5 4600GE</p></li>
<li><p>Ryzen 3 4300G</p></li>
<li><p>Ryzen 3 4300GE</p></li>
<li><p>Ryzen Pro 4000G</p></li>
<li><p>Ryzen 7 Pro 4700G</p></li>
<li><p>Ryzen 7 Pro 4750GE</p></li>
<li><p>Ryzen 5 Pro 4650G</p></li>
<li><p>Ryzen 5 Pro 4650GE</p></li>
<li><p>Ryzen 3 Pro 4350G</p></li>
<li><p>Ryzen 3 Pro 4350GE</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td colspan="8"><p><strong>GCN GFX10 (RDNA 1)</strong> <a class="reference internal" href="#amd-gcn-gfx10-rdna1" id="id19"><span>[AMD-GCN-GFX10-RDNA1]</span></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">gfx1010</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>dGPU</p></td>
<td><ul class="simple">
<li><p>cumode</p></li>
<li><p>wavefrontsize64</p></li>
<li><p>xnack</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Absolute
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>rocm-amdhsa</em></p></li>
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Radeon RX 5700</p></li>
<li><p>Radeon RX 5700 XT</p></li>
<li><p>Radeon Pro 5600 XT</p></li>
<li><p>Radeon Pro 5600M</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">gfx1011</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>dGPU</p></td>
<td><ul class="simple">
<li><p>cumode</p></li>
<li><p>wavefrontsize64</p></li>
<li><p>xnack</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Absolute
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>rocm-amdhsa</em></p></li>
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Radeon Pro V520</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">gfx1012</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>dGPU</p></td>
<td><ul class="simple">
<li><p>cumode</p></li>
<li><p>wavefrontsize64</p></li>
<li><p>xnack</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Absolute
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>rocm-amdhsa</em></p></li>
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Radeon RX 5500</p></li>
<li><p>Radeon RX 5500 XT</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">gfx1013</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>APU</p></td>
<td><ul class="simple">
<li><p>cumode</p></li>
<li><p>wavefrontsize64</p></li>
<li><p>xnack</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Absolute
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>rocm-amdhsa</em></p></li>
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><p><em>TBA</em></p>
</td>
</tr>
<tr class="row-odd"><td colspan="8"><p><strong>GCN GFX10 (RDNA 2)</strong> <a class="reference internal" href="#amd-gcn-gfx10-rdna2" id="id21"><span>[AMD-GCN-GFX10-RDNA2]</span></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">gfx1030</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>dGPU</p></td>
<td><ul class="simple">
<li><p>cumode</p></li>
<li><p>wavefrontsize64</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Absolute
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>rocm-amdhsa</em></p></li>
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Radeon RX 6800</p></li>
<li><p>Radeon RX 6800 XT</p></li>
<li><p>Radeon RX 6900 XT</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">gfx1031</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>dGPU</p></td>
<td><ul class="simple">
<li><p>cumode</p></li>
<li><p>wavefrontsize64</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Absolute
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>rocm-amdhsa</em></p></li>
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Radeon RX 6700 XT</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">gfx1032</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>dGPU</p></td>
<td><ul class="simple">
<li><p>cumode</p></li>
<li><p>wavefrontsize64</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Absolute
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>rocm-amdhsa</em></p></li>
<li><p><em>pal-amdhsa</em></p></li>
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><p><em>TBA</em></p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">gfx1033</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>APU</p></td>
<td><ul class="simple">
<li><p>cumode</p></li>
<li><p>wavefrontsize64</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Absolute
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><p><em>TBA</em></p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">gfx1034</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>dGPU</p></td>
<td><ul class="simple">
<li><p>cumode</p></li>
<li><p>wavefrontsize64</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Absolute
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><p><em>TBA</em></p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">gfx1035</span></code></p></td>
<td></td>
<td><p><code class="docutils literal notranslate"><span class="pre">amdgcn</span></code></p></td>
<td><p>APU</p></td>
<td><ul class="simple">
<li><p>cumode</p></li>
<li><p>wavefrontsize64</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Absolute
flat
scratch</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p><em>pal-amdpal</em></p></li>
</ul>
</td>
<td><p><em>TBA</em></p>
</td>
</tr>
</tbody>
</table>
</li>
</ul>
</div>
<div class="section" id="target-features">
<span id="amdgpu-target-features"></span><h3><a class="toc-backref" href="#id97">Target Features</a><a class="headerlink" href="#target-features" title="Permalink to this headline">¶</a></h3>
<p>Target features control how code is generated to support certain
processor specific features. Not all target features are supported by
all processors. The runtime must ensure that the features supported by
the device used to execute the code match the features enabled when
generating the code. A mismatch of features may result in incorrect
execution, or a reduction in performance.</p>
<p>The target features supported by each processor is listed in
<a class="reference internal" href="#amdgpu-processor-table"><span class="std std-ref">AMDGPU Processors</span></a>.</p>
<p>Target features are controlled by exactly one of the following Clang
options:</p>
<p><code class="docutils literal notranslate"><span class="pre">-mcpu=&lt;target-id&gt;</span></code> or <code class="docutils literal notranslate"><span class="pre">--offload-arch=&lt;target-id&gt;</span></code></p>
<blockquote>
<div><p>The <code class="docutils literal notranslate"><span class="pre">-mcpu</span></code> and <code class="docutils literal notranslate"><span class="pre">--offload-arch</span></code> can specify the target feature as
optional components of the target ID. If omitted, the target feature has the
<code class="docutils literal notranslate"><span class="pre">any</span></code> value. See <a class="reference internal" href="#amdgpu-target-id"><span class="std std-ref">Target ID</span></a>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">-m[no-]&lt;target-feature&gt;</span></code></p>
<blockquote>
<div><p>Target features not specified by the target ID are specified using a
separate option. These target features can have an <code class="docutils literal notranslate"><span class="pre">on</span></code> or <code class="docutils literal notranslate"><span class="pre">off</span></code>
value.  <code class="docutils literal notranslate"><span class="pre">on</span></code> is specified by omitting the <code class="docutils literal notranslate"><span class="pre">no-</span></code> prefix, and
<code class="docutils literal notranslate"><span class="pre">off</span></code> is specified by including the <code class="docutils literal notranslate"><span class="pre">no-</span></code> prefix. The default
if not specified is <code class="docutils literal notranslate"><span class="pre">off</span></code>.</p>
</div></blockquote>
<p>For example:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">-mcpu=gfx908:xnack+</span></code></dt><dd><p>Enable the <code class="docutils literal notranslate"><span class="pre">xnack</span></code> feature.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-mcpu=gfx908:xnack-</span></code></dt><dd><p>Disable the <code class="docutils literal notranslate"><span class="pre">xnack</span></code> feature.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-mcumode</span></code></dt><dd><p>Enable the <code class="docutils literal notranslate"><span class="pre">cumode</span></code> feature.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-mno-cumode</span></code></dt><dd><p>Disable the <code class="docutils literal notranslate"><span class="pre">cumode</span></code> feature.</p>
<table class="docutils align-default" id="amdgpu-target-features-table">
<caption><span class="caption-text">AMDGPU Target Features</span><a class="headerlink" href="#amdgpu-target-features-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 16%" />
<col style="width: 30%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Target Feature</p></th>
<th class="head"><p>Clang Option to Control</p></th>
<th class="head"><p>Description</p></th>
</tr>
<tr class="row-even"><th class="head"><p>Name</p></th>
<th class="head"></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td><p>cumode</p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-m[no-]cumode</span></code></p></li>
</ul>
</td>
<td><p>Control the wavefront execution mode used
when generating code for kernels. When disabled
native WGP wavefront execution mode is used,
when enabled CU wavefront execution mode is used
(see <a class="reference internal" href="#amdgpu-amdhsa-memory-model"><span class="std std-ref">Memory Model</span></a>).</p></td>
</tr>
<tr class="row-even"><td><p>sramecc</p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-mcpu</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--offload-arch</span></code></p></li>
</ul>
</td>
<td><p>If specified, generate code that can only be
loaded and executed in a process that has a
matching setting for SRAMECC.</p>
<p>If not specified for code object V2 to V3, generate
code that can be loaded and executed in a process
with SRAMECC enabled.</p>
<p>If not specified for code object V4, generate
code that can be loaded and executed in a process
with either setting of SRAMECC.</p>
</td>
</tr>
<tr class="row-odd"><td><p>tgsplit</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-m[no-]tgsplit</span></code></p></td>
<td><p>Enable/disable generating code that assumes
work-groups are launched in threadgroup split mode.
When enabled the waves of a work-group may be
launched in different CUs.</p></td>
</tr>
<tr class="row-even"><td><p>wavefrontsize64</p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-m[no-]wavefrontsize64</span></code></p></li>
</ul>
</td>
<td><p>Control the wavefront size used when
generating code for kernels. When disabled
native wavefront size 32 is used, when enabled
wavefront size 64 is used.</p></td>
</tr>
<tr class="row-odd"><td><p>xnack</p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-mcpu</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--offload-arch</span></code></p></li>
</ul>
</td>
<td><p>If specified, generate code that can only be
loaded and executed in a process that has a
matching setting for XNACK replay.</p>
<p>If not specified for code object V2 to V3, generate
code that can be loaded and executed in a process
with XNACK replay enabled.</p>
<p>If not specified for code object V4, generate
code that can be loaded and executed in a process
with either setting of XNACK replay.</p>
<p>XNACK replay can be used for demand paging and
page migration. If enabled in the device, then if
a page fault occurs the code may execute
incorrectly unless generated with XNACK replay
enabled, or generated for code object V4 without
specifying XNACK replay. Executing code that was
generated with XNACK replay enabled, or generated
for code object V4 without specifying XNACK replay,
on a device that does not have XNACK replay
enabled will execute correctly but may be less
performant than code generated for XNACK replay
disabled.</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</div>
<div class="section" id="target-id">
<span id="amdgpu-target-id"></span><h3><a class="toc-backref" href="#id98">Target ID</a><a class="headerlink" href="#target-id" title="Permalink to this headline">¶</a></h3>
<p>AMDGPU supports target IDs. See <a class="reference external" href="https://clang.llvm.org/docs/ClangOffloadBundler.html">Clang Offload Bundler</a> for a general
description. The AMDGPU target specific information is:</p>
<dl class="simple">
<dt><strong>processor</strong></dt><dd><p>Is an AMDGPU processor or alternative processor name specified in
<a class="reference internal" href="#amdgpu-processor-table"><span class="std std-ref">AMDGPU Processors</span></a>. The non-canonical form target ID allows both
the primary processor and alternative processor names. The canonical form
target ID only allow the primary processor name.</p>
</dd>
<dt><strong>target-feature</strong></dt><dd><p>Is a target feature name specified in <a class="reference internal" href="#amdgpu-target-features-table"><span class="std std-ref">AMDGPU Target Features</span></a> that
is supported by the processor. The target features supported by each processor
is specified in <a class="reference internal" href="#amdgpu-processor-table"><span class="std std-ref">AMDGPU Processors</span></a>. Those that can be specified in
a target ID are marked as being controlled by <code class="docutils literal notranslate"><span class="pre">-mcpu</span></code> and
<code class="docutils literal notranslate"><span class="pre">--offload-arch</span></code>. Each target feature must appear at most once in a target
ID. The non-canonical form target ID allows the target features to be
specified in any order. The canonical form target ID requires the target
features to be specified in alphabetic order.</p>
</dd>
</dl>
<div class="section" id="code-object-v2-to-v3-target-id">
<span id="amdgpu-target-id-v2-v3"></span><h4><a class="toc-backref" href="#id99">Code Object V2 to V3 Target ID</a><a class="headerlink" href="#code-object-v2-to-v3-target-id" title="Permalink to this headline">¶</a></h4>
<p>The target ID syntax for code object V2 to V3 is the same as defined in <a class="reference external" href="https://clang.llvm.org/docs/ClangOffloadBundler.html">Clang
Offload Bundler</a> except
when used in the <a class="reference internal" href="#amdgpu-assembler-directive-amdgcn-target"><span class="std std-ref">.amdgcn_target &lt;target-triple&gt; “-” &lt;target-id&gt;</span></a> assembler
directive and the bundle entry ID. In those cases it has the following BNF
syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">target</span><span class="o">-</span><span class="nb">id</span><span class="o">&gt;</span> <span class="p">::</span><span class="o">==</span> <span class="o">&lt;</span><span class="n">processor</span><span class="o">&gt;</span> <span class="p">(</span> <span class="s2">&quot;+&quot;</span> <span class="o">&lt;</span><span class="n">target</span><span class="o">-</span><span class="n">feature</span><span class="o">&gt;</span> <span class="p">)</span><span class="o">*</span>
</pre></div>
</div>
<p>Where a target feature is omitted if <em>Off</em> and present if <em>On</em> or <em>Any</em>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The code object V2 to V3 cannot represent <em>Any</em> and treats it the same as
<em>On</em>.</p>
</div>
</div>
</div>
<div class="section" id="embedding-bundled-code-objects">
<span id="amdgpu-embedding-bundled-objects"></span><h3><a class="toc-backref" href="#id100">Embedding Bundled Code Objects</a><a class="headerlink" href="#embedding-bundled-code-objects" title="Permalink to this headline">¶</a></h3>
<p>AMDGPU supports the HIP and OpenMP languages that perform code object embedding
as described in <a class="reference external" href="https://clang.llvm.org/docs/ClangOffloadBundler.html">Clang Offload Bundler</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The target ID syntax used for code object V2 to V3 for a bundle entry ID
differs from that used elsewhere. See <a class="reference internal" href="#amdgpu-target-id-v2-v3"><span class="std std-ref">Code Object V2 to V3 Target ID</span></a>.</p>
</div>
</div>
<div class="section" id="address-spaces">
<span id="amdgpu-address-spaces"></span><h3><a class="toc-backref" href="#id101">Address Spaces</a><a class="headerlink" href="#address-spaces" title="Permalink to this headline">¶</a></h3>
<p>The AMDGPU architecture supports a number of memory address spaces. The address
space names use the OpenCL standard names, with some additions.</p>
<p>The AMDGPU address spaces correspond to target architecture specific LLVM
address space numbers used in LLVM IR.</p>
<p>The AMDGPU address spaces are described in
<a class="reference internal" href="#amdgpu-address-spaces-table"><span class="std std-ref">AMDGPU Address Spaces</span></a>. Only 64-bit process address spaces are
supported for the <code class="docutils literal notranslate"><span class="pre">amdgcn</span></code> target.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-address-spaces-table">
<caption><span class="caption-text">AMDGPU Address Spaces</span><a class="headerlink" href="#amdgpu-address-spaces-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 30%" />
<col style="width: 14%" />
<col style="width: 10%" />
<col style="width: 15%" />
<col style="width: 6%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"></th>
<th class="head"></th>
<th class="head"></th>
<th class="head" colspan="2"><p>64-Bit Process Address Space</p></th>
</tr>
<tr class="row-even"><th class="head"><p>Address Space Name</p></th>
<th class="head"><p>LLVM IR Address
Space Number</p></th>
<th class="head"><p>HSA Segment
Name</p></th>
<th class="head"><p>Hardware
Name</p></th>
<th class="head"><p>Address
Size</p></th>
<th class="head"><p>NULL Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td><p>Generic</p></td>
<td><p>0</p></td>
<td><p>flat</p></td>
<td><p>flat</p></td>
<td><p>64</p></td>
<td><p>0x0000000000000000</p></td>
</tr>
<tr class="row-even"><td><p>Global</p></td>
<td><p>1</p></td>
<td><p>global</p></td>
<td><p>global</p></td>
<td><p>64</p></td>
<td><p>0x0000000000000000</p></td>
</tr>
<tr class="row-odd"><td><p>Region</p></td>
<td><p>2</p></td>
<td><p>N/A</p></td>
<td><p>GDS</p></td>
<td><p>32</p></td>
<td><p><em>not implemented for AMDHSA</em></p></td>
</tr>
<tr class="row-even"><td><p>Local</p></td>
<td><p>3</p></td>
<td><p>group</p></td>
<td><p>LDS</p></td>
<td><p>32</p></td>
<td><p>0xFFFFFFFF</p></td>
</tr>
<tr class="row-odd"><td><p>Constant</p></td>
<td><p>4</p></td>
<td><p>constant</p></td>
<td><p><em>same as global</em></p></td>
<td><p>64</p></td>
<td><p>0x0000000000000000</p></td>
</tr>
<tr class="row-even"><td><p>Private</p></td>
<td><p>5</p></td>
<td><p>private</p></td>
<td><p>scratch</p></td>
<td><p>32</p></td>
<td><p>0xFFFFFFFF</p></td>
</tr>
<tr class="row-odd"><td><p>Constant 32-bit</p></td>
<td><p>6</p></td>
<td><p><em>TODO</em></p></td>
<td></td>
<td></td>
<td><p>0x00000000</p></td>
</tr>
<tr class="row-even"><td><p>Buffer Fat Pointer (experimental)</p></td>
<td><p>7</p></td>
<td><p><em>TODO</em></p></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl>
<dt><strong>Generic</strong></dt><dd><p>The generic address space is supported unless the <em>Target Properties</em> column
of <a class="reference internal" href="#amdgpu-processor-table"><span class="std std-ref">AMDGPU Processors</span></a> specifies <em>Does not support generic address
space</em>.</p>
<p>The generic address space uses the hardware flat address support for two fixed
ranges of virtual addresses (the private and local apertures), that are
outside the range of addressable global memory, to map from a flat address to
a private or local address. This uses FLAT instructions that can take a flat
address and access global, private (scratch), and group (LDS) memory depending
on if the address is within one of the aperture ranges.</p>
<p>Flat access to scratch requires hardware aperture setup and setup in the
kernel prologue (see <a class="reference internal" href="#amdgpu-amdhsa-kernel-prolog-flat-scratch"><span class="std std-ref">Flat Scratch</span></a>). Flat
access to LDS requires hardware aperture setup and M0 (GFX7-GFX8) register
setup (see <a class="reference internal" href="#amdgpu-amdhsa-kernel-prolog-m0"><span class="std std-ref">M0</span></a>).</p>
<p>To convert between a private or group address space address (termed a segment
address) and a flat address the base address of the corresponding aperture
can be used. For GFX7-GFX8 these are available in the
<a class="reference internal" href="#amdgpu-amdhsa-hsa-aql-queue"><span class="std std-ref">HSA AQL Queue</span></a> the address of which can be obtained with
Queue Ptr SGPR (see <a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>). For
GFX9-GFX10 the aperture base addresses are directly available as inline
constant registers <code class="docutils literal notranslate"><span class="pre">SRC_SHARED_BASE/LIMIT</span></code> and <code class="docutils literal notranslate"><span class="pre">SRC_PRIVATE_BASE/LIMIT</span></code>.
In 64-bit address mode the aperture sizes are 2^32 bytes and the base is
aligned to 2^32 which makes it easier to convert from flat to segment or
segment to flat.</p>
<p>A global address space address has the same value when used as a flat address
so no conversion is needed.</p>
</dd>
<dt><strong>Global and Constant</strong></dt><dd><p>The global and constant address spaces both use global virtual addresses,
which are the same virtual address space used by the CPU. However, some
virtual addresses may only be accessible to the CPU, some only accessible
by the GPU, and some by both.</p>
<p>Using the constant address space indicates that the data will not change
during the execution of the kernel. This allows scalar read instructions to
be used. As the constant address space could only be modified on the host
side, a generic pointer loaded from the constant address space is safe to be
assumed as a global pointer since only the device global memory is visible
and managed on the host side. The vector and scalar L1 caches are invalidated
of volatile data before each kernel dispatch execution to allow constant
memory to change values between kernel dispatches.</p>
</dd>
<dt><strong>Region</strong></dt><dd><p>The region address space uses the hardware Global Data Store (GDS). All
wavefronts executing on the same device will access the same memory for any
given region address. However, the same region address accessed by wavefronts
executing on different devices will access different memory. It is higher
performance than global memory. It is allocated by the runtime. The data
store (DS) instructions can be used to access it.</p>
</dd>
<dt><strong>Local</strong></dt><dd><p>The local address space uses the hardware Local Data Store (LDS) which is
automatically allocated when the hardware creates the wavefronts of a
work-group, and freed when all the wavefronts of a work-group have
terminated. All wavefronts belonging to the same work-group will access the
same memory for any given local address. However, the same local address
accessed by wavefronts belonging to different work-groups will access
different memory. It is higher performance than global memory. The data store
(DS) instructions can be used to access it.</p>
</dd>
<dt><strong>Private</strong></dt><dd><p>The private address space uses the hardware scratch memory support which
automatically allocates memory when it creates a wavefront and frees it when
a wavefronts terminates. The memory accessed by a lane of a wavefront for any
given private address will be different to the memory accessed by another lane
of the same or different wavefront for the same private address.</p>
<p>If a kernel dispatch uses scratch, then the hardware allocates memory from a
pool of backing memory allocated by the runtime for each wavefront. The lanes
of the wavefront access this using dword (4 byte) interleaving. The mapping
used from private address to backing memory address is:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">wavefront-scratch-base</span> <span class="pre">+</span>
<span class="pre">((private-address</span> <span class="pre">/</span> <span class="pre">4)</span> <span class="pre">*</span> <span class="pre">wavefront-size</span> <span class="pre">*</span> <span class="pre">4)</span> <span class="pre">+</span>
<span class="pre">(wavefront-lane-id</span> <span class="pre">*</span> <span class="pre">4)</span> <span class="pre">+</span> <span class="pre">(private-address</span> <span class="pre">%</span> <span class="pre">4)</span></code></p>
</div></blockquote>
<p>If each lane of a wavefront accesses the same private address, the
interleaving results in adjacent dwords being accessed and hence requires
fewer cache lines to be fetched.</p>
<p>There are different ways that the wavefront scratch base address is
determined by a wavefront (see
<a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>).</p>
<p>Scratch memory can be accessed in an interleaved manner using buffer
instructions with the scratch buffer descriptor and per wavefront scratch
offset, by the scratch instructions, or by flat instructions. Multi-dword
access is not supported except by flat and scratch instructions in
GFX9-GFX10.</p>
</dd>
<dt><strong>Constant 32-bit</strong></dt><dd><p><em>TODO</em></p>
</dd>
<dt><strong>Buffer Fat Pointer</strong></dt><dd><p>The buffer fat pointer is an experimental address space that is currently
unsupported in the backend. It exposes a non-integral pointer that is in
the future intended to support the modelling of 128-bit buffer descriptors
plus a 32-bit offset into the buffer (in total encapsulating a 160-bit
<em>pointer</em>), allowing normal LLVM load/store/atomic operations to be used to
model the buffer descriptors used heavily in graphics workloads targeting
the backend.</p>
</dd>
</dl>
</div>
<div class="section" id="memory-scopes">
<span id="amdgpu-memory-scopes"></span><h3><a class="toc-backref" href="#id102">Memory Scopes</a><a class="headerlink" href="#memory-scopes" title="Permalink to this headline">¶</a></h3>
<p>This section provides LLVM memory synchronization scopes supported by the AMDGPU
backend memory model when the target triple OS is <code class="docutils literal notranslate"><span class="pre">amdhsa</span></code> (see
<a class="reference internal" href="#amdgpu-amdhsa-memory-model"><span class="std std-ref">Memory Model</span></a> and <a class="reference internal" href="#amdgpu-target-triples"><span class="std std-ref">Target Triples</span></a>).</p>
<p>The memory model supported is based on the HSA memory model <a class="reference internal" href="#hsa" id="id28"><span>[HSA]</span></a> which is
based in turn on HRF-indirect with scope inclusion <a class="reference internal" href="#hrf" id="id29"><span>[HRF]</span></a>. The happens-before
relation is transitive over the synchronizes-with relation independent of scope
and synchronizes-with allows the memory scope instances to be inclusive (see
table <a class="reference internal" href="#amdgpu-amdhsa-llvm-sync-scopes-table"><span class="std std-ref">AMDHSA LLVM Sync Scopes</span></a>).</p>
<p>This is different to the OpenCL <a class="reference internal" href="#id92" id="id30"><span>[OpenCL]</span></a> memory model which does not have scope
inclusion and requires the memory scopes to exactly match. However, this
is conservatively correct for OpenCL.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-llvm-sync-scopes-table">
<caption><span class="caption-text">AMDHSA LLVM Sync Scopes</span><a class="headerlink" href="#amdgpu-amdhsa-llvm-sync-scopes-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 31%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>LLVM Sync Scope</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>none</em></p></td>
<td><p>The default: <code class="docutils literal notranslate"><span class="pre">system</span></code>.</p>
<p>Synchronizes with, and participates in modification
and seq_cst total orderings with, other operations
(except image operations) for all address spaces
(except private, or generic that accesses private)
provided the other operation’s sync scope is:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">system</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">agent</span></code> and executed by a thread on the same
agent.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">workgroup</span></code> and executed by a thread in the
same work-group.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wavefront</span></code> and executed by a thread in the
same wavefront.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">agent</span></code></p></td>
<td><p>Synchronizes with, and participates in modification
and seq_cst total orderings with, other operations
(except image operations) for all address spaces
(except private, or generic that accesses private)
provided the other operation’s sync scope is:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">system</span></code> or <code class="docutils literal notranslate"><span class="pre">agent</span></code> and executed by a thread
on the same agent.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">workgroup</span></code> and executed by a thread in the
same work-group.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wavefront</span></code> and executed by a thread in the
same wavefront.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">workgroup</span></code></p></td>
<td><p>Synchronizes with, and participates in modification
and seq_cst total orderings with, other operations
(except image operations) for all address spaces
(except private, or generic that accesses private)
provided the other operation’s sync scope is:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">system</span></code>, <code class="docutils literal notranslate"><span class="pre">agent</span></code> or <code class="docutils literal notranslate"><span class="pre">workgroup</span></code> and
executed by a thread in the same work-group.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wavefront</span></code> and executed by a thread in the
same wavefront.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">wavefront</span></code></p></td>
<td><p>Synchronizes with, and participates in modification
and seq_cst total orderings with, other operations
(except image operations) for all address spaces
(except private, or generic that accesses private)
provided the other operation’s sync scope is:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">system</span></code>, <code class="docutils literal notranslate"><span class="pre">agent</span></code>, <code class="docutils literal notranslate"><span class="pre">workgroup</span></code> or
<code class="docutils literal notranslate"><span class="pre">wavefront</span></code> and executed by a thread in the
same wavefront.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">singlethread</span></code></p></td>
<td><p>Only synchronizes with and participates in
modification and seq_cst total orderings with,
other operations (except image operations) running
in the same thread for all address spaces (for
example, in signal handlers).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">one-as</span></code></p></td>
<td><p>Same as <code class="docutils literal notranslate"><span class="pre">system</span></code> but only synchronizes with other
operations within the same address space.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">agent-one-as</span></code></p></td>
<td><p>Same as <code class="docutils literal notranslate"><span class="pre">agent</span></code> but only synchronizes with other
operations within the same address space.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">workgroup-one-as</span></code></p></td>
<td><p>Same as <code class="docutils literal notranslate"><span class="pre">workgroup</span></code> but only synchronizes with
other operations within the same address space.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">wavefront-one-as</span></code></p></td>
<td><p>Same as <code class="docutils literal notranslate"><span class="pre">wavefront</span></code> but only synchronizes with
other operations within the same address space.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">singlethread-one-as</span></code></p></td>
<td><p>Same as <code class="docutils literal notranslate"><span class="pre">singlethread</span></code> but only synchronizes with
other operations within the same address space.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="llvm-ir-intrinsics">
<h3><a class="toc-backref" href="#id103">LLVM IR Intrinsics</a><a class="headerlink" href="#llvm-ir-intrinsics" title="Permalink to this headline">¶</a></h3>
<p>The AMDGPU backend implements the following LLVM IR intrinsics.</p>
<p><em>This section is WIP.</em></p>
</div>
<div class="section" id="llvm-ir-attributes">
<h3><a class="toc-backref" href="#id104">LLVM IR Attributes</a><a class="headerlink" href="#llvm-ir-attributes" title="Permalink to this headline">¶</a></h3>
<p>The AMDGPU backend supports the following LLVM IR attributes.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-llvm-ir-attributes-table">
<caption><span class="caption-text">AMDGPU LLVM IR Attributes</span><a class="headerlink" href="#amdgpu-llvm-ir-attributes-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 36%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>LLVM Attribute</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“amdgpu-flat-work-group-size”=”min,max”</p></td>
<td><p>Specify the minimum and maximum flat work group sizes that
will be specified when the kernel is dispatched. Generated
by the <code class="docutils literal notranslate"><span class="pre">amdgpu_flat_work_group_size</span></code> CLANG attribute <a class="reference internal" href="#clang-attr" id="id32"><span>[CLANG-ATTR]</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p>“amdgpu-implicitarg-num-bytes”=”n”</p></td>
<td><p>Number of kernel argument bytes to add to the kernel
argument block size for the implicit arguments. This
varies by OS and language (for OpenCL see
<a class="reference internal" href="#opencl-kernel-implicit-arguments-appended-for-amdhsa-os-table"><span class="std std-ref">OpenCL kernel implicit arguments appended for AMDHSA OS</span></a>).</p></td>
</tr>
<tr class="row-even"><td><p>“amdgpu-num-sgpr”=”n”</p></td>
<td><p>Specifies the number of SGPRs to use. Generated by
the <code class="docutils literal notranslate"><span class="pre">amdgpu_num_sgpr</span></code> CLANG attribute <a class="reference internal" href="#clang-attr" id="id33"><span>[CLANG-ATTR]</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p>“amdgpu-num-vgpr”=”n”</p></td>
<td><p>Specifies the number of VGPRs to use. Generated by the
<code class="docutils literal notranslate"><span class="pre">amdgpu_num_vgpr</span></code> CLANG attribute <a class="reference internal" href="#clang-attr" id="id34"><span>[CLANG-ATTR]</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p>“amdgpu-waves-per-eu”=”m,n”</p></td>
<td><p>Specify the minimum and maximum number of waves per
execution unit. Generated by the <code class="docutils literal notranslate"><span class="pre">amdgpu_waves_per_eu</span></code>
CLANG attribute <a class="reference internal" href="#clang-attr" id="id35"><span>[CLANG-ATTR]</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p>“amdgpu-ieee” true/false.</p></td>
<td><p>Specify whether the function expects the IEEE field of the
mode register to be set on entry. Overrides the default for
the calling convention.</p></td>
</tr>
<tr class="row-even"><td><p>“amdgpu-dx10-clamp” true/false.</p></td>
<td><p>Specify whether the function expects the DX10_CLAMP field of
the mode register to be set on entry. Overrides the default
for the calling convention.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
</div>
<div class="section" id="elf-code-object">
<span id="amdgpu-elf-code-object"></span><h2><a class="toc-backref" href="#id105">ELF Code Object</a><a class="headerlink" href="#elf-code-object" title="Permalink to this headline">¶</a></h2>
<p>The AMDGPU backend generates a standard ELF <a class="reference internal" href="#elf" id="id36"><span>[ELF]</span></a> relocatable code object that
can be linked by <code class="docutils literal notranslate"><span class="pre">lld</span></code> to produce a standard ELF shared code object which can
be loaded and executed on an AMDGPU target.</p>
<div class="section" id="header">
<span id="amdgpu-elf-header"></span><h3><a class="toc-backref" href="#id106">Header</a><a class="headerlink" href="#header" title="Permalink to this headline">¶</a></h3>
<p>The AMDGPU backend uses the following ELF header:</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-elf-header-table">
<caption><span class="caption-text">AMDGPU ELF Header</span><a class="headerlink" href="#amdgpu-elf-header-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 36%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Field</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">e_ident[EI_CLASS]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ELFCLASS64</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">e_ident[EI_DATA]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ELFDATA2LSB</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">e_ident[EI_OSABI]</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ELFOSABI_NONE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ELFOSABI_AMDGPU_HSA</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ELFOSABI_AMDGPU_PAL</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ELFOSABI_AMDGPU_MESA3D</span></code></p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">e_ident[EI_ABIVERSION]</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ELFABIVERSION_AMDGPU_HSA_V2</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ELFABIVERSION_AMDGPU_HSA_V3</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ELFABIVERSION_AMDGPU_HSA_V4</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ELFABIVERSION_AMDGPU_PAL</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ELFABIVERSION_AMDGPU_MESA3D</span></code></p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">e_type</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ET_REL</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ET_DYN</span></code></p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">e_machine</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">EM_AMDGPU</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">e_entry</span></code></p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">e_flags</span></code></p></td>
<td><p>See <a class="reference internal" href="#amdgpu-elf-header-e-flags-v2-table"><span class="std std-ref">AMDGPU ELF Header e_flags for Code Object V2</span></a>,
<a class="reference internal" href="#amdgpu-elf-header-e-flags-table-v3"><span class="std std-ref">AMDGPU ELF Header e_flags for Code Object V3</span></a>,
and <a class="reference internal" href="#amdgpu-elf-header-e-flags-table-v4"><span class="std std-ref">AMDGPU ELF Header e_flags for Code Object V4</span></a></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-elf-header-enumeration-values-table">
<caption><span class="caption-text">AMDGPU ELF Header Enumeration Values</span><a class="headerlink" href="#amdgpu-elf-header-enumeration-values-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 86%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EM_AMDGPU</span></code></p></td>
<td><p>224</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ELFOSABI_NONE</span></code></p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ELFOSABI_AMDGPU_HSA</span></code></p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ELFOSABI_AMDGPU_PAL</span></code></p></td>
<td><p>65</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ELFOSABI_AMDGPU_MESA3D</span></code></p></td>
<td><p>66</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ELFABIVERSION_AMDGPU_HSA_V2</span></code></p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ELFABIVERSION_AMDGPU_HSA_V3</span></code></p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ELFABIVERSION_AMDGPU_HSA_V4</span></code></p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ELFABIVERSION_AMDGPU_PAL</span></code></p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ELFABIVERSION_AMDGPU_MESA3D</span></code></p></td>
<td><p>0</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">e_ident[EI_CLASS]</span></code></dt><dd><p>The ELF class is:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ELFCLASS32</span></code> for <code class="docutils literal notranslate"><span class="pre">r600</span></code> architecture.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ELFCLASS64</span></code> for <code class="docutils literal notranslate"><span class="pre">amdgcn</span></code> architecture which only supports 64-bit
process address space applications.</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">e_ident[EI_DATA]</span></code></dt><dd><p>All AMDGPU targets use <code class="docutils literal notranslate"><span class="pre">ELFDATA2LSB</span></code> for little-endian byte ordering.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">e_ident[EI_OSABI]</span></code></dt><dd><p>One of the following AMDGPU target architecture specific OS ABIs
(see <a class="reference internal" href="#amdgpu-os"><span class="std std-ref">AMDGPU Operating Systems</span></a>):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ELFOSABI_NONE</span></code> for <em>unknown</em> OS.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ELFOSABI_AMDGPU_HSA</span></code> for <code class="docutils literal notranslate"><span class="pre">amdhsa</span></code> OS.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ELFOSABI_AMDGPU_PAL</span></code> for <code class="docutils literal notranslate"><span class="pre">amdpal</span></code> OS.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ELFOSABI_AMDGPU_MESA3D</span></code> for <code class="docutils literal notranslate"><span class="pre">mesa3D</span></code> OS.</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">e_ident[EI_ABIVERSION]</span></code></dt><dd><p>The ABI version of the AMDGPU target architecture specific OS ABI to which the code
object conforms:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ELFABIVERSION_AMDGPU_HSA_V2</span></code> is used to specify the version of AMD HSA
runtime ABI for code object V2. Specify using the Clang option
<code class="docutils literal notranslate"><span class="pre">-mcode-object-version=2</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ELFABIVERSION_AMDGPU_HSA_V3</span></code> is used to specify the version of AMD HSA
runtime ABI for code object V3. Specify using the Clang option
<code class="docutils literal notranslate"><span class="pre">-mcode-object-version=3</span></code>. This is the default code object
version if not specified.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ELFABIVERSION_AMDGPU_HSA_V4</span></code> is used to specify the version of AMD HSA
runtime ABI for code object V4. Specify using the Clang option
<code class="docutils literal notranslate"><span class="pre">-mcode-object-version=4</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ELFABIVERSION_AMDGPU_PAL</span></code> is used to specify the version of AMD PAL
runtime ABI.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ELFABIVERSION_AMDGPU_MESA3D</span></code> is used to specify the version of AMD MESA
3D runtime ABI.</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">e_type</span></code></dt><dd><p>Can be one of the following values:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ET_REL</span></code></dt><dd><p>The type produced by the AMDGPU backend compiler as it is relocatable code
object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ET_DYN</span></code></dt><dd><p>The type produced by the linker as it is a shared code object.</p>
</dd>
</dl>
<p>The AMD HSA runtime loader requires a <code class="docutils literal notranslate"><span class="pre">ET_DYN</span></code> code object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">e_machine</span></code></dt><dd><p>The value <code class="docutils literal notranslate"><span class="pre">EM_AMDGPU</span></code> is used for the machine for all processors supported
by the <code class="docutils literal notranslate"><span class="pre">r600</span></code> and <code class="docutils literal notranslate"><span class="pre">amdgcn</span></code> architectures (see
<a class="reference internal" href="#amdgpu-processor-table"><span class="std std-ref">AMDGPU Processors</span></a>). The specific processor is specified in the
<code class="docutils literal notranslate"><span class="pre">NT_AMD_HSA_ISA_VERSION</span></code> note record for code object V2 (see
<a class="reference internal" href="#amdgpu-note-records-v2"><span class="std std-ref">Code Object V2 Note Records</span></a>) and in the <code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH</span></code> bit field of the
<code class="docutils literal notranslate"><span class="pre">e_flags</span></code> for code object V3 to V4 (see
<a class="reference internal" href="#amdgpu-elf-header-e-flags-table-v3"><span class="std std-ref">AMDGPU ELF Header e_flags for Code Object V3</span></a> and
<a class="reference internal" href="#amdgpu-elf-header-e-flags-table-v4"><span class="std std-ref">AMDGPU ELF Header e_flags for Code Object V4</span></a>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">e_entry</span></code></dt><dd><p>The entry point is 0 as the entry points for individual kernels must be
selected in order to invoke them through AQL packets.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">e_flags</span></code></dt><dd><p>The AMDGPU backend uses the following ELF header flags:</p>
<table class="docutils align-default" id="amdgpu-elf-header-e-flags-v2-table">
<caption><span class="caption-text">AMDGPU ELF Header <code class="docutils literal notranslate"><span class="pre">e_flags</span></code> for Code Object V2</span><a class="headerlink" href="#amdgpu-elf-header-e-flags-v2-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 51%" />
<col style="width: 7%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_FEATURE_XNACK_V2</span></code></p></td>
<td><p>0x01</p></td>
<td><p>Indicates if the <code class="docutils literal notranslate"><span class="pre">xnack</span></code>
target feature is
enabled for all code
contained in the code object.
If the processor
does not support the
<code class="docutils literal notranslate"><span class="pre">xnack</span></code> target
feature then must
be 0.
See
<a class="reference internal" href="#amdgpu-target-features"><span class="std std-ref">Target Features</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_FEATURE_TRAP_HANDLER_V2</span></code></p></td>
<td><p>0x02</p></td>
<td><p>Indicates if the trap
handler is enabled for all
code contained in the code
object. If the processor
does not support a trap
handler then must be 0.
See
<a class="reference internal" href="#amdgpu-target-features"><span class="std std-ref">Target Features</span></a>.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="amdgpu-elf-header-e-flags-table-v3">
<caption><span class="caption-text">AMDGPU ELF Header <code class="docutils literal notranslate"><span class="pre">e_flags</span></code> for Code Object V3</span><a class="headerlink" href="#amdgpu-elf-header-e-flags-table-v3" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 45%" />
<col style="width: 7%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH</span></code></p></td>
<td><p>0x0ff</p></td>
<td><p>AMDGPU processor selection
mask for
<code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_xxx</span></code> values
defined in
<a class="reference internal" href="#amdgpu-ef-amdgpu-mach-table"><span class="std std-ref">AMDGPU EF_AMDGPU_MACH Values</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_FEATURE_XNACK_V3</span></code></p></td>
<td><p>0x100</p></td>
<td><p>Indicates if the <code class="docutils literal notranslate"><span class="pre">xnack</span></code>
target feature is
enabled for all code
contained in the code object.
If the processor
does not support the
<code class="docutils literal notranslate"><span class="pre">xnack</span></code> target
feature then must
be 0.
See
<a class="reference internal" href="#amdgpu-target-features"><span class="std std-ref">Target Features</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_FEATURE_SRAMECC_V3</span></code></p></td>
<td><p>0x200</p></td>
<td><p>Indicates if the <code class="docutils literal notranslate"><span class="pre">sramecc</span></code>
target feature is
enabled for all code
contained in the code object.
If the processor
does not support the
<code class="docutils literal notranslate"><span class="pre">sramecc</span></code> target
feature then must
be 0.
See
<a class="reference internal" href="#amdgpu-target-features"><span class="std std-ref">Target Features</span></a>.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="amdgpu-elf-header-e-flags-table-v4">
<caption><span class="caption-text">AMDGPU ELF Header <code class="docutils literal notranslate"><span class="pre">e_flags</span></code> for Code Object V4</span><a class="headerlink" href="#amdgpu-elf-header-e-flags-table-v4" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 52%" />
<col style="width: 6%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH</span></code></p></td>
<td><p>0x0ff</p></td>
<td><p>AMDGPU processor selection
mask for
<code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_xxx</span></code> values
defined in
<a class="reference internal" href="#amdgpu-ef-amdgpu-mach-table"><span class="std std-ref">AMDGPU EF_AMDGPU_MACH Values</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_FEATURE_XNACK_V4</span></code></p></td>
<td><p>0x300</p></td>
<td><p>XNACK selection mask for
<code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_FEATURE_XNACK_*_V4</span></code>
values.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_FEATURE_XNACK_UNSUPPORTED_V4</span></code></p></td>
<td><p>0x000</p></td>
<td><p>XNACK unsuppored.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_FEATURE_XNACK_ANY_V4</span></code></p></td>
<td><p>0x100</p></td>
<td><p>XNACK can have any value.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_FEATURE_XNACK_OFF_V4</span></code></p></td>
<td><p>0x200</p></td>
<td><p>XNACK disabled.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_FEATURE_XNACK_ON_V4</span></code></p></td>
<td><p>0x300</p></td>
<td><p>XNACK enabled.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_FEATURE_SRAMECC_V4</span></code></p></td>
<td><p>0xc00</p></td>
<td><p>SRAMECC selection mask for
<code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_FEATURE_SRAMECC_*_V4</span></code>
values.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_FEATURE_SRAMECC_UNSUPPORTED_V4</span></code></p></td>
<td><p>0x000</p></td>
<td><p>SRAMECC unsuppored.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_FEATURE_SRAMECC_ANY_V4</span></code></p></td>
<td><p>0x400</p></td>
<td><p>SRAMECC can have any value.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_FEATURE_SRAMECC_OFF_V4</span></code></p></td>
<td><p>0x800</p></td>
<td><p>SRAMECC disabled,</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_FEATURE_SRAMECC_ON_V4</span></code></p></td>
<td><p>0xc00</p></td>
<td><p>SRAMECC enabled.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="amdgpu-ef-amdgpu-mach-table">
<caption><span class="caption-text">AMDGPU <code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH</span></code> Values</span><a class="headerlink" href="#amdgpu-ef-amdgpu-mach-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 47%" />
<col style="width: 13%" />
<col style="width: 39%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Description (see
<a class="reference internal" href="#amdgpu-processor-table"><span class="std std-ref">AMDGPU Processors</span></a>)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_NONE</span></code></p></td>
<td><p>0x000</p></td>
<td><p><em>not specified</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_R600_R600</span></code></p></td>
<td><p>0x001</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r600</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_R600_R630</span></code></p></td>
<td><p>0x002</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r630</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_R600_RS880</span></code></p></td>
<td><p>0x003</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">rs880</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_R600_RV670</span></code></p></td>
<td><p>0x004</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">rv670</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_R600_RV710</span></code></p></td>
<td><p>0x005</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">rv710</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_R600_RV730</span></code></p></td>
<td><p>0x006</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">rv730</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_R600_RV770</span></code></p></td>
<td><p>0x007</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">rv770</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_R600_CEDAR</span></code></p></td>
<td><p>0x008</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">cedar</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_R600_CYPRESS</span></code></p></td>
<td><p>0x009</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">cypress</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_R600_JUNIPER</span></code></p></td>
<td><p>0x00a</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">juniper</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_R600_REDWOOD</span></code></p></td>
<td><p>0x00b</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">redwood</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_R600_SUMO</span></code></p></td>
<td><p>0x00c</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sumo</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_R600_BARTS</span></code></p></td>
<td><p>0x00d</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">barts</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_R600_CAICOS</span></code></p></td>
<td><p>0x00e</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">caicos</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_R600_CAYMAN</span></code></p></td>
<td><p>0x00f</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">cayman</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_R600_TURKS</span></code></p></td>
<td><p>0x010</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">turks</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><em>reserved</em></p></td>
<td><p>0x011 -
0x01f</p></td>
<td><p>Reserved for <code class="docutils literal notranslate"><span class="pre">r600</span></code>
architecture processors.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX600</span></code></p></td>
<td><p>0x020</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx600</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX601</span></code></p></td>
<td><p>0x021</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx601</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX700</span></code></p></td>
<td><p>0x022</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx700</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX701</span></code></p></td>
<td><p>0x023</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx701</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX702</span></code></p></td>
<td><p>0x024</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx702</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX703</span></code></p></td>
<td><p>0x025</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx703</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX704</span></code></p></td>
<td><p>0x026</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx704</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><em>reserved</em></p></td>
<td><p>0x027</p></td>
<td><p>Reserved.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX801</span></code></p></td>
<td><p>0x028</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx801</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX802</span></code></p></td>
<td><p>0x029</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx802</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX803</span></code></p></td>
<td><p>0x02a</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx803</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX810</span></code></p></td>
<td><p>0x02b</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx810</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX900</span></code></p></td>
<td><p>0x02c</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx900</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX902</span></code></p></td>
<td><p>0x02d</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx902</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX904</span></code></p></td>
<td><p>0x02e</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx904</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX906</span></code></p></td>
<td><p>0x02f</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx906</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX908</span></code></p></td>
<td><p>0x030</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx908</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX909</span></code></p></td>
<td><p>0x031</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx909</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX90C</span></code></p></td>
<td><p>0x032</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx90c</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX1010</span></code></p></td>
<td><p>0x033</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx1010</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX1011</span></code></p></td>
<td><p>0x034</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx1011</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX1012</span></code></p></td>
<td><p>0x035</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx1012</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX1030</span></code></p></td>
<td><p>0x036</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx1030</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX1031</span></code></p></td>
<td><p>0x037</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx1031</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX1032</span></code></p></td>
<td><p>0x038</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx1032</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX1033</span></code></p></td>
<td><p>0x039</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx1033</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX602</span></code></p></td>
<td><p>0x03a</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx602</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX705</span></code></p></td>
<td><p>0x03b</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx705</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX805</span></code></p></td>
<td><p>0x03c</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx805</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX1035</span></code></p></td>
<td><p>0x03d</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx1035</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX1034</span></code></p></td>
<td><p>0x03e</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx1034</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX90A</span></code></p></td>
<td><p>0x03f</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx90a</span></code></p></td>
</tr>
<tr class="row-even"><td><p><em>reserved</em></p></td>
<td><p>0x040</p></td>
<td><p>Reserved.</p></td>
</tr>
<tr class="row-odd"><td><p><em>reserved</em></p></td>
<td><p>0x041</p></td>
<td><p>Reserved.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH_AMDGCN_GFX1013</span></code></p></td>
<td><p>0x042</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx1013</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><em>reserved</em></p></td>
<td><p>0x043</p></td>
<td><p>Reserved.</p></td>
</tr>
<tr class="row-even"><td><p><em>reserved</em></p></td>
<td><p>0x044</p></td>
<td><p>Reserved.</p></td>
</tr>
<tr class="row-odd"><td><p><em>reserved</em></p></td>
<td><p>0x045</p></td>
<td><p>Reserved.</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
</div>
<div class="section" id="sections">
<h3><a class="toc-backref" href="#id107">Sections</a><a class="headerlink" href="#sections" title="Permalink to this headline">¶</a></h3>
<p>An AMDGPU target ELF code object has the standard ELF sections which include:</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-elf-sections-table">
<caption><span class="caption-text">AMDGPU ELF Sections</span><a class="headerlink" href="#amdgpu-elf-sections-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 27%" />
<col style="width: 24%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Attributes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.bss</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_NOBITS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHF_ALLOC</span></code> + <code class="docutils literal notranslate"><span class="pre">SHF_WRITE</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.data</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_PROGBITS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHF_ALLOC</span></code> + <code class="docutils literal notranslate"><span class="pre">SHF_WRITE</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.debug_</span></code><em>*</em></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_PROGBITS</span></code></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.dynamic</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_DYNAMIC</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHF_ALLOC</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.dynstr</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_PROGBITS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHF_ALLOC</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.dynsym</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_PROGBITS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHF_ALLOC</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.got</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_PROGBITS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHF_ALLOC</span></code> + <code class="docutils literal notranslate"><span class="pre">SHF_WRITE</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.hash</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_HASH</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHF_ALLOC</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.note</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_NOTE</span></code></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.rela</span></code><em>name</em></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_RELA</span></code></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.rela.dyn</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_RELA</span></code></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.rodata</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_PROGBITS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHF_ALLOC</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.shstrtab</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_STRTAB</span></code></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.strtab</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_STRTAB</span></code></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.symtab</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_SYMTAB</span></code></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.text</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHT_PROGBITS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHF_ALLOC</span></code> + <code class="docutils literal notranslate"><span class="pre">SHF_EXECINSTR</span></code></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>These sections have their standard meanings (see <a class="reference internal" href="#elf" id="id37"><span>[ELF]</span></a>) and are only generated
if needed.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">.debug</span></code><em>*</em></dt><dd><p>The standard DWARF sections. See <a class="reference internal" href="#amdgpu-dwarf-debug-information"><span class="std std-ref">DWARF Debug Information</span></a> for
information on the DWARF produced by the AMDGPU backend.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.dynamic</span></code>, <code class="docutils literal notranslate"><span class="pre">.dynstr</span></code>, <code class="docutils literal notranslate"><span class="pre">.dynsym</span></code>, <code class="docutils literal notranslate"><span class="pre">.hash</span></code></dt><dd><p>The standard sections used by a dynamic loader.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.note</span></code></dt><dd><p>See <a class="reference internal" href="#amdgpu-note-records"><span class="std std-ref">Note Records</span></a> for the note records supported by the AMDGPU
backend.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.rela</span></code><em>name</em>, <code class="docutils literal notranslate"><span class="pre">.rela.dyn</span></code></dt><dd><p>For relocatable code objects, <em>name</em> is the name of the section that the
relocation records apply. For example, <code class="docutils literal notranslate"><span class="pre">.rela.text</span></code> is the section name for
relocation records associated with the <code class="docutils literal notranslate"><span class="pre">.text</span></code> section.</p>
<p>For linked shared code objects, <code class="docutils literal notranslate"><span class="pre">.rela.dyn</span></code> contains all the relocation
records from each of the relocatable code object’s <code class="docutils literal notranslate"><span class="pre">.rela</span></code><em>name</em> sections.</p>
<p>See <a class="reference internal" href="#amdgpu-relocation-records"><span class="std std-ref">Relocation Records</span></a> for the relocation records supported by
the AMDGPU backend.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">.text</span></code></dt><dd><p>The executable machine code for the kernels and functions they call. Generated
as position independent code. See <a class="reference internal" href="#amdgpu-code-conventions"><span class="std std-ref">Code Conventions</span></a> for
information on conventions used in the isa generation.</p>
</dd>
</dl>
</div>
<div class="section" id="note-records">
<span id="amdgpu-note-records"></span><h3><a class="toc-backref" href="#id108">Note Records</a><a class="headerlink" href="#note-records" title="Permalink to this headline">¶</a></h3>
<p>The AMDGPU backend code object contains ELF note records in the <code class="docutils literal notranslate"><span class="pre">.note</span></code>
section. The set of generated notes and their semantics depend on the code
object version; see <a class="reference internal" href="#amdgpu-note-records-v2"><span class="std std-ref">Code Object V2 Note Records</span></a> and
<a class="reference internal" href="#amdgpu-note-records-v3-v4"><span class="std std-ref">Code Object V3 to V4 Note Records</span></a>.</p>
<p>As required by <code class="docutils literal notranslate"><span class="pre">ELFCLASS32</span></code> and <code class="docutils literal notranslate"><span class="pre">ELFCLASS64</span></code>, minimal zero-byte padding
must be generated after the <code class="docutils literal notranslate"><span class="pre">name</span></code> field to ensure the <code class="docutils literal notranslate"><span class="pre">desc</span></code> field is 4
byte aligned. In addition, minimal zero-byte padding must be generated to
ensure the <code class="docutils literal notranslate"><span class="pre">desc</span></code> field size is a multiple of 4 bytes. The <code class="docutils literal notranslate"><span class="pre">sh_addralign</span></code>
field of the <code class="docutils literal notranslate"><span class="pre">.note</span></code> section must be at least 4 to indicate at least 8 byte
alignment.</p>
<div class="section" id="code-object-v2-note-records">
<span id="amdgpu-note-records-v2"></span><h4><a class="toc-backref" href="#id109">Code Object V2 Note Records</a><a class="headerlink" href="#code-object-v2-note-records" title="Permalink to this headline">¶</a></h4>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Code object V2 is not the default code object version emitted by
this version of LLVM.</p>
</div>
<p>The AMDGPU backend code object uses the following ELF note record in the
<code class="docutils literal notranslate"><span class="pre">.note</span></code> section when compiling for code object V2.</p>
<p>The note record vendor field is “AMD”.</p>
<p>Additional note records may be present, but any which are not documented here
are deprecated and should not be used.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-elf-note-records-v2-table">
<caption><span class="caption-text">AMDGPU Code Object V2 ELF Note Records</span><a class="headerlink" href="#amdgpu-elf-note-records-v2-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 6%" />
<col style="width: 46%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“AMD”</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NT_AMD_HSA_CODE_OBJECT_VERSION</span></code></p></td>
<td><p>Code object version.</p></td>
</tr>
<tr class="row-odd"><td><p>“AMD”</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NT_AMD_HSA_HSAIL</span></code></p></td>
<td><p>HSAIL properties generated by the HSAIL
Finalizer and not the LLVM compiler.</p></td>
</tr>
<tr class="row-even"><td><p>“AMD”</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NT_AMD_HSA_ISA_VERSION</span></code></p></td>
<td><p>Target ISA version.</p></td>
</tr>
<tr class="row-odd"><td><p>“AMD”</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NT_AMD_HSA_METADATA</span></code></p></td>
<td><p>Metadata null terminated string in
YAML <a class="reference internal" href="#yaml" id="id38"><span>[YAML]</span></a> textual format.</p></td>
</tr>
<tr class="row-even"><td><p>“AMD”</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NT_AMD_HSA_ISA_NAME</span></code></p></td>
<td><p>Target ISA name.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-elf-note-record-enumeration-values-v2-table">
<caption><span class="caption-text">AMDGPU Code Object V2 ELF Note Record Enumeration Values</span><a class="headerlink" href="#amdgpu-elf-note-record-enumeration-values-v2-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 88%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">NT_AMD_HSA_CODE_OBJECT_VERSION</span></code></p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">NT_AMD_HSA_HSAIL</span></code></p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">NT_AMD_HSA_ISA_VERSION</span></code></p></td>
<td><p>3</p></td>
</tr>
<tr class="row-odd"><td><p><em>reserved</em></p></td>
<td><p>4-9</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">NT_AMD_HSA_METADATA</span></code></p></td>
<td><p>10</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">NT_AMD_HSA_ISA_NAME</span></code></p></td>
<td><p>11</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">NT_AMD_HSA_CODE_OBJECT_VERSION</span></code></dt><dd><p>Specifies the code object version number. The description field has the
following layout:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">amdgpu_hsa_note_code_object_version_s</span> <span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">major_version</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">minor_version</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">major_version</span></code> has a value less than or equal to 2.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NT_AMD_HSA_HSAIL</span></code></dt><dd><p>Specifies the HSAIL properties used by the HSAIL Finalizer. The description
field has the following layout:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">amdgpu_hsa_note_hsail_s</span> <span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">hsail_major_version</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">hsail_minor_version</span><span class="p">;</span>
  <span class="kt">uint8_t</span> <span class="n">profile</span><span class="p">;</span>
  <span class="kt">uint8_t</span> <span class="n">machine_model</span><span class="p">;</span>
  <span class="kt">uint8_t</span> <span class="n">default_float_round</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NT_AMD_HSA_ISA_VERSION</span></code></dt><dd><p>Specifies the target ISA version. The description field has the following layout:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">amdgpu_hsa_note_isa_s</span> <span class="p">{</span>
  <span class="kt">uint16_t</span> <span class="n">vendor_name_size</span><span class="p">;</span>
  <span class="kt">uint16_t</span> <span class="n">architecture_name_size</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">major</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">minor</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">stepping</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">vendor_and_architecture_name</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">vendor_name_size</span></code> and <code class="docutils literal notranslate"><span class="pre">architecture_name_size</span></code> are the length of the
vendor and architecture names respectively, including the NUL character.</p>
<p><code class="docutils literal notranslate"><span class="pre">vendor_and_architecture_name</span></code> contains the NUL terminates string for the
vendor, immediately followed by the NUL terminated string for the
architecture.</p>
<p>This note record is used by the HSA runtime loader.</p>
<p>Code object V2 only supports a limited number of processors and has fixed
settings for target features. See
<a class="reference internal" href="#amdgpu-elf-note-record-supported-processors-v2-table"><span class="std std-ref">AMDGPU Code Object V2 Supported Processors and Fixed Target Feature Settings</span></a> for a list of
processors and the corresponding target ID. In the table the note record ISA
name is a concatenation of the vendor name, architecture name, major, minor,
and stepping separated by a “:”.</p>
<p>The target ID column shows the processor name and fixed target features used
by the LLVM compiler. The LLVM compiler does not generate a
<code class="docutils literal notranslate"><span class="pre">NT_AMD_HSA_HSAIL</span></code> note record.</p>
<p>A code object generated by the Finalizer also uses code object V2 and always
generates a <code class="docutils literal notranslate"><span class="pre">NT_AMD_HSA_HSAIL</span></code> note record. The processor name and
<code class="docutils literal notranslate"><span class="pre">sramecc</span></code> target feature is as shown in
<a class="reference internal" href="#amdgpu-elf-note-record-supported-processors-v2-table"><span class="std std-ref">AMDGPU Code Object V2 Supported Processors and Fixed Target Feature Settings</span></a> but the <code class="docutils literal notranslate"><span class="pre">xnack</span></code>
target feature is specified by the <code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_FEATURE_XNACK_V2</span></code> <code class="docutils literal notranslate"><span class="pre">e_flags</span></code>
bit.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NT_AMD_HSA_ISA_NAME</span></code></dt><dd><p>Specifies the target ISA name as a non-NUL terminated string.</p>
<p>This note record is not used by the HSA runtime loader.</p>
<p>See the <code class="docutils literal notranslate"><span class="pre">NT_AMD_HSA_ISA_VERSION</span></code> note record description of the code object
V2’s limited support of processors and fixed settings for target features.</p>
<p>See <a class="reference internal" href="#amdgpu-elf-note-record-supported-processors-v2-table"><span class="std std-ref">AMDGPU Code Object V2 Supported Processors and Fixed Target Feature Settings</span></a> for a mapping
from the string to the corresponding target ID. If the <code class="docutils literal notranslate"><span class="pre">xnack</span></code> target
feature is supported and enabled, the string produced by the LLVM compiler
will may have a <code class="docutils literal notranslate"><span class="pre">+xnack</span></code> appended. The Finlizer did not do the appending and
instead used the <code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_FEATURE_XNACK_V2</span></code> <code class="docutils literal notranslate"><span class="pre">e_flags</span></code> bit.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NT_AMD_HSA_METADATA</span></code></dt><dd><p>Specifies extensible metadata associated with the code objects executed on HSA
<a class="reference internal" href="#hsa" id="id39"><span>[HSA]</span></a> compatible runtimes (see <a class="reference internal" href="#amdgpu-os"><span class="std std-ref">AMDGPU Operating Systems</span></a>). It is required when the
target triple OS is <code class="docutils literal notranslate"><span class="pre">amdhsa</span></code> (see <a class="reference internal" href="#amdgpu-target-triples"><span class="std std-ref">Target Triples</span></a>). See
<a class="reference internal" href="#amdgpu-amdhsa-code-object-metadata-v2"><span class="std std-ref">Code Object V2 Metadata</span></a> for the syntax of the code object
metadata string.</p>
<table class="docutils align-default" id="amdgpu-elf-note-record-supported-processors-v2-table">
<caption><span class="caption-text">AMDGPU Code Object V2 Supported Processors and Fixed Target Feature Settings</span><a class="headerlink" href="#amdgpu-elf-note-record-supported-processors-v2-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 45%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Note Record ISA Name</p></th>
<th class="head"><p>Target ID</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:6:0:0</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx600</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:6:0:1</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx601</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:6:0:2</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx602</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:7:0:0</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx700</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:7:0:1</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx701</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:7:0:2</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx702</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:7:0:3</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx703</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:7:0:4</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx704</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:7:0:5</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx705</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:8:0:0</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx802</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:8:0:1</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx801:xnack+</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:8:0:2</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx802</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:8:0:3</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx803</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:8:0:4</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx803</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:8:0:5</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx805</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:8:1:0</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx810:xnack+</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:9:0:0</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx900:xnack-</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:9:0:1</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx900:xnack+</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:9:0:2</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx902:xnack-</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:9:0:3</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx902:xnack+</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:9:0:4</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx904:xnack-</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:9:0:5</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx904:xnack+</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:9:0:6</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx906:sramecc-:xnack-</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:9:0:7</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx906:sramecc-:xnack+</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">AMD:AMDGPU:9:0:12</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">gfx90c:xnack-</span></code></p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
</div>
<div class="section" id="code-object-v3-to-v4-note-records">
<span id="amdgpu-note-records-v3-v4"></span><h4><a class="toc-backref" href="#id110">Code Object V3 to V4 Note Records</a><a class="headerlink" href="#code-object-v3-to-v4-note-records" title="Permalink to this headline">¶</a></h4>
<p>The AMDGPU backend code object uses the following ELF note record in the
<code class="docutils literal notranslate"><span class="pre">.note</span></code> section when compiling for code object V3 to V4.</p>
<p>The note record vendor field is “AMDGPU”.</p>
<p>Additional note records may be present, but any which are not documented here
are deprecated and should not be used.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-elf-note-records-table-v3-v4">
<caption><span class="caption-text">AMDGPU Code Object V3 to V4 ELF Note Records</span><a class="headerlink" href="#amdgpu-elf-note-records-table-v3-v4" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 11%" />
<col style="width: 39%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“AMDGPU”</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">NT_AMDGPU_METADATA</span></code></p></td>
<td><p>Metadata in Message Pack <a class="reference internal" href="#msgpack" id="id40"><span>[MsgPack]</span></a>
binary format.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-elf-note-record-enumeration-values-table-v3-v4">
<caption><span class="caption-text">AMDGPU Code Object V3 to V4 ELF Note Record Enumeration Values</span><a class="headerlink" href="#amdgpu-elf-note-record-enumeration-values-table-v3-v4" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 86%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>reserved</em></p></td>
<td><p>0-31</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">NT_AMDGPU_METADATA</span></code></p></td>
<td><p>32</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">NT_AMDGPU_METADATA</span></code></dt><dd><p>Specifies extensible metadata associated with an AMDGPU code object. It is
encoded as a map in the Message Pack <a class="reference internal" href="#msgpack" id="id41"><span>[MsgPack]</span></a> binary data format. See
<a class="reference internal" href="#amdgpu-amdhsa-code-object-metadata-v3"><span class="std std-ref">Code Object V3 Metadata</span></a> and
<a class="reference internal" href="#amdgpu-amdhsa-code-object-metadata-v4"><span class="std std-ref">Code Object V4 Metadata</span></a> for the map keys defined for the
<code class="docutils literal notranslate"><span class="pre">amdhsa</span></code> OS.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="symbols">
<span id="amdgpu-symbols"></span><h3><a class="toc-backref" href="#id111">Symbols</a><a class="headerlink" href="#symbols" title="Permalink to this headline">¶</a></h3>
<p>Symbols include the following:</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-elf-symbols-table">
<caption><span class="caption-text">AMDGPU ELF Symbols</span><a class="headerlink" href="#amdgpu-elf-symbols-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 27%" />
<col style="width: 23%" />
<col style="width: 21%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Section</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>link-name</em></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">STT_OBJECT</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">.data</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.rodata</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.bss</span></code></p></li>
</ul>
</td>
<td><p>Global variable</p></td>
</tr>
<tr class="row-odd"><td><p><em>link-name</em><code class="docutils literal notranslate"><span class="pre">.kd</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">STT_OBJECT</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">.rodata</span></code></p></li>
</ul>
</td>
<td><p>Kernel descriptor</p></td>
</tr>
<tr class="row-even"><td><p><em>link-name</em></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">STT_FUNC</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">.text</span></code></p></li>
</ul>
</td>
<td><p>Kernel entry point</p></td>
</tr>
<tr class="row-odd"><td><p><em>link-name</em></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">STT_OBJECT</span></code></p></td>
<td><ul class="simple">
<li><p>SHN_AMDGPU_LDS</p></li>
</ul>
</td>
<td><p>Global variable in LDS</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl>
<dt>Global variable</dt><dd><p>Global variables both used and defined by the compilation unit.</p>
<p>If the symbol is defined in the compilation unit then it is allocated in the
appropriate section according to if it has initialized data or is readonly.</p>
<p>If the symbol is external then its section is <code class="docutils literal notranslate"><span class="pre">STN_UNDEF</span></code> and the loader
will resolve relocations using the definition provided by another code object
or explicitly defined by the runtime.</p>
<p>If the symbol resides in local/group memory (LDS) then its section is the
special processor specific section name <code class="docutils literal notranslate"><span class="pre">SHN_AMDGPU_LDS</span></code>, and the
<code class="docutils literal notranslate"><span class="pre">st_value</span></code> field describes alignment requirements as it does for common
symbols.</p>
</dd>
<dt>Kernel descriptor</dt><dd><p>Every HSA kernel has an associated kernel descriptor. It is the address of the
kernel descriptor that is used in the AQL dispatch packet used to invoke the
kernel, not the kernel entry point. The layout of the HSA kernel descriptor is
defined in <a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor"><span class="std std-ref">Kernel Descriptor</span></a>.</p>
</dd>
<dt>Kernel entry point</dt><dd><p>Every HSA kernel also has a symbol for its machine code entry point.</p>
</dd>
</dl>
</div>
<div class="section" id="relocation-records">
<span id="amdgpu-relocation-records"></span><h3><a class="toc-backref" href="#id112">Relocation Records</a><a class="headerlink" href="#relocation-records" title="Permalink to this headline">¶</a></h3>
<p>AMDGPU backend generates <code class="docutils literal notranslate"><span class="pre">Elf64_Rela</span></code> relocation records. Supported
relocatable fields are:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">word32</span></code></dt><dd><p>This specifies a 32-bit field occupying 4 bytes with arbitrary byte
alignment. These values use the same byte order as other word values in the
AMDGPU architecture.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">word64</span></code></dt><dd><p>This specifies a 64-bit field occupying 8 bytes with arbitrary byte
alignment. These values use the same byte order as other word values in the
AMDGPU architecture.</p>
</dd>
</dl>
<p>Following notations are used for specifying relocation calculations:</p>
<dl class="simple">
<dt><strong>A</strong></dt><dd><p>Represents the addend used to compute the value of the relocatable field.</p>
</dd>
<dt><strong>G</strong></dt><dd><p>Represents the offset into the global offset table at which the relocation
entry’s symbol will reside during execution.</p>
</dd>
<dt><strong>GOT</strong></dt><dd><p>Represents the address of the global offset table.</p>
</dd>
<dt><strong>P</strong></dt><dd><p>Represents the place (section offset for <code class="docutils literal notranslate"><span class="pre">et_rel</span></code> or address for <code class="docutils literal notranslate"><span class="pre">et_dyn</span></code>)
of the storage unit being relocated (computed using <code class="docutils literal notranslate"><span class="pre">r_offset</span></code>).</p>
</dd>
<dt><strong>S</strong></dt><dd><p>Represents the value of the symbol whose index resides in the relocation
entry. Relocations not using this must specify a symbol index of
<code class="docutils literal notranslate"><span class="pre">STN_UNDEF</span></code>.</p>
</dd>
<dt><strong>B</strong></dt><dd><p>Represents the base address of a loaded executable or shared object which is
the difference between the ELF address and the actual load address.
Relocations using this are only valid in executable or shared objects.</p>
</dd>
</dl>
<p>The following relocation types are supported:</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-elf-relocation-records-table">
<caption><span class="caption-text">AMDGPU ELF Relocation Records</span><a class="headerlink" href="#amdgpu-elf-relocation-records-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 9%" />
<col style="width: 6%" />
<col style="width: 13%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Relocation Type</p></th>
<th class="head"><p>Kind</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Field</p></th>
<th class="head"><p>Calculation</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_NONE</span></code></p></td>
<td></td>
<td><p>0</p></td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_ABS32_LO</span></code></p></td>
<td><p>Static,
Dynamic</p></td>
<td><p>1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word32</span></code></p></td>
<td><p>(S + A) &amp; 0xFFFFFFFF</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_ABS32_HI</span></code></p></td>
<td><p>Static,
Dynamic</p></td>
<td><p>2</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word32</span></code></p></td>
<td><p>(S + A) &gt;&gt; 32</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_ABS64</span></code></p></td>
<td><p>Static,
Dynamic</p></td>
<td><p>3</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word64</span></code></p></td>
<td><p>S + A</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_REL32</span></code></p></td>
<td><p>Static</p></td>
<td><p>4</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word32</span></code></p></td>
<td><p>S + A - P</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_REL64</span></code></p></td>
<td><p>Static</p></td>
<td><p>5</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word64</span></code></p></td>
<td><p>S + A - P</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_ABS32</span></code></p></td>
<td><p>Static,
Dynamic</p></td>
<td><p>6</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word32</span></code></p></td>
<td><p>S + A</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_GOTPCREL</span></code></p></td>
<td><p>Static</p></td>
<td><p>7</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word32</span></code></p></td>
<td><p>G + GOT + A - P</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_GOTPCREL32_LO</span></code></p></td>
<td><p>Static</p></td>
<td><p>8</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word32</span></code></p></td>
<td><p>(G + GOT + A - P) &amp; 0xFFFFFFFF</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_GOTPCREL32_HI</span></code></p></td>
<td><p>Static</p></td>
<td><p>9</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word32</span></code></p></td>
<td><p>(G + GOT + A - P) &gt;&gt; 32</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_REL32_LO</span></code></p></td>
<td><p>Static</p></td>
<td><p>10</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word32</span></code></p></td>
<td><p>(S + A - P) &amp; 0xFFFFFFFF</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_REL32_HI</span></code></p></td>
<td><p>Static</p></td>
<td><p>11</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word32</span></code></p></td>
<td><p>(S + A - P) &gt;&gt; 32</p></td>
</tr>
<tr class="row-even"><td><p><em>reserved</em></p></td>
<td></td>
<td><p>12</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_RELATIVE64</span></code></p></td>
<td><p>Dynamic</p></td>
<td><p>13</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word64</span></code></p></td>
<td><p>B + A</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_REL16</span></code></p></td>
<td><p>Static</p></td>
<td><p>14</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">word16</span></code></p></td>
<td><p>((S + A - P) - 4) / 4</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">R_AMDGPU_ABS32_LO</span></code> and <code class="docutils literal notranslate"><span class="pre">R_AMDGPU_ABS32_HI</span></code> are only supported by
the <code class="docutils literal notranslate"><span class="pre">mesa3d</span></code> OS, which does not support <code class="docutils literal notranslate"><span class="pre">R_AMDGPU_ABS64</span></code>.</p>
<p>There is no current OS loader support for 32-bit programs and so
<code class="docutils literal notranslate"><span class="pre">R_AMDGPU_ABS32</span></code> is not used.</p>
</div>
<div class="section" id="loaded-code-object-path-uniform-resource-identifier-uri">
<span id="amdgpu-loaded-code-object-path-uniform-resource-identifier"></span><h3><a class="toc-backref" href="#id113">Loaded Code Object Path Uniform Resource Identifier (URI)</a><a class="headerlink" href="#loaded-code-object-path-uniform-resource-identifier-uri" title="Permalink to this headline">¶</a></h3>
<p>The AMD GPU code object loader represents the path of the ELF shared object from
which the code object was loaded as a textual Unifom Resource Identifier (URI).
Note that the code object is the in memory loaded relocated form of the ELF
shared object.  Multiple code objects may be loaded at different memory
addresses in the same process from the same ELF shared object.</p>
<p>The loaded code object path URI syntax is defined by the following BNF syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code_object_uri</span> <span class="p">::</span><span class="o">==</span> <span class="n">file_uri</span> <span class="o">|</span> <span class="n">memory_uri</span>
<span class="n">file_uri</span>        <span class="p">::</span><span class="o">==</span> <span class="s2">&quot;file://&quot;</span> <span class="n">file_path</span> <span class="p">[</span> <span class="n">range_specifier</span> <span class="p">]</span>
<span class="n">memory_uri</span>      <span class="p">::</span><span class="o">==</span> <span class="s2">&quot;memory://&quot;</span> <span class="n">process_id</span> <span class="n">range_specifier</span>
<span class="n">range_specifier</span> <span class="p">::</span><span class="o">==</span> <span class="p">[</span> <span class="s2">&quot;#&quot;</span> <span class="o">|</span> <span class="s2">&quot;?&quot;</span> <span class="p">]</span> <span class="s2">&quot;offset=&quot;</span> <span class="n">number</span> <span class="s2">&quot;&amp;&quot;</span> <span class="s2">&quot;size=&quot;</span> <span class="n">number</span>
<span class="n">file_path</span>       <span class="p">::</span><span class="o">==</span> <span class="n">URI_ENCODED_OS_FILE_PATH</span>
<span class="n">process_id</span>      <span class="p">::</span><span class="o">==</span> <span class="n">DECIMAL_NUMBER</span>
<span class="n">number</span>          <span class="p">::</span><span class="o">==</span> <span class="n">HEX_NUMBER</span> <span class="o">|</span> <span class="n">DECIMAL_NUMBER</span> <span class="o">|</span> <span class="n">OCTAL_NUMBER</span>
</pre></div>
</div>
<dl class="simple">
<dt><strong>number</strong></dt><dd><p>Is a C integral literal where hexadecimal values are prefixed by “0x” or “0X”,
and octal values by “0”.</p>
</dd>
<dt><strong>file_path</strong></dt><dd><p>Is the file’s path specified as a URI encoded UTF-8 string. In URI encoding,
every character that is not in the regular expression <code class="docutils literal notranslate"><span class="pre">[a-zA-Z0-9/_.~-]</span></code> is
encoded as two uppercase hexadecimal digits proceeded by “%”.  Directories in
the path are separated by “/”.</p>
</dd>
<dt><strong>offset</strong></dt><dd><p>Is a 0-based byte offset to the start of the code object.  For a file URI, it
is from the start of the file specified by the <code class="docutils literal notranslate"><span class="pre">file_path</span></code>, and if omitted
defaults to 0. For a memory URI, it is the memory address and is required.</p>
</dd>
<dt><strong>size</strong></dt><dd><p>Is the number of bytes in the code object.  For a file URI, if omitted it
defaults to the size of the file.  It is required for a memory URI.</p>
</dd>
<dt><strong>process_id</strong></dt><dd><p>Is the identity of the process owning the memory.  For Linux it is the C
unsigned integral decimal literal for the process ID (PID).</p>
</dd>
</dl>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">file</span><span class="p">:</span><span class="o">///</span><span class="n">dir1</span><span class="o">/</span><span class="n">dir2</span><span class="o">/</span><span class="n">file1</span>
<span class="n">file</span><span class="p">:</span><span class="o">///</span><span class="n">dir3</span><span class="o">/</span><span class="n">dir4</span><span class="o">/</span><span class="n">file2</span><span class="c1">#offset=0x2000&amp;size=3000</span>
<span class="n">memory</span><span class="p">:</span><span class="o">//</span><span class="mi">1234</span><span class="c1">#offset=0x20000&amp;size=3000</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="dwarf-debug-information">
<span id="amdgpu-dwarf-debug-information"></span><h2><a class="toc-backref" href="#id114">DWARF Debug Information</a><a class="headerlink" href="#dwarf-debug-information" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This section describes <strong>provisional support</strong> for AMDGPU DWARF <a class="reference internal" href="#dwarf" id="id43"><span>[DWARF]</span></a> that
is not currently fully implemented and is subject to change.</p>
</div>
<p>AMDGPU generates DWARF <a class="reference internal" href="#dwarf" id="id44"><span>[DWARF]</span></a> debugging information ELF sections (see
<a class="reference internal" href="#amdgpu-elf-code-object"><span class="std std-ref">ELF Code Object</span></a>) which contain information that maps the code
object executable code and data to the source language constructs. It can be
used by tools such as debuggers and profilers. It uses features defined in
<a class="reference internal" href="AMDGPUDwarfExtensionsForHeterogeneousDebugging.html"><span class="doc">DWARF Extensions For Heterogeneous Debugging</span></a> that are made available in
DWARF Version 4 and DWARF Version 5 as an LLVM vendor extension.</p>
<p>This section defines the AMDGPU target architecture specific DWARF mappings.</p>
<div class="section" id="register-identifier">
<span id="amdgpu-dwarf-register-identifier"></span><h3><a class="toc-backref" href="#id115">Register Identifier</a><a class="headerlink" href="#register-identifier" title="Permalink to this headline">¶</a></h3>
<p>This section defines the AMDGPU target architecture register numbers used in
DWARF operation expressions (see DWARF Version 5 section 2.5 and
<a class="reference internal" href="AMDGPUDwarfExtensionsForHeterogeneousDebugging.html#amdgpu-dwarf-operation-expressions"><span class="std std-ref">DWARF Operation Expressions</span></a>) and Call Frame Information
instructions (see DWARF Version 5 section 6.4 and
<a class="reference internal" href="AMDGPUDwarfExtensionsForHeterogeneousDebugging.html#amdgpu-dwarf-call-frame-information"><span class="std std-ref">Call Frame Information</span></a>).</p>
<p>A single code object can contain code for kernels that have different wavefront
sizes. The vector registers and some scalar registers are based on the wavefront
size. AMDGPU defines distinct DWARF registers for each wavefront size. This
simplifies the consumer of the DWARF so that each register has a fixed size,
rather than being dynamic according to the wavefront size mode. Similarly,
distinct DWARF registers are defined for those registers that vary in size
according to the process address size. This allows a consumer to treat a
specific AMDGPU processor as a single architecture regardless of how it is
configured at run time. The compiler explicitly specifies the DWARF registers
that match the mode in which the code it is generating will be executed.</p>
<p>DWARF registers are encoded as numbers, which are mapped to architecture
registers. The mapping for AMDGPU is defined in
<a class="reference internal" href="#amdgpu-dwarf-register-mapping-table"><span class="std std-ref">AMDGPU DWARF Register Mapping</span></a>. All AMDGPU targets use the same
mapping.</p>
<table class="docutils align-default" id="amdgpu-dwarf-register-mapping-table">
<caption><span class="caption-text">AMDGPU DWARF Register Mapping</span><a class="headerlink" href="#amdgpu-dwarf-register-mapping-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 19%" />
<col style="width: 23%" />
<col style="width: 11%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>DWARF Register</p></th>
<th class="head"><p>AMDGPU Register</p></th>
<th class="head"><p>Bit Size</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>PC_32</p></td>
<td><p>32</p></td>
<td><p>Program Counter (PC) when
executing in a 32-bit process
address space. Used in the CFI to
describe the PC of the calling
frame.</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>EXEC_MASK_32</p></td>
<td><p>32</p></td>
<td><p>Execution Mask Register when
executing in wavefront 32 mode.</p></td>
</tr>
<tr class="row-even"><td><p>2-15</p></td>
<td><p><em>Reserved</em></p></td>
<td></td>
<td><p><em>Reserved for highly accessed
registers using DWARF shortcut.</em></p></td>
</tr>
<tr class="row-odd"><td><p>16</p></td>
<td><p>PC_64</p></td>
<td><p>64</p></td>
<td><p>Program Counter (PC) when
executing in a 64-bit process
address space. Used in the CFI to
describe the PC of the calling
frame.</p></td>
</tr>
<tr class="row-even"><td><p>17</p></td>
<td><p>EXEC_MASK_64</p></td>
<td><p>64</p></td>
<td><p>Execution Mask Register when
executing in wavefront 64 mode.</p></td>
</tr>
<tr class="row-odd"><td><p>18-31</p></td>
<td><p><em>Reserved</em></p></td>
<td></td>
<td><p><em>Reserved for highly accessed
registers using DWARF shortcut.</em></p></td>
</tr>
<tr class="row-even"><td><p>32-95</p></td>
<td><p>SGPR0-SGPR63</p></td>
<td><p>32</p></td>
<td><p>Scalar General Purpose
Registers.</p></td>
</tr>
<tr class="row-odd"><td><p>96-127</p></td>
<td><p><em>Reserved</em></p></td>
<td></td>
<td><p><em>Reserved for frequently accessed
registers using DWARF 1-byte ULEB.</em></p></td>
</tr>
<tr class="row-even"><td><p>128</p></td>
<td><p>STATUS</p></td>
<td><p>32</p></td>
<td><p>Status Register.</p></td>
</tr>
<tr class="row-odd"><td><p>129-511</p></td>
<td><p><em>Reserved</em></p></td>
<td></td>
<td><p><em>Reserved for future Scalar
Architectural Registers.</em></p></td>
</tr>
<tr class="row-even"><td><p>512</p></td>
<td><p>VCC_32</p></td>
<td><p>32</p></td>
<td><p>Vector Condition Code Register
when executing in wavefront 32
mode.</p></td>
</tr>
<tr class="row-odd"><td><p>513-1023</p></td>
<td><p><em>Reserved</em></p></td>
<td></td>
<td><p><em>Reserved for future Vector
Architectural Registers when
executing in wavefront 32 mode.</em></p></td>
</tr>
<tr class="row-even"><td><p>768</p></td>
<td><p>VCC_64</p></td>
<td><p>64</p></td>
<td><p>Vector Condition Code Register
when executing in wavefront 64
mode.</p></td>
</tr>
<tr class="row-odd"><td><p>769-1023</p></td>
<td><p><em>Reserved</em></p></td>
<td></td>
<td><p><em>Reserved for future Vector
Architectural Registers when
executing in wavefront 64 mode.</em></p></td>
</tr>
<tr class="row-even"><td><p>1024-1087</p></td>
<td><p><em>Reserved</em></p></td>
<td></td>
<td><p><em>Reserved for padding.</em></p></td>
</tr>
<tr class="row-odd"><td><p>1088-1129</p></td>
<td><p>SGPR64-SGPR105</p></td>
<td><p>32</p></td>
<td><p>Scalar General Purpose Registers.</p></td>
</tr>
<tr class="row-even"><td><p>1130-1535</p></td>
<td><p><em>Reserved</em></p></td>
<td></td>
<td><p><em>Reserved for future Scalar
General Purpose Registers.</em></p></td>
</tr>
<tr class="row-odd"><td><p>1536-1791</p></td>
<td><p>VGPR0-VGPR255</p></td>
<td><p>32*32</p></td>
<td><p>Vector General Purpose Registers
when executing in wavefront 32
mode.</p></td>
</tr>
<tr class="row-even"><td><p>1792-2047</p></td>
<td><p><em>Reserved</em></p></td>
<td></td>
<td><p><em>Reserved for future Vector
General Purpose Registers when
executing in wavefront 32 mode.</em></p></td>
</tr>
<tr class="row-odd"><td><p>2048-2303</p></td>
<td><p>AGPR0-AGPR255</p></td>
<td><p>32*32</p></td>
<td><p>Vector Accumulation Registers
when executing in wavefront 32
mode.</p></td>
</tr>
<tr class="row-even"><td><p>2304-2559</p></td>
<td><p><em>Reserved</em></p></td>
<td></td>
<td><p><em>Reserved for future Vector
Accumulation Registers when
executing in wavefront 32 mode.</em></p></td>
</tr>
<tr class="row-odd"><td><p>2560-2815</p></td>
<td><p>VGPR0-VGPR255</p></td>
<td><p>64*32</p></td>
<td><p>Vector General Purpose Registers
when executing in wavefront 64
mode.</p></td>
</tr>
<tr class="row-even"><td><p>2816-3071</p></td>
<td><p><em>Reserved</em></p></td>
<td></td>
<td><p><em>Reserved for future Vector
General Purpose Registers when
executing in wavefront 64 mode.</em></p></td>
</tr>
<tr class="row-odd"><td><p>3072-3327</p></td>
<td><p>AGPR0-AGPR255</p></td>
<td><p>64*32</p></td>
<td><p>Vector Accumulation Registers
when executing in wavefront 64
mode.</p></td>
</tr>
<tr class="row-even"><td><p>3328-3583</p></td>
<td><p><em>Reserved</em></p></td>
<td></td>
<td><p><em>Reserved for future Vector
Accumulation Registers when
executing in wavefront 64 mode.</em></p></td>
</tr>
</tbody>
</table>
<p>The vector registers are represented as the full size for the wavefront. They
are organized as consecutive dwords (32-bits), one per lane, with the dword at
the least significant bit position corresponding to lane 0 and so forth. DWARF
location expressions involving the <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset</span></code> and
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_push_lane</span></code> operations are used to select the part of the vector
register corresponding to the lane that is executing the current thread of
execution in languages that are implemented using a SIMD or SIMT execution
model.</p>
<p>If the wavefront size is 32 lanes then the wavefront 32 mode register
definitions are used. If the wavefront size is 64 lanes then the wavefront 64
mode register definitions are used. Some AMDGPU targets support executing in
both wavefront 32 and wavefront 64 mode. The register definitions corresponding
to the wavefront mode of the generated code will be used.</p>
<p>If code is generated to execute in a 32-bit process address space, then the
32-bit process address space register definitions are used. If code is generated
to execute in a 64-bit process address space, then the 64-bit process address
space register definitions are used. The <code class="docutils literal notranslate"><span class="pre">amdgcn</span></code> target only supports the
64-bit process address space.</p>
</div>
<div class="section" id="address-class-identifier">
<span id="amdgpu-dwarf-address-class-identifier"></span><h3><a class="toc-backref" href="#id116">Address Class Identifier</a><a class="headerlink" href="#address-class-identifier" title="Permalink to this headline">¶</a></h3>
<p>The DWARF address class represents the source language memory space. See DWARF
Version 5 section 2.12 which is updated by the <em>DWARF Extensions For
Heterogeneous Debugging</em> section <a class="reference internal" href="AMDGPUDwarfExtensionsForHeterogeneousDebugging.html#amdgpu-dwarf-segment-addresses"><span class="std std-ref">Segmented Addresses</span></a>.</p>
<p>The DWARF address class mapping used for AMDGPU is defined in
<a class="reference internal" href="#amdgpu-dwarf-address-class-mapping-table"><span class="std std-ref">AMDGPU DWARF Address Class Mapping</span></a>.</p>
<table class="docutils align-default" id="amdgpu-dwarf-address-class-mapping-table">
<caption><span class="caption-text">AMDGPU DWARF Address Class Mapping</span><a class="headerlink" href="#amdgpu-dwarf-address-class-mapping-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 52%" />
<col style="width: 13%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="2"><p>DWARF</p></th>
<th class="head"><p>AMDGPU</p></th>
</tr>
<tr class="row-even"><th class="head"><p>Address Class Name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Address Space</p></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_none</span></code></p></td>
<td><p>0x0000</p></td>
<td><p>Generic (Flat)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_global</span></code></p></td>
<td><p>0x0001</p></td>
<td><p>Global</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_constant</span></code></p></td>
<td><p>0x0002</p></td>
<td><p>Global</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_group</span></code></p></td>
<td><p>0x0003</p></td>
<td><p>Local (group/LDS)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_private</span></code></p></td>
<td><p>0x0004</p></td>
<td><p>Private (Scratch)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_AMDGPU_region</span></code></p></td>
<td><p>0x8000</p></td>
<td><p>Region (GDS)</p></td>
</tr>
</tbody>
</table>
<p>The DWARF address class values defined in the <em>DWARF Extensions For
Heterogeneous Debugging</em> section <a class="reference internal" href="AMDGPUDwarfExtensionsForHeterogeneousDebugging.html#amdgpu-dwarf-segment-addresses"><span class="std std-ref">Segmented Addresses</span></a> are used.</p>
<p>In addition, <code class="docutils literal notranslate"><span class="pre">DW_ADDR_AMDGPU_region</span></code> is encoded as a vendor extension. This is
available for use for the AMD extension for access to the hardware GDS memory
which is scratchpad memory allocated per device.</p>
<p>For AMDGPU if no <code class="docutils literal notranslate"><span class="pre">DW_AT_address_class</span></code> attribute is present, then the default
address class of <code class="docutils literal notranslate"><span class="pre">DW_ADDR_none</span></code> is used.</p>
<p>See <a class="reference internal" href="#amdgpu-dwarf-address-space-identifier"><span class="std std-ref">Address Space Identifier</span></a> for information on the AMDGPU
mapping of DWARF address classes to DWARF address spaces, including address size
and NULL value.</p>
</div>
<div class="section" id="address-space-identifier">
<span id="amdgpu-dwarf-address-space-identifier"></span><h3><a class="toc-backref" href="#id117">Address Space Identifier</a><a class="headerlink" href="#address-space-identifier" title="Permalink to this headline">¶</a></h3>
<p>DWARF address spaces correspond to target architecture specific linear
addressable memory areas. See DWARF Version 5 section 2.12 and <em>DWARF Extensions
For Heterogeneous Debugging</em> section <a class="reference internal" href="AMDGPUDwarfExtensionsForHeterogeneousDebugging.html#amdgpu-dwarf-segment-addresses"><span class="std std-ref">Segmented Addresses</span></a>.</p>
<p>The DWARF address space mapping used for AMDGPU is defined in
<a class="reference internal" href="#amdgpu-dwarf-address-space-mapping-table"><span class="std std-ref">AMDGPU DWARF Address Space Mapping</span></a>.</p>
<table class="docutils align-default" id="amdgpu-dwarf-address-space-mapping-table">
<caption><span class="caption-text">AMDGPU DWARF Address Space Mapping</span><a class="headerlink" href="#amdgpu-dwarf-address-space-mapping-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 39%" />
<col style="width: 5%" />
<col style="width: 7%" />
<col style="width: 8%" />
<col style="width: 17%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>DWARF</p></th>
<th class="head"></th>
<th class="head" colspan="2"></th>
<th class="head"><p>AMDGPU</p></th>
<th class="head"><p>Notes</p></th>
</tr>
<tr class="row-even"><th class="head"><p>Address Space Name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Address</p></th>
<th class="head"><p>Bit Size</p></th>
<th class="head"><p>Address Space</p></th>
<th class="head"></th>
</tr>
<tr class="row-odd"><th class="head"></th>
<th class="head"></th>
<th class="head"><p>64-bit
process
address
space</p></th>
<th class="head"><p>32-bit
process
address
space</p></th>
<th class="head"></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ASPACE_none</span></code></p></td>
<td><p>0x00</p></td>
<td><p>64</p></td>
<td><p>32</p></td>
<td><p>Global</p></td>
<td><p><em>default address space</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ASPACE_AMDGPU_generic</span></code></p></td>
<td><p>0x01</p></td>
<td><p>64</p></td>
<td><p>32</p></td>
<td><p>Generic (Flat)</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ASPACE_AMDGPU_region</span></code></p></td>
<td><p>0x02</p></td>
<td><p>32</p></td>
<td><p>32</p></td>
<td><p>Region (GDS)</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ASPACE_AMDGPU_local</span></code></p></td>
<td><p>0x03</p></td>
<td><p>32</p></td>
<td><p>32</p></td>
<td><p>Local (group/LDS)</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><em>Reserved</em></p></td>
<td><p>0x04</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ASPACE_AMDGPU_private_lane</span></code></p></td>
<td><p>0x05</p></td>
<td><p>32</p></td>
<td><p>32</p></td>
<td><p>Private (Scratch)</p></td>
<td><p><em>focused lane</em></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ASPACE_AMDGPU_private_wave</span></code></p></td>
<td><p>0x06</p></td>
<td><p>32</p></td>
<td><p>32</p></td>
<td><p>Private (Scratch)</p></td>
<td><p><em>unswizzled wavefront</em></p></td>
</tr>
</tbody>
</table>
<p>See <a class="reference internal" href="#amdgpu-address-spaces"><span class="std std-ref">Address Spaces</span></a> for information on the AMDGPU address spaces
including address size and NULL value.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_ASPACE_none</span></code> address space is the default target architecture address
space used in DWARF operations that do not specify an address space. It
therefore has to map to the global address space so that the <code class="docutils literal notranslate"><span class="pre">DW_OP_addr*</span></code> and
related operations can refer to addresses in the program code.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_ASPACE_AMDGPU_generic</span></code> address space allows location expressions to
specify the flat address space. If the address corresponds to an address in the
local address space, then it corresponds to the wavefront that is executing the
focused thread of execution. If the address corresponds to an address in the
private address space, then it corresponds to the lane that is executing the
focused thread of execution for languages that are implemented using a SIMD or
SIMT execution model.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>CUDA-like languages such as HIP that do not have address spaces in the
language type system, but do allow variables to be allocated in different
address spaces, need to explicitly specify the <code class="docutils literal notranslate"><span class="pre">DW_ASPACE_AMDGPU_generic</span></code>
address space in the DWARF expression operations as the default address space
is the global address space.</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_ASPACE_AMDGPU_local</span></code> address space allows location expressions to
specify the local address space corresponding to the wavefront that is executing
the focused thread of execution.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_ASPACE_AMDGPU_private_lane</span></code> address space allows location expressions
to specify the private address space corresponding to the lane that is executing
the focused thread of execution for languages that are implemented using a SIMD
or SIMT execution model.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_ASPACE_AMDGPU_private_wave</span></code> address space allows location expressions
to specify the unswizzled private address space corresponding to the wavefront
that is executing the focused thread of execution. The wavefront view of private
memory is the per wavefront unswizzled backing memory layout defined in
<a class="reference internal" href="#amdgpu-address-spaces"><span class="std std-ref">Address Spaces</span></a>, such that address 0 corresponds to the first
location for the backing memory of the wavefront (namely the address is not
offset by <code class="docutils literal notranslate"><span class="pre">wavefront-scratch-base</span></code>). The following formula can be used to
convert from a <code class="docutils literal notranslate"><span class="pre">DW_ASPACE_AMDGPU_private_lane</span></code> address to a
<code class="docutils literal notranslate"><span class="pre">DW_ASPACE_AMDGPU_private_wave</span></code> address:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">private</span><span class="o">-</span><span class="n">address</span><span class="o">-</span><span class="n">wavefront</span> <span class="o">=</span>
  <span class="p">((</span><span class="n">private</span><span class="o">-</span><span class="n">address</span><span class="o">-</span><span class="n">lane</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="n">wavefront</span><span class="o">-</span><span class="n">size</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span>
  <span class="p">(</span><span class="n">wavefront</span><span class="o">-</span><span class="n">lane</span><span class="o">-</span><span class="nb">id</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">private</span><span class="o">-</span><span class="n">address</span><span class="o">-</span><span class="n">lane</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>If the <code class="docutils literal notranslate"><span class="pre">DW_ASPACE_AMDGPU_private_lane</span></code> address is dword aligned, and the start
of the dwords for each lane starting with lane 0 is required, then this
simplifies to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">private</span><span class="o">-</span><span class="n">address</span><span class="o">-</span><span class="n">wavefront</span> <span class="o">=</span>
  <span class="n">private</span><span class="o">-</span><span class="n">address</span><span class="o">-</span><span class="n">lane</span> <span class="o">*</span> <span class="n">wavefront</span><span class="o">-</span><span class="n">size</span>
</pre></div>
</div>
<p>A compiler can use the <code class="docutils literal notranslate"><span class="pre">DW_ASPACE_AMDGPU_private_wave</span></code> address space to read a
complete spilled vector register back into a complete vector register in the
CFI. The frame pointer can be a private lane address which is dword aligned,
which can be shifted to multiply by the wavefront size, and then used to form a
private wavefront address that gives a location for a contiguous set of dwords,
one per lane, where the vector register dwords are spilled. The compiler knows
the wavefront size since it generates the code. Note that the type of the
address may have to be converted as the size of a
<code class="docutils literal notranslate"><span class="pre">DW_ASPACE_AMDGPU_private_lane</span></code> address may be smaller than the size of a
<code class="docutils literal notranslate"><span class="pre">DW_ASPACE_AMDGPU_private_wave</span></code> address.</p>
</div>
<div class="section" id="lane-identifier">
<span id="amdgpu-dwarf-lane-identifier"></span><h3><a class="toc-backref" href="#id118">Lane identifier</a><a class="headerlink" href="#lane-identifier" title="Permalink to this headline">¶</a></h3>
<p>DWARF lane identifies specify a target architecture lane position for hardware
that executes in a SIMD or SIMT manner, and on which a source language maps its
threads of execution onto those lanes. The DWARF lane identifier is pushed by
the <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_push_lane</span></code> DWARF expression operation. See DWARF Version 5
section 2.5 which is updated by <em>DWARF Extensions For Heterogeneous Debugging</em>
section <a class="reference internal" href="AMDGPUDwarfExtensionsForHeterogeneousDebugging.html#amdgpu-dwarf-operation-expressions"><span class="std std-ref">DWARF Operation Expressions</span></a>.</p>
<p>For AMDGPU, the lane identifier corresponds to the hardware lane ID of a
wavefront. It is numbered from 0 to the wavefront size minus 1.</p>
</div>
<div class="section" id="operation-expressions">
<h3><a class="toc-backref" href="#id119">Operation Expressions</a><a class="headerlink" href="#operation-expressions" title="Permalink to this headline">¶</a></h3>
<p>DWARF expressions are used to compute program values and the locations of
program objects. See DWARF Version 5 section 2.5 and
<a class="reference internal" href="AMDGPUDwarfExtensionsForHeterogeneousDebugging.html#amdgpu-dwarf-operation-expressions"><span class="std std-ref">DWARF Operation Expressions</span></a>.</p>
<p>DWARF location descriptions describe how to access storage which includes memory
and registers. When accessing storage on AMDGPU, bytes are ordered with least
significant bytes first, and bits are ordered within bytes with least
significant bits first.</p>
<p>For AMDGPU CFI expressions, <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_select_bit_piece</span></code> is used to describe
unwinding vector registers that are spilled under the execution mask to memory:
the zero-single location description is the vector register, and the one-single
location description is the spilled memory location description. The
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code> is used to specify the address space of the
memory location description.</p>
<p>In AMDGPU expressions, <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_select_bit_piece</span></code> is used by the
<code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code> attribute expression where divergent control flow is
controlled by the execution mask. An undefined location description together
with <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_extend</span></code> is used to indicate the lane was not active on entry
to the subprogram. See <a class="reference internal" href="#amdgpu-dwarf-dw-at-llvm-lane-pc"><span class="std std-ref">DW_AT_LLVM_lane_pc</span></a> for an example.</p>
</div>
<div class="section" id="debugger-information-entry-attributes">
<h3><a class="toc-backref" href="#id120">Debugger Information Entry Attributes</a><a class="headerlink" href="#debugger-information-entry-attributes" title="Permalink to this headline">¶</a></h3>
<p>This section describes how certain debugger information entry attributes are
used by AMDGPU. See the sections in DWARF Version 5 section 2 which are updated
by <em>DWARF Extensions For Heterogeneous Debugging</em> section
<a class="reference internal" href="AMDGPUDwarfExtensionsForHeterogeneousDebugging.html#amdgpu-dwarf-debugging-information-entry-attributes"><span class="std std-ref">Debugging Information Entry Attributes</span></a>.</p>
<div class="section" id="dw-at-llvm-lane-pc">
<span id="amdgpu-dwarf-dw-at-llvm-lane-pc"></span><h4><a class="toc-backref" href="#id121"><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code></a><a class="headerlink" href="#dw-at-llvm-lane-pc" title="Permalink to this headline">¶</a></h4>
<p>For AMDGPU, the <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code> attribute is used to specify the program
location of the separate lanes of a SIMT thread.</p>
<p>If the lane is an active lane then this will be the same as the current program
location.</p>
<p>If the lane is inactive, but was active on entry to the subprogram, then this is
the program location in the subprogram at which execution of the lane is
conceptual positioned.</p>
<p>If the lane was not active on entry to the subprogram, then this will be the
undefined location. A client debugger can check if the lane is part of a valid
work-group by checking that the lane is in the range of the associated
work-group within the grid, accounting for partial work-groups. If it is not,
then the debugger can omit any information for the lane. Otherwise, the debugger
may repeatedly unwind the stack and inspect the <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code> of the
calling subprogram until it finds a non-undefined location. Conceptually the
lane only has the call frames that it has a non-undefined
<code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code>.</p>
<p>The following example illustrates how the AMDGPU backend can generate a DWARF
location list expression for the nested <code class="docutils literal notranslate"><span class="pre">IF/THEN/ELSE</span></code> structures of the
following subprogram pseudo code for a target with 64 lanes per wavefront.</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">SUBPROGRAM</span> <span class="n">X</span>
<span class="n">BEGIN</span>
  <span class="n">a</span><span class="p">;</span>
  <span class="n">IF</span> <span class="p">(</span><span class="n">c1</span><span class="p">)</span> <span class="n">THEN</span>
    <span class="n">b</span><span class="p">;</span>
    <span class="n">IF</span> <span class="p">(</span><span class="n">c2</span><span class="p">)</span> <span class="n">THEN</span>
      <span class="n">c</span><span class="p">;</span>
    <span class="n">ELSE</span>
      <span class="n">d</span><span class="p">;</span>
    <span class="n">ENDIF</span>
    <span class="n">e</span><span class="p">;</span>
  <span class="n">ELSE</span>
    <span class="n">f</span><span class="p">;</span>
  <span class="n">ENDIF</span>
  <span class="n">g</span><span class="p">;</span>
<span class="n">END</span>
</pre></div>
</td></tr></table></div>
<p>The AMDGPU backend may generate the following pseudo LLVM MIR to manipulate the
execution mask (<code class="docutils literal notranslate"><span class="pre">EXEC</span></code>) to linearize the control flow. The condition is
evaluated to make a mask of the lanes for which the condition evaluates to true.
First the <code class="docutils literal notranslate"><span class="pre">THEN</span></code> region is executed by setting the <code class="docutils literal notranslate"><span class="pre">EXEC</span></code> mask to the
logical <code class="docutils literal notranslate"><span class="pre">AND</span></code> of the current <code class="docutils literal notranslate"><span class="pre">EXEC</span></code> mask with the condition mask. Then the
<code class="docutils literal notranslate"><span class="pre">ELSE</span></code> region is executed by negating the <code class="docutils literal notranslate"><span class="pre">EXEC</span></code> mask and logical <code class="docutils literal notranslate"><span class="pre">AND</span></code> of
the saved <code class="docutils literal notranslate"><span class="pre">EXEC</span></code> mask at the start of the region. After the <code class="docutils literal notranslate"><span class="pre">IF/THEN/ELSE</span></code>
region the <code class="docutils literal notranslate"><span class="pre">EXEC</span></code> mask is restored to the value it had at the beginning of the
region. This is shown below. Other approaches are possible, but the basic
concept is the same.</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight"><pre><span></span>$lex_start:
  a;
  %1 = EXEC
  %2 = c1
$lex_1_start:
  EXEC = %1 &amp; %2
$if_1_then:
    b;
    %3 = EXEC
    %4 = c2
$lex_1_1_start:
    EXEC = %3 &amp; %4
$lex_1_1_then:
      c;
    EXEC = ~EXEC &amp; %3
$lex_1_1_else:
      d;
    EXEC = %3
$lex_1_1_end:
    e;
  EXEC = ~EXEC &amp; %1
$lex_1_else:
    f;
  EXEC = %1
$lex_1_end:
  g;
$lex_end:
</pre></div>
</td></tr></table></div>
<p>To create the DWARF location list expression that defines the location
description of a vector of lane program locations, the LLVM MIR <code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code>
pseudo instruction can be used to annotate the linearized control flow. This can
be done by defining an artificial variable for the lane PC. The DWARF location
list expression created for it is used as the value of the
<code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code> attribute on the subprogram’s debugger information entry.</p>
<p>A DWARF procedure is defined for each well nested structured control flow region
which provides the conceptual lane program location for a lane if it is not
active (namely it is divergent). The DWARF operation expression for each region
conceptually inherits the value of the immediately enclosing region and modifies
it according to the semantics of the region.</p>
<p>For an <code class="docutils literal notranslate"><span class="pre">IF/THEN/ELSE</span></code> region the divergent program location is at the start of
the region for the <code class="docutils literal notranslate"><span class="pre">THEN</span></code> region since it is executed first. For the <code class="docutils literal notranslate"><span class="pre">ELSE</span></code>
region the divergent program location is at the end of the <code class="docutils literal notranslate"><span class="pre">IF/THEN/ELSE</span></code>
region since the <code class="docutils literal notranslate"><span class="pre">THEN</span></code> region has completed.</p>
<p>The lane PC artificial variable is assigned at each region transition. It uses
the immediately enclosing region’s DWARF procedure to compute the program
location for each lane assuming they are divergent, and then modifies the result
by inserting the current program location for each lane that the <code class="docutils literal notranslate"><span class="pre">EXEC</span></code> mask
indicates is active.</p>
<p>By having separate DWARF procedures for each region, they can be reused to
define the value for any nested region. This reduces the total size of the DWARF
operation expressions.</p>
<p>The following provides an example using pseudo LLVM MIR.</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126</pre></div></td><td class="code"><div class="highlight"><pre><span></span>$lex_start:
  DEFINE_DWARF %__uint_64 = DW_TAG_base_type[
    DW_AT_name = &quot;__uint64&quot;;
    DW_AT_byte_size = 8;
    DW_AT_encoding = DW_ATE_unsigned;
  ];
  DEFINE_DWARF %__active_lane_pc = DW_TAG_dwarf_procedure[
    DW_AT_name = &quot;__active_lane_pc&quot;;
    DW_AT_location = [
      DW_OP_regx PC;
      DW_OP_LLVM_extend 64, 64;
      DW_OP_regval_type EXEC, %uint_64;
      DW_OP_LLVM_select_bit_piece 64, 64;
    ];
  ];
  DEFINE_DWARF %__divergent_lane_pc = DW_TAG_dwarf_procedure[
    DW_AT_name = &quot;__divergent_lane_pc&quot;;
    DW_AT_location = [
      DW_OP_LLVM_undefined;
      DW_OP_LLVM_extend 64, 64;
    ];
  ];
  DBG_VALUE $noreg, $noreg, %DW_AT_LLVM_lane_pc, DIExpression[
    DW_OP_call_ref %__divergent_lane_pc;
    DW_OP_call_ref %__active_lane_pc;
  ];
  a;
  %1 = EXEC;
  DBG_VALUE %1, $noreg, %__lex_1_save_exec;
  %2 = c1;
$lex_1_start:
  EXEC = %1 &amp; %2;
$lex_1_then:
    DEFINE_DWARF %__divergent_lane_pc_1_then = DW_TAG_dwarf_procedure[
      DW_AT_name = &quot;__divergent_lane_pc_1_then&quot;;
      DW_AT_location = DIExpression[
        DW_OP_call_ref %__divergent_lane_pc;
        DW_OP_addrx &amp;lex_1_start;
        DW_OP_stack_value;
        DW_OP_LLVM_extend 64, 64;
        DW_OP_call_ref %__lex_1_save_exec;
        DW_OP_deref_type 64, %__uint_64;
        DW_OP_LLVM_select_bit_piece 64, 64;
      ];
    ];
    DBG_VALUE $noreg, $noreg, %DW_AT_LLVM_lane_pc, DIExpression[
      DW_OP_call_ref %__divergent_lane_pc_1_then;
      DW_OP_call_ref %__active_lane_pc;
    ];
    b;
    %3 = EXEC;
    DBG_VALUE %3, %__lex_1_1_save_exec;
    %4 = c2;
$lex_1_1_start:
    EXEC = %3 &amp; %4;
$lex_1_1_then:
      DEFINE_DWARF %__divergent_lane_pc_1_1_then = DW_TAG_dwarf_procedure[
        DW_AT_name = &quot;__divergent_lane_pc_1_1_then&quot;;
        DW_AT_location = DIExpression[
          DW_OP_call_ref %__divergent_lane_pc_1_then;
          DW_OP_addrx &amp;lex_1_1_start;
          DW_OP_stack_value;
          DW_OP_LLVM_extend 64, 64;
          DW_OP_call_ref %__lex_1_1_save_exec;
          DW_OP_deref_type 64, %__uint_64;
          DW_OP_LLVM_select_bit_piece 64, 64;
        ];
      ];
      DBG_VALUE $noreg, $noreg, %DW_AT_LLVM_lane_pc, DIExpression[
        DW_OP_call_ref %__divergent_lane_pc_1_1_then;
        DW_OP_call_ref %__active_lane_pc;
      ];
      c;
    EXEC = ~EXEC &amp; %3;
$lex_1_1_else:
      DEFINE_DWARF %__divergent_lane_pc_1_1_else = DW_TAG_dwarf_procedure[
        DW_AT_name = &quot;__divergent_lane_pc_1_1_else&quot;;
        DW_AT_location = DIExpression[
          DW_OP_call_ref %__divergent_lane_pc_1_then;
          DW_OP_addrx &amp;lex_1_1_end;
          DW_OP_stack_value;
          DW_OP_LLVM_extend 64, 64;
          DW_OP_call_ref %__lex_1_1_save_exec;
          DW_OP_deref_type 64, %__uint_64;
          DW_OP_LLVM_select_bit_piece 64, 64;
        ];
      ];
      DBG_VALUE $noreg, $noreg, %DW_AT_LLVM_lane_pc, DIExpression[
        DW_OP_call_ref %__divergent_lane_pc_1_1_else;
        DW_OP_call_ref %__active_lane_pc;
      ];
      d;
    EXEC = %3;
$lex_1_1_end:
    DBG_VALUE $noreg, $noreg, %DW_AT_LLVM_lane_pc, DIExpression[
      DW_OP_call_ref %__divergent_lane_pc;
      DW_OP_call_ref %__active_lane_pc;
    ];
    e;
  EXEC = ~EXEC &amp; %1;
$lex_1_else:
    DEFINE_DWARF %__divergent_lane_pc_1_else = DW_TAG_dwarf_procedure[
      DW_AT_name = &quot;__divergent_lane_pc_1_else&quot;;
      DW_AT_location = DIExpression[
        DW_OP_call_ref %__divergent_lane_pc;
        DW_OP_addrx &amp;lex_1_end;
        DW_OP_stack_value;
        DW_OP_LLVM_extend 64, 64;
        DW_OP_call_ref %__lex_1_save_exec;
        DW_OP_deref_type 64, %__uint_64;
        DW_OP_LLVM_select_bit_piece 64, 64;
      ];
    ];
    DBG_VALUE $noreg, $noreg, %DW_AT_LLVM_lane_pc, DIExpression[
      DW_OP_call_ref %__divergent_lane_pc_1_else;
      DW_OP_call_ref %__active_lane_pc;
    ];
    f;
  EXEC = %1;
$lex_1_end:
  DBG_VALUE $noreg, $noreg, %DW_AT_LLVM_lane_pc DIExpression[
    DW_OP_call_ref %__divergent_lane_pc;
    DW_OP_call_ref %__active_lane_pc;
  ];
  g;
$lex_end:
</pre></div>
</td></tr></table></div>
<p>The DWARF procedure <code class="docutils literal notranslate"><span class="pre">%__active_lane_pc</span></code> is used to update the lane pc elements
that are active, with the current program location.</p>
<p>Artificial variables %__lex_1_save_exec and %__lex_1_1_save_exec are created for
the execution masks saved on entry to a region. Using the <code class="docutils literal notranslate"><span class="pre">DBG_VALUE</span></code> pseudo
instruction, location list entries will be created that describe where the
artificial variables are allocated at any given program location. The compiler
may allocate them to registers or spill them to memory.</p>
<p>The DWARF procedures for each region use the values of the saved execution mask
artificial variables to only update the lanes that are active on entry to the
region. All other lanes retain the value of the enclosing region where they were
last active. If they were not active on entry to the subprogram, then will have
the undefined location description.</p>
<p>Other structured control flow regions can be handled similarly. For example,
loops would set the divergent program location for the region at the end of the
loop. Any lanes active will be in the loop, and any lanes not active must have
exited the loop.</p>
<p>An <code class="docutils literal notranslate"><span class="pre">IF/THEN/ELSEIF/ELSEIF/...</span></code> region can be treated as a nest of
<code class="docutils literal notranslate"><span class="pre">IF/THEN/ELSE</span></code> regions.</p>
<p>The DWARF procedures can use the active lane artificial variable described in
<a class="reference internal" href="#amdgpu-dwarf-amdgpu-dw-at-llvm-active-lane"><span class="std std-ref">DW_AT_LLVM_active_lane</span></a> rather than the actual
<code class="docutils literal notranslate"><span class="pre">EXEC</span></code> mask in order to support whole or quad wavefront mode.</p>
</div>
<div class="section" id="dw-at-llvm-active-lane">
<span id="amdgpu-dwarf-amdgpu-dw-at-llvm-active-lane"></span><h4><a class="toc-backref" href="#id122"><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_active_lane</span></code></a><a class="headerlink" href="#dw-at-llvm-active-lane" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_active_lane</span></code> attribute on a subprogram debugger information
entry is used to specify the lanes that are conceptually active for a SIMT
thread.</p>
<p>The execution mask may be modified to implement whole or quad wavefront mode
operations. For example, all lanes may need to temporarily be made active to
execute a whole wavefront operation. Such regions would save the <code class="docutils literal notranslate"><span class="pre">EXEC</span></code> mask,
update it to enable the necessary lanes, perform the operations, and then
restore the <code class="docutils literal notranslate"><span class="pre">EXEC</span></code> mask from the saved value. While executing the whole
wavefront region, the conceptual execution mask is the saved value, not the
<code class="docutils literal notranslate"><span class="pre">EXEC</span></code> value.</p>
<p>This is handled by defining an artificial variable for the active lane mask. The
active lane mask artificial variable would be the actual <code class="docutils literal notranslate"><span class="pre">EXEC</span></code> mask for
normal regions, and the saved execution mask for regions where the mask is
temporarily updated. The location list expression created for this artificial
variable is used to define the value of the <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_active_lane</span></code>
attribute.</p>
</div>
<div class="section" id="dw-at-llvm-augmentation">
<h4><a class="toc-backref" href="#id123"><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_augmentation</span></code></a><a class="headerlink" href="#dw-at-llvm-augmentation" title="Permalink to this headline">¶</a></h4>
<p>For AMDGPU, the <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_augmentation</span></code> attribute of a compilation unit
debugger information entry has the following value for the augmentation string:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">amdgpu</span><span class="p">:</span><span class="n">v0</span><span class="o">.</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>The “vX.Y” specifies the major X and minor Y version number of the AMDGPU
extensions used in the DWARF of the compilation unit. The version number
conforms to <a class="reference internal" href="#semver" id="id45"><span>[SEMVER]</span></a>.</p>
</div>
</div>
<div class="section" id="call-frame-information">
<h3><a class="toc-backref" href="#id124">Call Frame Information</a><a class="headerlink" href="#call-frame-information" title="Permalink to this headline">¶</a></h3>
<p>DWARF Call Frame Information (CFI) describes how a consumer can virtually
<em>unwind</em> call frames in a running process or core dump. See DWARF Version 5
section 6.4 and <a class="reference internal" href="AMDGPUDwarfExtensionsForHeterogeneousDebugging.html#amdgpu-dwarf-call-frame-information"><span class="std std-ref">Call Frame Information</span></a>.</p>
<p>For AMDGPU, the Common Information Entry (CIE) fields have the following values:</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">augmentation</span></code> string contains the following null-terminated UTF-8 string:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">amd</span><span class="p">:</span><span class="n">v0</span><span class="o">.</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">vX.Y</span></code> specifies the major X and minor Y version number of the AMDGPU
extensions used in this CIE or to the FDEs that use it. The version number
conforms to <a class="reference internal" href="#semver" id="id46"><span>[SEMVER]</span></a>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">address_size</span></code> for the <code class="docutils literal notranslate"><span class="pre">Global</span></code> address space is defined in
<a class="reference internal" href="#amdgpu-dwarf-address-space-identifier"><span class="std std-ref">Address Space Identifier</span></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">segment_selector_size</span></code> is 0 as AMDGPU does not use a segment selector.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">code_alignment_factor</span></code> is 4 bytes.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">data_alignment_factor</span></code> is 4 bytes.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">return_address_register</span></code> is <code class="docutils literal notranslate"><span class="pre">PC_32</span></code> for 32-bit processes and <code class="docutils literal notranslate"><span class="pre">PC_64</span></code>
for 64-bit processes defined in <a class="reference internal" href="#amdgpu-dwarf-register-identifier"><span class="std std-ref">Register Identifier</span></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_instructions</span></code> Since a subprogram X with fewer registers can be
called from subprogram Y that has more allocated, X will not change any of
the extra registers as it cannot access them. Therefore, the default rule
for all columns is <code class="docutils literal notranslate"><span class="pre">same</span> <span class="pre">value</span></code>.</p></li>
</ol>
<p>For AMDGPU the register number follows the numbering defined in
<a class="reference internal" href="#amdgpu-dwarf-register-identifier"><span class="std std-ref">Register Identifier</span></a>.</p>
<p>For AMDGPU the instructions are variable size. A consumer can subtract 1 from
the return address to get the address of a byte within the call site
instructions. See DWARF Version 5 section 6.4.4.</p>
</div>
<div class="section" id="accelerated-access">
<h3><a class="toc-backref" href="#id125">Accelerated Access</a><a class="headerlink" href="#accelerated-access" title="Permalink to this headline">¶</a></h3>
<p>See DWARF Version 5 section 6.1.</p>
<div class="section" id="lookup-by-name-section-header">
<h4><a class="toc-backref" href="#id126">Lookup By Name Section Header</a><a class="headerlink" href="#lookup-by-name-section-header" title="Permalink to this headline">¶</a></h4>
<p>See DWARF Version 5 section 6.1.1.4.1 and <a class="reference internal" href="AMDGPUDwarfExtensionsForHeterogeneousDebugging.html#amdgpu-dwarf-lookup-by-name"><span class="std std-ref">Lookup By Name</span></a>.</p>
<p>For AMDGPU the lookup by name section header table:</p>
<p><code class="docutils literal notranslate"><span class="pre">augmentation_string_size</span></code> (uword)</p>
<blockquote>
<div><p>Set to the length of the <code class="docutils literal notranslate"><span class="pre">augmentation_string</span></code> value which is always a
multiple of 4.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">augmentation_string</span></code> (sequence of UTF-8 characters)</p>
<blockquote>
<div><p>Contains the following UTF-8 string null padded to a multiple of 4 bytes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">amdgpu</span><span class="p">:</span><span class="n">v0</span><span class="o">.</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>The “vX.Y” specifies the major X and minor Y version number of the AMDGPU
extensions used in the DWARF of this index. The version number conforms to
<a class="reference internal" href="#semver" id="id49"><span>[SEMVER]</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is different to the DWARF Version 5 definition that requires the first
4 characters to be the vendor ID. But this is consistent with the other
augmentation strings and does allow multiple vendor contributions. However,
backwards compatibility may be more desirable.</p>
</div>
</div></blockquote>
</div>
<div class="section" id="lookup-by-address-section-header">
<h4><a class="toc-backref" href="#id127">Lookup By Address Section Header</a><a class="headerlink" href="#lookup-by-address-section-header" title="Permalink to this headline">¶</a></h4>
<p>See DWARF Version 5 section 6.1.2.</p>
<p>For AMDGPU the lookup by address section header table:</p>
<p><code class="docutils literal notranslate"><span class="pre">address_size</span></code> (ubyte)</p>
<blockquote>
<div><p>Match the address size for the <code class="docutils literal notranslate"><span class="pre">Global</span></code> address space defined in
<a class="reference internal" href="#amdgpu-dwarf-address-space-identifier"><span class="std std-ref">Address Space Identifier</span></a>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">segment_selector_size</span></code> (ubyte)</p>
<blockquote>
<div><p>AMDGPU does not use a segment selector so this is 0. The entries in the
<code class="docutils literal notranslate"><span class="pre">.debug_aranges</span></code> do not have a segment selector.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="line-number-information">
<h3><a class="toc-backref" href="#id128">Line Number Information</a><a class="headerlink" href="#line-number-information" title="Permalink to this headline">¶</a></h3>
<p>See DWARF Version 5 section 6.2 and <a class="reference internal" href="AMDGPUDwarfExtensionsForHeterogeneousDebugging.html#amdgpu-dwarf-line-number-information"><span class="std std-ref">Line Number Information</span></a>.</p>
<p>AMDGPU does not use the <code class="docutils literal notranslate"><span class="pre">isa</span></code> state machine registers and always sets it to 0.
The instruction set must be obtained from the ELF file header <code class="docutils literal notranslate"><span class="pre">e_flags</span></code> field
in the <code class="docutils literal notranslate"><span class="pre">EF_AMDGPU_MACH</span></code> bit position (see <a class="reference internal" href="#amdgpu-elf-header"><span class="std std-ref">ELF Header</span></a>). See DWARF Version 5 section 6.2.2.</p>
<p>For AMDGPU the line number program header fields have the following values (see
DWARF Version 5 section 6.2.4):</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">address_size</span></code> (ubyte)</dt><dd><p>Matches the address size for the <code class="docutils literal notranslate"><span class="pre">Global</span></code> address space defined in
<a class="reference internal" href="#amdgpu-dwarf-address-space-identifier"><span class="std std-ref">Address Space Identifier</span></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">segment_selector_size</span></code> (ubyte)</dt><dd><p>AMDGPU does not use a segment selector so this is 0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">minimum_instruction_length</span></code> (ubyte)</dt><dd><p>For GFX9-GFX10 this is 4.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">maximum_operations_per_instruction</span></code> (ubyte)</dt><dd><p>For GFX9-GFX10 this is 1.</p>
</dd>
</dl>
<p>Source text for online-compiled programs (for example, those compiled by the
OpenCL language runtime) may be embedded into the DWARF Version 5 line table.
See DWARF Version 5 section 6.2.4.1 which is updated by <em>DWARF Extensions For
Heterogeneous Debugging</em> section <a class="reference internal" href="AMDGPUDwarfExtensionsForHeterogeneousDebugging.html#amdgpu-dwarf-line-number-information-dw-lnct-llvm-source"><span class="std std-ref">DW_LNCT_LLVM_source</span></a>.</p>
<p>The Clang option used to control source embedding in AMDGPU is defined in
<a class="reference internal" href="#amdgpu-clang-debug-options-table"><span class="std std-ref">AMDGPU Clang Debug Options</span></a>.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-clang-debug-options-table">
<caption><span class="caption-text">AMDGPU Clang Debug Options</span><a class="headerlink" href="#amdgpu-clang-debug-options-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Debug Flag</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>-g[no-]embed-source</p></td>
<td><p>Enable/disable embedding source text in DWARF
debug sections. Useful for environments where
source cannot be written to disk, such as
when performing online compilation.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>For example:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">-gembed-source</span></code></dt><dd><p>Enable the embedded source.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-gno-embed-source</span></code></dt><dd><p>Disable the embedded source.</p>
</dd>
</dl>
</div>
<div class="section" id="bit-and-64-bit-dwarf-formats">
<h3><a class="toc-backref" href="#id129">32-Bit and 64-Bit DWARF Formats</a><a class="headerlink" href="#bit-and-64-bit-dwarf-formats" title="Permalink to this headline">¶</a></h3>
<p>See DWARF Version 5 section 7.4 and
<a class="reference internal" href="AMDGPUDwarfExtensionsForHeterogeneousDebugging.html#amdgpu-dwarf-32-bit-and-64-bit-dwarf-formats"><span class="std std-ref">32-Bit and 64-Bit DWARF Formats</span></a>.</p>
<p>For AMDGPU:</p>
<ul class="simple">
<li><p>For the <code class="docutils literal notranslate"><span class="pre">amdgcn</span></code> target architecture only the 64-bit process address space
is supported.</p></li>
<li><p>The producer can generate either 32-bit or 64-bit DWARF format. LLVM generates
the 32-bit DWARF format.</p></li>
</ul>
</div>
<div class="section" id="unit-headers">
<h3><a class="toc-backref" href="#id130">Unit Headers</a><a class="headerlink" href="#unit-headers" title="Permalink to this headline">¶</a></h3>
<p>For AMDGPU the following values apply for each of the unit headers described in
DWARF Version 5 sections 7.5.1.1, 7.5.1.2, and 7.5.1.3:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">address_size</span></code> (ubyte)</dt><dd><p>Matches the address size for the <code class="docutils literal notranslate"><span class="pre">Global</span></code> address space defined in
<a class="reference internal" href="#amdgpu-dwarf-address-space-identifier"><span class="std std-ref">Address Space Identifier</span></a>.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="code-conventions">
<span id="amdgpu-code-conventions"></span><h2><a class="toc-backref" href="#id131">Code Conventions</a><a class="headerlink" href="#code-conventions" title="Permalink to this headline">¶</a></h2>
<p>This section provides code conventions used for each supported target triple OS
(see <a class="reference internal" href="#amdgpu-target-triples"><span class="std std-ref">Target Triples</span></a>).</p>
<div class="section" id="amdhsa">
<h3><a class="toc-backref" href="#id132">AMDHSA</a><a class="headerlink" href="#amdhsa" title="Permalink to this headline">¶</a></h3>
<p>This section provides code conventions used when the target triple OS is
<code class="docutils literal notranslate"><span class="pre">amdhsa</span></code> (see <a class="reference internal" href="#amdgpu-target-triples"><span class="std std-ref">Target Triples</span></a>).</p>
<div class="section" id="code-object-metadata">
<span id="amdgpu-amdhsa-code-object-metadata"></span><h4><a class="toc-backref" href="#id133">Code Object Metadata</a><a class="headerlink" href="#code-object-metadata" title="Permalink to this headline">¶</a></h4>
<p>The code object metadata specifies extensible metadata associated with the code
objects executed on HSA <a class="reference internal" href="#hsa" id="id51"><span>[HSA]</span></a> compatible runtimes (see <a class="reference internal" href="#amdgpu-os"><span class="std std-ref">AMDGPU Operating Systems</span></a>). The
encoding and semantics of this metadata depends on the code object version; see
<a class="reference internal" href="#amdgpu-amdhsa-code-object-metadata-v2"><span class="std std-ref">Code Object V2 Metadata</span></a>,
<a class="reference internal" href="#amdgpu-amdhsa-code-object-metadata-v3"><span class="std std-ref">Code Object V3 Metadata</span></a>, and
<a class="reference internal" href="#amdgpu-amdhsa-code-object-metadata-v4"><span class="std std-ref">Code Object V4 Metadata</span></a>.</p>
<p>Code object metadata is specified in a note record (see
<a class="reference internal" href="#amdgpu-note-records"><span class="std std-ref">Note Records</span></a>) and is required when the target triple OS is
<code class="docutils literal notranslate"><span class="pre">amdhsa</span></code> (see <a class="reference internal" href="#amdgpu-target-triples"><span class="std std-ref">Target Triples</span></a>). It must contain the minimum
information necessary to support the HSA compatible runtime kernel queries. For
example, the segment sizes needed in a dispatch packet. In addition, a
high-level language runtime may require other information to be included. For
example, the AMD OpenCL runtime records kernel argument information.</p>
<div class="section" id="code-object-v2-metadata">
<span id="amdgpu-amdhsa-code-object-metadata-v2"></span><h5><a class="toc-backref" href="#id134">Code Object V2 Metadata</a><a class="headerlink" href="#code-object-v2-metadata" title="Permalink to this headline">¶</a></h5>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Code object V2 is not the default code object version emitted by this version
of LLVM.</p>
</div>
<p>Code object V2 metadata is specified by the <code class="docutils literal notranslate"><span class="pre">NT_AMD_HSA_METADATA</span></code> note record
(see <a class="reference internal" href="#amdgpu-note-records-v2"><span class="std std-ref">Code Object V2 Note Records</span></a>).</p>
<p>The metadata is specified as a YAML formatted string (see <a class="reference internal" href="#yaml" id="id52"><span>[YAML]</span></a> and
<a class="reference internal" href="YamlIO.html"><span class="doc">YAML I/O</span></a>).</p>
<p>The metadata is represented as a single YAML document comprised of the mapping
defined in table <a class="reference internal" href="#amdgpu-amdhsa-code-object-metadata-map-v2-table"><span class="std std-ref">AMDHSA Code Object V2 Metadata Map</span></a> and
referenced tables.</p>
<p>For boolean values, the string values of <code class="docutils literal notranslate"><span class="pre">false</span></code> and <code class="docutils literal notranslate"><span class="pre">true</span></code> are used for
false and true respectively.</p>
<p>Additional information can be added to the mappings. To avoid conflicts, any
non-AMD key names should be prefixed by “<em>vendor-name</em>.”.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-code-object-metadata-map-v2-table">
<caption><span class="caption-text">AMDHSA Code Object V2 Metadata Map</span><a class="headerlink" href="#amdgpu-amdhsa-code-object-metadata-map-v2-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 11%" />
<col style="width: 15%" />
<col style="width: 10%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>String Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required?</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“Version”</p></td>
<td><p>sequence of
2 integers</p></td>
<td><p>Required</p></td>
<td><ul class="simple">
<li><p>The first integer is the major
version. Currently 1.</p></li>
<li><p>The second integer is the minor
version. Currently 0.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>“Printf”</p></td>
<td><p>sequence of
strings</p></td>
<td></td>
<td><p>Each string is encoded information
about a printf function call. The
encoded information is organized as
fields separated by colon (‘:’):</p>
<p><code class="docutils literal notranslate"><span class="pre">ID:N:S[0]:S[1]:...:S[N-1]:FormatString</span></code></p>
<p>where:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ID</span></code></dt><dd><p>A 32-bit integer as a unique id for
each printf function call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">N</span></code></dt><dd><p>A 32-bit integer equal to the number
of arguments of printf function call
minus 1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">S[i]</span></code> (where i = 0, 1, … , N-1)</dt><dd><p>32-bit integers for the size in bytes
of the i-th FormatString argument of
the printf function call</p>
</dd>
<dt>FormatString</dt><dd><p>The format string passed to the
printf function call.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>“Kernels”</p></td>
<td><p>sequence of
mapping</p></td>
<td><p>Required</p></td>
<td><p>Sequence of the mappings for each
kernel in the code object. See
<a class="reference internal" href="#amdgpu-amdhsa-code-object-kernel-metadata-map-v2-table"><span class="std std-ref">AMDHSA Code Object V2 Kernel Metadata Map</span></a>
for the definition of the mapping.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-code-object-kernel-metadata-map-v2-table">
<caption><span class="caption-text">AMDHSA Code Object V2 Kernel Metadata Map</span><a class="headerlink" href="#amdgpu-amdhsa-code-object-kernel-metadata-map-v2-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 12%" />
<col style="width: 8%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>String Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required?</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“Name”</p></td>
<td><p>string</p></td>
<td><p>Required</p></td>
<td><p>Source name of the kernel.</p></td>
</tr>
<tr class="row-odd"><td><p>“SymbolName”</p></td>
<td><p>string</p></td>
<td><p>Required</p></td>
<td><p>Name of the kernel
descriptor ELF symbol.</p></td>
</tr>
<tr class="row-even"><td><p>“Language”</p></td>
<td><p>string</p></td>
<td></td>
<td><p>Source language of the kernel.
Values include:</p>
<ul class="simple">
<li><p>“OpenCL C”</p></li>
<li><p>“OpenCL C++”</p></li>
<li><p>“HCC”</p></li>
<li><p>“OpenMP”</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>“LanguageVersion”</p></td>
<td><p>sequence of
2 integers</p></td>
<td></td>
<td><ul class="simple">
<li><p>The first integer is the major
version.</p></li>
<li><p>The second integer is the
minor version.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>“Attrs”</p></td>
<td><p>mapping</p></td>
<td></td>
<td><p>Mapping of kernel attributes.
See
<a class="reference internal" href="#amdgpu-amdhsa-code-object-kernel-attribute-metadata-map-v2-table"><span class="std std-ref">AMDHSA Code Object V2 Kernel Attribute Metadata Map</span></a>
for the mapping definition.</p></td>
</tr>
<tr class="row-odd"><td><p>“Args”</p></td>
<td><p>sequence of
mapping</p></td>
<td></td>
<td><p>Sequence of mappings of the
kernel arguments. See
<a class="reference internal" href="#amdgpu-amdhsa-code-object-kernel-argument-metadata-map-v2-table"><span class="std std-ref">AMDHSA Code Object V2 Kernel Argument Metadata Map</span></a>
for the definition of the mapping.</p></td>
</tr>
<tr class="row-even"><td><p>“CodeProps”</p></td>
<td><p>mapping</p></td>
<td></td>
<td><p>Mapping of properties related to
the kernel code. See
<a class="reference internal" href="#amdgpu-amdhsa-code-object-kernel-code-properties-metadata-map-v2-table"><span class="std std-ref">AMDHSA Code Object V2 Kernel Code Properties Metadata Map</span></a>
for the mapping definition.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-code-object-kernel-attribute-metadata-map-v2-table">
<caption><span class="caption-text">AMDHSA Code Object V2 Kernel Attribute Metadata Map</span><a class="headerlink" href="#amdgpu-amdhsa-code-object-kernel-attribute-metadata-map-v2-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 26%" />
<col style="width: 19%" />
<col style="width: 13%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>String Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required?</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“ReqdWorkGroupSize”</p></td>
<td><p>sequence of
3 integers</p></td>
<td></td>
<td><p>If not 0, 0, 0 then all values
must be &gt;=1 and the dispatch
work-group size X, Y, Z must
correspond to the specified
values. Defaults to 0, 0, 0.</p>
<p>Corresponds to the OpenCL
<code class="docutils literal notranslate"><span class="pre">reqd_work_group_size</span></code>
attribute.</p>
</td>
</tr>
<tr class="row-odd"><td><p>“WorkGroupSizeHint”</p></td>
<td><p>sequence of
3 integers</p></td>
<td></td>
<td><p>The dispatch work-group size
X, Y, Z is likely to be the
specified values.</p>
<p>Corresponds to the OpenCL
<code class="docutils literal notranslate"><span class="pre">work_group_size_hint</span></code>
attribute.</p>
</td>
</tr>
<tr class="row-even"><td><p>“VecTypeHint”</p></td>
<td><p>string</p></td>
<td></td>
<td><p>The name of a scalar or vector
type.</p>
<p>Corresponds to the OpenCL
<code class="docutils literal notranslate"><span class="pre">vec_type_hint</span></code> attribute.</p>
</td>
</tr>
<tr class="row-odd"><td><p>“RuntimeHandle”</p></td>
<td><p>string</p></td>
<td></td>
<td><p>The external symbol name
associated with a kernel.
OpenCL runtime allocates a
global buffer for the symbol
and saves the kernel’s address
to it, which is used for
device side enqueueing. Only
available for device side
enqueued kernels.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-code-object-kernel-argument-metadata-map-v2-table">
<caption><span class="caption-text">AMDHSA Code Object V2 Kernel Argument Metadata Map</span><a class="headerlink" href="#amdgpu-amdhsa-code-object-kernel-argument-metadata-map-v2-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 16%" />
<col style="width: 10%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>String Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required?</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“Name”</p></td>
<td><p>string</p></td>
<td></td>
<td><p>Kernel argument name.</p></td>
</tr>
<tr class="row-odd"><td><p>“TypeName”</p></td>
<td><p>string</p></td>
<td></td>
<td><p>Kernel argument type name.</p></td>
</tr>
<tr class="row-even"><td><p>“Size”</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>Kernel argument size in bytes.</p></td>
</tr>
<tr class="row-odd"><td><p>“Align”</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>Kernel argument alignment in
bytes. Must be a power of two.</p></td>
</tr>
<tr class="row-even"><td><p>“ValueKind”</p></td>
<td><p>string</p></td>
<td><p>Required</p></td>
<td><p>Kernel argument kind that
specifies how to set up the
corresponding argument.
Values include:</p>
<dl class="simple">
<dt>“ByValue”</dt><dd><p>The argument is copied
directly into the kernarg.</p>
</dd>
<dt>“GlobalBuffer”</dt><dd><p>A global address space pointer
to the buffer data is passed
in the kernarg.</p>
</dd>
<dt>“DynamicSharedPointer”</dt><dd><p>A group address space pointer
to dynamically allocated LDS
is passed in the kernarg.</p>
</dd>
<dt>“Sampler”</dt><dd><p>A global address space
pointer to a S# is passed in
the kernarg.</p>
</dd>
<dt>“Image”</dt><dd><p>A global address space
pointer to a T# is passed in
the kernarg.</p>
</dd>
<dt>“Pipe”</dt><dd><p>A global address space pointer
to an OpenCL pipe is passed in
the kernarg.</p>
</dd>
<dt>“Queue”</dt><dd><p>A global address space pointer
to an OpenCL device enqueue
queue is passed in the
kernarg.</p>
</dd>
<dt>“HiddenGlobalOffsetX”</dt><dd><p>The OpenCL grid dispatch
global offset for the X
dimension is passed in the
kernarg.</p>
</dd>
<dt>“HiddenGlobalOffsetY”</dt><dd><p>The OpenCL grid dispatch
global offset for the Y
dimension is passed in the
kernarg.</p>
</dd>
<dt>“HiddenGlobalOffsetZ”</dt><dd><p>The OpenCL grid dispatch
global offset for the Z
dimension is passed in the
kernarg.</p>
</dd>
<dt>“HiddenNone”</dt><dd><p>An argument that is not used
by the kernel. Space needs to
be left for it, but it does
not need to be set up.</p>
</dd>
<dt>“HiddenPrintfBuffer”</dt><dd><p>A global address space pointer
to the runtime printf buffer
is passed in kernarg.</p>
</dd>
<dt>“HiddenHostcallBuffer”</dt><dd><p>A global address space pointer
to the runtime hostcall buffer
is passed in kernarg.</p>
</dd>
<dt>“HiddenDefaultQueue”</dt><dd><p>A global address space pointer
to the OpenCL device enqueue
queue that should be used by
the kernel by default is
passed in the kernarg.</p>
</dd>
<dt>“HiddenCompletionAction”</dt><dd><p>A global address space pointer
to help link enqueued kernels into
the ancestor tree for determining
when the parent kernel has finished.</p>
</dd>
<dt>“HiddenMultiGridSyncArg”</dt><dd><p>A global address space pointer for
multi-grid synchronization is
passed in the kernarg.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>“ValueType”</p></td>
<td><p>string</p></td>
<td></td>
<td><p>Unused and deprecated. This should no longer
be emitted, but is accepted for compatibility.</p></td>
</tr>
<tr class="row-even"><td><p>“PointeeAlign”</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>Alignment in bytes of pointee
type for pointer type kernel
argument. Must be a power
of 2. Only present if
“ValueKind” is
“DynamicSharedPointer”.</p></td>
</tr>
<tr class="row-odd"><td><p>“AddrSpaceQual”</p></td>
<td><p>string</p></td>
<td></td>
<td><p>Kernel argument address space
qualifier. Only present if
“ValueKind” is “GlobalBuffer” or
“DynamicSharedPointer”. Values
are:</p>
<ul class="simple">
<li><p>“Private”</p></li>
<li><p>“Global”</p></li>
<li><p>“Constant”</p></li>
<li><p>“Local”</p></li>
<li><p>“Generic”</p></li>
<li><p>“Region”</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>“AccQual”</p></td>
<td><p>string</p></td>
<td></td>
<td><p>Kernel argument access
qualifier. Only present if
“ValueKind” is “Image” or
“Pipe”. Values
are:</p>
<ul class="simple">
<li><p>“ReadOnly”</p></li>
<li><p>“WriteOnly”</p></li>
<li><p>“ReadWrite”</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>“ActualAccQual”</p></td>
<td><p>string</p></td>
<td></td>
<td><p>The actual memory accesses
performed by the kernel on the
kernel argument. Only present if
“ValueKind” is “GlobalBuffer”,
“Image”, or “Pipe”. This may be
more restrictive than indicated
by “AccQual” to reflect what the
kernel actual does. If not
present then the runtime must
assume what is implied by
“AccQual” and “IsConst”. Values
are:</p>
<ul class="simple">
<li><p>“ReadOnly”</p></li>
<li><p>“WriteOnly”</p></li>
<li><p>“ReadWrite”</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>“IsConst”</p></td>
<td><p>boolean</p></td>
<td></td>
<td><p>Indicates if the kernel argument
is const qualified. Only present
if “ValueKind” is
“GlobalBuffer”.</p></td>
</tr>
<tr class="row-odd"><td><p>“IsRestrict”</p></td>
<td><p>boolean</p></td>
<td></td>
<td><p>Indicates if the kernel argument
is restrict qualified. Only
present if “ValueKind” is
“GlobalBuffer”.</p></td>
</tr>
<tr class="row-even"><td><p>“IsVolatile”</p></td>
<td><p>boolean</p></td>
<td></td>
<td><p>Indicates if the kernel argument
is volatile qualified. Only
present if “ValueKind” is
“GlobalBuffer”.</p></td>
</tr>
<tr class="row-odd"><td><p>“IsPipe”</p></td>
<td><p>boolean</p></td>
<td></td>
<td><p>Indicates if the kernel argument
is pipe qualified. Only present
if “ValueKind” is “Pipe”.</p>
</td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-code-object-kernel-code-properties-metadata-map-v2-table">
<caption><span class="caption-text">AMDHSA Code Object V2 Kernel Code Properties Metadata Map</span><a class="headerlink" href="#amdgpu-amdhsa-code-object-kernel-code-properties-metadata-map-v2-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 39%" />
<col style="width: 19%" />
<col style="width: 13%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>String Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required?</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“KernargSegmentSize”</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>The size in bytes of
the kernarg segment
that holds the values
of the arguments to
the kernel.</p></td>
</tr>
<tr class="row-odd"><td><p>“GroupSegmentFixedSize”</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>The amount of group
segment memory
required by a
work-group in
bytes. This does not
include any
dynamically allocated
group segment memory
that may be added
when the kernel is
dispatched.</p></td>
</tr>
<tr class="row-even"><td><p>“PrivateSegmentFixedSize”</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>The amount of fixed
private address space
memory required for a
work-item in
bytes. If the kernel
uses a dynamic call
stack then additional
space must be added
to this value for the
call stack.</p></td>
</tr>
<tr class="row-odd"><td><p>“KernargSegmentAlign”</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>The maximum byte
alignment of
arguments in the
kernarg segment. Must
be a power of 2.</p></td>
</tr>
<tr class="row-even"><td><p>“WavefrontSize”</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>Wavefront size. Must
be a power of 2.</p></td>
</tr>
<tr class="row-odd"><td><p>“NumSGPRs”</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>Number of scalar
registers used by a
wavefront for
GFX6-GFX10. This
includes the special
SGPRs for VCC, Flat
Scratch (GFX7-GFX10)
and XNACK (for
GFX8-GFX10). It does
not include the 16
SGPR added if a trap
handler is
enabled. It is not
rounded up to the
allocation
granularity.</p></td>
</tr>
<tr class="row-even"><td><p>“NumVGPRs”</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>Number of vector
registers used by
each work-item for
GFX6-GFX10</p></td>
</tr>
<tr class="row-odd"><td><p>“MaxFlatWorkGroupSize”</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>Maximum flat
work-group size
supported by the
kernel in work-items.
Must be &gt;=1 and
consistent with
ReqdWorkGroupSize if
not 0, 0, 0.</p></td>
</tr>
<tr class="row-even"><td><p>“NumSpilledSGPRs”</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>Number of stores from
a scalar register to
a register allocator
created spill
location.</p></td>
</tr>
<tr class="row-odd"><td><p>“NumSpilledVGPRs”</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>Number of stores from
a vector register to
a register allocator
created spill
location.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="code-object-v3-metadata">
<span id="amdgpu-amdhsa-code-object-metadata-v3"></span><h5><a class="toc-backref" href="#id135">Code Object V3 Metadata</a><a class="headerlink" href="#code-object-v3-metadata" title="Permalink to this headline">¶</a></h5>
<p>Code object V3 to V4 metadata is specified by the <code class="docutils literal notranslate"><span class="pre">NT_AMDGPU_METADATA</span></code> note
record (see <a class="reference internal" href="#amdgpu-note-records-v3-v4"><span class="std std-ref">Code Object V3 to V4 Note Records</span></a>).</p>
<p>The metadata is represented as Message Pack formatted binary data (see
<a class="reference internal" href="#msgpack" id="id57"><span>[MsgPack]</span></a>). The top level is a Message Pack map that includes the
keys defined in table
<a class="reference internal" href="#amdgpu-amdhsa-code-object-metadata-map-table-v3"><span class="std std-ref">AMDHSA Code Object V3 Metadata Map</span></a> and referenced
tables.</p>
<p>Additional information can be added to the maps. To avoid conflicts,
any key names should be prefixed by “<em>vendor-name</em>.” where
<code class="docutils literal notranslate"><span class="pre">vendor-name</span></code> can be the name of the vendor and specific vendor
tool that generates the information. The prefix is abbreviated to
simply “.” when it appears within a map that has been added by the
same <em>vendor-name</em>.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-code-object-metadata-map-table-v3">
<caption><span class="caption-text">AMDHSA Code Object V3 Metadata Map</span><a class="headerlink" href="#amdgpu-amdhsa-code-object-metadata-map-table-v3" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 17%" />
<col style="width: 14%" />
<col style="width: 9%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>String Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required?</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“amdhsa.version”</p></td>
<td><p>sequence of
2 integers</p></td>
<td><p>Required</p></td>
<td><ul class="simple">
<li><p>The first integer is the major
version. Currently 1.</p></li>
<li><p>The second integer is the minor
version. Currently 0.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>“amdhsa.printf”</p></td>
<td><p>sequence of
strings</p></td>
<td></td>
<td><p>Each string is encoded information
about a printf function call. The
encoded information is organized as
fields separated by colon (‘:’):</p>
<p><code class="docutils literal notranslate"><span class="pre">ID:N:S[0]:S[1]:...:S[N-1]:FormatString</span></code></p>
<p>where:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ID</span></code></dt><dd><p>A 32-bit integer as a unique id for
each printf function call</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">N</span></code></dt><dd><p>A 32-bit integer equal to the number
of arguments of printf function call
minus 1</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">S[i]</span></code> (where i = 0, 1, … , N-1)</dt><dd><p>32-bit integers for the size in bytes
of the i-th FormatString argument of
the printf function call</p>
</dd>
<dt>FormatString</dt><dd><p>The format string passed to the
printf function call.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>“amdhsa.kernels”</p></td>
<td><p>sequence of
map</p></td>
<td><p>Required</p></td>
<td><p>Sequence of the maps for each
kernel in the code object. See
<a class="reference internal" href="#amdgpu-amdhsa-code-object-kernel-metadata-map-table-v3"><span class="std std-ref">AMDHSA Code Object V3 Kernel Metadata Map</span></a>
for the definition of the keys included
in that map.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-code-object-kernel-metadata-map-table-v3">
<caption><span class="caption-text">AMDHSA Code Object V3 Kernel Metadata Map</span><a class="headerlink" href="#amdgpu-amdhsa-code-object-kernel-metadata-map-table-v3" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 27%" />
<col style="width: 11%" />
<col style="width: 7%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>String Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required?</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“.name”</p></td>
<td><p>string</p></td>
<td><p>Required</p></td>
<td><p>Source name of the kernel.</p></td>
</tr>
<tr class="row-odd"><td><p>“.symbol”</p></td>
<td><p>string</p></td>
<td><p>Required</p></td>
<td><p>Name of the kernel
descriptor ELF symbol.</p></td>
</tr>
<tr class="row-even"><td><p>“.language”</p></td>
<td><p>string</p></td>
<td></td>
<td><p>Source language of the kernel.
Values include:</p>
<ul class="simple">
<li><p>“OpenCL C”</p></li>
<li><p>“OpenCL C++”</p></li>
<li><p>“HCC”</p></li>
<li><p>“HIP”</p></li>
<li><p>“OpenMP”</p></li>
<li><p>“Assembler”</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>“.language_version”</p></td>
<td><p>sequence of
2 integers</p></td>
<td></td>
<td><ul class="simple">
<li><p>The first integer is the major
version.</p></li>
<li><p>The second integer is the
minor version.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>“.args”</p></td>
<td><p>sequence of
map</p></td>
<td></td>
<td><p>Sequence of maps of the
kernel arguments. See
<a class="reference internal" href="#amdgpu-amdhsa-code-object-kernel-argument-metadata-map-table-v3"><span class="std std-ref">AMDHSA Code Object V3 Kernel Argument Metadata Map</span></a>
for the definition of the keys
included in that map.</p></td>
</tr>
<tr class="row-odd"><td><p>“.reqd_workgroup_size”</p></td>
<td><p>sequence of
3 integers</p></td>
<td></td>
<td><p>If not 0, 0, 0 then all values
must be &gt;=1 and the dispatch
work-group size X, Y, Z must
correspond to the specified
values. Defaults to 0, 0, 0.</p>
<p>Corresponds to the OpenCL
<code class="docutils literal notranslate"><span class="pre">reqd_work_group_size</span></code>
attribute.</p>
</td>
</tr>
<tr class="row-even"><td><p>“.workgroup_size_hint”</p></td>
<td><p>sequence of
3 integers</p></td>
<td></td>
<td><p>The dispatch work-group size
X, Y, Z is likely to be the
specified values.</p>
<p>Corresponds to the OpenCL
<code class="docutils literal notranslate"><span class="pre">work_group_size_hint</span></code>
attribute.</p>
</td>
</tr>
<tr class="row-odd"><td><p>“.vec_type_hint”</p></td>
<td><p>string</p></td>
<td></td>
<td><p>The name of a scalar or vector
type.</p>
<p>Corresponds to the OpenCL
<code class="docutils literal notranslate"><span class="pre">vec_type_hint</span></code> attribute.</p>
</td>
</tr>
<tr class="row-even"><td><p>“.device_enqueue_symbol”</p></td>
<td><p>string</p></td>
<td></td>
<td><p>The external symbol name
associated with a kernel.
OpenCL runtime allocates a
global buffer for the symbol
and saves the kernel’s address
to it, which is used for
device side enqueueing. Only
available for device side
enqueued kernels.</p></td>
</tr>
<tr class="row-odd"><td><p>“.kernarg_segment_size”</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>The size in bytes of
the kernarg segment
that holds the values
of the arguments to
the kernel.</p></td>
</tr>
<tr class="row-even"><td><p>“.group_segment_fixed_size”</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>The amount of group
segment memory
required by a
work-group in
bytes. This does not
include any
dynamically allocated
group segment memory
that may be added
when the kernel is
dispatched.</p></td>
</tr>
<tr class="row-odd"><td><p>“.private_segment_fixed_size”</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>The amount of fixed
private address space
memory required for a
work-item in
bytes. If the kernel
uses a dynamic call
stack then additional
space must be added
to this value for the
call stack.</p></td>
</tr>
<tr class="row-even"><td><p>“.kernarg_segment_align”</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>The maximum byte
alignment of
arguments in the
kernarg segment. Must
be a power of 2.</p></td>
</tr>
<tr class="row-odd"><td><p>“.wavefront_size”</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>Wavefront size. Must
be a power of 2.</p></td>
</tr>
<tr class="row-even"><td><p>“.sgpr_count”</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>Number of scalar
registers required by a
wavefront for
GFX6-GFX9. A register
is required if it is
used explicitly, or
if a higher numbered
register is used
explicitly. This
includes the special
SGPRs for VCC, Flat
Scratch (GFX7-GFX9)
and XNACK (for
GFX8-GFX9). It does
not include the 16
SGPR added if a trap
handler is
enabled. It is not
rounded up to the
allocation
granularity.</p></td>
</tr>
<tr class="row-odd"><td><p>“.vgpr_count”</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>Number of vector
registers required by
each work-item for
GFX6-GFX9. A register
is required if it is
used explicitly, or
if a higher numbered
register is used
explicitly.</p></td>
</tr>
<tr class="row-even"><td><p>“.max_flat_workgroup_size”</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>Maximum flat
work-group size
supported by the
kernel in work-items.
Must be &gt;=1 and
consistent with
ReqdWorkGroupSize if
not 0, 0, 0.</p></td>
</tr>
<tr class="row-odd"><td><p>“.sgpr_spill_count”</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>Number of stores from
a scalar register to
a register allocator
created spill
location.</p></td>
</tr>
<tr class="row-even"><td><p>“.vgpr_spill_count”</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>Number of stores from
a vector register to
a register allocator
created spill
location.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-code-object-kernel-argument-metadata-map-table-v3">
<caption><span class="caption-text">AMDHSA Code Object V3 Kernel Argument Metadata Map</span><a class="headerlink" href="#amdgpu-amdhsa-code-object-kernel-argument-metadata-map-table-v3" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 24%" />
<col style="width: 15%" />
<col style="width: 10%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>String Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required?</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“.name”</p></td>
<td><p>string</p></td>
<td></td>
<td><p>Kernel argument name.</p></td>
</tr>
<tr class="row-odd"><td><p>“.type_name”</p></td>
<td><p>string</p></td>
<td></td>
<td><p>Kernel argument type name.</p></td>
</tr>
<tr class="row-even"><td><p>“.size”</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>Kernel argument size in bytes.</p></td>
</tr>
<tr class="row-odd"><td><p>“.offset”</p></td>
<td><p>integer</p></td>
<td><p>Required</p></td>
<td><p>Kernel argument offset in
bytes. The offset must be a
multiple of the alignment
required by the argument.</p></td>
</tr>
<tr class="row-even"><td><p>“.value_kind”</p></td>
<td><p>string</p></td>
<td><p>Required</p></td>
<td><p>Kernel argument kind that
specifies how to set up the
corresponding argument.
Values include:</p>
<dl class="simple">
<dt>“by_value”</dt><dd><p>The argument is copied
directly into the kernarg.</p>
</dd>
<dt>“global_buffer”</dt><dd><p>A global address space pointer
to the buffer data is passed
in the kernarg.</p>
</dd>
<dt>“dynamic_shared_pointer”</dt><dd><p>A group address space pointer
to dynamically allocated LDS
is passed in the kernarg.</p>
</dd>
<dt>“sampler”</dt><dd><p>A global address space
pointer to a S# is passed in
the kernarg.</p>
</dd>
<dt>“image”</dt><dd><p>A global address space
pointer to a T# is passed in
the kernarg.</p>
</dd>
<dt>“pipe”</dt><dd><p>A global address space pointer
to an OpenCL pipe is passed in
the kernarg.</p>
</dd>
<dt>“queue”</dt><dd><p>A global address space pointer
to an OpenCL device enqueue
queue is passed in the
kernarg.</p>
</dd>
<dt>“hidden_global_offset_x”</dt><dd><p>The OpenCL grid dispatch
global offset for the X
dimension is passed in the
kernarg.</p>
</dd>
<dt>“hidden_global_offset_y”</dt><dd><p>The OpenCL grid dispatch
global offset for the Y
dimension is passed in the
kernarg.</p>
</dd>
<dt>“hidden_global_offset_z”</dt><dd><p>The OpenCL grid dispatch
global offset for the Z
dimension is passed in the
kernarg.</p>
</dd>
<dt>“hidden_none”</dt><dd><p>An argument that is not used
by the kernel. Space needs to
be left for it, but it does
not need to be set up.</p>
</dd>
<dt>“hidden_printf_buffer”</dt><dd><p>A global address space pointer
to the runtime printf buffer
is passed in kernarg.</p>
</dd>
<dt>“hidden_hostcall_buffer”</dt><dd><p>A global address space pointer
to the runtime hostcall buffer
is passed in kernarg.</p>
</dd>
<dt>“hidden_default_queue”</dt><dd><p>A global address space pointer
to the OpenCL device enqueue
queue that should be used by
the kernel by default is
passed in the kernarg.</p>
</dd>
<dt>“hidden_completion_action”</dt><dd><p>A global address space pointer
to help link enqueued kernels into
the ancestor tree for determining
when the parent kernel has finished.</p>
</dd>
<dt>“hidden_multigrid_sync_arg”</dt><dd><p>A global address space pointer for
multi-grid synchronization is
passed in the kernarg.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>“.value_type”</p></td>
<td><p>string</p></td>
<td></td>
<td><p>Unused and deprecated. This should no longer
be emitted, but is accepted for compatibility.</p></td>
</tr>
<tr class="row-even"><td><p>“.pointee_align”</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>Alignment in bytes of pointee
type for pointer type kernel
argument. Must be a power
of 2. Only present if
“.value_kind” is
“dynamic_shared_pointer”.</p></td>
</tr>
<tr class="row-odd"><td><p>“.address_space”</p></td>
<td><p>string</p></td>
<td></td>
<td><p>Kernel argument address space
qualifier. Only present if
“.value_kind” is “global_buffer” or
“dynamic_shared_pointer”. Values
are:</p>
<ul class="simple">
<li><p>“private”</p></li>
<li><p>“global”</p></li>
<li><p>“constant”</p></li>
<li><p>“local”</p></li>
<li><p>“generic”</p></li>
<li><p>“region”</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>“.access”</p></td>
<td><p>string</p></td>
<td></td>
<td><p>Kernel argument access
qualifier. Only present if
“.value_kind” is “image” or
“pipe”. Values
are:</p>
<ul class="simple">
<li><p>“read_only”</p></li>
<li><p>“write_only”</p></li>
<li><p>“read_write”</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>“.actual_access”</p></td>
<td><p>string</p></td>
<td></td>
<td><p>The actual memory accesses
performed by the kernel on the
kernel argument. Only present if
“.value_kind” is “global_buffer”,
“image”, or “pipe”. This may be
more restrictive than indicated
by “.access” to reflect what the
kernel actual does. If not
present then the runtime must
assume what is implied by
“.access” and “.is_const”      . Values
are:</p>
<ul class="simple">
<li><p>“read_only”</p></li>
<li><p>“write_only”</p></li>
<li><p>“read_write”</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>“.is_const”</p></td>
<td><p>boolean</p></td>
<td></td>
<td><p>Indicates if the kernel argument
is const qualified. Only present
if “.value_kind” is
“global_buffer”.</p></td>
</tr>
<tr class="row-odd"><td><p>“.is_restrict”</p></td>
<td><p>boolean</p></td>
<td></td>
<td><p>Indicates if the kernel argument
is restrict qualified. Only
present if “.value_kind” is
“global_buffer”.</p></td>
</tr>
<tr class="row-even"><td><p>“.is_volatile”</p></td>
<td><p>boolean</p></td>
<td></td>
<td><p>Indicates if the kernel argument
is volatile qualified. Only
present if “.value_kind” is
“global_buffer”.</p></td>
</tr>
<tr class="row-odd"><td><p>“.is_pipe”</p></td>
<td><p>boolean</p></td>
<td></td>
<td><p>Indicates if the kernel argument
is pipe qualified. Only present
if “.value_kind” is “pipe”.</p>
</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="code-object-v4-metadata">
<span id="amdgpu-amdhsa-code-object-metadata-v4"></span><h5><a class="toc-backref" href="#id136">Code Object V4 Metadata</a><a class="headerlink" href="#code-object-v4-metadata" title="Permalink to this headline">¶</a></h5>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Code object V4 is not the default code object version emitted by this version
of LLVM.</p>
</div>
<p>Code object V4 metadata is the same as
<a class="reference internal" href="#amdgpu-amdhsa-code-object-metadata-v3"><span class="std std-ref">Code Object V3 Metadata</span></a> with the changes and additions
defined in table <a class="reference internal" href="#amdgpu-amdhsa-code-object-metadata-map-table-v3"><span class="std std-ref">AMDHSA Code Object V3 Metadata Map</span></a>.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-code-object-metadata-map-table-v4">
<caption><span class="caption-text">AMDHSA Code Object V4 Metadata Map Changes from <a class="reference internal" href="#amdgpu-amdhsa-code-object-metadata-v3"><span class="std std-ref">Code Object V3 Metadata</span></a></span><a class="headerlink" href="#amdgpu-amdhsa-code-object-metadata-map-table-v4" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 16%" />
<col style="width: 11%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>String Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required?</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“amdhsa.version”</p></td>
<td><p>sequence of
2 integers</p></td>
<td><p>Required</p></td>
<td><ul class="simple">
<li><p>The first integer is the major
version. Currently 1.</p></li>
<li><p>The second integer is the minor
version. Currently 1.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>“amdhsa.target”</p></td>
<td><p>string</p></td>
<td><p>Required</p></td>
<td><p>The target name of the code using the syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">target</span><span class="o">-</span><span class="n">triple</span><span class="o">&gt;</span> <span class="p">[</span> <span class="s2">&quot;-&quot;</span> <span class="o">&lt;</span><span class="n">target</span><span class="o">-</span><span class="nb">id</span><span class="o">&gt;</span> <span class="p">]</span>
</pre></div>
</div>
<p>A canonical target ID must be
used. See <a class="reference internal" href="#amdgpu-target-triples"><span class="std std-ref">Target Triples</span></a>
and <a class="reference internal" href="#amdgpu-target-id"><span class="std std-ref">Target ID</span></a>.</p>
</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
</div>
<div class="section" id="kernel-dispatch">
<h4><a class="toc-backref" href="#id137">Kernel Dispatch</a><a class="headerlink" href="#kernel-dispatch" title="Permalink to this headline">¶</a></h4>
<p>The HSA architected queuing language (AQL) defines a user space memory interface
that can be used to control the dispatch of kernels, in an agent independent
way. An agent can have zero or more AQL queues created for it using an HSA
compatible runtime (see <a class="reference internal" href="#amdgpu-os"><span class="std std-ref">AMDGPU Operating Systems</span></a>), in which AQL packets (all of which
are 64 bytes) can be placed. See the <em>HSA Platform System Architecture
Specification</em> <a class="reference internal" href="#hsa" id="id61"><span>[HSA]</span></a> for the AQL queue mechanics and packet layouts.</p>
<p>The packet processor of a kernel agent is responsible for detecting and
dispatching HSA kernels from the AQL queues associated with it. For AMD GPUs the
packet processor is implemented by the hardware command processor (CP),
asynchronous dispatch controller (ADC) and shader processor input controller
(SPI).</p>
<p>An HSA compatible runtime can be used to allocate an AQL queue object. It uses
the kernel mode driver to initialize and register the AQL queue with CP.</p>
<p>To dispatch a kernel the following actions are performed. This can occur in the
CPU host program, or from an HSA kernel executing on a GPU.</p>
<ol class="arabic simple">
<li><p>A pointer to an AQL queue for the kernel agent on which the kernel is to be
executed is obtained.</p></li>
<li><p>A pointer to the kernel descriptor (see
<a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor"><span class="std std-ref">Kernel Descriptor</span></a>) of the kernel to execute is obtained.
It must be for a kernel that is contained in a code object that that was
loaded by an HSA compatible runtime on the kernel agent with which the AQL
queue is associated.</p></li>
<li><p>Space is allocated for the kernel arguments using the HSA compatible runtime
allocator for a memory region with the kernarg property for the kernel agent
that will execute the kernel. It must be at least 16-byte aligned.</p></li>
<li><p>Kernel argument values are assigned to the kernel argument memory
allocation. The layout is defined in the <em>HSA Programmer’s Language
Reference</em> <a class="reference internal" href="#hsa" id="id62"><span>[HSA]</span></a>. For AMDGPU the kernel execution directly accesses the
kernel argument memory in the same way constant memory is accessed. (Note
that the HSA specification allows an implementation to copy the kernel
argument contents to another location that is accessed by the kernel.)</p></li>
<li><p>An AQL kernel dispatch packet is created on the AQL queue. The HSA compatible
runtime api uses 64-bit atomic operations to reserve space in the AQL queue
for the packet. The packet must be set up, and the final write must use an
atomic store release to set the packet kind to ensure the packet contents are
visible to the kernel agent. AQL defines a doorbell signal mechanism to
notify the kernel agent that the AQL queue has been updated. These rules, and
the layout of the AQL queue and kernel dispatch packet is defined in the <em>HSA
System Architecture Specification</em> <a class="reference internal" href="#hsa" id="id63"><span>[HSA]</span></a>.</p></li>
<li><p>A kernel dispatch packet includes information about the actual dispatch,
such as grid and work-group size, together with information from the code
object about the kernel, such as segment sizes. The HSA compatible runtime
queries on the kernel symbol can be used to obtain the code object values
which are recorded in the <a class="reference internal" href="#amdgpu-amdhsa-code-object-metadata"><span class="std std-ref">Code Object Metadata</span></a>.</p></li>
<li><p>CP executes micro-code and is responsible for detecting and setting up the
GPU to execute the wavefronts of a kernel dispatch.</p></li>
<li><p>CP ensures that when the a wavefront starts executing the kernel machine
code, the scalar general purpose registers (SGPR) and vector general purpose
registers (VGPR) are set up as required by the machine code. The required
setup is defined in the <a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor"><span class="std std-ref">Kernel Descriptor</span></a>. The initial
register state is defined in
<a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>.</p></li>
<li><p>The prolog of the kernel machine code (see
<a class="reference internal" href="#amdgpu-amdhsa-kernel-prolog"><span class="std std-ref">Kernel Prolog</span></a>) sets up the machine state as necessary
before continuing executing the machine code that corresponds to the kernel.</p></li>
<li><p>When the kernel dispatch has completed execution, CP signals the completion
signal specified in the kernel dispatch packet if not 0.</p></li>
</ol>
</div>
<div class="section" id="memory-spaces">
<span id="amdgpu-amdhsa-memory-spaces"></span><h4><a class="toc-backref" href="#id138">Memory Spaces</a><a class="headerlink" href="#memory-spaces" title="Permalink to this headline">¶</a></h4>
<p>The memory space properties are:</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-memory-spaces-table">
<caption><span class="caption-text">AMDHSA Memory Spaces</span><a class="headerlink" href="#amdgpu-amdhsa-memory-spaces-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 28%" />
<col style="width: 18%" />
<col style="width: 13%" />
<col style="width: 11%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Memory Space Name</p></th>
<th class="head"><p>HSA Segment
Name</p></th>
<th class="head"><p>Hardware
Name</p></th>
<th class="head"><p>Address
Size</p></th>
<th class="head"><p>NULL Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Private</p></td>
<td><p>private</p></td>
<td><p>scratch</p></td>
<td><p>32</p></td>
<td><p>0x00000000</p></td>
</tr>
<tr class="row-odd"><td><p>Local</p></td>
<td><p>group</p></td>
<td><p>LDS</p></td>
<td><p>32</p></td>
<td><p>0xFFFFFFFF</p></td>
</tr>
<tr class="row-even"><td><p>Global</p></td>
<td><p>global</p></td>
<td><p>global</p></td>
<td><p>64</p></td>
<td><p>0x0000000000000000</p></td>
</tr>
<tr class="row-odd"><td><p>Constant</p></td>
<td><p>constant</p></td>
<td><p><em>same as
global</em></p></td>
<td><p>64</p></td>
<td><p>0x0000000000000000</p></td>
</tr>
<tr class="row-even"><td><p>Generic</p></td>
<td><p>flat</p></td>
<td><p>flat</p></td>
<td><p>64</p></td>
<td><p>0x0000000000000000</p></td>
</tr>
<tr class="row-odd"><td><p>Region</p></td>
<td><p>N/A</p></td>
<td><p>GDS</p></td>
<td><p>32</p></td>
<td><p><em>not implemented
for AMDHSA</em></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The global and constant memory spaces both use global virtual addresses, which
are the same virtual address space used by the CPU. However, some virtual
addresses may only be accessible to the CPU, some only accessible by the GPU,
and some by both.</p>
<p>Using the constant memory space indicates that the data will not change during
the execution of the kernel. This allows scalar read instructions to be
used. The vector and scalar L1 caches are invalidated of volatile data before
each kernel dispatch execution to allow constant memory to change values between
kernel dispatches.</p>
<p>The local memory space uses the hardware Local Data Store (LDS) which is
automatically allocated when the hardware creates work-groups of wavefronts, and
freed when all the wavefronts of a work-group have terminated. The data store
(DS) instructions can be used to access it.</p>
<p>The private memory space uses the hardware scratch memory support. If the kernel
uses scratch, then the hardware allocates memory that is accessed using
wavefront lane dword (4 byte) interleaving. The mapping used from private
address to physical address is:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">wavefront-scratch-base</span> <span class="pre">+</span>
<span class="pre">(private-address</span> <span class="pre">*</span> <span class="pre">wavefront-size</span> <span class="pre">*</span> <span class="pre">4)</span> <span class="pre">+</span>
<span class="pre">(wavefront-lane-id</span> <span class="pre">*</span> <span class="pre">4)</span></code></p>
</div></blockquote>
<p>There are different ways that the wavefront scratch base address is determined
by a wavefront (see <a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>). This
memory can be accessed in an interleaved manner using buffer instruction with
the scratch buffer descriptor and per wavefront scratch offset, by the scratch
instructions, or by flat instructions. If each lane of a wavefront accesses the
same private address, the interleaving results in adjacent dwords being accessed
and hence requires fewer cache lines to be fetched. Multi-dword access is not
supported except by flat and scratch instructions in GFX9-GFX10.</p>
<p>The generic address space uses the hardware flat address support available in
GFX7-GFX10. This uses two fixed ranges of virtual addresses (the private and
local apertures), that are outside the range of addressible global memory, to
map from a flat address to a private or local address.</p>
<p>FLAT instructions can take a flat address and access global, private (scratch)
and group (LDS) memory depending in if the address is within one of the
aperture ranges. Flat access to scratch requires hardware aperture setup and
setup in the kernel prologue (see
<a class="reference internal" href="#amdgpu-amdhsa-kernel-prolog-flat-scratch"><span class="std std-ref">Flat Scratch</span></a>). Flat access to LDS requires
hardware aperture setup and M0 (GFX7-GFX8) register setup (see
<a class="reference internal" href="#amdgpu-amdhsa-kernel-prolog-m0"><span class="std std-ref">M0</span></a>).</p>
<p>To convert between a segment address and a flat address the base address of the
apertures address can be used. For GFX7-GFX8 these are available in the
<a class="reference internal" href="#amdgpu-amdhsa-hsa-aql-queue"><span class="std std-ref">HSA AQL Queue</span></a> the address of which can be obtained with
Queue Ptr SGPR (see <a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>). For
GFX9-GFX10 the aperture base addresses are directly available as inline constant
registers <code class="docutils literal notranslate"><span class="pre">SRC_SHARED_BASE/LIMIT</span></code> and <code class="docutils literal notranslate"><span class="pre">SRC_PRIVATE_BASE/LIMIT</span></code>. In 64 bit
address mode the aperture sizes are 2^32 bytes and the base is aligned to 2^32
which makes it easier to convert from flat to segment or segment to flat.</p>
</div>
<div class="section" id="image-and-samplers">
<h4><a class="toc-backref" href="#id139">Image and Samplers</a><a class="headerlink" href="#image-and-samplers" title="Permalink to this headline">¶</a></h4>
<p>Image and sample handles created by an HSA compatible runtime (see
<a class="reference internal" href="#amdgpu-os"><span class="std std-ref">AMDGPU Operating Systems</span></a>) are 64-bit addresses of a hardware 32-byte V# and 48 byte S#
object respectively. In order to support the HSA <code class="docutils literal notranslate"><span class="pre">query_sampler</span></code> operations
two extra dwords are used to store the HSA BRIG enumeration values for the
queries that are not trivially deducible from the S# representation.</p>
</div>
<div class="section" id="hsa-signals">
<h4><a class="toc-backref" href="#id140">HSA Signals</a><a class="headerlink" href="#hsa-signals" title="Permalink to this headline">¶</a></h4>
<p>HSA signal handles created by an HSA compatible runtime (see <a class="reference internal" href="#amdgpu-os"><span class="std std-ref">AMDGPU Operating Systems</span></a>)
are 64-bit addresses of a structure allocated in memory accessible from both the
CPU and GPU. The structure is defined by the runtime and subject to change
between releases. For example, see <a class="reference internal" href="#amd-rocm-github" id="id64"><span>[AMD-ROCm-github]</span></a>.</p>
</div>
<div class="section" id="hsa-aql-queue">
<span id="amdgpu-amdhsa-hsa-aql-queue"></span><h4><a class="toc-backref" href="#id141">HSA AQL Queue</a><a class="headerlink" href="#hsa-aql-queue" title="Permalink to this headline">¶</a></h4>
<p>The HSA AQL queue structure is defined by an HSA compatible runtime (see
<a class="reference internal" href="#amdgpu-os"><span class="std std-ref">AMDGPU Operating Systems</span></a>) and subject to change between releases. For example, see
<a class="reference internal" href="#amd-rocm-github" id="id65"><span>[AMD-ROCm-github]</span></a>. For some processors it contains fields needed to implement
certain language features such as the flat address aperture bases. It also
contains fields used by CP such as managing the allocation of scratch memory.</p>
</div>
<div class="section" id="kernel-descriptor">
<span id="amdgpu-amdhsa-kernel-descriptor"></span><h4><a class="toc-backref" href="#id142">Kernel Descriptor</a><a class="headerlink" href="#kernel-descriptor" title="Permalink to this headline">¶</a></h4>
<p>A kernel descriptor consists of the information needed by CP to initiate the
execution of a kernel, including the entry point address of the machine code
that implements the kernel.</p>
<div class="section" id="code-object-v3-kernel-descriptor">
<h5><a class="toc-backref" href="#id143">Code Object V3 Kernel Descriptor</a><a class="headerlink" href="#code-object-v3-kernel-descriptor" title="Permalink to this headline">¶</a></h5>
<p>CP microcode requires the Kernel descriptor to be allocated on 64-byte
alignment.</p>
<p>The fields used by CP for code objects before V3 also match those specified in
<a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor-v3-table"><span class="std std-ref">Code Object V3 Kernel Descriptor</span></a>.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-kernel-descriptor-v3-table">
<caption><span class="caption-text">Code Object V3 Kernel Descriptor</span><a class="headerlink" href="#amdgpu-amdhsa-kernel-descriptor-v3-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 31%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bits</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Field Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>31:0</p></td>
<td><p>4 bytes</p></td>
<td><p>GROUP_SEGMENT_FIXED_SIZE</p></td>
<td><p>The amount of fixed local
address space memory
required for a work-group
in bytes. This does not
include any dynamically
allocated local address
space memory that may be
added when the kernel is
dispatched.</p></td>
</tr>
<tr class="row-odd"><td><p>63:32</p></td>
<td><p>4 bytes</p></td>
<td><p>PRIVATE_SEGMENT_FIXED_SIZE</p></td>
<td><p>The amount of fixed
private address space
memory required for a
work-item in bytes.
Additional space may need to
be added to this value if
the call stack has
non-inlined function calls.</p></td>
</tr>
<tr class="row-even"><td><p>95:64</p></td>
<td><p>4 bytes</p></td>
<td><p>KERNARG_SIZE</p></td>
<td><p>The size of the kernarg
memory pointed to by the
AQL dispatch packet. The
kernarg memory is used to
pass arguments to the
kernel.</p>
<ul class="simple">
<li><p>If the kernarg pointer in
the dispatch packet is NULL
then there are no kernel
arguments.</p></li>
<li><p>If the kernarg pointer in
the dispatch packet is
not NULL and this value
is 0 then the kernarg
memory size is
unspecified.</p></li>
<li><p>If the kernarg pointer in
the dispatch packet is
not NULL and this value
is not 0 then the value
specifies the kernarg
memory size in bytes. It
is recommended to provide
a value as it may be used
by CP to optimize making
the kernarg memory
visible to the kernel
code.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>127:96</p></td>
<td><p>4 bytes</p></td>
<td></td>
<td><p>Reserved, must be 0.</p></td>
</tr>
<tr class="row-even"><td><p>191:128</p></td>
<td><p>8 bytes</p></td>
<td><p>KERNEL_CODE_ENTRY_BYTE_OFFSET</p></td>
<td><p>Byte offset (possibly
negative) from base
address of kernel
descriptor to kernel’s
entry point instruction
which must be 256 byte
aligned.</p></td>
</tr>
<tr class="row-odd"><td><p>351:272</p></td>
<td><p>20
bytes</p></td>
<td></td>
<td><p>Reserved, must be 0.</p></td>
</tr>
<tr class="row-even"><td><p>383:352</p></td>
<td><p>4 bytes</p></td>
<td><p>COMPUTE_PGM_RSRC3</p></td>
<td><dl class="simple">
<dt>GFX6-GFX9</dt><dd><p>Reserved, must be 0.</p>
</dd>
<dt>GFX90A</dt><dd><p>Compute Shader (CS)
program settings used by
CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC3</span></code>
configuration
register. See
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc3-gfx90a-table"><span class="std std-ref">compute_pgm_rsrc3 for GFX90A</span></a>.</p>
</dd>
<dt>GFX10</dt><dd><p>Compute Shader (CS)
program settings used by
CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC3</span></code>
configuration
register. See
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc3-gfx10-table"><span class="std std-ref">compute_pgm_rsrc3 for GFX10</span></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>415:384</p></td>
<td><p>4 bytes</p></td>
<td><p>COMPUTE_PGM_RSRC1</p></td>
<td><p>Compute Shader (CS)
program settings used by
CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1</span></code>
configuration
register. See
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc1-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc1 for GFX6-GFX10</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p>447:416</p></td>
<td><p>4 bytes</p></td>
<td><p>COMPUTE_PGM_RSRC2</p></td>
<td><p>Compute Shader (CS)
program settings used by
CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2</span></code>
configuration
register. See
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc2-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc2 for GFX6-GFX10</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p>458:448</p></td>
<td><p>7 bits</p></td>
<td><p><em>See separate bits below.</em></p></td>
<td><p>Enable the setup of the
SGPR user data registers
(see
<a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>).</p>
<p>The total number of SGPR
user data registers
requested must not exceed
16 and match value in
<code class="docutils literal notranslate"><span class="pre">compute_pgm_rsrc2.user_sgpr.user_sgpr_count</span></code>.
Any requests beyond 16
will be ignored.</p>
</td>
</tr>
<tr class="row-even"><td><p>&gt;448</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_SGPR_PRIVATE_SEGMENT
_BUFFER</p></td>
<td><p>If the <em>Target Properties</em>
column of
<a class="reference internal" href="#amdgpu-processor-table"><span class="std std-ref">AMDGPU Processors</span></a>
specifies <em>Architected flat
scratch</em> then not supported
and must be 0,</p></td>
</tr>
<tr class="row-odd"><td><p>&gt;449</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_SGPR_DISPATCH_PTR</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>&gt;450</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_SGPR_QUEUE_PTR</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>&gt;451</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_SGPR_KERNARG_SEGMENT_PTR</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>&gt;452</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_SGPR_DISPATCH_ID</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>&gt;453</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_SGPR_FLAT_SCRATCH_INIT</p></td>
<td><p>If the <em>Target Properties</em>
column of
<a class="reference internal" href="#amdgpu-processor-table"><span class="std std-ref">AMDGPU Processors</span></a>
specifies <em>Architected flat
scratch</em> then not supported
and must be 0,</p></td>
</tr>
<tr class="row-even"><td><p>&gt;454</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_SGPR_PRIVATE_SEGMENT
_SIZE</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>457:455</p></td>
<td><p>3 bits</p></td>
<td></td>
<td><p>Reserved, must be 0.</p></td>
</tr>
<tr class="row-even"><td><p>458</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_WAVEFRONT_SIZE32</p></td>
<td><dl class="simple">
<dt>GFX6-GFX9</dt><dd><p>Reserved, must be 0.</p>
</dd>
<dt>GFX10</dt><dd><ul class="simple">
<li><p>If 0 execute in
wavefront size 64 mode.</p></li>
<li><p>If 1 execute in
native wavefront size
32 mode.</p></li>
</ul>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>463:459</p></td>
<td><p>1 bit</p></td>
<td></td>
<td><p>Reserved, must be 0.</p></td>
</tr>
<tr class="row-even"><td><p>464</p></td>
<td><p>1 bit</p></td>
<td><p>RESERVED_464</p></td>
<td><p>Deprecated, must be 0.</p></td>
</tr>
<tr class="row-odd"><td><p>467:465</p></td>
<td><p>3 bits</p></td>
<td></td>
<td><p>Reserved, must be 0.</p></td>
</tr>
<tr class="row-even"><td><p>468</p></td>
<td><p>1 bit</p></td>
<td><p>RESERVED_468</p></td>
<td><p>Deprecated, must be 0.</p></td>
</tr>
<tr class="row-odd"><td><p>469:471</p></td>
<td><p>3 bits</p></td>
<td></td>
<td><p>Reserved, must be 0.</p></td>
</tr>
<tr class="row-even"><td><p>511:472</p></td>
<td><p>5 bytes</p></td>
<td></td>
<td><p>Reserved, must be 0.</p></td>
</tr>
<tr class="row-odd"><td><p>512</p></td>
<td colspan="3"><p><strong>Total size 64 bytes.</strong></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-compute-pgm-rsrc1-gfx6-gfx10-table">
<caption><span class="caption-text">compute_pgm_rsrc1 for GFX6-GFX10</span><a class="headerlink" href="#amdgpu-amdhsa-compute-pgm-rsrc1-gfx6-gfx10-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 26%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bits</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Field Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>5:0</p></td>
<td><p>6 bits</p></td>
<td><p>GRANULATED_WORKITEM_VGPR_COUNT</p></td>
<td><p>Number of vector register
blocks used by each work-item;
granularity is device
specific:</p>
<dl class="simple">
<dt>GFX6-GFX9</dt><dd><ul class="simple">
<li><p>vgprs_used 0..256</p></li>
<li><p>max(0, ceil(vgprs_used / 4) - 1)</p></li>
</ul>
</dd>
<dt>GFX90A</dt><dd><ul class="simple">
<li><p>vgprs_used 0..512</p></li>
<li><dl class="simple">
<dt>vgprs_used = align(arch_vgprs, 4)</dt><dd><ul>
<li><p>acc_vgprs</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>max(0, ceil(vgprs_used / 8) - 1)</p></li>
</ul>
</dd>
<dt>GFX10 (wavefront size 64)</dt><dd><ul class="simple">
<li><p>max_vgpr 1..256</p></li>
<li><p>max(0, ceil(vgprs_used / 4) - 1)</p></li>
</ul>
</dd>
<dt>GFX10 (wavefront size 32)</dt><dd><ul class="simple">
<li><p>max_vgpr 1..256</p></li>
<li><p>max(0, ceil(vgprs_used / 8) - 1)</p></li>
</ul>
</dd>
</dl>
<p>Where vgprs_used is defined
as the highest VGPR number
explicitly referenced plus
one.</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.VGPRS</span></code>.</p>
<p>The
<a class="reference internal" href="#amdgpu-assembler"><span class="std std-ref">Assembler</span></a>
calculates this
automatically for the
selected processor from
values provided to the
<cite>.amdhsa_kernel</cite> directive
by the
<cite>.amdhsa_next_free_vgpr</cite>
nested directive (see
<a class="reference internal" href="#amdhsa-kernel-directives-table"><span class="std std-ref">AMDHSA Kernel Assembler Directives</span></a>).</p>
</td>
</tr>
<tr class="row-odd"><td><p>9:6</p></td>
<td><p>4 bits</p></td>
<td><p>GRANULATED_WAVEFRONT_SGPR_COUNT</p></td>
<td><p>Number of scalar register
blocks used by a wavefront;
granularity is device
specific:</p>
<dl class="simple">
<dt>GFX6-GFX8</dt><dd><ul class="simple">
<li><p>sgprs_used 0..112</p></li>
<li><p>max(0, ceil(sgprs_used / 8) - 1)</p></li>
</ul>
</dd>
<dt>GFX9</dt><dd><ul class="simple">
<li><p>sgprs_used 0..112</p></li>
<li><p>2 * max(0, ceil(sgprs_used / 16) - 1)</p></li>
</ul>
</dd>
<dt>GFX10</dt><dd><p>Reserved, must be 0.
(128 SGPRs always
allocated.)</p>
</dd>
</dl>
<p>Where sgprs_used is
defined as the highest
SGPR number explicitly
referenced plus one, plus
a target specific number
of additional special
SGPRs for VCC,
FLAT_SCRATCH (GFX7+) and
XNACK_MASK (GFX8+), and
any additional
target specific
limitations. It does not
include the 16 SGPRs added
if a trap handler is
enabled.</p>
<p>The target specific
limitations and special
SGPR layout are defined in
the hardware
documentation, which can
be found in the
<a class="reference internal" href="#amdgpu-processors"><span class="std std-ref">Processors</span></a>
table.</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.SGPRS</span></code>.</p>
<p>The
<a class="reference internal" href="#amdgpu-assembler"><span class="std std-ref">Assembler</span></a>
calculates this
automatically for the
selected processor from
values provided to the
<cite>.amdhsa_kernel</cite> directive
by the
<cite>.amdhsa_next_free_sgpr</cite>
and <cite>.amdhsa_reserve_*</cite>
nested directives (see
<a class="reference internal" href="#amdhsa-kernel-directives-table"><span class="std std-ref">AMDHSA Kernel Assembler Directives</span></a>).</p>
</td>
</tr>
<tr class="row-even"><td><p>11:10</p></td>
<td><p>2 bits</p></td>
<td><p>PRIORITY</p></td>
<td><p>Must be 0.</p>
<p>Start executing wavefront
at the specified priority.</p>
<p>CP is responsible for
filling in
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.PRIORITY</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>13:12</p></td>
<td><p>2 bits</p></td>
<td><p>FLOAT_ROUND_MODE_32</p></td>
<td><p>Wavefront starts execution
with specified rounding
mode for single (32
bit) floating point
precision floating point
operations.</p>
<p>Floating point rounding
mode values are defined in
<a class="reference internal" href="#amdgpu-amdhsa-floating-point-rounding-mode-enumeration-values-table"><span class="std std-ref">Floating Point Rounding Mode Enumeration Values</span></a>.</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.FLOAT_MODE</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><p>15:14</p></td>
<td><p>2 bits</p></td>
<td><p>FLOAT_ROUND_MODE_16_64</p></td>
<td><p>Wavefront starts execution
with specified rounding
denorm mode for half/double (16
and 64-bit) floating point
precision floating point
operations.</p>
<p>Floating point rounding
mode values are defined in
<a class="reference internal" href="#amdgpu-amdhsa-floating-point-rounding-mode-enumeration-values-table"><span class="std std-ref">Floating Point Rounding Mode Enumeration Values</span></a>.</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.FLOAT_MODE</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>17:16</p></td>
<td><p>2 bits</p></td>
<td><p>FLOAT_DENORM_MODE_32</p></td>
<td><p>Wavefront starts execution
with specified denorm mode
for single (32
bit)  floating point
precision floating point
operations.</p>
<p>Floating point denorm mode
values are defined in
<a class="reference internal" href="#amdgpu-amdhsa-floating-point-denorm-mode-enumeration-values-table"><span class="std std-ref">Floating Point Denorm Mode Enumeration Values</span></a>.</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.FLOAT_MODE</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><p>19:18</p></td>
<td><p>2 bits</p></td>
<td><p>FLOAT_DENORM_MODE_16_64</p></td>
<td><p>Wavefront starts execution
with specified denorm mode
for half/double (16
and 64-bit) floating point
precision floating point
operations.</p>
<p>Floating point denorm mode
values are defined in
<a class="reference internal" href="#amdgpu-amdhsa-floating-point-denorm-mode-enumeration-values-table"><span class="std std-ref">Floating Point Denorm Mode Enumeration Values</span></a>.</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.FLOAT_MODE</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>20</p></td>
<td><p>1 bit</p></td>
<td><p>PRIV</p></td>
<td><p>Must be 0.</p>
<p>Start executing wavefront
in privilege trap handler
mode.</p>
<p>CP is responsible for
filling in
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.PRIV</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><p>21</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_DX10_CLAMP</p></td>
<td><p>Wavefront starts execution
with DX10 clamp mode
enabled. Used by the vector
ALU to force DX10 style
treatment of NaN’s (when
set, clamp NaN to zero,
otherwise pass NaN
through).</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.DX10_CLAMP</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>22</p></td>
<td><p>1 bit</p></td>
<td><p>DEBUG_MODE</p></td>
<td><p>Must be 0.</p>
<p>Start executing wavefront
in single step mode.</p>
<p>CP is responsible for
filling in
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.DEBUG_MODE</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><p>23</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_IEEE_MODE</p></td>
<td><p>Wavefront starts execution
with IEEE mode
enabled. Floating point
opcodes that support
exception flag gathering
will quiet and propagate
signaling-NaN inputs per
IEEE 754-2008. Min_dx10 and
max_dx10 become IEEE
754-2008 compliant due to
signaling-NaN propagation
and quieting.</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.IEEE_MODE</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>24</p></td>
<td><p>1 bit</p></td>
<td><p>BULKY</p></td>
<td><p>Must be 0.</p>
<p>Only one work-group allowed
to execute on a compute
unit.</p>
<p>CP is responsible for
filling in
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.BULKY</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><p>25</p></td>
<td><p>1 bit</p></td>
<td><p>CDBG_USER</p></td>
<td><p>Must be 0.</p>
<p>Flag that can be used to
control debugging code.</p>
<p>CP is responsible for
filling in
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.CDBG_USER</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>26</p></td>
<td><p>1 bit</p></td>
<td><p>FP16_OVFL</p></td>
<td><dl>
<dt>GFX6-GFX8</dt><dd><p>Reserved, must be 0.</p>
</dd>
<dt>GFX9-GFX10</dt><dd><p>Wavefront starts execution
with specified fp16 overflow
mode.</p>
<ul class="simple">
<li><p>If 0, fp16 overflow generates
+/-INF values.</p></li>
<li><p>If 1, fp16 overflow that is the
result of an +/-INF input value
or divide by 0 produces a +/-INF,
otherwise clamps computed
overflow to +/-MAX_FP16 as
appropriate.</p></li>
</ul>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.FP16_OVFL</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>28:27</p></td>
<td><p>2 bits</p></td>
<td></td>
<td><p>Reserved, must be 0.</p></td>
</tr>
<tr class="row-odd"><td><p>29</p></td>
<td><p>1 bit</p></td>
<td><p>WGP_MODE</p></td>
<td><dl>
<dt>GFX6-GFX9</dt><dd><p>Reserved, must be 0.</p>
</dd>
<dt>GFX10</dt><dd><ul class="simple">
<li><p>If 0 execute work-groups in
CU wavefront execution mode.</p></li>
<li><p>If 1 execute work-groups on
in WGP wavefront execution mode.</p></li>
</ul>
<p>See <a class="reference internal" href="#amdgpu-amdhsa-memory-model"><span class="std std-ref">Memory Model</span></a>.</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.WGP_MODE</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>30</p></td>
<td><p>1 bit</p></td>
<td><p>MEM_ORDERED</p></td>
<td><dl>
<dt>GFX6-GFX9</dt><dd><p>Reserved, must be 0.</p>
</dd>
<dt>GFX10</dt><dd><p>Controls the behavior of the
s_waitcnt’s vmcnt and vscnt
counters.</p>
<ul class="simple">
<li><p>If 0 vmcnt reports completion
of load and atomic with return
out of order with sample
instructions, and the vscnt
reports the completion of
store and atomic without
return in order.</p></li>
<li><p>If 1 vmcnt reports completion
of load, atomic with return
and sample instructions in
order, and the vscnt reports
the completion of store and
atomic without return in order.</p></li>
</ul>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.MEM_ORDERED</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>31</p></td>
<td><p>1 bit</p></td>
<td><p>FWD_PROGRESS</p></td>
<td><dl>
<dt>GFX6-GFX9</dt><dd><p>Reserved, must be 0.</p>
</dd>
<dt>GFX10</dt><dd><ul class="simple">
<li><p>If 0 execute SIMD wavefronts
using oldest first policy.</p></li>
<li><p>If 1 execute SIMD wavefronts to
ensure wavefronts will make some
forward progress.</p></li>
</ul>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC1.FWD_PROGRESS</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>32</p></td>
<td colspan="3"><p><strong>Total size 4 bytes</strong></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-compute-pgm-rsrc2-gfx6-gfx10-table">
<caption><span class="caption-text">compute_pgm_rsrc2 for GFX6-GFX10</span><a class="headerlink" href="#amdgpu-amdhsa-compute-pgm-rsrc2-gfx6-gfx10-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 26%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bits</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Field Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_PRIVATE_SEGMENT</p></td>
<td><ul class="simple">
<li><p>Enable the setup of the
private segment.</p></li>
<li><p>If the <em>Target Properties</em>
column of
<a class="reference internal" href="#amdgpu-processor-table"><span class="std std-ref">AMDGPU Processors</span></a>
does not specify
<em>Architected flat
scratch</em> then enable the
setup of the SGPR
wavefront scratch offset
system register (see
<a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>).</p></li>
<li><p>If the <em>Target Properties</em>
column of
<a class="reference internal" href="#amdgpu-processor-table"><span class="std std-ref">AMDGPU Processors</span></a>
specifies <em>Architected
flat scratch</em> then enable
the setup of the
FLAT_SCRATCH register
pair (see
<a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>).</p></li>
</ul>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.SCRATCH_EN</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>5:1</p></td>
<td><p>5 bits</p></td>
<td><p>USER_SGPR_COUNT</p></td>
<td><p>The total number of SGPR
user data registers
requested. This number must
match the number of user
data registers enabled.</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.USER_SGPR</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_TRAP_HANDLER</p></td>
<td><p>Must be 0.</p>
<p>This bit represents
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.TRAP_PRESENT</span></code>,
which is set by the CP if
the runtime has installed a
trap handler.</p>
</td>
</tr>
<tr class="row-odd"><td><p>7</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_SGPR_WORKGROUP_ID_X</p></td>
<td><p>Enable the setup of the
system SGPR register for
the work-group id in the X
dimension (see
<a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>).</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.TGID_X_EN</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><p>8</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_SGPR_WORKGROUP_ID_Y</p></td>
<td><p>Enable the setup of the
system SGPR register for
the work-group id in the Y
dimension (see
<a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>).</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.TGID_Y_EN</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>9</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_SGPR_WORKGROUP_ID_Z</p></td>
<td><p>Enable the setup of the
system SGPR register for
the work-group id in the Z
dimension (see
<a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>).</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.TGID_Z_EN</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><p>10</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_SGPR_WORKGROUP_INFO</p></td>
<td><p>Enable the setup of the
system SGPR register for
work-group information (see
<a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>).</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.TGID_SIZE_EN</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p>12:11</p></td>
<td><p>2 bits</p></td>
<td><p>ENABLE_VGPR_WORKITEM_ID</p></td>
<td><p>Enable the setup of the
VGPR system registers used
for the work-item ID.
<a class="reference internal" href="#amdgpu-amdhsa-system-vgpr-work-item-id-enumeration-values-table"><span class="std std-ref">System VGPR Work-Item ID Enumeration Values</span></a>
defines the values.</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.TIDIG_CMP_CNT</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><p>13</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_EXCEPTION_ADDRESS_WATCH</p></td>
<td><p>Must be 0.</p>
<p>Wavefront starts execution
with address watch
exceptions enabled which
are generated when L1 has
witnessed a thread access
an <em>address of
interest</em>.</p>
<p>CP is responsible for
filling in the address
watch bit in
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.EXCP_EN_MSB</span></code>
according to what the
runtime requests.</p>
</td>
</tr>
<tr class="row-odd"><td><p>14</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_EXCEPTION_MEMORY</p></td>
<td><p>Must be 0.</p>
<p>Wavefront starts execution
with memory violation
exceptions exceptions
enabled which are generated
when a memory violation has
occurred for this wavefront from
L1 or LDS
(write-to-read-only-memory,
mis-aligned atomic, LDS
address out of range,
illegal address, etc.).</p>
<p>CP sets the memory
violation bit in
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.EXCP_EN_MSB</span></code>
according to what the
runtime requests.</p>
</td>
</tr>
<tr class="row-even"><td><p>23:15</p></td>
<td><p>9 bits</p></td>
<td><p>GRANULATED_LDS_SIZE</p></td>
<td><p>Must be 0.</p>
<p>CP uses the rounded value
from the dispatch packet,
not this value, as the
dispatch may contain
dynamically allocated group
segment memory. CP writes
directly to
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.LDS_SIZE</span></code>.</p>
<p>Amount of group segment
(LDS) to allocate for each
work-group. Granularity is
device specific:</p>
<dl class="simple">
<dt>GFX6</dt><dd><p>roundup(lds-size / (64 * 4))</p>
</dd>
<dt>GFX7-GFX10</dt><dd><p>roundup(lds-size / (128 * 4))</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>24</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_EXCEPTION_IEEE_754_FP
_INVALID_OPERATION</p></td>
<td><p>Wavefront starts execution
with specified exceptions
enabled.</p>
<p>Used by CP to set up
<code class="docutils literal notranslate"><span class="pre">COMPUTE_PGM_RSRC2.EXCP_EN</span></code>
(set from bits 0..6).</p>
<p>IEEE 754 FP Invalid
Operation</p>
</td>
</tr>
<tr class="row-even"><td><p>25</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_EXCEPTION_FP_DENORMAL
_SOURCE</p></td>
<td><p>FP Denormal one or more
input operands is a
denormal number</p></td>
</tr>
<tr class="row-odd"><td><p>26</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_EXCEPTION_IEEE_754_FP
_DIVISION_BY_ZERO</p></td>
<td><p>IEEE 754 FP Division by
Zero</p></td>
</tr>
<tr class="row-even"><td><p>27</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_EXCEPTION_IEEE_754_FP
_OVERFLOW</p></td>
<td><p>IEEE 754 FP FP Overflow</p></td>
</tr>
<tr class="row-odd"><td><p>28</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_EXCEPTION_IEEE_754_FP
_UNDERFLOW</p></td>
<td><p>IEEE 754 FP Underflow</p></td>
</tr>
<tr class="row-even"><td><p>29</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_EXCEPTION_IEEE_754_FP
_INEXACT</p></td>
<td><p>IEEE 754 FP Inexact</p></td>
</tr>
<tr class="row-odd"><td><p>30</p></td>
<td><p>1 bit</p></td>
<td><p>ENABLE_EXCEPTION_INT_DIVIDE_BY
_ZERO</p></td>
<td><p>Integer Division by Zero
(rcp_iflag_f32 instruction
only)</p></td>
</tr>
<tr class="row-even"><td><p>31</p></td>
<td><p>1 bit</p></td>
<td></td>
<td><p>Reserved, must be 0.</p></td>
</tr>
<tr class="row-odd"><td><p>32</p></td>
<td colspan="3"><p><strong>Total size 4 bytes.</strong></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-compute-pgm-rsrc3-gfx90a-table">
<caption><span class="caption-text">compute_pgm_rsrc3 for GFX90A</span><a class="headerlink" href="#amdgpu-amdhsa-compute-pgm-rsrc3-gfx90a-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 26%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bits</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Field Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>5:0</p></td>
<td><p>6 bits</p></td>
<td><p>ACCUM_OFFSET</p></td>
<td><p>Offset of a first AccVGPR in the unified register file. Granularity 4.
Value 0-63. 0 - accum-offset = 4, 1 - accum-offset = 8, …,
63 - accum-offset = 256.</p></td>
</tr>
<tr class="row-odd"><td><p>6:15</p></td>
<td><p>10
bits</p></td>
<td></td>
<td><p>Reserved, must be 0.</p></td>
</tr>
<tr class="row-even"><td><p>16</p></td>
<td><p>1 bit</p></td>
<td><p>TG_SPLIT</p></td>
<td><ul class="simple">
<li><p>If 0 the waves of a work-group are
launched in the same CU.</p></li>
<li><p>If 1 the waves of a work-group can be
launched in different CUs. The waves
cannot use S_BARRIER or LDS.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>17:31</p></td>
<td><p>15
bits</p></td>
<td></td>
<td><p>Reserved, must be 0.</p></td>
</tr>
<tr class="row-even"><td><p>32</p></td>
<td colspan="3"><p><strong>Total size 4 bytes.</strong></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-compute-pgm-rsrc3-gfx10-table">
<caption><span class="caption-text">compute_pgm_rsrc3 for GFX10</span><a class="headerlink" href="#amdgpu-amdhsa-compute-pgm-rsrc3-gfx10-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 26%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bits</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Field Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>3:0</p></td>
<td><p>4 bits</p></td>
<td><p>SHARED_VGPR_COUNT</p></td>
<td><p>Number of shared VGPRs for wavefront size 64. Granularity 8. Value 0-120.
compute_pgm_rsrc1.vgprs + shared_vgpr_cnt cannot exceed 64.</p></td>
</tr>
<tr class="row-odd"><td><p>31:4</p></td>
<td><p>28
bits</p></td>
<td></td>
<td><p>Reserved, must be 0.</p></td>
</tr>
<tr class="row-even"><td><p>32</p></td>
<td colspan="3"><p><strong>Total size 4 bytes.</strong></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-floating-point-rounding-mode-enumeration-values-table">
<caption><span class="caption-text">Floating Point Rounding Mode Enumeration Values</span><a class="headerlink" href="#amdgpu-amdhsa-floating-point-rounding-mode-enumeration-values-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 52%" />
<col style="width: 7%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Enumeration Name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>FLOAT_ROUND_MODE_NEAR_EVEN</p></td>
<td><p>0</p></td>
<td><p>Round Ties To Even</p></td>
</tr>
<tr class="row-odd"><td><p>FLOAT_ROUND_MODE_PLUS_INFINITY</p></td>
<td><p>1</p></td>
<td><p>Round Toward +infinity</p></td>
</tr>
<tr class="row-even"><td><p>FLOAT_ROUND_MODE_MINUS_INFINITY</p></td>
<td><p>2</p></td>
<td><p>Round Toward -infinity</p></td>
</tr>
<tr class="row-odd"><td><p>FLOAT_ROUND_MODE_ZERO</p></td>
<td><p>3</p></td>
<td><p>Round Toward 0</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-floating-point-denorm-mode-enumeration-values-table">
<caption><span class="caption-text">Floating Point Denorm Mode Enumeration Values</span><a class="headerlink" href="#amdgpu-amdhsa-floating-point-denorm-mode-enumeration-values-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 52%" />
<col style="width: 7%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Enumeration Name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>FLOAT_DENORM_MODE_FLUSH_SRC_DST</p></td>
<td><p>0</p></td>
<td><p>Flush Source and Destination
Denorms</p></td>
</tr>
<tr class="row-odd"><td><p>FLOAT_DENORM_MODE_FLUSH_DST</p></td>
<td><p>1</p></td>
<td><p>Flush Output Denorms</p></td>
</tr>
<tr class="row-even"><td><p>FLOAT_DENORM_MODE_FLUSH_SRC</p></td>
<td><p>2</p></td>
<td><p>Flush Source Denorms</p></td>
</tr>
<tr class="row-odd"><td><p>FLOAT_DENORM_MODE_FLUSH_NONE</p></td>
<td><p>3</p></td>
<td><p>No Flush</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-system-vgpr-work-item-id-enumeration-values-table">
<caption><span class="caption-text">System VGPR Work-Item ID Enumeration Values</span><a class="headerlink" href="#amdgpu-amdhsa-system-vgpr-work-item-id-enumeration-values-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 55%" />
<col style="width: 7%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Enumeration Name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>SYSTEM_VGPR_WORKITEM_ID_X</p></td>
<td><p>0</p></td>
<td><p>Set work-item X dimension
ID.</p></td>
</tr>
<tr class="row-odd"><td><p>SYSTEM_VGPR_WORKITEM_ID_X_Y</p></td>
<td><p>1</p></td>
<td><p>Set work-item X and Y
dimensions ID.</p></td>
</tr>
<tr class="row-even"><td><p>SYSTEM_VGPR_WORKITEM_ID_X_Y_Z</p></td>
<td><p>2</p></td>
<td><p>Set work-item X, Y and Z
dimensions ID.</p></td>
</tr>
<tr class="row-odd"><td><p>SYSTEM_VGPR_WORKITEM_ID_UNDEFINED</p></td>
<td><p>3</p></td>
<td><p>Undefined.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
</div>
<div class="section" id="initial-kernel-execution-state">
<span id="amdgpu-amdhsa-initial-kernel-execution-state"></span><h4><a class="toc-backref" href="#id144">Initial Kernel Execution State</a><a class="headerlink" href="#initial-kernel-execution-state" title="Permalink to this headline">¶</a></h4>
<p>This section defines the register state that will be set up by the packet
processor prior to the start of execution of every wavefront. This is limited by
the constraints of the hardware controllers of CP/ADC/SPI.</p>
<p>The order of the SGPR registers is defined, but the compiler can specify which
ones are actually setup in the kernel descriptor using the <code class="docutils literal notranslate"><span class="pre">enable_sgpr_*</span></code> bit
fields (see <a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor"><span class="std std-ref">Kernel Descriptor</span></a>). The register numbers used
for enabled registers are dense starting at SGPR0: the first enabled register is
SGPR0, the next enabled register is SGPR1 etc.; disabled registers do not have
an SGPR number.</p>
<p>The initial SGPRs comprise up to 16 User SRGPs that are set by CP and apply to
all wavefronts of the grid. It is possible to specify more than 16 User SGPRs
using the <code class="docutils literal notranslate"><span class="pre">enable_sgpr_*</span></code> bit fields, in which case only the first 16 are
actually initialized. These are then immediately followed by the System SGPRs
that are set up by ADC/SPI and can have different values for each wavefront of
the grid dispatch.</p>
<p>SGPR register initial state is defined in
<a class="reference internal" href="#amdgpu-amdhsa-sgpr-register-set-up-order-table"><span class="std std-ref">SGPR Register Set Up Order</span></a>.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-sgpr-register-set-up-order-table">
<caption><span class="caption-text">SGPR Register Set Up Order</span><a class="headerlink" href="#amdgpu-amdhsa-sgpr-register-set-up-order-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 10%" />
<col style="width: 26%" />
<col style="width: 6%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>SGPR Order</p></th>
<th class="head"><p>Name
(kernel descriptor enable
field)</p></th>
<th class="head"><p>Number
of
SGPRs</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>First</p></td>
<td><p>Private Segment Buffer
(enable_sgpr_private
_segment_buffer)</p></td>
<td><p>4</p></td>
<td><p>See
<a class="reference internal" href="#amdgpu-amdhsa-kernel-prolog-private-segment-buffer"><span class="std std-ref">Private Segment Buffer</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p>then</p></td>
<td><p>Dispatch Ptr
(enable_sgpr_dispatch_ptr)</p></td>
<td><p>2</p></td>
<td><p>64-bit address of AQL dispatch
packet for kernel dispatch
actually executing.</p></td>
</tr>
<tr class="row-even"><td><p>then</p></td>
<td><p>Queue Ptr
(enable_sgpr_queue_ptr)</p></td>
<td><p>2</p></td>
<td><p>64-bit address of amd_queue_t
object for AQL queue on which
the dispatch packet was
queued.</p></td>
</tr>
<tr class="row-odd"><td><p>then</p></td>
<td><p>Kernarg Segment Ptr
(enable_sgpr_kernarg
_segment_ptr)</p></td>
<td><p>2</p></td>
<td><p>64-bit address of Kernarg
segment. This is directly
copied from the
kernarg_address in the kernel
dispatch packet.</p>
<p>Having CP load it once avoids
loading it at the beginning of
every wavefront.</p>
</td>
</tr>
<tr class="row-even"><td><p>then</p></td>
<td><p>Dispatch Id
(enable_sgpr_dispatch_id)</p></td>
<td><p>2</p></td>
<td><p>64-bit Dispatch ID of the
dispatch packet being
executed.</p></td>
</tr>
<tr class="row-odd"><td><p>then</p></td>
<td><p>Flat Scratch Init
(enable_sgpr_flat_scratch
_init)</p></td>
<td><p>2</p></td>
<td><p>See
<a class="reference internal" href="#amdgpu-amdhsa-kernel-prolog-flat-scratch"><span class="std std-ref">Flat Scratch</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p>then</p></td>
<td><p>Private Segment Size
(enable_sgpr_private
_segment_size)</p></td>
<td><p>1</p></td>
<td><p>The 32-bit byte size of a
single work-item’s memory
allocation. This is the
value from the kernel
dispatch packet Private
Segment Byte Size rounded up
by CP to a multiple of
DWORD.</p>
<p>Having CP load it once avoids
loading it at the beginning of
every wavefront.</p>
<p>This is not used for
GFX7-GFX8 since it is the same
value as the second SGPR of
Flat Scratch Init. However, it
may be needed for GFX9-GFX10 which
changes the meaning of the
Flat Scratch Init value.</p>
</td>
</tr>
<tr class="row-odd"><td><p>then</p></td>
<td><p>Work-Group Id X
(enable_sgpr_workgroup_id
_X)</p></td>
<td><p>1</p></td>
<td><p>32-bit work-group id in X
dimension of grid for
wavefront.</p></td>
</tr>
<tr class="row-even"><td><p>then</p></td>
<td><p>Work-Group Id Y
(enable_sgpr_workgroup_id
_Y)</p></td>
<td><p>1</p></td>
<td><p>32-bit work-group id in Y
dimension of grid for
wavefront.</p></td>
</tr>
<tr class="row-odd"><td><p>then</p></td>
<td><p>Work-Group Id Z
(enable_sgpr_workgroup_id
_Z)</p></td>
<td><p>1</p></td>
<td><p>32-bit work-group id in Z
dimension of grid for
wavefront.</p></td>
</tr>
<tr class="row-even"><td><p>then</p></td>
<td><p>Work-Group Info
(enable_sgpr_workgroup
_info)</p></td>
<td><p>1</p></td>
<td><p>{first_wavefront, 14’b0000,
ordered_append_term[10:0],
threadgroup_size_in_wavefronts[5:0]}</p></td>
</tr>
<tr class="row-odd"><td><p>then</p></td>
<td><p>Scratch Wavefront Offset
(enable_sgpr_private
_segment_wavefront_offset)</p></td>
<td><p>1</p></td>
<td><p>See
<a class="reference internal" href="#amdgpu-amdhsa-kernel-prolog-flat-scratch"><span class="std std-ref">Flat Scratch</span></a>.
and
<a class="reference internal" href="#amdgpu-amdhsa-kernel-prolog-private-segment-buffer"><span class="std std-ref">Private Segment Buffer</span></a>.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The order of the VGPR registers is defined, but the compiler can specify which
ones are actually setup in the kernel descriptor using the <code class="docutils literal notranslate"><span class="pre">enable_vgpr*</span></code> bit
fields (see <a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor"><span class="std std-ref">Kernel Descriptor</span></a>). The register numbers used
for enabled registers are dense starting at VGPR0: the first enabled register is
VGPR0, the next enabled register is VGPR1 etc.; disabled registers do not have a
VGPR number.</p>
<p>There are different methods used for the VGPR initial state:</p>
<ul>
<li><p>Unless the <em>Target Properties</em> column of <a class="reference internal" href="#amdgpu-processor-table"><span class="std std-ref">AMDGPU Processors</span></a>
specifies otherwise, a separate VGPR register is used per work-item ID. The
VGPR register initial state for this method is defined in
<a class="reference internal" href="#amdgpu-amdhsa-vgpr-register-set-up-order-for-unpacked-work-item-id-method-table"><span class="std std-ref">VGPR Register Set Up Order for Unpacked Work-Item ID Method</span></a>.</p></li>
<li><p>If <em>Target Properties</em> column of <a class="reference internal" href="#amdgpu-processor-table"><span class="std std-ref">AMDGPU Processors</span></a>
specifies <em>Packed work-item IDs</em>, the initial value of VGPR0 register is used
for all work-item IDs. The register layout for this method is defined in
<a class="reference internal" href="#amdgpu-amdhsa-register-layout-for-packed-work-item-id-method-table"><span class="std std-ref">Register Layout for Packed Work-Item ID Method</span></a>.</p>
<table class="docutils align-default" id="amdgpu-amdhsa-vgpr-register-set-up-order-for-unpacked-work-item-id-method-table">
<caption><span class="caption-text">VGPR Register Set Up Order for Unpacked Work-Item ID Method</span><a class="headerlink" href="#amdgpu-amdhsa-vgpr-register-set-up-order-for-unpacked-work-item-id-method-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 36%" />
<col style="width: 8%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>VGPR Order</p></th>
<th class="head"><p>Name
(kernel descriptor enable
field)</p></th>
<th class="head"><p>Number
of
VGPRs</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>First</p></td>
<td><p>Work-Item Id X
(Always initialized)</p></td>
<td><p>1</p></td>
<td><p>32-bit work-item id in X
dimension of work-group for
wavefront lane.</p></td>
</tr>
<tr class="row-odd"><td><p>then</p></td>
<td><p>Work-Item Id Y
(enable_vgpr_workitem_id
&gt; 0)</p></td>
<td><p>1</p></td>
<td><p>32-bit work-item id in Y
dimension of work-group for
wavefront lane.</p></td>
</tr>
<tr class="row-even"><td><p>then</p></td>
<td><p>Work-Item Id Z
(enable_vgpr_workitem_id
&gt; 1)</p></td>
<td><p>1</p></td>
<td><p>32-bit work-item id in Z
dimension of work-group for
wavefront lane.</p></td>
</tr>
</tbody>
</table>
</li>
</ul>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-register-layout-for-packed-work-item-id-method-table">
<caption><span class="caption-text">Register Layout for Packed Work-Item ID Method</span><a class="headerlink" href="#amdgpu-amdhsa-register-layout-for-packed-work-item-id-method-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 23%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bits</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Field Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0:9</p></td>
<td><p>10 bits</p></td>
<td><p>Work-Item Id X</p></td>
<td><p>Work-item id in X
dimension of work-group for
wavefront lane.</p>
<p>Always initialized.</p>
</td>
</tr>
<tr class="row-odd"><td><p>10:19</p></td>
<td><p>10 bits</p></td>
<td><p>Work-Item Id Y</p></td>
<td><p>Work-item id in Y
dimension of work-group for
wavefront lane.</p>
<p>Initialized if enable_vgpr_workitem_id &gt;
0, otherwise set to 0.</p>
</td>
</tr>
<tr class="row-even"><td><p>20:29</p></td>
<td><p>10 bits</p></td>
<td><p>Work-Item Id Z</p></td>
<td><p>Work-item id in Z
dimension of work-group for
wavefront lane.</p>
<p>Initialized if enable_vgpr_workitem_id &gt;
1, otherwise set to 0.</p>
</td>
</tr>
<tr class="row-odd"><td><p>30:31</p></td>
<td><p>2 bits</p></td>
<td></td>
<td><p>Reserved, set to 0.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The setting of registers is done by GPU CP/ADC/SPI hardware as follows:</p>
<ol class="arabic simple">
<li><p>SGPRs before the Work-Group Ids are set by CP using the 16 User Data
registers.</p></li>
<li><p>Work-group Id registers X, Y, Z are set by ADC which supports any
combination including none.</p></li>
<li><p>Scratch Wavefront Offset is set by SPI in a per wavefront basis which is why
its value cannot be included with the flat scratch init value which is per
queue (see <a class="reference internal" href="#amdgpu-amdhsa-kernel-prolog-flat-scratch"><span class="std std-ref">Flat Scratch</span></a>).</p></li>
<li><p>The VGPRs are set by SPI which only supports specifying either (X), (X, Y)
or (X, Y, Z).</p></li>
<li><p>Flat Scratch register pair initialization is described in
<a class="reference internal" href="#amdgpu-amdhsa-kernel-prolog-flat-scratch"><span class="std std-ref">Flat Scratch</span></a>.</p></li>
</ol>
<p>The global segment can be accessed either using buffer instructions (GFX6 which
has V# 64-bit address support), flat instructions (GFX7-GFX10), or global
instructions (GFX9-GFX10).</p>
<p>If buffer operations are used, then the compiler can generate a V# with the
following properties:</p>
<ul class="simple">
<li><p>base address of 0</p></li>
<li><p>no swizzle</p></li>
<li><p>ATC: 1 if IOMMU present (such as APU)</p></li>
<li><p>ptr64: 1</p></li>
<li><p>MTYPE set to support memory coherence that matches the runtime (such as CC for
APU and NC for dGPU).</p></li>
</ul>
</div>
<div class="section" id="kernel-prolog">
<span id="amdgpu-amdhsa-kernel-prolog"></span><h4><a class="toc-backref" href="#id145">Kernel Prolog</a><a class="headerlink" href="#kernel-prolog" title="Permalink to this headline">¶</a></h4>
<p>The compiler performs initialization in the kernel prologue depending on the
target and information about things like stack usage in the kernel and called
functions. Some of this initialization requires the compiler to request certain
User and System SGPRs be present in the
<a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a> via the
<a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor"><span class="std std-ref">Kernel Descriptor</span></a>.</p>
<div class="section" id="cfi">
<span id="amdgpu-amdhsa-kernel-prolog-cfi"></span><h5><a class="toc-backref" href="#id146">CFI</a><a class="headerlink" href="#cfi" title="Permalink to this headline">¶</a></h5>
<ol class="arabic simple">
<li><p>The CFI return address is undefined.</p></li>
<li><p>The CFI CFA is defined using an expression which evaluates to a location
description that comprises one memory location description for the
<code class="docutils literal notranslate"><span class="pre">DW_ASPACE_AMDGPU_private_lane</span></code> address space address <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p></li>
</ol>
</div>
<div class="section" id="m0">
<span id="amdgpu-amdhsa-kernel-prolog-m0"></span><h5><a class="toc-backref" href="#id147">M0</a><a class="headerlink" href="#m0" title="Permalink to this headline">¶</a></h5>
<dl class="simple">
<dt>GFX6-GFX8</dt><dd><p>The M0 register must be initialized with a value at least the total LDS size
if the kernel may access LDS via DS or flat operations. Total LDS size is
available in dispatch packet. For M0, it is also possible to use maximum
possible value of LDS for given target (0x7FFF for GFX6 and 0xFFFF for
GFX7-GFX8).</p>
</dd>
<dt>GFX9-GFX10</dt><dd><p>The M0 register is not used for range checking LDS accesses and so does not
need to be initialized in the prolog.</p>
</dd>
</dl>
</div>
<div class="section" id="stack-pointer">
<span id="amdgpu-amdhsa-kernel-prolog-stack-pointer"></span><h5><a class="toc-backref" href="#id148">Stack Pointer</a><a class="headerlink" href="#stack-pointer" title="Permalink to this headline">¶</a></h5>
<p>If the kernel has function calls it must set up the ABI stack pointer described
in <a class="reference internal" href="#amdgpu-amdhsa-function-call-convention-non-kernel-functions"><span class="std std-ref">Non-Kernel Functions</span></a> by setting
SGPR32 to the unswizzled scratch offset of the address past the last local
allocation.</p>
</div>
<div class="section" id="frame-pointer">
<span id="amdgpu-amdhsa-kernel-prolog-frame-pointer"></span><h5><a class="toc-backref" href="#id149">Frame Pointer</a><a class="headerlink" href="#frame-pointer" title="Permalink to this headline">¶</a></h5>
<p>If the kernel needs a frame pointer for the reasons defined in
<code class="docutils literal notranslate"><span class="pre">SIFrameLowering</span></code> then SGPR33 is used and is always set to <code class="docutils literal notranslate"><span class="pre">0</span></code> in the
kernel prolog. If a frame pointer is not required then all uses of the frame
pointer are replaced with immediate <code class="docutils literal notranslate"><span class="pre">0</span></code> offsets.</p>
</div>
<div class="section" id="flat-scratch">
<span id="amdgpu-amdhsa-kernel-prolog-flat-scratch"></span><h5><a class="toc-backref" href="#id150">Flat Scratch</a><a class="headerlink" href="#flat-scratch" title="Permalink to this headline">¶</a></h5>
<p>There are different methods used for initializing flat scratch:</p>
<ul>
<li><p>If the <em>Target Properties</em> column of <a class="reference internal" href="#amdgpu-processor-table"><span class="std std-ref">AMDGPU Processors</span></a>
specifies <em>Does not support generic address space</em>:</p>
<p>Flat scratch is not supported and there is no flat scratch register pair.</p>
</li>
<li><p>If the <em>Target Properties</em> column of <a class="reference internal" href="#amdgpu-processor-table"><span class="std std-ref">AMDGPU Processors</span></a>
specifies <em>Offset flat scratch</em>:</p>
<p>If the kernel or any function it calls may use flat operations to access
scratch memory, the prolog code must set up the FLAT_SCRATCH register pair
(FLAT_SCRATCH_LO/FLAT_SCRATCH_HI). Initialization uses Flat Scratch Init and
Scratch Wavefront Offset SGPR registers (see
<a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>):</p>
<ol class="arabic">
<li><p>The low word of Flat Scratch Init is the 32-bit byte offset from
<code class="docutils literal notranslate"><span class="pre">SH_HIDDEN_PRIVATE_BASE_VIMID</span></code> to the base of scratch backing memory
being managed by SPI for the queue executing the kernel dispatch. This is
the same value used in the Scratch Segment Buffer V# base address.</p>
<p>CP obtains this from the runtime. (The Scratch Segment Buffer base address
is <code class="docutils literal notranslate"><span class="pre">SH_HIDDEN_PRIVATE_BASE_VIMID</span></code> plus this offset.)</p>
<p>The prolog must add the value of Scratch Wavefront Offset to get the
wavefront’s byte scratch backing memory offset from
<code class="docutils literal notranslate"><span class="pre">SH_HIDDEN_PRIVATE_BASE_VIMID</span></code>.</p>
<p>The Scratch Wavefront Offset must also be used as an offset with Private
segment address when using the Scratch Segment Buffer.</p>
<p>Since FLAT_SCRATCH_LO is in units of 256 bytes, the offset must be right
shifted by 8 before moving into FLAT_SCRATCH_HI.</p>
<p>FLAT_SCRATCH_HI corresponds to SGPRn-4 on GFX7, and SGPRn-6 on GFX8 (where
SGPRn is the highest numbered SGPR allocated to the wavefront).
FLAT_SCRATCH_HI is multiplied by 256 (as it is in units of 256 bytes) and
added to <code class="docutils literal notranslate"><span class="pre">SH_HIDDEN_PRIVATE_BASE_VIMID</span></code> to calculate the per wavefront
FLAT SCRATCH BASE in flat memory instructions that access the scratch
aperture.</p>
</li>
<li><p>The second word of Flat Scratch Init is 32-bit byte size of a single
work-items scratch memory usage.</p>
<p>CP obtains this from the runtime, and it is always a multiple of DWORD. CP
checks that the value in the kernel dispatch packet Private Segment Byte
Size is not larger and requests the runtime to increase the queue’s scratch
size if necessary.</p>
<p>CP directly loads from the kernel dispatch packet Private Segment Byte Size
field and rounds up to a multiple of DWORD. Having CP load it once avoids
loading it at the beginning of every wavefront.</p>
<p>The kernel prolog code must move it to FLAT_SCRATCH_LO which is SGPRn-3 on
GFX7 and SGPRn-5 on GFX8. FLAT_SCRATCH_LO is used as the FLAT SCRATCH SIZE
in flat memory instructions.</p>
</li>
</ol>
</li>
<li><p>If the <em>Target Properties</em> column of <a class="reference internal" href="#amdgpu-processor-table"><span class="std std-ref">AMDGPU Processors</span></a>
specifies <em>Absolute flat scratch</em>:</p>
<p>If the kernel or any function it calls may use flat operations to access
scratch memory, the prolog code must set up the FLAT_SCRATCH register pair
(FLAT_SCRATCH_LO/FLAT_SCRATCH_HI which are in SGPRn-4/SGPRn-3). Initialization
uses Flat Scratch Init and Scratch Wavefront Offset SGPR registers (see
<a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>):</p>
<p>The Flat Scratch Init is the 64-bit address of the base of scratch backing
memory being managed by SPI for the queue executing the kernel dispatch.</p>
<p>CP obtains this from the runtime.</p>
<p>The kernel prolog must add the value of the wave’s Scratch Wavefront Offset
and move the result as a 64-bit value to the FLAT_SCRATCH SGPR register pair
which is SGPRn-6 and SGPRn-5. It is used as the FLAT SCRATCH BASE in flat
memory instructions.</p>
<p>The Scratch Wavefront Offset must also be used as an offset with Private
segment address when using the Scratch Segment Buffer (see
<a class="reference internal" href="#amdgpu-amdhsa-kernel-prolog-private-segment-buffer"><span class="std std-ref">Private Segment Buffer</span></a>).</p>
</li>
<li><p>If the <em>Target Properties</em> column of <a class="reference internal" href="#amdgpu-processor-table"><span class="std std-ref">AMDGPU Processors</span></a>
specifies <em>Architected flat scratch</em>:</p>
<p>If ENABLE_PRIVATE_SEGMENT is enabled in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc2-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc2 for GFX6-GFX10</span></a> then the FLAT_SCRATCH
register pair will be initialized to the 64-bit address of the base of scratch
backing memory being managed by SPI for the queue executing the kernel
dispatch plus the value of the wave’s Scratch Wavefront Offset for use as the
flat scratch base in flat memory instructions.</p>
</li>
</ul>
</div>
<div class="section" id="private-segment-buffer">
<span id="amdgpu-amdhsa-kernel-prolog-private-segment-buffer"></span><h5><a class="toc-backref" href="#id151">Private Segment Buffer</a><a class="headerlink" href="#private-segment-buffer" title="Permalink to this headline">¶</a></h5>
<p>If the <em>Target Properties</em> column of <a class="reference internal" href="#amdgpu-processor-table"><span class="std std-ref">AMDGPU Processors</span></a> specifies
<em>Architected flat scratch</em> then a Private Segment Buffer is not supported.
Instead the flat SCRATCH instructions are used.</p>
<p>Otherwise, Private Segment Buffer SGPR register is used to initialize 4 SGPRs
that are used as a V# to access scratch. CP uses the value provided by the
runtime. It is used, together with Scratch Wavefront Offset as an offset, to
access the private memory space using a segment address. See
<a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>.</p>
<p>The scratch V# is a four-aligned SGPR and always selected for the kernel as
follows:</p>
<blockquote>
<div><ul>
<li><p>If it is known during instruction selection that there is stack usage,
SGPR0-3 is reserved for use as the scratch V#.  Stack usage is assumed if
optimizations are disabled (<code class="docutils literal notranslate"><span class="pre">-O0</span></code>), if stack objects already exist (for
locals, etc.), or if there are any function calls.</p></li>
<li><p>Otherwise, four high numbered SGPRs beginning at a four-aligned SGPR index
are reserved for the tentative scratch V#. These will be used if it is
determined that spilling is needed.</p>
<ul class="simple">
<li><p>If no use is made of the tentative scratch V#, then it is unreserved,
and the register count is determined ignoring it.</p></li>
<li><p>If use is made of the tentative scratch V#, then its register numbers
are shifted to the first four-aligned SGPR index after the highest one
allocated by the register allocator, and all uses are updated. The
register count includes them in the shifted location.</p></li>
<li><p>In either case, if the processor has the SGPR allocation bug, the
tentative allocation is not shifted or unreserved in order to ensure
the register count is higher to workaround the bug.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This approach of using a tentative scratch V# and shifting the register
numbers if used avoids having to perform register allocation a second
time if the tentative V# is eliminated. This is more efficient and
avoids the problem that the second register allocation may perform
spilling which will fail as there is no longer a scratch V#.</p>
</div>
</li>
</ul>
</div></blockquote>
<p>When the kernel prolog code is being emitted it is known whether the scratch V#
described above is actually used. If it is, the prolog code must set it up by
copying the Private Segment Buffer to the scratch V# registers and then adding
the Private Segment Wavefront Offset to the queue base address in the V#. The
result is a V# with a base address pointing to the beginning of the wavefront
scratch backing memory.</p>
<p>The Private Segment Buffer is always requested, but the Private Segment
Wavefront Offset is only requested if it is used (see
<a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>).</p>
</div>
</div>
<div class="section" id="memory-model">
<span id="amdgpu-amdhsa-memory-model"></span><h4><a class="toc-backref" href="#id152">Memory Model</a><a class="headerlink" href="#memory-model" title="Permalink to this headline">¶</a></h4>
<p>This section describes the mapping of the LLVM memory model onto AMDGPU machine
code (see <a class="reference internal" href="LangRef.html#memmodel"><span class="std std-ref">Memory Model for Concurrent Operations</span></a>).</p>
<p>The AMDGPU backend supports the memory synchronization scopes specified in
<a class="reference internal" href="#amdgpu-memory-scopes"><span class="std std-ref">Memory Scopes</span></a>.</p>
<p>The code sequences used to implement the memory model specify the order of
instructions that a single thread must execute. The <code class="docutils literal notranslate"><span class="pre">s_waitcnt</span></code> and cache
management instructions such as <code class="docutils literal notranslate"><span class="pre">buffer_wbinvl1_vol</span></code> are defined with respect
to other memory instructions executed by the same thread. This allows them to be
moved earlier or later which can allow them to be combined with other instances
of the same instruction, or hoisted/sunk out of loops to improve performance.
Only the instructions related to the memory model are given; additional
<code class="docutils literal notranslate"><span class="pre">s_waitcnt</span></code> instructions are required to ensure registers are defined before
being used. These may be able to be combined with the memory model <code class="docutils literal notranslate"><span class="pre">s_waitcnt</span></code>
instructions as described above.</p>
<p>The AMDGPU backend supports the following memory models:</p>
<blockquote>
<div><dl class="simple">
<dt>HSA Memory Model <a class="reference internal" href="#hsa" id="id66"><span>[HSA]</span></a></dt><dd><p>The HSA memory model uses a single happens-before relation for all address
spaces (see <a class="reference internal" href="#amdgpu-address-spaces"><span class="std std-ref">Address Spaces</span></a>).</p>
</dd>
<dt>OpenCL Memory Model <a class="reference internal" href="#id92" id="id67"><span>[OpenCL]</span></a></dt><dd><p>The OpenCL memory model which has separate happens-before relations for the
global and local address spaces. Only a fence specifying both global and
local address space, and seq_cst instructions join the relationships. Since
the LLVM <code class="docutils literal notranslate"><span class="pre">memfence</span></code> instruction does not allow an address space to be
specified the OpenCL fence has to conservatively assume both local and
global address space was specified. However, optimizations can often be
done to eliminate the additional <code class="docutils literal notranslate"><span class="pre">s_waitcnt</span></code> instructions when there are
no intervening memory instructions which access the corresponding address
space. The code sequences in the table indicate what can be omitted for the
OpenCL memory. The target triple environment is used to determine if the
source language is OpenCL (see <a class="reference internal" href="#amdgpu-opencl"><span class="std std-ref">OpenCL</span></a>).</p>
</dd>
</dl>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">ds/flat_load/store/atomic</span></code> instructions to local memory are termed LDS
operations.</p>
<p><code class="docutils literal notranslate"><span class="pre">buffer/global/flat_load/store/atomic</span></code> instructions to global memory are
termed vector memory operations.</p>
<p>Private address space uses <code class="docutils literal notranslate"><span class="pre">buffer_load/store</span></code> using the scratch V#
(GFX6-GFX8), or <code class="docutils literal notranslate"><span class="pre">scratch_load/store</span></code> (GFX9-GFX10). Since only a single thread
is accessing the memory, atomic memory orderings are not meaningful, and all
accesses are treated as non-atomic.</p>
<p>Constant address space uses <code class="docutils literal notranslate"><span class="pre">buffer/global_load</span></code> instructions (or equivalent
scalar memory instructions). Since the constant address space contents do not
change during the execution of a kernel dispatch it is not legal to perform
stores, and atomic memory orderings are not meaningful, and all accesses are
treated as non-atomic.</p>
<p>A memory synchronization scope wider than work-group is not meaningful for the
group (LDS) address space and is treated as work-group.</p>
<p>The memory model does not support the region address space which is treated as
non-atomic.</p>
<p>Acquire memory ordering is not meaningful on store atomic instructions and is
treated as non-atomic.</p>
<p>Release memory ordering is not meaningful on load atomic instructions and is
treated a non-atomic.</p>
<p>Acquire-release memory ordering is not meaningful on load or store atomic
instructions and is treated as acquire and release respectively.</p>
<p>The memory order also adds the single thread optimization constraints defined in
table
<a class="reference internal" href="#amdgpu-amdhsa-memory-model-single-thread-optimization-constraints-table"><span class="std std-ref">AMDHSA Memory Model Single Thread Optimization Constraints</span></a>.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-memory-model-single-thread-optimization-constraints-table">
<caption><span class="caption-text">AMDHSA Memory Model Single Thread Optimization Constraints</span><a class="headerlink" href="#amdgpu-amdhsa-memory-model-single-thread-optimization-constraints-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 16%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>LLVM Memory</p></th>
<th class="head"><p>Optimization Constraints</p></th>
</tr>
<tr class="row-even"><th class="head"><p>Ordering</p></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td><p>unordered</p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-even"><td><p>monotonic</p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-odd"><td><p>acquire</p></td>
<td><ul class="simple">
<li><p>If a load atomic/atomicrmw then no following load/load
atomic/store/store atomic/atomicrmw/fence instruction can be
moved before the acquire.</p></li>
<li><p>If a fence then same as load atomic, plus no preceding
associated fence-paired-atomic can be moved after the fence.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>release</p></td>
<td><ul class="simple">
<li><p>If a store atomic/atomicrmw then no preceding load/load
atomic/store/store atomic/atomicrmw/fence instruction can be
moved after the release.</p></li>
<li><p>If a fence then same as store atomic, plus no following
associated fence-paired-atomic can be moved before the
fence.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>acq_rel</p></td>
<td><p>Same constraints as both acquire and release.</p></td>
</tr>
<tr class="row-even"><td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>If a load atomic then same constraints as acquire, plus no
preceding sequentially consistent load atomic/store
atomic/atomicrmw/fence instruction can be moved after the
seq_cst.</p></li>
<li><p>If a store atomic then the same constraints as release, plus
no following sequentially consistent load atomic/store
atomic/atomicrmw/fence instruction can be moved before the
seq_cst.</p></li>
<li><p>If an atomicrmw/fence then same constraints as acq_rel.</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The code sequences used to implement the memory model are defined in the
following sections:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#amdgpu-amdhsa-memory-model-gfx6-gfx9"><span class="std std-ref">Memory Model GFX6-GFX9</span></a></p></li>
<li><p><a class="reference internal" href="#amdgpu-amdhsa-memory-model-gfx90a"><span class="std std-ref">Memory Model GFX90A</span></a></p></li>
<li><p><a class="reference internal" href="#amdgpu-amdhsa-memory-model-gfx10"><span class="std std-ref">Memory Model GFX10</span></a></p></li>
</ul>
<div class="section" id="memory-model-gfx6-gfx9">
<span id="amdgpu-amdhsa-memory-model-gfx6-gfx9"></span><h5><a class="toc-backref" href="#id153">Memory Model GFX6-GFX9</a><a class="headerlink" href="#memory-model-gfx6-gfx9" title="Permalink to this headline">¶</a></h5>
<p>For GFX6-GFX9:</p>
<ul class="simple">
<li><p>Each agent has multiple shader arrays (SA).</p></li>
<li><p>Each SA has multiple compute units (CU).</p></li>
<li><p>Each CU has multiple SIMDs that execute wavefronts.</p></li>
<li><p>The wavefronts for a single work-group are executed in the same CU but may be
executed by different SIMDs.</p></li>
<li><p>Each CU has a single LDS memory shared by the wavefronts of the work-groups
executing on it.</p></li>
<li><p>All LDS operations of a CU are performed as wavefront wide operations in a
global order and involve no caching. Completion is reported to a wavefront in
execution order.</p></li>
<li><p>The LDS memory has multiple request queues shared by the SIMDs of a
CU. Therefore, the LDS operations performed by different wavefronts of a
work-group can be reordered relative to each other, which can result in
reordering the visibility of vector memory operations with respect to LDS
operations of other wavefronts in the same work-group. A <code class="docutils literal notranslate"><span class="pre">s_waitcnt</span>
<span class="pre">lgkmcnt(0)</span></code> is required to ensure synchronization between LDS operations and
vector memory operations between wavefronts of a work-group, but not between
operations performed by the same wavefront.</p></li>
<li><p>The vector memory operations are performed as wavefront wide operations and
completion is reported to a wavefront in execution order. The exception is
that for GFX7-GFX9 <code class="docutils literal notranslate"><span class="pre">flat_load/store/atomic</span></code> instructions can report out of
vector memory order if they access LDS memory, and out of LDS operation order
if they access global memory.</p></li>
<li><p>The vector memory operations access a single vector L1 cache shared by all
SIMDs a CU. Therefore, no special action is required for coherence between the
lanes of a single wavefront, or for coherence between wavefronts in the same
work-group. A <code class="docutils literal notranslate"><span class="pre">buffer_wbinvl1_vol</span></code> is required for coherence between
wavefronts executing in different work-groups as they may be executing on
different CUs.</p></li>
<li><p>The scalar memory operations access a scalar L1 cache shared by all wavefronts
on a group of CUs. The scalar and vector L1 caches are not coherent. However,
scalar operations are used in a restricted way so do not impact the memory
model. See <a class="reference internal" href="#amdgpu-amdhsa-memory-spaces"><span class="std std-ref">Memory Spaces</span></a>.</p></li>
<li><p>The vector and scalar memory operations use an L2 cache shared by all CUs on
the same agent.</p></li>
<li><p>The L2 cache has independent channels to service disjoint ranges of virtual
addresses.</p></li>
<li><p>Each CU has a separate request queue per channel. Therefore, the vector and
scalar memory operations performed by wavefronts executing in different
work-groups (which may be executing on different CUs) of an agent can be
reordered relative to each other. A <code class="docutils literal notranslate"><span class="pre">s_waitcnt</span> <span class="pre">vmcnt(0)</span></code> is required to
ensure synchronization between vector memory operations of different CUs. It
ensures a previous vector memory operation has completed before executing a
subsequent vector memory or LDS operation and so can be used to meet the
requirements of acquire and release.</p></li>
<li><p>The L2 cache can be kept coherent with other agents on some targets, or ranges
of virtual addresses can be set up to bypass it to ensure system coherence.</p></li>
</ul>
<p>Scalar memory operations are only used to access memory that is proven to not
change during the execution of the kernel dispatch. This includes constant
address space and global address space for program scope <code class="docutils literal notranslate"><span class="pre">const</span></code> variables.
Therefore, the kernel machine code does not have to maintain the scalar cache to
ensure it is coherent with the vector caches. The scalar and vector caches are
invalidated between kernel dispatches by CP since constant address space data
may change between kernel dispatch executions. See
<a class="reference internal" href="#amdgpu-amdhsa-memory-spaces"><span class="std std-ref">Memory Spaces</span></a>.</p>
<p>The one exception is if scalar writes are used to spill SGPR registers. In this
case the AMDGPU backend ensures the memory location used to spill is never
accessed by vector memory operations at the same time. If scalar writes are used
then a <code class="docutils literal notranslate"><span class="pre">s_dcache_wb</span></code> is inserted before the <code class="docutils literal notranslate"><span class="pre">s_endpgm</span></code> and before a function
return since the locations may be used for vector memory instructions by a
future wavefront that uses the same scratch area, or a function call that
creates a frame at the same address, respectively. There is no need for a
<code class="docutils literal notranslate"><span class="pre">s_dcache_inv</span></code> as all scalar writes are write-before-read in the same thread.</p>
<p>For kernarg backing memory:</p>
<ul class="simple">
<li><p>CP invalidates the L1 cache at the start of each kernel dispatch.</p></li>
<li><p>On dGPU the kernarg backing memory is allocated in host memory accessed as
MTYPE UC (uncached) to avoid needing to invalidate the L2 cache. This also
causes it to be treated as non-volatile and so is not invalidated by
<code class="docutils literal notranslate"><span class="pre">*_vol</span></code>.</p></li>
<li><p>On APU the kernarg backing memory it is accessed as MTYPE CC (cache coherent)
and so the L2 cache will be coherent with the CPU and other agents.</p></li>
</ul>
<p>Scratch backing memory (which is used for the private address space) is accessed
with MTYPE NC_NV (non-coherent non-volatile). Since the private address space is
only accessed by a single thread, and is always write-before-read, there is
never a need to invalidate these entries from the L1 cache. Hence all cache
invalidates are done as <code class="docutils literal notranslate"><span class="pre">*_vol</span></code> to only invalidate the volatile cache lines.</p>
<p>The code sequences used to implement the memory model for GFX6-GFX9 are defined
in table <a class="reference internal" href="#amdgpu-amdhsa-memory-model-code-sequences-gfx6-gfx9-table"><span class="std std-ref">AMDHSA Memory Model Code Sequences GFX6-GFX9</span></a>.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-memory-model-code-sequences-gfx6-gfx9-table">
<caption><span class="caption-text">AMDHSA Memory Model Code Sequences GFX6-GFX9</span><a class="headerlink" href="#amdgpu-amdhsa-memory-model-code-sequences-gfx6-gfx9-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 17%" />
<col style="width: 12%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>LLVM Instr</p></th>
<th class="head"><p>LLVM Memory
Ordering</p></th>
<th class="head"><p>LLVM Memory
Sync Scope</p></th>
<th class="head"><p>AMDGPU
Address
Space</p></th>
<th class="head"><p>AMDGPU Machine Code
GFX6-GFX9</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td colspan="5"><p><strong>Non-Atomic</strong></p></td>
</tr>
<tr class="row-odd"><td><p>load</p></td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
<li><p>private</p></li>
<li><p>constant</p></li>
</ul>
</td>
<td><ul>
<li><p>!volatile &amp; !nontemporal</p>
<ol class="arabic simple">
<li><p>buffer/global/flat_load</p></li>
</ol>
</li>
<li><p>!volatile &amp; nontemporal</p>
<ol class="arabic simple">
<li><p>buffer/global/flat_load
glc=1 slc=1</p></li>
</ol>
</li>
<li><p>volatile</p>
<ol class="arabic simple">
<li><p>buffer/global/flat_load
glc=1</p></li>
<li><p>s_waitcnt vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following volatile
global/generic
load/store.</p></li>
<li><p>Ensures that
volatile
operations to
different
addresses will not
be reordered by
hardware.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>load</p></td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_load</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>store</p></td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
<li><p>private</p></li>
<li><p>constant</p></li>
</ul>
</td>
<td><ul>
<li><p>!volatile &amp; !nontemporal</p>
<ol class="arabic simple">
<li><p>buffer/global/flat_store</p></li>
</ol>
</li>
<li><p>!volatile &amp; nontemporal</p>
<ol class="arabic simple">
<li><p>buffer/global/flat_store
glc=1 slc=1</p></li>
</ol>
</li>
<li><p>volatile</p>
<ol class="arabic simple">
<li><p>buffer/global/flat_store</p></li>
<li><p>s_waitcnt vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following volatile
global/generic
load/store.</p></li>
<li><p>Ensures that
volatile
operations to
different
addresses will not
be reordered by
hardware.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>store</p></td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_store</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td colspan="5"><p><strong>Unordered Atomic</strong></p></td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>unordered</p></td>
<td><p><em>any</em></p></td>
<td><p><em>any</em></p></td>
<td><p><em>Same as non-atomic</em>.</p></td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>unordered</p></td>
<td><p><em>any</em></p></td>
<td><p><em>any</em></p></td>
<td><p><em>Same as non-atomic</em>.</p></td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>unordered</p></td>
<td><p><em>any</em></p></td>
<td><p><em>any</em></p></td>
<td><p><em>Same as monotonic atomic</em>.</p></td>
</tr>
<tr class="row-odd"><td colspan="5"><p><strong>Monotonic Atomic</strong></p></td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/ds/flat_load</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_load
glc=1</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>store atomic</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_store</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_store</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td colspan="5"><p><strong>Acquire Atomic</strong></p></td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/ds/flat_load</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global_load</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds/flat_load</p></li>
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit.</p></li>
<li><p>Must happen before
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures any
following global
data read is no
older than a local load
atomic value being
acquired.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global_load
glc=1</p></li>
<li><p>s_waitcnt vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the load
has completed
before invalidating
the cache.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following
loads will not see
stale global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>flat_load glc=1</p></li>
<li><p>s_waitcnt vmcnt(0) &amp;
lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL omit
lgkmcnt(0).</p></li>
<li><p>Must happen before
following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the flat_load
has completed
before invalidating
the cache.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/ds/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds/flat_atomic</p></li>
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit.</p></li>
<li><p>Must happen before
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures any
following global
data read is no
older than a local
atomicrmw value
being acquired.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global_atomic</p></li>
<li><p>s_waitcnt vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the
atomicrmw has
completed before
invalidating the
cache.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>flat_atomic</p></li>
<li><p>s_waitcnt vmcnt(0) &amp;
lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Must happen before
following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the
atomicrmw has
completed before
invalidating the
cache.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-even"><td><p>fence</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL and
address space is
not generic, omit.</p></li>
<li><p>However, since LLVM
currently has no
address space on
the fence need to
conservatively
always generate. If
fence had an
address space then
set to address
space of OpenCL
fence flag, or to
generic if both
local and global
flags are
specified.</p></li>
<li><p>Must happen after
any preceding
local/generic load
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>Must happen before
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures any
following global
data read is no
older than the
value read by the
fence-paired-atomic.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).</p></li>
<li><p>However, since LLVM
currently has no
address space on
the fence need to
conservatively
always generate
(see comment for
previous fence).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic load
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic load
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>Must happen before
the following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures that the
fence-paired atomic
has completed
before invalidating
the
cache. Therefore
any following
locations read must
be no older than
the value read by
the
fence-paired-atomic.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before any
following global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td colspan="5"><p><strong>Release Atomic</strong></p></td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/ds/flat_store</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>store atomic</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit.</p></li>
<li><p>Must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
store.</p></li>
<li><p>Ensures that all
memory operations
to local have
completed before
performing the
store that is being
released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global/flat_store</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_store</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>store atomic</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
store.</p></li>
<li><p>Ensures that all
memory operations
to memory have
completed before
performing the
store that is being
released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global/flat_store</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/ds/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit.</p></li>
<li><p>Must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
to local have
completed before
performing the
atomicrmw that is
being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
to global and local
have completed
before performing
the atomicrmw that
is being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-even"><td><p>fence</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL and
address space is
not generic, omit.</p></li>
<li><p>However, since LLVM
currently has no
address space on
the fence need to
conservatively
always generate. If
fence had an
address space then
set to address
space of OpenCL
fence flag, or to
generic if both
local and global
flags are
specified.</p></li>
<li><p>Must happen after
any preceding
local/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
any following store
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>Ensures that all
memory operations
to local have
completed before
performing the
following
fence-paired-atomic.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).</p></li>
<li><p>If OpenCL and
address space is
local, omit
vmcnt(0).</p></li>
<li><p>However, since LLVM
currently has no
address space on
the fence need to
conservatively
always generate. If
fence had an
address space then
set to address
space of OpenCL
fence flag, or to
generic if both
local and global
flags are
specified.</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
any following store
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>Ensures that all
memory operations
have
completed before
performing the
following
fence-paired-atomic.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td colspan="5"><p><strong>Acquire-Release Atomic</strong></p></td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/ds/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit.</p></li>
<li><p>Must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
to local have
completed before
performing the
atomicrmw that is
being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_atomic</p></li>
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit.</p></li>
<li><p>Must happen before
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures any
following global
data read is no
older than the local load
atomic value being
acquired.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit.</p></li>
<li><p>Must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
to local have
completed before
performing the
atomicrmw that is
being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>flat_atomic</p></li>
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit.</p></li>
<li><p>Must happen before
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures any
following global
data read is no
older than a local load
atomic value being
acquired.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
to global have
completed before
performing the
atomicrmw that is
being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global_atomic</p></li>
<li><p>s_waitcnt vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the
atomicrmw has
completed before
invalidating the
cache.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="4">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
to global have
completed before
performing the
atomicrmw that is
being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>flat_atomic</p></li>
<li><p>s_waitcnt vmcnt(0) &amp;
lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Must happen before
following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the
atomicrmw has
completed before
invalidating the
cache.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="4">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-even"><td><p>fence</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL and
address space is
not generic, omit.</p></li>
<li><p>However,
since LLVM
currently has no
address space on
the fence need to
conservatively
always generate
(see comment for
previous fence).</p></li>
<li><p>Must happen after
any preceding
local/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
to local have
completed before
performing any
following global
memory operations.</p></li>
<li><p>Ensures that the
preceding
local/generic load
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
acquire-fence-paired-atomic)
has completed
before following
global memory
operations. This
satisfies the
requirements of
acquire.</p></li>
<li><p>Ensures that all
previous memory
operations have
completed before a
following
local/generic store
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
release-fence-paired-atomic).
This satisfies the
requirements of
release.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).</p></li>
<li><p>However, since LLVM
currently has no
address space on
the fence need to
conservatively
always generate
(see comment for
previous fence).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures that the
preceding
global/local/generic
load
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
acquire-fence-paired-atomic)
has completed
before invalidating
the cache. This
satisfies the
requirements of
acquire.</p></li>
<li><p>Ensures that all
previous memory
operations have
completed before a
following
global/local/generic
store
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
release-fence-paired-atomic).
This satisfies the
requirements of
release.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data. This
satisfies the
requirements of
acquire.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td colspan="5"><p><strong>Sequential Consistent Atomic</strong></p></td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><p><em>Same as corresponding
load atomic acquire,
except must generated
all instructions even
for OpenCL.</em></p></td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must
happen after
preceding
local/generic load
atomic/store
atomic/atomicrmw
with memory
ordering of seq_cst
and with equal or
wider sync scope.
(Note that seq_cst
fences have their
own s_waitcnt
lgkmcnt(0) and so do
not need to be
considered.)</p></li>
<li><p>Ensures any
preceding
sequential
consistent local
memory instructions
have completed
before executing
this sequentially
consistent
instruction. This
prevents reordering
a seq_cst store
followed by a
seq_cst load. (Note
that seq_cst is
stronger than
acquire/release as
the reordering of
load acquire
followed by a store
release is
prevented by the
s_waitcnt of
the release, but
there is nothing
preventing a store
release followed by
load acquire from
completing out of
order. The s_waitcnt
could be placed after
seq_store or before
the seq_load. We
choose the load to
make the s_waitcnt be
as late as possible
so that the store
may have already
completed.)</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p><em>Following
instructions same as
corresponding load
atomic acquire,
except must generated
all instructions even
for OpenCL.</em></p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><p><em>Same as corresponding
load atomic acquire,
except must generated
all instructions even
for OpenCL.</em></p></td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Could be split into
separate s_waitcnt
vmcnt(0)
and s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
preceding
global/generic load
atomic/store
atomic/atomicrmw
with memory
ordering of seq_cst
and with equal or
wider sync scope.
(Note that seq_cst
fences have their
own s_waitcnt
lgkmcnt(0) and so do
not need to be
considered.)</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
preceding
global/generic load
atomic/store
atomic/atomicrmw
with memory
ordering of seq_cst
and with equal or
wider sync scope.
(Note that seq_cst
fences have their
own s_waitcnt
vmcnt(0) and so do
not need to be
considered.)</p></li>
<li><p>Ensures any
preceding
sequential
consistent global
memory instructions
have completed
before executing
this sequentially
consistent
instruction. This
prevents reordering
a seq_cst store
followed by a
seq_cst load. (Note
that seq_cst is
stronger than
acquire/release as
the reordering of
load acquire
followed by a store
release is
prevented by the
s_waitcnt of
the release, but
there is nothing
preventing a store
release followed by
load acquire from
completing out of
order. The s_waitcnt
could be placed after
seq_store or before
the seq_load. We
choose the load to
make the s_waitcnt be
as late as possible
so that the store
may have already
completed.)</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p><em>Following
instructions same as
corresponding load
atomic acquire,
except must generated
all instructions even
for OpenCL.</em></p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><p><em>Same as corresponding
store atomic release,
except must generated
all instructions even
for OpenCL.</em></p></td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><p><em>Same as corresponding
atomicrmw acq_rel,
except must generated
all instructions even
for OpenCL.</em></p></td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><p><em>Same as corresponding
fence acq_rel,
except must generated
all instructions even
for OpenCL.</em></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="memory-model-gfx90a">
<span id="amdgpu-amdhsa-memory-model-gfx90a"></span><h5><a class="toc-backref" href="#id154">Memory Model GFX90A</a><a class="headerlink" href="#memory-model-gfx90a" title="Permalink to this headline">¶</a></h5>
<p>For GFX90A:</p>
<ul class="simple">
<li><p>Each agent has multiple shader arrays (SA).</p></li>
<li><p>Each SA has multiple compute units (CU).</p></li>
<li><p>Each CU has multiple SIMDs that execute wavefronts.</p></li>
<li><p>The wavefronts for a single work-group are executed in the same CU but may be
executed by different SIMDs. The exception is when in tgsplit execution mode
when the wavefronts may be executed by different SIMDs in different CUs.</p></li>
<li><p>Each CU has a single LDS memory shared by the wavefronts of the work-groups
executing on it. The exception is when in tgsplit execution mode when no LDS
is allocated as wavefronts of the same work-group can be in different CUs.</p></li>
<li><p>All LDS operations of a CU are performed as wavefront wide operations in a
global order and involve no caching. Completion is reported to a wavefront in
execution order.</p></li>
<li><p>The LDS memory has multiple request queues shared by the SIMDs of a
CU. Therefore, the LDS operations performed by different wavefronts of a
work-group can be reordered relative to each other, which can result in
reordering the visibility of vector memory operations with respect to LDS
operations of other wavefronts in the same work-group. A <code class="docutils literal notranslate"><span class="pre">s_waitcnt</span>
<span class="pre">lgkmcnt(0)</span></code> is required to ensure synchronization between LDS operations and
vector memory operations between wavefronts of a work-group, but not between
operations performed by the same wavefront.</p></li>
<li><p>The vector memory operations are performed as wavefront wide operations and
completion is reported to a wavefront in execution order. The exception is
that <code class="docutils literal notranslate"><span class="pre">flat_load/store/atomic</span></code> instructions can report out of vector memory
order if they access LDS memory, and out of LDS operation order if they access
global memory.</p></li>
<li><p>The vector memory operations access a single vector L1 cache shared by all
SIMDs a CU. Therefore:</p>
<ul>
<li><p>No special action is required for coherence between the lanes of a single
wavefront.</p></li>
<li><p>No special action is required for coherence between wavefronts in the same
work-group since they execute on the same CU. The exception is when in
tgsplit execution mode as wavefronts of the same work-group can be in
different CUs and so a <code class="docutils literal notranslate"><span class="pre">buffer_wbinvl1_vol</span></code> is required as described in
the following item.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">buffer_wbinvl1_vol</span></code> is required for coherence between wavefronts
executing in different work-groups as they may be executing on different
CUs.</p></li>
</ul>
</li>
<li><p>The scalar memory operations access a scalar L1 cache shared by all wavefronts
on a group of CUs. The scalar and vector L1 caches are not coherent. However,
scalar operations are used in a restricted way so do not impact the memory
model. See <a class="reference internal" href="#amdgpu-amdhsa-memory-spaces"><span class="std std-ref">Memory Spaces</span></a>.</p></li>
<li><p>The vector and scalar memory operations use an L2 cache shared by all CUs on
the same agent.</p>
<ul>
<li><p>The L2 cache has independent channels to service disjoint ranges of virtual
addresses.</p></li>
<li><p>Each CU has a separate request queue per channel. Therefore, the vector and
scalar memory operations performed by wavefronts executing in different
work-groups (which may be executing on different CUs), or the same
work-group if executing in tgsplit mode, of an agent can be reordered
relative to each other. A <code class="docutils literal notranslate"><span class="pre">s_waitcnt</span> <span class="pre">vmcnt(0)</span></code> is required to ensure
synchronization between vector memory operations of different CUs. It
ensures a previous vector memory operation has completed before executing a
subsequent vector memory or LDS operation and so can be used to meet the
requirements of acquire and release.</p></li>
<li><p>The L2 cache of one agent can be kept coherent with other agents by:
using the MTYPE RW (read-write) or MTYPE CC (cache-coherent) with the PTE
C-bit for memory local to the L2; and using the MTYPE NC (non-coherent) with
the PTE C-bit set or MTYPE UC (uncached) for memory not local to the L2.</p>
<ul>
<li><p>Any local memory cache lines will be automatically invalidated by writes
from CUs associated with other L2 caches, or writes from the CPU, due to
the cache probe caused by coherent requests. Coherent requests are caused
by GPU accesses to pages with the PTE C-bit set, by CPU accesses over
XGMI, and by PCIe requests that are configured to be coherent requests.</p></li>
<li><p>XGMI accesses from the CPU to local memory may be cached on the CPU.
Subsequent access from the GPU will automatically invalidate or writeback
the CPU cache due to the L2 probe filter and and the PTE C-bit being set.</p></li>
<li><p>Since all work-groups on the same agent share the same L2, no L2
invalidation or writeback is required for coherence.</p></li>
<li><p>To ensure coherence of local and remote memory writes of work-groups in
different agents a <code class="docutils literal notranslate"><span class="pre">buffer_wbl2</span></code> is required. It will writeback dirty L2
cache lines of MTYPE RW (used for local coarse grain memory) and MTYPE NC
()used for remote coarse grain memory). Note that MTYPE CC (used for local
fine grain memory) causes write through to DRAM, and MTYPE UC (used for
remote fine grain memory) bypasses the L2, so both will never result in
dirty L2 cache lines.</p></li>
<li><p>To ensure coherence of local and remote memory reads of work-groups in
different agents a <code class="docutils literal notranslate"><span class="pre">buffer_invl2</span></code> is required. It will invalidate L2
cache lines with MTYPE NC (used for remote coarse grain memory). Note that
MTYPE CC (used for local fine grain memory) and MTYPE RW (used for local
coarse memory) cause local reads to be invalidated by remote writes with
with the PTE C-bit so these cache lines are not invalidated. Note that
MTYPE UC (used for remote fine grain memory) bypasses the L2, so will
never result in L2 cache lines that need to be invalidated.</p></li>
</ul>
</li>
<li><p>PCIe access from the GPU to the CPU memory is kept coherent by using the
MTYPE UC (uncached) which bypasses the L2.</p></li>
</ul>
</li>
</ul>
<p>Scalar memory operations are only used to access memory that is proven to not
change during the execution of the kernel dispatch. This includes constant
address space and global address space for program scope <code class="docutils literal notranslate"><span class="pre">const</span></code> variables.
Therefore, the kernel machine code does not have to maintain the scalar cache to
ensure it is coherent with the vector caches. The scalar and vector caches are
invalidated between kernel dispatches by CP since constant address space data
may change between kernel dispatch executions. See
<a class="reference internal" href="#amdgpu-amdhsa-memory-spaces"><span class="std std-ref">Memory Spaces</span></a>.</p>
<p>The one exception is if scalar writes are used to spill SGPR registers. In this
case the AMDGPU backend ensures the memory location used to spill is never
accessed by vector memory operations at the same time. If scalar writes are used
then a <code class="docutils literal notranslate"><span class="pre">s_dcache_wb</span></code> is inserted before the <code class="docutils literal notranslate"><span class="pre">s_endpgm</span></code> and before a function
return since the locations may be used for vector memory instructions by a
future wavefront that uses the same scratch area, or a function call that
creates a frame at the same address, respectively. There is no need for a
<code class="docutils literal notranslate"><span class="pre">s_dcache_inv</span></code> as all scalar writes are write-before-read in the same thread.</p>
<p>For kernarg backing memory:</p>
<ul class="simple">
<li><p>CP invalidates the L1 cache at the start of each kernel dispatch.</p></li>
<li><p>On dGPU over XGMI or PCIe the kernarg backing memory is allocated in host
memory accessed as MTYPE UC (uncached) to avoid needing to invalidate the L2
cache. This also causes it to be treated as non-volatile and so is not
invalidated by <code class="docutils literal notranslate"><span class="pre">*_vol</span></code>.</p></li>
<li><p>On APU the kernarg backing memory is accessed as MTYPE CC (cache coherent) and
so the L2 cache will be coherent with the CPU and other agents.</p></li>
</ul>
<p>Scratch backing memory (which is used for the private address space) is accessed
with MTYPE NC_NV (non-coherent non-volatile). Since the private address space is
only accessed by a single thread, and is always write-before-read, there is
never a need to invalidate these entries from the L1 cache. Hence all cache
invalidates are done as <code class="docutils literal notranslate"><span class="pre">*_vol</span></code> to only invalidate the volatile cache lines.</p>
<p>The code sequences used to implement the memory model for GFX90A are defined
in table <a class="reference internal" href="#amdgpu-amdhsa-memory-model-code-sequences-gfx90a-table"><span class="std std-ref">AMDHSA Memory Model Code Sequences GFX90A</span></a>.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-memory-model-code-sequences-gfx90a-table">
<caption><span class="caption-text">AMDHSA Memory Model Code Sequences GFX90A</span><a class="headerlink" href="#amdgpu-amdhsa-memory-model-code-sequences-gfx90a-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 17%" />
<col style="width: 12%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>LLVM Instr</p></th>
<th class="head"><p>LLVM Memory
Ordering</p></th>
<th class="head"><p>LLVM Memory
Sync Scope</p></th>
<th class="head"><p>AMDGPU
Address
Space</p></th>
<th class="head"><p>AMDGPU Machine Code
GFX90A</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td colspan="5"><p><strong>Non-Atomic</strong></p></td>
</tr>
<tr class="row-odd"><td><p>load</p></td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
<li><p>private</p></li>
<li><p>constant</p></li>
</ul>
</td>
<td><ul>
<li><p>!volatile &amp; !nontemporal</p>
<ol class="arabic simple">
<li><p>buffer/global/flat_load</p></li>
</ol>
</li>
<li><p>!volatile &amp; nontemporal</p>
<ol class="arabic simple">
<li><p>buffer/global/flat_load
glc=1 slc=1</p></li>
</ol>
</li>
<li><p>volatile</p>
<ol class="arabic simple">
<li><p>buffer/global/flat_load
glc=1</p></li>
<li><p>s_waitcnt vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following volatile
global/generic
load/store.</p></li>
<li><p>Ensures that
volatile
operations to
different
addresses will not
be reordered by
hardware.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>load</p></td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_load</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>store</p></td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
<li><p>private</p></li>
<li><p>constant</p></li>
</ul>
</td>
<td><ul>
<li><p>!volatile &amp; !nontemporal</p>
<ol class="arabic simple">
<li><p>buffer/global/flat_store</p></li>
</ol>
</li>
<li><p>!volatile &amp; nontemporal</p>
<ol class="arabic simple">
<li><p>buffer/global/flat_store
glc=1 slc=1</p></li>
</ol>
</li>
<li><p>volatile</p>
<ol class="arabic simple">
<li><p>buffer/global/flat_store</p></li>
<li><p>s_waitcnt vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following volatile
global/generic
load/store.</p></li>
<li><p>Ensures that
volatile
operations to
different
addresses will not
be reordered by
hardware.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>store</p></td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_store</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td colspan="5"><p><strong>Unordered Atomic</strong></p></td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>unordered</p></td>
<td><p><em>any</em></p></td>
<td><p><em>any</em></p></td>
<td><p><em>Same as non-atomic</em>.</p></td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>unordered</p></td>
<td><p><em>any</em></p></td>
<td><p><em>any</em></p></td>
<td><p><em>Same as non-atomic</em>.</p></td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>unordered</p></td>
<td><p><em>any</em></p></td>
<td><p><em>any</em></p></td>
<td><p><em>Same as monotonic atomic</em>.</p></td>
</tr>
<tr class="row-odd"><td colspan="5"><p><strong>Monotonic Atomic</strong></p></td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_load</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_load
glc=1</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If not TgSplit execution
mode, omit glc=1.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><p><em>If TgSplit execution mode,
local address space cannot
be used.</em></p>
<ol class="arabic simple">
<li><p>ds_load</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_load
glc=1</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_load
glc=1</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
<li><p>agent</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_store</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>store atomic</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_store</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><p><em>If TgSplit execution mode,
local address space cannot
be used.</em></p>
<ol class="arabic simple">
<li><p>ds_store</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
<li><p>agent</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><p><em>If TgSplit execution mode,
local address space cannot
be used.</em></p>
<ol class="arabic simple">
<li><p>ds_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td colspan="5"><p><strong>Acquire Atomic</strong></p></td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/ds/flat_load</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global_load glc=1</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If not TgSplit execution
mode, omit glc=1.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>s_waitcnt vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If not TgSplit execution
mode, omit.</p></li>
<li><p>Must happen before the
following buffer_wbinvl1_vol.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If not TgSplit execution
mode, omit.</p></li>
<li><p>Must happen before
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following
loads will not see
stale data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><p><em>If TgSplit execution mode,
local address space cannot
be used.</em></p>
<ol class="arabic simple">
<li><p>ds_load</p></li>
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit.</p></li>
<li><p>Must happen before
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures any
following global
data read is no
older than the local load
atomic value being
acquired.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>flat_load glc=1</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If not TgSplit execution
mode, omit glc=1.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>s_waitcnt lgkm/vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Use lgkmcnt(0) if not
TgSplit execution mode
and vmcnt(0) if TgSplit
execution mode.</p></li>
<li><p>If OpenCL, omit lgkmcnt(0).</p></li>
<li><p>Must happen before
the following
buffer_wbinvl1_vol and any
following global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures any
following global
data read is no
older than a local load
atomic value being
acquired.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If not TgSplit execution
mode, omit.</p></li>
<li><p>Ensures that
following
loads will not see
stale data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global_load
glc=1</p></li>
<li><p>s_waitcnt vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the load
has completed
before invalidating
the cache.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following
loads will not see
stale global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_load
glc=1</p></li>
<li><p>s_waitcnt vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
following buffer_invl2 and
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the load
has completed
before invalidating
the cache.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_invl2;
buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following
loads will not see
stale L1 global data,
nor see stale L2 MTYPE
NC global data.
MTYPE RW and CC memory will
never be stale in L2 due to
the memory probes.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>flat_load glc=1</p></li>
<li><p>s_waitcnt vmcnt(0) &amp;
lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If TgSplit execution mode,
omit lgkmcnt(0).</p></li>
<li><p>If OpenCL omit
lgkmcnt(0).</p></li>
<li><p>Must happen before
following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the flat_load
has completed
before invalidating
the cache.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>flat_load glc=1</p></li>
<li><p>s_waitcnt vmcnt(0) &amp;
lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If TgSplit execution mode,
omit lgkmcnt(0).</p></li>
<li><p>If OpenCL omit
lgkmcnt(0).</p></li>
<li><p>Must happen before
following
buffer_invl2 and
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the flat_load
has completed
before invalidating
the caches.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_invl2;
buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following
loads will not see
stale L1 global data,
nor see stale L2 MTYPE
NC global data.
MTYPE RW and CC memory will
never be stale in L2 due to
the memory probes.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><p><em>If TgSplit execution mode,
local address space cannot
be used.</em></p>
<ol class="arabic simple">
<li><p>ds_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global_atomic</p></li>
<li><p>s_waitcnt vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If not TgSplit execution
mode, omit.</p></li>
<li><p>Must happen before the
following buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the atomicrmw
has completed
before invalidating
the cache.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If not TgSplit execution
mode, omit.</p></li>
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><p><em>If TgSplit execution mode,
local address space cannot
be used.</em></p>
<ol class="arabic simple">
<li><p>ds_atomic</p></li>
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit.</p></li>
<li><p>Must happen before
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures any
following global
data read is no
older than the local
atomicrmw value
being acquired.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>flat_atomic</p></li>
<li><p>s_waitcnt lgkm/vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Use lgkmcnt(0) if not
TgSplit execution mode
and vmcnt(0) if TgSplit
execution mode.</p></li>
<li><p>If OpenCL, omit lgkmcnt(0).</p></li>
<li><p>Must happen before
the following
buffer_wbinvl1_vol and
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures any
following global
data read is no
older than a local
atomicrmw value
being acquired.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If not TgSplit execution
mode, omit.</p></li>
<li><p>Ensures that
following
loads will not see
stale data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global_atomic</p></li>
<li><p>s_waitcnt vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the
atomicrmw has
completed before
invalidating the
cache.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global_atomic</p></li>
<li><p>s_waitcnt vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
following buffer_invl2 and
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the
atomicrmw has
completed before
invalidating the
caches.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_invl2;
buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following
loads will not see
stale L1 global data,
nor see stale L2 MTYPE
NC global data.
MTYPE RW and CC memory will
never be stale in L2 due to
the memory probes.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>flat_atomic</p></li>
<li><p>s_waitcnt vmcnt(0) &amp;
lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If TgSplit execution mode,
omit lgkmcnt(0).</p></li>
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Must happen before
following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the
atomicrmw has
completed before
invalidating the
cache.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>flat_atomic</p></li>
<li><p>s_waitcnt vmcnt(0) &amp;
lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If TgSplit execution mode,
omit lgkmcnt(0).</p></li>
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Must happen before
following
buffer_invl2 and
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the
atomicrmw has
completed before
invalidating the
caches.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_invl2;
buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following
loads will not see
stale L1 global data,
nor see stale L2 MTYPE
NC global data.
MTYPE RW and CC memory will
never be stale in L2 due to
the memory probes.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-even"><td><p>fence</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkm/vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Use lgkmcnt(0) if not
TgSplit execution mode
and vmcnt(0) if TgSplit
execution mode.</p></li>
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).</p></li>
<li><p>If OpenCL and
address space is
local, omit
vmcnt(0).</p></li>
<li><p>However, since LLVM
currently has no
address space on
the fence need to
conservatively
always generate. If
fence had an
address space then
set to address
space of OpenCL
fence flag, or to
generic if both
local and global
flags are
specified.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic load
atomic/
atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic load
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>Must happen before
the following
buffer_wbinvl1_vol and
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures any
following global
data read is no
older than the
value read by the
fence-paired-atomic.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If not TgSplit execution
mode, omit.</p></li>
<li><p>Ensures that
following
loads will not see
stale data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If TgSplit execution mode,
omit lgkmcnt(0).</p></li>
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).</p></li>
<li><p>However, since LLVM
currently has no
address space on
the fence need to
conservatively
always generate
(see comment for
previous fence).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic load
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic load
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>Must happen before
the following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures that the
fence-paired atomic
has completed
before invalidating
the
cache. Therefore
any following
locations read must
be no older than
the value read by
the
fence-paired-atomic.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before any
following global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>fence</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>system</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If TgSplit execution mode,
omit lgkmcnt(0).</p></li>
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).</p></li>
<li><p>However, since LLVM
currently has no
address space on
the fence need to
conservatively
always generate
(see comment for
previous fence).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic load
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic load
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>Must happen before
the following buffer_invl2 and
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures that the
fence-paired atomic
has completed
before invalidating
the
cache. Therefore
any following
locations read must
be no older than
the value read by
the
fence-paired-atomic.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer_invl2;
buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before any
following global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following
loads will not see
stale L1 global data,
nor see stale L2 MTYPE
NC global data.
MTYPE RW and CC memory will
never be stale in L2 due to
the memory probes.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td colspan="5"><p><strong>Release Atomic</strong></p></td>
</tr>
<tr class="row-even"><td><p>store atomic</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_store</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><p><em>If TgSplit execution mode,
local address space cannot
be used.</em></p>
<ol class="arabic simple">
<li><p>ds_store</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>store atomic</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkm/vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Use lgkmcnt(0) if not
TgSplit execution mode
and vmcnt(0) if TgSplit
execution mode.</p></li>
<li><p>If OpenCL, omit lgkmcnt(0).</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic load/store/
load atomic/store atomic/
atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
store.</p></li>
<li><p>Ensures that all
memory operations
have
completed before
performing the
store that is being
released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global/flat_store</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><p><em>If TgSplit execution mode,
local address space cannot
be used.</em></p>
<ol class="arabic simple">
<li><p>ds_store</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>store atomic</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If TgSplit execution mode,
omit lgkmcnt(0).</p></li>
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
store.</p></li>
<li><p>Ensures that all
memory operations
to memory have
completed before
performing the
store that is being
released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global/flat_store</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer_wbl2</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
following s_waitcnt.</p></li>
<li><p>Performs L2 writeback to
ensure previous
global/generic
store/atomicrmw are
visible at system scope.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If TgSplit execution mode,
omit lgkmcnt(0).</p></li>
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after any
preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after any
preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
store.</p></li>
<li><p>Ensures that all
memory operations
to memory and the L2
writeback have
completed before
performing the
store that is being
released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer/global/flat_store</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><p><em>If TgSplit execution mode,
local address space cannot
be used.</em></p>
<ol class="arabic simple">
<li><p>ds_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkm/vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Use lgkmcnt(0) if not
TgSplit execution mode
and vmcnt(0) if TgSplit
execution mode.</p></li>
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic load/store/
load atomic/store atomic/
atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
have
completed before
performing the
atomicrmw that is
being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><p><em>If TgSplit execution mode,
local address space cannot
be used.</em></p>
<ol class="arabic simple">
<li><p>ds_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If TgSplit execution mode,
omit lgkmcnt(0).</p></li>
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
to global and local
have completed
before performing
the atomicrmw that
is being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer_wbl2</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
following s_waitcnt.</p></li>
<li><p>Performs L2 writeback to
ensure previous
global/generic
store/atomicrmw are
visible at system scope.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If TgSplit execution mode,
omit lgkmcnt(0).</p></li>
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
to memory and the L2
writeback have
completed before
performing the
store that is being
released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer/global/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>fence</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkm/vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Use lgkmcnt(0) if not
TgSplit execution mode
and vmcnt(0) if TgSplit
execution mode.</p></li>
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).</p></li>
<li><p>If OpenCL and
address space is
local, omit
vmcnt(0).</p></li>
<li><p>However, since LLVM
currently has no
address space on
the fence need to
conservatively
always generate. If
fence had an
address space then
set to address
space of OpenCL
fence flag, or to
generic if both
local and global
flags are
specified.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/
load atomic/store atomic/
atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
any following store
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>Ensures that all
memory operations
have
completed before
performing the
following
fence-paired-atomic.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>fence</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If TgSplit execution mode,
omit lgkmcnt(0).</p></li>
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).</p></li>
<li><p>If OpenCL and
address space is
local, omit
vmcnt(0).</p></li>
<li><p>However, since LLVM
currently has no
address space on
the fence need to
conservatively
always generate. If
fence had an
address space then
set to address
space of OpenCL
fence flag, or to
generic if both
local and global
flags are
specified.</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
any following store
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>Ensures that all
memory operations
have
completed before
performing the
following
fence-paired-atomic.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>system</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>buffer_wbl2</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL and
address space is
local, omit.</p></li>
<li><p>Must happen before
following s_waitcnt.</p></li>
<li><p>Performs L2 writeback to
ensure previous
global/generic
store/atomicrmw are
visible at system scope.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If TgSplit execution mode,
omit lgkmcnt(0).</p></li>
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).</p></li>
<li><p>If OpenCL and
address space is
local, omit
vmcnt(0).</p></li>
<li><p>However, since LLVM
currently has no
address space on
the fence need to
conservatively
always generate. If
fence had an
address space then
set to address
space of OpenCL
fence flag, or to
generic if both
local and global
flags are
specified.</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
any following store
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>Ensures that all
memory operations
have
completed before
performing the
following
fence-paired-atomic.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td colspan="5"><p><strong>Acquire-Release Atomic</strong></p></td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><p><em>If TgSplit execution mode,
local address space cannot
be used.</em></p>
<ol class="arabic simple">
<li><p>ds_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkm/vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Use lgkmcnt(0) if not
TgSplit execution mode
and vmcnt(0) if TgSplit
execution mode.</p></li>
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic load/store/
load atomic/store atomic/
atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
have
completed before
performing the
atomicrmw that is
being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global_atomic</p></li>
<li><p>s_waitcnt vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If not TgSplit execution
mode, omit.</p></li>
<li><p>Must happen before
the following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures any
following global
data read is no
older than the
atomicrmw value
being acquired.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="4">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If not TgSplit execution
mode, omit.</p></li>
<li><p>Ensures that
following
loads will not see
stale data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><p><em>If TgSplit execution mode,
local address space cannot
be used.</em></p>
<ol class="arabic simple">
<li><p>ds_atomic</p></li>
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit.</p></li>
<li><p>Must happen before
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures any
following global
data read is no
older than the local load
atomic value being
acquired.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkm/vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Use lgkmcnt(0) if not
TgSplit execution mode
and vmcnt(0) if TgSplit
execution mode.</p></li>
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic load/store/
load atomic/store atomic/
atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
have
completed before
performing the
atomicrmw that is
being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>flat_atomic</p></li>
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If not TgSplit execution
mode, omit vmcnt(0).</p></li>
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Must happen before
the following
buffer_wbinvl1_vol and
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures any
following global
data read is no
older than a local load
atomic value being
acquired.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If not TgSplit execution
mode, omit.</p></li>
<li><p>Ensures that
following
loads will not see
stale data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If TgSplit execution mode,
omit lgkmcnt(0).</p></li>
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
to global have
completed before
performing the
atomicrmw that is
being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global_atomic</p></li>
<li><p>s_waitcnt vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the
atomicrmw has
completed before
invalidating the
cache.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="4">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer_wbl2</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
following s_waitcnt.</p></li>
<li><p>Performs L2 writeback to
ensure previous
global/generic
store/atomicrmw are
visible at system scope.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If TgSplit execution mode,
omit lgkmcnt(0).</p></li>
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
to global and L2 writeback
have completed before
performing the
atomicrmw that is
being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer/global_atomic</p></li>
<li><p>s_waitcnt vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
following buffer_invl2 and
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the
atomicrmw has
completed before
invalidating the
caches.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="5">
<li><p>buffer_invl2;
buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following
loads will not see
stale L1 global data,
nor see stale L2 MTYPE
NC global data.
MTYPE RW and CC memory will
never be stale in L2 due to
the memory probes.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If TgSplit execution mode,
omit lgkmcnt(0).</p></li>
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
to global have
completed before
performing the
atomicrmw that is
being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>flat_atomic</p></li>
<li><p>s_waitcnt vmcnt(0) &amp;
lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If TgSplit execution mode,
omit lgkmcnt(0).</p></li>
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Must happen before
following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the
atomicrmw has
completed before
invalidating the
cache.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="4">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer_wbl2</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
following s_waitcnt.</p></li>
<li><p>Performs L2 writeback to
ensure previous
global/generic
store/atomicrmw are
visible at system scope.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If TgSplit execution mode,
omit lgkmcnt(0).</p></li>
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
to global and L2 writeback
have completed before
performing the
atomicrmw that is
being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>flat_atomic</p></li>
<li><p>s_waitcnt vmcnt(0) &amp;
lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If TgSplit execution mode,
omit lgkmcnt(0).</p></li>
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Must happen before
following buffer_invl2 and
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures the
atomicrmw has
completed before
invalidating the
caches.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="5">
<li><p>buffer_invl2;
buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following
loads will not see
stale L1 global data,
nor see stale L2 MTYPE
NC global data.
MTYPE RW and CC memory will
never be stale in L2 due to
the memory probes.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>fence</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkm/vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Use lgkmcnt(0) if not
TgSplit execution mode
and vmcnt(0) if TgSplit
execution mode.</p></li>
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).</p></li>
<li><p>If OpenCL and
address space is
local, omit
vmcnt(0).</p></li>
<li><p>However,
since LLVM
currently has no
address space on
the fence need to
conservatively
always generate
(see comment for
previous fence).</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/
load atomic/store atomic/
atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
have
completed before
performing any
following global
memory operations.</p></li>
<li><p>Ensures that the
preceding
local/generic load
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
acquire-fence-paired-atomic)
has completed
before following
global memory
operations. This
satisfies the
requirements of
acquire.</p></li>
<li><p>Ensures that all
previous memory
operations have
completed before a
following
local/generic store
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
release-fence-paired-atomic).
This satisfies the
requirements of
release.</p></li>
<li><p>Must happen before
the following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures that the
acquire-fence-paired
atomic has completed
before invalidating
the
cache. Therefore
any following
locations read must
be no older than
the value read by
the
acquire-fence-paired-atomic.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If not TgSplit execution
mode, omit.</p></li>
<li><p>Ensures that
following
loads will not see
stale data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>fence</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If TgSplit execution mode,
omit lgkmcnt(0).</p></li>
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).</p></li>
<li><p>However, since LLVM
currently has no
address space on
the fence need to
conservatively
always generate
(see comment for
previous fence).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures that the
preceding
global/local/generic
load
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
acquire-fence-paired-atomic)
has completed
before invalidating
the cache. This
satisfies the
requirements of
acquire.</p></li>
<li><p>Ensures that all
previous memory
operations have
completed before a
following
global/local/generic
store
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
release-fence-paired-atomic).
This satisfies the
requirements of
release.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data. This
satisfies the
requirements of
acquire.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>system</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>buffer_wbl2</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL and
address space is
local, omit.</p></li>
<li><p>Must happen before
following s_waitcnt.</p></li>
<li><p>Performs L2 writeback to
ensure previous
global/generic
store/atomicrmw are
visible at system scope.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If TgSplit execution mode,
omit lgkmcnt(0).</p></li>
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).</p></li>
<li><p>However, since LLVM
currently has no
address space on
the fence need to
conservatively
always generate
(see comment for
previous fence).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and
s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following buffer_invl2 and
buffer_wbinvl1_vol.</p></li>
<li><p>Ensures that the
preceding
global/local/generic
load
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
acquire-fence-paired-atomic)
has completed
before invalidating
the cache. This
satisfies the
requirements of
acquire.</p></li>
<li><p>Ensures that all
previous memory
operations have
completed before a
following
global/local/generic
store
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
release-fence-paired-atomic).
This satisfies the
requirements of
release.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_invl2;
buffer_wbinvl1_vol</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following
loads will not see
stale L1 global data,
nor see stale L2 MTYPE
NC global data.
MTYPE RW and CC memory will
never be stale in L2 due to
the memory probes.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td colspan="5"><p><strong>Sequential Consistent Atomic</strong></p></td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><p><em>Same as corresponding
load atomic acquire,
except must generated
all instructions even
for OpenCL.</em></p></td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkm/vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Use lgkmcnt(0) if not
TgSplit execution mode
and vmcnt(0) if TgSplit
execution mode.</p></li>
<li><p>s_waitcnt lgkmcnt(0) must
happen after
preceding
local/generic load
atomic/store
atomic/atomicrmw
with memory
ordering of seq_cst
and with equal or
wider sync scope.
(Note that seq_cst
fences have their
own s_waitcnt
lgkmcnt(0) and so do
not need to be
considered.)</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
preceding
global/generic load
atomic/store
atomic/atomicrmw
with memory
ordering of seq_cst
and with equal or
wider sync scope.
(Note that seq_cst
fences have their
own s_waitcnt
vmcnt(0) and so do
not need to be
considered.)</p></li>
<li><p>Ensures any
preceding
sequential
consistent global/local
memory instructions
have completed
before executing
this sequentially
consistent
instruction. This
prevents reordering
a seq_cst store
followed by a
seq_cst load. (Note
that seq_cst is
stronger than
acquire/release as
the reordering of
load acquire
followed by a store
release is
prevented by the
s_waitcnt of
the release, but
there is nothing
preventing a store
release followed by
load acquire from
completing out of
order. The s_waitcnt
could be placed after
seq_store or before
the seq_load. We
choose the load to
make the s_waitcnt be
as late as possible
so that the store
may have already
completed.)</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p><em>Following
instructions same as
corresponding load
atomic acquire,
except must generated
all instructions even
for OpenCL.</em></p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><p><em>If TgSplit execution mode,
local address space cannot
be used.</em></p>
<p><em>Same as corresponding
load atomic acquire,
except must generated
all instructions even
for OpenCL.</em></p>
</td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If TgSplit execution mode,
omit lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0)
and s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
preceding
global/generic load
atomic/store
atomic/atomicrmw
with memory
ordering of seq_cst
and with equal or
wider sync scope.
(Note that seq_cst
fences have their
own s_waitcnt
lgkmcnt(0) and so do
not need to be
considered.)</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
preceding
global/generic load
atomic/store
atomic/atomicrmw
with memory
ordering of seq_cst
and with equal or
wider sync scope.
(Note that seq_cst
fences have their
own s_waitcnt
vmcnt(0) and so do
not need to be
considered.)</p></li>
<li><p>Ensures any
preceding
sequential
consistent global
memory instructions
have completed
before executing
this sequentially
consistent
instruction. This
prevents reordering
a seq_cst store
followed by a
seq_cst load. (Note
that seq_cst is
stronger than
acquire/release as
the reordering of
load acquire
followed by a store
release is
prevented by the
s_waitcnt of
the release, but
there is nothing
preventing a store
release followed by
load acquire from
completing out of
order. The s_waitcnt
could be placed after
seq_store or before
the seq_load. We
choose the load to
make the s_waitcnt be
as late as possible
so that the store
may have already
completed.)</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p><em>Following
instructions same as
corresponding load
atomic acquire,
except must generated
all instructions even
for OpenCL.</em></p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><p><em>Same as corresponding
store atomic release,
except must generated
all instructions even
for OpenCL.</em></p></td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><p><em>Same as corresponding
atomicrmw acq_rel,
except must generated
all instructions even
for OpenCL.</em></p></td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><p><em>Same as corresponding
fence acq_rel,
except must generated
all instructions even
for OpenCL.</em></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="memory-model-gfx10">
<span id="amdgpu-amdhsa-memory-model-gfx10"></span><h5><a class="toc-backref" href="#id155">Memory Model GFX10</a><a class="headerlink" href="#memory-model-gfx10" title="Permalink to this headline">¶</a></h5>
<p>For GFX10:</p>
<ul class="simple">
<li><p>Each agent has multiple shader arrays (SA).</p></li>
<li><p>Each SA has multiple work-group processors (WGP).</p></li>
<li><p>Each WGP has multiple compute units (CU).</p></li>
<li><p>Each CU has multiple SIMDs that execute wavefronts.</p></li>
<li><p>The wavefronts for a single work-group are executed in the same
WGP. In CU wavefront execution mode the wavefronts may be executed by
different SIMDs in the same CU. In WGP wavefront execution mode the
wavefronts may be executed by different SIMDs in different CUs in the same
WGP.</p></li>
<li><p>Each WGP has a single LDS memory shared by the wavefronts of the work-groups
executing on it.</p></li>
<li><p>All LDS operations of a WGP are performed as wavefront wide operations in a
global order and involve no caching. Completion is reported to a wavefront in
execution order.</p></li>
<li><p>The LDS memory has multiple request queues shared by the SIMDs of a
WGP. Therefore, the LDS operations performed by different wavefronts of a
work-group can be reordered relative to each other, which can result in
reordering the visibility of vector memory operations with respect to LDS
operations of other wavefronts in the same work-group. A <code class="docutils literal notranslate"><span class="pre">s_waitcnt</span>
<span class="pre">lgkmcnt(0)</span></code> is required to ensure synchronization between LDS operations and
vector memory operations between wavefronts of a work-group, but not between
operations performed by the same wavefront.</p></li>
<li><p>The vector memory operations are performed as wavefront wide operations.
Completion of load/store/sample operations are reported to a wavefront in
execution order of other load/store/sample operations performed by that
wavefront.</p></li>
<li><p>The vector memory operations access a vector L0 cache. There is a single L0
cache per CU. Each SIMD of a CU accesses the same L0 cache. Therefore, no
special action is required for coherence between the lanes of a single
wavefront. However, a <code class="docutils literal notranslate"><span class="pre">buffer_gl0_inv</span></code> is required for coherence between
wavefronts executing in the same work-group as they may be executing on SIMDs
of different CUs that access different L0s. A <code class="docutils literal notranslate"><span class="pre">buffer_gl0_inv</span></code> is also
required for coherence between wavefronts executing in different work-groups
as they may be executing on different WGPs.</p></li>
<li><p>The scalar memory operations access a scalar L0 cache shared by all wavefronts
on a WGP. The scalar and vector L0 caches are not coherent. However, scalar
operations are used in a restricted way so do not impact the memory model. See
<a class="reference internal" href="#amdgpu-amdhsa-memory-spaces"><span class="std std-ref">Memory Spaces</span></a>.</p></li>
<li><p>The vector and scalar memory L0 caches use an L1 cache shared by all WGPs on
the same SA. Therefore, no special action is required for coherence between
the wavefronts of a single work-group. However, a <code class="docutils literal notranslate"><span class="pre">buffer_gl1_inv</span></code> is
required for coherence between wavefronts executing in different work-groups
as they may be executing on different SAs that access different L1s.</p></li>
<li><p>The L1 caches have independent quadrants to service disjoint ranges of virtual
addresses.</p></li>
<li><p>Each L0 cache has a separate request queue per L1 quadrant. Therefore, the
vector and scalar memory operations performed by different wavefronts, whether
executing in the same or different work-groups (which may be executing on
different CUs accessing different L0s), can be reordered relative to each
other. A <code class="docutils literal notranslate"><span class="pre">s_waitcnt</span> <span class="pre">vmcnt(0)</span> <span class="pre">&amp;</span> <span class="pre">vscnt(0)</span></code> is required to ensure
synchronization between vector memory operations of different wavefronts. It
ensures a previous vector memory operation has completed before executing a
subsequent vector memory or LDS operation and so can be used to meet the
requirements of acquire, release and sequential consistency.</p></li>
<li><p>The L1 caches use an L2 cache shared by all SAs on the same agent.</p></li>
<li><p>The L2 cache has independent channels to service disjoint ranges of virtual
addresses.</p></li>
<li><p>Each L1 quadrant of a single SA accesses a different L2 channel. Each L1
quadrant has a separate request queue per L2 channel. Therefore, the vector
and scalar memory operations performed by wavefronts executing in different
work-groups (which may be executing on different SAs) of an agent can be
reordered relative to each other. A <code class="docutils literal notranslate"><span class="pre">s_waitcnt</span> <span class="pre">vmcnt(0)</span> <span class="pre">&amp;</span> <span class="pre">vscnt(0)</span></code> is
required to ensure synchronization between vector memory operations of
different SAs. It ensures a previous vector memory operation has completed
before executing a subsequent vector memory and so can be used to meet the
requirements of acquire, release and sequential consistency.</p></li>
<li><p>The L2 cache can be kept coherent with other agents on some targets, or ranges
of virtual addresses can be set up to bypass it to ensure system coherence.</p></li>
</ul>
<p>Scalar memory operations are only used to access memory that is proven to not
change during the execution of the kernel dispatch. This includes constant
address space and global address space for program scope <code class="docutils literal notranslate"><span class="pre">const</span></code> variables.
Therefore, the kernel machine code does not have to maintain the scalar cache to
ensure it is coherent with the vector caches. The scalar and vector caches are
invalidated between kernel dispatches by CP since constant address space data
may change between kernel dispatch executions. See
<a class="reference internal" href="#amdgpu-amdhsa-memory-spaces"><span class="std std-ref">Memory Spaces</span></a>.</p>
<p>The one exception is if scalar writes are used to spill SGPR registers. In this
case the AMDGPU backend ensures the memory location used to spill is never
accessed by vector memory operations at the same time. If scalar writes are used
then a <code class="docutils literal notranslate"><span class="pre">s_dcache_wb</span></code> is inserted before the <code class="docutils literal notranslate"><span class="pre">s_endpgm</span></code> and before a function
return since the locations may be used for vector memory instructions by a
future wavefront that uses the same scratch area, or a function call that
creates a frame at the same address, respectively. There is no need for a
<code class="docutils literal notranslate"><span class="pre">s_dcache_inv</span></code> as all scalar writes are write-before-read in the same thread.</p>
<p>For kernarg backing memory:</p>
<ul class="simple">
<li><p>CP invalidates the L0 and L1 caches at the start of each kernel dispatch.</p></li>
<li><p>On dGPU the kernarg backing memory is accessed as MTYPE UC (uncached) to avoid
needing to invalidate the L2 cache.</p></li>
<li><p>On APU the kernarg backing memory is accessed as MTYPE CC (cache coherent) and
so the L2 cache will be coherent with the CPU and other agents.</p></li>
</ul>
<p>Scratch backing memory (which is used for the private address space) is accessed
with MTYPE NC (non-coherent). Since the private address space is only accessed
by a single thread, and is always write-before-read, there is never a need to
invalidate these entries from the L0 or L1 caches.</p>
<p>Wavefronts are executed in native mode with in-order reporting of loads and
sample instructions. In this mode vmcnt reports completion of load, atomic with
return and sample instructions in order, and the vscnt reports the completion of
store and atomic without return in order. See <code class="docutils literal notranslate"><span class="pre">MEM_ORDERED</span></code> field in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc1-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc1 for GFX6-GFX10</span></a>.</p>
<p>Wavefronts can be executed in WGP or CU wavefront execution mode:</p>
<ul class="simple">
<li><p>In WGP wavefront execution mode the wavefronts of a work-group are executed
on the SIMDs of both CUs of the WGP. Therefore, explicit management of the per
CU L0 caches is required for work-group synchronization. Also accesses to L1
at work-group scope need to be explicitly ordered as the accesses from
different CUs are not ordered.</p></li>
<li><p>In CU wavefront execution mode the wavefronts of a work-group are executed on
the SIMDs of a single CU of the WGP. Therefore, all global memory access by
the work-group access the same L0 which in turn ensures L1 accesses are
ordered and so do not require explicit management of the caches for
work-group synchronization.</p></li>
</ul>
<p>See <code class="docutils literal notranslate"><span class="pre">WGP_MODE</span></code> field in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc1-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc1 for GFX6-GFX10</span></a> and
<a class="reference internal" href="#amdgpu-target-features"><span class="std std-ref">Target Features</span></a>.</p>
<p>The code sequences used to implement the memory model for GFX10 are defined in
table <a class="reference internal" href="#amdgpu-amdhsa-memory-model-code-sequences-gfx10-table"><span class="std std-ref">AMDHSA Memory Model Code Sequences GFX10</span></a>.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdhsa-memory-model-code-sequences-gfx10-table">
<caption><span class="caption-text">AMDHSA Memory Model Code Sequences GFX10</span><a class="headerlink" href="#amdgpu-amdhsa-memory-model-code-sequences-gfx10-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 17%" />
<col style="width: 12%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>LLVM Instr</p></th>
<th class="head"><p>LLVM Memory
Ordering</p></th>
<th class="head"><p>LLVM Memory
Sync Scope</p></th>
<th class="head"><p>AMDGPU
Address
Space</p></th>
<th class="head"><p>AMDGPU Machine Code
GFX10</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td colspan="5"><p><strong>Non-Atomic</strong></p></td>
</tr>
<tr class="row-odd"><td><p>load</p></td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
<li><p>private</p></li>
<li><p>constant</p></li>
</ul>
</td>
<td><ul>
<li><p>!volatile &amp; !nontemporal</p>
<ol class="arabic simple">
<li><p>buffer/global/flat_load</p></li>
</ol>
</li>
<li><p>!volatile &amp; nontemporal</p>
<ol class="arabic simple">
<li><p>buffer/global/flat_load
slc=1</p></li>
</ol>
</li>
<li><p>volatile</p>
<ol class="arabic simple">
<li><p>buffer/global/flat_load
glc=1 dlc=1</p></li>
<li><p>s_waitcnt vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following volatile
global/generic
load/store.</p></li>
<li><p>Ensures that
volatile
operations to
different
addresses will not
be reordered by
hardware.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>load</p></td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_load</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>store</p></td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
<li><p>private</p></li>
<li><p>constant</p></li>
</ul>
</td>
<td><ul>
<li><p>!volatile &amp; !nontemporal</p>
<ol class="arabic simple">
<li><p>buffer/global/flat_store</p></li>
</ol>
</li>
<li><p>!volatile &amp; nontemporal</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>buffer/global/flat_store
slc=1</p></li>
</ol>
</div></blockquote>
</li>
<li><p>volatile</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>buffer/global/flat_store</p></li>
<li><p>s_waitcnt vscnt(0)</p></li>
</ol>
<ul class="simple">
<li><p>Must happen before
any following volatile
global/generic
load/store.</p></li>
<li><p>Ensures that
volatile
operations to
different
addresses will not
be reordered by
hardware.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>store</p></td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_store</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td colspan="5"><p><strong>Unordered Atomic</strong></p></td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>unordered</p></td>
<td><p><em>any</em></p></td>
<td><p><em>any</em></p></td>
<td><p><em>Same as non-atomic</em>.</p></td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>unordered</p></td>
<td><p><em>any</em></p></td>
<td><p><em>any</em></p></td>
<td><p><em>Same as non-atomic</em>.</p></td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>unordered</p></td>
<td><p><em>any</em></p></td>
<td><p><em>any</em></p></td>
<td><p><em>Same as monotonic atomic</em>.</p></td>
</tr>
<tr class="row-odd"><td colspan="5"><p><strong>Monotonic Atomic</strong></p></td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_load</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_load
glc=1</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit glc=1.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_load</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_load
glc=1 dlc=1</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>store atomic</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_store</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_store</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>monotonic</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td colspan="5"><p><strong>Acquire Atomic</strong></p></td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/ds/flat_load</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global_load glc=1</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit glc=1.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>s_waitcnt vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit.</p></li>
<li><p>Must happen before
the following buffer_gl0_inv
and before any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_gl0_inv</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit.</p></li>
<li><p>Ensures that
following
loads will not see
stale data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_load</p></li>
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit.</p></li>
<li><p>Must happen before
the following buffer_gl0_inv
and before any following
global/generic load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures any
following global
data read is no
older than the local load
atomic value being
acquired.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_gl0_inv</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit.</p></li>
<li><p>If OpenCL, omit.</p></li>
<li><p>Ensures that
following
loads will not see
stale data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>flat_load glc=1</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit glc=1.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit vmcnt(0).</p></li>
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Must happen before
the following
buffer_gl0_inv and any
following global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures any
following global
data read is no
older than a local load
atomic value being
acquired.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_gl0_inv</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit.</p></li>
<li><p>Ensures that
following
loads will not see
stale data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global_load
glc=1 dlc=1</p></li>
<li><p>s_waitcnt vmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
following
buffer_gl*_inv.</p></li>
<li><p>Ensures the load
has completed
before invalidating
the caches.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_gl0_inv;
buffer_gl1_inv</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following
loads will not see
stale global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>flat_load glc=1 dlc=1</p></li>
<li><p>s_waitcnt vmcnt(0) &amp;
lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL omit
lgkmcnt(0).</p></li>
<li><p>Must happen before
following
buffer_gl*_invl.</p></li>
<li><p>Ensures the flat_load
has completed
before invalidating
the caches.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_gl0_inv;
buffer_gl1_inv</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/ds/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global_atomic</p></li>
<li><p>s_waitcnt vm/vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit.</p></li>
<li><p>Use vmcnt(0) if atomic with
return and vscnt(0) if
atomic with no-return.</p></li>
<li><p>Must happen before
the following buffer_gl0_inv
and before any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_gl0_inv</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit.</p></li>
<li><p>Ensures that
following
loads will not see
stale data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>ds_atomic</p></li>
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit.</p></li>
<li><p>Must happen before
the following
buffer_gl0_inv.</p></li>
<li><p>Ensures any
following global
data read is no
older than the local
atomicrmw value
being acquired.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_gl0_inv</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL omit.</p></li>
<li><p>Ensures that
following
loads will not see
stale data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>flat_atomic</p></li>
<li><p>s_waitcnt lgkmcnt(0) &amp;
vm/vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit vm/vscnt(0).</p></li>
<li><p>If OpenCL, omit lgkmcnt(0).</p></li>
<li><p>Use vmcnt(0) if atomic with
return and vscnt(0) if
atomic with no-return.</p></li>
<li><p>Must happen before
the following
buffer_gl0_inv.</p></li>
<li><p>Ensures any
following global
data read is no
older than a local
atomicrmw value
being acquired.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_gl0_inv</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit.</p></li>
<li><p>Ensures that
following
loads will not see
stale data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global_atomic</p></li>
<li><p>s_waitcnt vm/vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Use vmcnt(0) if atomic with
return and vscnt(0) if
atomic with no-return.</p></li>
<li><p>Must happen before
following
buffer_gl*_inv.</p></li>
<li><p>Ensures the
atomicrmw has
completed before
invalidating the
caches.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_gl0_inv;
buffer_gl1_inv</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>flat_atomic</p></li>
<li><p>s_waitcnt vm/vscnt(0) &amp;
lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Use vmcnt(0) if atomic with
return and vscnt(0) if
atomic with no-return.</p></li>
<li><p>Must happen before
following
buffer_gl*_inv.</p></li>
<li><p>Ensures the
atomicrmw has
completed before
invalidating the
caches.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_gl0_inv;
buffer_gl1_inv</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-even"><td><p>fence</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0) &amp; vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit vmcnt(0) and
vscnt(0).</p></li>
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).</p></li>
<li><p>If OpenCL and
address space is
local, omit
vmcnt(0) and vscnt(0).</p></li>
<li><p>However, since LLVM
currently has no
address space on
the fence need to
conservatively
always generate. If
fence had an
address space then
set to address
space of OpenCL
fence flag, or to
generic if both
local and global
flags are
specified.</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0), s_waitcnt
vscnt(0) and s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic load
atomic/
atomicrmw-with-return-value
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>s_waitcnt vscnt(0)
must happen after
any preceding
global/generic
atomicrmw-no-return-value
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic load
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>Must happen before
the following
buffer_gl0_inv.</p></li>
<li><p>Ensures that the
fence-paired atomic
has completed
before invalidating
the
cache. Therefore
any following
locations read must
be no older than
the value read by
the
fence-paired-atomic.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_gl0_inv</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit.</p></li>
<li><p>Ensures that
following
loads will not see
stale data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>acquire</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0) &amp; vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).</p></li>
<li><p>If OpenCL and
address space is
local, omit
vmcnt(0) and vscnt(0).</p></li>
<li><p>However, since LLVM
currently has no
address space on
the fence need to
conservatively
always generate
(see comment for
previous fence).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0), s_waitcnt
vscnt(0) and s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic load
atomic/
atomicrmw-with-return-value
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>s_waitcnt vscnt(0)
must happen after
any preceding
global/generic
atomicrmw-no-return-value
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic load
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>Must happen before
the following
buffer_gl*_inv.</p></li>
<li><p>Ensures that the
fence-paired atomic
has completed
before invalidating
the
caches. Therefore
any following
locations read must
be no older than
the value read by
the
fence-paired-atomic.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer_gl0_inv;
buffer_gl1_inv</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before any
following global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td colspan="5"><p><strong>Release Atomic</strong></p></td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/ds/flat_store</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>store atomic</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0) &amp; vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit vmcnt(0) and
vscnt(0).</p></li>
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0), s_waitcnt
vscnt(0) and s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic load/load
atomic/
atomicrmw-with-return-value.</p></li>
<li><p>s_waitcnt vscnt(0)
must happen after
any preceding
global/generic
store/store
atomic/
atomicrmw-no-return-value.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
store.</p></li>
<li><p>Ensures that all
memory operations
have
completed before
performing the
store that is being
released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global/flat_store</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt vmcnt(0) &amp; vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit.</p></li>
<li><p>If OpenCL, omit.</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and s_waitcnt
vscnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic load/load
atomic/
atomicrmw-with-return-value.</p></li>
<li><p>s_waitcnt vscnt(0)
must happen after
any preceding
global/generic
store/store atomic/
atomicrmw-no-return-value.</p></li>
<li><p>Must happen before
the following
store.</p></li>
<li><p>Ensures that all
global memory
operations have
completed before
performing the
store that is being
released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>ds_store</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>store atomic</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0) &amp; vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0), s_waitcnt vscnt(0)
and s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/load
atomic/
atomicrmw-with-return-value.</p></li>
<li><p>s_waitcnt vscnt(0)
must happen after
any preceding
global/generic
store/store atomic/
atomicrmw-no-return-value.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
store.</p></li>
<li><p>Ensures that all
memory operations
have
completed before
performing the
store that is being
released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global/flat_store</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/ds/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0) &amp; vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit vmcnt(0) and
vscnt(0).</p></li>
<li><p>If OpenCL, omit lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0), s_waitcnt
vscnt(0) and s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic load/load
atomic/
atomicrmw-with-return-value.</p></li>
<li><p>s_waitcnt vscnt(0)
must happen after
any preceding
global/generic
store/store
atomic/
atomicrmw-no-return-value.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
have
completed before
performing the
atomicrmw that is
being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt vmcnt(0) &amp; vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit.</p></li>
<li><p>If OpenCL, omit.</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and s_waitcnt
vscnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic load/load
atomic/
atomicrmw-with-return-value.</p></li>
<li><p>s_waitcnt vscnt(0)
must happen after
any preceding
global/generic
store/store atomic/
atomicrmw-no-return-value.</p></li>
<li><p>Must happen before
the following
store.</p></li>
<li><p>Ensures that all
global memory
operations have
completed before
performing the
store that is being
released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>ds_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><dl class="simple">
<dt>s_waitcnt lgkmcnt(0) &amp;</dt><dd><p>vmcnt(0) &amp; vscnt(0)</p>
</dd>
</dl>
</li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0), s_waitcnt
vscnt(0) and s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/load atomic/
atomicrmw-with-return-value.</p></li>
<li><p>s_waitcnt vscnt(0)
must happen after
any preceding
global/generic
store/store atomic/
atomicrmw-no-return-value.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
to global and local
have completed
before performing
the atomicrmw that
is being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-even"><td><p>fence</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0) &amp; vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit vmcnt(0) and
vscnt(0).</p></li>
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).</p></li>
<li><p>If OpenCL and
address space is
local, omit
vmcnt(0) and vscnt(0).</p></li>
<li><p>However, since LLVM
currently has no
address space on
the fence need to
conservatively
always generate. If
fence had an
address space then
set to address
space of OpenCL
fence flag, or to
generic if both
local and global
flags are
specified.</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0), s_waitcnt
vscnt(0) and s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/load
atomic/
atomicrmw-with-return-value.</p></li>
<li><p>s_waitcnt vscnt(0)
must happen after
any preceding
global/generic
store/store atomic/
atomicrmw-no-return-value.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store atomic/
atomicrmw.</p></li>
<li><p>Must happen before
any following store
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>Ensures that all
memory operations
have
completed before
performing the
following
fence-paired-atomic.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>release</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0) &amp; vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).</p></li>
<li><p>If OpenCL and
address space is
local, omit
vmcnt(0) and vscnt(0).</p></li>
<li><p>However, since LLVM
currently has no
address space on
the fence need to
conservatively
always generate. If
fence had an
address space then
set to address
space of OpenCL
fence flag, or to
generic if both
local and global
flags are
specified.</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0), s_waitcnt
vscnt(0) and s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/load atomic/
atomicrmw-with-return-value.</p></li>
<li><p>s_waitcnt vscnt(0)
must happen after
any preceding
global/generic
store/store atomic/
atomicrmw-no-return-value.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
any following store
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
fence-paired-atomic).</p></li>
<li><p>Ensures that all
memory operations
have
completed before
performing the
following
fence-paired-atomic.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td colspan="5"><p><strong>Acquire-Release Atomic</strong></p></td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>buffer/global/ds/flat_atomic</p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0) &amp; vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit vmcnt(0) and
vscnt(0).</p></li>
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0), s_waitcnt
vscnt(0), and s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic load/load
atomic/
atomicrmw-with-return-value.</p></li>
<li><p>s_waitcnt vscnt(0)
must happen after
any preceding
global/generic
store/store
atomic/
atomicrmw-no-return-value.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
have
completed before
performing the
atomicrmw that is
being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global_atomic</p></li>
<li><p>s_waitcnt vm/vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit.</p></li>
<li><p>Use vmcnt(0) if atomic with
return and vscnt(0) if
atomic with no-return.</p></li>
<li><p>Must happen before
the following
buffer_gl0_inv.</p></li>
<li><p>Ensures any
following global
data read is no
older than the
atomicrmw value
being acquired.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="4">
<li><p>buffer_gl0_inv</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit.</p></li>
<li><p>Ensures that
following
loads will not see
stale data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt vmcnt(0) &amp; vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit.</p></li>
<li><p>If OpenCL, omit.</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and s_waitcnt
vscnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic load/load
atomic/
atomicrmw-with-return-value.</p></li>
<li><p>s_waitcnt vscnt(0)
must happen after
any preceding
global/generic
store/store atomic/
atomicrmw-no-return-value.</p></li>
<li><p>Must happen before
the following
store.</p></li>
<li><p>Ensures that all
global memory
operations have
completed before
performing the
store that is being
released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>ds_atomic</p></li>
<li><p>s_waitcnt lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit.</p></li>
<li><p>Must happen before
the following
buffer_gl0_inv.</p></li>
<li><p>Ensures any
following global
data read is no
older than the local load
atomic value being
acquired.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="4">
<li><p>buffer_gl0_inv</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit.</p></li>
<li><p>If OpenCL omit.</p></li>
<li><p>Ensures that
following
loads will not see
stale data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0) &amp; vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit vmcnt(0) and
vscnt(0).</p></li>
<li><p>If OpenCL, omit lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0), s_waitcnt
vscnt(0) and s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic load/load
atomic/
atomicrmw-with-return-value.</p></li>
<li><p>s_waitcnt vscnt(0)
must happen after
any preceding
global/generic
store/store
atomic/
atomicrmw-no-return-value.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
have
completed before
performing the
atomicrmw that is
being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>flat_atomic</p></li>
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0) &amp; vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit vmcnt(0) and
vscnt(0).</p></li>
<li><p>If OpenCL, omit lgkmcnt(0).</p></li>
<li><p>Must happen before
the following
buffer_gl0_inv.</p></li>
<li><p>Ensures any
following global
data read is no
older than the load
atomic value being
acquired.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_gl0_inv</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit.</p></li>
<li><p>Ensures that
following
loads will not see
stale data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0) &amp; vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0), s_waitcnt
vscnt(0) and s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/load atomic/
atomicrmw-with-return-value.</p></li>
<li><p>s_waitcnt vscnt(0)
must happen after
any preceding
global/generic
store/store atomic/
atomicrmw-no-return-value.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
to global have
completed before
performing the
atomicrmw that is
being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer/global_atomic</p></li>
<li><p>s_waitcnt vm/vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Use vmcnt(0) if atomic with
return and vscnt(0) if
atomic with no-return.</p></li>
<li><p>Must happen before
following
buffer_gl*_inv.</p></li>
<li><p>Ensures the
atomicrmw has
completed before
invalidating the
caches.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="4">
<li><p>buffer_gl0_inv;
buffer_gl1_inv</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0) &amp; vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0), s_waitcnt
vscnt(0), and s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/load atomic
atomicrmw-with-return-value.</p></li>
<li><p>s_waitcnt vscnt(0)
must happen after
any preceding
global/generic
store/store atomic/
atomicrmw-no-return-value.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
have
completed before
performing the
atomicrmw that is
being released.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>flat_atomic</p></li>
<li><p>s_waitcnt vm/vscnt(0) &amp;
lgkmcnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL, omit
lgkmcnt(0).</p></li>
<li><p>Use vmcnt(0) if atomic with
return and vscnt(0) if
atomic with no-return.</p></li>
<li><p>Must happen before
following
buffer_gl*_inv.</p></li>
<li><p>Ensures the
atomicrmw has
completed before
invalidating the
caches.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="4">
<li><p>buffer_gl0_inv;
buffer_gl1_inv</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
</tr>
<tr class="row-even"><td><p>fence</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0) &amp; vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit vmcnt(0) and
vscnt(0).</p></li>
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).</p></li>
<li><p>If OpenCL and
address space is
local, omit
vmcnt(0) and vscnt(0).</p></li>
<li><p>However,
since LLVM
currently has no
address space on
the fence need to
conservatively
always generate
(see comment for
previous fence).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0), s_waitcnt
vscnt(0) and s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/load
atomic/
atomicrmw-with-return-value.</p></li>
<li><p>s_waitcnt vscnt(0)
must happen after
any preceding
global/generic
store/store atomic/
atomicrmw-no-return-value.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store atomic/
atomicrmw.</p></li>
<li><p>Must happen before
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures that all
memory operations
have
completed before
performing any
following global
memory operations.</p></li>
<li><p>Ensures that the
preceding
local/generic load
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
acquire-fence-paired-atomic)
has completed
before following
global memory
operations. This
satisfies the
requirements of
acquire.</p></li>
<li><p>Ensures that all
previous memory
operations have
completed before a
following
local/generic store
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
release-fence-paired-atomic).
This satisfies the
requirements of
release.</p></li>
<li><p>Must happen before
the following
buffer_gl0_inv.</p></li>
<li><p>Ensures that the
acquire-fence-paired
atomic has completed
before invalidating
the
cache. Therefore
any following
locations read must
be no older than
the value read by
the
acquire-fence-paired-atomic.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>buffer_gl0_inv</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit.</p></li>
<li><p>Ensures that
following
loads will not see
stale data.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>acq_rel</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0) &amp; vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If OpenCL and
address space is
not generic, omit
lgkmcnt(0).</p></li>
<li><p>If OpenCL and
address space is
local, omit
vmcnt(0) and vscnt(0).</p></li>
<li><p>However, since LLVM
currently has no
address space on
the fence need to
conservatively
always generate
(see comment for
previous fence).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0), s_waitcnt
vscnt(0) and s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
any preceding
global/generic
load/load
atomic/
atomicrmw-with-return-value.</p></li>
<li><p>s_waitcnt vscnt(0)
must happen after
any preceding
global/generic
store/store atomic/
atomicrmw-no-return-value.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
any preceding
local/generic
load/store/load
atomic/store
atomic/atomicrmw.</p></li>
<li><p>Must happen before
the following
buffer_gl*_inv.</p></li>
<li><p>Ensures that the
preceding
global/local/generic
load
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
acquire-fence-paired-atomic)
has completed
before invalidating
the caches. This
satisfies the
requirements of
acquire.</p></li>
<li><p>Ensures that all
previous memory
operations have
completed before a
following
global/local/generic
store
atomic/atomicrmw
with an equal or
wider sync scope
and memory ordering
stronger than
unordered (this is
termed the
release-fence-paired-atomic).
This satisfies the
requirements of
release.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>buffer_gl0_inv;
buffer_gl1_inv</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Must happen before
any following
global/generic
load/load
atomic/store/store
atomic/atomicrmw.</p></li>
<li><p>Ensures that
following loads
will not see stale
global data. This
satisfies the
requirements of
acquire.</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td colspan="5"><p><strong>Sequential Consistent Atomic</strong></p></td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><p><em>Same as corresponding
load atomic acquire,
except must generated
all instructions even
for OpenCL.</em></p></td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0) &amp; vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit vmcnt(0) and
vscnt(0).</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0), s_waitcnt
vscnt(0), and s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt lgkmcnt(0) must
happen after
preceding
local/generic load
atomic/store
atomic/atomicrmw
with memory
ordering of seq_cst
and with equal or
wider sync scope.
(Note that seq_cst
fences have their
own s_waitcnt
lgkmcnt(0) and so do
not need to be
considered.)</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
preceding
global/generic load
atomic/
atomicrmw-with-return-value
with memory
ordering of seq_cst
and with equal or
wider sync scope.
(Note that seq_cst
fences have their
own s_waitcnt
vmcnt(0) and so do
not need to be
considered.)</p></li>
<li><p>s_waitcnt vscnt(0)
Must happen after
preceding
global/generic store
atomic/
atomicrmw-no-return-value
with memory
ordering of seq_cst
and with equal or
wider sync scope.
(Note that seq_cst
fences have their
own s_waitcnt
vscnt(0) and so do
not need to be
considered.)</p></li>
<li><p>Ensures any
preceding
sequential
consistent global/local
memory instructions
have completed
before executing
this sequentially
consistent
instruction. This
prevents reordering
a seq_cst store
followed by a
seq_cst load. (Note
that seq_cst is
stronger than
acquire/release as
the reordering of
load acquire
followed by a store
release is
prevented by the
s_waitcnt of
the release, but
there is nothing
preventing a store
release followed by
load acquire from
completing out of
order. The s_waitcnt
could be placed after
seq_store or before
the seq_load. We
choose the load to
make the s_waitcnt be
as late as possible
so that the store
may have already
completed.)</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p><em>Following
instructions same as
corresponding load
atomic acquire,
except must generated
all instructions even
for OpenCL.</em></p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>load atomic</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>workgroup</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>local</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt vmcnt(0) &amp; vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>If CU wavefront execution
mode, omit.</p></li>
<li><p>Could be split into
separate s_waitcnt
vmcnt(0) and s_waitcnt
vscnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt vmcnt(0)
Must happen after
preceding
global/generic load
atomic/
atomicrmw-with-return-value
with memory
ordering of seq_cst
and with equal or
wider sync scope.
(Note that seq_cst
fences have their
own s_waitcnt
vmcnt(0) and so do
not need to be
considered.)</p></li>
<li><p>s_waitcnt vscnt(0)
Must happen after
preceding
global/generic store
atomic/
atomicrmw-no-return-value
with memory
ordering of seq_cst
and with equal or
wider sync scope.
(Note that seq_cst
fences have their
own s_waitcnt
vscnt(0) and so do
not need to be
considered.)</p></li>
<li><p>Ensures any
preceding
sequential
consistent global
memory instructions
have completed
before executing
this sequentially
consistent
instruction. This
prevents reordering
a seq_cst store
followed by a
seq_cst load. (Note
that seq_cst is
stronger than
acquire/release as
the reordering of
load acquire
followed by a store
release is
prevented by the
s_waitcnt of
the release, but
there is nothing
preventing a store
release followed by
load acquire from
completing out of
order. The s_waitcnt
could be placed after
seq_store or before
the seq_load. We
choose the load to
make the s_waitcnt be
as late as possible
so that the store
may have already
completed.)</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p><em>Following
instructions same as
corresponding load
atomic acquire,
except must generated
all instructions even
for OpenCL.</em></p></li>
</ol>
</td>
</tr>
<tr class="row-even"><td><p>load atomic</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><ol class="arabic simple">
<li><p>s_waitcnt lgkmcnt(0) &amp;
vmcnt(0) &amp; vscnt(0)</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>Could be split into
separate s_waitcnt
vmcnt(0), s_waitcnt
vscnt(0) and s_waitcnt
lgkmcnt(0) to allow
them to be
independently moved
according to the
following rules.</p></li>
<li><p>s_waitcnt lgkmcnt(0)
must happen after
preceding
local load
atomic/store
atomic/atomicrmw
with memory
ordering of seq_cst
and with equal or
wider sync scope.
(Note that seq_cst
fences have their
own s_waitcnt
lgkmcnt(0) and so do
not need to be
considered.)</p></li>
<li><p>s_waitcnt vmcnt(0)
must happen after
preceding
global/generic load
atomic/
atomicrmw-with-return-value
with memory
ordering of seq_cst
and with equal or
wider sync scope.
(Note that seq_cst
fences have their
own s_waitcnt
vmcnt(0) and so do
not need to be
considered.)</p></li>
<li><p>s_waitcnt vscnt(0)
Must happen after
preceding
global/generic store
atomic/
atomicrmw-no-return-value
with memory
ordering of seq_cst
and with equal or
wider sync scope.
(Note that seq_cst
fences have their
own s_waitcnt
vscnt(0) and so do
not need to be
considered.)</p></li>
<li><p>Ensures any
preceding
sequential
consistent global
memory instructions
have completed
before executing
this sequentially
consistent
instruction. This
prevents reordering
a seq_cst store
followed by a
seq_cst load. (Note
that seq_cst is
stronger than
acquire/release as
the reordering of
load acquire
followed by a store
release is
prevented by the
s_waitcnt of
the release, but
there is nothing
preventing a store
release followed by
load acquire from
completing out of
order. The s_waitcnt
could be placed after
seq_store or before
the seq_load. We
choose the load to
make the s_waitcnt be
as late as possible
so that the store
may have already
completed.)</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p><em>Following
instructions same as
corresponding load
atomic acquire,
except must generated
all instructions even
for OpenCL.</em></p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>store atomic</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><p><em>Same as corresponding
store atomic release,
except must generated
all instructions even
for OpenCL.</em></p></td>
</tr>
<tr class="row-even"><td><p>atomicrmw</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>global</p></li>
<li><p>local</p></li>
<li><p>generic</p></li>
</ul>
</td>
<td><p><em>Same as corresponding
atomicrmw acq_rel,
except must generated
all instructions even
for OpenCL.</em></p></td>
</tr>
<tr class="row-odd"><td><p>fence</p></td>
<td><p>seq_cst</p></td>
<td><ul class="simple">
<li><p>singlethread</p></li>
<li><p>wavefront</p></li>
<li><p>workgroup</p></li>
<li><p>agent</p></li>
<li><p>system</p></li>
</ul>
</td>
<td><p><em>none</em></p></td>
<td><p><em>Same as corresponding
fence acq_rel,
except must generated
all instructions even
for OpenCL.</em></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
</div>
<div class="section" id="trap-handler-abi">
<h4><a class="toc-backref" href="#id156">Trap Handler ABI</a><a class="headerlink" href="#trap-handler-abi" title="Permalink to this headline">¶</a></h4>
<p>For code objects generated by the AMDGPU backend for HSA <a class="reference internal" href="#hsa" id="id68"><span>[HSA]</span></a> compatible
runtimes (see <a class="reference internal" href="#amdgpu-os"><span class="std std-ref">AMDGPU Operating Systems</span></a>), the runtime installs a trap handler that
supports the <code class="docutils literal notranslate"><span class="pre">s_trap</span></code> instruction. For usage see:</p>
<ul>
<li><p><a class="reference internal" href="#amdgpu-trap-handler-for-amdhsa-os-v2-table"><span class="std std-ref">AMDGPU Trap Handler for AMDHSA OS Code Object V2</span></a></p></li>
<li><p><a class="reference internal" href="#amdgpu-trap-handler-for-amdhsa-os-v3-table"><span class="std std-ref">AMDGPU Trap Handler for AMDHSA OS Code Object V3</span></a></p></li>
<li><p><a class="reference internal" href="#amdgpu-trap-handler-for-amdhsa-os-v4-table"><span class="std std-ref">AMDGPU Trap Handler for AMDHSA OS Code Object V4</span></a></p>
<table class="docutils align-default" id="amdgpu-trap-handler-for-amdhsa-os-v2-table">
<caption><span class="caption-text">AMDGPU Trap Handler for AMDHSA OS Code Object V2</span><a class="headerlink" href="#amdgpu-trap-handler-for-amdhsa-os-v2-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Usage</p></th>
<th class="head"><p>Code Sequence</p></th>
<th class="head"><p>Trap Handler
Inputs</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x00</span></code></p></td>
<td></td>
<td><p>Reserved by hardware.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">debugtrap(arg)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x01</span></code></p></td>
<td><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SGPR0-1</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">queue_ptr</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VGPR0</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">arg</span></code></p>
</dd>
</dl>
</td>
<td><p>Reserved for Finalizer HSA <code class="docutils literal notranslate"><span class="pre">debugtrap</span></code>
intrinsic (not implemented).</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">llvm.trap</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x02</span></code></p></td>
<td><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SGPR0-1</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">queue_ptr</span></code></p>
</dd>
</dl>
</td>
<td><p>Causes wave to be halted with the PC at
the trap instruction. The associated
queue is signalled to put it into the
error state.  When the queue is put in
the error state, the waves executing
dispatches on the queue will be
terminated.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">llvm.debugtrap</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x03</span></code></p></td>
<td><p><em>none</em></p></td>
<td><ul class="simple">
<li><p>If debugger not enabled then behaves
as a no-operation. The trap handler
is entered and immediately returns to
continue execution of the wavefront.</p></li>
<li><p>If the debugger is enabled, causes
the debug trap to be reported by the
debugger and the wavefront is put in
the halt state with the PC at the
instruction.  The debugger must
increment the PC and resume the wave.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x04</span></code></p></td>
<td></td>
<td><p>Reserved.</p></td>
</tr>
<tr class="row-odd"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x05</span></code></p></td>
<td></td>
<td><p>Reserved.</p></td>
</tr>
<tr class="row-even"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x06</span></code></p></td>
<td></td>
<td><p>Reserved.</p></td>
</tr>
<tr class="row-odd"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x07</span></code></p></td>
<td></td>
<td><p>Reserved.</p></td>
</tr>
<tr class="row-even"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x08</span></code></p></td>
<td></td>
<td><p>Reserved.</p></td>
</tr>
<tr class="row-odd"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0xfe</span></code></p></td>
<td></td>
<td><p>Reserved.</p></td>
</tr>
<tr class="row-even"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0xff</span></code></p></td>
<td></td>
<td><p>Reserved.</p></td>
</tr>
</tbody>
</table>
</li>
</ul>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-trap-handler-for-amdhsa-os-v3-table">
<caption><span class="caption-text">AMDGPU Trap Handler for AMDHSA OS Code Object V3</span><a class="headerlink" href="#amdgpu-trap-handler-for-amdhsa-os-v3-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 22%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Usage</p></th>
<th class="head"><p>Code Sequence</p></th>
<th class="head"><p>Trap Handler
Inputs</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x00</span></code></p></td>
<td></td>
<td><p>Reserved by hardware.</p></td>
</tr>
<tr class="row-odd"><td><p>debugger breakpoint</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x01</span></code></p></td>
<td><p><em>none</em></p></td>
<td><p>Reserved for debugger to use for
breakpoints. Causes wave to be halted
with the PC at the trap instruction.
The debugger is responsible to resume
the wave, including the instruction
that the breakpoint overwrote.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">llvm.trap</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x02</span></code></p></td>
<td><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SGPR0-1</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">queue_ptr</span></code></p>
</dd>
</dl>
</td>
<td><p>Causes wave to be halted with the PC at
the trap instruction. The associated
queue is signalled to put it into the
error state.  When the queue is put in
the error state, the waves executing
dispatches on the queue will be
terminated.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">llvm.debugtrap</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x03</span></code></p></td>
<td><p><em>none</em></p></td>
<td><ul class="simple">
<li><p>If debugger not enabled then behaves
as a no-operation. The trap handler
is entered and immediately returns to
continue execution of the wavefront.</p></li>
<li><p>If the debugger is enabled, causes
the debug trap to be reported by the
debugger and the wavefront is put in
the halt state with the PC at the
instruction.  The debugger must
increment the PC and resume the wave.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x04</span></code></p></td>
<td></td>
<td><p>Reserved.</p></td>
</tr>
<tr class="row-odd"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x05</span></code></p></td>
<td></td>
<td><p>Reserved.</p></td>
</tr>
<tr class="row-even"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x06</span></code></p></td>
<td></td>
<td><p>Reserved.</p></td>
</tr>
<tr class="row-odd"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x07</span></code></p></td>
<td></td>
<td><p>Reserved.</p></td>
</tr>
<tr class="row-even"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x08</span></code></p></td>
<td></td>
<td><p>Reserved.</p></td>
</tr>
<tr class="row-odd"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0xfe</span></code></p></td>
<td></td>
<td><p>Reserved.</p></td>
</tr>
<tr class="row-even"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0xff</span></code></p></td>
<td></td>
<td><p>Reserved.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-trap-handler-for-amdhsa-os-v4-table">
<caption><span class="caption-text">AMDGPU Trap Handler for AMDHSA OS Code Object V4</span><a class="headerlink" href="#amdgpu-trap-handler-for-amdhsa-os-v4-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 18%" />
<col style="width: 14%" />
<col style="width: 15%" />
<col style="width: 16%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Usage</p></th>
<th class="head"><p>Code Sequence</p></th>
<th class="head"><p>GFX6-GFX8 Inputs</p></th>
<th class="head"><p>GFX9-GFX10 Inputs</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x00</span></code></p></td>
<td></td>
<td></td>
<td><p>Reserved by hardware.</p></td>
</tr>
<tr class="row-odd"><td><p>debugger breakpoint</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x01</span></code></p></td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
<td><p>Reserved for debugger to use for
breakpoints. Causes wave to be halted
with the PC at the trap instruction.
The debugger is responsible to resume
the wave, including the instruction
that the breakpoint overwrote.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">llvm.trap</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x02</span></code></p></td>
<td><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">SGPR0-1</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">queue_ptr</span></code></p>
</dd>
</dl>
</td>
<td><p><em>none</em></p></td>
<td><p>Causes wave to be halted with the PC at
the trap instruction. The associated
queue is signalled to put it into the
error state.  When the queue is put in
the error state, the waves executing
dispatches on the queue will be
terminated.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">llvm.debugtrap</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x03</span></code></p></td>
<td><p><em>none</em></p></td>
<td><p><em>none</em></p></td>
<td><ul class="simple">
<li><p>If debugger not enabled then behaves
as a no-operation. The trap handler
is entered and immediately returns to
continue execution of the wavefront.</p></li>
<li><p>If the debugger is enabled, causes
the debug trap to be reported by the
debugger and the wavefront is put in
the halt state with the PC at the
instruction.  The debugger must
increment the PC and resume the wave.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x04</span></code></p></td>
<td></td>
<td></td>
<td><p>Reserved.</p></td>
</tr>
<tr class="row-odd"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x05</span></code></p></td>
<td></td>
<td></td>
<td><p>Reserved.</p></td>
</tr>
<tr class="row-even"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x06</span></code></p></td>
<td></td>
<td></td>
<td><p>Reserved.</p></td>
</tr>
<tr class="row-odd"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x07</span></code></p></td>
<td></td>
<td></td>
<td><p>Reserved.</p></td>
</tr>
<tr class="row-even"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0x08</span></code></p></td>
<td></td>
<td></td>
<td><p>Reserved.</p></td>
</tr>
<tr class="row-odd"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0xfe</span></code></p></td>
<td></td>
<td></td>
<td><p>Reserved.</p></td>
</tr>
<tr class="row-even"><td><p>reserved</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s_trap</span> <span class="pre">0xff</span></code></p></td>
<td></td>
<td></td>
<td><p>Reserved.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="call-convention">
<span id="amdgpu-amdhsa-function-call-convention"></span><h4><a class="toc-backref" href="#id157">Call Convention</a><a class="headerlink" href="#call-convention" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section is currently incomplete and has inaccuracies. It is WIP that will
be updated as information is determined.</p>
</div>
<p>See <a class="reference internal" href="#amdgpu-dwarf-address-space-identifier"><span class="std std-ref">Address Space Identifier</span></a> for information on swizzled
addresses. Unswizzled addresses are normal linear addresses.</p>
<div class="section" id="kernel-functions">
<span id="amdgpu-amdhsa-function-call-convention-kernel-functions"></span><h5><a class="toc-backref" href="#id158">Kernel Functions</a><a class="headerlink" href="#kernel-functions" title="Permalink to this headline">¶</a></h5>
<p>This section describes the call convention ABI for the outer kernel function.</p>
<p>See <a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a> for the kernel call
convention.</p>
<p>The following is not part of the AMDGPU kernel calling convention but describes
how the AMDGPU implements function calls:</p>
<ol class="arabic">
<li><p>Clang decides the kernarg layout to match the <em>HSA Programmer’s Language
Reference</em> <a class="reference internal" href="#hsa" id="id69"><span>[HSA]</span></a>.</p>
<ul class="simple">
<li><p>All structs are passed directly.</p></li>
<li><p>Lambda values are passed <em>TBA</em>.</p></li>
</ul>
</li>
</ol>
<ol class="arabic simple" start="4">
<li><p>The kernel performs certain setup in its prolog, as described in
<a class="reference internal" href="#amdgpu-amdhsa-kernel-prolog"><span class="std std-ref">Kernel Prolog</span></a>.</p></li>
</ol>
</div>
<div class="section" id="non-kernel-functions">
<span id="amdgpu-amdhsa-function-call-convention-non-kernel-functions"></span><h5><a class="toc-backref" href="#id159">Non-Kernel Functions</a><a class="headerlink" href="#non-kernel-functions" title="Permalink to this headline">¶</a></h5>
<p>This section describes the call convention ABI for functions other than the
outer kernel function.</p>
<p>If a kernel has function calls then scratch is always allocated and used for
the call stack which grows from low address to high address using the swizzled
scratch address space.</p>
<p>On entry to a function:</p>
<ol class="arabic">
<li><p>SGPR0-3 contain a V# with the following properties (see
<a class="reference internal" href="#amdgpu-amdhsa-kernel-prolog-private-segment-buffer"><span class="std std-ref">Private Segment Buffer</span></a>):</p>
<ul class="simple">
<li><p>Base address pointing to the beginning of the wavefront scratch backing
memory.</p></li>
<li><p>Swizzled with dword element size and stride of wavefront size elements.</p></li>
</ul>
</li>
<li><p>The FLAT_SCRATCH register pair is setup. See
<a class="reference internal" href="#amdgpu-amdhsa-kernel-prolog-flat-scratch"><span class="std std-ref">Flat Scratch</span></a>.</p></li>
<li><p>GFX6-GFX8: M0 register set to the size of LDS in bytes. See
<a class="reference internal" href="#amdgpu-amdhsa-kernel-prolog-m0"><span class="std std-ref">M0</span></a>.</p></li>
<li><p>The EXEC register is set to the lanes active on entry to the function.</p></li>
<li><p>MODE register: <em>TBD</em></p></li>
<li><p>VGPR0-31 and SGPR4-29 are used to pass function input arguments as described
below.</p></li>
<li><p>SGPR30-31 return address (RA). The code address that the function must
return to when it completes. The value is undefined if the function is <em>no
return</em>.</p></li>
<li><p>SGPR32 is used for the stack pointer (SP). It is an unswizzled scratch
offset relative to the beginning of the wavefront scratch backing memory.</p>
<p>The unswizzled SP can be used with buffer instructions as an unswizzled SGPR
offset with the scratch V# in SGPR0-3 to access the stack in a swizzled
manner.</p>
<p>The unswizzled SP value can be converted into the swizzled SP value by:</p>
<blockquote>
<div><div class="line-block">
<div class="line">swizzled SP = unswizzled SP / wavefront size</div>
</div>
</div></blockquote>
<p>This may be used to obtain the private address space address of stack
objects and to convert this address to a flat address by adding the flat
scratch aperture base address.</p>
<p>The swizzled SP value is always 4 bytes aligned for the <code class="docutils literal notranslate"><span class="pre">r600</span></code>
architecture and 16 byte aligned for the <code class="docutils literal notranslate"><span class="pre">amdgcn</span></code> architecture.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">amdgcn</span></code> value is selected to avoid dynamic stack alignment for the
OpenCL language which has the largest base type defined as 16 bytes.</p>
</div>
<p>On entry, the swizzled SP value is the address of the first function
argument passed on the stack. Other stack passed arguments are positive
offsets from the entry swizzled SP value.</p>
<p>The function may use positive offsets beyond the last stack passed argument
for stack allocated local variables and register spill slots. If necessary,
the function may align these to greater alignment than 16 bytes. After these
the function may dynamically allocate space for such things as runtime sized
<code class="docutils literal notranslate"><span class="pre">alloca</span></code> local allocations.</p>
<p>If the function calls another function, it will place any stack allocated
arguments after the last local allocation and adjust SGPR32 to the address
after the last local allocation.</p>
</li>
<li><p>All other registers are unspecified.</p></li>
<li><p>Any necessary <code class="docutils literal notranslate"><span class="pre">s_waitcnt</span></code> has been performed to ensure memory is available
to the function.</p></li>
</ol>
<p>On exit from a function:</p>
<ol class="arabic">
<li><p>VGPR0-31 and SGPR4-29 are used to pass function result arguments as
described below. Any registers used are considered clobbered registers.</p></li>
<li><p>The following registers are preserved and have the same value as on entry:</p>
<ul>
<li><p>FLAT_SCRATCH</p></li>
<li><p>EXEC</p></li>
<li><p>GFX6-GFX8: M0</p></li>
<li><p>All SGPR registers except the clobbered registers of SGPR4-31.</p></li>
<li><p>VGPR40-47</p></li>
<li><p>VGPR56-63</p></li>
<li><p>VGPR72-79</p></li>
<li><p>VGPR88-95</p></li>
<li><p>VGPR104-111</p></li>
<li><p>VGPR120-127</p></li>
<li><p>VGPR136-143</p></li>
<li><p>VGPR152-159</p></li>
<li><p>VGPR168-175</p></li>
<li><p>VGPR184-191</p></li>
<li><p>VGPR200-207</p></li>
<li><p>VGPR216-223</p></li>
<li><p>VGPR232-239</p></li>
<li><p>VGPR248-255</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Except the argument registers, the VGPRs clobbered and the preserved
registers are intermixed at regular intervals in order to keep a
similar ratio independent of the number of allocated VGPRs.</p>
</div>
</div></blockquote>
</li>
<li><p>Lanes of all VGPRs that are inactive at the call site.</p>
<p>For the AMDGPU backend, an inter-procedural register allocation (IPRA)
optimization may mark some of clobbered SGPR and VGPR registers as
preserved if it can be determined that the called function does not change
their value.</p>
</li>
</ul>
</li>
</ol>
<ol class="arabic simple" start="2">
<li><p>The PC is set to the RA provided on entry.</p></li>
<li><p>MODE register: <em>TBD</em>.</p></li>
<li><p>All other registers are clobbered.</p></li>
<li><p>Any necessary <code class="docutils literal notranslate"><span class="pre">s_waitcnt</span></code> has been performed to ensure memory accessed by
function is available to the caller.</p></li>
</ol>
<p>The function input arguments are made up of the formal arguments explicitly
declared by the source language function plus the implicit input arguments used
by the implementation.</p>
<p>The source language input arguments are:</p>
<ol class="arabic simple">
<li><p>Any source language implicit <code class="docutils literal notranslate"><span class="pre">this</span></code> or <code class="docutils literal notranslate"><span class="pre">self</span></code> argument comes first as a
pointer type.</p></li>
<li><p>Followed by the function formal arguments in left to right source order.</p></li>
</ol>
<p>The source language result arguments are:</p>
<ol class="arabic simple">
<li><p>The function result argument.</p></li>
</ol>
<p>The source language input or result struct type arguments that are less than or
equal to 16 bytes, are decomposed recursively into their base type fields, and
each field is passed as if a separate argument. For input arguments, if the
called function requires the struct to be in memory, for example because its
address is taken, then the function body is responsible for allocating a stack
location and copying the field arguments into it. Clang terms this <em>direct
struct</em>.</p>
<p>The source language input struct type arguments that are greater than 16 bytes,
are passed by reference. The caller is responsible for allocating a stack
location to make a copy of the struct value and pass the address as the input
argument. The called function is responsible to perform the dereference when
accessing the input argument. Clang terms this <em>by-value struct</em>.</p>
<p>A source language result struct type argument that is greater than 16 bytes, is
returned by reference. The caller is responsible for allocating a stack location
to hold the result value and passes the address as the last input argument
(before the implicit input arguments). In this case there are no result
arguments. The called function is responsible to perform the dereference when
storing the result value. Clang terms this <em>structured return (sret)</em>.</p>
<p><em>TODO: correct the ``sret`` definition.</em></p>
<p>Lambda argument types are treated as struct types with an implementation defined
set of fields.</p>
<p>For AMDGPU backend all source language arguments (including the decomposed
struct type arguments) are passed in VGPRs unless marked <code class="docutils literal notranslate"><span class="pre">inreg</span></code> in which case
they are passed in SGPRs.</p>
<p>The AMDGPU backend walks the function call graph from the leaves to determine
which implicit input arguments are used, propagating to each caller of the
function. The used implicit arguments are appended to the function arguments
after the source language arguments in the following order:</p>
<ol class="arabic">
<li><p>Work-Item ID (1 VGPR)</p>
<p>The X, Y and Z work-item ID are packed into a single VGRP with the following
layout. Only fields actually used by the function are set. The other bits
are undefined.</p>
<p>The values come from the initial kernel execution state. See
<a class="reference internal" href="#amdgpu-amdhsa-initial-kernel-execution-state"><span class="std std-ref">Initial Kernel Execution State</span></a>.</p>
<table class="docutils align-default" id="amdgpu-amdhsa-workitem-implicit-argument-layout-table">
<caption><span class="caption-text">Work-item implicit argument layout</span><a class="headerlink" href="#amdgpu-amdhsa-workitem-implicit-argument-layout-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bits</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Field Name</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>9:0</p></td>
<td><p>10 bits</p></td>
<td><p>X Work-Item ID</p></td>
</tr>
<tr class="row-odd"><td><p>19:10</p></td>
<td><p>10 bits</p></td>
<td><p>Y Work-Item ID</p></td>
</tr>
<tr class="row-even"><td><p>29:20</p></td>
<td><p>10 bits</p></td>
<td><p>Z Work-Item ID</p></td>
</tr>
<tr class="row-odd"><td><p>31:30</p></td>
<td><p>2 bits</p></td>
<td><p>Unused</p></td>
</tr>
</tbody>
</table>
</li>
<li><p>Dispatch Ptr (2 SGPRs)</p>
<p>The value comes from the initial kernel execution state. See
<a class="reference internal" href="#amdgpu-amdhsa-sgpr-register-set-up-order-table"><span class="std std-ref">SGPR Register Set Up Order</span></a>.</p>
</li>
<li><p>Queue Ptr (2 SGPRs)</p>
<p>The value comes from the initial kernel execution state. See
<a class="reference internal" href="#amdgpu-amdhsa-sgpr-register-set-up-order-table"><span class="std std-ref">SGPR Register Set Up Order</span></a>.</p>
</li>
<li><p>Kernarg Segment Ptr (2 SGPRs)</p>
<p>The value comes from the initial kernel execution state. See
<a class="reference internal" href="#amdgpu-amdhsa-sgpr-register-set-up-order-table"><span class="std std-ref">SGPR Register Set Up Order</span></a>.</p>
</li>
<li><p>Dispatch id (2 SGPRs)</p>
<p>The value comes from the initial kernel execution state. See
<a class="reference internal" href="#amdgpu-amdhsa-sgpr-register-set-up-order-table"><span class="std std-ref">SGPR Register Set Up Order</span></a>.</p>
</li>
<li><p>Work-Group ID X (1 SGPR)</p>
<p>The value comes from the initial kernel execution state. See
<a class="reference internal" href="#amdgpu-amdhsa-sgpr-register-set-up-order-table"><span class="std std-ref">SGPR Register Set Up Order</span></a>.</p>
</li>
<li><p>Work-Group ID Y (1 SGPR)</p>
<p>The value comes from the initial kernel execution state. See
<a class="reference internal" href="#amdgpu-amdhsa-sgpr-register-set-up-order-table"><span class="std std-ref">SGPR Register Set Up Order</span></a>.</p>
</li>
<li><p>Work-Group ID Z (1 SGPR)</p>
<p>The value comes from the initial kernel execution state. See
<a class="reference internal" href="#amdgpu-amdhsa-sgpr-register-set-up-order-table"><span class="std std-ref">SGPR Register Set Up Order</span></a>.</p>
</li>
<li><p>Implicit Argument Ptr (2 SGPRs)</p>
<p>The value is computed by adding an offset to Kernarg Segment Ptr to get the
global address space pointer to the first kernarg implicit argument.</p>
</li>
</ol>
<p>The input and result arguments are assigned in order in the following manner:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There are likely some errors and omissions in the following description that
need correction.</p>
</div>
<ul>
<li><p>VGPR arguments are assigned to consecutive VGPRs starting at VGPR0 up to
VGPR31.</p>
<p>If there are more arguments than will fit in these registers, the remaining
arguments are allocated on the stack in order on naturally aligned
addresses.</p>
</li>
<li><p>SGPR arguments are assigned to consecutive SGPRs starting at SGPR0 up to
SGPR29.</p>
<p>If there are more arguments than will fit in these registers, the remaining
arguments are allocated on the stack in order on naturally aligned
addresses.</p>
</li>
</ul>
<p>Note that decomposed struct type arguments may have some fields passed in
registers and some in memory.</p>
<p>The following is not part of the AMDGPU function calling convention but
describes how the AMDGPU implements function calls:</p>
<ol class="arabic">
<li><p>SGPR33 is used as a frame pointer (FP) if necessary. Like the SP it is an
unswizzled scratch address. It is only needed if runtime sized <code class="docutils literal notranslate"><span class="pre">alloca</span></code>
are used, or for the reasons defined in <code class="docutils literal notranslate"><span class="pre">SIFrameLowering</span></code>.</p></li>
<li><p>Runtime stack alignment is supported. SGPR34 is used as a base pointer (BP)
to access the incoming stack arguments in the function. The BP is needed
only when the function requires the runtime stack alignment.</p></li>
<li><p>Allocating SGPR arguments on the stack are not supported.</p></li>
<li><p>No CFI is currently generated. See
<a class="reference internal" href="AMDGPUDwarfExtensionsForHeterogeneousDebugging.html#amdgpu-dwarf-call-frame-information"><span class="std std-ref">Call Frame Information</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>CFI will be generated that defines the CFA as the unswizzled address
relative to the wave scratch base in the unswizzled private address space
of the lowest address stack allocated local variable.</p>
<p><code class="docutils literal notranslate"><span class="pre">DW_AT_frame_base</span></code> will be defined as the swizzled address in the
swizzled private address space by dividing the CFA by the wavefront size
(since CFA is always at least dword aligned which matches the scratch
swizzle element size).</p>
<p>If no dynamic stack alignment was performed, the stack allocated arguments
are accessed as negative offsets relative to <code class="docutils literal notranslate"><span class="pre">DW_AT_frame_base</span></code>, and the
local variables and register spill slots are accessed as positive offsets
relative to <code class="docutils literal notranslate"><span class="pre">DW_AT_frame_base</span></code>.</p>
</div>
</li>
<li><p>Function argument passing is implemented by copying the input physical
registers to virtual registers on entry. The register allocator can spill if
necessary. These are copied back to physical registers at call sites. The
net effect is that each function call can have these values in entirely
distinct locations. The IPRA can help avoid shuffling argument registers.</p></li>
<li><p>Call sites are implemented by setting up the arguments at positive offsets
from SP. Then SP is incremented to account for the known frame size before
the call and decremented after the call.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The CFI will reflect the changed calculation needed to compute the CFA
from SP.</p>
</div>
</li>
<li><p>4 byte spill slots are used in the stack frame. One slot is allocated for an
emergency spill slot. Buffer instructions are used for stack accesses and
not the <code class="docutils literal notranslate"><span class="pre">flat_scratch</span></code> instruction.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="section" id="amdpal">
<h3><a class="toc-backref" href="#id160">AMDPAL</a><a class="headerlink" href="#amdpal" title="Permalink to this headline">¶</a></h3>
<p>This section provides code conventions used when the target triple OS is
<code class="docutils literal notranslate"><span class="pre">amdpal</span></code> (see <a class="reference internal" href="#amdgpu-target-triples"><span class="std std-ref">Target Triples</span></a>).</p>
<div class="section" id="amdgpu-amdpal-code-object-metadata-section">
<span id="id80"></span><h4><a class="toc-backref" href="#id161">Code Object Metadata</a><a class="headerlink" href="#amdgpu-amdpal-code-object-metadata-section" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The metadata is currently in development and is subject to major
changes. Only the current version is supported. <em>When this document
was generated the version was 2.6.</em></p>
</div>
<p>Code object metadata is specified by the <code class="docutils literal notranslate"><span class="pre">NT_AMDGPU_METADATA</span></code> note
record (see <a class="reference internal" href="#amdgpu-note-records-v3-v4"><span class="std std-ref">Code Object V3 to V4 Note Records</span></a>).</p>
<p>The metadata is represented as Message Pack formatted binary data (see
<a class="reference internal" href="#msgpack" id="id81"><span>[MsgPack]</span></a>). The top level is a Message Pack map that includes the keys
defined in table <a class="reference internal" href="#amdgpu-amdpal-code-object-metadata-map-table"><span class="std std-ref">AMDPAL Code Object Metadata Map</span></a>
and referenced tables.</p>
<p>Additional information can be added to the maps. To avoid conflicts, any
key names should be prefixed by “<em>vendor-name</em>.” where <code class="docutils literal notranslate"><span class="pre">vendor-name</span></code>
can be the name of the vendor and specific vendor tool that generates the
information. The prefix is abbreviated to simply “.” when it appears
within a map that has been added by the same <em>vendor-name</em>.</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdpal-code-object-metadata-map-table">
<caption><span class="caption-text">AMDPAL Code Object Metadata Map</span><a class="headerlink" href="#amdgpu-amdpal-code-object-metadata-map-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 17%" />
<col style="width: 13%" />
<col style="width: 8%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>String Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required?</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“amdpal.version”</p></td>
<td><p>sequence of
2 integers</p></td>
<td><p>Required</p></td>
<td><p>PAL code object metadata (major, minor) version. The current values
are defined by <em>Util::Abi::PipelineMetadata(Major|Minor)Version</em>.</p></td>
</tr>
<tr class="row-odd"><td><p>“amdpal.pipelines”</p></td>
<td><p>sequence of
map</p></td>
<td><p>Required</p></td>
<td><p>Per-pipeline metadata. See
<a class="reference internal" href="#amdgpu-amdpal-code-object-pipeline-metadata-map-table"><span class="std std-ref">AMDPAL Code Object Pipeline Metadata Map</span></a> for the
definition of the keys included in that map.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdpal-code-object-pipeline-metadata-map-table">
<caption><span class="caption-text">AMDPAL Code Object Pipeline Metadata Map</span><a class="headerlink" href="#amdgpu-amdpal-code-object-pipeline-metadata-map-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 32%" />
<col style="width: 12%" />
<col style="width: 8%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>String Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required?</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“.name”</p></td>
<td><p>string</p></td>
<td></td>
<td><p>Source name of the pipeline.</p></td>
</tr>
<tr class="row-odd"><td><p>“.type”</p></td>
<td><p>string</p></td>
<td></td>
<td><p>Pipeline type, e.g. VsPs. Values include:</p>
<blockquote>
<div><ul class="simple">
<li><p>“VsPs”</p></li>
<li><p>“Gs”</p></li>
<li><p>“Cs”</p></li>
<li><p>“Ngg”</p></li>
<li><p>“Tess”</p></li>
<li><p>“GsTess”</p></li>
<li><p>“NggTess”</p></li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td><p>“.internal_pipeline_hash”</p></td>
<td><p>sequence of
2 integers</p></td>
<td><p>Required</p></td>
<td><p>Internal compiler hash for this pipeline. Lower
64 bits is the “stable” portion of the hash, used
for e.g. shader replacement lookup. Upper 64 bits
is the “unique” portion of the hash, used for
e.g. pipeline cache lookup. The value is
implementation defined, and can not be relied on
between different builds of the compiler.</p></td>
</tr>
<tr class="row-odd"><td><p>“.shaders”</p></td>
<td><p>map</p></td>
<td></td>
<td><p>Per-API shader metadata. See
<a class="reference internal" href="#amdgpu-amdpal-code-object-shader-map-table"><span class="std std-ref">AMDPAL Code Object Shader Map</span></a>
for the definition of the keys included in that
map.</p></td>
</tr>
<tr class="row-even"><td><p>“.hardware_stages”</p></td>
<td><p>map</p></td>
<td></td>
<td><p>Per-hardware stage metadata. See
<a class="reference internal" href="#amdgpu-amdpal-code-object-hardware-stage-map-table"><span class="std std-ref">AMDPAL Code Object Hardware Stage Map</span></a>
for the definition of the keys included in that
map.</p></td>
</tr>
<tr class="row-odd"><td><p>“.shader_functions”</p></td>
<td><p>map</p></td>
<td></td>
<td><p>Per-shader function metadata. See
<a class="reference internal" href="#amdgpu-amdpal-code-object-shader-function-map-table"><span class="std std-ref">AMDPAL Code Object Shader Function Map</span></a>
for the definition of the keys included in that
map.</p></td>
</tr>
<tr class="row-even"><td><p>“.registers”</p></td>
<td><p>map</p></td>
<td><p>Required</p></td>
<td><p>Hardware register configuration. See
<a class="reference internal" href="#amdgpu-amdpal-code-object-register-map-table"><span class="std std-ref">AMDPAL Code Object Register Map</span></a>
for the definition of the keys included in that
map.</p></td>
</tr>
<tr class="row-odd"><td><p>“.user_data_limit”</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>Number of user data entries accessed by this
pipeline.</p></td>
</tr>
<tr class="row-even"><td><p>“.spill_threshold”</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>The user data spill threshold.  0xFFFF for
NoUserDataSpilling.</p></td>
</tr>
<tr class="row-odd"><td><p>“.uses_viewport_array_index”</p></td>
<td><p>boolean</p></td>
<td></td>
<td><p>Indicates whether or not the pipeline uses the
viewport array index feature. Pipelines which use
this feature can render into all 16 viewports,
whereas pipelines which do not use it are
restricted to viewport #0.</p></td>
</tr>
<tr class="row-even"><td><p>“.es_gs_lds_size”</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>Size in bytes of LDS space used internally for
handling data-passing between the ES and GS
shader stages. This can be zero if the data is
passed using off-chip buffers. This value should
be used to program all user-SGPRs which have been
marked with “UserDataMapping::EsGsLdsSize”
(typically only the GS and VS HW stages will ever
have a user-SGPR so marked).</p></td>
</tr>
<tr class="row-odd"><td><p>“.nggSubgroupSize”</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>Explicit maximum subgroup size for NGG shaders
(maximum number of threads in a subgroup).</p></td>
</tr>
<tr class="row-even"><td><p>“.num_interpolants”</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>Graphics only. Number of PS interpolants.</p></td>
</tr>
<tr class="row-odd"><td><p>“.mesh_scratch_memory_size”</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>Max mesh shader scratch memory used.</p></td>
</tr>
<tr class="row-even"><td><p>“.api”</p></td>
<td><p>string</p></td>
<td></td>
<td><p>Name of the client graphics API.</p></td>
</tr>
<tr class="row-odd"><td><p>“.api_create_info”</p></td>
<td><p>binary</p></td>
<td></td>
<td><p>Graphics API shader create info binary blob. Can
be defined by the driver using the compiler if
they want to be able to correlate API-specific
information used during creation at a later time.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdpal-code-object-shader-map-table">
<caption><span class="caption-text">AMDPAL Code Object Shader Map</span><a class="headerlink" href="#amdgpu-amdpal-code-object-shader-map-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 15%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>String Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><ul class="simple">
<li><p>“.compute”</p></li>
<li><p>“.vertex”</p></li>
<li><p>“.hull”</p></li>
<li><p>“.domain”</p></li>
<li><p>“.geometry”</p></li>
<li><p>“.pixel”</p></li>
</ul>
</td>
<td><p>map</p></td>
<td><p>See <a class="reference internal" href="#amdgpu-amdpal-code-object-api-shader-metadata-map-table"><span class="std std-ref">AMDPAL Code Object API Shader Metadata Map</span></a>
for the definition of the keys included in that map.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdpal-code-object-api-shader-metadata-map-table">
<caption><span class="caption-text">AMDPAL Code Object API Shader Metadata Map</span><a class="headerlink" href="#amdgpu-amdpal-code-object-api-shader-metadata-map-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 18%" />
<col style="width: 13%" />
<col style="width: 8%" />
<col style="width: 62%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>String Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required?</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“.api_shader_hash”</p></td>
<td><p>sequence of
2 integers</p></td>
<td><p>Required</p></td>
<td><p>Input shader hash, typically passed in from the client. The value
is implementation defined, and can not be relied on between
different builds of the compiler.</p></td>
</tr>
<tr class="row-odd"><td><p>“.hardware_mapping”</p></td>
<td><p>sequence of
string</p></td>
<td><p>Required</p></td>
<td><p>Flags indicating the HW stages this API shader maps to. Values
include:</p>
<blockquote>
<div><ul class="simple">
<li><p>“.ls”</p></li>
<li><p>“.hs”</p></li>
<li><p>“.es”</p></li>
<li><p>“.gs”</p></li>
<li><p>“.vs”</p></li>
<li><p>“.ps”</p></li>
<li><p>“.cs”</p></li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdpal-code-object-hardware-stage-map-table">
<caption><span class="caption-text">AMDPAL Code Object Hardware Stage Map</span><a class="headerlink" href="#amdgpu-amdpal-code-object-hardware-stage-map-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 13%" />
<col style="width: 14%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>String Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><ul class="simple">
<li><p>“.ls”</p></li>
<li><p>“.hs”</p></li>
<li><p>“.es”</p></li>
<li><p>“.gs”</p></li>
<li><p>“.vs”</p></li>
<li><p>“.ps”</p></li>
<li><p>“.cs”</p></li>
</ul>
</td>
<td><p>map</p></td>
<td><p>See <a class="reference internal" href="#amdgpu-amdpal-code-object-hardware-stage-metadata-map-table"><span class="std std-ref">AMDPAL Code Object Hardware Stage Metadata Map</span></a>
for the definition of the keys included in that map.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdpal-code-object-hardware-stage-metadata-map-table">
<caption><span class="caption-text">AMDPAL Code Object Hardware Stage Metadata Map</span><a class="headerlink" href="#amdgpu-amdpal-code-object-hardware-stage-metadata-map-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 23%" />
<col style="width: 13%" />
<col style="width: 8%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>String Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Required?</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“.entry_point”</p></td>
<td><p>string</p></td>
<td></td>
<td><p>The ELF symbol pointing to this pipeline’s stage entry point.</p></td>
</tr>
<tr class="row-odd"><td><p>“.scratch_memory_size”</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>Scratch memory size in bytes.</p></td>
</tr>
<tr class="row-even"><td><p>“.lds_size”</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>Local Data Share size in bytes.</p></td>
</tr>
<tr class="row-odd"><td><p>“.perf_data_buffer_size”</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>Performance data buffer size in bytes.</p></td>
</tr>
<tr class="row-even"><td><p>“.vgpr_count”</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>Number of VGPRs used.</p></td>
</tr>
<tr class="row-odd"><td><p>“.sgpr_count”</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>Number of SGPRs used.</p></td>
</tr>
<tr class="row-even"><td><p>“.vgpr_limit”</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>If non-zero, indicates the shader was compiled with a
directive to instruct the compiler to limit the VGPR usage to
be less than or equal to the specified value (only set if
different from HW default).</p></td>
</tr>
<tr class="row-odd"><td><p>“.sgpr_limit”</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>SGPR count upper limit (only set if different from HW
default).</p></td>
</tr>
<tr class="row-even"><td><p>“.threadgroup_dimensions”</p></td>
<td><p>sequence of
3 integers</p></td>
<td></td>
<td><p>Thread-group X/Y/Z dimensions (Compute only).</p></td>
</tr>
<tr class="row-odd"><td><p>“.wavefront_size”</p></td>
<td><p>integer</p></td>
<td></td>
<td><p>Wavefront size (only set if different from HW default).</p></td>
</tr>
<tr class="row-even"><td><p>“.uses_uavs”</p></td>
<td><p>boolean</p></td>
<td></td>
<td><p>The shader reads or writes UAVs.</p></td>
</tr>
<tr class="row-odd"><td><p>“.uses_rovs”</p></td>
<td><p>boolean</p></td>
<td></td>
<td><p>The shader reads or writes ROVs.</p></td>
</tr>
<tr class="row-even"><td><p>“.writes_uavs”</p></td>
<td><p>boolean</p></td>
<td></td>
<td><p>The shader writes to one or more UAVs.</p></td>
</tr>
<tr class="row-odd"><td><p>“.writes_depth”</p></td>
<td><p>boolean</p></td>
<td></td>
<td><p>The shader writes out a depth value.</p></td>
</tr>
<tr class="row-even"><td><p>“.uses_append_consume”</p></td>
<td><p>boolean</p></td>
<td></td>
<td><p>The shader uses append and/or consume operations, either
memory or GDS.</p></td>
</tr>
<tr class="row-odd"><td><p>“.uses_prim_id”</p></td>
<td><p>boolean</p></td>
<td></td>
<td><p>The shader uses PrimID.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdpal-code-object-shader-function-map-table">
<caption><span class="caption-text">AMDPAL Code Object Shader Function Map</span><a class="headerlink" href="#amdgpu-amdpal-code-object-shader-function-map-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 14%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>String Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>symbol name</em></p></td>
<td><p>map</p></td>
<td><p><em>symbol name</em> is the ELF symbol name of the shader function code
entry address. The value is the function’s metadata. See
<a class="reference internal" href="#amdgpu-amdpal-code-object-shader-function-metadata-map-table"><span class="std std-ref">AMDPAL Code Object Shader Function Metadata Map</span></a>.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdpal-code-object-shader-function-metadata-map-table">
<caption><span class="caption-text">AMDPAL Code Object Shader Function Metadata Map</span><a class="headerlink" href="#amdgpu-amdpal-code-object-shader-function-metadata-map-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 27%" />
<col style="width: 13%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>String Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“.api_shader_hash”</p></td>
<td><p>sequence of
2 integers</p></td>
<td><p>Input shader hash, typically passed in from the client. The value
is implementation defined, and can not be relied on between
different builds of the compiler.</p></td>
</tr>
<tr class="row-odd"><td><p>“.scratch_memory_size”</p></td>
<td><p>integer</p></td>
<td><p>Size in bytes of scratch memory used by the shader.</p></td>
</tr>
<tr class="row-even"><td><p>“.lds_size”</p></td>
<td><p>integer</p></td>
<td><p>Size in bytes of LDS memory.</p></td>
</tr>
<tr class="row-odd"><td><p>“.vgpr_count”</p></td>
<td><p>integer</p></td>
<td><p>Number of VGPRs used by the shader.</p></td>
</tr>
<tr class="row-even"><td><p>“.sgpr_count”</p></td>
<td><p>integer</p></td>
<td><p>Number of SGPRs used by the shader.</p></td>
</tr>
<tr class="row-odd"><td><p>“.stack_frame_size_in_bytes”</p></td>
<td><p>integer</p></td>
<td><p>Amount of stack size used by the shader.</p></td>
</tr>
<tr class="row-even"><td><p>“.shader_subtype”</p></td>
<td><p>string</p></td>
<td><p>Shader subtype/kind. Values include:</p>
<blockquote>
<div><ul class="simple">
<li><p>“Unknown”</p></li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</div></blockquote>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdpal-code-object-register-map-table">
<caption><span class="caption-text">AMDPAL Code Object Register Map</span><a class="headerlink" href="#amdgpu-amdpal-code-object-register-map-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 24%" />
<col style="width: 13%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>32-bit Integer Key</p></th>
<th class="head"><p>Value Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">reg</span> <span class="pre">offset</span></code></p></td>
<td><p>32-bit integer</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">reg</span> <span class="pre">offset</span></code> is the dword offset into the GFXIP register space of
a GRBM register (i.e., driver accessible GPU register number, not
shader GPR register number). The driver is required to program each
specified register to the corresponding specified value when
executing this pipeline. Typically, the <code class="docutils literal notranslate"><span class="pre">reg</span> <span class="pre">offsets</span></code> are the
<code class="docutils literal notranslate"><span class="pre">uint16_t</span></code> offsets to each register as defined by the hardware
chip headers. The register is set to the provided value. However, a
<code class="docutils literal notranslate"><span class="pre">reg</span> <span class="pre">offset</span></code> that specifies a user data register (e.g.,
COMPUTE_USER_DATA_0) needs special treatment. See
<a class="reference internal" href="#amdgpu-amdpal-code-object-user-data-section"><span class="std std-ref">User Data</span></a> section for more
information.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<div class="section" id="user-data">
<span id="amdgpu-amdpal-code-object-user-data-section"></span><h5><a class="toc-backref" href="#id162">User Data</a><a class="headerlink" href="#user-data" title="Permalink to this headline">¶</a></h5>
<p>Each hardware stage has a set of 32-bit physical SPI <em>user data registers</em>
(either 16 or 32 based on graphics IP and the stage) which can be
written from a command buffer and then loaded into SGPRs when waves are
launched via a subsequent dispatch or draw operation. This is the way
most arguments are passed from the application/runtime to a hardware
shader.</p>
<p>PAL abstracts this functionality by exposing a set of 128 <em>user data
entries</em> per pipeline a client can use to pass arguments from a command
buffer to one or more shaders in that pipeline. The ELF code object must
specify a mapping from virtualized <em>user data entries</em> to physical <em>user
data registers</em>, and PAL is responsible for implementing that mapping,
including spilling overflow <em>user data entries</em> to memory if needed.</p>
<p>Since the <em>user data registers</em> are GRBM-accessible SPI registers, this
mapping is actually embedded in the <code class="docutils literal notranslate"><span class="pre">.registers</span></code> metadata entry. For
most registers, the value in that map is a literal 32-bit value that
should be written to the register by the driver. However, when the
register is a <em>user data register</em> (any USER_DATA register e.g.,
SPI_SHADER_USER_DATA_PS_5), the value is instead an encoding that tells
the driver to write either a <em>user data entry</em> value or one of several
driver-internal values to the register. This encoding is described in
the following table:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, <em>user data registers</em> 0 and 1 (e.g., SPI_SHADER_USER_DATA_PS_0,
and SPI_SHADER_USER_DATA_PS_1) are reserved. <em>User data register</em> 0 must
always be programmed to the address of the GlobalTable, and <em>user data
register</em> 1 must always be programmed to the address of the PerShaderTable.</p>
</div>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-amdpal-code-object-metadata-user-data-mapping-table">
<caption><span class="caption-text">AMDPAL User Data Mapping</span><a class="headerlink" href="#amdgpu-amdpal-code-object-metadata-user-data-mapping-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 9%" />
<col style="width: 16%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0..127</p></td>
<td><p><em>User Data Entry</em></p></td>
<td><p>32-bit value of user_data_entry[N] as specified via <em>CmdSetUserData()</em></p></td>
</tr>
<tr class="row-odd"><td><p>0x10000000</p></td>
<td><p>GlobalTable</p></td>
<td><p>32-bit pointer to GPU memory containing the global internal table (should
always point to <em>user data register</em> 0).</p></td>
</tr>
<tr class="row-even"><td><p>0x10000001</p></td>
<td><p>PerShaderTable</p></td>
<td><p>32-bit pointer to GPU memory containing the per-shader internal table. See
<a class="reference internal" href="#amdgpu-amdpal-code-object-metadata-user-data-per-shader-table-section"><span class="std std-ref">Per-Shader Table</span></a>
for more detail (should always point to <em>user data register</em> 1).</p></td>
</tr>
<tr class="row-odd"><td><p>0x10000002</p></td>
<td><p>SpillTable</p></td>
<td><p>32-bit pointer to GPU memory containing the user data spill table. See
<a class="reference internal" href="#amdgpu-amdpal-code-object-metadata-user-data-spill-table-section"><span class="std std-ref">Spill Table</span></a> for
more detail.</p></td>
</tr>
<tr class="row-even"><td><p>0x10000003</p></td>
<td><p>BaseVertex</p></td>
<td><p>Vertex offset (32-bit unsigned integer). Not needed if the pipeline doesn’t
reference the draw index in the vertex shader. Only supported by the first
stage in a graphics pipeline.</p></td>
</tr>
<tr class="row-odd"><td><p>0x10000004</p></td>
<td><p>BaseInstance</p></td>
<td><p>Instance offset (32-bit unsigned integer). Only supported by the first stage in
a graphics pipeline.</p></td>
</tr>
<tr class="row-even"><td><p>0x10000005</p></td>
<td><p>DrawIndex</p></td>
<td><p>Draw index (32-bit unsigned integer). Only supported by the first stage in a
graphics pipeline.</p></td>
</tr>
<tr class="row-odd"><td><p>0x10000006</p></td>
<td><p>Workgroup</p></td>
<td><p>Thread group count (32-bit unsigned integer). Low half of a 64-bit address of
a buffer containing the grid dimensions for a Compute dispatch operation. The
high half of the address is stored in the next sequential user-SGPR. Only
supported by compute pipelines.</p></td>
</tr>
<tr class="row-even"><td><p>0x1000000A</p></td>
<td><p>EsGsLdsSize</p></td>
<td><p>Indicates that PAL will program this user-SGPR to contain the amount of LDS
space used for the ES/GS pseudo-ring-buffer for passing data between shader
stages.</p></td>
</tr>
<tr class="row-odd"><td><p>0x1000000B</p></td>
<td><p>ViewId</p></td>
<td><p>View id (32-bit unsigned integer) identifies a view of graphic
pipeline instancing.</p></td>
</tr>
<tr class="row-even"><td><p>0x1000000C</p></td>
<td><p>StreamOutTable</p></td>
<td><p>32-bit pointer to GPU memory containing the stream out target SRD table.  This
can only appear for one shader stage per pipeline.</p></td>
</tr>
<tr class="row-odd"><td><p>0x1000000D</p></td>
<td><p>PerShaderPerfData</p></td>
<td><p>32-bit pointer to GPU memory containing the per-shader performance data buffer.</p></td>
</tr>
<tr class="row-even"><td><p>0x1000000F</p></td>
<td><p>VertexBufferTable</p></td>
<td><p>32-bit pointer to GPU memory containing the vertex buffer SRD table.  This can
only appear for one shader stage per pipeline.</p></td>
</tr>
<tr class="row-odd"><td><p>0x10000010</p></td>
<td><p>UavExportTable</p></td>
<td><p>32-bit pointer to GPU memory containing the UAV export SRD table.  This can
only appear for one shader stage per pipeline (PS). These replace color targets
and are completely separate from any UAVs used by the shader. This is optional,
and only used by the PS when UAV exports are used to replace color-target
exports to optimize specific shaders.</p></td>
</tr>
<tr class="row-even"><td><p>0x10000011</p></td>
<td><p>NggCullingData</p></td>
<td><p>64-bit pointer to GPU memory containing the hardware register data needed by
some NGG pipelines to perform culling.  This value contains the address of the
first of two consecutive registers which provide the full GPU address.</p></td>
</tr>
<tr class="row-odd"><td><p>0x10000015</p></td>
<td><p>FetchShaderPtr</p></td>
<td><p>64-bit pointer to GPU memory containing the fetch shader subroutine.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<div class="section" id="per-shader-table">
<span id="amdgpu-amdpal-code-object-metadata-user-data-per-shader-table-section"></span><h6><a class="toc-backref" href="#id163">Per-Shader Table</a><a class="headerlink" href="#per-shader-table" title="Permalink to this headline">¶</a></h6>
<p>Low 32 bits of the GPU address for an optional buffer in the <code class="docutils literal notranslate"><span class="pre">.data</span></code>
section of the ELF. The high 32 bits of the address match the high 32 bits
of the shader’s program counter.</p>
<p>The buffer can be anything the shader compiler needs it for, and
allows each shader to have its own region of the <code class="docutils literal notranslate"><span class="pre">.data</span></code> section.
Typically, this could be a table of buffer SRD’s and the data pointed to
by the buffer SRD’s, but it could be a flat-address region of memory as
well. Its layout and usage are defined by the shader compiler.</p>
<p>Each shader’s table in the <code class="docutils literal notranslate"><span class="pre">.data</span></code> section is referenced by the symbol
<code class="docutils literal notranslate"><span class="pre">_amdgpu_</span></code><em>xs</em><code class="docutils literal notranslate"><span class="pre">_shdr_intrl_data</span></code>  where <em>xs</em> corresponds with the
hardware shader stage the data is for. E.g.,
<code class="docutils literal notranslate"><span class="pre">_amdgpu_cs_shdr_intrl_data</span></code> for the compute shader hardware stage.</p>
</div>
<div class="section" id="spill-table">
<span id="amdgpu-amdpal-code-object-metadata-user-data-spill-table-section"></span><h6><a class="toc-backref" href="#id164">Spill Table</a><a class="headerlink" href="#spill-table" title="Permalink to this headline">¶</a></h6>
<p>It is possible for a hardware shader to need access to more <em>user data
entries</em> than there are slots available in user data registers for one
or more hardware shader stages. In that case, the PAL runtime expects
the necessary <em>user data entries</em> to be spilled to GPU memory and use
one user data register to point to the spilled user data memory. The
value of the <em>user data entry</em> must then represent the location where
a shader expects to read the low 32-bits of the table’s GPU virtual
address. The <em>spill table</em> itself represents a set of 32-bit values
managed by the PAL runtime in GPU-accessible memory that can be made
indirectly accessible to a hardware shader.</p>
</div>
</div>
</div>
</div>
<div class="section" id="unspecified-os">
<h3><a class="toc-backref" href="#id165">Unspecified OS</a><a class="headerlink" href="#unspecified-os" title="Permalink to this headline">¶</a></h3>
<p>This section provides code conventions used when the target triple OS is
empty (see <a class="reference internal" href="#amdgpu-target-triples"><span class="std std-ref">Target Triples</span></a>).</p>
<div class="section" id="id82">
<h4><a class="toc-backref" href="#id166">Trap Handler ABI</a><a class="headerlink" href="#id82" title="Permalink to this headline">¶</a></h4>
<p>For code objects generated by AMDGPU backend for non-amdhsa OS, the runtime does
not install a trap handler. The <code class="docutils literal notranslate"><span class="pre">llvm.trap</span></code> and <code class="docutils literal notranslate"><span class="pre">llvm.debugtrap</span></code>
instructions are handled as follows:</p>
<blockquote>
<div><table class="docutils align-default" id="amdgpu-trap-handler-for-non-amdhsa-os-table">
<caption><span class="caption-text">AMDGPU Trap Handler for Non-AMDHSA OS</span><a class="headerlink" href="#amdgpu-trap-handler-for-non-amdhsa-os-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 21%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Usage</p></th>
<th class="head"><p>Code Sequence</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>llvm.trap</p></td>
<td><p>s_endpgm</p></td>
<td><p>Causes wavefront to be terminated.</p></td>
</tr>
<tr class="row-odd"><td><p>llvm.debugtrap</p></td>
<td><p><em>none</em></p></td>
<td><p>Compiler warning given that there is no
trap handler installed.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="source-languages">
<h2><a class="toc-backref" href="#id167">Source Languages</a><a class="headerlink" href="#source-languages" title="Permalink to this headline">¶</a></h2>
<div class="section" id="opencl">
<span id="amdgpu-opencl"></span><h3><a class="toc-backref" href="#id168">OpenCL</a><a class="headerlink" href="#opencl" title="Permalink to this headline">¶</a></h3>
<p>When the language is OpenCL the following differences occur:</p>
<ol class="arabic simple">
<li><p>The OpenCL memory model is used (see <a class="reference internal" href="#amdgpu-amdhsa-memory-model"><span class="std std-ref">Memory Model</span></a>).</p></li>
<li><p>The AMDGPU backend appends additional arguments to the kernel’s explicit
arguments for the AMDHSA OS (see
<a class="reference internal" href="#opencl-kernel-implicit-arguments-appended-for-amdhsa-os-table"><span class="std std-ref">OpenCL kernel implicit arguments appended for AMDHSA OS</span></a>).</p></li>
<li><p>Additional metadata is generated
(see <a class="reference internal" href="#amdgpu-amdhsa-code-object-metadata"><span class="std std-ref">Code Object Metadata</span></a>).</p></li>
</ol>
<blockquote>
<div><table class="docutils align-default" id="opencl-kernel-implicit-arguments-appended-for-amdhsa-os-table">
<caption><span class="caption-text">OpenCL kernel implicit arguments appended for AMDHSA OS</span><a class="headerlink" href="#opencl-kernel-implicit-arguments-appended-for-amdhsa-os-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 13%" />
<col style="width: 6%" />
<col style="width: 14%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Position</p></th>
<th class="head"><p>Byte
Size</p></th>
<th class="head"><p>Byte
Alignment</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>8</p></td>
<td><p>8</p></td>
<td><p>OpenCL Global Offset X</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>8</p></td>
<td><p>8</p></td>
<td><p>OpenCL Global Offset Y</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>8</p></td>
<td><p>8</p></td>
<td><p>OpenCL Global Offset Z</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>8</p></td>
<td><p>8</p></td>
<td><p>OpenCL address of printf buffer</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>8</p></td>
<td><p>8</p></td>
<td><p>OpenCL address of virtual queue used by
enqueue_kernel.</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>8</p></td>
<td><p>8</p></td>
<td><p>OpenCL address of AqlWrap struct used by
enqueue_kernel.</p></td>
</tr>
<tr class="row-even"><td><p>7</p></td>
<td><p>8</p></td>
<td><p>8</p></td>
<td><p>Pointer argument used for Multi-gird
synchronization.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="hcc">
<span id="amdgpu-hcc"></span><h3><a class="toc-backref" href="#id169">HCC</a><a class="headerlink" href="#hcc" title="Permalink to this headline">¶</a></h3>
<p>When the language is HCC the following differences occur:</p>
<ol class="arabic simple">
<li><p>The HSA memory model is used (see <a class="reference internal" href="#amdgpu-amdhsa-memory-model"><span class="std std-ref">Memory Model</span></a>).</p></li>
</ol>
</div>
<div class="section" id="assembler">
<span id="amdgpu-assembler"></span><h3><a class="toc-backref" href="#id170">Assembler</a><a class="headerlink" href="#assembler" title="Permalink to this headline">¶</a></h3>
<p>AMDGPU backend has LLVM-MC based assembler which is currently in development.
It supports AMDGCN GFX6-GFX10.</p>
<p>This section describes general syntax for instructions and operands.</p>
<div class="section" id="instructions">
<h4><a class="toc-backref" href="#id171">Instructions</a><a class="headerlink" href="#instructions" title="Permalink to this headline">¶</a></h4>
<p>An instruction has the following <a class="reference internal" href="AMDGPUInstructionSyntax.html"><span class="doc">syntax</span></a>:</p>
<blockquote>
<div><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">&lt;</span></code><em>opcode</em><code class="docutils literal notranslate"><span class="pre">&gt;</span> <span class="pre">&lt;</span></code><em>operand0</em><code class="docutils literal notranslate"><span class="pre">&gt;,</span> <span class="pre">&lt;</span></code><em>operand1</em><code class="docutils literal notranslate"><span class="pre">&gt;,...</span>
<span class="pre">&lt;</span></code><em>modifier0</em><code class="docutils literal notranslate"><span class="pre">&gt;</span> <span class="pre">&lt;</span></code><em>modifier1</em><code class="docutils literal notranslate"><span class="pre">&gt;...</span></code></div>
</div>
</div></blockquote>
<p><a class="reference internal" href="AMDGPUOperandSyntax.html"><span class="doc">Operands</span></a> are comma-separated while
<a class="reference internal" href="AMDGPUModifierSyntax.html"><span class="doc">modifiers</span></a> are space-separated.</p>
<p>The order of operands and modifiers is fixed.
Most modifiers are optional and may be omitted.</p>
<p>Links to detailed instruction syntax description may be found in the following
table. Note that features under development are not included
in this description.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 47%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Core ISA</p></th>
<th class="head"><p>ISA Extensions</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="AMDGPU/AMDGPUAsmGFX7.html"><span class="doc">GFX7</span></a></p></td>
<td><p>-</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="AMDGPU/AMDGPUAsmGFX8.html"><span class="doc">GFX8</span></a></p></td>
<td><p>-</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="AMDGPU/AMDGPUAsmGFX9.html"><span class="doc">GFX9</span></a></p></td>
<td><p><a class="reference internal" href="AMDGPU/AMDGPUAsmGFX900.html"><span class="doc">gfx900</span></a></p>
<p><a class="reference internal" href="AMDGPU/AMDGPUAsmGFX900.html"><span class="doc">gfx902</span></a></p>
<p><a class="reference internal" href="AMDGPU/AMDGPUAsmGFX904.html"><span class="doc">gfx904</span></a></p>
<p><a class="reference internal" href="AMDGPU/AMDGPUAsmGFX906.html"><span class="doc">gfx906</span></a></p>
<p><a class="reference internal" href="AMDGPU/AMDGPUAsmGFX908.html"><span class="doc">gfx908</span></a></p>
<p><a class="reference internal" href="AMDGPU/AMDGPUAsmGFX900.html"><span class="doc">gfx909</span></a></p>
<p><a class="reference internal" href="AMDGPU/AMDGPUAsmGFX90a.html"><span class="doc">gfx90a</span></a></p>
</td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="AMDGPU/AMDGPUAsmGFX10.html"><span class="doc">GFX10</span></a></p></td>
<td><p><a class="reference internal" href="AMDGPU/AMDGPUAsmGFX1011.html"><span class="doc">gfx1011</span></a></p>
<p><a class="reference internal" href="AMDGPU/AMDGPUAsmGFX1011.html"><span class="doc">gfx1012</span></a></p>
</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>For more information about instructions, their semantics and supported
combinations of operands, refer to one of instruction set architecture manuals
<a class="reference internal" href="#amd-gcn-gfx6" id="id83"><span>[AMD-GCN-GFX6]</span></a>, <a class="reference internal" href="#amd-gcn-gfx7" id="id84"><span>[AMD-GCN-GFX7]</span></a>, <a class="reference internal" href="#amd-gcn-gfx8" id="id85"><span>[AMD-GCN-GFX8]</span></a>,
<a class="reference internal" href="#amd-gcn-gfx900-gfx904-vega" id="id86"><span>[AMD-GCN-GFX900-GFX904-VEGA]</span></a>, <a class="reference internal" href="#amd-gcn-gfx906-vega7nm" id="id87"><span>[AMD-GCN-GFX906-VEGA7NM]</span></a>
<a class="reference internal" href="#amd-gcn-gfx908-cdna1" id="id88"><span>[AMD-GCN-GFX908-CDNA1]</span></a>, <a class="reference internal" href="#amd-gcn-gfx10-rdna1" id="id89"><span>[AMD-GCN-GFX10-RDNA1]</span></a> and <a class="reference internal" href="#amd-gcn-gfx10-rdna2" id="id90"><span>[AMD-GCN-GFX10-RDNA2]</span></a>.</p>
</div>
<div class="section" id="operands">
<h4><a class="toc-backref" href="#id172">Operands</a><a class="headerlink" href="#operands" title="Permalink to this headline">¶</a></h4>
<p>Detailed description of operands may be found <a class="reference internal" href="AMDGPUOperandSyntax.html"><span class="doc">here</span></a>.</p>
</div>
<div class="section" id="modifiers">
<h4><a class="toc-backref" href="#id173">Modifiers</a><a class="headerlink" href="#modifiers" title="Permalink to this headline">¶</a></h4>
<p>Detailed description of modifiers may be found
<a class="reference internal" href="AMDGPUModifierSyntax.html"><span class="doc">here</span></a>.</p>
</div>
<div class="section" id="instruction-examples">
<h4><a class="toc-backref" href="#id174">Instruction Examples</a><a class="headerlink" href="#instruction-examples" title="Permalink to this headline">¶</a></h4>
<div class="section" id="ds">
<h5><a class="toc-backref" href="#id175">DS</a><a class="headerlink" href="#ds" title="Permalink to this headline">¶</a></h5>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span></span><span class="nf">ds_add_u32</span> <span class="nv">v2</span><span class="p">,</span> <span class="nv">v4</span> <span class="nv">offset</span><span class="p">:</span><span class="mi">16</span>
<span class="nf">ds_write_src2_b64</span> <span class="nv">v2</span> <span class="nv">offset0</span><span class="p">:</span><span class="mi">4</span> <span class="nv">offset1</span><span class="p">:</span><span class="mi">8</span>
<span class="nf">ds_cmpst_f32</span> <span class="nv">v2</span><span class="p">,</span> <span class="nv">v4</span><span class="p">,</span> <span class="nv">v6</span>
<span class="nf">ds_min_rtn_f64</span> <span class="nv">v</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">9</span><span class="p">],</span> <span class="nv">v2</span><span class="p">,</span> <span class="nv">v</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p>For full list of supported instructions, refer to “LDS/GDS instructions” in ISA
Manual.</p>
</div>
<div class="section" id="flat">
<h5><a class="toc-backref" href="#id176">FLAT</a><a class="headerlink" href="#flat" title="Permalink to this headline">¶</a></h5>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span></span><span class="nf">flat_load_dword</span> <span class="nv">v1</span><span class="p">,</span> <span class="nv">v</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">flat_store_dwordx3</span> <span class="nv">v</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span> <span class="nv">v</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span>
<span class="nf">flat_atomic_swap</span> <span class="nv">v1</span><span class="p">,</span> <span class="nv">v</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span> <span class="nv">v5</span> <span class="nv">glc</span>
<span class="nf">flat_atomic_cmpswap</span> <span class="nv">v1</span><span class="p">,</span> <span class="nv">v</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span> <span class="nv">v</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="nv">glc</span> <span class="nv">slc</span>
<span class="nf">flat_atomic_fmax_x2</span> <span class="nv">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="nv">v</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span> <span class="nv">v</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="nv">glc</span>
</pre></div>
</div>
<p>For full list of supported instructions, refer to “FLAT instructions” in ISA
Manual.</p>
</div>
<div class="section" id="mubuf">
<h5><a class="toc-backref" href="#id177">MUBUF</a><a class="headerlink" href="#mubuf" title="Permalink to this headline">¶</a></h5>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span></span><span class="nf">buffer_load_dword</span> <span class="nv">v1</span><span class="p">,</span> <span class="nv">off</span><span class="p">,</span> <span class="nv">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">],</span> <span class="nv">s1</span>
<span class="nf">buffer_store_dwordx4</span> <span class="nv">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span> <span class="nv">v2</span><span class="p">,</span> <span class="nv">ttmp</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">],</span> <span class="nv">s1</span> <span class="nv">offen</span> <span class="nv">offset</span><span class="p">:</span><span class="mi">4</span> <span class="nv">glc</span> <span class="nv">tfe</span>
<span class="nf">buffer_store_format_xy</span> <span class="nv">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="nv">off</span><span class="p">,</span> <span class="nv">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">],</span> <span class="nv">s1</span>
<span class="nf">buffer_wbinvl1</span>
<span class="nf">buffer_atomic_inc</span> <span class="nv">v1</span><span class="p">,</span> <span class="nv">v2</span><span class="p">,</span> <span class="nv">s</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">11</span><span class="p">],</span> <span class="nv">s4</span> <span class="nv">idxen</span> <span class="nv">offset</span><span class="p">:</span><span class="mi">4</span> <span class="nv">slc</span>
</pre></div>
</div>
<p>For full list of supported instructions, refer to “MUBUF Instructions” in ISA
Manual.</p>
</div>
<div class="section" id="smrd-smem">
<h5><a class="toc-backref" href="#id178">SMRD/SMEM</a><a class="headerlink" href="#smrd-smem" title="Permalink to this headline">¶</a></h5>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span></span><span class="nf">s_load_dword</span> <span class="nv">s1</span><span class="p">,</span> <span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="mh">0xfc</span>
<span class="nf">s_load_dwordx8</span> <span class="nv">s</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">15</span><span class="p">],</span> <span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="nv">s4</span>
<span class="nf">s_load_dwordx16</span> <span class="nv">s</span><span class="p">[</span><span class="mi">88</span><span class="p">:</span><span class="mi">103</span><span class="p">],</span> <span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="nv">s4</span>
<span class="nf">s_dcache_inv_vol</span>
<span class="nf">s_memtime</span> <span class="nv">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p>For full list of supported instructions, refer to “Scalar Memory Operations” in
ISA Manual.</p>
</div>
<div class="section" id="sop1">
<h5><a class="toc-backref" href="#id179">SOP1</a><a class="headerlink" href="#sop1" title="Permalink to this headline">¶</a></h5>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span></span><span class="nf">s_mov_b32</span> <span class="nv">s1</span><span class="p">,</span> <span class="nv">s2</span>
<span class="nf">s_mov_b64</span> <span class="nv">s</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="mh">0x80000000</span>
<span class="nf">s_cmov_b32</span> <span class="nv">s1</span><span class="p">,</span> <span class="mi">200</span>
<span class="nf">s_wqm_b64</span> <span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="nv">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">s_bcnt0_i32_b64</span> <span class="nv">s1</span><span class="p">,</span> <span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="nf">s_swappc_b64</span> <span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="nv">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">s_cbranch_join</span> <span class="nv">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p>For full list of supported instructions, refer to “SOP1 Instructions” in ISA
Manual.</p>
</div>
<div class="section" id="sop2">
<h5><a class="toc-backref" href="#id180">SOP2</a><a class="headerlink" href="#sop2" title="Permalink to this headline">¶</a></h5>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span></span><span class="nf">s_add_u32</span> <span class="nv">s1</span><span class="p">,</span> <span class="nv">s2</span><span class="p">,</span> <span class="nv">s3</span>
<span class="nf">s_and_b64</span> <span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="nv">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">],</span> <span class="nv">s</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span>
<span class="nf">s_cselect_b32</span> <span class="nv">s1</span><span class="p">,</span> <span class="nv">s2</span><span class="p">,</span> <span class="nv">s3</span>
<span class="nf">s_andn2_b32</span> <span class="nv">s2</span><span class="p">,</span> <span class="nv">s4</span><span class="p">,</span> <span class="nv">s6</span>
<span class="nf">s_lshr_b64</span> <span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="nv">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">],</span> <span class="nv">s6</span>
<span class="nf">s_ashr_i32</span> <span class="nv">s2</span><span class="p">,</span> <span class="nv">s4</span><span class="p">,</span> <span class="nv">s6</span>
<span class="nf">s_bfm_b64</span> <span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="nv">s4</span><span class="p">,</span> <span class="nv">s6</span>
<span class="nf">s_bfe_i64</span> <span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="nv">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">],</span> <span class="nv">s6</span>
<span class="nf">s_cbranch_g_fork</span> <span class="nv">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">],</span> <span class="nv">s</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span>
</pre></div>
</div>
<p>For full list of supported instructions, refer to “SOP2 Instructions” in ISA
Manual.</p>
</div>
<div class="section" id="sopc">
<h5><a class="toc-backref" href="#id181">SOPC</a><a class="headerlink" href="#sopc" title="Permalink to this headline">¶</a></h5>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span></span><span class="nf">s_cmp_eq_i32</span> <span class="nv">s1</span><span class="p">,</span> <span class="nv">s2</span>
<span class="nf">s_bitcmp1_b32</span> <span class="nv">s1</span><span class="p">,</span> <span class="nv">s2</span>
<span class="nf">s_bitcmp0_b64</span> <span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="nv">s4</span>
<span class="nf">s_setvskip</span> <span class="nv">s3</span><span class="p">,</span> <span class="nv">s5</span>
</pre></div>
</div>
<p>For full list of supported instructions, refer to “SOPC Instructions” in ISA
Manual.</p>
</div>
<div class="section" id="sopp">
<h5><a class="toc-backref" href="#id182">SOPP</a><a class="headerlink" href="#sopp" title="Permalink to this headline">¶</a></h5>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span></span><span class="nf">s_barrier</span>
<span class="nf">s_nop</span> <span class="mi">2</span>
<span class="nf">s_endpgm</span>
<span class="nf">s_waitcnt</span> <span class="mi">0</span> <span class="c1">; Wait for all counters to be 0</span>
<span class="nf">s_waitcnt</span> <span class="nv">vmcnt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nv">expcnt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nv">lgkmcnt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">; Equivalent to above</span>
<span class="nf">s_waitcnt</span> <span class="nv">vmcnt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">; Wait for vmcnt counter to be 1.</span>
<span class="nf">s_sethalt</span> <span class="mi">9</span>
<span class="nf">s_sleep</span> <span class="mi">10</span>
<span class="nf">s_sendmsg</span> <span class="mh">0x1</span>
<span class="nf">s_sendmsg</span> <span class="nv">sendmsg</span><span class="p">(</span><span class="nv">MSG_INTERRUPT</span><span class="p">)</span>
<span class="nf">s_trap</span> <span class="mi">1</span>
</pre></div>
</div>
<p>For full list of supported instructions, refer to “SOPP Instructions” in ISA
Manual.</p>
<p>Unless otherwise mentioned, little verification is performed on the operands
of SOPP Instructions, so it is up to the programmer to be familiar with the
range or acceptable values.</p>
</div>
<div class="section" id="valu">
<h5><a class="toc-backref" href="#id183">VALU</a><a class="headerlink" href="#valu" title="Permalink to this headline">¶</a></h5>
<p>For vector ALU instruction opcodes (VOP1, VOP2, VOP3, VOPC, VOP_DPP, VOP_SDWA),
the assembler will automatically use optimal encoding based on its operands. To
force specific encoding, one can add a suffix to the opcode of the instruction:</p>
<ul class="simple">
<li><p>_e32 for 32-bit VOP1/VOP2/VOPC</p></li>
<li><p>_e64 for 64-bit VOP3</p></li>
<li><p>_dpp for VOP_DPP</p></li>
<li><p>_sdwa for VOP_SDWA</p></li>
</ul>
<p>VOP1/VOP2/VOP3/VOPC examples:</p>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span></span><span class="nf">v_mov_b32</span> <span class="nv">v1</span><span class="p">,</span> <span class="nv">v2</span>
<span class="nf">v_mov_b32_e32</span> <span class="nv">v1</span><span class="p">,</span> <span class="nv">v2</span>
<span class="nf">v_nop</span>
<span class="nf">v_cvt_f64_i32_e32</span> <span class="nv">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="nv">v2</span>
<span class="nf">v_floor_f32_e32</span> <span class="nv">v1</span><span class="p">,</span> <span class="nv">v2</span>
<span class="nf">v_bfrev_b32_e32</span> <span class="nv">v1</span><span class="p">,</span> <span class="nv">v2</span>
<span class="nf">v_add_f32_e32</span> <span class="nv">v1</span><span class="p">,</span> <span class="nv">v2</span><span class="p">,</span> <span class="nv">v3</span>
<span class="nf">v_mul_i32_i24_e64</span> <span class="nv">v1</span><span class="p">,</span> <span class="nv">v2</span><span class="p">,</span> <span class="mi">3</span>
<span class="nf">v_mul_i32_i24_e32</span> <span class="nv">v1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="nv">v3</span>
<span class="nf">v_mul_i32_i24_e32</span> <span class="nv">v1</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="nv">v3</span>
<span class="nf">v_addc_u32</span> <span class="nv">v1</span><span class="p">,</span> <span class="nv">s</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="nv">v2</span><span class="p">,</span> <span class="nv">v3</span><span class="p">,</span> <span class="nv">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="nf">v_max_f16_e32</span> <span class="nv">v1</span><span class="p">,</span> <span class="nv">v2</span><span class="p">,</span> <span class="nv">v3</span>
</pre></div>
</div>
<p>VOP_DPP examples:</p>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span></span><span class="nf">v_mov_b32</span> <span class="nv">v0</span><span class="p">,</span> <span class="nv">v0</span> <span class="nv">quad_perm</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="nf">v_sin_f32</span> <span class="nv">v0</span><span class="p">,</span> <span class="nv">v0</span> <span class="nv">row_shl</span><span class="p">:</span><span class="mi">1</span> <span class="nv">row_mask</span><span class="p">:</span><span class="mh">0xa</span> <span class="nv">bank_mask</span><span class="p">:</span><span class="mh">0x1</span> <span class="nv">bound_ctrl</span><span class="p">:</span><span class="mi">0</span>
<span class="nf">v_mov_b32</span> <span class="nv">v0</span><span class="p">,</span> <span class="nv">v0</span> <span class="nv">wave_shl</span><span class="p">:</span><span class="mi">1</span>
<span class="nf">v_mov_b32</span> <span class="nv">v0</span><span class="p">,</span> <span class="nv">v0</span> <span class="nv">row_mirror</span>
<span class="nf">v_mov_b32</span> <span class="nv">v0</span><span class="p">,</span> <span class="nv">v0</span> <span class="nv">row_bcast</span><span class="p">:</span><span class="mi">31</span>
<span class="nf">v_mov_b32</span> <span class="nv">v0</span><span class="p">,</span> <span class="nv">v0</span> <span class="nv">quad_perm</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="nv">row_mask</span><span class="p">:</span><span class="mh">0xa</span> <span class="nv">bank_mask</span><span class="p">:</span><span class="mh">0x1</span> <span class="nv">bound_ctrl</span><span class="p">:</span><span class="mi">0</span>
<span class="nf">v_add_f32</span> <span class="nv">v0</span><span class="p">,</span> <span class="nv">v0</span><span class="p">,</span> <span class="o">|</span><span class="nv">v0</span><span class="o">|</span> <span class="nv">row_shl</span><span class="p">:</span><span class="mi">1</span> <span class="nv">row_mask</span><span class="p">:</span><span class="mh">0xa</span> <span class="nv">bank_mask</span><span class="p">:</span><span class="mh">0x1</span> <span class="nv">bound_ctrl</span><span class="p">:</span><span class="mi">0</span>
<span class="nf">v_max_f16</span> <span class="nv">v1</span><span class="p">,</span> <span class="nv">v2</span><span class="p">,</span> <span class="nv">v3</span> <span class="nv">row_shl</span><span class="p">:</span><span class="mi">1</span> <span class="nv">row_mask</span><span class="p">:</span><span class="mh">0xa</span> <span class="nv">bank_mask</span><span class="p">:</span><span class="mh">0x1</span> <span class="nv">bound_ctrl</span><span class="p">:</span><span class="mi">0</span>
</pre></div>
</div>
<p>VOP_SDWA examples:</p>
<div class="highlight-nasm notranslate"><div class="highlight"><pre><span></span><span class="nf">v_mov_b32</span> <span class="nv">v1</span><span class="p">,</span> <span class="nv">v2</span> <span class="nb">ds</span><span class="nv">t_sel</span><span class="p">:</span><span class="kt">BYTE</span><span class="nv">_0</span> <span class="nb">ds</span><span class="nv">t_unused</span><span class="p">:</span><span class="nv">UNUSED_PRESERVE</span> <span class="nv">src0_sel</span><span class="p">:</span><span class="kt">DWORD</span>
<span class="nf">v_min_u32</span> <span class="nv">v200</span><span class="p">,</span> <span class="nv">v200</span><span class="p">,</span> <span class="nv">v1</span> <span class="nb">ds</span><span class="nv">t_sel</span><span class="p">:</span><span class="kt">WORD</span><span class="nv">_1</span> <span class="nb">ds</span><span class="nv">t_unused</span><span class="p">:</span><span class="nv">UNUSED_PAD</span> <span class="nv">src0_sel</span><span class="p">:</span><span class="kt">BYTE</span><span class="nv">_1</span> <span class="nv">src1_sel</span><span class="p">:</span><span class="kt">DWORD</span>
<span class="nf">v_sin_f32</span> <span class="nv">v0</span><span class="p">,</span> <span class="nv">v0</span> <span class="nb">ds</span><span class="nv">t_unused</span><span class="p">:</span><span class="nv">UNUSED_PAD</span> <span class="nv">src0_sel</span><span class="p">:</span><span class="kt">WORD</span><span class="nv">_1</span>
<span class="nf">v_fract_f32</span> <span class="nv">v0</span><span class="p">,</span> <span class="o">|</span><span class="nv">v0</span><span class="o">|</span> <span class="nb">ds</span><span class="nv">t_sel</span><span class="p">:</span><span class="kt">DWORD</span> <span class="nb">ds</span><span class="nv">t_unused</span><span class="p">:</span><span class="nv">UNUSED_PAD</span> <span class="nv">src0_sel</span><span class="p">:</span><span class="kt">WORD</span><span class="nv">_1</span>
<span class="nf">v_cmpx_le_u32</span> <span class="nv">vcc</span><span class="p">,</span> <span class="nv">v1</span><span class="p">,</span> <span class="nv">v2</span> <span class="nv">src0_sel</span><span class="p">:</span><span class="kt">BYTE</span><span class="nv">_2</span> <span class="nv">src1_sel</span><span class="p">:</span><span class="kt">WORD</span><span class="nv">_0</span>
</pre></div>
</div>
<p>For full list of supported instructions, refer to “Vector ALU instructions”.</p>
</div>
</div>
<div class="section" id="code-object-v2-predefined-symbols">
<span id="amdgpu-amdhsa-assembler-predefined-symbols-v2"></span><h4><a class="toc-backref" href="#id184">Code Object V2 Predefined Symbols</a><a class="headerlink" href="#code-object-v2-predefined-symbols" title="Permalink to this headline">¶</a></h4>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Code object V2 is not the default code object version emitted by
this version of LLVM.</p>
</div>
<p>The AMDGPU assembler defines and updates some symbols automatically. These
symbols do not affect code generation.</p>
<div class="section" id="option-machine-version-major">
<h5><a class="toc-backref" href="#id185">.option.machine_version_major</a><a class="headerlink" href="#option-machine-version-major" title="Permalink to this headline">¶</a></h5>
<p>Set to the GFX major generation number of the target being assembled for. For
example, when assembling for a “GFX9” target this will be set to the integer
value “9”. The possible GFX major generation numbers are presented in
<a class="reference internal" href="#amdgpu-processors"><span class="std std-ref">Processors</span></a>.</p>
</div>
<div class="section" id="option-machine-version-minor">
<h5><a class="toc-backref" href="#id186">.option.machine_version_minor</a><a class="headerlink" href="#option-machine-version-minor" title="Permalink to this headline">¶</a></h5>
<p>Set to the GFX minor generation number of the target being assembled for. For
example, when assembling for a “GFX810” target this will be set to the integer
value “1”. The possible GFX minor generation numbers are presented in
<a class="reference internal" href="#amdgpu-processors"><span class="std std-ref">Processors</span></a>.</p>
</div>
<div class="section" id="option-machine-version-stepping">
<h5><a class="toc-backref" href="#id187">.option.machine_version_stepping</a><a class="headerlink" href="#option-machine-version-stepping" title="Permalink to this headline">¶</a></h5>
<p>Set to the GFX stepping generation number of the target being assembled for.
For example, when assembling for a “GFX704” target this will be set to the
integer value “4”. The possible GFX stepping generation numbers are presented
in <a class="reference internal" href="#amdgpu-processors"><span class="std std-ref">Processors</span></a>.</p>
</div>
<div class="section" id="kernel-vgpr-count">
<h5><a class="toc-backref" href="#id188">.kernel.vgpr_count</a><a class="headerlink" href="#kernel-vgpr-count" title="Permalink to this headline">¶</a></h5>
<p>Set to zero each time a
<a class="reference internal" href="#amdgpu-amdhsa-assembler-directive-amdgpu-hsa-kernel"><span class="std std-ref">.amdgpu_hsa_kernel (name)</span></a> directive is
encountered. At each instruction, if the current value of this symbol is less
than or equal to the maximum VGPR number explicitly referenced within that
instruction then the symbol value is updated to equal that VGPR number plus
one.</p>
</div>
<div class="section" id="kernel-sgpr-count">
<h5><a class="toc-backref" href="#id189">.kernel.sgpr_count</a><a class="headerlink" href="#kernel-sgpr-count" title="Permalink to this headline">¶</a></h5>
<p>Set to zero each time a
<a class="reference internal" href="#amdgpu-amdhsa-assembler-directive-amdgpu-hsa-kernel"><span class="std std-ref">.amdgpu_hsa_kernel (name)</span></a> directive is
encountered. At each instruction, if the current value of this symbol is less
than or equal to the maximum VGPR number explicitly referenced within that
instruction then the symbol value is updated to equal that SGPR number plus
one.</p>
</div>
</div>
<div class="section" id="code-object-v2-directives">
<span id="amdgpu-amdhsa-assembler-directives-v2"></span><h4><a class="toc-backref" href="#id190">Code Object V2 Directives</a><a class="headerlink" href="#code-object-v2-directives" title="Permalink to this headline">¶</a></h4>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Code object V2 is not the default code object version emitted by
this version of LLVM.</p>
</div>
<p>AMDGPU ABI defines auxiliary data in output code object. In assembly source,
one can specify them with assembler directives.</p>
<div class="section" id="hsa-code-object-version-major-minor">
<h5><a class="toc-backref" href="#id191">.hsa_code_object_version major, minor</a><a class="headerlink" href="#hsa-code-object-version-major-minor" title="Permalink to this headline">¶</a></h5>
<p><em>major</em> and <em>minor</em> are integers that specify the version of the HSA code
object that will be generated by the assembler.</p>
</div>
<div class="section" id="hsa-code-object-isa-major-minor-stepping-vendor-arch">
<h5><a class="toc-backref" href="#id192">.hsa_code_object_isa [major, minor, stepping, vendor, arch]</a><a class="headerlink" href="#hsa-code-object-isa-major-minor-stepping-vendor-arch" title="Permalink to this headline">¶</a></h5>
<p><em>major</em>, <em>minor</em>, and <em>stepping</em> are all integers that describe the instruction
set architecture (ISA) version of the assembly program.</p>
<p><em>vendor</em> and <em>arch</em> are quoted strings. <em>vendor</em> should always be equal to
“AMD” and <em>arch</em> should always be equal to “AMDGPU”.</p>
<p>By default, the assembler will derive the ISA version, <em>vendor</em>, and <em>arch</em>
from the value of the -mcpu option that is passed to the assembler.</p>
</div>
<div class="section" id="amdgpu-hsa-kernel-name">
<span id="amdgpu-amdhsa-assembler-directive-amdgpu-hsa-kernel"></span><h5><a class="toc-backref" href="#id193">.amdgpu_hsa_kernel (name)</a><a class="headerlink" href="#amdgpu-hsa-kernel-name" title="Permalink to this headline">¶</a></h5>
<p>This directives specifies that the symbol with given name is a kernel entry
point (label) and the object should contain corresponding symbol of type
STT_AMDGPU_HSA_KERNEL.</p>
</div>
<div class="section" id="amd-kernel-code-t">
<h5><a class="toc-backref" href="#id194">.amd_kernel_code_t</a><a class="headerlink" href="#amd-kernel-code-t" title="Permalink to this headline">¶</a></h5>
<p>This directive marks the beginning of a list of key / value pairs that are used
to specify the amd_kernel_code_t object that will be emitted by the assembler.
The list must be terminated by the <em>.end_amd_kernel_code_t</em> directive. For any
amd_kernel_code_t values that are unspecified a default value will be used. The
default value for all keys is 0, with the following exceptions:</p>
<ul class="simple">
<li><p><em>amd_code_version_major</em> defaults to 1.</p></li>
<li><p><em>amd_kernel_code_version_minor</em> defaults to 2.</p></li>
<li><p><em>amd_machine_kind</em> defaults to 1.</p></li>
<li><p><em>amd_machine_version_major</em>, <em>machine_version_minor</em>, and
<em>amd_machine_version_stepping</em> are derived from the value of the -mcpu option
that is passed to the assembler.</p></li>
<li><p><em>kernel_code_entry_byte_offset</em> defaults to 256.</p></li>
<li><p><em>wavefront_size</em> defaults 6 for all targets before GFX10. For GFX10 onwards
defaults to 6 if target feature <code class="docutils literal notranslate"><span class="pre">wavefrontsize64</span></code> is enabled, otherwise 5.
Note that wavefront size is specified as a power of two, so a value of <strong>n</strong>
means a size of 2^ <strong>n</strong>.</p></li>
<li><p><em>call_convention</em> defaults to -1.</p></li>
<li><p><em>kernarg_segment_alignment</em>, <em>group_segment_alignment</em>, and
<em>private_segment_alignment</em> default to 4. Note that alignments are specified
as a power of 2, so a value of <strong>n</strong> means an alignment of 2^ <strong>n</strong>.</p></li>
<li><p><em>enable_tg_split</em> defaults to 1 if target feature <code class="docutils literal notranslate"><span class="pre">tgsplit</span></code> is enabled for
GFX90A onwards.</p></li>
<li><p><em>enable_wgp_mode</em> defaults to 1 if target feature <code class="docutils literal notranslate"><span class="pre">cumode</span></code> is disabled for
GFX10 onwards.</p></li>
<li><p><em>enable_mem_ordered</em> defaults to 1 for GFX10 onwards.</p></li>
</ul>
<p>The <em>.amd_kernel_code_t</em> directive must be placed immediately after the
function label and before any instructions.</p>
<p>For a full list of amd_kernel_code_t keys, refer to AMDGPU ABI document,
comments in lib/Target/AMDGPU/AmdKernelCodeT.h and test/CodeGen/AMDGPU/hsa.s.</p>
</div>
</div>
<div class="section" id="code-object-v2-example-source-code">
<span id="amdgpu-amdhsa-assembler-example-v2"></span><h4><a class="toc-backref" href="#id195">Code Object V2 Example Source Code</a><a class="headerlink" href="#code-object-v2-example-source-code" title="Permalink to this headline">¶</a></h4>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Code Object V2 is not the default code object version emitted by
this version of LLVM.</p>
</div>
<p>Here is an example of a minimal assembly source file, defining one HSA kernel:</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="o">.</span><span class="n">hsa_code_object_version</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span>
<span class="o">.</span><span class="n">hsa_code_object_isa</span>

<span class="o">.</span><span class="n">hsatext</span>
<span class="o">.</span><span class="n">globl</span>  <span class="n">hello_world</span>
<span class="o">.</span><span class="n">p2align</span> <span class="mi">8</span>
<span class="o">.</span><span class="n">amdgpu_hsa_kernel</span> <span class="n">hello_world</span>

<span class="n">hello_world</span><span class="p">:</span>

   <span class="o">.</span><span class="n">amd_kernel_code_t</span>
      <span class="n">enable_sgpr_kernarg_segment_ptr</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">is_ptr64</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">compute_pgm_rsrc1_vgprs</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="n">compute_pgm_rsrc1_sgprs</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="n">compute_pgm_rsrc2_user_sgpr</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="n">compute_pgm_rsrc1_wgp_mode</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="n">compute_pgm_rsrc1_mem_ordered</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="n">compute_pgm_rsrc1_fwd_progress</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="o">.</span><span class="n">end_amd_kernel_code_t</span>

  <span class="n">s_load_dwordx2</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="mh">0x0</span>
  <span class="n">v_mov_b32</span> <span class="n">v0</span><span class="p">,</span> <span class="mf">3.14159</span>
  <span class="n">s_waitcnt</span> <span class="n">lgkmcnt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="n">v_mov_b32</span> <span class="n">v1</span><span class="p">,</span> <span class="n">s0</span>
  <span class="n">v_mov_b32</span> <span class="n">v2</span><span class="p">,</span> <span class="n">s1</span>
  <span class="n">flat_store_dword</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">v0</span>
  <span class="n">s_endpgm</span>
<span class="o">.</span><span class="n">Lfunc_end0</span><span class="p">:</span>
     <span class="o">.</span><span class="n">size</span>   <span class="n">hello_world</span><span class="p">,</span> <span class="o">.</span><span class="n">Lfunc_end0</span><span class="o">-</span><span class="n">hello_world</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="code-object-v3-to-v4-predefined-symbols">
<span id="amdgpu-amdhsa-assembler-predefined-symbols-v3-v4"></span><h4><a class="toc-backref" href="#id196">Code Object V3 to V4 Predefined Symbols</a><a class="headerlink" href="#code-object-v3-to-v4-predefined-symbols" title="Permalink to this headline">¶</a></h4>
<p>The AMDGPU assembler defines and updates some symbols automatically. These
symbols do not affect code generation.</p>
<div class="section" id="amdgcn-gfx-generation-number">
<h5><a class="toc-backref" href="#id197">.amdgcn.gfx_generation_number</a><a class="headerlink" href="#amdgcn-gfx-generation-number" title="Permalink to this headline">¶</a></h5>
<p>Set to the GFX major generation number of the target being assembled for. For
example, when assembling for a “GFX9” target this will be set to the integer
value “9”. The possible GFX major generation numbers are presented in
<a class="reference internal" href="#amdgpu-processors"><span class="std std-ref">Processors</span></a>.</p>
</div>
<div class="section" id="amdgcn-gfx-generation-minor">
<h5><a class="toc-backref" href="#id198">.amdgcn.gfx_generation_minor</a><a class="headerlink" href="#amdgcn-gfx-generation-minor" title="Permalink to this headline">¶</a></h5>
<p>Set to the GFX minor generation number of the target being assembled for. For
example, when assembling for a “GFX810” target this will be set to the integer
value “1”. The possible GFX minor generation numbers are presented in
<a class="reference internal" href="#amdgpu-processors"><span class="std std-ref">Processors</span></a>.</p>
</div>
<div class="section" id="amdgcn-gfx-generation-stepping">
<h5><a class="toc-backref" href="#id199">.amdgcn.gfx_generation_stepping</a><a class="headerlink" href="#amdgcn-gfx-generation-stepping" title="Permalink to this headline">¶</a></h5>
<p>Set to the GFX stepping generation number of the target being assembled for.
For example, when assembling for a “GFX704” target this will be set to the
integer value “4”. The possible GFX stepping generation numbers are presented
in <a class="reference internal" href="#amdgpu-processors"><span class="std std-ref">Processors</span></a>.</p>
</div>
<div class="section" id="amdgcn-next-free-vgpr">
<span id="amdgpu-amdhsa-assembler-symbol-next-free-vgpr"></span><h5><a class="toc-backref" href="#id200">.amdgcn.next_free_vgpr</a><a class="headerlink" href="#amdgcn-next-free-vgpr" title="Permalink to this headline">¶</a></h5>
<p>Set to zero before assembly begins. At each instruction, if the current value
of this symbol is less than or equal to the maximum VGPR number explicitly
referenced within that instruction then the symbol value is updated to equal
that VGPR number plus one.</p>
<p>May be used to set the <cite>.amdhsa_next_free_vgpr</cite> directive in
<a class="reference internal" href="#amdhsa-kernel-directives-table"><span class="std std-ref">AMDHSA Kernel Assembler Directives</span></a>.</p>
<p>May be set at any time, e.g. manually set to zero at the start of each kernel.</p>
</div>
<div class="section" id="amdgcn-next-free-sgpr">
<span id="amdgpu-amdhsa-assembler-symbol-next-free-sgpr"></span><h5><a class="toc-backref" href="#id201">.amdgcn.next_free_sgpr</a><a class="headerlink" href="#amdgcn-next-free-sgpr" title="Permalink to this headline">¶</a></h5>
<p>Set to zero before assembly begins. At each instruction, if the current value
of this symbol is less than or equal the maximum SGPR number explicitly
referenced within that instruction then the symbol value is updated to equal
that SGPR number plus one.</p>
<p>May be used to set the <cite>.amdhsa_next_free_spgr</cite> directive in
<a class="reference internal" href="#amdhsa-kernel-directives-table"><span class="std std-ref">AMDHSA Kernel Assembler Directives</span></a>.</p>
<p>May be set at any time, e.g. manually set to zero at the start of each kernel.</p>
</div>
</div>
<div class="section" id="code-object-v3-to-v4-directives">
<span id="amdgpu-amdhsa-assembler-directives-v3-v4"></span><h4><a class="toc-backref" href="#id202">Code Object V3 to V4 Directives</a><a class="headerlink" href="#code-object-v3-to-v4-directives" title="Permalink to this headline">¶</a></h4>
<p>Directives which begin with <code class="docutils literal notranslate"><span class="pre">.amdgcn</span></code> are valid for all <code class="docutils literal notranslate"><span class="pre">amdgcn</span></code>
architecture processors, and are not OS-specific. Directives which begin with
<code class="docutils literal notranslate"><span class="pre">.amdhsa</span></code> are specific to <code class="docutils literal notranslate"><span class="pre">amdgcn</span></code> architecture processors when the
<code class="docutils literal notranslate"><span class="pre">amdhsa</span></code> OS is specified. See <a class="reference internal" href="#amdgpu-target-triples"><span class="std std-ref">Target Triples</span></a> and
<a class="reference internal" href="#amdgpu-processors"><span class="std std-ref">Processors</span></a>.</p>
<div class="section" id="amdgcn-target-target-triple-target-id">
<span id="amdgpu-assembler-directive-amdgcn-target"></span><h5><a class="toc-backref" href="#id203">.amdgcn_target &lt;target-triple&gt; “-” &lt;target-id&gt;</a><a class="headerlink" href="#amdgcn-target-target-triple-target-id" title="Permalink to this headline">¶</a></h5>
<p>Optional directive which declares the <code class="docutils literal notranslate"><span class="pre">&lt;target-triple&gt;-&lt;target-id&gt;</span></code> supported
by the containing assembler source file. Used by the assembler to validate
command-line options such as <code class="docutils literal notranslate"><span class="pre">-triple</span></code>, <code class="docutils literal notranslate"><span class="pre">-mcpu</span></code>, and
<code class="docutils literal notranslate"><span class="pre">--offload-arch=&lt;target-id&gt;</span></code>. A non-canonical target ID is allowed. See
<a class="reference internal" href="#amdgpu-target-triples"><span class="std std-ref">Target Triples</span></a> and <a class="reference internal" href="#amdgpu-target-id"><span class="std std-ref">Target ID</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The target ID syntax used for code object V2 to V3 for this directive differs
from that used elsewhere. See <a class="reference internal" href="#amdgpu-target-id-v2-v3"><span class="std std-ref">Code Object V2 to V3 Target ID</span></a>.</p>
</div>
</div>
<div class="section" id="amdhsa-kernel-name">
<h5><a class="toc-backref" href="#id204">.amdhsa_kernel &lt;name&gt;</a><a class="headerlink" href="#amdhsa-kernel-name" title="Permalink to this headline">¶</a></h5>
<p>Creates a correctly aligned AMDHSA kernel descriptor and a symbol,
<code class="docutils literal notranslate"><span class="pre">&lt;name&gt;.kd</span></code>, in the current location of the current section. Only valid when
the OS is <code class="docutils literal notranslate"><span class="pre">amdhsa</span></code>. <code class="docutils literal notranslate"><span class="pre">&lt;name&gt;</span></code> must be a symbol that labels the first
instruction to execute, and does not need to be previously defined.</p>
<p>Marks the beginning of a list of directives used to generate the bytes of a
kernel descriptor, as described in <a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor"><span class="std std-ref">Kernel Descriptor</span></a>.
Directives which may appear in this list are described in
<a class="reference internal" href="#amdhsa-kernel-directives-table"><span class="std std-ref">AMDHSA Kernel Assembler Directives</span></a>. Directives may appear in any order, must
be valid for the target being assembled for, and cannot be repeated. Directives
support the range of values specified by the field they reference in
<a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor"><span class="std std-ref">Kernel Descriptor</span></a>. If a directive is not specified, it is
assumed to have its default value, unless it is marked as “Required”, in which
case it is an error to omit the directive. This list of directives is
terminated by an <code class="docutils literal notranslate"><span class="pre">.end_amdhsa_kernel</span></code> directive.</p>
<blockquote>
<div><table class="docutils align-default" id="amdhsa-kernel-directives-table">
<caption><span class="caption-text">AMDHSA Kernel Assembler Directives</span><a class="headerlink" href="#amdhsa-kernel-directives-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 35%" />
<col style="width: 12%" />
<col style="width: 7%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Directive</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Supported On</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_group_segment_fixed_size</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls GROUP_SEGMENT_FIXED_SIZE in
<a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor-v3-table"><span class="std std-ref">Code Object V3 Kernel Descriptor</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_private_segment_fixed_size</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls PRIVATE_SEGMENT_FIXED_SIZE in
<a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor-v3-table"><span class="std std-ref">Code Object V3 Kernel Descriptor</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_kernarg_size</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls KERNARG_SIZE in
<a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor-v3-table"><span class="std std-ref">Code Object V3 Kernel Descriptor</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_user_sgpr_private_segment_buffer</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls ENABLE_SGPR_PRIVATE_SEGMENT_BUFFER in
<a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor-v3-table"><span class="std std-ref">Code Object V3 Kernel Descriptor</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_user_sgpr_dispatch_ptr</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls ENABLE_SGPR_DISPATCH_PTR in
<a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor-v3-table"><span class="std std-ref">Code Object V3 Kernel Descriptor</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_user_sgpr_queue_ptr</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls ENABLE_SGPR_QUEUE_PTR in
<a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor-v3-table"><span class="std std-ref">Code Object V3 Kernel Descriptor</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_user_sgpr_kernarg_segment_ptr</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls ENABLE_SGPR_KERNARG_SEGMENT_PTR in
<a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor-v3-table"><span class="std std-ref">Code Object V3 Kernel Descriptor</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_user_sgpr_dispatch_id</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls ENABLE_SGPR_DISPATCH_ID in
<a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor-v3-table"><span class="std std-ref">Code Object V3 Kernel Descriptor</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_user_sgpr_flat_scratch_init</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls ENABLE_SGPR_FLAT_SCRATCH_INIT in
<a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor-v3-table"><span class="std std-ref">Code Object V3 Kernel Descriptor</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_user_sgpr_private_segment_size</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls ENABLE_SGPR_PRIVATE_SEGMENT_SIZE in
<a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor-v3-table"><span class="std std-ref">Code Object V3 Kernel Descriptor</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_wavefront_size32</span></code></p></td>
<td><p>Target
Feature
Specific
(wavefrontsize64)</p></td>
<td><p>GFX10</p></td>
<td><p>Controls ENABLE_WAVEFRONT_SIZE32 in
<a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor-v3-table"><span class="std std-ref">Code Object V3 Kernel Descriptor</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_system_sgpr_private_segment_wavefront_offset</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls ENABLE_PRIVATE_SEGMENT in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc2-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc2 for GFX6-GFX10</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_system_sgpr_workgroup_id_x</span></code></p></td>
<td><p>1</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls ENABLE_SGPR_WORKGROUP_ID_X in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc2-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc2 for GFX6-GFX10</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_system_sgpr_workgroup_id_y</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls ENABLE_SGPR_WORKGROUP_ID_Y in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc2-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc2 for GFX6-GFX10</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_system_sgpr_workgroup_id_z</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls ENABLE_SGPR_WORKGROUP_ID_Z in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc2-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc2 for GFX6-GFX10</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_system_sgpr_workgroup_info</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls ENABLE_SGPR_WORKGROUP_INFO in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc2-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc2 for GFX6-GFX10</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_system_vgpr_workitem_id</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls ENABLE_VGPR_WORKITEM_ID in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc2-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc2 for GFX6-GFX10</span></a>.
Possible values are defined in
<a class="reference internal" href="#amdgpu-amdhsa-system-vgpr-work-item-id-enumeration-values-table"><span class="std std-ref">System VGPR Work-Item ID Enumeration Values</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_next_free_vgpr</span></code></p></td>
<td><p>Required</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Maximum VGPR number explicitly referenced, plus one.
Used to calculate GRANULATED_WORKITEM_VGPR_COUNT in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc1-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc1 for GFX6-GFX10</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_next_free_sgpr</span></code></p></td>
<td><p>Required</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Maximum SGPR number explicitly referenced, plus one.
Used to calculate GRANULATED_WAVEFRONT_SGPR_COUNT in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc1-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc1 for GFX6-GFX10</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_accum_offset</span></code></p></td>
<td><p>Required</p></td>
<td><p>GFX90A</p></td>
<td><p>Offset of a first AccVGPR in the unified register file.
Used to calculate ACCUM_OFFSET in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc3-gfx90a-table"><span class="std std-ref">compute_pgm_rsrc3 for GFX90A</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_reserve_vcc</span></code></p></td>
<td><p>1</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Whether the kernel may use the special VCC SGPR.
Used to calculate GRANULATED_WAVEFRONT_SGPR_COUNT in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc1-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc1 for GFX6-GFX10</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_reserve_flat_scratch</span></code></p></td>
<td><p>1</p></td>
<td><p>GFX7-GFX10</p></td>
<td><p>Whether the kernel may use flat instructions to access
scratch memory. Used to calculate
GRANULATED_WAVEFRONT_SGPR_COUNT in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc1-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc1 for GFX6-GFX10</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_reserve_xnack_mask</span></code></p></td>
<td><p>Target
Feature
Specific
(xnack)</p></td>
<td><p>GFX8-GFX10</p></td>
<td><p>Whether the kernel may trigger XNACK replay.
Used to calculate GRANULATED_WAVEFRONT_SGPR_COUNT in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc1-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc1 for GFX6-GFX10</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_float_round_mode_32</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls FLOAT_ROUND_MODE_32 in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc1-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc1 for GFX6-GFX10</span></a>.
Possible values are defined in
<a class="reference internal" href="#amdgpu-amdhsa-floating-point-rounding-mode-enumeration-values-table"><span class="std std-ref">Floating Point Rounding Mode Enumeration Values</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_float_round_mode_16_64</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls FLOAT_ROUND_MODE_16_64 in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc1-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc1 for GFX6-GFX10</span></a>.
Possible values are defined in
<a class="reference internal" href="#amdgpu-amdhsa-floating-point-rounding-mode-enumeration-values-table"><span class="std std-ref">Floating Point Rounding Mode Enumeration Values</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_float_denorm_mode_32</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls FLOAT_DENORM_MODE_32 in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc1-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc1 for GFX6-GFX10</span></a>.
Possible values are defined in
<a class="reference internal" href="#amdgpu-amdhsa-floating-point-denorm-mode-enumeration-values-table"><span class="std std-ref">Floating Point Denorm Mode Enumeration Values</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_float_denorm_mode_16_64</span></code></p></td>
<td><p>3</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls FLOAT_DENORM_MODE_16_64 in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc1-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc1 for GFX6-GFX10</span></a>.
Possible values are defined in
<a class="reference internal" href="#amdgpu-amdhsa-floating-point-denorm-mode-enumeration-values-table"><span class="std std-ref">Floating Point Denorm Mode Enumeration Values</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_dx10_clamp</span></code></p></td>
<td><p>1</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls ENABLE_DX10_CLAMP in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc1-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc1 for GFX6-GFX10</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_ieee_mode</span></code></p></td>
<td><p>1</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls ENABLE_IEEE_MODE in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc1-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc1 for GFX6-GFX10</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_fp16_overflow</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX9-GFX10</p></td>
<td><p>Controls FP16_OVFL in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc1-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc1 for GFX6-GFX10</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_tg_split</span></code></p></td>
<td><p>Target
Feature
Specific
(tgsplit)</p></td>
<td><p>GFX90A</p></td>
<td><p>Controls TG_SPLIT in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc3-gfx90a-table"><span class="std std-ref">compute_pgm_rsrc3 for GFX90A</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_workgroup_processor_mode</span></code></p></td>
<td><p>Target
Feature
Specific
(cumode)</p></td>
<td><p>GFX10</p></td>
<td><p>Controls ENABLE_WGP_MODE in
<a class="reference internal" href="#amdgpu-amdhsa-kernel-descriptor-v3-table"><span class="std std-ref">Code Object V3 Kernel Descriptor</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_memory_ordered</span></code></p></td>
<td><p>1</p></td>
<td><p>GFX10</p></td>
<td><p>Controls MEM_ORDERED in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc1-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc1 for GFX6-GFX10</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_forward_progress</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX10</p></td>
<td><p>Controls FWD_PROGRESS in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc1-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc1 for GFX6-GFX10</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_exception_fp_ieee_invalid_op</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls ENABLE_EXCEPTION_IEEE_754_FP_INVALID_OPERATION in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc2-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc2 for GFX6-GFX10</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_exception_fp_denorm_src</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls ENABLE_EXCEPTION_FP_DENORMAL_SOURCE in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc2-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc2 for GFX6-GFX10</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_exception_fp_ieee_div_zero</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls ENABLE_EXCEPTION_IEEE_754_FP_DIVISION_BY_ZERO in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc2-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc2 for GFX6-GFX10</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_exception_fp_ieee_overflow</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls ENABLE_EXCEPTION_IEEE_754_FP_OVERFLOW in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc2-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc2 for GFX6-GFX10</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_exception_fp_ieee_underflow</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls ENABLE_EXCEPTION_IEEE_754_FP_UNDERFLOW in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc2-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc2 for GFX6-GFX10</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_exception_fp_ieee_inexact</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls ENABLE_EXCEPTION_IEEE_754_FP_INEXACT in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc2-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc2 for GFX6-GFX10</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.amdhsa_exception_int_div_zero</span></code></p></td>
<td><p>0</p></td>
<td><p>GFX6-GFX10</p></td>
<td><p>Controls ENABLE_EXCEPTION_INT_DIVIDE_BY_ZERO in
<a class="reference internal" href="#amdgpu-amdhsa-compute-pgm-rsrc2-gfx6-gfx10-table"><span class="std std-ref">compute_pgm_rsrc2 for GFX6-GFX10</span></a>.</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="amdgpu-metadata">
<h5><a class="toc-backref" href="#id205">.amdgpu_metadata</a><a class="headerlink" href="#amdgpu-metadata" title="Permalink to this headline">¶</a></h5>
<p>Optional directive which declares the contents of the <code class="docutils literal notranslate"><span class="pre">NT_AMDGPU_METADATA</span></code>
note record (see <a class="reference internal" href="#amdgpu-elf-note-records-table-v3-v4"><span class="std std-ref">AMDGPU Code Object V3 to V4 ELF Note Records</span></a>).</p>
<p>The contents must be in the <a class="reference internal" href="#yaml" id="id91"><span>[YAML]</span></a> markup format, with the same structure and
semantics described in <a class="reference internal" href="#amdgpu-amdhsa-code-object-metadata-v3"><span class="std std-ref">Code Object V3 Metadata</span></a> or
<a class="reference internal" href="#amdgpu-amdhsa-code-object-metadata-v4"><span class="std std-ref">Code Object V4 Metadata</span></a>.</p>
<p>This directive is terminated by an <code class="docutils literal notranslate"><span class="pre">.end_amdgpu_metadata</span></code> directive.</p>
</div>
</div>
<div class="section" id="code-object-v3-to-v4-example-source-code">
<span id="amdgpu-amdhsa-assembler-example-v3-v4"></span><h4><a class="toc-backref" href="#id206">Code Object V3 to V4 Example Source Code</a><a class="headerlink" href="#code-object-v3-to-v4-example-source-code" title="Permalink to this headline">¶</a></h4>
<p>Here is an example of a minimal assembly source file, defining one HSA kernel:</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="o">.</span><span class="n">amdgcn_target</span> <span class="s2">&quot;amdgcn-amd-amdhsa--gfx900+xnack&quot;</span> <span class="o">//</span> <span class="n">optional</span>

<span class="o">.</span><span class="n">text</span>
<span class="o">.</span><span class="n">globl</span> <span class="n">hello_world</span>
<span class="o">.</span><span class="n">p2align</span> <span class="mi">8</span>
<span class="o">.</span><span class="n">type</span> <span class="n">hello_world</span><span class="p">,</span><span class="nd">@function</span>
<span class="n">hello_world</span><span class="p">:</span>
  <span class="n">s_load_dwordx2</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="mh">0x0</span>
  <span class="n">v_mov_b32</span> <span class="n">v0</span><span class="p">,</span> <span class="mf">3.14159</span>
  <span class="n">s_waitcnt</span> <span class="n">lgkmcnt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="n">v_mov_b32</span> <span class="n">v1</span><span class="p">,</span> <span class="n">s0</span>
  <span class="n">v_mov_b32</span> <span class="n">v2</span><span class="p">,</span> <span class="n">s1</span>
  <span class="n">flat_store_dword</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">v0</span>
  <span class="n">s_endpgm</span>
<span class="o">.</span><span class="n">Lfunc_end0</span><span class="p">:</span>
  <span class="o">.</span><span class="n">size</span>   <span class="n">hello_world</span><span class="p">,</span> <span class="o">.</span><span class="n">Lfunc_end0</span><span class="o">-</span><span class="n">hello_world</span>

<span class="o">.</span><span class="n">rodata</span>
<span class="o">.</span><span class="n">p2align</span> <span class="mi">6</span>
<span class="o">.</span><span class="n">amdhsa_kernel</span> <span class="n">hello_world</span>
  <span class="o">.</span><span class="n">amdhsa_user_sgpr_kernarg_segment_ptr</span> <span class="mi">1</span>
  <span class="o">.</span><span class="n">amdhsa_next_free_vgpr</span> <span class="o">.</span><span class="n">amdgcn</span><span class="o">.</span><span class="n">next_free_vgpr</span>
  <span class="o">.</span><span class="n">amdhsa_next_free_sgpr</span> <span class="o">.</span><span class="n">amdgcn</span><span class="o">.</span><span class="n">next_free_sgpr</span>
<span class="o">.</span><span class="n">end_amdhsa_kernel</span>

<span class="o">.</span><span class="n">amdgpu_metadata</span>
<span class="o">---</span>
<span class="n">amdhsa</span><span class="o">.</span><span class="n">version</span><span class="p">:</span>
  <span class="o">-</span> <span class="mi">1</span>
  <span class="o">-</span> <span class="mi">0</span>
<span class="n">amdhsa</span><span class="o">.</span><span class="n">kernels</span><span class="p">:</span>
  <span class="o">-</span> <span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">hello_world</span>
    <span class="o">.</span><span class="n">symbol</span><span class="p">:</span> <span class="n">hello_world</span><span class="o">.</span><span class="n">kd</span>
    <span class="o">.</span><span class="n">kernarg_segment_size</span><span class="p">:</span> <span class="mi">48</span>
    <span class="o">.</span><span class="n">group_segment_fixed_size</span><span class="p">:</span> <span class="mi">0</span>
    <span class="o">.</span><span class="n">private_segment_fixed_size</span><span class="p">:</span> <span class="mi">0</span>
    <span class="o">.</span><span class="n">kernarg_segment_align</span><span class="p">:</span> <span class="mi">4</span>
    <span class="o">.</span><span class="n">wavefront_size</span><span class="p">:</span> <span class="mi">64</span>
    <span class="o">.</span><span class="n">sgpr_count</span><span class="p">:</span> <span class="mi">2</span>
    <span class="o">.</span><span class="n">vgpr_count</span><span class="p">:</span> <span class="mi">3</span>
    <span class="o">.</span><span class="n">max_flat_workgroup_size</span><span class="p">:</span> <span class="mi">256</span>
    <span class="o">.</span><span class="n">args</span><span class="p">:</span>
      <span class="o">-</span> <span class="o">.</span><span class="n">size</span><span class="p">:</span> <span class="mi">8</span>
        <span class="o">.</span><span class="n">offset</span><span class="p">:</span> <span class="mi">0</span>
        <span class="o">.</span><span class="n">value_kind</span><span class="p">:</span> <span class="n">global_buffer</span>
        <span class="o">.</span><span class="n">address_space</span><span class="p">:</span> <span class="k">global</span>
        <span class="o">.</span><span class="n">actual_access</span><span class="p">:</span> <span class="n">write_only</span>
<span class="o">//...</span>
<span class="o">.</span><span class="n">end_amdgpu_metadata</span>
</pre></div>
</td></tr></table></div>
<p>This kernel is equivalent to the following HIP program:</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">__global__</span> <span class="n">void</span> <span class="n">hello_world</span><span class="p">(</span><span class="nb">float</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mf">3.14159</span><span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>If an assembly source file contains multiple kernels and/or functions, the
<a class="reference internal" href="#amdgpu-amdhsa-assembler-symbol-next-free-vgpr"><span class="std std-ref">.amdgcn.next_free_vgpr</span></a> and
<a class="reference internal" href="#amdgpu-amdhsa-assembler-symbol-next-free-sgpr"><span class="std std-ref">.amdgcn.next_free_sgpr</span></a> symbols may be reset using
the <code class="docutils literal notranslate"><span class="pre">.set</span> <span class="pre">&lt;symbol&gt;,</span> <span class="pre">&lt;expression&gt;</span></code> directive. For example, in the case of two
kernels, where <code class="docutils literal notranslate"><span class="pre">function1</span></code> is only called from <code class="docutils literal notranslate"><span class="pre">kernel1</span></code> it is sufficient
to group the function with the kernel that calls it and reset the symbols
between the two connected components:</p>
<div class="highlight-default notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="o">.</span><span class="n">amdgcn_target</span> <span class="s2">&quot;amdgcn-amd-amdhsa--gfx900+xnack&quot;</span> <span class="o">//</span> <span class="n">optional</span>

<span class="o">//</span> <span class="n">gpr</span> <span class="n">tracking</span> <span class="n">symbols</span> <span class="n">are</span> <span class="n">implicitly</span> <span class="nb">set</span> <span class="n">to</span> <span class="n">zero</span>

<span class="o">.</span><span class="n">text</span>
<span class="o">.</span><span class="n">globl</span> <span class="n">kern0</span>
<span class="o">.</span><span class="n">p2align</span> <span class="mi">8</span>
<span class="o">.</span><span class="n">type</span> <span class="n">kern0</span><span class="p">,</span><span class="nd">@function</span>
<span class="n">kern0</span><span class="p">:</span>
  <span class="o">//</span> <span class="o">...</span>
  <span class="n">s_endpgm</span>
<span class="o">.</span><span class="n">Lkern0_end</span><span class="p">:</span>
  <span class="o">.</span><span class="n">size</span>   <span class="n">kern0</span><span class="p">,</span> <span class="o">.</span><span class="n">Lkern0_end</span><span class="o">-</span><span class="n">kern0</span>

<span class="o">.</span><span class="n">rodata</span>
<span class="o">.</span><span class="n">p2align</span> <span class="mi">6</span>
<span class="o">.</span><span class="n">amdhsa_kernel</span> <span class="n">kern0</span>
  <span class="o">//</span> <span class="o">...</span>
  <span class="o">.</span><span class="n">amdhsa_next_free_vgpr</span> <span class="o">.</span><span class="n">amdgcn</span><span class="o">.</span><span class="n">next_free_vgpr</span>
  <span class="o">.</span><span class="n">amdhsa_next_free_sgpr</span> <span class="o">.</span><span class="n">amdgcn</span><span class="o">.</span><span class="n">next_free_sgpr</span>
<span class="o">.</span><span class="n">end_amdhsa_kernel</span>

<span class="o">//</span> <span class="n">reset</span> <span class="n">symbols</span> <span class="n">to</span> <span class="n">begin</span> <span class="n">tracking</span> <span class="n">usage</span> <span class="ow">in</span> <span class="n">func1</span> <span class="ow">and</span> <span class="n">kern1</span>
<span class="o">.</span><span class="n">set</span> <span class="o">.</span><span class="n">amdgcn</span><span class="o">.</span><span class="n">next_free_vgpr</span><span class="p">,</span> <span class="mi">0</span>
<span class="o">.</span><span class="n">set</span> <span class="o">.</span><span class="n">amdgcn</span><span class="o">.</span><span class="n">next_free_sgpr</span><span class="p">,</span> <span class="mi">0</span>

<span class="o">.</span><span class="n">text</span>
<span class="o">.</span><span class="n">hidden</span> <span class="n">func1</span>
<span class="o">.</span><span class="k">global</span> <span class="n">func1</span>
<span class="o">.</span><span class="n">p2align</span> <span class="mi">2</span>
<span class="o">.</span><span class="n">type</span> <span class="n">func1</span><span class="p">,</span><span class="nd">@function</span>
<span class="n">func1</span><span class="p">:</span>
  <span class="o">//</span> <span class="o">...</span>
  <span class="n">s_setpc_b64</span> <span class="n">s</span><span class="p">[</span><span class="mi">30</span><span class="p">:</span><span class="mi">31</span><span class="p">]</span>
<span class="o">.</span><span class="n">Lfunc1_end</span><span class="p">:</span>
<span class="o">.</span><span class="n">size</span> <span class="n">func1</span><span class="p">,</span> <span class="o">.</span><span class="n">Lfunc1_end</span><span class="o">-</span><span class="n">func1</span>

<span class="o">.</span><span class="n">globl</span> <span class="n">kern1</span>
<span class="o">.</span><span class="n">p2align</span> <span class="mi">8</span>
<span class="o">.</span><span class="n">type</span> <span class="n">kern1</span><span class="p">,</span><span class="nd">@function</span>
<span class="n">kern1</span><span class="p">:</span>
  <span class="o">//</span> <span class="o">...</span>
  <span class="n">s_getpc_b64</span> <span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
  <span class="n">s_add_u32</span> <span class="n">s4</span><span class="p">,</span> <span class="n">s4</span><span class="p">,</span> <span class="n">func1</span><span class="nd">@rel32@lo</span><span class="o">+</span><span class="mi">4</span>
  <span class="n">s_addc_u32</span> <span class="n">s5</span><span class="p">,</span> <span class="n">s5</span><span class="p">,</span> <span class="n">func1</span><span class="nd">@rel32@lo</span><span class="o">+</span><span class="mi">4</span>
  <span class="n">s_swappc_b64</span> <span class="n">s</span><span class="p">[</span><span class="mi">30</span><span class="p">:</span><span class="mi">31</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
  <span class="o">//</span> <span class="o">...</span>
  <span class="n">s_endpgm</span>
<span class="o">.</span><span class="n">Lkern1_end</span><span class="p">:</span>
  <span class="o">.</span><span class="n">size</span>   <span class="n">kern1</span><span class="p">,</span> <span class="o">.</span><span class="n">Lkern1_end</span><span class="o">-</span><span class="n">kern1</span>

<span class="o">.</span><span class="n">rodata</span>
<span class="o">.</span><span class="n">p2align</span> <span class="mi">6</span>
<span class="o">.</span><span class="n">amdhsa_kernel</span> <span class="n">kern1</span>
  <span class="o">//</span> <span class="o">...</span>
  <span class="o">.</span><span class="n">amdhsa_next_free_vgpr</span> <span class="o">.</span><span class="n">amdgcn</span><span class="o">.</span><span class="n">next_free_vgpr</span>
  <span class="o">.</span><span class="n">amdhsa_next_free_sgpr</span> <span class="o">.</span><span class="n">amdgcn</span><span class="o">.</span><span class="n">next_free_sgpr</span>
<span class="o">.</span><span class="n">end_amdhsa_kernel</span>
</pre></div>
</td></tr></table></div>
<p>These symbols cannot identify connected components in order to automatically
track the usage for each kernel. However, in some cases careful organization of
the kernels and functions in the source file means there is minimal additional
effort required to accurately calculate GPR usage.</p>
</div>
</div>
</div>
<div class="section" id="additional-documentation">
<h2><a class="toc-backref" href="#id207">Additional Documentation</a><a class="headerlink" href="#additional-documentation" title="Permalink to this headline">¶</a></h2>
<dl class="citation">
<dt class="label" id="amd-gcn-gfx6"><span class="brackets">AMD-GCN-GFX6</span><span class="fn-backref">(<a href="#id8">1</a>,<a href="#id83">2</a>)</span></dt>
<dd><p><a class="reference external" href="http://developer.amd.com/wordpress/media/2012/12/AMD_Southern_Islands_Instruction_Set_Architecture.pdf">AMD Southern Islands Series ISA</a></p>
</dd>
<dt class="label" id="amd-gcn-gfx7"><span class="brackets">AMD-GCN-GFX7</span><span class="fn-backref">(<a href="#id9">1</a>,<a href="#id84">2</a>)</span></dt>
<dd><p><a class="reference external" href="http://developer.amd.com/wordpress/media/2013/07/AMD_Sea_Islands_Instruction_Set_Architecture.pdf">AMD Sea Islands Series ISA</a></p>
</dd>
<dt class="label" id="amd-gcn-gfx8"><span class="brackets">AMD-GCN-GFX8</span><span class="fn-backref">(<a href="#id11">1</a>,<a href="#id85">2</a>)</span></dt>
<dd><p><a class="reference external" href="http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2013/12/AMD_GCN3_Instruction_Set_Architecture_rev1.1.pdf">AMD GCN3 Instruction Set Architecture</a></p>
</dd>
<dt class="label" id="amd-gcn-gfx900-gfx904-vega"><span class="brackets">AMD-GCN-GFX900-GFX904-VEGA</span><span class="fn-backref">(<a href="#id13">1</a>,<a href="#id86">2</a>)</span></dt>
<dd><p><a class="reference external" href="http://developer.amd.com/wordpress/media/2013/12/Vega_Shader_ISA_28July2017.pdf">AMD Vega Instruction Set Architecture</a></p>
</dd>
<dt class="label" id="amd-gcn-gfx906-vega7nm"><span class="brackets">AMD-GCN-GFX906-VEGA7NM</span><span class="fn-backref">(<a href="#id14">1</a>,<a href="#id87">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://gpuopen.com/wp-content/uploads/2019/11/Vega_7nm_Shader_ISA_26November2019.pdf">AMD Vega 7nm Instruction Set Architecture</a></p>
</dd>
<dt class="label" id="amd-gcn-gfx908-cdna1"><span class="brackets">AMD-GCN-GFX908-CDNA1</span><span class="fn-backref">(<a href="#id15">1</a>,<a href="#id88">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://developer.amd.com/wp-content/resources/CDNA1_Shader_ISA_14December2020.pdf">AMD Instinct MI100 Instruction Set Architecture</a></p>
</dd>
<dt class="label" id="amd-gcn-gfx10-rdna1"><span class="brackets">AMD-GCN-GFX10-RDNA1</span><span class="fn-backref">(<a href="#id19">1</a>,<a href="#id89">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://gpuopen.com/wp-content/uploads/2019/08/RDNA_Shader_ISA_5August2019.pdf">AMD RDNA 1.0 Instruction Set Architecture</a></p>
</dd>
<dt class="label" id="amd-gcn-gfx10-rdna2"><span class="brackets">AMD-GCN-GFX10-RDNA2</span><span class="fn-backref">(<a href="#id21">1</a>,<a href="#id90">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://developer.amd.com/wp-content/resources/RDNA2_Shader_ISA_November2020.pdf">AMD RDNA 2 Instruction Set Architecture</a></p>
</dd>
<dt class="label" id="amd-radeon-hd-2000-3000"><span class="brackets"><a class="fn-backref" href="#id4">AMD-RADEON-HD-2000-3000</a></span></dt>
<dd><p><a class="reference external" href="http://developer.amd.com/wordpress/media/2012/10/R600_Instruction_Set_Architecture.pdf">AMD R6xx shader ISA</a></p>
</dd>
<dt class="label" id="amd-radeon-hd-4000"><span class="brackets"><a class="fn-backref" href="#id5">AMD-RADEON-HD-4000</a></span></dt>
<dd><p><a class="reference external" href="http://developer.amd.com/wordpress/media/2012/10/R700-Family_Instruction_Set_Architecture.pdf">AMD R7xx shader ISA</a></p>
</dd>
<dt class="label" id="amd-radeon-hd-5000"><span class="brackets"><a class="fn-backref" href="#id6">AMD-RADEON-HD-5000</a></span></dt>
<dd><p><a class="reference external" href="http://developer.amd.com/wordpress/media/2012/10/AMD_Evergreen-Family_Instruction_Set_Architecture.pdf">AMD Evergreen shader ISA</a></p>
</dd>
<dt class="label" id="amd-radeon-hd-6000"><span class="brackets"><a class="fn-backref" href="#id7">AMD-RADEON-HD-6000</a></span></dt>
<dd><p><a class="reference external" href="http://developer.amd.com/wordpress/media/2012/10/AMD_HD_6900_Series_Instruction_Set_Architecture.pdf">AMD Cayman/Trinity shader ISA</a></p>
</dd>
<dt class="label" id="amd-rocm"><span class="brackets"><a class="fn-backref" href="#id2">AMD-ROCm</a></span></dt>
<dd><p><a class="reference external" href="https://rocmdocs.amd.com/">AMD ROCm™ Platform</a></p>
</dd>
<dt class="label" id="amd-rocm-github"><span class="brackets">AMD-ROCm-github</span><span class="fn-backref">(<a href="#id64">1</a>,<a href="#id65">2</a>)</span></dt>
<dd><p><a class="reference external" href="http://github.com/RadeonOpenCompute">AMD ROCm™ github</a></p>
</dd>
<dt class="label" id="amd-rocm-release-notes"><span class="brackets"><a class="fn-backref" href="#id3">AMD-ROCm-Release-Notes</a></span></dt>
<dd><p><a class="reference external" href="https://github.com/RadeonOpenCompute/ROCm">AMD ROCm Release Notes</a></p>
</dd>
<dt class="label" id="clang-attr"><span class="brackets">CLANG-ATTR</span><span class="fn-backref">(<a href="#id32">1</a>,<a href="#id33">2</a>,<a href="#id34">3</a>,<a href="#id35">4</a>)</span></dt>
<dd><p><a class="reference external" href="https://clang.llvm.org/docs/AttributeReference.html">Attributes in Clang</a></p>
</dd>
<dt class="label" id="dwarf"><span class="brackets">DWARF</span><span class="fn-backref">(<a href="#id43">1</a>,<a href="#id44">2</a>)</span></dt>
<dd><p><a class="reference external" href="http://dwarfstd.org/">DWARF Debugging Information Format</a></p>
</dd>
<dt class="label" id="elf"><span class="brackets">ELF</span><span class="fn-backref">(<a href="#id36">1</a>,<a href="#id37">2</a>)</span></dt>
<dd><p><a class="reference external" href="http://www.sco.com/developers/gabi/">Executable and Linkable Format (ELF)</a></p>
</dd>
<dt class="label" id="hrf"><span class="brackets"><a class="fn-backref" href="#id29">HRF</a></span></dt>
<dd><p><a class="reference external" href="http://benedictgaster.org/wp-content/uploads/2014/01/asplos269-FINAL.pdf">Heterogeneous-race-free Memory Models</a></p>
</dd>
<dt class="label" id="hsa"><span class="brackets">HSA</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id28">2</a>,<a href="#id39">3</a>,<a href="#id51">4</a>,<a href="#id61">5</a>,<a href="#id62">6</a>,<a href="#id63">7</a>,<a href="#id66">8</a>,<a href="#id68">9</a>,<a href="#id69">10</a>)</span></dt>
<dd><p><a class="reference external" href="http://www.hsafoundation.com/">Heterogeneous System Architecture (HSA) Foundation</a></p>
</dd>
<dt class="label" id="msgpack"><span class="brackets">MsgPack</span><span class="fn-backref">(<a href="#id40">1</a>,<a href="#id41">2</a>,<a href="#id57">3</a>,<a href="#id81">4</a>)</span></dt>
<dd><p><a class="reference external" href="http://www.msgpack.org/">Message Pack</a></p>
</dd>
<dt class="label" id="id92"><span class="brackets">OpenCL</span><span class="fn-backref">(<a href="#id30">1</a>,<a href="#id67">2</a>)</span></dt>
<dd><p><a class="reference external" href="http://www.khronos.org/registry/cl/specs/opencl-2.0.pdf">The OpenCL Specification Version 2.0</a></p>
</dd>
<dt class="label" id="semver"><span class="brackets">SEMVER</span><span class="fn-backref">(<a href="#id45">1</a>,<a href="#id46">2</a>,<a href="#id49">3</a>)</span></dt>
<dd><p><a class="reference external" href="https://semver.org/">Semantic Versioning</a></p>
</dd>
<dt class="label" id="yaml"><span class="brackets">YAML</span><span class="fn-backref">(<a href="#id38">1</a>,<a href="#id52">2</a>,<a href="#id91">3</a>)</span></dt>
<dd><p><a class="reference external" href="http://www.yaml.org/spec/1.2/spec.html">YAML Ain’t Markup Language (YAML™) Version 1.2</a></p>
</dd>
</dl>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="AMDGPU/AMDGPUAsmGFX7.html" title="Syntax of Core GFX7 Instructions"
             >next</a> |</li>
        <li class="right" >
          <a href="AliasAnalysis.html" title="LLVM Alias Analysis Infrastructure"
             >previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" >User Guides</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2003-2021, LLVM Project.
      Last updated on 2021-10-05.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.2.
    </div>
  </body>
</html>