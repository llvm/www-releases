

<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>DWARF Proposal For Heterogeneous Debugging &#8212; LLVM 11 documentation</title>
    <link rel="stylesheet" href="_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Benchmarking tips" href="Benchmarking.html" />
    <link rel="prev" title="AMDGPU Instructions Notation" href="AMDGPUInstructionNotation.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="Benchmarking.html" title="Benchmarking tips"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="AMDGPUInstructionNotation.html" title="AMDGPU Instructions Notation"
             accesskey="P">previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" >User Guides</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="AMDGPUUsage.html" accesskey="U">User Guide for AMDGPU Backend</a> &#187;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="https://llvm.org/docs/UserGuides.html">User Guides</a></li>
    <li><a href="https://llvm.org/docs/Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/Contributing.html">Contributing to LLVM</a></li>
    <li><a href="https://llvm.org/docs/HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#irc">IRC</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/FAQ.html">FAQ</a></li>
    <li><a href="https://llvm.org/docs/Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project//">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/AMDGPUDwarfProposalForHeterogeneousDebugging.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="dwarf-proposal-for-heterogeneous-debugging">
<span id="amdgpu-dwarf-proposal-for-heterogeneous-debugging"></span><h1>DWARF Proposal For Heterogeneous Debugging<a class="headerlink" href="#dwarf-proposal-for-heterogeneous-debugging" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id4">Introduction</a></p></li>
<li><p><a class="reference internal" href="#motivation" id="id5">Motivation</a></p></li>
<li><p><a class="reference internal" href="#proposed-changes-relative-to-dwarf-version-5" id="id6">Proposed Changes Relative to DWARF Version 5</a></p>
<ul>
<li><p><a class="reference internal" href="#general-description" id="id7">General Description</a></p>
<ul>
<li><p><a class="reference internal" href="#attribute-types" id="id8">Attribute Types</a></p></li>
<li><p><a class="reference internal" href="#dwarf-expressions" id="id9">DWARF Expressions</a></p>
<ul>
<li><p><a class="reference internal" href="#dwarf-operation-expressions" id="id10">DWARF Operation Expressions</a></p>
<ul>
<li><p><a class="reference internal" href="#stack-operations" id="id11">Stack Operations</a></p></li>
<li><p><a class="reference internal" href="#control-flow-operations" id="id12">Control Flow Operations</a></p></li>
<li><p><a class="reference internal" href="#value-operations" id="id13">Value Operations</a></p>
<ul>
<li><p><a class="reference internal" href="#literal-operations" id="id14">Literal Operations</a></p></li>
<li><p><a class="reference internal" href="#arithmetic-and-logical-operations" id="id15">Arithmetic and Logical Operations</a></p></li>
<li><p><a class="reference internal" href="#type-conversion-operations" id="id16">Type Conversion Operations</a></p></li>
<li><p><a class="reference internal" href="#special-value-operations" id="id17">Special Value Operations</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#location-description-operations" id="id18">Location Description Operations</a></p>
<ul>
<li><p><a class="reference internal" href="#general-location-description-operations" id="id19">General Location Description Operations</a></p></li>
<li><p><a class="reference internal" href="#undefined-location-description-operations" id="id20">Undefined Location Description Operations</a></p></li>
<li><p><a class="reference internal" href="#memory-location-description-operations" id="id21">Memory Location Description Operations</a></p></li>
<li><p><a class="reference internal" href="#register-location-description-operations" id="id22">Register Location Description Operations</a></p></li>
<li><p><a class="reference internal" href="#implicit-location-description-operations" id="id23">Implicit Location Description Operations</a></p></li>
<li><p><a class="reference internal" href="#composite-location-description-operations" id="id24">Composite Location Description Operations</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#dwarf-location-list-expressions" id="id25">DWARF Location List Expressions</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#segmented-addresses" id="id26">Segmented Addresses</a></p></li>
<li><p><a class="reference internal" href="#debugging-information-entry-attributes" id="id27">Debugging Information Entry Attributes</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#program-scope-entities" id="id28">Program Scope Entities</a></p>
<ul>
<li><p><a class="reference internal" href="#unit-entities" id="id29">Unit Entities</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#other-debugger-information" id="id30">Other Debugger Information</a></p>
<ul>
<li><p><a class="reference internal" href="#accelerated-access" id="id31">Accelerated Access</a></p>
<ul>
<li><p><a class="reference internal" href="#lookup-by-name" id="id32">Lookup By Name</a></p>
<ul>
<li><p><a class="reference internal" href="#contents-of-the-name-index" id="id33">Contents of the Name Index</a></p></li>
<li><p><a class="reference internal" href="#data-representation-of-the-name-index" id="id34">Data Representation of the Name Index</a></p>
<ul>
<li><p><a class="reference internal" href="#section-header" id="id35">Section Header</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#line-number-information" id="id36">Line Number Information</a></p>
<ul>
<li><p><a class="reference internal" href="#the-line-number-program-header" id="id37">The Line Number Program Header</a></p>
<ul>
<li><p><a class="reference internal" href="#standard-content-descriptions" id="id38">Standard Content Descriptions</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#call-frame-information" id="id39">Call Frame Information</a></p>
<ul>
<li><p><a class="reference internal" href="#structure-of-call-frame-information" id="id40">Structure of Call Frame Information</a></p></li>
<li><p><a class="reference internal" href="#call-frame-instructions" id="id41">Call Frame Instructions</a></p>
<ul>
<li><p><a class="reference internal" href="#row-creation-instructions" id="id42">Row Creation Instructions</a></p></li>
<li><p><a class="reference internal" href="#cfa-definition-instructions" id="id43">CFA Definition Instructions</a></p></li>
<li><p><a class="reference internal" href="#register-rule-instructions" id="id44">Register Rule Instructions</a></p></li>
<li><p><a class="reference internal" href="#row-state-instructions" id="id45">Row State Instructions</a></p></li>
<li><p><a class="reference internal" href="#padding-instruction" id="id46">Padding Instruction</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#call-frame-instruction-usage" id="id47">Call Frame Instruction Usage</a></p></li>
<li><p><a class="reference internal" href="#call-frame-calling-address" id="id48">Call Frame Calling Address</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#data-representation" id="id49">Data Representation</a></p>
<ul>
<li><p><a class="reference internal" href="#bit-and-64-bit-dwarf-formats" id="id50">32-Bit and 64-Bit DWARF Formats</a></p></li>
<li><p><a class="reference internal" href="#format-of-debugging-information" id="id51">Format of Debugging Information</a></p>
<ul>
<li><p><a class="reference internal" href="#attribute-encodings" id="id52">Attribute Encodings</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id1" id="id53">DWARF Expressions</a></p>
<ul>
<li><p><a class="reference internal" href="#operation-expressions" id="id54">Operation Expressions</a></p></li>
<li><p><a class="reference internal" href="#location-list-expressions" id="id55">Location List Expressions</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#source-languages" id="id56">Source Languages</a></p></li>
<li><p><a class="reference internal" href="#address-class-and-address-space-encodings" id="id57">Address Class and Address Space Encodings</a></p></li>
<li><p><a class="reference internal" href="#id2" id="id58">Line Number Information</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id59">Call Frame Information</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#attributes-by-tag-value-informative" id="id60">Attributes by Tag Value (Informative)</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#examples" id="id61">Examples</a></p></li>
<li><p><a class="reference internal" href="#references" id="id62">References</a></p></li>
</ul>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This document describes a <strong>provisional proposal</strong> for DWARF Version 6
[<a class="reference internal" href="#amdgpu-dwarf-dwarf"><span class="std std-ref">DWARF</span></a>] to support heterogeneous debugging. It is
not currently fully implemented and is subject to change.</p>
</div>
<div class="section" id="introduction">
<span id="amdgpu-dwarf-introduction"></span><h2><a class="toc-backref" href="#id4">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>AMD [<a class="reference internal" href="#amdgpu-dwarf-amd"><span class="std std-ref">AMD</span></a>] has been working on supporting heterogeneous
computing through the AMD Radeon Open Compute Platform (ROCm) [<a class="reference internal" href="#amdgpu-dwarf-amd-rocm"><span class="std std-ref">AMD-ROCm</span></a>]. A heterogeneous computing program can be written in a
high level language such as C++ or Fortran with OpenMP pragmas, OpenCL, or HIP
(a portable C++ programming environment for heterogeneous computing [<a class="reference internal" href="#amdgpu-dwarf-hip"><span class="std std-ref">HIP</span></a>]). A heterogeneous compiler and runtime allows a program to
execute on multiple devices within the same native process. Devices could
include CPUs, GPUs, DSPs, FPGAs, or other special purpose accelerators.
Currently HIP programs execute on systems with CPUs and GPUs.</p>
<p>ROCm is fully open sourced and includes contributions to open source projects
such as LLVM for compilation [<a class="reference internal" href="#amdgpu-dwarf-llvm"><span class="std std-ref">LLVM</span></a>] and GDB for
debugging [<a class="reference internal" href="#amdgpu-dwarf-gdb"><span class="std std-ref">GDB</span></a>], as well as collaboration with other
third party projects such as the GCC compiler [<a class="reference internal" href="#amdgpu-dwarf-gcc"><span class="std std-ref">GCC</span></a>]
and the Perforce TotalView HPC debugger [<a class="reference internal" href="#amdgpu-dwarf-perforce-totalview"><span class="std std-ref">Perforce-TotalView</span></a>].</p>
<p>To support debugging heterogeneous programs several features that are not
provided by current DWARF Version 5 [<a class="reference internal" href="#amdgpu-dwarf-dwarf"><span class="std std-ref">DWARF</span></a>] have
been identified. This document contains a collection of proposals to address
providing those features.</p>
<p>The <a class="reference internal" href="#amdgpu-dwarf-motivation"><span class="std std-ref">Motivation</span></a> section describes the issues that are being
addressed for heterogeneous computing. That is followed by the
<a class="reference internal" href="#amdgpu-dwarf-proposed-changes-relative-to-dwarf-version-5"><span class="std std-ref">Proposed Changes Relative to DWARF Version 5</span></a> section
containing the proposed textual changes relative to the DWARF Version 5
standard. Then there is an <a class="reference internal" href="#amdgpu-dwarf-examples"><span class="std std-ref">Examples</span></a> section that links to
the AMD GPU specific usage of the features in the proposal that includes an
example. Finally, there is a <a class="reference internal" href="#amdgpu-dwarf-references"><span class="std std-ref">References</span></a> section. There are a
number of notes included that raise open questions, or provide alternative
approaches considered. The draft proposal seeks to be general in nature and
backwards compatible with DWARF Version 5. Its goal is to be applicable to
meeting the needs of any heterogeneous system and not be vendor or architecture
specific.</p>
<p>A fundamental aspect of the draft proposal is that it allows DWARF expression
location descriptions as stack elements. The draft proposal is based on DWARF
Version 5 and maintains compatibility with DWARF Version 5. After attempting
several alternatives, the current thinking is that such an addition to DWARF
Version 5 is the simplest and cleanest way to support debugging optimized GPU
code. It also appears to be generally useful and may be able to address other
reported DWARF issues, as well as being helpful in providing better optimization
support for non-GPU code.</p>
<p>General feedback on this draft proposal is sought, together with suggestions on
how to clarify, simplify, or organize it before submitting it as a formal DWARF
proposal. The current draft proposal is large and may need to be split into
separate proposals before formal submission. Any suggestions on how best to do
that are appreciated. However, at the initial review stage it is believed there
is value in presenting a unified proposal as there are mutual dependencies
between the various parts that would not be as apparent if it was broken up into
separate independent proposals.</p>
<p>We are in the process of modifying LLVM and GDB to support this draft proposal
which is providing experience and insights. We plan to upstream the changes to
those projects for any final form of the proposal.</p>
<p>The author very much appreciates the input provided so far by many others which
has been incorporated into this current version.</p>
</div>
<div class="section" id="motivation">
<span id="amdgpu-dwarf-motivation"></span><h2><a class="toc-backref" href="#id5">Motivation</a><a class="headerlink" href="#motivation" title="Permalink to this headline">¶</a></h2>
<p>This document proposes a set of backwards compatible extensions to DWARF Version
5 [<a class="reference internal" href="#amdgpu-dwarf-dwarf"><span class="std std-ref">DWARF</span></a>] for consideration of inclusion into a
future DWARF Version 6 standard to support heterogeneous debugging.</p>
<p>The remainder of this section provides motivation for each proposed feature in
terms of heterogeneous debugging on commercially available AMD GPU hardware
(AMDGPU). The goal is to add support to the AMD [<a class="reference internal" href="#amdgpu-dwarf-amd"><span class="std std-ref">AMD</span></a>]
open source Radeon Open Compute Platform (ROCm) [<a class="reference internal" href="#amdgpu-dwarf-amd-rocm"><span class="std std-ref">AMD-ROCm</span></a>] which is an implementation of the industry standard
for heterogeneous computing devices defined by the Heterogeneous System
Architecture (HSA) Foundation [<a class="reference internal" href="#amdgpu-dwarf-hsa"><span class="std std-ref">HSA</span></a>]. ROCm includes the
LLVM compiler [<a class="reference internal" href="#amdgpu-dwarf-llvm"><span class="std std-ref">LLVM</span></a>] with upstreamed support for
AMDGPU [<a class="reference internal" href="#amdgpu-dwarf-amdgpu-llvm"><span class="std std-ref">AMDGPU-LLVM</span></a>]. The goal is to also add
the GDB debugger [<a class="reference internal" href="#amdgpu-dwarf-gdb"><span class="std std-ref">GDB</span></a>] with upstreamed support for
AMDGPU [<a class="reference internal" href="#amdgpu-dwarf-amd-rocgdb"><span class="std std-ref">AMD-ROCgdb</span></a>]. In addition, the goal is
to work with third parties to enable support for AMDGPU debugging in the GCC
compiler [<a class="reference internal" href="#amdgpu-dwarf-gcc"><span class="std std-ref">GCC</span></a>] and the Perforce TotalView HPC debugger
[<a class="reference internal" href="#amdgpu-dwarf-perforce-totalview"><span class="std std-ref">Perforce-TotalView</span></a>].</p>
<p>However, the proposal is intended to be vendor and architecture neutral. It is
believed to apply to other heterogeous hardware devices including GPUs, DSPs,
FPGAs, and other specialized hardware. These collectively include similar
characteristics and requirements as AMDGPU devices. Parts of the proposal can
also apply to traditional CPU hardware that supports large vector registers.
Compilers can map source languages and extensions that describe large scale
parallel execution onto the lanes of the vector registers. This is common in
programming languages used in ML and HPC. The proposal also includes improved
support for optimized code on any architecture. Some of the generalizations may
also benefit other issues that have been raised.</p>
<p>The proposal has evolved though collaboration with many individuals and active
prototyping within the GDB debugger and LLVM compiler. Input has also been very
much appreciated from the developers working on the Perforce TotalView HPC
Debugger and GCC compiler.</p>
<p>The AMDGPU has several features that require additional DWARF functionality in
order to support optimized code.</p>
<p>AMDGPU optimized code may spill vector registers to non-global address space
memory, and this spilling may be done only for lanes that are active on entry
to the subprogram. To support this, a location description that can be created
as a masked select is required. See <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_select_bit_piece</span></code>.</p>
<p>Since the active lane mask may be held in a register, a way to get the value
of a register on entry to a subprogram is required. To support this an
operation that returns the caller value of a register as specified by the Call
Frame Information (CFI) is required. See <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_call_frame_entry_reg</span></code>
and <a class="reference internal" href="#amdgpu-dwarf-call-frame-information"><span class="std std-ref">Call Frame Information</span></a>.</p>
<p>Current DWARF uses an empty expression to indicate an undefined location
description. Since the masked select composite location description operation
takes more than one location description, it is necessary to have an explicit
way to specify an undefined location description. Otherwise it is not possible
to specify that a particular one of the input location descriptions is
undefined. See <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_undefined</span></code>.</p>
<p>CFI describes restoring callee saved registers that are spilled. Currently CFI
only allows a location description that is a register, memory address, or
implicit location description. AMDGPU optimized code may spill scalar
registers into portions of vector registers. This requires extending CFI to
allow any location description. See
<a class="reference internal" href="#amdgpu-dwarf-call-frame-information"><span class="std std-ref">Call Frame Information</span></a>.</p>
<p>The vector registers of the AMDGPU are represented as their full wavefront
size, meaning the wavefront size times the dword size. This reflects the
actual hardware and allows the compiler to generate DWARF for languages that
map a thread to the complete wavefront. It also allows more efficient DWARF to
be generated to describe the CFI as only a single expression is required for
the whole vector register, rather than a separate expression for each lane’s
dword of the vector register. It also allows the compiler to produce DWARF
that indexes the vector register if it spills scalar registers into portions
of a vector registers.</p>
<p>Since DWARF stack value entries have a base type and AMDGPU registers are a
vector of dwords, the ability to specify that a base type is a vector is
required. See <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_vector_size</span></code>.</p>
<p>If the source language is mapped onto the AMDGPU wavefronts in a SIMT manner,
then the variable DWARF location expressions must compute the location for a
single lane of the wavefront. Therefore, a DWARF operation is required to
denote the current lane, much like <code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code> denotes the
current object. The <code class="docutils literal notranslate"><span class="pre">DW_OP_*piece</span></code> operations only allow literal indices.
Therefore, a way to use a computed offset of an arbitrary location description
(such as a vector register) is required. See <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_push_lane</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset_uconst</span></code>, and
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_bit_offset</span></code>.</p>
<p>If the source language is mapped onto the AMDGPU wavefronts in a SIMT manner
the compiler can use the AMDGPU execution mask register to control which lanes
are active. To describe the conceptual location of non-active lanes a DWARF
expression is needed that can compute a per lane PC. For efficiency, this is
done for the wavefront as a whole. This expression benefits by having a masked
select composite location description operation. This requires an attribute
for source location of each lane. The AMDGPU may update the execution mask for
whole wavefront operations and so needs an attribute that computes the current
active lane mask. See <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_select_bit_piece</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_extend</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code>, and <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_active_lane</span></code>.</p>
<p>AMDGPU needs to be able to describe addresses that are in different kinds of
memory. Optimized code may need to describe a variable that resides in pieces
that are in different kinds of storage which may include parts of registers,
memory that is in a mixture of memory kinds, implicit values, or be undefined.
DWARF has the concept of segment addresses. However, the segment cannot be
specified within a DWARF expression, which is only able to specify the offset
portion of a segment address. The segment index is only provided by the entity
that specifies the DWARF expression. Therefore, the segment index is a
property that can only be put on complete objects, such as a variable. That
makes it only suitable for describing an entity (such as variable or
subprogram code) that is in a single kind of memory. Therefore, AMDGPU uses
the DWARF concept of address spaces. For example, a variable may be allocated
in a register that is partially spilled to the call stack which is in the
private address space, and partially spilled to the local address space.</p>
<p>DWARF uses the concept of an address in many expression operations but does not
define how it relates to address spaces. For example,
<code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code> pushes the address of an object. Other contexts
implicitly push an address on the stack before evaluating an expression. For
example, the <code class="docutils literal notranslate"><span class="pre">DW_AT_use_location</span></code> attribute of the
<code class="docutils literal notranslate"><span class="pre">DW_TAG_ptr_to_member_type</span></code>. The expression that uses the address needs to
do so in a general way and not need to be dependent on the address space of
the address. For example, a pointer to member value may want to be applied to
an object that may reside in any address space.</p>
<p>The number of registers and the cost of memory operations is much higher for
AMDGPU than a typical CPU. The compiler attempts to optimize whole variables
and arrays into registers. Currently DWARF only allows
<code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code> and related operations to work with a global
memory location. To support AMDGPU optimized code it is required to generalize
DWARF to allow any location description to be used. This allows registers, or
composite location descriptions that may be a mixture of memory, registers, or
even implicit values.</p>
<p>DWARF Version 5 does not allow location descriptions to be entries on the
DWARF stack. They can only be the final result of the evaluation of a DWARF
expression. However, by allowing a location description to be a first-class
entry on the DWARF stack it becomes possible to compose expressions containing
both values and location descriptions naturally. It allows objects to be
located in any kind of memory address space, in registers, be implicit values,
be undefined, or a composite of any of these. By extending DWARF carefully,
all existing DWARF expressions can retain their current semantic meaning.
DWARF has implicit conversions that convert from a value that represents an
address in the default address space to a memory location description. This
can be extended to allow a default address space memory location description
to be implicitly converted back to its address value. This allows all DWARF
Version 5 expressions to retain their same meaning, while adding the ability
to explicitly create memory location descriptions in non-default address
spaces and generalizing the power of composite location descriptions to any
kind of location description. See <a class="reference internal" href="#amdgpu-dwarf-operation-expressions"><span class="std std-ref">DWARF Operation Expressions</span></a>.</p>
<p>To allow composition of composite location descriptions, an explicit operation
that indicates the end of the definition of a composite location description
is required. This can be implied if the end of a DWARF expression is reached,
allowing current DWARF expressions to remain legal. See
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_piece_end</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_OP_plus</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_OP_minus</span></code> can be defined to operate on a memory
location description in the default target architecture specific address space
and a generic type value to produce an updated memory location description. This
allows them to continue to be used to offset an address. To generalize
offsetting to any location description, including location descriptions that
describe when bytes are in registers, are implicit, or a composite of these, the
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset_uconst</span></code>, and
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_bit_offset</span></code> offset operations are added. Unlike <code class="docutils literal notranslate"><span class="pre">DW_OP_plus</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_OP_plus_uconst</span></code>, and <code class="docutils literal notranslate"><span class="pre">DW_OP_minus</span></code> arithmetic operations, these do not
define that integer overflow causes wrap-around. The offset operations can
operate on location storage of any size. For example, implicit location storage
could be any number of bits in size. It is simpler to define offsets that exceed
the size of the location storage as being ill-formed, than having to force an
implementation to support potentially infinite precision offsets to allow it to
correctly track a series of positive and negative offsets that may transiently
overflow or underflow, but end up in range. This is simple for the arithmetic
operations as they are defined in terms of two’s compliment arithmetic on a base
type of a fixed size.</p>
<p>Having the offset operations allows <code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code> to push a
location description that may be in a register, or be an implicit value, and the
DWARF expression of <code class="docutils literal notranslate"><span class="pre">DW_TAG_ptr_to_member_type</span></code> can contain them to offset
within it. <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_bit_offset</span></code> generalizes DWARF to work with bit fields
which is not possible in DWARF Version 5.</p>
<p>The DWARF <code class="docutils literal notranslate"><span class="pre">DW_OP_xderef*</span></code> operations allow a value to be converted into an
address of a specified address space which is then read. But it provides no
way to create a memory location description for an address in the non-default
address space. For example, AMDGPU variables can be allocated in the local
address space at a fixed address. It is required to have an operation to
create an address in a specific address space that can be used to define the
location description of the variable. Defining this operation to produce a
location description allows the size of addresses in an address space to be
larger than the generic type. See <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code>.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code> operation had to produce a value
that can be implicitly converted to a memory location description, then it
would be limited to the size of the generic type which matches the size of the
default address space. Its value would be unspecified and likely not match any
value in the actual program. By making the result a location description, it
allows a consumer great freedom in how it implements it. The implicit
conversion back to a value can be limited only to the default address space to
maintain compatibility with DWARF Version 5. For other address spaces the
producer can use the new operations that explicitly specify the address space.</p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_breg*</span></code> treats the register as containing an address in the default
address space. It is required to be able to specify the address space of the
register value. See <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_bregx</span></code>.</p>
<p>Similarly, <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> treats its implicit pointer value as
being in the default address space. It is required to be able to specify the
address space of the pointer value. See
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code>.</p>
<p>Almost all uses of addresses in DWARF are limited to defining location
descriptions, or to be dereferenced to read memory. The exception is
<code class="docutils literal notranslate"><span class="pre">DW_CFA_val_offset</span></code> which uses the address to set the value of a register.
By defining the CFA DWARF expression as being a memory location description,
it can maintain what address space it is, and that can be used to convert the
offset address back to an address in that address space. See
<a class="reference internal" href="#amdgpu-dwarf-call-frame-information"><span class="std std-ref">Call Frame Information</span></a>.</p>
<p>This approach allows all existing DWARF to have the identical semantics. It
allows the compiler to explicitly specify the address space it is using. For
example, a compiler could choose to access private memory in a swizzled manner
when mapping a source language to a wavefront in a SIMT manner, or to access
it in an unswizzled manner if mapping the same language with the wavefront
being the thread. It also allows the compiler to mix the address space it uses
to access private memory. For example, for SIMT it can still spill entire
vector registers in an unswizzled manner, while using a swizzled private
memory for SIMT variable access. This approach allows memory location
descriptions for different address spaces to be combined using the regular
<code class="docutils literal notranslate"><span class="pre">DW_OP_*piece</span></code> operations.</p>
<p>Location descriptions are an abstraction of storage, they give freedom to the
consumer on how to implement them. They allow the address space to encode lane
information so they can be used to read memory with only the memory
description and no extra arguments. The same set of operations can operate on
locations independent of their kind of storage. The <code class="docutils literal notranslate"><span class="pre">DW_OP_deref*</span></code> therefore
can be used on any storage kind. <code class="docutils literal notranslate"><span class="pre">DW_OP_xderef*</span></code> is unnecessary except to
become a more compact way to convert a non-default address space address
followed by dereferencing it.</p>
<p>In DWARF Version 5 a location description is defined as a single location
description or a location list. A location list is defined as either
effectively an undefined location description or as one or more single
location descriptions to describe an object with multiple places. The
<code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> operations can put a
location description on the stack. Furthermore, debugger information entry
attributes such as <code class="docutils literal notranslate"><span class="pre">DW_AT_data_member_location</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_AT_use_location</span></code>, and
<code class="docutils literal notranslate"><span class="pre">DW_AT_vtable_elem_location</span></code> are defined as pushing a location description
on the expression stack before evaluating the expression. However, DWARF
Version 5 only allows the stack to contain values and so only a single memory
address can be on the stack which makes these incapable of handling location
descriptions with multiple places, or places other than memory. Since this
proposal allows the stack to contain location descriptions, the operations are
generalized to support location descriptions that can have multiple places.
This is backwards compatible with DWARF Version 5 and allows objects with
multiple places to be supported. For example, the expression that describes
how to access the field of an object can be evaluated with a location
description that has multiple places and will result in a location description
with multiple places as expected. With this change, the separate DWARF Version
5 sections that described DWARF expressions and location lists have been
unified into a single section that describes DWARF expressions in general.
This unification seems to be a natural consequence and a necessity of allowing
location descriptions to be part of the evaluation stack.</p>
<p>For those familiar with the definition of location descriptions in DWARF
Version 5, the definition in this proposal is presented differently, but does
in fact define the same concept with the same fundamental semantics. However,
it does so in a way that allows the concept to extend to support address
spaces, bit addressing, the ability for composite location descriptions to be
composed of any kind of location description, and the ability to support
objects located at multiple places. Collectively these changes expand the set
of processors that can be supported and improves support for optimized code.</p>
<p>Several approaches were considered, and the one proposed appears to be the
cleanest and offers the greatest improvement of DWARF’s ability to support
optimized code. Examining the GDB debugger and LLVM compiler, it appears only
to require modest changes as they both already have to support general use of
location descriptions. It is anticipated that will also be the case for other
debuggers and compilers.</p>
<p>As an experiment, GDB was modified to evaluate DWARF Version 5 expressions
with location descriptions as stack entries and implicit conversions. All GDB
tests have passed, except one that turned out to be an invalid test by DWARF
Version 5 rules. The code in GDB actually became simpler as all evaluation was
on the stack and there was no longer a need to maintain a separate structure
for the location description result. This gives confidence of the backwards
compatibility.</p>
<p>Since the AMDGPU supports languages such as OpenCL [<a class="reference internal" href="#amdgpu-dwarf-opencl"><span class="std std-ref">OpenCL</span></a>], there is a need to define source language address
classes so they can be used in a consistent way by consumers. It would also be
desirable to add support for using them in defining language types rather than
the current target architecture specific address spaces. See
<a class="reference internal" href="#amdgpu-dwarf-segment-addresses"><span class="std std-ref">Segmented Addresses</span></a>.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_augmentation</span></code> attribute is added to a compilation unit
debugger information entry to indicate that there is additional target
architecture specific information in the debugging information entries of that
compilation unit. This allows a consumer to know what extensions are present
in the debugger information entries as is possible with the augmentation
string of other sections. The format that should be used for the augmentation
string in the lookup by name table and CFI Common Information Entry is also
recommended to allow a consumer to parse the string when it contains
information from multiple vendors.</p>
<p>The AMDGPU supports programming languages that include online compilation
where the source text may be created at runtime. Therefore, a way to embed the
source text in the debug information is required. For example, the OpenCL
language runtime supports online compilation. See
<a class="reference internal" href="#amdgpu-dwarf-line-number-information"><span class="std std-ref">Line Number Information</span></a>.</p>
<p>Support to allow MD5 checksums to be optionally present in the line table is
added. This allows linking together compilation units where some have MD5
checksums and some do not. In DWARF Version 5 the file timestamp and file size
can be optional, but if the MD5 checksum is present it must be valid for all
files. See <a class="reference internal" href="#amdgpu-dwarf-line-number-information"><span class="std std-ref">Line Number Information</span></a>.</p>
<p>Support is added for the HIP programming language [<a class="reference internal" href="#amdgpu-dwarf-hip"><span class="std std-ref">HIP</span></a>] which is supported by the AMDGPU. See
<a class="reference internal" href="#amdgpu-dwarf-language-names"><span class="std std-ref">Unit Entities</span></a>.</p>
<p>The following sections provide the definitions for the additional operations,
as well as clarifying how existing expression operations, CFI operations, and
attributes behave with respect to generalized location descriptions that
support address spaces and location descriptions that support multiple places.
It has been defined such that it is backwards compatible with DWARF Version 5.
The definitions are intended to fully define well-formed DWARF in a consistent
style based on the DWARF Version 5 specification. Non-normative text is shown
in <em>italics</em>.</p>
<p>The names for the new operations, attributes, and constants include “<code class="docutils literal notranslate"><span class="pre">LLVM</span></code>” and are encoded with vendor specific codes so this proposal can be
implemented as an LLVM vendor extension to DWARF Version 5. If accepted these
names would not include the “<code class="docutils literal notranslate"><span class="pre">LLVM</span></code>” and would not use encodings in the
vendor range.</p>
<p>The proposal is described in
<a class="reference internal" href="#amdgpu-dwarf-proposed-changes-relative-to-dwarf-version-5"><span class="std std-ref">Proposed Changes Relative to DWARF Version 5</span></a> and is
organized to follow the section ordering of DWARF Version 5. It includes notes
to indicate the corresponding DWARF Version 5 sections to which they pertain.
Other notes describe additional changes that may be worth considering, and to
raise questions.</p>
</div>
<div class="section" id="proposed-changes-relative-to-dwarf-version-5">
<span id="amdgpu-dwarf-proposed-changes-relative-to-dwarf-version-5"></span><h2><a class="toc-backref" href="#id6">Proposed Changes Relative to DWARF Version 5</a><a class="headerlink" href="#proposed-changes-relative-to-dwarf-version-5" title="Permalink to this headline">¶</a></h2>
<div class="section" id="general-description">
<h3><a class="toc-backref" href="#id7">General Description</a><a class="headerlink" href="#general-description" title="Permalink to this headline">¶</a></h3>
<div class="section" id="attribute-types">
<h4><a class="toc-backref" href="#id8">Attribute Types</a><a class="headerlink" href="#attribute-types" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This augments DWARF Version 5 section 2.2 and Table 2.2.</p>
</div>
<p>The following table provides the additional attributes. See
<a class="reference internal" href="#amdgpu-dwarf-debugging-information-entry-attributes"><span class="std std-ref">Debugging Information Entry Attributes</span></a>.</p>
<table class="docutils align-default" id="amdgpu-dwarf-attribute-names-table">
<caption><span class="caption-text">Attribute names</span><a class="headerlink" href="#amdgpu-dwarf-attribute-names-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 43%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Attribute</p></th>
<th class="head"><p>Usage</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_active_lane</span></code></p></td>
<td><p>SIMD or SIMT active lanes</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_augmentation</span></code></p></td>
<td><p>Compilation unit augmentation string</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code></p></td>
<td><p>SIMD or SIMT lane program location</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lanes</span></code></p></td>
<td><p>SIMD or SIMT thread lane count</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_vector_size</span></code></p></td>
<td><p>Base type vector size</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dwarf-expressions">
<span id="amdgpu-dwarf-expressions"></span><h4><a class="toc-backref" href="#id9">DWARF Expressions</a><a class="headerlink" href="#dwarf-expressions" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section, and its nested sections, replaces DWARF Version 5 section 2.5 and
section 2.6. The new proposed DWARF expression operations are defined as well
as clarifying the extensions to already existing DWARF Version 5 operations. It is
based on the text of the existing DWARF Version 5 standard.</p>
</div>
<p>DWARF expressions describe how to compute a value or specify a location.</p>
<p><em>The evaluation of a DWARF expression can provide the location of an object, the
value of an array bound, the length of a dynamic string, the desired value
itself, and so on.</em></p>
<p>The evaluation of a DWARF expression can either result in a value or a location
description:</p>
<p><em>value</em></p>
<blockquote>
<div><p>A value has a type and a literal value. It can represent a literal value of
any supported base type of the target architecture. The base type specifies
the size and encoding of the literal value.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It may be desirable to add an implicit pointer base type encoding. It would
be used for the type of the value that is produced when the <code class="docutils literal notranslate"><span class="pre">DW_OP_deref*</span></code>
operation retrieves the full contents of an implicit pointer location
storage created by the <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> or
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code> operations. The literal value would
record the debugging information entry and byte dispacement specified by the
associated <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> or
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code> operations.</p>
</div>
<p>Instead of a base type, a value can have a distinguished generic type, which
is an integral type that has the size of an address in the target architecture
default address space and unspecified signedness.</p>
<p><em>The generic type is the same as the unspecified type used for stack
operations defined in DWARF Version 4 and before.</em></p>
<p>An integral type is a base type that has an encoding of <code class="docutils literal notranslate"><span class="pre">DW_ATE_signed</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_ATE_signed_char</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_ATE_unsigned</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_ATE_unsigned_char</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_ATE_boolean</span></code>, or any target architecture defined integral encoding in
the inclusive range <code class="docutils literal notranslate"><span class="pre">DW_ATE_lo_user</span></code> to <code class="docutils literal notranslate"><span class="pre">DW_ATE_hi_user</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is unclear if <code class="docutils literal notranslate"><span class="pre">DW_ATE_address</span></code> is an integral type. GDB does not seem
to consider it as integral.</p>
</div>
</div></blockquote>
<p><em>location description</em></p>
<blockquote>
<div><p><em>Debugging information must provide consumers a way to find the location of
program variables, determine the bounds of dynamic arrays and strings, and
possibly to find the base address of a subprogram’s stack frame or the return
address of a subprogram. Furthermore, to meet the needs of recent computer
architectures and optimization techniques, debugging information must be able
to describe the location of an object whose location changes over the object’s
lifetime, and may reside at multiple locations simultaneously during parts of
an object’s lifetime.</em></p>
<p>Information about the location of program objects is provided by location
descriptions.</p>
<p>Location descriptions can consist of one or more single location descriptions.</p>
<p>A single location description specifies the location storage that holds a
program object and a position within the location storage where the program
object starts. The position within the location storage is expressed as a bit
offset relative to the start of the location storage.</p>
<p>A location storage is a linear stream of bits that can hold values. Each
location storage has a size in bits and can be accessed using a zero-based bit
offset. The ordering of bits within a location storage uses the bit numbering
and direction conventions that are appropriate to the current language on the
target architecture.</p>
<p>There are five kinds of location storage:</p>
<dl class="simple">
<dt><em>memory location storage</em></dt><dd><p>Corresponds to the target architecture memory address spaces.</p>
</dd>
<dt><em>register location storage</em></dt><dd><p>Corresponds to the target architecture registers.</p>
</dd>
<dt><em>implicit location storage</em></dt><dd><p>Corresponds to fixed values that can only be read.</p>
</dd>
<dt><em>undefined location storage</em></dt><dd><p>Indicates no value is available and therefore cannot be read or written.</p>
</dd>
<dt><em>composite location storage</em></dt><dd><p>Allows a mixture of these where some bits come from one location storage and
some from another location storage, or from disjoint parts of the same
location storage.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It may be better to add an implicit pointer location storage kind used by
the <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code>
operations. It would specify the debugger information entry and byte offset
provided by the operations.</p>
</div>
<p><em>Location descriptions are a language independent representation of addressing
rules. They are created using DWARF operation expressions of arbitrary
complexity. They can be the result of evaluting a debugger information entry
attribute that specifies an operation expression. In this usage they can
describe the location of an object as long as its lifetime is either static or
the same as the lexical block (see DWARF Version 5 section 3.5) that owns it,
and it does not move during its lifetime. They can be the result of evaluating
a debugger information entry attribute that specifies a location list
expression. In this usage they can describe the location of an object that has
a limited lifetime, changes its location during its lifetime, or has multiple
locations over part or all of its lifetime.</em></p>
<p>If a location description has more than one single location description, the
DWARF expression is ill-formed if the object value held in each single
location description’s position within the associated location storage is not
the same value, except for the parts of the value that are uninitialized.</p>
<p><em>A location description that has more than one single location description can
only be created by a location list expression that has overlapping program
location ranges, or certain expression operations that act on a location
description that has more than one single location description. There are no
operation expression operations that can directly create a location
description with more than one single location description.</em></p>
<p><em>A location description with more than one single location description can be
used to describe objects that reside in more than one piece of storage at the
same time. An object may have more than one location as a result of
optimization. For example, a value that is only read may be promoted from
memory to a register for some region of code, but later code may revert to
reading the value from memory as the register may be used for other purposes.
For the code region where the value is in a register, any change to the object
value must be made in both the register and the memory so both regions of code
will read the updated value.</em></p>
<p><em>A consumer of a location description with more than one single location
description can read the object’s value from any of the single location
descriptions (since they all refer to location storage that has the same
value), but must write any changed value to all the single location
descriptions.</em></p>
</div></blockquote>
<p>A DWARF expression can either be encoded as a operation expression (see
<a class="reference internal" href="#amdgpu-dwarf-operation-expressions"><span class="std std-ref">DWARF Operation Expressions</span></a>), or as a location list expression
(see <a class="reference internal" href="#amdgpu-dwarf-location-list-expressions"><span class="std std-ref">DWARF Location List Expressions</span></a>).</p>
<p>A DWARF expression is evaluated in the context of:</p>
<dl>
<dt><em>A current subprogram</em></dt><dd><p>This may be used in the evaluation of register access operations to support
virtual unwinding of the call stack (see
<a class="reference internal" href="#amdgpu-dwarf-call-frame-information"><span class="std std-ref">Call Frame Information</span></a>).</p>
</dd>
<dt><em>A current program location</em></dt><dd><p>This may be used in the evaluation of location list expressions to select
amongst multiple program location ranges. It should be the program location
corresponding to the current subprogram. If the current subprogram was reached
by virtual call stack unwinding, then the program location will correspond to
the associated call site.</p>
</dd>
<dt><em>An initial stack</em></dt><dd><p>This is a list of values or location descriptions that will be pushed on the
operation expression evaluation stack in the order provided before evaluation
of an operation expression starts.</p>
<p>Some debugger information entries have attributes that evaluate their DWARF
expression value with initial stack entries. In all other cases the initial
stack is empty.</p>
</dd>
</dl>
<p>When a DWARF expression is evaluated, it may be specified whether a value or
location description is required as the result kind.</p>
<p>If a result kind is specified, and the result of the evaluation does not match
the specified result kind, then the implicit conversions described in
<a class="reference internal" href="#amdgpu-dwarf-memory-location-description-operations"><span class="std std-ref">Memory Location Description Operations</span></a> are performed if
valid. Otherwise, the DWARF expression is ill-formed.</p>
<div class="section" id="dwarf-operation-expressions">
<span id="amdgpu-dwarf-operation-expressions"></span><h5><a class="toc-backref" href="#id10">DWARF Operation Expressions</a><a class="headerlink" href="#dwarf-operation-expressions" title="Permalink to this headline">¶</a></h5>
<p>An operation expression is comprised of a stream of operations, each consisting
of an opcode followed by zero or more operands. The number of operands is
implied by the opcode.</p>
<p>Operations represent a postfix operation on a simple stack machine. Each stack
entry can hold either a value or a location description. Operations can act on
entries on the stack, including adding entries and removing entries. If the kind
of a stack entry does not match the kind required by the operation and is not
implicitly convertible to the required kind (see
<a class="reference internal" href="#amdgpu-dwarf-memory-location-description-operations"><span class="std std-ref">Memory Location Description Operations</span></a>), then the DWARF
operation expression is ill-formed.</p>
<p>Evaluation of an operation expression starts with an empty stack on which the
entries from the initial stack provided by the context are pushed in the order
provided. Then the operations are evaluated, starting with the first operation
of the stream, until one past the last operation of the stream is reached. The
result of the evaluation is:</p>
<ul>
<li><p>If evaluation of the DWARF expression requires a location description, then:</p>
<ul>
<li><p>If the stack is empty, the result is a location description with one
undefined location description.</p>
<p><em>This rule is for backwards compatibility with DWARF Version 5 which has no
explicit operation to create an undefined location description, and uses an
empty operation expression for this purpose.</em></p>
</li>
<li><p>If the top stack entry is a location description, or can be converted
to one (see <a class="reference internal" href="#amdgpu-dwarf-memory-location-description-operations"><span class="std std-ref">Memory Location Description Operations</span></a>),
then the result is that, possibly converted, location description. Any other
entries on the stack are discarded.</p></li>
<li><p>Otherwise the DWARF expression is ill-formed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Could define this case as returning an implicit location description as
if the <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit</span></code> operation is performed.</p>
</div>
</li>
</ul>
</li>
<li><p>If evaluation of the DWARF expression requires a value, then:</p>
<ul class="simple">
<li><p>If the top stack entry is a value, or can be converted to one (see
<a class="reference internal" href="#amdgpu-dwarf-memory-location-description-operations"><span class="std std-ref">Memory Location Description Operations</span></a>), then the result
is that, possibly converted, value. Any other entries on the stack are
discarded.</p></li>
<li><p>Otherwise the DWARF expression is ill-formed.</p></li>
</ul>
</li>
<li><p>If evaluation of the DWARF expression does not specify if a value or location
description is required, then:</p>
<ul>
<li><p>If the stack is empty, the result is a location description with one
undefined location description.</p>
<p><em>This rule is for backwards compatibility with DWARF Version 5 which has no
explicit operation to create an undefined location description, and uses an
empty operation expression for this purpose.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This rule is consistent with the rule above for when a location
description is requested. However, GDB appears to report this as an error
and no GDB tests appear to cause an empty stack for this case.</p>
</div>
</li>
<li><p>Otherwise, the top stack entry is returned. Any other entries on the stack
are discarded.</p></li>
</ul>
</li>
</ul>
<p>An operation expression is encoded as a byte block with some form of prefix that
specifies the byte count. It can be used:</p>
<ul class="simple">
<li><p>as the value of a debugging information entry attribute that is encoded using
class <code class="docutils literal notranslate"><span class="pre">exprloc</span></code> (see DWARF Version 5 section 7.5.5),</p></li>
<li><p>as the operand to certain operation expression operations,</p></li>
<li><p>as the operand to certain call frame information operations (see
<a class="reference internal" href="#amdgpu-dwarf-call-frame-information"><span class="std std-ref">Call Frame Information</span></a>),</p></li>
<li><p>and in location list entries (see
<a class="reference internal" href="#amdgpu-dwarf-location-list-expressions"><span class="std std-ref">DWARF Location List Expressions</span></a>).</p></li>
</ul>
<div class="section" id="stack-operations">
<span id="amdgpu-dwarf-stack-operations"></span><h6><a class="toc-backref" href="#id11">Stack Operations</a><a class="headerlink" href="#stack-operations" title="Permalink to this headline">¶</a></h6>
<p>The following operations manipulate the DWARF stack. Operations that index the
stack assume that the top of the stack (most recently added entry) has index 0.
They allow the stack entries to be either a value or location description.</p>
<p>If any stack entry accessed by a stack operation is an incomplete composite
location description (see
<a class="reference internal" href="#amdgpu-dwarf-composite-location-description-operations"><span class="std std-ref">Composite Location Description Operations</span></a>), then the DWARF
expression is ill-formed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These operations now support stack entries that are values and location
descriptions.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If it is desired to also make them work with incomplete composite location
descriptions, then would need to define that the composite location storage
specified by the incomplete composite location description is also replicated
when a copy is pushed. This ensures that each copy of the incomplete composite
location description can update the composite location storage they specify
independently.</p>
</div>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_dup</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_dup</span></code> duplicates the stack entry at the top of the stack.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_drop</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_drop</span></code> pops the stack entry at the top of the stack and discards it.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_pick</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_pick</span></code> has a single unsigned 1-byte operand that represents an index
I. A copy of the stack entry with index I is pushed onto the stack.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_over</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_over</span></code> pushes a copy of the entry with index 1.</p>
<p><em>This is equivalent to a ``DW_OP_pick 1`` operation.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_swap</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_swap</span></code> swaps the top two stack entries. The entry at the top of the
stack becomes the second stack entry, and the second stack entry becomes the
top of the stack.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_rot</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_rot</span></code> rotates the first three stack entries. The entry at the top of
the stack becomes the third stack entry, the second entry becomes the top of
the stack, and the third entry becomes the second entry.</p>
</li>
</ol>
</div>
<div class="section" id="control-flow-operations">
<span id="amdgpu-dwarf-control-flow-operations"></span><h6><a class="toc-backref" href="#id12">Control Flow Operations</a><a class="headerlink" href="#control-flow-operations" title="Permalink to this headline">¶</a></h6>
<p>The following operations provide simple control of the flow of a DWARF operation
expression.</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_nop</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_nop</span></code> is a place holder. It has no effect on the DWARF stack
entries.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_le</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_ge</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_eq</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_lt</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_gt</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_OP_ne</span></code></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The same as in DWARF Version 5 section 2.5.1.5.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_skip</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_skip</span></code> is an unconditional branch. Its single operand is a 2-byte
signed integer constant. The 2-byte constant is the number of bytes of the
DWARF expression to skip forward or backward from the current operation,
beginning after the 2-byte constant.</p>
<p>If the updated position is at one past the end of the last operation, then
the operation expression evaluation is complete.</p>
<p>Otherwise, the DWARF expression is ill-formed if the updated operation
position is not in the range of the first to last operation inclusive, or
not at the start of an operation.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_bra</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_bra</span></code> is a conditional branch. Its single operand is a 2-byte signed
integer constant. This operation pops the top of stack. If the value popped
is not the constant 0, the 2-byte constant operand is the number of bytes of
the DWARF operation expression to skip forward or backward from the current
operation, beginning after the 2-byte constant.</p>
<p>If the updated position is at one past the end of the last operation, then
the operation expression evaluation is complete.</p>
<p>Otherwise, the DWARF expression is ill-formed if the updated operation
position is not in the range of the first to last operation inclusive, or
not at the start of an operation.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_call2,</span> <span class="pre">DW_OP_call4,</span> <span class="pre">DW_OP_call_ref</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_call2</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_call4</span></code>, and <code class="docutils literal notranslate"><span class="pre">DW_OP_call_ref</span></code> perform DWARF
procedure calls during evaluation of a DWARF expression.</p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_call2</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_OP_call4</span></code>, have one operand that is a 2- or 4-byte
unsigned offset, respectively, of a debugging information entry D in the
current compilation unit.</p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_call_ref</span></code> has one operand that is a 4-byte unsigned value in the
32-bit DWARF format, or an 8-byte unsigned value in the 64-bit DWARF format,
that represents an offset of a debugging information entry D in a
<code class="docutils literal notranslate"><span class="pre">.debug_info</span></code> section, which may be contained in an executable or shared
object file other than that containing the operation. For references from
one executable or shared object file to another, the relocation must be
performed by the consumer.</p>
<p><em>Operand interpretation of</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_call2</span></code><em>,</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_call4</span></code><em>, and</em>
<code class="docutils literal notranslate"><span class="pre">DW_OP_call_ref</span></code> <em>is exactly like that for</em> <code class="docutils literal notranslate"><span class="pre">DW_FORM_ref2</span></code><em>,
``DW_FORM_ref4``*, and</em> <code class="docutils literal notranslate"><span class="pre">DW_FORM_ref_addr</span></code><em>, respectively.</em></p>
<p>The call operation is evaluated by:</p>
<ul>
<li><p>If D has a <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> attribute that is encoded as a <code class="docutils literal notranslate"><span class="pre">exprloc</span></code>
that specifies an operation expression E, then execution of the current
operation expression continues from the first operation of E. Execution
continues until one past the last operation of E is reached, at which
point execution continues with the operation following the call operation.
Since E is evaluated on the same stack as the call, E can use, add, and/or
remove entries already on the stack.</p>
<p><em>Values on the stack at the time of the call may be used as parameters by
the called expression and values left on the stack by the called expression
may be used as return values by prior agreement between the calling and
called expressions.</em></p>
</li>
<li><p>If D has a <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> attribute that is encoded as a <code class="docutils literal notranslate"><span class="pre">loclist</span></code> or
<code class="docutils literal notranslate"><span class="pre">loclistsptr</span></code>, then the specified location list expression E is
evaluated, and the resulting location description is pushed on the stack.
The evaluation of E uses a context that has the same current frame and
current program location as the current operation expression, but an empty
initial stack.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This rule avoids having to define how to execute a matched location list
entry operation expression on the same stack as the call when there are
multiple matches. But it allows the call to obtain the location
description for a variable or formal parameter which may use a location
list expression.</p>
<p>An alternative is to treat the case when D has a <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code>
attribute that is encoded as a <code class="docutils literal notranslate"><span class="pre">loclist</span></code> or <code class="docutils literal notranslate"><span class="pre">loclistsptr</span></code>, and the
specified location list expression E’ matches a single location list
entry with operation expression E, the same as the <code class="docutils literal notranslate"><span class="pre">exprloc</span></code> case and
evaluate on the same stack.</p>
<p>But this is not attractive as if the attribute is for a variable that
happens to end with a non-singleton stack, it will not simply put a
location description on the stack. Presumably the intent of using
<code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> on a variable or formal parameter debugger information
entry is to push just one location description on the stack. That
location description may have more than one single location description.</p>
<p>The previous rule for <code class="docutils literal notranslate"><span class="pre">exprloc</span></code> also has the same problem as normally
a variable or formal parameter location expression may leave multiple
entries on the stack and only return the top entry.</p>
<p>GDB implements <code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> by always executing E on the same stack.
If the location list has multiple matching entries, it simply picks the
first one and ignores the rest. This seems fundementally at odds with
the desire to supporting multiple places for variables.</p>
<p>So, it feels like <code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> should both support pushing a location
description on the stack for a variable or formal parameter, and also
support being able to execute an operation expression on the same stack.
Being able to specify a different operation expression for different
program locations seems a desirable feature to retain.</p>
<p>A solution to that is to have a distinct <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_proc</span></code> attribute
for the <code class="docutils literal notranslate"><span class="pre">DW_TAG_dwarf_procedure</span></code> debugging information entry. Then the
<code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> attribute expression is always executed separately
and pushes a location description (that may have multiple single
location descriptions), and the <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_proc</span></code> attribute expression
is always executed on the same stack and can leave anything on the
stack.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_proc</span></code> attribute could have the new classes
<code class="docutils literal notranslate"><span class="pre">exprproc</span></code>, <code class="docutils literal notranslate"><span class="pre">loclistproc</span></code>, and <code class="docutils literal notranslate"><span class="pre">loclistsptrproc</span></code> to indicate that
the expression is executed on the same stack. <code class="docutils literal notranslate"><span class="pre">exprproc</span></code> is the same
encoding as <code class="docutils literal notranslate"><span class="pre">exprloc</span></code>. <code class="docutils literal notranslate"><span class="pre">loclistproc</span></code> and <code class="docutils literal notranslate"><span class="pre">loclistsptrproc</span></code> are the
same encoding as their non-<code class="docutils literal notranslate"><span class="pre">proc</span></code> counterparts except the DWARF is
ill-formed if the location list does not match exactly one location list
entry and a default entry is required. These forms indicate explicitly
that the matched single operation expression must be executed on the
same stack. This is better than ad hoc special rules for <code class="docutils literal notranslate"><span class="pre">loclistproc</span></code>
and <code class="docutils literal notranslate"><span class="pre">loclistsptrproc</span></code> which are currently clearly defined to always
return a location description. The producer then explicitly indicates
the intent through the attribute classes.</p>
<p>Such a change would be a breaking change for how GDB implements
<code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code>. However, are the breaking cases actually occurring in
practice? GDB could implement the current approach for DWARF Version 5,
and the new semantics for DWARF Version 6 which has been done for some
other features.</p>
<p>Another option is to limit the execution to be on the same stack only to
the evaluation of an expression E that is the value of a
<code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> attribute of a <code class="docutils literal notranslate"><span class="pre">DW_TAG_dwarf_procedure</span></code> debugging
information entry. The DWARF would be ill-formed if E is a location list
expression that does not match exactly one location list entry. In all
other cases the evaluation of an expression E that is the value of a
<code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> attribute would evaluate E with a context that has
the same current frame and current program location as the current
operation expression, but an empty initial stack, and push the resulting
location description on the stack.</p>
</div>
</li>
<li><p>If D has a <code class="docutils literal notranslate"><span class="pre">DW_AT_const_value</span></code> attribute with a value V, then it is as
if a <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_value</span> <span class="pre">V</span></code> operation was executed.</p>
<p><em>This allows a call operation to be used to compute the location
description for any variable or formal parameter regardless of whether the
producer has optimized it to a constant. This is consistent with the
``DW_OP_implicit_pointer`` operation.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Alternatively, could deprecate using <code class="docutils literal notranslate"><span class="pre">DW_AT_const_value</span></code> for
<code class="docutils literal notranslate"><span class="pre">DW_TAG_variable</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_TAG_formal_parameter</span></code> debugger information
entries that are constants and instead use <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> with an
operation expression that results in a location description with one
implicit location description. Then this rule would not be required.</p>
</div>
</li>
<li><p>Otherwise, there is no effect and no changes are made to the stack.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In DWARF Version 5, if D does not have a <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> then
<code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> is defined to have no effect. It is unclear that this is
the right definition as a producer should be able to rely on using
<code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> to get a location description for any non-<code class="docutils literal notranslate"><span class="pre">DW_TAG_dwarf_procedure</span></code> debugging information entries. Also, the
producer should not be creating DWARF with <code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> to a
<code class="docutils literal notranslate"><span class="pre">DW_TAG_dwarf_procedure</span></code> that does not have a <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code>
attribute. So, should this case be defined as an ill-formed DWARF
expression?</p>
</div>
</li>
</ul>
<p><em>The</em> <code class="docutils literal notranslate"><span class="pre">DW_TAG_dwarf_procedure</span></code> <em>debugging information entry can be used to
define DWARF procedures that can be called.</em></p>
</li>
</ol>
</div>
<div class="section" id="value-operations">
<span id="amdgpu-dwarf-value-operations"></span><h6><a class="toc-backref" href="#id13">Value Operations</a><a class="headerlink" href="#value-operations" title="Permalink to this headline">¶</a></h6>
<p>This section describes the operations that push values on the stack.</p>
<p>Each value stack entry has a type and a literal value and can represent a
literal value of any supported base type of the target architecture. The base
type specifies the size and encoding of the literal value.</p>
<p>Instead of a base type, value stack entries can have a distinguished generic
type, which is an integral type that has the size of an address in the target
architecture default address space and unspecified signedness.</p>
<p><em>The generic type is the same as the unspecified type used for stack operations
defined in DWARF Version 4 and before.</em></p>
<p>An integral type is a base type that has an encoding of <code class="docutils literal notranslate"><span class="pre">DW_ATE_signed</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_ATE_signed_char</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_ATE_unsigned</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_ATE_unsigned_char</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_ATE_boolean</span></code>, or any target architecture defined integral encoding in the
inclusive range <code class="docutils literal notranslate"><span class="pre">DW_ATE_lo_user</span></code> to <code class="docutils literal notranslate"><span class="pre">DW_ATE_hi_user</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unclear if <code class="docutils literal notranslate"><span class="pre">DW_ATE_address</span></code> is an integral type. GDB does not seem to
consider it as integral.</p>
</div>
<div class="section" id="literal-operations">
<span id="amdgpu-dwarf-literal-operations"></span><h7><a class="toc-backref" href="#id14">Literal Operations</a><a class="headerlink" href="#literal-operations" title="Permalink to this headline">¶</a></h7>
<p>The following operations all push a literal value onto the DWARF stack.</p>
<p>Operations other than <code class="docutils literal notranslate"><span class="pre">DW_OP_const_type</span></code> push a value V with the generic type.
If V is larger than the generic type, then V is truncated to the generic type
size and the low-order bits used.</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_lit0</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_lit1</span></code>, …, <code class="docutils literal notranslate"><span class="pre">DW_OP_lit31</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_lit&lt;N&gt;</span></code> operations encode an unsigned literal value N from 0
through 31, inclusive. They push the value N with the generic type.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_const1u</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_const2u</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_const4u</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_const8u</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_const&lt;N&gt;u</span></code> operations have a single operand that is a 1, 2, 4, or
8-byte unsigned integer constant U, respectively. They push the value U with
the generic type.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_const1s</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_const2s</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_const4s</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_const8s</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_const&lt;N&gt;s</span></code> operations have a single operand that is a 1, 2, 4, or
8-byte signed integer constant S, respectively. They push the value S with
the generic type.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span></code> has a single unsigned LEB128 integer operand N. It pushes
the value N with the generic type.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_consts</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_consts</span></code> has a single signed LEB128 integer operand N. It pushes the
value N with the generic type.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_constx</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_constx</span></code> has a single unsigned LEB128 integer operand that
represents a zero-based index into the <code class="docutils literal notranslate"><span class="pre">.debug_addr</span></code> section relative to
the value of the <code class="docutils literal notranslate"><span class="pre">DW_AT_addr_base</span></code> attribute of the associated compilation
unit. The value N in the <code class="docutils literal notranslate"><span class="pre">.debug_addr</span></code> section has the size of the generic
type. It pushes the value N with the generic type.</p>
<p><em>The</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_constx</span></code> <em>operation is provided for constants that require
link-time relocation but should not be interpreted by the consumer as a
relocatable address (for example, offsets to thread-local storage).</em></p>
</li>
</ol>
<ol class="arabic" start="9">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_const_type</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_const_type</span></code> has three operands. The first is an unsigned LEB128
integer that represents the offset of a debugging information entry D in the
current compilation unit, that provides the type of the constant value. The
second is a 1-byte unsigned integral constant S. The third is a block of
bytes B, with a length equal to S.</p>
<p>T is the bit size of the type D. The least significant T bits of B are
interpreted as a value V of the type D. It pushes the value V with the type
D.</p>
<p>The DWARF is ill-formed if D is not a <code class="docutils literal notranslate"><span class="pre">DW_TAG_base_type</span></code> debugging
information entry, or if T divided by 8 and rounded up to a multiple of 8
(the byte size) is not equal to S.</p>
<p><em>While the size of the byte block B can be inferred from the type D
definition, it is encoded explicitly into the operation so that the
operation can be parsed easily without reference to the</em> <code class="docutils literal notranslate"><span class="pre">.debug_info</span></code>
<em>section.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_push_lane</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_push_lane</span></code> pushes a value with the generic type that is the
target architecture specific lane identifier of the thread of execution for
which a user presented expression is currently being evaluated.</p>
<p><em>For languages that are implemented using a SIMD or SIMT execution model,
this is the lane number that corresponds to the source language thread of
execution upon which the user is focused.</em></p>
</li>
</ol>
</div>
<div class="section" id="arithmetic-and-logical-operations">
<span id="amdgpu-dwarf-arithmetic-logical-operations"></span><h7><a class="toc-backref" href="#id15">Arithmetic and Logical Operations</a><a class="headerlink" href="#arithmetic-and-logical-operations" title="Permalink to this headline">¶</a></h7>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section is the same as DWARF Version 5 section 2.5.1.4.</p>
</div>
</div>
<div class="section" id="type-conversion-operations">
<span id="amdgpu-dwarf-type-conversions-operations"></span><h7><a class="toc-backref" href="#id16">Type Conversion Operations</a><a class="headerlink" href="#type-conversion-operations" title="Permalink to this headline">¶</a></h7>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section is the same as DWARF Version 5 section 2.5.1.6.</p>
</div>
</div>
<div class="section" id="special-value-operations">
<span id="amdgpu-dwarf-general-operations"></span><h7><a class="toc-backref" href="#id17">Special Value Operations</a><a class="headerlink" href="#special-value-operations" title="Permalink to this headline">¶</a></h7>
<p>There are these special value operations currently defined:</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_regval_type</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_regval_type</span></code> has two operands. The first is an unsigned LEB128
integer that represents a register number R. The second is an unsigned
LEB128 integer that represents the offset of a debugging information entry D
in the current compilation unit, that provides the type of the register
value.</p>
<p>The contents of register R are interpreted as a value V of the type D. The
value V is pushed on the stack with the type D.</p>
<p>The DWARF is ill-formed if D is not a <code class="docutils literal notranslate"><span class="pre">DW_TAG_base_type</span></code> debugging
information entry, or if the size of type D is not the same as the size of
register R.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Should DWARF allow the type D to be a different size to the size of the
register R? Requiring them to be the same bit size avoids any issue of
conversion as the bit contents of the register is simply interpreted as a
value of the specified type. If a conversion is wanted it can be done
explicitly using a <code class="docutils literal notranslate"><span class="pre">DW_OP_convert</span></code> operation.</p>
<p>GDB has a per register hook that allows a target specific conversion on a
register by register basis. It defaults to truncation of bigger registers,
and to actually reading bytes from the next register (or reads out of
bounds for the last register) for smaller registers. There are no GDB
tests that read a register out of bounds (except an illegal hand written
assembly test).</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_deref</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_OP_deref</span></code> operation pops one stack entry that must be a location
description L.</p>
<p>A value of the bit size of the generic type is retrieved from the location
storage specified by L. The value V retrieved is pushed on the stack with
the generic type.</p>
<p>If any bit of the value is retrieved from the undefined location storage, or
the offset of any bit exceeds the size of the location storage specified by
L, then the DWARF expression is ill-formed.</p>
<p>See <a class="reference internal" href="#amdgpu-dwarf-implicit-location-descriptions"><span class="std std-ref">Implicit Location Description Operations</span></a> for special rules
concerning implicit location descriptions created by the
<code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_implicit_aspace_pointer</span></code>
operations.</p>
<p><em>If L, or the location description of any composite location description
part that is a subcomponent of L, has more than one single location
description, then any one of them can be selected as they are required to
all have the same value. For any single location description SL, bits are
retrieved from the associated storage location starting at the bit offset
specified by SL. For a composite location description, the retrieved bits
are the concatenation of the N bits from each composite location part PL,
where N is limited to the size of PL.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_deref_size</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_deref_size</span></code> has a single 1-byte unsigned integral constant that
represents a byte result size S.</p>
<p>It pops one stack entry that must be a location description L.</p>
<p>T is the smaller of the generic type size and S scaled by 8 (the byte size).
A value V of T bits is retrieved from the location storage specified by L.
If V is smaller than the size of the generic type, V is zero-extended to the
generic type size. V is pushed onto the stack with the generic type.</p>
<p>The DWARF expression is ill-formed if any bit of the value is retrieved from
the undefined location storage, or if the offset of any bit exceeds the size
of the location storage specified by L.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Truncating the value when S is larger than the generic type matches what
GDB does. This allows the generic type size to not be a integral byte
size. It does allow S to be arbitrarily large. Should S be restricted to
the size of the generic type rounded up to a multiple of 8?</p>
</div>
<p>See <a class="reference internal" href="#amdgpu-dwarf-implicit-location-descriptions"><span class="std std-ref">Implicit Location Description Operations</span></a> for special rules
concerning implicit location descriptions created by the
<code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_implicit_aspace_pointer</span></code>
operations.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_deref_type</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_deref_type</span></code> has two operands. The first is a 1-byte unsigned
integral constant S. The second is an unsigned LEB128 integer that
represents the offset of a debugging information entry D in the current
compilation unit, that provides the type of the result value.</p>
<p>It pops one stack entry that must be a location description L. T is the bit
size of the type D. A value V of T bits is retrieved from the location
storage specified by L. V is pushed on the stack with the type D.</p>
<p>The DWARF is ill-formed if D is not a <code class="docutils literal notranslate"><span class="pre">DW_TAG_base_type</span></code> debugging
information entry, if T divided by 8 and rounded up to a multiple of 8 (the
byte size) is not equal to S, if any bit of the value is retrieved from the
undefined location storage, or if the offset of any bit exceeds the size of
the location storage specified by L.</p>
<p>See <a class="reference internal" href="#amdgpu-dwarf-implicit-location-descriptions"><span class="std std-ref">Implicit Location Description Operations</span></a> for special rules
concerning implicit location descriptions created by the
<code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_implicit_aspace_pointer</span></code>
operations.</p>
<p><em>While the size of the pushed value V can be inferred from the type D
definition, it is encoded explicitly into the operation so that the
operation can be parsed easily without reference to the</em> <code class="docutils literal notranslate"><span class="pre">.debug_info</span></code>
<em>section.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is unclear why the operand S is needed. Unlike <code class="docutils literal notranslate"><span class="pre">DW_OP_const_type</span></code>,
the size is not needed for parsing. Any evaluation needs to get the base
type to record with the value to know its encoding and bit size.</p>
<p>This definition allows the base type to be a bit size since there seems no
reason to restrict it.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_xderef</span></code> <em>Deprecated</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_xderef</span></code> pops two stack entries. The first must be an integral type
value that represents an address A. The second must be an integral type
value that represents a target architecture specific address space
identifier AS.</p>
<p>The operation is equivalent to performing <code class="docutils literal notranslate"><span class="pre">DW_OP_swap;</span>
<span class="pre">DW_OP_LLVM_form_aspace_address;</span> <span class="pre">DW_OP_deref</span></code>. The value V retrieved is left
on the stack with the generic type.</p>
<p><em>This operation is deprecated as the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code>
<em>operation can be used and provides greater expressiveness.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_xderef_size</span></code> <em>Deprecated</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_xderef_size</span></code> has a single 1-byte unsigned integral constant that
represents a byte result size S.</p>
<p>It pops two stack entries. The first must be an integral type value that
represents an address A. The second must be an integral type value that
represents a target architecture specific address space identifier AS.</p>
<p>The operation is equivalent to performing <code class="docutils literal notranslate"><span class="pre">DW_OP_swap;</span>
<span class="pre">DW_OP_LLVM_form_aspace_address;</span> <span class="pre">DW_OP_deref_size</span> <span class="pre">S</span></code>. The zero-extended
value V retrieved is left on the stack with the generic type.</p>
<p><em>This operation is deprecated as the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code>
<em>operation can be used and provides greater expressiveness.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_xderef_type</span></code> <em>Deprecated</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_xderef_type</span></code> has two operands. The first is a 1-byte unsigned
integral constant S. The second operand is an unsigned LEB128
integer R that represents the offset of a debugging information entry D in
the current compilation unit, that provides the type of the result value.</p>
<p>It pops two stack entries. The first must be an integral type value that
represents an address A. The second must be an integral type value that
represents a target architecture specific address space identifier AS.</p>
<p>The operation is equivalent to performing <code class="docutils literal notranslate"><span class="pre">DW_OP_swap;</span>
<span class="pre">DW_OP_LLVM_form_aspace_address;</span> <span class="pre">DW_OP_deref_type</span> <span class="pre">S</span> <span class="pre">R</span></code>. The value V
retrieved is left on the stack with the type D.</p>
<p><em>This operation is deprecated as the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code>
<em>operation can be used and provides greater expressiveness.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_entry_value</span></code> <em>Deprecated</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_entry_value</span></code> pushes the value that the described location held upon
entering the current subprogram.</p>
<p>It has two operands. The first is an unsigned LEB128 integer S. The second
is a block of bytes, with a length equal S, interpreted as a DWARF
operation expression E.</p>
<p>E is evaluated as if it had been evaluated upon entering the current
subprogram with an empty initial stack.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is unclear what this means. What is the current program location and
current frame that must be used? Does this require reverse execution so
the register and memory state are as it was on entry to the current
subprogram?</p>
</div>
<p>The DWARF expression is ill-formed if the evaluation of E executes a
<code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code> operation.</p>
<p>If the result of E is a location description with one register location
description (see <a class="reference internal" href="#amdgpu-dwarf-register-location-descriptions"><span class="std std-ref">Register Location Description Operations</span></a>),
<code class="docutils literal notranslate"><span class="pre">DW_OP_entry_value</span></code> pushes the value that register had upon entering the
current subprogram. The value entry type is the target architecture register
base type. If the register value is undefined or the register location
description bit offset is not 0, then the DWARF expression is ill-formed.</p>
<p><em>The register location description provides a more compact form for the case
where the value was in a register on entry to the subprogram.</em></p>
<p>If the result of E is a value V, <code class="docutils literal notranslate"><span class="pre">DW_OP_entry_value</span></code> pushes V on the
stack.</p>
<p>Otherwise, the DWARF expression is ill-formed.</p>
<p><em>The values needed to evaluate</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_entry_value</span></code> <em>could be obtained in
several ways. The consumer could suspend execution on entry to the
subprogram, record values needed by</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_entry_value</span></code> <em>expressions
within the subprogram, and then continue. When evaluating</em>
<code class="docutils literal notranslate"><span class="pre">DW_OP_entry_value</span></code><em>, the consumer would use these recorded values
rather than the current values. Or, when evaluating</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_entry_value</span></code><em>, the consumer could virtually unwind using the Call Frame Information
(see</em> <a class="reference internal" href="#amdgpu-dwarf-call-frame-information"><span class="std std-ref">Call Frame Information</span></a><em>) to recover register
values that might have been clobbered since the subprogram entry point.</em></p>
<p><em>The</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_entry_value</span></code> <em>operation is deprecated as its main usage is
provided by other means. DWARF Version 5 added the</em>
<code class="docutils literal notranslate"><span class="pre">DW_TAG_call_site_parameter</span></code> <em>debugger information entry for call sites
that has</em> <code class="docutils literal notranslate"><span class="pre">DW_AT_call_value</span></code><em>,</em> <code class="docutils literal notranslate"><span class="pre">DW_AT_call_data_location</span></code><em>, and</em>
<code class="docutils literal notranslate"><span class="pre">DW_AT_call_data_value</span></code> <em>attributes that provide DWARF expressions to
compute actual parameter values at the time of the call, and requires the
producer to ensure the expressions are valid to evaluate even when virtually
unwound. The</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_call_frame_entry_reg</span></code> <em>operation provides access
to registers in the virtually unwound calling frame.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is unclear why this operation is defined this way. How would a consumer
know what values have to be saved on entry to the subprogram? Does it have
to parse every expression of every <code class="docutils literal notranslate"><span class="pre">DW_OP_entry_value</span></code> operation to
capture all the possible results needed? Or does it have to implement
reverse execution so it can evaluate the expression in the context of the
entry of the subprogram so it can obtain the entry point register and
memory values? Or does the compiler somehow instruct the consumer how to
create the saved copies of the variables on entry?</p>
<p>If the expression is simply using existing variables, then it is just a
regular expression and no special operation is needed. If the main purpose
is only to read the entry value of a register using CFI then it would be
better to have an operation that explicitly does just that such as the
proposed <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_call_frame_entry_reg</span></code> operation.</p>
<p>GDB only seems to implement <code class="docutils literal notranslate"><span class="pre">DW_OP_entry_value</span></code> when E is exactly
<code class="docutils literal notranslate"><span class="pre">DW_OP_reg*</span></code> or <code class="docutils literal notranslate"><span class="pre">DW_OP_breg*;</span> <span class="pre">DW_OP_deref*</span></code>. It evaluates E in the
context of the calling subprogram and the calling call site program
location. But the wording suggests that is not the intention.</p>
<p>Given these issues it is suggested <code class="docutils literal notranslate"><span class="pre">DW_OP_entry_value</span></code> is deprecated in
favor of using the new facities that have well defined semantics and
implementations.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="section" id="location-description-operations">
<span id="amdgpu-dwarf-location-description-operations"></span><h6><a class="toc-backref" href="#id18">Location Description Operations</a><a class="headerlink" href="#location-description-operations" title="Permalink to this headline">¶</a></h6>
<p>This section describes the operations that push location descriptions on the
stack.</p>
<div class="section" id="general-location-description-operations">
<h7><a class="toc-backref" href="#id19">General Location Description Operations</a><a class="headerlink" href="#general-location-description-operations" title="Permalink to this headline">¶</a></h7>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset</span></code> pops two stack entries. The first must be an integral
type value that represents a byte displacement B. The second must be a
location description L.</p>
<p>It adds the value of B scaled by 8 (the byte size) to the bit offset of each
single location description SL of L, and pushes the updated L.</p>
<p>If the updated bit offset of any SL is less than 0 or greater than or equal
to the size of the location storage specified by SL, then the DWARF
expression is ill-formed.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset_uconst</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset_uconst</span></code> has a single unsigned LEB128 integer operand
that represents a byte displacement B.</p>
<p>The operation is equivalent to performing <code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span> <span class="pre">B;</span>
<span class="pre">DW_OP_LLVM_offset</span></code>.</p>
<p><em>This operation is supplied specifically to be able to encode more field
displacements in two bytes than can be done with</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_lit*;</span>
<span class="pre">DW_OP_LLVM_offset</span></code><em>.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Should this be named <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset_uconst</span></code> to match
<code class="docutils literal notranslate"><span class="pre">DW_OP_plus_uconst</span></code>, or <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset_constu</span></code> to match
<code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span></code>?</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_bit_offset</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_bit_offset</span></code> pops two stack entries. The first must be an
integral type value that represents a bit displacement B. The second must be
a location description L.</p>
<p>It adds the value of B to the bit offset of each single location description
SL of L, and pushes the updated L.</p>
<p>If the updated bit offset of any SL is less than 0 or greater than or equal
to the size of the location storage specified by SL, then the DWARF
expression is ill-formed.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code> pushes the location description L of the
object currently being evaluated as part of evaluation of a user presented
expression.</p>
<p>This object may correspond to an independent variable described by its own
debugging information entry or it may be a component of an array, structure,
or class whose address has been dynamically determined by an earlier step
during user expression evaluation.</p>
<p><em>This operation provides explicit functionality (especially for arrays
involving descriptions) that is analogous to the implicit push of the base
location description of a structure prior to evaluation of a
``DW_AT_data_member_location`` to access a data member of a structure.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_call_frame_entry_reg</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_call_frame_entry_reg</span></code> has a single unsigned LEB128 integer
operand that represents a target architecture register number R.</p>
<p>It pushes a location description L that holds the value of register R on
entry to the current subprogram as defined by the Call Frame Information
(see <a class="reference internal" href="#amdgpu-dwarf-call-frame-information"><span class="std std-ref">Call Frame Information</span></a>).</p>
<p><em>If there is no Call Frame Information defined, then the default rules for
the target architecture are used. If the register rule is</em> undefined<em>, then
the undefined location description is pushed. If the register rule is</em> same
value<em>, then a register location description for R is pushed.</em></p>
</li>
</ol>
</div>
<div class="section" id="undefined-location-description-operations">
<h7><a class="toc-backref" href="#id20">Undefined Location Description Operations</a><a class="headerlink" href="#undefined-location-description-operations" title="Permalink to this headline">¶</a></h7>
<p><em>The undefined location storage represents a piece or all of an object that is
present in the source but not in the object code (perhaps due to optimization).
Neither reading nor writing to the undefined location storage is meaningful.</em></p>
<p>An undefined location description specifies the undefined location storage.
There is no concept of the size of the undefined location storage, nor of a bit
offset for an undefined location description. The <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_*offset</span></code>
operations leave an undefined location description unchanged. The
<code class="docutils literal notranslate"><span class="pre">DW_OP_*piece</span></code> operations can explicitly or implicitly specify an undefined
location description, allowing any size and offset to be specified, and results
in a part with all undefined bits.</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_undefined</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_undefined</span></code> pushes a location description L that comprises one
undefined location description SL.</p>
</li>
</ol>
</div>
<div class="section" id="memory-location-description-operations">
<span id="amdgpu-dwarf-memory-location-description-operations"></span><h7><a class="toc-backref" href="#id21">Memory Location Description Operations</a><a class="headerlink" href="#memory-location-description-operations" title="Permalink to this headline">¶</a></h7>
<p>Each of the target architecture specific address spaces has a corresponding
memory location storage that denotes the linear addressable memory of that
address space. The size of each memory location storage corresponds to the range
of the addresses in the corresponding address space.</p>
<p><em>It is target architecture defined how address space location storage maps to
target architecture physical memory. For example, they may be independent
memory, or more than one location storage may alias the same physical memory
possibly at different offsets and with different interleaving. The mapping may
also be dictated by the source language address classes.</em></p>
<p>A memory location description specifies a memory location storage. The bit
offset corresponds to a bit position within a byte of the memory. Bits accessed
using a memory location description, access the corresponding target
architecture memory starting at the bit position within the byte specified by
the bit offset.</p>
<p>A memory location description that has a bit offset that is a multiple of 8 (the
byte size) is defined to be a byte address memory location description. It has a
memory byte address A that is equal to the bit offset divided by 8.</p>
<p>A memory location description that does not have a bit offset that is a multiple
of 8 (the byte size) is defined to be a bit field memory location description.
It has a bit position B equal to the bit offset modulo 8, and a memory byte
address A equal to the bit offset minus B that is then divided by 8.</p>
<p>The address space AS of a memory location description is defined to be the
address space that corresponds to the memory location storage associated with
the memory location description.</p>
<p>A location description that is comprised of one byte address memory location
description SL is defined to be a memory byte address location description. It
has a byte address equal to A and an address space equal to AS of the
corresponding SL.</p>
<p><code class="docutils literal notranslate"><span class="pre">DW_ASPACE_none</span></code> is defined as the target architecture default address space.</p>
<p>If a stack entry is required to be a location description, but it is a value V
with the generic type, then it is implicitly converted to a location description
L with one memory location description SL. SL specifies the memory location
storage that corresponds to the target architecture default address space with a
bit offset equal to V scaled by 8 (the byte size).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If it is wanted to allow any integral type value to be implicitly converted to
a memory location description in the target architecture default address
space:</p>
<blockquote>
<div><p>If a stack entry is required to be a location description, but is a value V
with an integral type, then it is implicitly converted to a location
description L with a one memory location description SL. If the type size of
V is less than the generic type size, then the value V is zero extended to
the size of the generic type. The least significant generic type size bits
are treated as a twos-complement unsigned value to be used as an address A.
SL specifies memory location storage corresponding to the target
architecture default address space with a bit offset equal to A scaled by 8
(the byte size).</p>
</div></blockquote>
<p>The implicit conversion could also be defined as target architecture specific.
For example, GDB checks if V is an integral type. If it is not it gives an
error. Otherwise, GDB zero-extends V to 64 bits. If the GDB target defines a
hook function, then it is called. The target specific hook function can modify
the 64-bit value, possibly sign extending based on the original value type.
Finally, GDB treats the 64-bit value V as a memory location address.</p>
</div>
<p>If a stack entry is required to be a location description, but it is an implicit
pointer value IPV with the target architecture default address space, then it is
implicitly converted to a location description with one single location
description specified by IPV. See
<a class="reference internal" href="#amdgpu-dwarf-implicit-location-descriptions"><span class="std std-ref">Implicit Location Description Operations</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Is this rule required for DWARF Version 5 backwards compatibility? If not, it
can be eliminated, and the producer can use
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code>.</p>
</div>
<p>If a stack entry is required to be a value, but it is a location description L
with one memory location description SL in the target architecture default
address space with a bit offset B that is a multiple of 8, then it is implicitly
converted to a value equal to B divided by 8 (the byte size) with the generic
type.</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_addr</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_addr</span></code> has a single byte constant value operand, which has the size
of the generic type, that represents an address A.</p>
<p>It pushes a location description L with one memory location description SL
on the stack. SL specifies the memory location storage corresponding to the
target architecture default address space with a bit offset equal to A
scaled by 8 (the byte size).</p>
<p><em>If the DWARF is part of a code object, then A may need to be relocated. For
example, in the ELF code object format, A must be adjusted by the difference
between the ELF segment virtual address and the virtual address at which the
segment is loaded.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_addrx</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_addrx</span></code> has a single unsigned LEB128 integer operand that represents
a zero-based index into the <code class="docutils literal notranslate"><span class="pre">.debug_addr</span></code> section relative to the value of
the <code class="docutils literal notranslate"><span class="pre">DW_AT_addr_base</span></code> attribute of the associated compilation unit. The
address value A in the <code class="docutils literal notranslate"><span class="pre">.debug_addr</span></code> section has the size of the generic
type.</p>
<p>It pushes a location description L with one memory location description SL
on the stack. SL specifies the memory location storage corresponding to the
target architecture default address space with a bit offset equal to A
scaled by 8 (the byte size).</p>
<p><em>If the DWARF is part of a code object, then A may need to be relocated. For
example, in the ELF code object format, A must be adjusted by the difference
between the ELF segment virtual address and the virtual address at which the
segment is loaded.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code> pops top two stack entries. The first
must be an integral type value that represents a target architecture
specific address space identifier AS. The second must be an integral type
value that represents an address A.</p>
<p>The address size S is defined as the address bit size of the target
architecture specific address space that corresponds to AS.</p>
<p>A is adjusted to S bits by zero extending if necessary, and then treating the
least significant S bits as a twos-complement unsigned value A’.</p>
<p>It pushes a location description L with one memory location description SL
on the stack. SL specifies the memory location storage that corresponds to
AS with a bit offset equal to A’ scaled by 8 (the byte size).</p>
<p>The DWARF expression is ill-formed if AS is not one of the values defined by
the target architecture specific <code class="docutils literal notranslate"><span class="pre">DW_ASPACE_*</span></code> values.</p>
<p>See <a class="reference internal" href="#amdgpu-dwarf-implicit-location-descriptions"><span class="std std-ref">Implicit Location Description Operations</span></a> for special rules
concerning implicit pointer values produced by dereferencing implicit
location descriptions created by the <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> and
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_implicit_aspace_pointer</span></code> operations.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_form_tls_address</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_form_tls_address</span></code> pops one stack entry that must be an integral
type value and treats it as a thread-local storage address T.</p>
<p>It pushes a location description L with one memory location description SL
on the stack. SL is the target architecture specific memory location
description that corresponds to the thread-local storage address T.</p>
<p>The meaning of the thread-local storage address T is defined by the run-time
environment. If the run-time environment supports multiple thread-local
storage blocks for a single thread, then the block corresponding to the
executable or shared library containing this DWARF expression is used.</p>
<p><em>Some implementations of C, C++, Fortran, and other languages support a
thread-local storage class. Variables with this storage class have distinct
values and addresses in distinct threads, much as automatic variables have
distinct values and addresses in each subprogram invocation. Typically,
there is a single block of storage containing all thread-local variables
declared in the main executable, and a separate block for the variables
declared in each shared library. Each thread-local variable can then be
accessed in its block using an identifier. This identifier is typically a
byte offset into the block and pushed onto the DWARF stack by one of the</em>
<code class="docutils literal notranslate"><span class="pre">DW_OP_const*</span></code> <em>operations prior to the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_form_tls_address</span></code>
<em>operation. Computing the address of the appropriate block can be complex
(in some cases, the compiler emits a function call to do it), and difficult
to describe using ordinary DWARF location descriptions. Instead of forcing
complex thread-local storage calculations into the DWARF expressions, the</em>
<code class="docutils literal notranslate"><span class="pre">DW_OP_form_tls_address</span></code> <em>allows the consumer to perform the computation
based on the target architecture specific run-time environment.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_call_frame_cfa</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_call_frame_cfa</span></code> pushes the location description L of the Canonical
Frame Address (CFA) of the current subprogram, obtained from the Call Frame
Information on the stack. See <a class="reference internal" href="#amdgpu-dwarf-call-frame-information"><span class="std std-ref">Call Frame Information</span></a>.</p>
<p><em>Although the value of the</em> <code class="docutils literal notranslate"><span class="pre">DW_AT_frame_base</span></code> <em>attribute of the debugger
information entry corresponding to the current subprogram can be computed
using a location list expression, in some cases this would require an
extensive location list because the values of the registers used in
computing the CFA change during a subprogram execution. If the Call Frame
Information is present, then it already encodes such changes, and it is
space efficient to reference that using the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_call_frame_cfa</span></code>
<em>operation.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_fbreg</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_fbreg</span></code> has a single signed LEB128 integer operand that represents a
byte displacement B.</p>
<p>The location description L for the <em>frame base</em> of the current subprogram is
obtained from the <code class="docutils literal notranslate"><span class="pre">DW_AT_frame_base</span></code> attribute of the debugger information
entry corresponding to the current subprogram as described in
<a class="reference internal" href="#amdgpu-dwarf-debugging-information-entry-attributes"><span class="std std-ref">Debugging Information Entry Attributes</span></a>.</p>
<p>The location description L is updated as if the <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset_uconst</span>
<span class="pre">B</span></code> operation was applied. The updated L is pushed on the stack.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_breg0</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_breg1</span></code>, …, <code class="docutils literal notranslate"><span class="pre">DW_OP_breg31</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_OP_breg&lt;N&gt;</span></code> operations encode the numbers of up to 32 registers,
numbered from 0 through 31, inclusive. The register number R corresponds to
the N in the operation name.</p>
<p>They have a single signed LEB128 integer operand that represents a byte
displacement B.</p>
<p>The address space identifier AS is defined as the one corresponding to the
target architecture specific default address space.</p>
<p>The address size S is defined as the address bit size of the target
architecture specific address space corresponding to AS.</p>
<p>The contents of the register specified by R are retrieved as a
twos-complement unsigned value and zero extended to S bits. B is added and
the least significant S bits are treated as a twos-complement unsigned value
to be used as an address A.</p>
<p>They push a location description L comprising one memory location
description LS on the stack. LS specifies the memory location storage that
corresponds to AS with a bit offset equal to A scaled by 8 (the byte size).</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_bregx</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_bregx</span></code> has two operands. The first is an unsigned LEB128 integer
that represents a register number R. The second is a signed LEB128
integer that represents a byte displacement B.</p>
<p>The action is the same as for <code class="docutils literal notranslate"><span class="pre">DW_OP_breg&lt;N&gt;</span></code> except that R is used as the
register number and B is used as the byte displacement.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_bregx</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_bregx</span></code> has two operands. The first is an unsigned
LEB128 integer that represents a register number R. The second is a signed
LEB128 integer that represents a byte displacement B. It pops one stack
entry that is required to be an integral type value that represents a target
architecture specific address space identifier AS.</p>
<p>The action is the same as for <code class="docutils literal notranslate"><span class="pre">DW_OP_breg&lt;N&gt;</span></code> except that R is used as the
register number, B is used as the byte displacement, and AS is used as the
address space identifier.</p>
<p>The DWARF expression is ill-formed if AS is not one of the values defined by
the target architecture specific <code class="docutils literal notranslate"><span class="pre">DW_ASPACE_*</span></code> values.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Could also consider adding <code class="docutils literal notranslate"><span class="pre">DW_OP_aspace_breg0,</span> <span class="pre">DW_OP_aspace_breg1,</span> <span class="pre">...,</span>
<span class="pre">DW_OP_aspace_bref31</span></code> which would save encoding size.</p>
</div>
</li>
</ol>
</div>
<div class="section" id="register-location-description-operations">
<span id="amdgpu-dwarf-register-location-descriptions"></span><h7><a class="toc-backref" href="#id22">Register Location Description Operations</a><a class="headerlink" href="#register-location-description-operations" title="Permalink to this headline">¶</a></h7>
<p>There is a register location storage that corresponds to each of the target
architecture registers. The size of each register location storage corresponds
to the size of the corresponding target architecture register.</p>
<p>A register location description specifies a register location storage. The bit
offset corresponds to a bit position within the register. Bits accessed using a
register location description access the corresponding target architecture
register starting at the specified bit offset.</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_reg0</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_reg1</span></code>, …, <code class="docutils literal notranslate"><span class="pre">DW_OP_reg31</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_reg&lt;N&gt;</span></code> operations encode the numbers of up to 32 registers,
numbered from 0 through 31, inclusive. The target architecture register
number R corresponds to the N in the operation name.</p>
<p>They push a location description L that specifies one register location
description SL on the stack. SL specifies the register location storage that
corresponds to R with a bit offset of 0.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_regx</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_regx</span></code> has a single unsigned LEB128 integer operand that represents
a target architecture register number R.</p>
<p>It pushes a location description L that specifies one register location
description SL on the stack. SL specifies the register location storage that
corresponds to R with a bit offset of 0.</p>
</li>
</ol>
<p><em>These operations obtain a register location. To fetch the contents of a
register, it is necessary to use</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_regval_type</span></code><em>, use one of the</em>
<code class="docutils literal notranslate"><span class="pre">DW_OP_breg*</span></code> <em>register-based addressing operations, or use</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_deref*</span></code>
<em>on a register location description.</em></p>
</div>
<div class="section" id="implicit-location-description-operations">
<span id="amdgpu-dwarf-implicit-location-descriptions"></span><h7><a class="toc-backref" href="#id23">Implicit Location Description Operations</a><a class="headerlink" href="#implicit-location-description-operations" title="Permalink to this headline">¶</a></h7>
<p>Implicit location storage represents a piece or all of an object which has no
actual location in the program but whose contents are nonetheless known, either
as a constant or can be computed from other locations and values in the program.</p>
<p>An implicit location description specifies an implicit location storage. The bit
offset corresponds to a bit position within the implicit location storage. Bits
accessed using an implicit location description, access the corresponding
implicit storage value starting at the bit offset.</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_value</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_value</span></code> has two operands. The first is an unsigned LEB128
integer that represents a byte size S. The second is a block of bytes with a
length equal to S treated as a literal value V.</p>
<p>An implicit location storage LS is created with the literal value V and a
size of S.</p>
<p>It pushes location description L with one implicit location description SL
on the stack. SL specifies LS with a bit offset of 0.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_stack_value</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_stack_value</span></code> pops one stack entry that must be a value V.</p>
<p>An implicit location storage LS is created with the literal value V and a
size equal to V’s base type size.</p>
<p>It pushes a location description L with one implicit location description SL
on the stack. SL specifies LS with a bit offset of 0.</p>
<p><em>The</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_stack_value</span></code> <em>operation specifies that the object does not
exist in memory, but its value is nonetheless known. In this form, the
location description specifies the actual value of the object, rather than
specifying the memory or register storage that holds the value.</em></p>
<p>See <a class="reference internal" href="#amdgpu-dwarf-implicit-location-descriptions"><span class="std std-ref">Implicit Location Description Operations</span></a> for special rules
concerning implicit pointer values produced by dereferencing implicit
location descriptions created by the <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> and
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_implicit_aspace_pointer</span></code> operations.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since location descriptions are allowed on the stack, the
<code class="docutils literal notranslate"><span class="pre">DW_OP_stack_value</span></code> operation no longer terminates the DWARF operation
expression execution as in DWARF Version 5.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code></p>
<p><em>An optimizing compiler may eliminate a pointer, while still retaining the
value that the pointer addressed.</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> <em>allows a
producer to describe this value.</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> <em>specifies an object is a pointer to the target
architecture default address space that cannot be represented as a real
pointer, even though the value it would point to can be described. In this
form, the location description specifies a debugging information entry that
represents the actual location description of the object to which the
pointer would point. Thus, a consumer of the debug information would be able
to access the dereferenced pointer, even when it cannot access the pointer
itself.</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> has two operands. The first is a 4-byte unsigned
value in the 32-bit DWARF format, or an 8-byte unsigned value in the 64-bit
DWARF format, that represents a debugging information entry reference R. The
second is a signed LEB128 integer that represents a byte displacement B.</p>
<p>R is used as the offset of a debugging information entry D in a
<code class="docutils literal notranslate"><span class="pre">.debug_info</span></code> section, which may be contained in an executable or shared
object file other than that containing the operation. For references from one
executable or shared object file to another, the relocation must be
performed by the consumer.</p>
<p><em>The first operand interpretation is exactly like that for</em>
<code class="docutils literal notranslate"><span class="pre">DW_FORM_ref_addr</span></code><em>.</em></p>
<p>The address space identifier AS is defined as the one corresponding to the
target architecture specific default address space.</p>
<p>The address size S is defined as the address bit size of the target
architecture specific address space corresponding to AS.</p>
<p>An implicit location storage LS is created with the debugging information
entry D, address space AS, and size of S.</p>
<p>It pushes a location description L that comprises one implicit location
description SL on the stack. SL specifies LS with a bit offset of 0.</p>
<p>If a <code class="docutils literal notranslate"><span class="pre">DW_OP_deref*</span></code> operation pops a location description L’, and
retrieves S bits where both:</p>
<ol class="arabic">
<li><p>All retrieved bits come from an implicit location description that
refers to an implicit location storage that is the same as LS.</p>
<p><em>Note that all bits do not have to come from the same implicit location
description, as L’ may involve composite location descriptors.</em></p>
</li>
<li><p>The bits come from consecutive ascending offsets within their respective
implicit location storage.</p></li>
</ol>
<p><em>These rules are equivalent to retrieving the complete contents of LS.</em></p>
<p>Then the value V pushed by the <code class="docutils literal notranslate"><span class="pre">DW_OP_deref*</span></code> operation is an implicit
pointer value IPV with a target architecture specific address space of AS, a
debugging information entry of D, and a base type of T. If AS is the target
architecture default address space, then T is the generic type. Otherwise, T
is a target architecture specific integral type with a bit size equal to S.</p>
<p>Otherwise, if a <code class="docutils literal notranslate"><span class="pre">DW_OP_deref*</span></code> operation is applied to a location
description such that some retrieved bits come from an implicit location
storage that is the same as LS, then the DWARF expression is ill-formed.</p>
<p>If IPV is either implicitly converted to a location description (only done
if AS is the target architecture default address space) or used by
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code> (only done if the address space specified
is AS), then the resulting location description RL is:</p>
<ul>
<li><p>If D has a <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> attribute, the DWARF expression E from the
<code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> attribute is evaluated as a location description. The
current subprogram and current program location of the evaluation context
that is accessing IPV is used for the evaluation context of E, together
with an empty initial stack. RL is the expression result.</p></li>
<li><p>If D has a <code class="docutils literal notranslate"><span class="pre">DW_AT_const_value</span></code> attribute, then an implicit location
storage RLS is created from the <code class="docutils literal notranslate"><span class="pre">DW_AT_const_value</span></code> attribute’s value
with a size matching the size of the <code class="docutils literal notranslate"><span class="pre">DW_AT_const_value</span></code> attribute’s
value. RL comprises one implicit location description SRL. SRL specifies
RLS with a bit offset of 0.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If using <code class="docutils literal notranslate"><span class="pre">DW_AT_const_value</span></code> for variables and formal parameters is
deprecated and instead <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> is used with an implicit
location description, then this rule would not be required.</p>
</div>
</li>
<li><p>Otherwise the DWARF expression is ill-formed.</p></li>
</ul>
<p>The bit offset of RL is updated as if the <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset_uconst</span> <span class="pre">B</span></code>
operation was applied.</p>
<p>If a <code class="docutils literal notranslate"><span class="pre">DW_OP_stack_value</span></code> operation pops a value that is the same as IPV,
then it pushes a location description that is the same as L.</p>
<p>The DWARF expression is ill-formed if it accesses LS or IPV in any other
manner.</p>
<p><em>The restrictions on how an implicit pointer location description created
by</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> <em>and</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code>
<em>can be used are to simplify the DWARF consumer. Similarly, for an implicit
pointer value created by</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_deref*</span></code> <em>and</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_stack_value</span></code>.*</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code> has two operands that are the same as
for <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code>.</p>
<p>It pops one stack entry that must be an integral type value that represents
a target architecture specific address space identifier AS.</p>
<p>The location description L that is pushed on the stack is the same as for
<code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> except that the address space identifier used is
AS.</p>
<p>The DWARF expression is ill-formed if AS is not one of the values defined by
the target architecture specific <code class="docutils literal notranslate"><span class="pre">DW_ASPACE_*</span></code> values.</p>
</li>
</ol>
<p><em>Typically a</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> <em>or</em>
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code> <em>operation is used in a DWARF expression
E</em><sub>1</sub> <em>of a</em> <code class="docutils literal notranslate"><span class="pre">DW_TAG_variable</span></code> <em>or</em> <code class="docutils literal notranslate"><span class="pre">DW_TAG_formal_parameter</span></code>
<em>debugging information entry D</em><sub>1</sub><em>’s</em> <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> <em>attribute.
The debugging information entry referenced by the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code>
<em>or</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code> <em>operations is typically itself a</em>
<code class="docutils literal notranslate"><span class="pre">DW_TAG_variable</span></code> <em>or</em> <code class="docutils literal notranslate"><span class="pre">DW_TAG_formal_parameter</span></code> <em>debugging information
entry D</em><sub>2</sub> <em>whose</em> <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> <em>attribute gives a second DWARF
expression E</em><sub>2</sub><em>.</em></p>
<p><em>D</em><sub>1</sub> <em>and E</em><sub>1</sub> <em>are describing the location of a pointer type
object. D</em><sub>2</sub> <em>and E</em><sub>2</sub> <em>are describing the location of the
object pointed to by that pointer object.</em></p>
<p><em>However, D</em><sub>2</sub> <em>may be any debugging information entry that contains a</em>
<code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> <em>or</em> <code class="docutils literal notranslate"><span class="pre">DW_AT_const_value</span></code> <em>attribute (for example,</em>
<code class="docutils literal notranslate"><span class="pre">DW_TAG_dwarf_procedure</span></code><em>). By using E</em><sub>2</sub><em>, a consumer can
reconstruct the value of the object when asked to dereference the pointer
described by E</em><sub>1</sub> <em>which contains the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> or
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_implicit_pointer</span></code> <em>operation.</em></p>
</div>
<div class="section" id="composite-location-description-operations">
<span id="amdgpu-dwarf-composite-location-description-operations"></span><h7><a class="toc-backref" href="#id24">Composite Location Description Operations</a><a class="headerlink" href="#composite-location-description-operations" title="Permalink to this headline">¶</a></h7>
<p>A composite location storage represents an object or value which may be
contained in part of another location storage or contained in parts of more
than one location storage.</p>
<p>Each part has a part location description L and a part bit size S. L can have
one or more single location descriptions SL. If there are more than one SL then
that indicates that part is located in more than one place. The bits of each
place of the part comprise S contiguous bits from the location storage LS
specified by SL starting at the bit offset specified by SL. All the bits must
be within the size of LS or the DWARF expression is ill-formed.</p>
<p>A composite location storage can have zero or more parts. The parts are
contiguous such that the zero-based location storage bit index will range over
each part with no gaps between them. Therefore, the size of a composite location
storage is the sum of the size of its parts. The DWARF expression is ill-formed
if the size of the contiguous location storage is larger than the size of the
memory location storage corresponding to the largest target architecture
specific address space.</p>
<p>A composite location description specifies a composite location storage. The bit
offset corresponds to a bit position within the composite location storage.</p>
<p>There are operations that create a composite location storage.</p>
<p>There are other operations that allow a composite location storage to be
incrementally created. Each part is created by a separate operation. There may
be one or more operations to create the final composite location storage. A
series of such operations describes the parts of the composite location storage
that are in the order that the associated part operations are executed.</p>
<p>To support incremental creation, a composite location storage can be in an
incomplete state. When an incremental operation operates on an incomplete
composite location storage, it adds a new part, otherwise it creates a new
composite location storage. The <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_piece_end</span></code> operation explicitly
makes an incomplete composite location storage complete.</p>
<p>A composite location description that specifies a composite location storage
that is incomplete is termed an incomplete composite location description. A
composite location description that specifies a composite location storage that
is complete is termed a complete composite location description.</p>
<p>If the top stack entry is a location description that has one incomplete
composite location description SL after the execution of an operation expression
has completed, SL is converted to a complete composite location description.</p>
<p><em>Note that this conversion does not happen after the completion of an operation
expression that is evaluated on the same stack by the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code>
<em>operations. Such executions are not a separate evaluation of an operation
expression, but rather the continued evaluation of the same operation expression
that contains the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> <em>operation.</em></p>
<p>If a stack entry is required to be a location description L, but L has an
incomplete composite location description, then the DWARF expression is
ill-formed. The exception is for the operations involved in incrementally
creating a composite location description as described below.</p>
<p><em>Note that a DWARF operation expression may arbitrarily compose composite
location descriptions from any other location description, including those that
have multiple single location descriptions, and those that have composite
location descriptions.</em></p>
<p><em>The incremental composite location description operations are defined to be
compatible with the definitions in DWARF Version 5.</em></p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_piece</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_piece</span></code> has a single unsigned LEB128 integer that represents a byte
size S.</p>
<p>The action is based on the context:</p>
<ul>
<li><p>If the stack is empty, then a location description L comprised of one
incomplete composite location description SL is pushed on the stack.</p>
<p>An incomplete composite location storage LS is created with a single part
P. P specifies a location description PL and has a bit size of S scaled by
8 (the byte size). PL is comprised of one undefined location description
PSL.</p>
<p>SL specifies LS with a bit offset of 0.</p>
</li>
<li><p>Otherwise, if the top stack entry is a location description L comprised of
one incomplete composite location description SL, then the incomplete
composite location storage LS that SL specifies is updated to append a new
part P. P specifies a location description PL and has a bit size of S
scaled by 8 (the byte size). PL is comprised of one undefined location
description PSL. L is left on the stack.</p></li>
<li><p>Otherwise, if the top stack entry is a location description or can be
converted to one, then it is popped and treated as a part location
description PL. Then:</p>
<ul>
<li><p>If the top stack entry (after popping PL) is a location description L
comprised of one incomplete composite location description SL, then the
incomplete composite location storage LS that SL specifies is updated to
append a new part P. P specifies the location description PL and has a
bit size of S scaled by 8 (the byte size). L is left on the stack.</p></li>
<li><p>Otherwise, a location description L comprised of one incomplete
composite location description SL is pushed on the stack.</p>
<p>An incomplete composite location storage LS is created with a single
part P. P specifies the location description PL and has a bit size of S
scaled by 8 (the byte size).</p>
<p>SL specifies LS with a bit offset of 0.</p>
</li>
</ul>
</li>
<li><p>Otherwise, the DWARF expression is ill-formed</p></li>
</ul>
<p><em>Many compilers store a single variable in sets of registers or store a
variable partially in memory and partially in registers.</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_piece</span></code>
<em>provides a way of describing where a part of a variable is located.</em></p>
<p><em>If a non-0 byte displacement is required, the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset</span></code>
<em>operation can be used to update the location description before using it as
the part location description of a</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_piece</span></code> <em>operation.</em></p>
<p><em>The evaluation rules for the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_piece</span></code> <em>operation allow it to be
compatible with the DWARF Version 5 definition.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since this proposal allows location descriptions to be entries on the
stack, a simpler operation to create composite location descriptions. For
example, just one operation that specifies how many parts, and pops pairs
of stack entries for the part size and location description. Not only
would this be a simpler operation and avoid the complexities of incomplete
composite location descriptions, but it may also have a smaller encoding
in practice. However, the desire for compatibility with DWARF Version 5 is
likely a stronger consideration.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_bit_piece</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_bit_piece</span></code> has two operands. The first is an unsigned LEB128
integer that represents the part bit size S. The second is an unsigned
LEB128 integer that represents a bit displacement B.</p>
<p>The action is the same as for <code class="docutils literal notranslate"><span class="pre">DW_OP_piece</span></code> except that any part created
has the bit size S, and the location description PL of any created part is
updated as if the <code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span> <span class="pre">B;</span> <span class="pre">DW_OP_LLVM_bit_offset</span></code> operations were
applied.</p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_bit_piece</span></code> <em>is used instead of</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_piece</span></code> <em>when the piece to
be assembled is not byte-sized or is not at the start of the part location
description.</em></p>
<p><em>If a computed bit displacement is required, the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_bit_offset</span></code>
<em>operation can be used to update the location description before using it as
the part location description of a</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_bit_piece</span></code> <em>operation.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The bit offset operand is not needed as <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_bit_offset</span></code> can be
used on the part’s location description.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_piece_end</span></code> <em>New</em></p>
<p>If the top stack entry is not a location description L comprised of one
incomplete composite location description SL, then the DWARF expression is
ill-formed.</p>
<p>Otherwise, the incomplete composite location storage LS specified by SL is
updated to be a complete composite location description with the same parts.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_extend</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_extend</span></code> has two operands. The first is an unsigned LEB128
integer that represents the element bit size S. The second is an unsigned
LEB128 integer that represents a count C.</p>
<p>It pops one stack entry that must be a location description and is treated
as the part location description PL.</p>
<p>A location description L comprised of one complete composite location
description SL is pushed on the stack.</p>
<p>A complete composite location storage LS is created with C identical parts
P. Each P specifies PL and has a bit size of S.</p>
<p>SL specifies LS with a bit offset of 0.</p>
<p>The DWARF expression is ill-formed if the element bit size or count are 0.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_select_bit_piece</span></code> <em>New</em></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_select_bit_piece</span></code> has two operands. The first is an unsigned
LEB128 integer that represents the element bit size S. The second is an
unsigned LEB128 integer that represents a count C.</p>
<p>It pops three stack entries. The first must be an integral type value that
represents a bit mask value M. The second must be a location description
that represents the one-location description L1. The third must be a
location description that represents the zero-location description L0.</p>
<p>A complete composite location storage LS is created with C parts P<sub>N</sub>
ordered in ascending N from 0 to C-1 inclusive. Each P<sub>N</sub> specifies
location description PL<sub>N</sub> and has a bit size of S.</p>
<p>PL<sub>N</sub> is as if the <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_bit_offset</span> <span class="pre">N*S</span></code> operation was
applied to PLX<sub>N</sub>.</p>
<p>PLX<sub>N</sub> is the same as L0 if the N<sup>th</sup> least significant bit of
M is a zero, otherwise it is the same as L1.</p>
<p>A location description L comprised of one complete composite location
description SL is pushed on the stack. SL specifies LS with a bit offset of
0.</p>
<p>The DWARF expression is ill-formed if S or C are 0, or if the bit size of M
is less than C.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="section" id="dwarf-location-list-expressions">
<span id="amdgpu-dwarf-location-list-expressions"></span><h5><a class="toc-backref" href="#id25">DWARF Location List Expressions</a><a class="headerlink" href="#dwarf-location-list-expressions" title="Permalink to this headline">¶</a></h5>
<p><em>To meet the needs of recent computer architectures and optimization techniques,
debugging information must be able to describe the location of an object whose
location changes over the object’s lifetime, and may reside at multiple
locations during parts of an object’s lifetime. Location list expressions are
used in place of operation expressions whenever the object whose location is
being described has these requirements.</em></p>
<p>A location list expression consists of a series of location list entries. Each
location list entry is one of the following kinds:</p>
<p><em>Bounded location description</em></p>
<blockquote>
<div><p>This kind of location list entry provides an operation expression that
evaluates to the location description of an object that is valid over a
lifetime bounded by a starting and ending address. The starting address is the
lowest address of the address range over which the location is valid. The
ending address is the address of the first location past the highest address
of the address range.</p>
<p>The location list entry matches when the current program location is within
the given range.</p>
<p>There are several kinds of bounded location description entries which differ
in the way that they specify the starting and ending addresses.</p>
</div></blockquote>
<p><em>Default location description</em></p>
<blockquote>
<div><p>This kind of location list entry provides an operation expression that
evaluates to the location description of an object that is valid when no
bounded location description entry applies.</p>
<p>The location list entry matches when the current program location is not
within the range of any bounded location description entry.</p>
</div></blockquote>
<p><em>Base address</em></p>
<blockquote>
<div><p>This kind of location list entry provides an address to be used as the base
address for beginning and ending address offsets given in certain kinds of
bounded location description entries. The applicable base address of a bounded
location description entry is the address specified by the closest preceding
base address entry in the same location list. If there is no preceding base
address entry, then the applicable base address defaults to the base address
of the compilation unit (see DWARF Version 5 section 3.1.1).</p>
<p>In the case of a compilation unit where all of the machine code is contained
in a single contiguous section, no base address entry is needed.</p>
</div></blockquote>
<p><em>End-of-list</em></p>
<blockquote>
<div><p>This kind of location list entry marks the end of the location list
expression.</p>
</div></blockquote>
<p>The address ranges defined by the bounded location description entries of a
location list expression may overlap. When they do, they describe a situation in
which an object exists simultaneously in more than one place.</p>
<p>If all of the address ranges in a given location list expression do not
collectively cover the entire range over which the object in question is
defined, and there is no following default location description entry, it is
assumed that the object is not available for the portion of the range that is
not covered.</p>
<p>The operation expression of each matching location list entry is evaluated as a
location description and its result is returned as the result of the location
list entry. The operation expression is evaluated with the same context as the
location list expression, including the same current frame, current program
location, and initial stack.</p>
<p>The result of the evaluation of a DWARF location list expression is a location
description that is comprised of the union of the single location descriptions
of the location description result of each matching location list entry. If
there are no matching location list entries, then the result is a location
description that comprises one undefined location description.</p>
<p>A location list expression can only be used as the value of a debugger
information entry attribute that is encoded using class <code class="docutils literal notranslate"><span class="pre">loclist</span></code> or
<code class="docutils literal notranslate"><span class="pre">loclistsptr</span></code> (see DWARF Version 5 section 7.5.5). The value of the attribute
provides an index into a separate object file section called <code class="docutils literal notranslate"><span class="pre">.debug_loclists</span></code>
or <code class="docutils literal notranslate"><span class="pre">.debug_loclists.dwo</span></code> (for split DWARF object files) that contains the
location list entries.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code> operation can be used to
specify a debugger information entry attribute that has a location list
expression. Several debugger information entry attributes allow DWARF
expressions that are evaluated with an initial stack that includes a location
description that may originate from the evaluation of a location list
expression.</p>
<p><em>This location list representation, the</em> <code class="docutils literal notranslate"><span class="pre">loclist</span></code> <em>and</em> <code class="docutils literal notranslate"><span class="pre">loclistsptr</span></code>
<em>class, and the related</em> <code class="docutils literal notranslate"><span class="pre">DW_AT_loclists_base</span></code> <em>attribute are new in DWARF
Version 5. Together they eliminate most, or all of the code object relocations
previously needed for location list expressions.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The rest of this section is the same as DWARF Version 5 section 2.6.2.</p>
</div>
</div>
</div>
<div class="section" id="segmented-addresses">
<span id="amdgpu-dwarf-segment-addresses"></span><h4><a class="toc-backref" href="#id26">Segmented Addresses</a><a class="headerlink" href="#segmented-addresses" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This augments DWARF Version 5 section 2.12.</p>
</div>
<p>DWARF address classes are used for source languages that have the concept of
memory spaces. They are used in the <code class="docutils literal notranslate"><span class="pre">DW_AT_address_class</span></code> attribute for
pointer type, reference type, subprogram, and subprogram type debugger
information entries.</p>
<p>Each DWARF address class is conceptually a separate source language memory space
with its own lifetime and aliasing rules. DWARF address classes are used to
specify the source language memory spaces that pointer type and reference type
values refer, and to specify the source language memory space in which variables
are allocated.</p>
<p>The set of currently defined source language DWARF address classes, together
with source language mappings, is given in
<a class="reference internal" href="#amdgpu-dwarf-address-class-table"><span class="std std-ref">Address class</span></a>.</p>
<p>Vendor defined source language address classes may be defined using codes in the
range <code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_lo_user</span></code> to <code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_hi_user</span></code>.</p>
<table class="docutils align-default" id="amdgpu-dwarf-address-class-table">
<caption><span class="caption-text">Address class</span><a class="headerlink" href="#amdgpu-dwarf-address-class-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 39%" />
<col style="width: 19%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Address Class Name</p></th>
<th class="head"><p>Meaning</p></th>
<th class="head"><p>C/C++</p></th>
<th class="head"><p>OpenCL</p></th>
<th class="head"><p>CUDA/HIP</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_none</span></code></p></td>
<td><p>generic</p></td>
<td><p><em>default</em></p></td>
<td><p>generic</p></td>
<td><p><em>default</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_global</span></code></p></td>
<td><p>global</p></td>
<td></td>
<td><p>global</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_constant</span></code></p></td>
<td><p>constant</p></td>
<td></td>
<td><p>constant</p></td>
<td><p>constant</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_group</span></code></p></td>
<td><p>thread-group</p></td>
<td></td>
<td><p>local</p></td>
<td><p>shared</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_private</span></code></p></td>
<td><p>thread</p></td>
<td></td>
<td><p>private</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_lo_user</span></code></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_hi_user</span></code></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>DWARF address spaces correspond to target architecture specific linear
addressable memory areas. They are used in DWARF expression location
descriptions to describe in which target architecture specific memory area data
resides.</p>
<p><em>Target architecture specific DWARF address spaces may correspond to hardware
supported facilities such as memory utilizing base address registers, scratchpad
memory, and memory with special interleaving. The size of addresses in these
address spaces may vary. Their access and allocation may be hardware managed
with each thread or group of threads having access to independent storage. For
these reasons they may have properties that do not allow them to be viewed as
part of the unified global virtual address space accessible by all threads.</em></p>
<p><em>It is target architecture specific whether multiple DWARF address spaces are
supported and how source language DWARF address classes map to target
architecture specific DWARF address spaces. A target architecture may map
multiple source language DWARF address classes to the same target architecture
specific DWARF address class. Optimization may determine that variable lifetime
and access pattern allows them to be allocated in faster scratchpad memory
represented by a different DWARF address space.</em></p>
<p>Although DWARF address space identifiers are target architecture specific,
<code class="docutils literal notranslate"><span class="pre">DW_ASPACE_none</span></code> is a common address space supported by all target
architectures.</p>
<p>DWARF address space identifiers are used by:</p>
<ul class="simple">
<li><p>The DWARF expession operations: <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_bregx</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_implicit_aspace_pointer</span></code>,
and <code class="docutils literal notranslate"><span class="pre">DW_OP_xderef*</span></code>.</p></li>
<li><p>The CFI instructions: <code class="docutils literal notranslate"><span class="pre">DW_CFA_def_aspace_cfa</span></code> and
<code class="docutils literal notranslate"><span class="pre">DW_CFA_def_aspace_cfa_sf</span></code>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>With the definition of DWARF address classes and DWARF address spaces in this
proposal, DWARF Version 5 table 2.7 needs to be updated. It seems it is an
example of DWARF address spaces and not DWARF address classes.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>With the expanded support for DWARF address spaces in this proposal, it may be
worth examining if DWARF segments can be eliminated and DWARF address spaces
used instead.</p>
<p>That may involve extending DWARF address spaces to also be used to specify
code locations. In target architectures that use different memory areas for
code and data this would seem a natural use for DWARF address spaces. This
would allow DWARF expression location descriptions to be used to describe the
location of subprograms and entry points that are used in expressions
involving subprogram pointer type values.</p>
<p>Currently, DWARF expressions assume data and code resides in the same default
DWARF address space, and only the address ranges in DWARF location list
entries and in the <code class="docutils literal notranslate"><span class="pre">.debug_aranges</span></code> section for accelerated access for
addresses allow DWARF segments to be used to distinguish.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, DWARF defines address class values as being target architecture
specific. It is unclear how language specific memory spaces are intended to be
represented in DWARF using these.</p>
<p>For example, OpenCL defines memory spaces (called address spaces in OpenCL)
for <code class="docutils literal notranslate"><span class="pre">global</span></code>, <code class="docutils literal notranslate"><span class="pre">local</span></code>, <code class="docutils literal notranslate"><span class="pre">constant</span></code>, and <code class="docutils literal notranslate"><span class="pre">private</span></code>. These are part of
the type system and are modifiers to pointer types. In addition, OpenCL
defines <code class="docutils literal notranslate"><span class="pre">generic</span></code> pointers that can reference either the <code class="docutils literal notranslate"><span class="pre">global</span></code>,
<code class="docutils literal notranslate"><span class="pre">local</span></code>, or <code class="docutils literal notranslate"><span class="pre">private</span></code> memory spaces. To support the OpenCL language the
debugger would want to support casting pointers between the <code class="docutils literal notranslate"><span class="pre">generic</span></code> and
other memory spaces, querying what memory space a <code class="docutils literal notranslate"><span class="pre">generic</span></code> pointer value is
currently referencing, and possibly using pointer casting to form an address
for a specific memory space out of an integral value.</p>
<p>The method to use to dereference a pointer type or reference type value is
defined in DWARF expressions using <code class="docutils literal notranslate"><span class="pre">DW_OP_xderef*</span></code> which uses a target
architecture specific address space.</p>
<p>DWARF defines the <code class="docutils literal notranslate"><span class="pre">DW_AT_address_class</span></code> attribute on pointer type and
reference type debugger information entries. It specifies the method to use to
dereference them. Why is the value of this not the same as the address space
value used in <code class="docutils literal notranslate"><span class="pre">DW_OP_xderef*</span></code>? In both cases it is target architecture
specific and the architecture presumably will use the same set of methods to
dereference pointers in both cases.</p>
<p>Since <code class="docutils literal notranslate"><span class="pre">DW_AT_address_class</span></code> uses a target architecture specific value, it
cannot in general capture the source language memory space type modifier
concept. On some architectures all source language memory space modifiers may
actually use the same method for dereferencing pointers.</p>
<p>One possibility is for DWARF to add an <code class="docutils literal notranslate"><span class="pre">DW_TAG_LLVM_address_class_type</span></code>
debugger information entry type modifier that can be applied to a pointer type
and reference type. The <code class="docutils literal notranslate"><span class="pre">DW_AT_address_class</span></code> attribute could be re-defined
to not be target architecture specific and instead define generalized language
values (as is proposed above for DWARF address classes in the table
<a class="reference internal" href="#amdgpu-dwarf-address-class-table"><span class="std std-ref">Address class</span></a>) that will support OpenCL and other
languages using memory spaces. The <code class="docutils literal notranslate"><span class="pre">DW_AT_address_class</span></code> attribute could be
defined to not be applied to pointer types or reference types, but instead
only to the new <code class="docutils literal notranslate"><span class="pre">DW_TAG_LLVM_address_class_type</span></code> type modifier debugger
information entry.</p>
<p>If a pointer type or reference type is not modified by
<code class="docutils literal notranslate"><span class="pre">DW_TAG_LLVM_address_class_type</span></code> or if <code class="docutils literal notranslate"><span class="pre">DW_TAG_LLVM_address_class_type</span></code>
has no <code class="docutils literal notranslate"><span class="pre">DW_AT_address_class</span></code> attribute, then the pointer type or reference
type would be defined to use the <code class="docutils literal notranslate"><span class="pre">DW_ADDR_none</span></code> address class as currently.
Since modifiers can be chained, it would need to be defined if multiple
<code class="docutils literal notranslate"><span class="pre">DW_TAG_LLVM_address_class_type</span></code> modifiers were legal, and if so if the
outermost one is the one that takes precedence.</p>
<p>A target architecture implementation that supports multiple address spaces
would need to map <code class="docutils literal notranslate"><span class="pre">DW_ADDR_none</span></code> appropriately to support CUDA-like
languages that have no address classes in the type system but do support
variable allocation in address classes. Such variable allocation would result
in the variable’s location description needing an address space.</p>
<p>The approach proposed in <a class="reference internal" href="#amdgpu-dwarf-address-class-table"><span class="std std-ref">Address class</span></a> is to define
the default <code class="docutils literal notranslate"><span class="pre">DW_ADDR_none</span></code> to be the generic address class and not the
global address class. This matches how CLANG and LLVM have added support for
CUDA-like languages on top of existing C++ language support. This allows all
addresses to be generic by default which matches CUDA-like languages.</p>
<p>An alternative approach is to define <code class="docutils literal notranslate"><span class="pre">DW_ADDR_none</span></code> as being the global
address class and then change <code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_global</span></code> to
<code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_generic</span></code>. This would match the reality that languages that do
not support multiple memory spaces only have one default global memory space.
Generally, in these languages if they expose that the target architecture
supports multiple address spaces, the default one is still the global memory
space. Then a language that does support multiple memory spaces has to
explicitly indicate which pointers have the added ability to reference more
than the global memory space. However, compilers generating DWARF for
CUDA-like languages would then have to define every CUDA-like language pointer
type or reference type using <code class="docutils literal notranslate"><span class="pre">DW_TAG_LLVM_address_class_type</span></code> with a
<code class="docutils literal notranslate"><span class="pre">DW_AT_address_class</span></code> attribute of <code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_generic</span></code> to match the
language semantics.</p>
<p>A new <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_address_space</span></code> attribute could be defined that can be
applied to pointer type, reference type, subprogram, and subprogram type to
describe how objects having the given type are dereferenced or called (the
role that <code class="docutils literal notranslate"><span class="pre">DW_AT_address_class</span></code> currently provides). The values of
<code class="docutils literal notranslate"><span class="pre">DW_AT_address_space</span></code> would be target architecture specific and the same as
used in <code class="docutils literal notranslate"><span class="pre">DW_OP_xderef*</span></code>.</p>
</div>
</div>
<div class="section" id="debugging-information-entry-attributes">
<span id="amdgpu-dwarf-debugging-information-entry-attributes"></span><h4><a class="toc-backref" href="#id27">Debugging Information Entry Attributes</a><a class="headerlink" href="#debugging-information-entry-attributes" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section provides changes to existing debugger information entry
attributes and defines attributes added by the proposal. These would be
incorporated into the appropriate DWARF Version 5 chapter 2 sections.</p>
</div>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code></p>
<p>Any debugging information entry describing a data object (which includes
variables and parameters) or common blocks may have a <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code>
attribute, whose value is a DWARF expression E.</p>
<p>The result of the attribute is obtained by evaluating E as a location
description in the context of the current subprogram, current program
location, and with an empty initial stack. See
<a class="reference internal" href="#amdgpu-dwarf-expressions"><span class="std std-ref">DWARF Expressions</span></a>.</p>
<p>See <a class="reference internal" href="#amdgpu-dwarf-control-flow-operations"><span class="std std-ref">Control Flow Operations</span></a> for special evaluation rules
used by the <code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> operations.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Delete the description of how the <code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> operations evaluate a
<code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> attribute as that is now described in the operations.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See the discussion about the <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> attribute in the
<code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> operation. Having each attribute only have a single
purpose and single execution semantics seems desirable. It makes it easier
for the consumer that no longer have to track the context. It makes it
easier for the producer as it can rely on a single semantics for each
attribute.</p>
<p>For that reason, limiting the <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> attribute to only
supporting evaluating the location description of an object, and using a
different attribute and encoding class for the evaluation of DWARF
expression <em>procedures</em> on the same operation expression stack seems
desirable.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_const_value</span></code></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Could deprecate using the <code class="docutils literal notranslate"><span class="pre">DW_AT_const_value</span></code> attribute for
<code class="docutils literal notranslate"><span class="pre">DW_TAG_variable</span></code> or <code class="docutils literal notranslate"><span class="pre">DW_TAG_formal_parameter</span></code> debugger information
entries that have been optimized to a constant. Instead,
<code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code> could be used with a DWARF expression that produces an
implicit location description now that any location description can be
used within a DWARF expression. This allows the <code class="docutils literal notranslate"><span class="pre">DW_OP_call*</span></code> operations
to be used to push the location description of any variable regardless of
how it is optimized.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_frame_base</span></code></p>
<p>A <code class="docutils literal notranslate"><span class="pre">DW_TAG_subprogram</span></code> or <code class="docutils literal notranslate"><span class="pre">DW_TAG_entry_point</span></code> debugger information entry
may have a <code class="docutils literal notranslate"><span class="pre">DW_AT_frame_base</span></code> attribute, whose value is a DWARF expression
E.</p>
<p>The result of the attribute is obtained by evaluating E as a location
description in the context of the current subprogram, current program
location, and with an empty initial stack.</p>
<p>The DWARF is ill-formed if E contains an <code class="docutils literal notranslate"><span class="pre">DW_OP_fbreg</span></code> operation, or the
resulting location description L is not comprised of one single location
description SL.</p>
<p>If SL a register location description for register R, then L is replaced
with the result of evaluating a <code class="docutils literal notranslate"><span class="pre">DW_OP_bregx</span> <span class="pre">R,</span> <span class="pre">0</span></code> operation. This
computes the frame base memory location description in the target
architecture default address space.</p>
<p><em>This allows the more compact</em> <code class="docutils literal notranslate"><span class="pre">DW_OPreg*</span></code> <em>to be used instead of</em>
<code class="docutils literal notranslate"><span class="pre">DW_OP_breg*</span> <span class="pre">0</span></code><em>.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This rule could be removed and require the producer to create the required
location description directly using <code class="docutils literal notranslate"><span class="pre">DW_OP_call_frame_cfa</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_OP_breg*</span></code>, or <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_aspace_bregx</span></code>. This would also then
allow a target to implement the call frames within a large register.</p>
</div>
<p>Otherwise, the DWARF is ill-formed if SL is not a memory location
description in any of the target architecture specific address spaces.</p>
<p>The resulting L is the <em>frame base</em> for the subprogram or entry point.</p>
<p><em>Typically, E will use the</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_call_frame_cfa</span></code> <em>operation or be a
stack pointer register plus or minus some offset.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_data_member_location</span></code></p>
<p>For a <code class="docutils literal notranslate"><span class="pre">DW_AT_data_member_location</span></code> attribute there are two cases:</p>
<ol class="arabic">
<li><p>If the attribute is an integer constant B, it provides the offset in
bytes from the beginning of the containing entity.</p>
<p>The result of the attribute is obtained by evaluating a
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset</span> <span class="pre">B</span></code> operation with an initial stack comprising the
location description of the beginning of the containing entity.  The
result of the evaluation is the location description of the base of the
member entry.</p>
<p><em>If the beginning of the containing entity is not byte aligned, then the
beginning of the member entry has the same bit displacement within a
byte.</em></p>
</li>
<li><p>Otherwise, the attribute must be a DWARF expression E which is evaluated
with a context of the current frame, current program location, and an
initial stack comprising the location description of the beginning of
the containing entity. The result of the evaluation is the location
description of the base of the member entry.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The beginning of the containing entity can now be any location
description, including those with more than one single location
description, and those with single location descriptions that are of any
kind and have any bit offset.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_use_location</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_TAG_ptr_to_member_type</span></code> debugging information entry has a
<code class="docutils literal notranslate"><span class="pre">DW_AT_use_location</span></code> attribute whose value is a DWARF expression E. It is
used to compute the location description of the member of the class to which
the pointer to member entry points.</p>
<p><em>The method used to find the location description of a given member of a
class, structure, or union is common to any instance of that class,
structure, or union and to any instance of the pointer to member type. The
method is thus associated with the pointer to member type, rather than with
each object that has a pointer to member type.</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_AT_use_location</span></code> DWARF expression is used in conjunction with the
location description for a particular object of the given pointer to member
type and for a particular structure or class instance.</p>
<p>The result of the attribute is obtained by evaluating E as a location
description with the context of the current subprogram, current program
location, and an initial stack comprising two entries. The first entry is
the value of the pointer to member object itself. The second entry is the
location description of the base of the entire class, structure, or union
instance containing the member whose location is being calculated.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_data_location</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_AT_data_location</span></code> attribute may be used with any type that
provides one or more levels of hidden indirection and/or run-time parameters
in its representation. Its value is a DWARF operation expression E which
computes the location description of the data for an object. When this
attribute is omitted, the location description of the data is the same as
the location description of the object.</p>
<p>The result of the attribute is obtained by evaluating E as a location
description with the context of the current subprogram, current program
location, and an empty initial stack.</p>
<p><em>E will typically involve an operation expression that begins with a</em>
<code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code> <em>operation which loads the location
description of the object which can then serve as a description in
subsequent calculation.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since <code class="docutils literal notranslate"><span class="pre">DW_AT_data_member_location</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_AT_use_location</span></code>, and
<code class="docutils literal notranslate"><span class="pre">DW_AT_vtable_elem_location</span></code> allow both operation expressions and
location list expressions, why does <code class="docutils literal notranslate"><span class="pre">DW_AT_data_location</span></code> not allow
both? In all cases they apply to data objects so less likely that
optimization would cause different operation expressions for different
program location ranges. But if supporting for some then should be for
all.</p>
<p>It seems odd this attribute is not the same as
<code class="docutils literal notranslate"><span class="pre">DW_AT_data_member_location</span></code> in having an initial stack with the
location description of the object since the expression has to need it.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_vtable_elem_location</span></code></p>
<p>An entry for a virtual function also has a <code class="docutils literal notranslate"><span class="pre">DW_AT_vtable_elem_location</span></code>
attribute whose value is a DWARF expression E.</p>
<p>The result of the attribute is obtained by evaluating E as a location
description with the context of the current subprogram, current program
location, and an initial stack comprising the location description of the
object of the enclosing type.</p>
<p>The resulting location description is the slot for the function within the
virtual function table for the enclosing class.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_static_link</span></code></p>
<p>If a <code class="docutils literal notranslate"><span class="pre">DW_TAG_subprogram</span></code> or <code class="docutils literal notranslate"><span class="pre">DW_TAG_entry_point</span></code> debugger information
entry is lexically nested, it may have a <code class="docutils literal notranslate"><span class="pre">DW_AT_static_link</span></code> attribute,
whose value is a DWARF expression E.</p>
<p>The result of the attribute is obtained by evaluating E as a location
description with the context of the current subprogram, current program
location, and an empty initial stack.</p>
<p>The DWARF is ill-formed if the resulting location description L is is not
comprised of one memory location description in any of the target
architecture specific address spaces.</p>
<p>The resulting L is the <em>frame base</em> of the relevant instance of the
subprogram that immediately lexically encloses the subprogram or entry
point.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_return_addr</span></code></p>
<p>A <code class="docutils literal notranslate"><span class="pre">DW_TAG_subprogram</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_TAG_inlined_subroutine</span></code>, or
<code class="docutils literal notranslate"><span class="pre">DW_TAG_entry_point</span></code> debugger information entry may have a
<code class="docutils literal notranslate"><span class="pre">DW_AT_return_addr</span></code> attribute, whose value is a DWARF expression E.</p>
<p>The result of the attribute is obtained by evaluating E as a location
description with the context of the current subprogram, current program
location, and an empty initial stack.</p>
<p>The DWARF is ill-formed if the resulting location description L is not
comprised one memory location description in any of the target architecture
specific address spaces.</p>
<p>The resulting L is the place where the return address for the subprogram or
entry point is stored.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is unclear why <code class="docutils literal notranslate"><span class="pre">DW_TAG_inlined_subroutine</span></code> has a
<code class="docutils literal notranslate"><span class="pre">DW_AT_return_addr</span></code> attribute but not a <code class="docutils literal notranslate"><span class="pre">DW_AT_frame_base</span></code> or
<code class="docutils literal notranslate"><span class="pre">DW_AT_static_link</span></code> attribute. Seems it would either have all of them or
none. Since inlined subprograms do not have a frame it seems they would
have none of these attributes.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_call_value</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_AT_call_data_location</span></code>, and <code class="docutils literal notranslate"><span class="pre">DW_AT_call_data_value</span></code></p>
<p>A <code class="docutils literal notranslate"><span class="pre">DW_TAG_call_site_parameter</span></code> debugger information entry may have a
<code class="docutils literal notranslate"><span class="pre">DW_AT_call_value</span></code> attribute, whose value is a DWARF operation expression
E<sub>1</sub>.</p>
<p>The result of the <code class="docutils literal notranslate"><span class="pre">DW_AT_call_value</span></code> attribute is obtained by evaluating
E<sub>1</sub> as a value with the context of the call site subprogram, call
site program location, and an empty initial stack.</p>
<p>The call site subprogram is the subprogram containing the
<code class="docutils literal notranslate"><span class="pre">DW_TAG_call_site_parameter</span></code> debugger information entry. The call site
program location is the location of call site in the call site subprogram.</p>
<p><em>The consumer may have to virtually unwind to the call site in order to
evaluate the attribute. This will provide both the call site subprogram and
call site program location needed to evaluate the expression.</em></p>
<p>The resulting value V<sub>1</sub> is the value of the parameter at the time of
the call made by the call site.</p>
<p>For parameters passed by reference, where the code passes a pointer to a
location which contains the parameter, or for reference type parameters, the
<code class="docutils literal notranslate"><span class="pre">DW_TAG_call_site_parameter</span></code> debugger information entry may also have a
<code class="docutils literal notranslate"><span class="pre">DW_AT_call_data_location</span></code> attribute whose value is a DWARF operation
expression E<sub>2</sub>, and a <code class="docutils literal notranslate"><span class="pre">DW_AT_call_data_value</span></code> attribute whose
value is a DWARF operation expression E<sub>3</sub>.</p>
<p>The value of the <code class="docutils literal notranslate"><span class="pre">DW_AT_call_data_location</span></code> attribute is obtained by
evaluating E<sub>2</sub> as a location description with the context of the
call site subprogram, call site program location, and an empty initial
stack.</p>
<p>The resulting location description L<sub>2</sub> is the location where the
referenced parameter lives during the call made by the call site. If E<sub>2</sub> would just be a <code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code>, then the
<code class="docutils literal notranslate"><span class="pre">DW_AT_call_data_location</span></code> attribute may be omitted.</p>
<p>The value of the <code class="docutils literal notranslate"><span class="pre">DW_AT_call_data_value</span></code> attribute is obtained by
evaluating E<sub>3</sub> as a value with the context of the call site
subprogram, call site program location, and an empty initial stack.</p>
<p>The resulting value V<sub>3</sub> is the value in L<sub>2</sub> at the time of
the call made by the call site.</p>
<p>If it is not possible to avoid the expressions of these attributes from
accessing registers or memory locations that might be clobbered by the
subprogram being called by the call site, then the associated attribute
should not be provided.</p>
<p><em>The reason for the restriction is that the parameter may need to be
accessed during the execution of the callee. The consumer may virtually
unwind from the called subprogram back to the caller and then evaluate the
attribute expressions. The call frame information (see</em>
<a class="reference internal" href="#amdgpu-dwarf-call-frame-information"><span class="std std-ref">Call Frame Information</span></a><em>) will not be able to restore
registers that have been clobbered, and clobbered memory will no longer have
the value at the time of the call.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lanes</span></code> <em>New</em></p>
<p>For languages that are implemented using a SIMD or SIMT execution model, a
<code class="docutils literal notranslate"><span class="pre">DW_TAG_subprogram</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_TAG_inlined_subroutine</span></code>, or
<code class="docutils literal notranslate"><span class="pre">DW_TAG_entry_point</span></code> debugger information entry may have a
<code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lanes</span></code> attribute whose value is an integer constant that is
the number of lanes per thread. This is the static number of lanes per
thread. It is not the dynamic number of lanes with which the thread was
initiated, for example, due to smaller or partial work-groups.</p>
<p>If not present, the default value of 1 is used.</p>
<p>The DWARF is ill-formed if the value is 0.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code> <em>New</em></p>
<p>For languages that are implemented using a SIMD or SIMT execution model, a
<code class="docutils literal notranslate"><span class="pre">DW_TAG_subprogram</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_TAG_inlined_subroutine</span></code>, or
<code class="docutils literal notranslate"><span class="pre">DW_TAG_entry_point</span></code> debugging information entry may have a
<code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code> attribute whose value is a DWARF expression E.</p>
<p>The result of the attribute is obtained by evaluating E as a location
description with the context of the current subprogram, current program
location, and an empty initial stack.</p>
<p>The resulting location description L is for a thread lane count sized vector
of generic type elements. The thread lane count is the value of the
<code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lanes</span></code> attribute. Each element holds the conceptual program
location of the corresponding lane, where the least significant element
corresponds to the first target architecture specific lane identifier and so
forth. If the lane was not active when the current subprogram was called,
its element is an undefined location description.</p>
<p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code> <em>allows the compiler to indicate conceptually where
each lane of a SIMT thread is positioned even when it is in divergent
control flow that is not active.</em></p>
<p><em>Typically, the result is a location description with one composite location
description with each part being a location description with either one
undefined location description or one memory location description.</em></p>
<p>If not present, the thread is not being used in a SIMT manner, and the
thread’s current program location is used.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_active_lane</span></code> <em>New</em></p>
<p>For languages that are implemented using a SIMD or SIMT execution model, a
<code class="docutils literal notranslate"><span class="pre">DW_TAG_subprogram</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_TAG_inlined_subroutine</span></code>, or
<code class="docutils literal notranslate"><span class="pre">DW_TAG_entry_point</span></code> debugger information entry may have a
<code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_active_lane</span></code> attribute whose value is a DWARF expression E.</p>
<p>The result of the attribute is obtained by evaluating E as a value with the
context of the current subprogram, current program location, and an empty
initial stack.</p>
<p>The DWARF is ill-formed if the resulting value V is not an integral value.</p>
<p>The resulting V is a bit mask of active lanes for the current program
location. The N<sup>th</sup> least significant bit of the mask corresponds to
the N<sup>th</sup> lane. If the bit is 1 the lane is active, otherwise it is
inactive.</p>
<p><em>Some targets may update the target architecture execution mask for regions
of code that must execute with different sets of lanes than the current
active lanes. For example, some code must execute with all lanes made
temporarily active.</em> <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_active_lane</span></code> <em>allows the compiler to
provide the means to determine the source language active lanes.</em></p>
<p>If not present and <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lanes</span></code> is greater than 1, then the target
architecture execution mask is used.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_vector_size</span></code> <em>New</em></p>
<p>A <code class="docutils literal notranslate"><span class="pre">DW_TAG_base_type</span></code> debugger information entry for a base type T may have
a <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_vector_size</span></code> attribute whose value is an integer constant
that is the vector type size N.</p>
<p>The representation of a vector base type is as N contiguous elements, each
one having the representation of a base type T’ that is the same as T
without the <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_vector_size</span></code> attribute.</p>
<p>If a <code class="docutils literal notranslate"><span class="pre">DW_TAG_base_type</span></code> debugger information entry does not have a
<code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_vector_size</span></code> attribute, then the base type is not a vector
type.</p>
<p>The DWARF is ill-formed if N is not greater than 0.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>LLVM has mention of a non-upstreamed debugger information entry that is
intended to support vector types. However, that was not for a base type so
would not be suitable as the type of a stack value entry. But perhaps that
could be replaced by using this attribute.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_augmentation</span></code> <em>New</em></p>
<p>A <code class="docutils literal notranslate"><span class="pre">DW_TAG_compile_unit</span></code> debugger information entry for a compilation unit
may have a <code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_augmentation</span></code> attribute, whose value is an
augmentation string.</p>
<p><em>The augmentation string allows producers to indicate that there is
additional vendor or target specific information in the debugging
information entries. For example, this might be information about the
version of vendor specific extensions that are being used.</em></p>
<p>If not present, or if the string is empty, then the compilation unit has no
augmentation string.</p>
<p>The format for the augmentation string is:</p>
<blockquote>
<div><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">[</span></code><em>vendor</em><code class="docutils literal notranslate"><span class="pre">:v</span></code><em>X</em><code class="docutils literal notranslate"><span class="pre">.</span></code><em>Y</em>[<code class="docutils literal notranslate"><span class="pre">:</span></code><em>options</em>]<code class="docutils literal notranslate"><span class="pre">]</span></code>*</div>
</div>
</div></blockquote>
<p>Where <em>vendor</em> is the producer, <code class="docutils literal notranslate"><span class="pre">vX.Y</span></code> specifies the major X and minor Y
version number of the extensions used, and <em>options</em> is an optional string
providing additional information about the extensions. The version number
must conform to semantic versioning [<a class="reference internal" href="#amdgpu-dwarf-semver"><span class="std std-ref">SEMVER</span></a>].
The <em>options</em> string must not contain the “<code class="docutils literal notranslate"><span class="pre">]</span></code>” character.</p>
<p>For example:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">abc</span><span class="p">:</span><span class="n">v0</span><span class="o">.</span><span class="mi">0</span><span class="p">][</span><span class="n">def</span><span class="p">:</span><span class="n">v1</span><span class="o">.</span><span class="mi">2</span><span class="p">:</span><span class="n">feature</span><span class="o">-</span><span class="n">a</span><span class="o">=</span><span class="n">on</span><span class="p">,</span><span class="n">feature</span><span class="o">-</span><span class="n">b</span><span class="o">=</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ol>
</div>
</div>
<div class="section" id="program-scope-entities">
<h3><a class="toc-backref" href="#id28">Program Scope Entities</a><a class="headerlink" href="#program-scope-entities" title="Permalink to this headline">¶</a></h3>
<div class="section" id="unit-entities">
<span id="amdgpu-dwarf-language-names"></span><h4><a class="toc-backref" href="#id29">Unit Entities</a><a class="headerlink" href="#unit-entities" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This augments DWARF Version 5 section 3.1.1 and Table 3.1.</p>
</div>
<p>Additional language codes defined for use with the <code class="docutils literal notranslate"><span class="pre">DW_AT_language</span></code> attribute
are defined in <a class="reference internal" href="#amdgpu-dwarf-language-names-table"><span class="std std-ref">Language Names</span></a>.</p>
<table class="docutils align-default" id="amdgpu-dwarf-language-names-table">
<caption><span class="caption-text">Language Names</span><a class="headerlink" href="#amdgpu-dwarf-language-names-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 41%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Language Name</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_LANG_LLVM_HIP</span></code></p></td>
<td><p>HIP Language.</p></td>
</tr>
</tbody>
</table>
<p>The HIP language [<a class="reference internal" href="#amdgpu-dwarf-hip"><span class="std std-ref">HIP</span></a>] can be supported by extending
the C++ language.</p>
</div>
</div>
<div class="section" id="other-debugger-information">
<h3><a class="toc-backref" href="#id30">Other Debugger Information</a><a class="headerlink" href="#other-debugger-information" title="Permalink to this headline">¶</a></h3>
<div class="section" id="accelerated-access">
<h4><a class="toc-backref" href="#id31">Accelerated Access</a><a class="headerlink" href="#accelerated-access" title="Permalink to this headline">¶</a></h4>
<div class="section" id="lookup-by-name">
<span id="amdgpu-dwarf-lookup-by-name"></span><h5><a class="toc-backref" href="#id32">Lookup By Name</a><a class="headerlink" href="#lookup-by-name" title="Permalink to this headline">¶</a></h5>
<div class="section" id="contents-of-the-name-index">
<h6><a class="toc-backref" href="#id33">Contents of the Name Index</a><a class="headerlink" href="#contents-of-the-name-index" title="Permalink to this headline">¶</a></h6>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following provides changes to DWARF Version 5 section 6.1.1.1.</p>
<p>The rule for debugger information entries included in the name index in the
optional <code class="docutils literal notranslate"><span class="pre">.debug_names</span></code> section is extended to also include named
<code class="docutils literal notranslate"><span class="pre">DW_TAG_variable</span></code> debugging information entries with a <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code>
attribute that includes a <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code> operation.</p>
</div>
<p>The name index must contain an entry for each debugging information entry that
defines a named subprogram, label, variable, type, or namespace, subject to the
following rules:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_TAG_variable</span></code> debugging information entries with a <code class="docutils literal notranslate"><span class="pre">DW_AT_location</span></code>
attribute that includes a <code class="docutils literal notranslate"><span class="pre">DW_OP_addr</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_form_aspace_address</span></code>,
or <code class="docutils literal notranslate"><span class="pre">DW_OP_form_tls_address</span></code> operation are included; otherwise, they are
excluded.</p></li>
</ul>
</div>
<div class="section" id="data-representation-of-the-name-index">
<h6><a class="toc-backref" href="#id34">Data Representation of the Name Index</a><a class="headerlink" href="#data-representation-of-the-name-index" title="Permalink to this headline">¶</a></h6>
<div class="section" id="section-header">
<h7><a class="toc-backref" href="#id35">Section Header</a><a class="headerlink" href="#section-header" title="Permalink to this headline">¶</a></h7>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following provides an addition to DWARF Version 5 section 6.1.1.4.1 item
14 <code class="docutils literal notranslate"><span class="pre">augmentation_string</span></code>.</p>
</div>
<p>A null-terminated UTF-8 vendor specific augmentation string, which provides
additional information about the contents of this index. If provided, the
recommended format for augmentation string is:</p>
<blockquote>
<div><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">[</span></code><em>vendor</em><code class="docutils literal notranslate"><span class="pre">:v</span></code><em>X</em><code class="docutils literal notranslate"><span class="pre">.</span></code><em>Y</em>[<code class="docutils literal notranslate"><span class="pre">:</span></code><em>options</em>]<code class="docutils literal notranslate"><span class="pre">]</span></code>*</div>
</div>
</div></blockquote>
<p>Where <em>vendor</em> is the producer, <code class="docutils literal notranslate"><span class="pre">vX.Y</span></code> specifies the major X and minor Y
version number of the extensions used in the DWARF of the compilation unit, and
<em>options</em> is an optional string providing additional information about the
extensions. The version number must conform to semantic versioning [<a class="reference internal" href="#amdgpu-dwarf-semver"><span class="std std-ref">SEMVER</span></a>]. The <em>options</em> string must not contain the “<code class="docutils literal notranslate"><span class="pre">]</span></code>”
character.</p>
<p>For example:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">abc</span><span class="p">:</span><span class="n">v0</span><span class="o">.</span><span class="mi">0</span><span class="p">][</span><span class="n">def</span><span class="p">:</span><span class="n">v1</span><span class="o">.</span><span class="mi">2</span><span class="p">:</span><span class="n">feature</span><span class="o">-</span><span class="n">a</span><span class="o">=</span><span class="n">on</span><span class="p">,</span><span class="n">feature</span><span class="o">-</span><span class="n">b</span><span class="o">=</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is different to the definition in DWARF Version 5 but is consistent with
the other augmentation strings and allows multiple vendor extensions to be
supported.</p>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="line-number-information">
<span id="amdgpu-dwarf-line-number-information"></span><h4><a class="toc-backref" href="#id36">Line Number Information</a><a class="headerlink" href="#line-number-information" title="Permalink to this headline">¶</a></h4>
<div class="section" id="the-line-number-program-header">
<h5><a class="toc-backref" href="#id37">The Line Number Program Header</a><a class="headerlink" href="#the-line-number-program-header" title="Permalink to this headline">¶</a></h5>
<div class="section" id="standard-content-descriptions">
<h6><a class="toc-backref" href="#id38">Standard Content Descriptions</a><a class="headerlink" href="#standard-content-descriptions" title="Permalink to this headline">¶</a></h6>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This augments DWARF Version 5 section 6.2.4.1.</p>
</div>
<ol class="arabic" id="amdgpu-dwarf-line-number-information-dw-lnct-llvm-source">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_LNCT_LLVM_source</span></code></p>
<p>The component is a null-terminated UTF-8 source text string with “<code class="docutils literal notranslate"><span class="pre">\n</span></code>” line endings. This content code is paired with the same forms as
<code class="docutils literal notranslate"><span class="pre">DW_LNCT_path</span></code>. It can be used for file name entries.</p>
<p>The value is an empty null-terminated string if no source is available. If
the source is available but is an empty file then the value is a
null-terminated single “<code class="docutils literal notranslate"><span class="pre">\n</span></code>”.</p>
<p><em>When the source field is present, consumers can use the embedded source
instead of attempting to discover the source on disk using the file path
provided by the</em> <code class="docutils literal notranslate"><span class="pre">DW_LNCT_path</span></code> <em>field. When the source field is absent,
consumers can access the file to get the source text.</em></p>
<p><em>This is particularly useful for programing languages that support runtime
compilation and runtime generation of source text. In these cases, the
source text does not reside in any permanent file. For example, the OpenCL
language [:ref:`OpenCL &lt;amdgpu-dwarf-OpenCL&gt;`] supports online compilation.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_LNCT_LLVM_is_MD5</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">DW_LNCT_LLVM_is_MD5</span></code> indicates if the <code class="docutils literal notranslate"><span class="pre">DW_LNCT_MD5</span></code> content kind, if
present, is valid: when 0 it is not valid and when 1 it is valid. If
<code class="docutils literal notranslate"><span class="pre">DW_LNCT_LLVM_is_MD5</span></code> content kind is not present, and <code class="docutils literal notranslate"><span class="pre">DW_LNCT_MD5</span></code>
content kind is present, then the MD5 checksum is valid.</p>
<p><code class="docutils literal notranslate"><span class="pre">DW_LNCT_LLVM_is_MD5</span></code> is always paired with the <code class="docutils literal notranslate"><span class="pre">DW_FORM_udata</span></code> form.</p>
<p><em>This allows a compilation unit to have a mixture of files with and without
MD5 checksums. This can happen when multiple relocatable files are linked
together.</em></p>
</li>
</ol>
</div>
</div>
</div>
<div class="section" id="call-frame-information">
<span id="amdgpu-dwarf-call-frame-information"></span><h4><a class="toc-backref" href="#id39">Call Frame Information</a><a class="headerlink" href="#call-frame-information" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This section provides changes to existing Call Frame Information and defines
instructions added by the proposal. Additional support is added for address
spaces. Register unwind DWARF expressions are generalized to allow any
location description, including those with composite and implicit location
descriptions.</p>
<p>These changes would be incorporated into the DWARF Version 5 section 6.1.</p>
</div>
<div class="section" id="structure-of-call-frame-information">
<h5><a class="toc-backref" href="#id40">Structure of Call Frame Information</a><a class="headerlink" href="#structure-of-call-frame-information" title="Permalink to this headline">¶</a></h5>
<p>The register rules are:</p>
<dl>
<dt><em>undefined</em></dt><dd><p>A register that has this rule has no recoverable value in the previous frame.
(By convention, it is not preserved by a callee.)</p>
</dd>
<dt><em>same value</em></dt><dd><p>This register has not been modified from the previous frame. (By convention,
it is preserved by the callee, but the callee has not modified it.)</p>
</dd>
<dt><em>offset(N)</em></dt><dd><p>N is a signed byte offset. The previous value of this register is saved at the
location description computed as if the DWARF operation expression
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset</span> <span class="pre">N</span></code> is evaluated as a location description with an initial
stack comprising the location description of the current CFA (see
<a class="reference internal" href="#amdgpu-dwarf-operation-expressions"><span class="std std-ref">DWARF Operation Expressions</span></a>).</p>
</dd>
<dt><em>val_offset(N)</em></dt><dd><p>N is a signed byte offset. The previous value of this register is the memory
byte address of the location description computed as if the DWARF operation
expression <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_offset</span> <span class="pre">N</span></code> is evaluated as a location description with
an initial stack comprising the location description of the current CFA (see
<a class="reference internal" href="#amdgpu-dwarf-operation-expressions"><span class="std std-ref">DWARF Operation Expressions</span></a>).</p>
<p>The DWARF is ill-formed if the CFA location description is not a memory byte
address location description, or if the register size does not match the size
of an address in the address space of the current CFA location description.</p>
<p><em>Since the CFA location description is required to be a memory byte address
location description, the value of val_offset(N) will also be a memory byte
address location description since it is offsetting the CFA location
description by N bytes. Furthermore, the value of val_offset(N) will be a
memory byte address in the same address space as the CFA location
description.</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Should DWARF allow the address size to be a different size to the size of
the register? Requiring them to be the same bit size avoids any issue of
conversion as the bit contents of the register is simply interpreted as a
value of the address.</p>
<p>GDB has a per register hook that allows a target specific conversion on a
register by register basis. It defaults to truncation of bigger registers,
and to actually reading bytes from the next register (or reads out of bounds
for the last register) for smaller registers. There are no GDB tests that
read a register out of bounds (except an illegal hand written assembly
test).</p>
</div>
</dd>
<dt><em>register(R)</em></dt><dd><p>The previous value of this register is stored in another register numbered R.</p>
<p>The DWARF is ill-formed if the register sizes do not match.</p>
</dd>
<dt><em>expression(E)</em></dt><dd><p>The previous value of this register is located at the location description
produced by evaluating the DWARF operation expression E (see
<a class="reference internal" href="#amdgpu-dwarf-operation-expressions"><span class="std std-ref">DWARF Operation Expressions</span></a>).</p>
<p>E is evaluated as a location description in the context of the current
subprogram, current program location, and with an initial stack comprising the
location description of the current CFA.</p>
</dd>
<dt><em>val_expression(E)</em></dt><dd><p>The previous value of this register is the value produced by evaluating the
DWARF operation expression E (see <a class="reference internal" href="#amdgpu-dwarf-operation-expressions"><span class="std std-ref">DWARF Operation Expressions</span></a>).</p>
<p>E is evaluated as a value in the context of the current subprogram, current
program location, and with an initial stack comprising the location
description of the current CFA.</p>
<p>The DWARF is ill-formed if the resulting value type size does not match the
register size.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This has limited usefulness as the DWARF expression E can only produce
values up to the size of the generic type. This is due to not allowing any
operations that specify a type in a CFI operation expression. This makes it
unusable for registers that are larger than the generic type. However,
<em>expression(E)</em> can be used to create an implicit location description of
any size.</p>
</div>
</dd>
<dt><em>architectural</em></dt><dd><p>The rule is defined externally to this specification by the augmenter.</p>
</dd>
</dl>
<p>A Common Information Entry holds information that is shared among many Frame
Description Entries. There is at least one CIE in every non-empty
<code class="docutils literal notranslate"><span class="pre">.debug_frame</span></code> section. A CIE contains the following fields, in order:</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">length</span></code> (initial length)</p>
<p>A constant that gives the number of bytes of the CIE structure, not
including the length field itself. The size of the length field plus the
value of length must be an integral multiple of the address size specified
in the <code class="docutils literal notranslate"><span class="pre">address_size</span></code> field.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">CIE_id</span></code> (4 or 8 bytes, see
<a class="reference internal" href="#amdgpu-dwarf-32-bit-and-64-bit-dwarf-formats"><span class="std std-ref">32-Bit and 64-Bit DWARF Formats</span></a>)</p>
<p>A constant that is used to distinguish CIEs from FDEs.</p>
<p>In the 32-bit DWARF format, the value of the CIE id in the CIE header is
0xffffffff; in the 64-bit DWARF format, the value is 0xffffffffffffffff.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">version</span></code> (ubyte)</p>
<p>A version number. This number is specific to the call frame information and
is independent of the DWARF version number.</p>
<p>The value of the CIE version number is 4.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Would this be increased to 5 to reflect the changes in the proposal?</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">augmentation</span></code> (sequence of UTF-8 characters)</p>
<p>A null-terminated UTF-8 string that identifies the augmentation to this CIE
or to the FDEs that use it. If a reader encounters an augmentation string
that is unexpected, then only the following fields can be read:</p>
<ul class="simple">
<li><p>CIE: length, CIE_id, version, augmentation</p></li>
<li><p>FDE: length, CIE_pointer, initial_location, address_range</p></li>
</ul>
<p>If there is no augmentation, this value is a zero byte.</p>
<p><em>The augmentation string allows users to indicate that there is additional
vendor and target architecture specific information in the CIE or FDE which
is needed to virtually unwind a stack frame. For example, this might be
information about dynamically allocated data which needs to be freed on exit
from the routine.</em></p>
<p><em>Because the</em> <code class="docutils literal notranslate"><span class="pre">.debug_frame</span></code> <em>section is useful independently of any</em>
<code class="docutils literal notranslate"><span class="pre">.debug_info</span></code> <em>section, the augmentation string always uses UTF-8
encoding.</em></p>
<p>The recommended format for the augmentation string is:</p>
<blockquote>
<div><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">[</span></code><em>vendor</em><code class="docutils literal notranslate"><span class="pre">:v</span></code><em>X</em><code class="docutils literal notranslate"><span class="pre">.</span></code><em>Y</em>[<code class="docutils literal notranslate"><span class="pre">:</span></code><em>options</em>]<code class="docutils literal notranslate"><span class="pre">]</span></code>*</div>
</div>
</div></blockquote>
<p>Where <em>vendor</em> is the producer, <code class="docutils literal notranslate"><span class="pre">vX.Y</span></code> specifies the major X and minor Y
version number of the extensions used, and <em>options</em> is an optional string
providing additional information about the extensions. The version number
must conform to semantic versioning [<a class="reference internal" href="#amdgpu-dwarf-semver"><span class="std std-ref">SEMVER</span></a>].
The <em>options</em> string must not contain the “<code class="docutils literal notranslate"><span class="pre">]</span></code>” character.</p>
<p>For example:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">abc</span><span class="p">:</span><span class="n">v0</span><span class="o">.</span><span class="mi">0</span><span class="p">][</span><span class="n">def</span><span class="p">:</span><span class="n">v1</span><span class="o">.</span><span class="mi">2</span><span class="p">:</span><span class="n">feature</span><span class="o">-</span><span class="n">a</span><span class="o">=</span><span class="n">on</span><span class="p">,</span><span class="n">feature</span><span class="o">-</span><span class="n">b</span><span class="o">=</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">address_size</span></code> (ubyte)</p>
<p>The size of a target address in this CIE and any FDEs that use it, in bytes.
If a compilation unit exists for this frame, its address size must match the
address size here.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">segment_selector_size</span></code> (ubyte)</p>
<p>The size of a segment selector in this CIE and any FDEs that use it, in
bytes.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">code_alignment_factor</span></code> (unsigned LEB128)</p>
<p>A constant that is factored out of all advance location instructions (see
<a class="reference internal" href="#amdgpu-dwarf-row-creation-instructions"><span class="std std-ref">Row Creation Instructions</span></a>). The resulting value is
<code class="docutils literal notranslate"><span class="pre">(operand</span> <span class="pre">*</span> <span class="pre">code_alignment_factor)</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">data_alignment_factor</span></code> (signed LEB128)</p>
<p>A constant that is factored out of certain offset instructions (see
<a class="reference internal" href="#amdgpu-dwarf-cfa-definition-instructions"><span class="std std-ref">CFA Definition Instructions</span></a> and
<a class="reference internal" href="#amdgpu-dwarf-register-rule-instructions"><span class="std std-ref">Register Rule Instructions</span></a>). The resulting value is
<code class="docutils literal notranslate"><span class="pre">(operand</span> <span class="pre">*</span> <span class="pre">data_alignment_factor)</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">return_address_register</span></code> (unsigned LEB128)</p>
<p>An unsigned LEB128 constant that indicates which column in the rule table
represents the return address of the subprogram. Note that this column might
not correspond to an actual machine register.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_instructions</span></code> (array of ubyte)</p>
<p>A sequence of rules that are interpreted to create the initial setting of
each column in the table.</p>
<p>The default rule for all columns before interpretation of the initial
instructions is the undefined rule. However, an ABI authoring body or a
compilation system authoring body may specify an alternate default value for
any or all columns.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">padding</span></code> (array of ubyte)</p>
<p>Enough <code class="docutils literal notranslate"><span class="pre">DW_CFA_nop</span></code> instructions to make the size of this entry match the
length value above.</p>
</li>
</ol>
<p>An FDE contains the following fields, in order:</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">length</span></code> (initial length)</p>
<p>A constant that gives the number of bytes of the header and instruction
stream for this subprogram, not including the length field itself. The size
of the length field plus the value of length must be an integral multiple of
the address size.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">CIE_pointer</span></code> (4 or 8 bytes, see
<a class="reference internal" href="#amdgpu-dwarf-32-bit-and-64-bit-dwarf-formats"><span class="std std-ref">32-Bit and 64-Bit DWARF Formats</span></a>)</p>
<p>A constant offset into the <code class="docutils literal notranslate"><span class="pre">.debug_frame</span></code> section that denotes the CIE
that is associated with this FDE.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_location</span></code> (segment selector and target address)</p>
<p>The address of the first location associated with this table entry. If the
segment_selector_size field of this FDE’s CIE is non-zero, the initial
location is preceded by a segment selector of the given length.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">address_range</span></code> (target address)</p>
<p>The number of bytes of program instructions described by this entry.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">instructions</span></code> (array of ubyte)</p>
<p>A sequence of table defining instructions that are described in
<a class="reference internal" href="#amdgpu-dwarf-call-frame-instructions"><span class="std std-ref">Call Frame Instructions</span></a>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">padding</span></code> (array of ubyte)</p>
<p>Enough <code class="docutils literal notranslate"><span class="pre">DW_CFA_nop</span></code> instructions to make the size of this entry match the
length value above.</p>
</li>
</ol>
</div>
<div class="section" id="call-frame-instructions">
<span id="amdgpu-dwarf-call-frame-instructions"></span><h5><a class="toc-backref" href="#id41">Call Frame Instructions</a><a class="headerlink" href="#call-frame-instructions" title="Permalink to this headline">¶</a></h5>
<p>Some call frame instructions have operands that are encoded as DWARF operation
expressions E (see <a class="reference internal" href="#amdgpu-dwarf-operation-expressions"><span class="std std-ref">DWARF Operation Expressions</span></a>). The DWARF
operations that can be used in E have the following restrictions:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_addrx</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_call2</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_call4</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_call_ref</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_OP_const_type</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_constx</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_convert</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_OP_deref_type</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_fbreg</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_implicit_pointer</span></code>,
<code class="docutils literal notranslate"><span class="pre">DW_OP_regval_type</span></code>, <code class="docutils literal notranslate"><span class="pre">DW_OP_reinterpret</span></code>, and <code class="docutils literal notranslate"><span class="pre">DW_OP_xderef_type</span></code>
operations are not allowed because the call frame information must not depend
on other debug sections.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_push_object_address</span></code> is not allowed because there is no object
context to provide a value to push.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_push_lane</span></code> is not allowed because the call frame instructions
describe the actions for the whole thread, not the lanes independently.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_call_frame_cfa</span></code> and <code class="docutils literal notranslate"><span class="pre">DW_OP_entry_value</span></code> are not allowed because
their use would be circular.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_call_frame_entry_reg</span></code> is not allowed if evaluating E causes a
circular dependency between <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_call_frame_entry_reg</span></code> operations.</p>
<p><em>For example, if a register R1 has a</em> <code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_expression</span></code>
<em>instruction that evaluates a</em> <code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_call_frame_entry_reg</span></code> <em>operation
that specifies register R2, and register R2 has a</em>
<code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_expression</span></code> <em>instruction that that evaluates a</em>
<code class="docutils literal notranslate"><span class="pre">DW_OP_LLVM_call_frame_entry_reg</span></code> <em>operation that specifies register R1.</em></p>
</li>
</ul>
<p><em>Call frame instructions to which these restrictions apply include</em>
<code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_expression</span></code><em>,</em> <code class="docutils literal notranslate"><span class="pre">DW_CFA_expression</span></code><em>, and</em>
<code class="docutils literal notranslate"><span class="pre">DW_CFA_val_expression</span></code><em>.</em></p>
<div class="section" id="row-creation-instructions">
<span id="amdgpu-dwarf-row-creation-instructions"></span><h6><a class="toc-backref" href="#id42">Row Creation Instructions</a><a class="headerlink" href="#row-creation-instructions" title="Permalink to this headline">¶</a></h6>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These instructions are the same as in DWARF Version 5 section 6.4.2.1.</p>
</div>
</div>
<div class="section" id="cfa-definition-instructions">
<span id="amdgpu-dwarf-cfa-definition-instructions"></span><h6><a class="toc-backref" href="#id43">CFA Definition Instructions</a><a class="headerlink" href="#cfa-definition-instructions" title="Permalink to this headline">¶</a></h6>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa</span></code> instruction takes two unsigned LEB128 operands
representing a register number R and a (non-factored) byte displacement B.
AS is set to the target architecture default address space identifier. The
required action is to define the current CFA rule to be the result of
evaluating the DWARF operation expression <code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span> <span class="pre">AS;</span>
<span class="pre">DW_OP_aspace_bregx</span> <span class="pre">R,</span> <span class="pre">B</span></code> as a location description.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_sf</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_sf</span></code> instruction takes two operands: an unsigned LEB128
value representing a register number R and a signed LEB128 factored byte
displacement B. AS is set to the target architecture default address space
identifier. The required action is to define the current CFA rule to be the
result of evaluating the DWARF operation expression <code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span> <span class="pre">AS;</span>
<span class="pre">DW_OP_aspace_bregx</span> <span class="pre">R,</span> <span class="pre">B*data_alignment_factor</span></code> as a location description.</p>
<p><em>The action is the same as</em> <code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa</span></code> <em>except that the second
operand is signed and factored.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_def_aspace_cfa</span></code> <em>New</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_def_aspace_cfa</span></code> instruction takes three unsigned LEB128
operands representing a register number R, a (non-factored) byte
displacement B, and a target architecture specific address space identifier
AS. The required action is to define the current CFA rule to be the result
of evaluating the DWARF operation expression <code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span> <span class="pre">AS;</span>
<span class="pre">DW_OP_aspace_bregx</span> <span class="pre">R,</span> <span class="pre">B</span></code> as a location description.</p>
<p>If AS is not one of the values defined by the target architecture specific
<code class="docutils literal notranslate"><span class="pre">DW_ASPACE_*</span></code> values then the DWARF expression is ill-formed.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_def_aspace_cfa_sf</span></code> <em>New</em></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_sf</span></code> instruction takes three operands: an unsigned
LEB128 value representing a register number R, a signed LEB128 factored byte
displacement B, and an unsigned LEB128 value representing a target
architecture specific address space identifier AS. The required action is to
define the current CFA rule to be the result of evaluating the DWARF
operation expression <code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span> <span class="pre">AS;</span> <span class="pre">DW_OP_aspace_bregx</span> <span class="pre">R,</span>
<span class="pre">B*data_alignment_factor</span></code> as a location description.</p>
<p>If AS is not one of the values defined by the target architecture specific
<code class="docutils literal notranslate"><span class="pre">DW_ASPACE_*</span></code> values, then the DWARF expression is ill-formed.</p>
<p><em>The action is the same as</em> <code class="docutils literal notranslate"><span class="pre">DW_CFA_aspace_def_cfa</span></code> <em>except that the
second operand is signed and factored.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_register</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_register</span></code> instruction takes a single unsigned LEB128
operand representing a register number R. The required action is to define
the current CFA rule to be the result of evaluating the DWARF operation
expression <code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span> <span class="pre">AS;</span> <span class="pre">DW_OP_aspace_bregx</span> <span class="pre">R,</span> <span class="pre">B</span></code> as a location
description. B and AS are the old CFA byte displacement and address space
respectively.</p>
<p>If the subprogram has no current CFA rule, or the rule was defined by a
<code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_expression</span></code> instruction, then the DWARF is ill-formed.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_offset</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_offset</span></code> instruction takes a single unsigned LEB128
operand representing a (non-factored) byte displacement B. The required
action is to define the current CFA rule to be the result of evaluating the
DWARF operation expression <code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span> <span class="pre">AS;</span> <span class="pre">DW_OP_aspace_bregx</span> <span class="pre">R,</span> <span class="pre">B</span></code> as a
location description. R and AS are the old CFA register number and address
space respectively.</p>
<p>If the subprogram has no current CFA rule, or the rule was defined by a
<code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_expression</span></code> instruction, then the DWARF is ill-formed.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_offset_sf</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_offset_sf</span></code> instruction takes a signed LEB128 operand
representing a factored byte displacement B. The required action is to
define the current CFA rule to be the result of evaluating the DWARF
operation expression <code class="docutils literal notranslate"><span class="pre">DW_OP_constu</span> <span class="pre">AS;</span> <span class="pre">DW_OP_aspace_bregx</span> <span class="pre">R,</span>
<span class="pre">B*data_alignment_factor</span></code> as a location description. R and AS are the old
CFA register number and address space respectively.</p>
<p>If the subprogram has no current CFA rule, or the rule was defined by a
<code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_expression</span></code> instruction, then the DWARF is ill-formed.</p>
<p><em>The action is the same as</em> <code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_offset</span></code> <em>except that the
operand is signed and factored.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_expression</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_def_cfa_expression</span></code> instruction takes a single operand encoded
as a <code class="docutils literal notranslate"><span class="pre">DW_FORM_exprloc</span></code> value representing a DWARF operation expression E.
The required action is to define the current CFA rule to be the result of
evaluating E as a location description in the context of the current
subprogram, current program location, and an empty initial stack.</p>
<p><em>See</em> <a class="reference internal" href="#amdgpu-dwarf-call-frame-instructions"><span class="std std-ref">Call Frame Instructions</span></a> <em>regarding restrictions on
the DWARF expression operations that can be used in E.</em></p>
<p>The DWARF is ill-formed if the result of evaluating E is not a memory byte
address location description.</p>
</li>
</ol>
</div>
<div class="section" id="register-rule-instructions">
<span id="amdgpu-dwarf-register-rule-instructions"></span><h6><a class="toc-backref" href="#id44">Register Rule Instructions</a><a class="headerlink" href="#register-rule-instructions" title="Permalink to this headline">¶</a></h6>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_undefined</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_undefined</span></code> instruction takes a single unsigned LEB128 operand
that represents a register number R. The required action is to set the rule
for the register specified by R to <code class="docutils literal notranslate"><span class="pre">undefined</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_same_value</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_same_value</span></code> instruction takes a single unsigned LEB128 operand
that represents a register number R. The required action is to set the rule
for the register specified by R to <code class="docutils literal notranslate"><span class="pre">same</span> <span class="pre">value</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_offset</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_offset</span></code> instruction takes two operands: a register number R
(encoded with the opcode) and an unsigned LEB128 constant representing a
factored displacement B. The required action is to change the rule for the
register specified by R to be an <em>offset(B*data_alignment_factor)</em> rule.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Seems this should be named <code class="docutils literal notranslate"><span class="pre">DW_CFA_offset_uf</span></code> since the offset is
unsigned factored.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_offset_extended</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_offset_extended</span></code> instruction takes two unsigned LEB128
operands representing a register number R and a factored displacement B.
This instruction is identical to <code class="docutils literal notranslate"><span class="pre">DW_CFA_offset</span></code> except for the encoding
and size of the register operand.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Seems this should be named <code class="docutils literal notranslate"><span class="pre">DW_CFA_offset_extended_uf</span></code> since the
displacement is unsigned factored.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_offset_extended_sf</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_offset_extended_sf</span></code> instruction takes two operands: an
unsigned LEB128 value representing a register number R and a signed LEB128
factored displacement B. This instruction is identical to
<code class="docutils literal notranslate"><span class="pre">DW_CFA_offset_extended</span></code> except that B is signed.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_val_offset</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_val_offset</span></code> instruction takes two unsigned LEB128 operands
representing a register number R and a factored displacement B. The required
action is to change the rule for the register indicated by R to be a
<em>val_offset(B*data_alignment_factor)</em> rule.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Seems this should be named <code class="docutils literal notranslate"><span class="pre">DW_CFA_val_offset_uf</span></code> since the displacement
is unsigned factored.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An alternative is to define <code class="docutils literal notranslate"><span class="pre">DW_CFA_val_offset</span></code> to implicitly use the
target architecture default address space, and add another operation that
specifies the address space.</p>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_val_offset_sf</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_val_offset_sf</span></code> instruction takes two operands: an unsigned
LEB128 value representing a register number R and a signed LEB128 factored
displacement B. This instruction is identical to <code class="docutils literal notranslate"><span class="pre">DW_CFA_val_offset</span></code>
except that B is signed.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_register</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_register</span></code> instruction takes two unsigned LEB128 operands
representing register numbers R1 and R2 respectively. The required action is
to set the rule for the register specified by R1 to be a <em>register(R2)</em> rule.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_expression</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_expression</span></code> instruction takes two operands: an unsigned LEB128
value representing a register number R, and a <code class="docutils literal notranslate"><span class="pre">DW_FORM_block</span></code> value
representing a DWARF operation expression E. The required action is to
change the rule for the register specified by R to be an <em>expression(E)</em>
rule.</p>
<p><em>That is, E computes the location description where the register value can
be retrieved.</em></p>
<p><em>See</em> <a class="reference internal" href="#amdgpu-dwarf-call-frame-instructions"><span class="std std-ref">Call Frame Instructions</span></a> <em>regarding restrictions on
the DWARF expression operations that can be used in E.</em></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_val_expression</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_val_expression</span></code> instruction takes two operands: an unsigned
LEB128 value representing a register number R, and a <code class="docutils literal notranslate"><span class="pre">DW_FORM_block</span></code> value
representing a DWARF operation expression E. The required action is to
change the rule for the register specified by R to be a <em>val_expression(E)</em>
rule.</p>
<p><em>That is, E computes the value of register R.</em></p>
<p><em>See</em> <a class="reference internal" href="#amdgpu-dwarf-call-frame-instructions"><span class="std std-ref">Call Frame Instructions</span></a> <em>regarding restrictions on
the DWARF expression operations that can be used in E.</em></p>
<p>If the result of evaluating E is not a value with a base type size that
matches the register size, then the DWARF is ill-formed.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_restore</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_restore</span></code> instruction takes a single operand (encoded with the
opcode) that represents a register number R. The required action is to
change the rule for the register specified by R to the rule assigned it by
the <code class="docutils literal notranslate"><span class="pre">initial_instructions</span></code> in the CIE.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_CFA_restore_extended</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">DW_CFA_restore_extended</span></code> instruction takes a single unsigned LEB128
operand that represents a register number R. This instruction is identical
to <code class="docutils literal notranslate"><span class="pre">DW_CFA_restore</span></code> except for the encoding and size of the register
operand.</p>
</li>
</ol>
</div>
<div class="section" id="row-state-instructions">
<h6><a class="toc-backref" href="#id45">Row State Instructions</a><a class="headerlink" href="#row-state-instructions" title="Permalink to this headline">¶</a></h6>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These instructions are the same as in DWARF Version 5 section 6.4.2.4.</p>
</div>
</div>
<div class="section" id="padding-instruction">
<h6><a class="toc-backref" href="#id46">Padding Instruction</a><a class="headerlink" href="#padding-instruction" title="Permalink to this headline">¶</a></h6>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These instructions are the same as in DWARF Version 5 section 6.4.2.5.</p>
</div>
</div>
</div>
<div class="section" id="call-frame-instruction-usage">
<h5><a class="toc-backref" href="#id47">Call Frame Instruction Usage</a><a class="headerlink" href="#call-frame-instruction-usage" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The same as in DWARF Version 5 section 6.4.3.</p>
</div>
</div>
<div class="section" id="call-frame-calling-address">
<span id="amdgpu-dwarf-call-frame-calling-address"></span><h5><a class="toc-backref" href="#id48">Call Frame Calling Address</a><a class="headerlink" href="#call-frame-calling-address" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The same as in DWARF Version 5 section 6.4.4.</p>
</div>
</div>
</div>
</div>
<div class="section" id="data-representation">
<h3><a class="toc-backref" href="#id49">Data Representation</a><a class="headerlink" href="#data-representation" title="Permalink to this headline">¶</a></h3>
<div class="section" id="bit-and-64-bit-dwarf-formats">
<span id="amdgpu-dwarf-32-bit-and-64-bit-dwarf-formats"></span><h4><a class="toc-backref" href="#id50">32-Bit and 64-Bit DWARF Formats</a><a class="headerlink" href="#bit-and-64-bit-dwarf-formats" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This augments DWARF Version 5 section 7.4.</p>
</div>
<ol class="arabic">
<li><p>Within the body of the <code class="docutils literal notranslate"><span class="pre">.debug_info</span></code> section, certain forms of attribute
value depend on the choice of DWARF format as follows. For the 32-bit DWARF
format, the value is a 4-byte unsigned integer; for the 64-bit DWARF format,
the value is an 8-byte unsigned integer.</p>
<table class="docutils align-default" id="amdgpu-dwarf-debug-info-section-attribute-form-roles-table">
<caption><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">.debug_info</span></code> section attribute form roles</span><a class="headerlink" href="#amdgpu-dwarf-debug-info-section-attribute-form-roles-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 49%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Form</p></th>
<th class="head"><p>Role</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>DW_FORM_line_strp</p></td>
<td><p>offset in <code class="docutils literal notranslate"><span class="pre">.debug_line_str</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>DW_FORM_ref_addr</p></td>
<td><p>offset in <code class="docutils literal notranslate"><span class="pre">.debug_info</span></code></p></td>
</tr>
<tr class="row-even"><td><p>DW_FORM_sec_offset</p></td>
<td><p>offset in a section other than
<code class="docutils literal notranslate"><span class="pre">.debug_info</span></code> or <code class="docutils literal notranslate"><span class="pre">.debug_str</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>DW_FORM_strp</p></td>
<td><p>offset in <code class="docutils literal notranslate"><span class="pre">.debug_str</span></code></p></td>
</tr>
<tr class="row-even"><td><p>DW_FORM_strp_sup</p></td>
<td><p>offset in <code class="docutils literal notranslate"><span class="pre">.debug_str</span></code> section of
supplementary object file</p></td>
</tr>
<tr class="row-odd"><td><p>DW_OP_call_ref</p></td>
<td><p>offset in <code class="docutils literal notranslate"><span class="pre">.debug_info</span></code></p></td>
</tr>
<tr class="row-even"><td><p>DW_OP_implicit_pointer</p></td>
<td><p>offset in <code class="docutils literal notranslate"><span class="pre">.debug_info</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>DW_OP_LLVM_aspace_implicit_pointer</p></td>
<td><p>offset in <code class="docutils literal notranslate"><span class="pre">.debug_info</span></code></p></td>
</tr>
</tbody>
</table>
</li>
</ol>
</div>
<div class="section" id="format-of-debugging-information">
<h4><a class="toc-backref" href="#id51">Format of Debugging Information</a><a class="headerlink" href="#format-of-debugging-information" title="Permalink to this headline">¶</a></h4>
<div class="section" id="attribute-encodings">
<h5><a class="toc-backref" href="#id52">Attribute Encodings</a><a class="headerlink" href="#attribute-encodings" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This augments DWARF Version 5 section 7.5.4 and Table 7.5.</p>
</div>
<p>The following table gives the encoding of the additional debugging information
entry attributes.</p>
<table class="docutils align-default" id="amdgpu-dwarf-attribute-encodings-table">
<caption><span class="caption-text">Attribute encodings</span><a class="headerlink" href="#amdgpu-dwarf-attribute-encodings-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 45%" />
<col style="width: 8%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Attribute Name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Classes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>DW_AT_LLVM_active_lane</p></td>
<td><p>0x3e08</p></td>
<td><p>exprloc, loclist</p></td>
</tr>
<tr class="row-odd"><td><p>DW_AT_LLVM_augmentation</p></td>
<td><p>0x3e09</p></td>
<td><p>string</p></td>
</tr>
<tr class="row-even"><td><p>DW_AT_LLVM_lanes</p></td>
<td><p>0x3e0a</p></td>
<td><p>constant</p></td>
</tr>
<tr class="row-odd"><td><p>DW_AT_LLVM_lane_pc</p></td>
<td><p>0x3e0b</p></td>
<td><p>exprloc, loclist</p></td>
</tr>
<tr class="row-even"><td><p>DW_AT_LLVM_vector_size</p></td>
<td><p>0x3e0c</p></td>
<td><p>constant</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id1">
<h4><a class="toc-backref" href="#id53">DWARF Expressions</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Rename DWARF Version 5 section 7.7 to reflect the unification of location
descriptions into DWARF expressions.</p>
</div>
<div class="section" id="operation-expressions">
<h5><a class="toc-backref" href="#id54">Operation Expressions</a><a class="headerlink" href="#operation-expressions" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Rename DWARF Version 5 section 7.7.1 and delete section 7.7.2 to reflect the
unification of location descriptions into DWARF expressions.</p>
<p>This augments DWARF Version 5 section 7.7.1 and Table 7.9.</p>
</div>
<p>The following table gives the encoding of the additional DWARF expression
operations.</p>
<table class="docutils align-default" id="amdgpu-dwarf-operation-encodings-table">
<caption><span class="caption-text">DWARF Operation Encodings</span><a class="headerlink" href="#amdgpu-dwarf-operation-encodings-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 44%" />
<col style="width: 6%" />
<col style="width: 10%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operation</p></th>
<th class="head"><p>Code</p></th>
<th class="head"><p>Number
of
Operands</p></th>
<th class="head"><p>Notes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>DW_OP_LLVM_form_aspace_address</p></td>
<td><p>0xe1</p></td>
<td><p>0</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>DW_OP_LLVM_push_lane</p></td>
<td><p>0xe2</p></td>
<td><p>0</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>DW_OP_LLVM_offset</p></td>
<td><p>0xe3</p></td>
<td><p>0</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>DW_OP_LLVM_offset_uconst</p></td>
<td><p>0xe4</p></td>
<td><p>1</p></td>
<td><p>ULEB128 byte displacement</p></td>
</tr>
<tr class="row-even"><td><p>DW_OP_LLVM_bit_offset</p></td>
<td><p>0xe5</p></td>
<td><p>0</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>DW_OP_LLVM_call_frame_entry_reg</p></td>
<td><p>0xe6</p></td>
<td><p>1</p></td>
<td><p>ULEB128 register number</p></td>
</tr>
<tr class="row-even"><td><p>DW_OP_LLVM_undefined</p></td>
<td><p>0xe7</p></td>
<td><p>0</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>DW_OP_LLVM_aspace_bregx</p></td>
<td><p>0xe8</p></td>
<td><p>2</p></td>
<td><p>ULEB128 register number,
ULEB128 byte displacement</p></td>
</tr>
<tr class="row-even"><td><p>DW_OP_LLVM_aspace_implicit_pointer</p></td>
<td><p>0xe9</p></td>
<td><p>2</p></td>
<td><p>4- or 8-byte offset of DIE,
SLEB128 byte displacement</p></td>
</tr>
<tr class="row-odd"><td><p>DW_OP_LLVM_piece_end</p></td>
<td><p>0xea</p></td>
<td><p>0</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>DW_OP_LLVM_extend</p></td>
<td><p>0xeb</p></td>
<td><p>2</p></td>
<td><p>ULEB128 bit size,
ULEB128 count</p></td>
</tr>
<tr class="row-odd"><td><p>DW_OP_LLVM_select_bit_piece</p></td>
<td><p>0xec</p></td>
<td><p>2</p></td>
<td><p>ULEB128 bit size,
ULEB128 count</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="location-list-expressions">
<h5><a class="toc-backref" href="#id55">Location List Expressions</a><a class="headerlink" href="#location-list-expressions" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Rename DWARF Version 5 section 7.7.3 to reflect that location lists are a kind
of DWARF expression.</p>
</div>
</div>
</div>
<div class="section" id="source-languages">
<h4><a class="toc-backref" href="#id56">Source Languages</a><a class="headerlink" href="#source-languages" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This augments DWARF Version 5 section 7.12 and Table 7.17.</p>
</div>
<p>The following table gives the encoding of the additional DWARF languages.</p>
<table class="docutils align-default" id="amdgpu-dwarf-language-encodings-table">
<caption><span class="caption-text">Language encodings</span><a class="headerlink" href="#amdgpu-dwarf-language-encodings-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 44%" />
<col style="width: 13%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Language Name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Default Lower Bound</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_LANG_LLVM_HIP</span></code></p></td>
<td><p>0x8100</p></td>
<td><p>0</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="address-class-and-address-space-encodings">
<h4><a class="toc-backref" href="#id57">Address Class and Address Space Encodings</a><a class="headerlink" href="#address-class-and-address-space-encodings" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This replaces DWARF Version 5 section 7.13.</p>
</div>
<p>The encodings of the constants used for the currently defined address classes
are given in <a class="reference internal" href="#amdgpu-dwarf-address-class-encodings-table"><span class="std std-ref">Address class encodings</span></a>.</p>
<table class="docutils align-default" id="amdgpu-dwarf-address-class-encodings-table">
<caption><span class="caption-text">Address class encodings</span><a class="headerlink" href="#amdgpu-dwarf-address-class-encodings-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 81%" />
<col style="width: 19%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Address Class Name</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_none</span></code></p></td>
<td><p>0x0000</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_global</span></code></p></td>
<td><p>0x0001</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_constant</span></code></p></td>
<td><p>0x0002</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_group</span></code></p></td>
<td><p>0x0003</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_private</span></code></p></td>
<td><p>0x0004</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_lo_user</span></code></p></td>
<td><p>0x8000</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_ADDR_LLVM_hi_user</span></code></p></td>
<td><p>0xffff</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id2">
<h4><a class="toc-backref" href="#id58">Line Number Information</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This augments DWARF Version 5 section 7.22 and Table 7.27.</p>
</div>
<p>The following table gives the encoding of the additional line number header
entry formats.</p>
<table class="docutils align-default" id="amdgpu-dwarf-line-number-header-entry-format-encodings-table">
<caption><span class="caption-text">Line number header entry format encodings</span><a class="headerlink" href="#amdgpu-dwarf-line-number-header-entry-format-encodings-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 64%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Line number header entry format name</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_LNCT_LLVM_source</span></code></p></td>
<td><p>0x2001</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_LNCT_LLVM_is_MD5</span></code></p></td>
<td><p>0x2002</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id3">
<h4><a class="toc-backref" href="#id59">Call Frame Information</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This augments DWARF Version 5 section 7.24 and Table 7.29.</p>
</div>
<p>The following table gives the encoding of the additional call frame information
instructions.</p>
<table class="docutils align-default" id="amdgpu-dwarf-call-frame-instruction-encodings-table">
<caption><span class="caption-text">Call frame instruction encodings</span><a class="headerlink" href="#amdgpu-dwarf-call-frame-instruction-encodings-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 27%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 18%" />
<col style="width: 18%" />
<col style="width: 24%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Instruction</p></th>
<th class="head"><p>High 2
Bits</p></th>
<th class="head"><p>Low 6
Bits</p></th>
<th class="head"><p>Operand 1</p></th>
<th class="head"><p>Operand 2</p></th>
<th class="head"><p>Operand 3</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>DW_CFA_def_aspace_cfa</p></td>
<td><p>0</p></td>
<td><p>0x30</p></td>
<td><p>ULEB128 register</p></td>
<td><p>ULEB128 offset</p></td>
<td><p>ULEB128 address space</p></td>
</tr>
<tr class="row-odd"><td><p>DW_CFA_def_aspace_cfa_sf</p></td>
<td><p>0</p></td>
<td><p>0x31</p></td>
<td><p>ULEB128 register</p></td>
<td><p>SLEB128 offset</p></td>
<td><p>ULEB128 address space</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="attributes-by-tag-value-informative">
<h3><a class="toc-backref" href="#id60">Attributes by Tag Value (Informative)</a><a class="headerlink" href="#attributes-by-tag-value-informative" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This augments DWARF Version 5 Appendix A and Table A.1.</p>
</div>
<p>The following table provides the additional attributes that are applicable to
debugger information entries.</p>
<table class="docutils align-default" id="amdgpu-dwarf-attributes-by-tag-value-table">
<caption><span class="caption-text">Attributes by tag value</span><a class="headerlink" href="#amdgpu-dwarf-attributes-by-tag-value-table" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Tag Name</p></th>
<th class="head"><p>Applicable Attributes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_TAG_base_type</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_vector_size</span></code></p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_TAG_compile_unit</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_augmentation</span></code></p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_TAG_entry_point</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_active_lane</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lanes</span></code></p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DW_TAG_inlined_subroutine</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_active_lane</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lanes</span></code></p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DW_TAG_subprogram</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_active_lane</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lane_pc</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DW_AT_LLVM_lanes</span></code></p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="examples">
<span id="amdgpu-dwarf-examples"></span><h2><a class="toc-backref" href="#id61">Examples</a><a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>The AMD GPU specific usage of the features in the proposal, including examples,
is available at <a class="reference internal" href="AMDGPUUsage.html#amdgpu-dwarf-debug-information"><span class="std std-ref">DWARF Debug Information</span></a>.</p>
</div>
<div class="section" id="references">
<span id="amdgpu-dwarf-references"></span><h2><a class="toc-backref" href="#id62">References</a><a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div></div></blockquote>
<ol class="arabic simple" id="amdgpu-dwarf-amd">
<li><p>[AMD] <a class="reference external" href="https://www.amd.com/">Advanced Micro Devices</a></p>
</li>
<li id="amdgpu-dwarf-amd-rocm"><p>[AMD-ROCm] <a class="reference external" href="https://rocm-documentation.readthedocs.io">AMD ROCm Platform</a></p>
</li>
<li id="amdgpu-dwarf-amd-rocgdb"><p>[AMD-ROCgdb] <a class="reference external" href="https://github.com/ROCm-Developer-Tools/ROCgdb">AMD ROCm Debugger (ROCgdb)</a></p>
</li>
<li id="amdgpu-dwarf-amdgpu-llvm"><p>[AMDGPU-LLVM] <a class="reference external" href="https://llvm.org/docs/AMDGPUUsage.html">User Guide for AMDGPU LLVM Backend</a></p>
</li>
<li id="amdgpu-dwarf-cuda"><p>[CUDA] <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/">Nvidia CUDA Language</a></p>
</li>
<li id="amdgpu-dwarf-dwarf"><p>[DWARF] <a class="reference external" href="http://dwarfstd.org/">DWARF Debugging Information Format</a></p>
</li>
<li id="amdgpu-dwarf-elf"><p>[ELF] <a class="reference external" href="http://www.sco.com/developers/gabi/">Executable and Linkable Format (ELF)</a></p>
</li>
<li id="amdgpu-dwarf-gcc"><p>[GCC] <a class="reference external" href="https://www.gnu.org/software/gcc/">GCC: The GNU Compiler Collection</a></p>
</li>
<li id="amdgpu-dwarf-gdb"><p>[GDB] <a class="reference external" href="https://www.gnu.org/software/gdb/">GDB: The GNU Project Debugger</a></p>
</li>
<li id="amdgpu-dwarf-hip"><p>[HIP] <a class="reference external" href="https://rocm-documentation.readthedocs.io/en/latest/Programming_Guides/Programming-Guides.html#hip-programing-guide">HIP Programming Guide</a></p>
</li>
<li id="amdgpu-dwarf-hsa"><p>[HSA] <a class="reference external" href="http://www.hsafoundation.com/">Heterogeneous System Architecture (HSA) Foundation</a></p>
</li>
<li id="amdgpu-dwarf-llvm"><p>[LLVM] <a class="reference external" href="https://llvm.org/">The LLVM Compiler Infrastructure</a></p>
</li>
<li id="amdgpu-dwarf-opencl"><p>[OpenCL] <a class="reference external" href="http://www.khronos.org/registry/cl/specs/opencl-2.0.pdf">The OpenCL Specification Version 2.0</a></p>
</li>
<li id="amdgpu-dwarf-perforce-totalview"><p>[Perforce-TotalView] <a class="reference external" href="https://totalview.io/products/totalview">Perforce TotalView HPC Debugging Software</a></p>
</li>
<li id="amdgpu-dwarf-semver"><p>[SEMVER] <a class="reference external" href="https://semver.org/">Semantic Versioning</a></p></li>
</ol>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="Benchmarking.html" title="Benchmarking tips"
             >next</a> |</li>
        <li class="right" >
          <a href="AMDGPUInstructionNotation.html" title="AMDGPU Instructions Notation"
             >previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" >User Guides</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="AMDGPUUsage.html" >User Guide for AMDGPU Backend</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2003-2020, LLVM Project.
      Last updated on 2020-10-12.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.3.
    </div>
  </body>
</html>