<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Pointer Authentication &#8212; Clang 21.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=e491ac2d" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=eafc0fe6" />
    <script src="_static/documentation_options.js?v=c54a4614"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Matrix Types" href="MatrixTypes.html" />
    <link rel="prev" title="Objective-C Automatic Reference Counting (ARC)" href="AutomaticReferenceCounting.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Clang 21.1.0 documentation</span></a></h1>
        <h2 class="heading"><span>Pointer Authentication</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="AutomaticReferenceCounting.html">Objective-C Automatic Reference Counting (ARC)</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="MatrixTypes.html">Matrix Types</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="pointer-authentication">
<h1>Pointer Authentication<a class="headerlink" href="#pointer-authentication" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id8">Introduction</a></p></li>
<li><p><a class="reference internal" href="#basic-concepts" id="id9">Basic concepts</a></p>
<ul>
<li><p><a class="reference internal" href="#discriminators" id="id10">Discriminators</a></p></li>
<li><p><a class="reference internal" href="#signing-schemas" id="id11">Signing schemas</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#language-features" id="id12">Language features</a></p>
<ul>
<li><p><a class="reference internal" href="#language-implementation" id="id13">Language implementation</a></p>
<ul>
<li><p><a class="reference internal" href="#c-data-pointers" id="id14">C data pointers</a></p></li>
<li><p><a class="reference internal" href="#c-function-pointers" id="id15">C function pointers</a></p></li>
<li><p><a class="reference internal" href="#null-pointers" id="id16">Null pointers</a></p></li>
<li><p><a class="reference internal" href="#return-addresses" id="id17">Return addresses</a></p></li>
<li><p><a class="reference internal" href="#c-virtual-functions" id="id18">C++ virtual functions</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#language-extensions" id="id19">Language extensions</a></p>
<ul>
<li><p><a class="reference internal" href="#feature-testing" id="id20">Feature testing</a></p></li>
<li><p><a class="reference internal" href="#ptrauth-qualifier" id="id21"><code class="docutils literal notranslate"><span class="pre">__ptrauth</span></code> qualifier</a></p>
<ul>
<li><p><a class="reference internal" href="#non-triviality-from-address-diversity" id="id22">Non-triviality from address diversity</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#ptrauth-h" id="id23"><code class="docutils literal notranslate"><span class="pre">&lt;ptrauth.h&gt;</span></code></a></p>
<ul>
<li><p><a class="reference internal" href="#ptrauth-key" id="id24"><code class="docutils literal notranslate"><span class="pre">ptrauth_key</span></code></a></p></li>
<li><p><a class="reference internal" href="#ptrauth-extra-data-t" id="id25"><code class="docutils literal notranslate"><span class="pre">ptrauth_extra_data_t</span></code></a></p></li>
<li><p><a class="reference internal" href="#ptrauth-blend-discriminator" id="id26"><code class="docutils literal notranslate"><span class="pre">ptrauth_blend_discriminator</span></code></a></p></li>
<li><p><a class="reference internal" href="#ptrauth-string-discriminator" id="id27"><code class="docutils literal notranslate"><span class="pre">ptrauth_string_discriminator</span></code></a></p></li>
<li><p><a class="reference internal" href="#ptrauth-strip" id="id28"><code class="docutils literal notranslate"><span class="pre">ptrauth_strip</span></code></a></p></li>
<li><p><a class="reference internal" href="#ptrauth-sign-constant" id="id29"><code class="docutils literal notranslate"><span class="pre">ptrauth_sign_constant</span></code></a></p></li>
<li><p><a class="reference internal" href="#ptrauth-sign-unauthenticated" id="id30"><code class="docutils literal notranslate"><span class="pre">ptrauth_sign_unauthenticated</span></code></a></p></li>
<li><p><a class="reference internal" href="#ptrauth-auth-and-resign" id="id31"><code class="docutils literal notranslate"><span class="pre">ptrauth_auth_and_resign</span></code></a></p></li>
<li><p><a class="reference internal" href="#ptrauth-auth-function" id="id32"><code class="docutils literal notranslate"><span class="pre">ptrauth_auth_function</span></code></a></p></li>
<li><p><a class="reference internal" href="#ptrauth-auth-data" id="id33"><code class="docutils literal notranslate"><span class="pre">ptrauth_auth_data</span></code></a></p></li>
<li><p><a class="reference internal" href="#ptrauth-sign-generic-data" id="id34"><code class="docutils literal notranslate"><span class="pre">ptrauth_sign_generic_data</span></code></a></p></li>
<li><p><a class="reference internal" href="#standard-ptrauth-qualifiers" id="id35">Standard <code class="docutils literal notranslate"><span class="pre">__ptrauth</span></code> qualifiers</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#theory-of-operation" id="id36">Theory of operation</a></p>
<ul>
<li><p><a class="reference internal" href="#attacks-on-pointer-authentication" id="id37">Attacks on pointer authentication</a></p>
<ul>
<li><p><a class="reference internal" href="#attacks-of-interest-to-programmers" id="id38">Attacks of interest to programmers</a></p>
<ul>
<li><p><a class="reference internal" href="#substitution-attacks" id="id39">Substitution attacks</a></p></li>
<li><p><a class="reference internal" href="#access-path-attacks" id="id40">Access path attacks</a></p></li>
<li><p><a class="reference internal" href="#signing-oracles" id="id41">Signing oracles</a></p></li>
<li><p><a class="reference internal" href="#authentication-oracles" id="id42">Authentication oracles</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#attacks-of-interest-to-implementors" id="id43">Attacks of interest to implementors</a></p>
<ul>
<li><p><a class="reference internal" href="#failure-to-trap-on-authentication-failure" id="id44">Failure to trap on authentication failure</a></p></li>
<li><p><a class="reference internal" href="#attackable-code-sequences" id="id45">Attackable code sequences</a></p></li>
<li><p><a class="reference internal" href="#register-clobbering" id="id46">Register clobbering</a></p></li>
<li><p><a class="reference internal" href="#attacks-on-relative-addressing" id="id47">Attacks on relative addressing</a></p></li>
<li><p><a class="reference internal" href="#signature-forging" id="id48">Signature forging</a></p></li>
<li><p><a class="reference internal" href="#remapping" id="id49">Remapping</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#safe-derivation" id="id50">Safe derivation</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#language-abi" id="id51">Language ABI</a></p>
<ul>
<li><p><a class="reference internal" href="#key-assignments" id="id52">Key assignments</a></p></li>
<li><p><a class="reference internal" href="#implementation-defined-algorithms-and-quantities" id="id53">Implementation-defined algorithms and quantities</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id54">Return addresses</a></p></li>
<li><p><a class="reference internal" href="#global-offset-tables" id="id55">Global offset tables</a></p></li>
<li><p><a class="reference internal" href="#dynamic-symbol-lookup" id="id56">Dynamic symbol lookup</a></p></li>
<li><p><a class="reference internal" href="#c-function-abi" id="id57">C function pointers</a></p></li>
<li><p><a class="reference internal" href="#c-virtual-tables" id="id58">C++ virtual tables</a></p></li>
<li><p><a class="reference internal" href="#c-dynamic-cast" id="id59">C++ dynamic_cast</a></p></li>
<li><p><a class="reference internal" href="#c-std-type-info-v-table-pointers" id="id60">C++ std::type_info v-table pointers</a></p></li>
<li><p><a class="reference internal" href="#c-member-function-pointers" id="id61">C++ member function pointers</a></p></li>
<li><p><a class="reference internal" href="#c-mangling" id="id62">C++ mangling</a></p></li>
<li><p><a class="reference internal" href="#blocks" id="id63">Blocks</a></p></li>
<li><p><a class="reference internal" href="#objective-c-runtime" id="id64">Objective-C runtime</a></p></li>
<li><p><a class="reference internal" href="#objective-c-methods" id="id65">Objective-C methods</a></p></li>
<li><p><a class="reference internal" href="#objective-c-class-method-list-pointer" id="id66">Objective-C class method list pointer</a></p></li>
<li><p><a class="reference internal" href="#objective-c-class-read-only-data-pointer" id="id67">Objective-C class read-only data pointer</a></p></li>
<li><p><a class="reference internal" href="#objective-c-isa-and-super-pointers" id="id68">Objective-C <code class="docutils literal notranslate"><span class="pre">isa</span></code> and <code class="docutils literal notranslate"><span class="pre">super</span></code> pointers</a></p></li>
<li><p><a class="reference internal" href="#objective-c-sel-pointers" id="id69">Objective-C <code class="docutils literal notranslate"><span class="pre">SEL</span></code> pointers</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#alternative-implementations" id="id70">Alternative implementations</a></p>
<ul>
<li><p><a class="reference internal" href="#signature-storage" id="id71">Signature storage</a></p></li>
<li><p><a class="reference internal" href="#hashing-vs-encrypting-pointers" id="id72">Hashing vs. encrypting pointers</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>Pointer authentication is a technology which offers strong probabilistic
protection against exploiting a broad class of memory bugs to take control of
program execution.  When adopted consistently in a language ABI, it provides
a form of relatively fine-grained control flow integrity (CFI) check that
resists both return-oriented programming (ROP) and jump-oriented programming
(JOP) attacks.</p>
<p>While pointer authentication can be implemented purely in software, direct
hardware support (e.g. as provided by Armv8.3 PAuth) can dramatically improve
performance and code size.  Similarly, while pointer authentication
can be implemented on any architecture, taking advantage of the (typically)
excess addressing range of a target with 64-bit pointers minimizes the impact
on memory performance and can allow interoperation with existing code (by
disabling pointer authentication dynamically).  This document will generally
attempt to present the pointer authentication feature independent of any
hardware implementation or ABI.  Considerations that are
implementation-specific are clearly identified throughout.</p>
<p>Note that there are several different terms in use:</p>
<ul class="simple">
<li><p><strong>Pointer authentication</strong> is a target-independent language technology.</p></li>
<li><p><strong>PAuth</strong> (sometimes referred to as <strong>PAC</strong>, for Pointer Authentication
Codes) is an AArch64 architecture extension that provides hardware support
for pointer authentication.  Additional extensions either modify some of the
PAuth instruction behavior (notably FPAC), or provide new instruction
variants (PAuth_LR).</p></li>
<li><p><strong>Armv8.3</strong> is an AArch64 architecture revision that makes PAuth mandatory.</p></li>
<li><p><strong>arm64e</strong> is a specific ABI (not yet fully stable) for implementing pointer
authentication using PAuth on certain Apple operating systems.</p></li>
</ul>
<p>This document serves four purposes:</p>
<ul class="simple">
<li><p>It describes the basic ideas of pointer authentication.</p></li>
<li><p>It documents several language extensions that are useful on targets using
pointer authentication.</p></li>
<li><p>It presents a theory of operation for the security mitigation, describing the
basic requirements for correctness, various weaknesses in the mechanism, and
ways in which programmers can strengthen its protections (including
recommendations for language implementors).</p></li>
<li><p>It documents the stable ABI of the C, C++, and Objective-C languages on arm64e
platforms.</p></li>
</ul>
</section>
<section id="basic-concepts">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">Basic concepts</a><a class="headerlink" href="#basic-concepts" title="Link to this heading">¶</a></h2>
<p>The simple address of an object or function is a <strong>raw pointer</strong>.  A raw
pointer can be <strong>signed</strong> to produce a <strong>signed pointer</strong>.  A signed pointer
can be then <strong>authenticated</strong> in order to verify that it was <strong>validly signed</strong>
and extract the original raw pointer.  These terms reflect the most likely
implementation technique: computing and storing a cryptographic signature along
with the pointer.</p>
<p>An <strong>abstract signing key</strong> is a name which refers to a secret key which is
used to sign and authenticate pointers.  The concrete key value for a
particular name is consistent throughout a process.</p>
<p>A <strong>discriminator</strong> is an arbitrary value used to <strong>diversify</strong> signed pointers
so that one validly-signed pointer cannot simply be copied over another.
A discriminator is simply opaque data of some implementation-defined size that
is included in the signature as a salt (see <a class="reference internal" href="#discriminators">Discriminators</a> for details.)</p>
<p>Nearly all aspects of pointer authentication use just these two primary
operations:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sign(raw_pointer,</span> <span class="pre">key,</span> <span class="pre">discriminator)</span></code> produces a signed pointer given
a raw pointer, an abstract signing key, and a discriminator.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">auth(signed_pointer,</span> <span class="pre">key,</span> <span class="pre">discriminator)</span></code> produces a raw pointer given
a signed pointer, an abstract signing key, and a discriminator.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">auth(sign(raw_pointer,</span> <span class="pre">key,</span> <span class="pre">discriminator),</span> <span class="pre">key,</span> <span class="pre">discriminator)</span></code> must
succeed and produce <code class="docutils literal notranslate"><span class="pre">raw_pointer</span></code>.  <code class="docutils literal notranslate"><span class="pre">auth</span></code> applied to a value that was
ultimately produced in any other way is expected to fail, which halts the
program either:</p>
<ul class="simple">
<li><p>immediately, on implementations that enforce <code class="docutils literal notranslate"><span class="pre">auth</span></code> success (e.g., when
using compiler-generated <code class="docutils literal notranslate"><span class="pre">auth</span></code> failure checks, or Armv8.3 with the FPAC
extension), or</p></li>
<li><p>when the resulting pointer value is used, on implementations that don’t.</p></li>
</ul>
<p>However, regardless of the implementation’s handling of <code class="docutils literal notranslate"><span class="pre">auth</span></code> failures, it
is permitted for <code class="docutils literal notranslate"><span class="pre">auth</span></code> to fail to detect that a signed pointer was not
produced in this way, in which case it may return anything; this is what makes
pointer authentication a probabilistic mitigation rather than a perfect one.</p>
<p>There are two secondary operations which are required only to implement certain
intrinsics in <code class="docutils literal notranslate"><span class="pre">&lt;ptrauth.h&gt;</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">strip(signed_pointer,</span> <span class="pre">key)</span></code> produces a raw pointer given a signed pointer
and a key without verifying its validity, unlike <code class="docutils literal notranslate"><span class="pre">auth</span></code>.  This is useful
for certain kinds of tooling, such as crash backtraces; it should generally
not be used in the basic language ABI except in very careful ways.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sign_generic(value)</span></code> produces a cryptographic signature for arbitrary
data, not necessarily a pointer.  This is useful for efficiently verifying
that non-pointer data has not been tampered with.</p></li>
</ul>
<p>Whenever any of these operations is called for, the key value must be known
statically.  This is because the layout of a signed pointer may vary according
to the signing key.  (For example, in Armv8.3, the layout of a signed pointer
depends on whether Top Byte Ignore (TBI) is enabled, which can be set
independently for I and D keys.)</p>
<div class="admonition-note-for-api-designers-and-language-implementors admonition">
<p class="admonition-title">Note for API designers and language implementors</p>
<p>These are the <em>primitive</em> operations of pointer authentication, provided for
clarity of description.  They are not suitable either as high-level
interfaces or as primitives in a compiler IR because they expose raw
pointers.  Raw pointers require special attention in the language
implementation to avoid the accidental creation of exploitable code
sequences; see the section on <a class="reference internal" href="#attackable-code-sequences">Attackable code sequences</a>.</p>
</div>
<p>The following details are all implementation-defined:</p>
<ul class="simple">
<li><p>the nature of a signed pointer</p></li>
<li><p>the size of a discriminator</p></li>
<li><p>the number and nature of the signing keys</p></li>
<li><p>the implementation of the <code class="docutils literal notranslate"><span class="pre">sign</span></code>, <code class="docutils literal notranslate"><span class="pre">auth</span></code>, <code class="docutils literal notranslate"><span class="pre">strip</span></code>, and <code class="docutils literal notranslate"><span class="pre">sign_generic</span></code>
operations</p></li>
</ul>
<p>While the use of the terms “sign” and “signed pointer” suggest the use of
a cryptographic signature, other implementations may be possible.  See
<a class="reference internal" href="#alternative-implementations">Alternative implementations</a> for an exploration of implementation options.</p>
<div class="admonition-implementation-example-armv8-3 admonition">
<p class="admonition-title">Implementation example: Armv8.3</p>
<p>Readers may find it helpful to know how these terms map to Armv8.3 PAuth:</p>
<ul class="simple">
<li><p>A signed pointer is a pointer with a signature stored in the
otherwise-unused high bits.  The kernel configures the address width based
on the system’s addressing needs, and enables TBI for I or D keys as
needed.  The bits above the address bits and below the TBI bits (if
enabled) are unused.  The signature width then depends on this addressing
configuration.</p></li>
<li><p>A discriminator is a 64-bit integer.  Constant discriminators are 16-bit
integers.  Blending a constant discriminator into an address consists of
replacing the top 16 bits of the pointer containing the address with the
constant.  Pointers used for blending purposes should only have address
bits, since higher bits will be at least partially overwritten with the
constant discriminator.</p></li>
<li><p>There are five 128-bit signing-key registers, each of which can only be
directly read or set by privileged code.  Of these, four are used for
signing pointers, and the fifth is used only for <code class="docutils literal notranslate"><span class="pre">sign_generic</span></code>.  The key
data is simply a pepper added to the hash, not an encryption key, and so
can be initialized using random data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sign</span></code> computes a cryptographic hash of the pointer, discriminator, and
signing key, and stores it in the high bits as the signature. <code class="docutils literal notranslate"><span class="pre">auth</span></code>
removes the signature, computes the same hash, and compares the result with
the stored signature.  <code class="docutils literal notranslate"><span class="pre">strip</span></code> removes the signature without
authenticating it.  The <code class="docutils literal notranslate"><span class="pre">aut</span></code> instructions in the baseline Armv8.3 PAuth
feature do not guarantee to trap on authentication failure; instead, they
simply corrupt the pointer so that later uses will likely trap. Unless the
“later use” follows immediately and cannot be recovered from (e.g. with a
signal handler), this does not provide adequate protection against
<a class="reference internal" href="#authentication-oracles">authentication oracles</a>, so implementations must emit additional
instructions to force an immediate trap. This is unnecessary if the
processor provides the optional <code class="docutils literal notranslate"><span class="pre">FPAC</span></code> extension, which guarantees an
immediate trap.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sign_generic</span></code> corresponds to the <code class="docutils literal notranslate"><span class="pre">pacga</span></code> instruction, which takes two
64-bit values and produces a 64-bit cryptographic hash. Implementations of
this instruction are not required to produce meaningful data in all bits of
the result.</p></li>
</ul>
</div>
<section id="discriminators">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Discriminators</a><a class="headerlink" href="#discriminators" title="Link to this heading">¶</a></h3>
<p>A discriminator is arbitrary extra data which alters the signature calculated
for a pointer.  When two pointers are signed differently — either with
different keys or with different discriminators — an attacker cannot simply
replace one pointer with the other.</p>
<p>To use standard cryptographic terminology, a discriminator acts as a
<a class="reference external" href="https://en.wikipedia.org/wiki/Salt_(cryptography)">salt</a> in the signing of a
pointer, and the key data acts as a
<a class="reference external" href="https://en.wikipedia.org/wiki/Pepper_(cryptography)">pepper</a>.  That is,
both the discriminator and key data are ultimately just added as inputs to the
signing algorithm along with the pointer, but they serve significantly
different roles.  The key data is a common secret added to every signature,
whereas the discriminator is a value that can be derived from
the context in which a specific pointer is signed.  However, unlike a password
salt, it’s important that discriminators be <em>independently</em> derived from the
circumstances of the signing; they should never simply be stored alongside
a pointer.  Discriminators are then re-derived in authentication operations.</p>
<p>The intrinsic interface in <code class="docutils literal notranslate"><span class="pre">&lt;ptrauth.h&gt;</span></code> allows an arbitrary discriminator
value to be provided, but can only be used when running normal code.  The
discriminators used by language ABIs must be restricted to make it feasible for
the loader to sign pointers stored in global memory without needing excessive
amounts of metadata.  Under these restrictions, a discriminator may consist of
either or both of the following:</p>
<ul class="simple">
<li><p>The address at which the pointer is stored in memory.  A pointer signed with
a discriminator which incorporates its storage address is said to have
<strong>address diversity</strong>.  In general, using address diversity means that
a pointer cannot be reliably copied by an attacker to or from a different
memory location.  However, an attacker may still be able to attack a larger
call sequence if they can alter the address through which the pointer is
accessed.  Furthermore, some situations cannot use address diversity because
of language or other restrictions.</p></li>
<li><p>A constant integer, called a <strong>constant discriminator</strong>. A pointer signed
with a non-zero constant discriminator is said to have <strong>constant
diversity</strong>.  If the discriminator is specific to a single declaration, it is
said to have <strong>declaration diversity</strong>; if the discriminator is specific to
a type of value, it is said to have <strong>type diversity</strong>.  For example, C++
v-tables on arm64e sign their component functions using a hash of their
method names and signatures, which provides declaration diversity; similarly,
C++ member function pointers sign their invocation functions using a hash of
the member pointer type, which provides type diversity.</p></li>
</ul>
<p>The implementation may need to restrict constant discriminators to be
significantly smaller than the full size of a discriminator.  For example, on
arm64e, constant discriminators are only 16-bit values.  This is believed to
not significantly weaken the mitigation, since collisions remain uncommon.</p>
<p>The algorithm for blending a constant discriminator with a storage address is
implementation-defined.</p>
</section>
<section id="signing-schemas">
<span id="id1"></span><h3><a class="toc-backref" href="#id11" role="doc-backlink">Signing schemas</a><a class="headerlink" href="#signing-schemas" title="Link to this heading">¶</a></h3>
<p>Correct use of pointer authentication requires the signing code and the
authenticating code to agree about the <strong>signing schema</strong> for the pointer:</p>
<ul class="simple">
<li><p>the abstract signing key with which the pointer should be signed and</p></li>
<li><p>an algorithm for computing the discriminator.</p></li>
</ul>
<p>As described in the section above on <a class="reference internal" href="#discriminators">Discriminators</a>, in most situations, the
discriminator is produced by taking a constant discriminator and optionally
blending it with the storage address of the pointer.  In these situations, the
signing schema breaks down even more simply:</p>
<ul class="simple">
<li><p>the abstract signing key,</p></li>
<li><p>a constant discriminator, and</p></li>
<li><p>whether to use address diversity.</p></li>
</ul>
<p>It is important that the signing schema be independently derived at all signing
and authentication sites.  Preferably, the schema should be hard-coded
everywhere it is needed, but at the very least, it must not be derived by
inspecting information stored along with the pointer.  See the section on
<a class="reference internal" href="#attacks-on-pointer-authentication">Attacks on pointer authentication</a> for more information.</p>
</section>
</section>
<section id="language-features">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">Language features</a><a class="headerlink" href="#language-features" title="Link to this heading">¶</a></h2>
<p>There are three levels of the pointer authentication language feature:</p>
<ul class="simple">
<li><p>The language implementation automatically signs and authenticates function
pointers (and certain data pointers) across a variety of standard situations,
including return addresses, function pointers, and C++ virtual functions. The
intent is for all pointers to code in program memory to be signed in some way
and for all branches to code in program text to authenticate those
signatures. In addition to the code pointers themselves, we also use pointer
authentication to protect data values that directly or indirectly influence
control flow or program integrity, or can provide attackers with some other
powerful program compromise.</p></li>
<li><p>The language also provides extensions to override the default rules used by
the language implementation.  For example, the <code class="docutils literal notranslate"><span class="pre">__ptrauth</span></code> type qualifier
can be used to change how pointers or pointer sized integers are signed when
they are stored in a particular variable or field; this provides much stronger
protection than is guaranteed by the default rules for C function and data
pointers.</p></li>
<li><p>Finally, the language provides the <code class="docutils literal notranslate"><span class="pre">&lt;ptrauth.h&gt;</span></code> intrinsic interface for
manually signing and authenticating pointers in code.  These can be used in
circumstances where very specific behavior is required.</p></li>
</ul>
<section id="language-implementation">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Language implementation</a><a class="headerlink" href="#language-implementation" title="Link to this heading">¶</a></h3>
<p>For the most part, pointer authentication is an unobserved detail of the
implementation of the programming language.  Any element of the language
implementation that would perform an indirect branch to a pointer is implicitly
altered so that the pointer is signed when first constructed and authenticated
when the branch is performed.  This includes:</p>
<ul class="simple">
<li><p>indirect-call features in the programming language, such as C function
pointers, C++ virtual functions, C++ member function pointers, the “blocks”
C extension, and so on;</p></li>
<li><p>returning from a function, no matter how it is called; and</p></li>
<li><p>indirect calls introduced by the implementation, such as branches through the
global offset table (GOT) used to implement direct calls to functions defined
outside of the current shared object.</p></li>
</ul>
<p>For more information about this, see the <a class="reference internal" href="#language-abi">Language ABI</a> section.</p>
<p>However, some aspects of the implementation are observable by the programmer or
otherwise require special notice.</p>
<section id="c-data-pointers">
<h4><a class="toc-backref" href="#id14" role="doc-backlink">C data pointers</a><a class="headerlink" href="#c-data-pointers" title="Link to this heading">¶</a></h4>
<p>The current implementation in Clang does not sign pointers to ordinary data by
default. For a partial explanation of the reasoning behind this, see the
<a class="reference internal" href="#theory-of-operation">Theory of Operation</a> section.</p>
<p>A specific data pointer which is more security-sensitive than most can be
signed using the <a class="reference internal" href="#ptrauth-qualifier">__ptrauth qualifier</a> or using the <code class="docutils literal notranslate"><span class="pre">&lt;ptrauth.h&gt;</span></code>
intrinsics.</p>
</section>
<section id="c-function-pointers">
<h4><a class="toc-backref" href="#id15" role="doc-backlink">C function pointers</a><a class="headerlink" href="#c-function-pointers" title="Link to this heading">¶</a></h4>
<p>The C standard imposes restrictions on the representation and semantics of
function pointer types which make it difficult to achieve satisfactory
signature diversity in the default language rules.  See <a class="reference internal" href="#attacks-on-pointer-authentication">Attacks on pointer
authentication</a> for more information about signature diversity.  Programmers
should strongly consider using the <code class="docutils literal notranslate"><span class="pre">__ptrauth</span></code> qualifier to improve the
protections for important function pointers, such as the components of of
a hand-rolled “v-table”; see the section on the <a class="reference internal" href="#ptrauth-qualifier">__ptrauth qualifier</a> for
details.</p>
<p>The value of a pointer to a C function includes a signature, even when the
value is cast to a non-function-pointer type like <code class="docutils literal notranslate"><span class="pre">void*</span></code> or <code class="docutils literal notranslate"><span class="pre">intptr_t</span></code>. On
implementations that use high bits to store the signature, this means that
relational comparisons and hashes will vary according to the exact signature
value, which is likely to change between executions of a program.  In some
implementations, it may also vary based on the exact function pointer type.</p>
</section>
<section id="null-pointers">
<h4><a class="toc-backref" href="#id16" role="doc-backlink">Null pointers</a><a class="headerlink" href="#null-pointers" title="Link to this heading">¶</a></h4>
<p>In principle, an implementation could derive the signed null pointer value
simply by applying the standard signing algorithm to the raw null pointer
value. However, for likely signing algorithms, this would mean that the signed
null pointer value would no longer be statically known, which would have many
negative consequences.  For one, it would become substantially more expensive
to emit null pointer values or to perform null-pointer checks.  For another,
the pervasive (even if technically unportable) assumption that null pointers
are bitwise zero would be invalidated, making it substantially more difficult
to adopt pointer authentication, as well as weakening common optimizations for
zero-initialized memory such as the use of <code class="docutils literal notranslate"><span class="pre">.bzz</span></code> sections.  Therefore it is
beneficial to treat null pointers specially by giving them their usual
representation.  On AArch64, this requires additional code when working with
possibly-null pointers, such as when copying a pointer field that has been
signed with address diversity.</p>
<p>While this representation of nulls is the safest option for the general case,
there are some situations in which a null pointer may have important semantic
or security impact. For that purpose Clang has the concept of a pointer
authentication schema that signs and authenticates null values.</p>
</section>
<section id="return-addresses">
<h4><a class="toc-backref" href="#id17" role="doc-backlink">Return addresses</a><a class="headerlink" href="#return-addresses" title="Link to this heading">¶</a></h4>
<p>The current implementation in Clang implicitly signs the return addresses in
function calls.  While the value of the return address is technically an
implementation detail of a function, there are some important libraries and
development tools which rely on manually walking the chain of stack frames.
These tools must be updated to correctly account for pointer authentication,
either by stripping signatures (if security is not important for the tool, e.g.
if it is capturing a stack trace during a crash) or properly authenticating
them.  More information about how these values are signed is available in the
<a class="reference internal" href="#language-abi">Language ABI</a> section.</p>
</section>
<section id="c-virtual-functions">
<h4><a class="toc-backref" href="#id18" role="doc-backlink">C++ virtual functions</a><a class="headerlink" href="#c-virtual-functions" title="Link to this heading">¶</a></h4>
<p>The current implementation in Clang signs virtual function pointers with
a discriminator derived from the full signature of the overridden method,
including the method name and parameter types.  It is possible to write C++
code that relies on v-table layout remaining constant despite changes to
a method signature; for example, a parameter might be a <code class="docutils literal notranslate"><span class="pre">typedef</span></code> that
resolves to a different type based on a build setting.  Such code violates
C++’s One Definition Rule (ODR), but that violation is not normally detected;
however, pointer authentication will detect it.</p>
</section>
</section>
<section id="language-extensions">
<h3><a class="toc-backref" href="#id19" role="doc-backlink">Language extensions</a><a class="headerlink" href="#language-extensions" title="Link to this heading">¶</a></h3>
<section id="feature-testing">
<h4><a class="toc-backref" href="#id20" role="doc-backlink">Feature testing</a><a class="headerlink" href="#feature-testing" title="Link to this heading">¶</a></h4>
<p>Whether the current target uses pointer authentication can be tested for with
a number of different tests.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__PTRAUTH__</span></code> macro is defined if <code class="docutils literal notranslate"><span class="pre">&lt;ptrauth.h&gt;</span></code> provides its normal
interface. This implies support for the pointer authentication intrinsics
and the <code class="docutils literal notranslate"><span class="pre">__ptrauth</span></code> qualifier.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_feature(ptrauth_returns)</span></code> is true if the target uses pointer
authentication to protect return addresses.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_feature(ptrauth_calls)</span></code> is true if the target uses pointer
authentication to protect indirect branches.  On arm64e this implies
<code class="docutils literal notranslate"><span class="pre">__has_feature(ptrauth_returns)</span></code>, <code class="docutils literal notranslate"><span class="pre">__has_feature(ptrauth_intrinsics)</span></code>,
and the <code class="docutils literal notranslate"><span class="pre">__PTRAUTH__</span></code> macro.</p></li>
<li><p>For backwards compatibility purposes <code class="docutils literal notranslate"><span class="pre">__has_feature(ptrauth_intrinsics)</span></code>
and <code class="docutils literal notranslate"><span class="pre">__has_feature(ptrauth_qualifier)</span></code> are available on arm64e targets.
These features are synonymous with each other, and are equivalent to testing
for the <code class="docutils literal notranslate"><span class="pre">__PTRAUTH__</span></code> macro definition. Use of these features should be
restricted to cases where backwards compatibility is required, and should be
paired with <code class="docutils literal notranslate"><span class="pre">defined(__PTRAUTH__)</span></code>.</p></li>
</ul>
<p>Clang provides several other tests only for historical purposes; for current
purposes they are all equivalent to <code class="docutils literal notranslate"><span class="pre">ptrauth_calls</span></code>.</p>
</section>
<section id="ptrauth-qualifier">
<h4><a class="toc-backref" href="#id21" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">__ptrauth</span></code> qualifier</a><a class="headerlink" href="#ptrauth-qualifier" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">__ptrauth(key,</span> <span class="pre">address,</span> <span class="pre">discriminator)</span></code> is an extended type
qualifier which causes so-qualified objects to hold pointers or pointer sized
integers signed using the specified schema rather than the default schema for
such types.</p>
<p>In the current implementation in Clang, the qualified type must be a C pointer
type, either to a function or to an object, or a pointer sized integer.  It
currently cannot be an Objective-C pointer type, a C++ reference type, or a
block pointer type; these restrictions may be lifted in the future.</p>
<p>The current implementation in Clang is known to not provide adequate safety
guarantees against the creation of <a class="reference internal" href="#signing-oracles">signing oracles</a> when assigning data
pointers to <code class="docutils literal notranslate"><span class="pre">__ptrauth</span></code>-qualified gl-values.  See the section on <a class="reference internal" href="#safe-derivation">safe
derivation</a> for more information.</p>
<p>The qualifier’s operands are as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">key</span></code> - an expression evaluating to a key value from <code class="docutils literal notranslate"><span class="pre">&lt;ptrauth.h&gt;</span></code>; must
be a constant expression</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">address</span></code> - whether to use address diversity (1) or not (0); must be
a constant expression with one of these two values</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">discriminator</span></code> - a constant discriminator; must be a constant expression</p></li>
</ul>
<p>See <a class="reference internal" href="#discriminators">Discriminators</a> for more information about discriminators.</p>
<p>Currently the operands must be constant-evaluable even within templates. In the
future this restriction may be lifted to allow value-dependent expressions as
long as they instantiate to a constant expression.</p>
<p>Consistent with the ordinary C/C++ rule for parameters, top-level <code class="docutils literal notranslate"><span class="pre">__ptrauth</span></code>
qualifiers on a parameter (after parameter type adjustment) are ignored when
deriving the type of the function.  The parameter will be passed using the
default ABI for the unqualified pointer type.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is an object of type <code class="docutils literal notranslate"><span class="pre">__ptrauth(key,</span> <span class="pre">address,</span> <span class="pre">discriminator)</span> <span class="pre">T</span></code>,
then the signing schema of the value stored in <code class="docutils literal notranslate"><span class="pre">x</span></code> is a key of <code class="docutils literal notranslate"><span class="pre">key</span></code> and
a discriminator determined as follows:</p>
<ul class="simple">
<li><p>if <code class="docutils literal notranslate"><span class="pre">address</span></code> is 0, then the discriminator is <code class="docutils literal notranslate"><span class="pre">discriminator</span></code>;</p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">address</span></code> is 1 and <code class="docutils literal notranslate"><span class="pre">discriminator</span></code> is 0, then the discriminator is
<code class="docutils literal notranslate"><span class="pre">&amp;x</span></code>; otherwise</p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">address</span></code> is 1 and <code class="docutils literal notranslate"><span class="pre">discriminator</span></code> is non-zero, then the discriminator
is <code class="docutils literal notranslate"><span class="pre">ptrauth_blend_discriminator(&amp;x,</span> <span class="pre">discriminator)</span></code>; see
<a class="reference internal" href="#ptrauth-blend-discriminator">ptrauth_blend_discriminator</a>.</p></li>
</ul>
<section id="non-triviality-from-address-diversity">
<h5><a class="toc-backref" href="#id22" role="doc-backlink">Non-triviality from address diversity</a><a class="headerlink" href="#non-triviality-from-address-diversity" title="Link to this heading">¶</a></h5>
<p>Address diversity must impose additional restrictions in order to allow the
implementation to correctly copy values.  In C++, a type qualified with address
diversity is treated like a class type with non-trivial copy/move constructors
and assignment operators, with the usual effect on containing classes and
unions.  C does not have a standard concept of non-triviality, and so we must
describe the basic rules here, with the intention of imitating the emergent
rules of C++:</p>
<ul class="simple">
<li><p>A type may be <strong>non-trivial to copy</strong>.</p></li>
<li><p>A type may also be <strong>illegal to copy</strong>. Types that are illegal to copy are
always non-trivial to copy.</p></li>
<li><p>A type may also be <strong>address-sensitive</strong>. This includes types that use self
referencing pointers, data protected by address diversified pointer
authentication, or other similar concepts.</p></li>
<li><p>A type qualified with a <code class="docutils literal notranslate"><span class="pre">ptrauth</span></code> qualifier or implicit authentication
schema that requires address diversity is non-trivial to copy and
address-sensitive.</p></li>
<li><p>An array type is illegal to copy, non-trivial to copy, or address-sensitive
if its element type is illegal to copy, non-trivial to copy, or
address-sensitive, respectively.</p></li>
<li><p>A struct type is illegal to copy, non-trivial to copy, or address-sensitive
if it has a field whose type is illegal to copy, non-trivial to copy, or
address-sensitive, respectively.</p></li>
<li><p>A union type is both illegal and non-trivial to copy if it has a field whose
type is non-trivial or illegal to copy.</p></li>
<li><p>A union type is address-sensitive if it has a field whose type is
address-sensitive.</p></li>
<li><p>A program is ill-formed if it uses a type that is illegal to copy as
a function parameter, argument, or return type.</p></li>
<li><p>A program is ill-formed if an expression requires a type to be copied that is
illegal to copy.</p></li>
<li><p>Otherwise, copying a type that is non-trivial to copy correctly copies its
subobjects.</p></li>
<li><p>Types that are address-sensitive must always be passed and returned
indirectly. Thus, changing the address-sensitivity of a type may be
ABI-breaking even if its size and alignment do not change.</p></li>
</ul>
</section>
</section>
</section>
<section id="ptrauth-h">
<h3><a class="toc-backref" href="#id23" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">&lt;ptrauth.h&gt;</span></code></a><a class="headerlink" href="#ptrauth-h" title="Link to this heading">¶</a></h3>
<p>This header defines the following types and operations:</p>
<section id="ptrauth-key">
<h4><a class="toc-backref" href="#id24" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">ptrauth_key</span></code></a><a class="headerlink" href="#ptrauth-key" title="Link to this heading">¶</a></h4>
<p>This <code class="docutils literal notranslate"><span class="pre">enum</span></code> is the type of abstract signing keys.  In addition to defining
the set of implementation-specific signing keys (for example, Armv8.3 defines
<code class="docutils literal notranslate"><span class="pre">ptrauth_key_asia</span></code>), it also defines some portable aliases for those keys.
For example, <code class="docutils literal notranslate"><span class="pre">ptrauth_key_function_pointer</span></code> is the key generally used for
C function pointers, which will generally be suitable for other
function-signing schemas.</p>
<p>In all the operation descriptions below, key values must be constant values
corresponding to one of the implementation-specific abstract signing keys from
this <code class="docutils literal notranslate"><span class="pre">enum</span></code>.</p>
</section>
<section id="ptrauth-extra-data-t">
<h4><a class="toc-backref" href="#id25" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">ptrauth_extra_data_t</span></code></a><a class="headerlink" href="#ptrauth-extra-data-t" title="Link to this heading">¶</a></h4>
<p>This is a <code class="docutils literal notranslate"><span class="pre">typedef</span></code> of a standard integer type of the correct size to hold
a discriminator value.</p>
<p>In the signing and authentication operation descriptions below, discriminator
values must have either pointer type or integer type. If the discriminator is
an integer, it will be coerced to <code class="docutils literal notranslate"><span class="pre">ptrauth_extra_data_t</span></code>.</p>
</section>
<section id="ptrauth-blend-discriminator">
<h4><a class="toc-backref" href="#id26" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">ptrauth_blend_discriminator</span></code></a><a class="headerlink" href="#ptrauth-blend-discriminator" title="Link to this heading">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ptrauth_blend_discriminator</span><span class="p">(</span><span class="n">pointer</span><span class="p">,</span><span class="w"> </span><span class="n">integer</span><span class="p">)</span>
</pre></div>
</div>
<p>Produce a discriminator value which blends information from the given pointer
and the given integer.</p>
<p>Implementations may ignore some bits from each value, which is to say, the
blending algorithm may be chosen for speed and convenience over theoretical
strength as a hash-combining algorithm.  For example, arm64e simply overwrites
the high 16 bits of the pointer with the low 16 bits of the integer, which can
be done in a single instruction with an immediate integer.</p>
<p><code class="docutils literal notranslate"><span class="pre">pointer</span></code> must have pointer type, and <code class="docutils literal notranslate"><span class="pre">integer</span></code> must have integer type. The
result has type <code class="docutils literal notranslate"><span class="pre">ptrauth_extra_data_t</span></code>.</p>
</section>
<section id="ptrauth-string-discriminator">
<h4><a class="toc-backref" href="#id27" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">ptrauth_string_discriminator</span></code></a><a class="headerlink" href="#ptrauth-string-discriminator" title="Link to this heading">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ptrauth_string_discriminator</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute a constant discriminator from the given string.</p>
<p><code class="docutils literal notranslate"><span class="pre">string</span></code> must be a string literal of <code class="docutils literal notranslate"><span class="pre">char</span></code> character type.  The result has
type <code class="docutils literal notranslate"><span class="pre">ptrauth_extra_data_t</span></code>.</p>
<p>The result value is never zero and always within range for both the
<code class="docutils literal notranslate"><span class="pre">__ptrauth</span></code> qualifier and <code class="docutils literal notranslate"><span class="pre">ptrauth_blend_discriminator</span></code>.</p>
<p>This can be used in constant expressions.</p>
</section>
<section id="ptrauth-strip">
<h4><a class="toc-backref" href="#id28" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">ptrauth_strip</span></code></a><a class="headerlink" href="#ptrauth-strip" title="Link to this heading">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ptrauth_strip</span><span class="p">(</span><span class="n">signedPointer</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">)</span>
</pre></div>
</div>
<p>Given that <code class="docutils literal notranslate"><span class="pre">signedPointer</span></code> matches the layout for signed pointers signed with
the given key, extract the raw pointer from it.  This operation does not trap
and cannot fail, even if the pointer is not validly signed.</p>
</section>
<section id="ptrauth-sign-constant">
<h4><a class="toc-backref" href="#id29" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">ptrauth_sign_constant</span></code></a><a class="headerlink" href="#ptrauth-sign-constant" title="Link to this heading">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ptrauth_sign_constant</span><span class="p">(</span><span class="n">pointer</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">discriminator</span><span class="p">)</span>
</pre></div>
</div>
<p>Return a signed pointer for a constant address in a manner which guarantees
a non-attackable sequence.</p>
<p><code class="docutils literal notranslate"><span class="pre">pointer</span></code> must be a constant expression of pointer type which evaluates to
a non-null pointer.
<code class="docutils literal notranslate"><span class="pre">key</span></code>  must be a constant expression of type <code class="docutils literal notranslate"><span class="pre">ptrauth_key</span></code>.
<code class="docutils literal notranslate"><span class="pre">discriminator</span></code> must be a constant expression of pointer or integer type;
if an integer, it will be coerced to <code class="docutils literal notranslate"><span class="pre">ptrauth_extra_data_t</span></code>.
The result will have the same type as <code class="docutils literal notranslate"><span class="pre">pointer</span></code>.</p>
<p>This can be used in constant expressions.</p>
</section>
<section id="ptrauth-sign-unauthenticated">
<h4><a class="toc-backref" href="#id30" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">ptrauth_sign_unauthenticated</span></code></a><a class="headerlink" href="#ptrauth-sign-unauthenticated" title="Link to this heading">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ptrauth_sign_unauthenticated</span><span class="p">(</span><span class="n">pointer</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">discriminator</span><span class="p">)</span>
</pre></div>
</div>
<p>Produce a signed pointer for the given raw pointer without applying any
authentication or extra treatment.  This operation is not required to have the
same behavior on a null pointer that the language implementation would.</p>
<p>This is a treacherous operation that can easily result in <a class="reference internal" href="#signing-oracles">signing oracles</a>.
Programs should use it seldom and carefully.</p>
</section>
<section id="ptrauth-auth-and-resign">
<h4><a class="toc-backref" href="#id31" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">ptrauth_auth_and_resign</span></code></a><a class="headerlink" href="#ptrauth-auth-and-resign" title="Link to this heading">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ptrauth_auth_and_resign</span><span class="p">(</span><span class="n">pointer</span><span class="p">,</span><span class="w"> </span><span class="n">oldKey</span><span class="p">,</span><span class="w"> </span><span class="n">oldDiscriminator</span><span class="p">,</span><span class="w"> </span><span class="n">newKey</span><span class="p">,</span><span class="w"> </span><span class="n">newDiscriminator</span><span class="p">)</span>
</pre></div>
</div>
<p>Authenticate that <code class="docutils literal notranslate"><span class="pre">pointer</span></code> is signed with <code class="docutils literal notranslate"><span class="pre">oldKey</span></code> and
<code class="docutils literal notranslate"><span class="pre">oldDiscriminator</span></code> and then resign the raw-pointer result of that
authentication with <code class="docutils literal notranslate"><span class="pre">newKey</span></code> and <code class="docutils literal notranslate"><span class="pre">newDiscriminator</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">pointer</span></code> must have pointer type.  The result will have the same type as
<code class="docutils literal notranslate"><span class="pre">pointer</span></code>.  This operation is not required to have the same behavior on
a null pointer that the language implementation would.</p>
<p>The code sequence produced for this operation must not be directly attackable.
However, if the discriminator values are not constant integers, their
computations may still be attackable.  In the future, Clang should be enhanced
to guaranteed non-attackability if these expressions are
<a class="reference internal" href="#safe-derivation"><span class="std std-ref">safely-derived</span></a>.</p>
</section>
<section id="ptrauth-auth-function">
<h4><a class="toc-backref" href="#id32" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">ptrauth_auth_function</span></code></a><a class="headerlink" href="#ptrauth-auth-function" title="Link to this heading">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ptrauth_auth_function</span><span class="p">(</span><span class="n">pointer</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">discriminator</span><span class="p">)</span>
</pre></div>
</div>
<p>Authenticate that <code class="docutils literal notranslate"><span class="pre">pointer</span></code> is signed with <code class="docutils literal notranslate"><span class="pre">key</span></code> and <code class="docutils literal notranslate"><span class="pre">discriminator</span></code> and
re-sign it to the standard schema for a function pointer of its type.</p>
<p><code class="docutils literal notranslate"><span class="pre">pointer</span></code> must have function pointer type.  The result will have the same
type as <code class="docutils literal notranslate"><span class="pre">pointer</span></code>.  This operation is not required to have the same behavior
on a null pointer that the language implementation would.</p>
<p>This operation makes the same attackability guarantees as
<code class="docutils literal notranslate"><span class="pre">ptrauth_auth_and_resign</span></code>.</p>
<p>If this operation appears syntactically as the function operand of a call,
Clang guarantees that the call will directly authenticate the function value
using the given schema rather than re-signing to the standard schema.</p>
</section>
<section id="ptrauth-auth-data">
<h4><a class="toc-backref" href="#id33" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">ptrauth_auth_data</span></code></a><a class="headerlink" href="#ptrauth-auth-data" title="Link to this heading">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ptrauth_auth_data</span><span class="p">(</span><span class="n">pointer</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">discriminator</span><span class="p">)</span>
</pre></div>
</div>
<p>Authenticate that <code class="docutils literal notranslate"><span class="pre">pointer</span></code> is signed with <code class="docutils literal notranslate"><span class="pre">key</span></code> and <code class="docutils literal notranslate"><span class="pre">discriminator</span></code> and
remove the signature.</p>
<p><code class="docutils literal notranslate"><span class="pre">pointer</span></code> must have object pointer type.  The result will have the same type
as <code class="docutils literal notranslate"><span class="pre">pointer</span></code>.  This operation is not required to have the same behavior on
a null pointer that the language implementation would.</p>
<p>In the future when Clang makes safe derivation guarantees, the result of
this operation should be considered safely-derived.</p>
</section>
<section id="ptrauth-sign-generic-data">
<h4><a class="toc-backref" href="#id34" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">ptrauth_sign_generic_data</span></code></a><a class="headerlink" href="#ptrauth-sign-generic-data" title="Link to this heading">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ptrauth_sign_generic_data</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span><span class="w"> </span><span class="n">value2</span><span class="p">)</span>
</pre></div>
</div>
<p>Computes a signature for the given pair of values, incorporating a secret
signing key.</p>
<p>This operation can be used to verify that arbitrary data has not been tampered
with by computing a signature for the data, storing that signature, and then
repeating this process and verifying that it yields the same result.  This can
be reasonably done in any number of ways; for example, a library could compute
an ordinary checksum of the data and just sign the result in order to get the
tamper-resistance advantages of the secret signing key (since otherwise an
attacker could reliably overwrite both the data and the checksum).</p>
<p><code class="docutils literal notranslate"><span class="pre">value1</span></code> and <code class="docutils literal notranslate"><span class="pre">value2</span></code> must be either pointers or integers.  If the integers
are larger than <code class="docutils literal notranslate"><span class="pre">uintptr_t</span></code> then data not representable in <code class="docutils literal notranslate"><span class="pre">uintptr_t</span></code> may
be discarded.</p>
<p>The result will have type <code class="docutils literal notranslate"><span class="pre">ptrauth_generic_signature_t</span></code>, which is an integer
type.  Implementations are not required to make all bits of the result equally
significant; in particular, some implementations are known to not leave
meaningful data in the low bits.</p>
</section>
<section id="standard-ptrauth-qualifiers">
<h4><a class="toc-backref" href="#id35" role="doc-backlink">Standard <code class="docutils literal notranslate"><span class="pre">__ptrauth</span></code> qualifiers</a><a class="headerlink" href="#standard-ptrauth-qualifiers" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">&lt;ptrauth.h&gt;</span></code> additionally provides several macros which expand to
<code class="docutils literal notranslate"><span class="pre">__ptrauth</span></code> qualifiers for common ABI situations.</p>
<p>For convenience, these macros expand to nothing when pointer authentication is
disabled.</p>
<p>These macros can be found in the header; some details of these macros may be
unstable or implementation-specific.</p>
</section>
</section>
</section>
<section id="theory-of-operation">
<h2><a class="toc-backref" href="#id36" role="doc-backlink">Theory of operation</a><a class="headerlink" href="#theory-of-operation" title="Link to this heading">¶</a></h2>
<p>The threat model of pointer authentication is as follows:</p>
<ul class="simple">
<li><p>The attacker has the ability to read and write to a certain range of
addresses, possibly the entire address space.  However, they are constrained
by the normal rules of the process: for example, they cannot write to memory
that is mapped read-only, and if they access unmapped memory it will trigger
a trap.</p></li>
<li><p>The attacker has no ability to add arbitrary executable code to the program.
For example, the program does not include malicious code to begin with, and
the attacker cannot alter existing instructions, load a malicious shared
library, or remap writable pages as executable.  If the attacker wants to get
the process to perform a specific sequence of actions, they must somehow
subvert the normal control flow of the process.</p></li>
</ul>
<p>In both of the above paragraphs, it is merely assumed that the attacker’s
<em>current</em> capabilities are restricted; that is, their current exploit does not
directly give them the power to do these things.  The attacker’s immediate goal
may well be to leverage their exploit to gain these capabilities, e.g. to load
a malicious dynamic library into the process, even though the process does not
directly contain code to do so.</p>
<p>Note that any bug that fits the above threat model can be immediately exploited
as a denial-of-service attack by simply performing an illegal access and
crashing the program.  Pointer authentication cannot protect against this.
While denial-of-service attacks are unfortunate, they are also unquestionably
the best possible result of a bug this severe. Therefore, pointer authentication
enthusiastically embraces the idea of halting the program on a pointer
authentication failure rather than continuing in a possibly-compromised state.</p>
<p>Pointer authentication is a form of control-flow integrity (CFI) enforcement.
The basic security hypothesis behind CFI enforcement is that many bugs can only
be usefully exploited (other than as a denial-of-service) by leveraging them to
subvert the control flow of the program.  If this is true, then by inhibiting or
limiting that subversion, it may be possible to largely mitigate the security
consequences of those bugs by rendering them impractical (or, ideally,
impossible) to exploit.</p>
<p>Every indirect branch in a program has a purpose.  Using human intelligence, a
programmer can describe where a particular branch <em>should</em> go according to this
purpose: a <code class="docutils literal notranslate"><span class="pre">return</span></code> in <code class="docutils literal notranslate"><span class="pre">printf</span></code> should return to the call site, a particular
call in <code class="docutils literal notranslate"><span class="pre">qsort</span></code> should call the comparator that was passed in as an argument,
and so on.  But for CFI to enforce that every branch in a program goes where it
<em>should</em> in this sense would require CFI to perfectly enforce every semantic
rule of the program’s abstract machine; that is, it would require making the
programming environment perfectly sound.  That is out of scope.  Instead, the
goal of CFI is merely to catch attempts to make a branch go somewhere that its
obviously <em>shouldn’t</em> for its purpose: for example, to stop a call from
branching into the middle of a function rather than its beginning.  As the
information available to CFI gets better about the purpose of the branch, CFI
can enforce tighter and tighter restrictions on where the branch is permitted to
go.  Still, ultimately CFI cannot make the program sound.  This may help explain
why pointer authentication makes some of the choices it does: for example, to
sign and authenticate mostly code pointers rather than every pointer in the
program.  Preventing attackers from redirecting branches is both particularly
important and particularly approachable as a goal.  Detecting corruption more
broadly is infeasible with these techniques, and the attempt would have far
higher cost.</p>
<section id="attacks-on-pointer-authentication">
<h3><a class="toc-backref" href="#id37" role="doc-backlink">Attacks on pointer authentication</a><a class="headerlink" href="#attacks-on-pointer-authentication" title="Link to this heading">¶</a></h3>
<p>Pointer authentication works as follows.  Every indirect branch in a program has
a purpose.  For every purpose, the implementation chooses a
<a class="reference internal" href="#signing-schemas"><span class="std std-ref">signing schema</span></a>.  At some place where a pointer is known
to be correct for its purpose, it is signed according to the purpose’s schema.
At every place where the pointer is needed for its purpose, it is authenticated
according to the purpose’s schema.  If that authentication fails, the program is
halted.</p>
<p>There are a variety of ways to attack this.</p>
<section id="attacks-of-interest-to-programmers">
<h4><a class="toc-backref" href="#id38" role="doc-backlink">Attacks of interest to programmers</a><a class="headerlink" href="#attacks-of-interest-to-programmers" title="Link to this heading">¶</a></h4>
<p>These attacks arise from weaknesses in the default protections offered by
pointer authentication.  They can be addressed by using attributes or intrinsics
to opt in to stronger protection.</p>
<section id="substitution-attacks">
<h5><a class="toc-backref" href="#id39" role="doc-backlink">Substitution attacks</a><a class="headerlink" href="#substitution-attacks" title="Link to this heading">¶</a></h5>
<p>An attacker can simply overwrite a pointer intended for one purpose with a
pointer intended for another purpose if both purposes use the same signing
schema and that schema does not use address diversity.</p>
<p>The most common source of this weakness is when code relies on using the default
language rules for C function pointers.  The current implementation uses the
exact same signing schema for all C function pointers, even for functions of
substantially different type.  While efforts are ongoing to improve constant
diversity for C function pointers of different type, there are necessary limits
to this.  The C standard requires function pointers to be copyable with
<code class="docutils literal notranslate"><span class="pre">memcpy</span></code>, which means that function pointers can never use address diversity.
Furthermore, even if a function pointer can only be replaced with another
function of the exact same type, that can still be useful to an attacker, as in
the following example of a hand-rolled “v-table”:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">ObjectOperations</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">retain</span><span class="p">)(</span><span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)(</span><span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">deallocate</span><span class="p">)(</span><span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">logStatus</span><span class="p">)(</span><span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The weakness in this design is that by lacking any context specific
discriminator, this means an attacker can substitute any of these fields with
any other function pointer signed with the default schema. Similarly the lack of
address diversity allows an attacker to replace the functions in one type’s
“v-table” with those of another. This can be mitigated by overriding the default
authentication schema with a more specific signing schema for each purpose.  For
instance, in this example, the <code class="docutils literal notranslate"><span class="pre">__ptrauth</span></code> qualifier can be used with a
different constant discriminator for each field.  Since there’s no particular
reason it’s important for this v-table to be copyable with <code class="docutils literal notranslate"><span class="pre">memcpy</span></code>, the
functions can also be signed with address diversity:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#if defined(__PTRAUTH__)</span>
<span class="cp">#define objectOperation(discriminator) \</span>
<span class="cp">  __ptrauth(ptrauth_key_function_pointer, 1, discriminator)</span>
<span class="cp">#else</span>
<span class="cp">#define objectOperation(discriminator)</span>
<span class="cp">#endif</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">ObjectOperations</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">objectOperation</span><span class="p">(</span><span class="mh">0xf017</span><span class="p">)</span><span class="w"> </span><span class="n">retain</span><span class="p">)(</span><span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">objectOperation</span><span class="p">(</span><span class="mh">0x2639</span><span class="p">)</span><span class="w"> </span><span class="n">release</span><span class="p">)(</span><span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">objectOperation</span><span class="p">(</span><span class="mh">0x8bb0</span><span class="p">)</span><span class="w"> </span><span class="n">deallocate</span><span class="p">)(</span><span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">objectOperation</span><span class="p">(</span><span class="mh">0xc5d4</span><span class="p">)</span><span class="w"> </span><span class="n">logStatus</span><span class="p">)(</span><span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This weakness can also sometimes be mitigated by simply keeping the signed
pointer in constant memory, but this is less effective than using better signing
diversity.</p>
</section>
<section id="access-path-attacks">
<span id="id2"></span><h5><a class="toc-backref" href="#id40" role="doc-backlink">Access path attacks</a><a class="headerlink" href="#access-path-attacks" title="Link to this heading">¶</a></h5>
<p>If a signed pointer is often accessed indirectly (that is, by first loading the
address of the object where the signed pointer is stored), an attacker can
affect uses of it by overwriting the intermediate pointer in the access path.</p>
<p>The most common scenario exhibiting this weakness is an object with a pointer to
a “v-table” (a structure holding many function pointers). An attacker does not
need to replace a signed function pointer in the v-table if they can instead
simply replace the v-table pointer in the object with their own pointer —
perhaps to memory where they’ve constructed their own v-table, or to existing
memory that coincidentally happens to contain a signed pointer at the right
offset that’s been signed with the right signing schema.</p>
<p>This attack arises because data pointers are not signed by default. It works
even if the signed pointer uses address diversity: address diversity merely
means that each pointer is signed with its own storage address,
which (by design) is invariant to changes in the accessing pointer.</p>
<p>Using sufficiently diverse signing schemas within the v-table can provide
reasonably strong mitigation against this weakness.  Always use address and type
diversity in v-tables to prevent attackers from assembling their own v-table.
Avoid re-using constant discriminators to prevent attackers from replacing a
v-table pointer with a pointer to totally unrelated memory that just happens to
contain an similarly-signed pointer, or reused memory containing a different
type.</p>
<p>Further mitigation can be attained by signing pointers to v-tables. Any
signature at all should prevent attackers from forging v-table pointers; they
will need to somehow harvest an existing signed pointer from elsewhere in
memory.  Using a meaningful constant discriminator will force this to be
harvested from an object with similar structure (e.g. a different implementation
of the same interface).  Using address diversity will prevent such harvesting
entirely.  However, care must be taken when sourcing the v-table pointer
originally; do not blindly sign a pointer that is not
<a class="reference internal" href="#safe-derivation"><span class="std std-ref">safely derived</span></a>.</p>
</section>
<section id="signing-oracles">
<span id="id3"></span><h5><a class="toc-backref" href="#id41" role="doc-backlink">Signing oracles</a><a class="headerlink" href="#signing-oracles" title="Link to this heading">¶</a></h5>
<p>A signing oracle is a bit of code which can be exploited by an attacker to sign
an arbitrary pointer in a way that can later be recovered.  Such oracles can be
used by attackers to forge signatures matching the oracle’s signing schema,
which is likely to cause a total compromise of pointer authentication’s
effectiveness.</p>
<p>This attack only affects ordinary programmers if they are using certain
treacherous patterns of code.  Currently this includes:</p>
<ul class="simple">
<li><p>all uses of the <code class="docutils literal notranslate"><span class="pre">__ptrauth_sign_unauthenticated</span></code> intrinsic and</p></li>
<li><p>assigning values to <code class="docutils literal notranslate"><span class="pre">__ptrauth</span></code>-qualified l-values.</p></li>
</ul>
<p>Care must be taken in these situations to ensure that the pointer being signed
has been <a class="reference internal" href="#safe-derivation"><span class="std std-ref">safely derived</span></a> or is otherwise not possible to
attack.  (In some cases, this may be challenging without compiler support.)</p>
<p>A diagnostic will be added in the future for implicitly dangerous patterns of
code, such as assigning a non-safely-derived values to a
<code class="docutils literal notranslate"><span class="pre">__ptrauth</span></code>-qualified l-value.</p>
</section>
<section id="authentication-oracles">
<span id="id4"></span><h5><a class="toc-backref" href="#id42" role="doc-backlink">Authentication oracles</a><a class="headerlink" href="#authentication-oracles" title="Link to this heading">¶</a></h5>
<p>An authentication oracle is a bit of code which can be exploited by an attacker
to leak whether a signed pointer is validly signed without halting the program
if it isn’t.  Such oracles can be used to forge signatures matching the oracle’s
signing schema if the attacker can repeatedly invoke the oracle for different
candidate signed pointers. This is likely to cause a total compromise of pointer
authentication’s effectiveness.</p>
<p>There should be no way for an ordinary programmer to create an authentication
oracle using the current set of operations. However, implementation flaws in the
past have occasionally given rise to authentication oracles due to a failure to
immediately trap on authentication failure.</p>
<p>The likelihood of creating an authentication oracle is why there is currently no
intrinsic which queries whether a signed pointer is validly signed.</p>
</section>
</section>
<section id="attacks-of-interest-to-implementors">
<h4><a class="toc-backref" href="#id43" role="doc-backlink">Attacks of interest to implementors</a><a class="headerlink" href="#attacks-of-interest-to-implementors" title="Link to this heading">¶</a></h4>
<p>These attacks are not inherent to the model; they arise from mistakes in either
implementing or using the <cite>sign</cite> and <cite>auth</cite> operations. Avoiding these mistakes
requires careful work throughout the system.</p>
<section id="failure-to-trap-on-authentication-failure">
<h5><a class="toc-backref" href="#id44" role="doc-backlink">Failure to trap on authentication failure</a><a class="headerlink" href="#failure-to-trap-on-authentication-failure" title="Link to this heading">¶</a></h5>
<p>Any failure to halt the program on an authentication failure is likely to be
exploitable by attackers to create an
<a class="reference internal" href="#authentication-oracles"><span class="std std-ref">authentication oracle</span></a>.</p>
<p>There are several different ways to introduce this problem:</p>
<ul>
<li><p>The implementation might try to halt the program in some way that can be
intercepted.</p>
<p>For example, the Armv8.3 <code class="docutils literal notranslate"><span class="pre">aut</span></code> instructions do not directly trap on
authentication failure on processors that lack the <code class="docutils literal notranslate"><span class="pre">FPAC</span></code> extension.
Instead, they corrupt their results to be invalid pointers, with the idea that
subsequent uses of those pointers will trigger traps as bad memory accesses.
However, most kernels do not immediately halt programs that trap due to bad
memory accesses; instead, they notify the process to give it an opportunity to
recover. If this happens with an <code class="docutils literal notranslate"><span class="pre">auth</span></code> failure, the attacker may be able to
exploit the recovery path in a way that creates an oracle. Kernels must
provide a way for a process to trap unrecoverably, and this should cover all
<code class="docutils literal notranslate"><span class="pre">FPAC</span></code> traps. Compilers must ensure that <code class="docutils literal notranslate"><span class="pre">auth</span></code> failures trigger an
unrecoverable trap, ideally by taking advantage of <code class="docutils literal notranslate"><span class="pre">FPAC</span></code>, but if necessary
by emitting extra instructions.</p>
</li>
<li><p>A compiler might use an intermediate representation (IR) for <code class="docutils literal notranslate"><span class="pre">sign</span></code> and
<code class="docutils literal notranslate"><span class="pre">auth</span></code> operations that cannot make adequate correctness guarantees.</p>
<p>For example, suppose that an IR uses ARMv8.3-like semantics for <code class="docutils literal notranslate"><span class="pre">auth</span></code>: the
operation merely corrupts its result on failure instead of promising to trap.
A frontend might emit patterns of IR that always follow an <code class="docutils literal notranslate"><span class="pre">auth</span></code> with a
memory access, thinking that this ensures correctness. But if the IR can be
transformed to insert code between the <code class="docutils literal notranslate"><span class="pre">auth</span></code> and the access, or if the
<code class="docutils literal notranslate"><span class="pre">auth</span></code> can be speculated, then this potentially creates an oracle.  It is
better for <code class="docutils literal notranslate"><span class="pre">auth</span></code> to semantically guarantee to trap, potentially requiring
an explicit check in the generated code. An ARMv8.3-like target can avoid this
explicit check in the common case by recognizing the pattern of an <code class="docutils literal notranslate"><span class="pre">auth</span></code>
followed immediately by an access.</p>
</li>
</ul>
</section>
<section id="attackable-code-sequences">
<h5><a class="toc-backref" href="#id45" role="doc-backlink">Attackable code sequences</a><a class="headerlink" href="#attackable-code-sequences" title="Link to this heading">¶</a></h5>
<p>If code that is part of a pointer authentication operation is interleaved with
code that may itself be vulnerable to attacks, an attacker may be able to use
this to create a <a class="reference internal" href="#signing-oracles"><span class="std std-ref">signing</span></a> or
<a class="reference internal" href="#authentication-oracles"><span class="std std-ref">authentication</span></a> oracle.</p>
<p>For example, suppose that the compiler is generating a call to a function and
passing two arguments: a signed constant pointer and a value derived from a
call.  In ARMv8.3, this code might look like so:</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">adr</span><span class="w"> </span><span class="no">x19</span><span class="p">,</span><span class="w"> </span><span class="no">_callback.</span><span class="w">        </span><span class="c1">; compute &amp;_callback</span>
<span class="nf">paciza</span><span class="w"> </span><span class="no">x19</span><span class="w">                 </span><span class="c1">; sign it with a constant discriminator of 0</span>
<span class="nf">blr</span><span class="w"> </span><span class="no">_argGenerator</span><span class="w">          </span><span class="c1">; call _argGenerator() (returns in x0)</span>
<span class="nf">mov</span><span class="w"> </span><span class="no">x1</span><span class="p">,</span><span class="w"> </span><span class="no">x0</span><span class="w">                 </span><span class="c1">; move call result to second arg register</span>
<span class="nf">mov</span><span class="w"> </span><span class="no">x0</span><span class="p">,</span><span class="w"> </span><span class="no">x19</span><span class="w">                </span><span class="c1">; move signed &amp;_callback to first arg register</span>
<span class="nf">blr</span><span class="w"> </span><span class="no">_function</span><span class="w">              </span><span class="c1">; call _function</span>
</pre></div>
</div>
<p>This code is correct, as would be a sequencing that does <em>both</em> the <code class="docutils literal notranslate"><span class="pre">adr</span></code> and
the <code class="docutils literal notranslate"><span class="pre">paciza</span></code> after the call to <code class="docutils literal notranslate"><span class="pre">_argGenerator</span></code>.  But a sequence that
computes the address of <code class="docutils literal notranslate"><span class="pre">_callback</span></code> but leaves it as a raw pointer in a
register during the call to <code class="docutils literal notranslate"><span class="pre">_argGenerator</span></code> would be vulnerable:</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">adr</span><span class="w"> </span><span class="no">x19</span><span class="p">,</span><span class="w"> </span><span class="no">_callback.</span><span class="w">        </span><span class="c1">; compute &amp;_callback</span>
<span class="nf">blr</span><span class="w"> </span><span class="no">_argGenerator</span><span class="w">          </span><span class="c1">; call _argGenerator() (returns in x0)</span>
<span class="nf">mov</span><span class="w"> </span><span class="no">x1</span><span class="p">,</span><span class="w"> </span><span class="no">x0</span><span class="w">                 </span><span class="c1">; move call result to second arg register</span>
<span class="nf">paciza</span><span class="w"> </span><span class="no">x19</span><span class="w">                 </span><span class="c1">; sign &amp;_callback</span>
<span class="nf">mov</span><span class="w"> </span><span class="no">x0</span><span class="p">,</span><span class="w"> </span><span class="no">x19</span><span class="w">                </span><span class="c1">; move signed &amp;_callback to first arg register</span>
<span class="nf">blr</span><span class="w"> </span><span class="no">_function</span><span class="w">              </span><span class="c1">; call _function</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">_argGenerator</span></code> spills <code class="docutils literal notranslate"><span class="pre">x19</span></code> (a callee-save register), and if the
attacker can perform a write during this call, then the attacker can overwrite
the spill slot with an arbitrary pointer that will eventually be unconditionally
signed after the function returns.  This would be a signing oracle.</p>
<p>The implementation can avoid this by obeying two basic rules:</p>
<ul>
<li><p>The compiler’s intermediate representations (IR) should not provide operations
that expose intermediate raw pointers.  This may require providing extra
operations that perform useful combinations of operations.</p>
<p>For example, there should be an “atomic” auth-and-resign operation that should
be used instead of emitting an <code class="docutils literal notranslate"><span class="pre">auth</span></code> operation whose result is fed into a
<code class="docutils literal notranslate"><span class="pre">sign</span></code>.</p>
<p>Similarly, if a pointer should be authenticated as part of doing a memory
access or a call, then the access or call should be decorated with enough
information to perform the authentication; there should not be a separate
<code class="docutils literal notranslate"><span class="pre">auth</span></code> whose result is used as the pointer operand for the access or call.
(In LLVM IR, we do this for calls, but not yet for loads or stores.)</p>
<p>“Operations” includes things like materializing a signed value to a known
function or global variable.  The compiler must be able to recognize and emit
this as a unified operation, rather than potentially splitting it up as in
the example above.</p>
</li>
<li><p>The compiler backend should not be too aggressive about scheduling
instructions that are part of a pointer authentication operation. This may
require custom code-generation of these operations in some cases.</p></li>
</ul>
</section>
<section id="register-clobbering">
<h5><a class="toc-backref" href="#id46" role="doc-backlink">Register clobbering</a><a class="headerlink" href="#register-clobbering" title="Link to this heading">¶</a></h5>
<p>As a refinement of the section on <a class="reference internal" href="#attackable-code-sequences">Attackable code sequences</a>, if the attacker
has the ability to modify arbitrary <em>register</em> state at arbitrary points in the
program, then special care must be taken.</p>
<p>For example, ARMv8.3 might materialize a signed function pointer like so:</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">adr</span><span class="w"> </span><span class="no">x0</span><span class="p">,</span><span class="w"> </span><span class="no">_callback.</span><span class="w">        </span><span class="c1">; compute &amp;_callback</span>
<span class="nf">paciza</span><span class="w"> </span><span class="no">x0</span><span class="w">                 </span><span class="c1">; sign it with a constant discriminator of 0</span>
</pre></div>
</div>
<p>If an attacker has the ability to overwrite <code class="docutils literal notranslate"><span class="pre">x0</span></code> between these two
instructions, this code sequence is vulnerable to becoming a signing oracle.</p>
<p>For the most part, this sort of attack is not possible: it is a basic element of
the design of modern computation that register state is private and inviolable.
However, in systems that support asynchronous interrupts, this property requires
the cooperation of the interrupt-handling code. If that code saves register
state to memory, and that memory can be overwritten by an attacker, then
essentially the attack can overwrite arbitrary register state at an arbitrary
point.  This could be a concern if the threat model includes attacks on the
kernel or if the program uses user-space preemptive multitasking.</p>
<p>(Readers might object that an attacker cannot rely on asynchronous interrupts
triggering at an exact instruction boundary.  In fact, researchers have had some
success in doing exactly that.  Even ignoring that, though, we should aim to
protect against lucky attackers just as much as good ones.)</p>
<p>To protect against this, saved register state must be at least partially signed
(using something like <a class="reference internal" href="#ptrauth-sign-generic-data">ptrauth_sign_generic_data</a>).  This is required for
correctness anyway because saved thread states include security-critical
registers such as SP, FP, PC, and LR (where applicable).  Ideally, this
signature would cover all the registers, but since saving and restoring
registers can be very performance-sensitive, that may not be acceptable. It is
sufficient to set aside a small number of scratch registers that will be
guaranteed to be preserved correctly; the compiler can then be careful to only
store critical values like intermediate raw pointers in those registers.</p>
<p><code class="docutils literal notranslate"><span class="pre">setjmp</span></code> and <code class="docutils literal notranslate"><span class="pre">longjmp</span></code> should sign and authenticate the core registers (SP,
FP, PC, and LR), but they do not need to worry about intermediate values because
<code class="docutils literal notranslate"><span class="pre">setjmp</span></code> can only be called synchronously, and the compiler should never
schedule pointer-authentication operations interleaved with arbitrary calls.</p>
</section>
<section id="attacks-on-relative-addressing">
<span id="relative-addresses"></span><h5><a class="toc-backref" href="#id47" role="doc-backlink">Attacks on relative addressing</a><a class="headerlink" href="#attacks-on-relative-addressing" title="Link to this heading">¶</a></h5>
<p>Relative addressing is a technique used to compress and reduce the load-time
cost of infrequently-used global data.  The pointer authentication system is
unlikely to support signing or authenticating a relative address, and in most
cases it would defeat the point to do so: it would take additional storage
space, and applying the signature would take extra work at load time.</p>
<p>Relative addressing is not precluded by the use of pointer authentication, but
it does take extra considerations to make it secure:</p>
<ul class="simple">
<li><p>Relative addresses must only be stored in read-only memory.  A writable
relative address can be overwritten to point nearly anywhere, making it
inherently insecure; this danger can only be compensated for with techniques
for protecting arbitrary data like <a class="reference internal" href="#ptrauth-sign-generic-data">ptrauth_sign_generic_data</a>.</p></li>
<li><p>Relative addresses must only be accessed through signed pointers with adequate
diversity.  If an attacker can perform an <cite>access path attack</cite> to replace the
pointer through which the relative address is accessed, they can easily cause
the relative address to point wherever they want.</p></li>
</ul>
</section>
<section id="signature-forging">
<h5><a class="toc-backref" href="#id48" role="doc-backlink">Signature forging</a><a class="headerlink" href="#signature-forging" title="Link to this heading">¶</a></h5>
<p>If an attacker can exactly reproduce the behavior of the signing algorithm, and
they know all the correct inputs to it, then they can perfectly forge a
signature on an arbitrary pointer.</p>
<p>There are three components to avoiding this mistake:</p>
<ul class="simple">
<li><p>The abstract signing algorithm should be good: it should not have glaring
flaws which would allow attackers to predict its result with better than
random accuracy without knowing all the inputs (like the key values).</p></li>
<li><p>The key values should be kept secret.  If at all possible, they should never
be stored in accessible memory, or perhaps only stored encrypted.</p></li>
<li><p>Contexts that are meant to be independently protected should use different
key values.  For example, the kernel should not use the same keys as user
processes.  Different user processes should also use different keys from each
other as much as possible, although this may pose its own technical
challenges.</p></li>
</ul>
</section>
<section id="remapping">
<h5><a class="toc-backref" href="#id49" role="doc-backlink">Remapping</a><a class="headerlink" href="#remapping" title="Link to this heading">¶</a></h5>
<p>If an attacker can change the memory protections on certain pages of the
program’s memory, that can substantially weaken the protections afforded by
pointer authentication.</p>
<ul class="simple">
<li><p>If an attacker can inject their own executable code, they can also certainly
inject code that can be used as a <a class="reference internal" href="#signing-oracles"><span class="std std-ref">signing oracle</span></a>.
The same is true if they can write to the instruction stream.</p></li>
<li><p>If an attacker can remap read-only program data sections to be writable, then
any use of <a class="reference internal" href="#relative-addresses"><span class="std std-ref">Attacks on relative addressing</span></a> in global data becomes insecure.</p></li>
<li><p>On platforms that use them, if an attacker can remap the memory containing
the <a class="reference internal" href="#global-offset-tables">global offset tables</a> as writable, then any unsigned pointers in those
tables are insecure.</p></li>
</ul>
<p>Remapping memory in this way often requires the attacker to have already
substantively subverted the control flow of the process.  Nonetheless, if the
operating system has a mechanism for mapping pages in a way that cannot be
remapped, this should be used wherever possible.</p>
</section>
</section>
</section>
<section id="safe-derivation">
<span id="id5"></span><h3><a class="toc-backref" href="#id50" role="doc-backlink">Safe derivation</a><a class="headerlink" href="#safe-derivation" title="Link to this heading">¶</a></h3>
<p>Whether a data pointer is stored, even briefly, as a raw pointer can affect the
security-correctness of a program.  (Function pointers are never implicitly
stored as raw pointers; raw pointers to functions can only be produced with the
<code class="docutils literal notranslate"><span class="pre">&lt;ptrauth.h&gt;</span></code> intrinsics.)  Repeated re-signing can also impact performance.
Clang makes a modest set of guarantees in this area:</p>
<ul class="simple">
<li><p>An expression of pointer type is said to be <strong>safely derived</strong> if:</p>
<ul>
<li><p>it takes the address of a global variable or function, or</p></li>
<li><p>it is a load from a gl-value of <code class="docutils literal notranslate"><span class="pre">__ptrauth</span></code>-qualified type, or</p></li>
<li><p>it is a load from read-only memory that has been initialized from a safely
derived source, such as the <cite>data const</cite> section of a binary or library.</p></li>
</ul>
</li>
<li><p>If a value that is safely derived is assigned to a <code class="docutils literal notranslate"><span class="pre">__ptrauth</span></code>-qualified
object, including by initialization, then the value will be directly signed as
appropriate for the target qualifier and will not be stored as a raw pointer.</p></li>
<li><p>If the function expression of a call is a gl-value of <code class="docutils literal notranslate"><span class="pre">__ptrauth</span></code>-qualified
type, then the call will be authenticated directly according to the source
qualifier and will not be resigned to the default rule for a function pointer
of its type.</p></li>
</ul>
<p>These guarantees are known to be inadequate for data pointer security. In
particular, Clang should be enhanced to make the following guarantees:</p>
<ul class="simple">
<li><p>A pointer should additionally be considered safely derived if it is:</p>
<ul>
<li><p>the address of a gl-value that is safely derived,</p></li>
<li><p>the result of pointer arithmetic on a pointer that is safely derived (with
some restrictions on the integer operand),</p></li>
<li><p>the result of a comma operator where the second operand is safely derived,</p></li>
<li><p>the result of a conditional operator where the selected operand is safely
derived, or</p></li>
<li><p>the result of loading from a safely derived gl-value.</p></li>
</ul>
</li>
<li><p>A gl-value should be considered safely derived if it is:</p>
<ul>
<li><p>a dereference of a safely derived pointer,</p></li>
<li><p>a member access into a safely derived gl-value, or</p></li>
<li><p>a reference to a variable.</p></li>
</ul>
</li>
<li><p>An access to a safely derived gl-value should be guaranteed to not allow
replacement of any of the safely-derived component values at any point in the
access.  “Access” should include loading a function pointer.</p></li>
<li><p>Assignments should include pointer-arithmetic operators like <code class="docutils literal notranslate"><span class="pre">+=</span></code>.</p></li>
</ul>
<p>Making these guarantees will require further work, including significant new
support in LLVM IR.</p>
<p>Furthermore, Clang should implement a warning when assigning a data pointer that
is not safely derived to a <code class="docutils literal notranslate"><span class="pre">__ptrauth</span></code>-qualified gl-value.</p>
</section>
</section>
<section id="language-abi">
<h2><a class="toc-backref" href="#id51" role="doc-backlink">Language ABI</a><a class="headerlink" href="#language-abi" title="Link to this heading">¶</a></h2>
<p>This section describes the pointer-authentication ABI currently implemented in
Clang for the Apple arm64e target.  As other targets adopt pointer
authentication, this section should be generalized to express their ABIs as
well.</p>
<section id="key-assignments">
<h3><a class="toc-backref" href="#id52" role="doc-backlink">Key assignments</a><a class="headerlink" href="#key-assignments" title="Link to this heading">¶</a></h3>
<p>ARMv8.3 provides four abstract signing keys: <code class="docutils literal notranslate"><span class="pre">IA</span></code>, <code class="docutils literal notranslate"><span class="pre">IB</span></code>, <code class="docutils literal notranslate"><span class="pre">DA</span></code>, and <code class="docutils literal notranslate"><span class="pre">DB</span></code>.
The architecture designates <code class="docutils literal notranslate"><span class="pre">IA</span></code> and <code class="docutils literal notranslate"><span class="pre">IB</span></code> for signing code pointers and
<code class="docutils literal notranslate"><span class="pre">DA</span></code> and <code class="docutils literal notranslate"><span class="pre">DB</span></code> for signing data pointers; this is reinforced by two
properties:</p>
<ul class="simple">
<li><p>The ISA provides instructions that perform combined auth+call and auth+load
operations; these instructions can only use the <code class="docutils literal notranslate"><span class="pre">I</span></code> keys and <code class="docutils literal notranslate"><span class="pre">D</span></code> keys,
respectively.</p></li>
<li><p>AArch64’s TBI feature can be separately enabled for code pointers (controlling
whether indirect-branch instructions ignore those bits) and data pointers
(controlling whether memory-access instructions) ignore those bits. If TBI is
enabled for a kind of pointer, the sign and auth operations preserve the TBI
bits when signing with an associated keys (at the cost of shrinking the number
of available signing bits by 8).</p></li>
</ul>
<p>arm64e then further subdivides the keys as follows:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">A</span></code> keys are used for primarily “global” purposes like signing v-tables
and function pointers.  These keys are sometimes called <em>process-independent</em>
or <em>cross-process</em> because on existing OSes they are not changed when changing
processes, although this is not a platform guarantee.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">B</span></code> keys are used for primarily “local” purposes like signing return
addresses.  These keys are sometimes called <em>process-specific</em> because they
are typically different between processes. However, they are in fact shared
across processes in one situation: systems which provide <code class="docutils literal notranslate"><span class="pre">fork</span></code> cannot
change these keys in the child process; they can only be changed during
<code class="docutils literal notranslate"><span class="pre">exec</span></code>.</p></li>
</ul>
</section>
<section id="implementation-defined-algorithms-and-quantities">
<h3><a class="toc-backref" href="#id53" role="doc-backlink">Implementation-defined algorithms and quantities</a><a class="headerlink" href="#implementation-defined-algorithms-and-quantities" title="Link to this heading">¶</a></h3>
<p>The cryptographic hash algorithm used to compute signatures in ARMv8.3 is a
private detail of the hardware implementation.</p>
<p>arm64e restricts constant discriminators (used in <code class="docutils literal notranslate"><span class="pre">__ptrauth</span></code> and
<code class="docutils literal notranslate"><span class="pre">ptrauth_blend_discriminator</span></code>) to the range from 0 to 65535, inclusive.  A 0
discriminator generally signifies that no blending is required; see the
documentation for <code class="docutils literal notranslate"><span class="pre">ptrauth_blend_discriminator</span></code>.  This range is somewhat
narrow but has two advantages:</p>
<ul>
<li><p>The AArch64 ISA allows an arbitrary 16-bit immediate to be written over the
top 16 bits of a register in a single instruction:</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">movk</span><span class="w"> </span><span class="no">xN</span><span class="p">,</span><span class="w"> </span><span class="mi">#0</span><span class="no">x4849</span><span class="p">,</span><span class="w"> </span><span class="no">LSL</span><span class="w"> </span><span class="mi">48</span>
</pre></div>
</div>
<p>This is ideal for the discriminator blending operation because it adds minimal
code-size overhead and avoids overwriting any interesting bits from the
pointer.  Blending in a wider constant discriminator would either clobber
interesting bits (e.g. if it was loaded with <code class="docutils literal notranslate"><span class="pre">movk</span> <span class="pre">xN,</span> <span class="pre">#0x4c4f,</span> <span class="pre">LSL</span> <span class="pre">32</span></code>) or
require significantly more code (e.g. if the discriminator was loaded with a
<code class="docutils literal notranslate"><span class="pre">mov+bfi</span></code> sequence).</p>
</li>
<li><p>It is possible to pack a 16-bit discriminator into loader metadata with
minimal compromises, whereas a wider discriminator would require extra
metadata storage and therefore significantly impact load times.</p></li>
</ul>
<p>The string hash used by <code class="docutils literal notranslate"><span class="pre">ptrauth_string_discriminator</span></code> is a 64-bit SipHash-2-4
using the constant seed <code class="docutils literal notranslate"><span class="pre">b5d4c9eb79104a796fec8b1b428781d4</span></code> (big-endian), with
the result reduced by modulo to the range of non-zero discriminators (i.e.
<code class="docutils literal notranslate"><span class="pre">(rawHash</span> <span class="pre">%</span> <span class="pre">65535)</span> <span class="pre">+</span> <span class="pre">1</span></code>).</p>
</section>
<section id="id6">
<h3><a class="toc-backref" href="#id54" role="doc-backlink">Return addresses</a><a class="headerlink" href="#id6" title="Link to this heading">¶</a></h3>
<p>The kernel must ensure that attackers cannot replace LR due to an asynchronous
exception; see <a class="reference internal" href="#register-clobbering">Register clobbering</a>.  If this is done by generally protecting
LR, then functions which don’t spill LR to the stack can avoid signing it
entirely.  Otherwise, the return address must be signed; on arm64e it is signed
with the <code class="docutils literal notranslate"><span class="pre">IB</span></code> key using the stack pointer on entry as the discriminator.</p>
<p>Protecting return addresses is of such particular importance that the <code class="docutils literal notranslate"><span class="pre">IB</span></code> key
is almost entirely reserved for this purpose.</p>
</section>
<section id="global-offset-tables">
<h3><a class="toc-backref" href="#id55" role="doc-backlink">Global offset tables</a><a class="headerlink" href="#global-offset-tables" title="Link to this heading">¶</a></h3>
<p>The global offset table (GOT) is not part of the language ABI, but it is a
common implementation technique for dynamic linking which deserves special
discussion here.</p>
<p>Whenever possible, signed pointers should be materialized directly in code
rather than via the GOT, e.g. using an <code class="docutils literal notranslate"><span class="pre">adrp+add+pac</span></code> sequence on ARMv8.3.
This decreases the amount of work necessary at load time to initialize the GOT,
but more importantly, it defines away the potential for several attacks:</p>
<ul class="simple">
<li><p>Attackers cannot change instructions, so there is no way to cause this code
sequence to materialize a different pointer, whereas an access via the GOT
always has <em>at minimum</em> a probabilistic chance to be the target of successful
<a class="reference internal" href="#substitution-attacks">substitution attacks</a>.</p></li>
<li><p>The GOT is a dense pool of fixed pointers at a fixed offset relative to code;
attackers can search this pool for useful pointers that can be used in
<a class="reference internal" href="#substitution-attacks">substitution attacks</a>, whereas pointers that are only materialized directly
are not so easily available.</p></li>
<li><p>Similarly, attackers can use <a class="reference internal" href="#access-path-attacks">access path attacks</a> to replace a pointer to a
signed pointer with a pointer to the GOT if the signing schema used within the
GOT happens to be the same as the original pointer.  This kind of collision
becomes much less likely to be useful the fewer pointers are in the GOT in the
first place.</p></li>
</ul>
<p>If this can be done for a symbol, then the compiler need only ensure that it
materializes the signed pointer using registers that are safe against
<a class="reference internal" href="#register-clobbering">register clobbering</a>.</p>
<p>However, many symbols can only be accessed via the GOT, e.g. because they
resolve to definitions outside of the current image.  In this case, care must
be taken to ensure that using the GOT does not introduce weaknesses.</p>
<ul class="simple">
<li><p>If the entire GOT can be mapped read-only after loading, then no signing is
required within the GOT.  In fact, not signing pointers in the GOT is
preferable in this case because it makes the GOT useless for the harvesting
and access-path attacks above.  Storing raw pointers in this way is usually
extremely unsafe, but for the special case of an immutable GOT entry it’s fine
because the GOT is always accessed via an address that is directly
materialized in code and thus provably unattackable.  (But see <a class="reference internal" href="#remapping">Remapping</a>.)</p></li>
<li><p>Otherwise, GOT entries which are used for producing a signed pointer constant
must be signed.  The signing schema used in the GOT need not match the target
signing schema for the signed constant.  To counteract the threats of
substitution attacks, it’s best if GOT entries can be signed with address
diversity.  Using a good constant discriminator as well (perhaps derived from
the symbol name) can make it less useful to use a pointer to the GOT as the
replacement in an <a class="reference internal" href="#access-path-attacks"><span class="std std-ref">access path attack</span></a>.</p></li>
</ul>
<p>In either case, the compiler must ensure that materializing the address of a GOT
entry as part of producing a signed pointer constant is not vulnerable to
<a class="reference internal" href="#register-clobbering">register clobbering</a>.  If the linker also generates code for this, e.g. for
call stubs, this generated code must take the same precautions.</p>
</section>
<section id="dynamic-symbol-lookup">
<h3><a class="toc-backref" href="#id56" role="doc-backlink">Dynamic symbol lookup</a><a class="headerlink" href="#dynamic-symbol-lookup" title="Link to this heading">¶</a></h3>
<p>On platforms that support dynamically loading or resolving symbols it is
necessary for them to define the pointer authentication semantics of the APIs
provided to perform such lookups. While the platform may choose to reply
unsigned pointers from such function and rely on the caller performing the
initial signing, doing so creates the opportunity for caller side errors that
create <a class="reference internal" href="#signing-oracles"><span class="std std-ref">signing oracles</span></a>.</p>
<p>On arm64e the <cite>dlsym</cite> function is used to resolve a symbol at runtime. If the
resolved symbol is a function or other code pointer the returned pointer is
signed using the default function signing schema described in
<a class="reference internal" href="#c-function-abi"><span class="std std-ref">C function pointers</span></a>. If the resolved symbol is not a code pointer it is
returned as an unsigned pointer.</p>
</section>
<section id="c-function-abi">
<span id="id7"></span><h3><a class="toc-backref" href="#id57" role="doc-backlink">C function pointers</a><a class="headerlink" href="#c-function-abi" title="Link to this heading">¶</a></h3>
<p>On arm64e, C function pointers are currently signed with the <code class="docutils literal notranslate"><span class="pre">IA</span></code> key without
address diversity and with a constant discriminator of 0.</p>
<p>The C and C++ standards do not permit C function pointers to be signed with
address diversity by default: in C++ terms, function pointer types are required
to be trivially copyable, which means they must be copyable with <code class="docutils literal notranslate"><span class="pre">memcpy</span></code>.</p>
<p>The use of a uniform constant discriminator greatly simplifies the adoption of
arm64e, but it is a significant weakness in the mitigation because it allows any
C function pointer to be replaced with another. Clang supports
<cite>-fptrauth-function-pointer-type-discrimination</cite>, which enables a variant ABI
that uses type discrimination for function pointers. When generating the type
based discriminator for a function type all primitive integer types are
considered equivalent due to the prevalence of mismatching integer parameter
types in real world code. Type discrimination of function pointers is
ABI-incompatible with the standard arm64e ABI, but it can be used in constrained
contexts such as embedded systems or in code that does not require function
pointer interoperation with the standard ABI (e.g. because it does not pass
function pointers back and forth, or only does so through
<code class="docutils literal notranslate"><span class="pre">__ptrauth</span></code>-qualified l-values).</p>
</section>
<section id="c-virtual-tables">
<h3><a class="toc-backref" href="#id58" role="doc-backlink">C++ virtual tables</a><a class="headerlink" href="#c-virtual-tables" title="Link to this heading">¶</a></h3>
<p>By default the pointer to a C++ virtual table is currently signed with the
<code class="docutils literal notranslate"><span class="pre">DA</span></code> key, address diversity, and a constant discriminator equal to the string
hash (see <a class="reference internal" href="#ptrauth-string-discriminator">ptrauth_string_discriminator</a>) of the mangled v-table identifier
of the primary base class for the v-table. To support existing code or ABI
constraints it is possible to use the <cite>ptrauth_vtable_pointer</cite> attribute to
override the schema used for the v-table pointer of the base type of
polymorphic class hierarchy. This attribute permits the configuration of the
key, address diversity mode, and any extra constant discriminator to be used.</p>
<p>Virtual functions in a C++ virtual table are signed with the <code class="docutils literal notranslate"><span class="pre">IA</span></code> key, address
diversity, and a constant discriminator equal to the string hash (see
<a class="reference internal" href="#ptrauth-string-discriminator">ptrauth_string_discriminator</a>) of the mangled name of the function which
originally gave rise to the v-table slot.</p>
</section>
<section id="c-dynamic-cast">
<h3><a class="toc-backref" href="#id59" role="doc-backlink">C++ dynamic_cast</a><a class="headerlink" href="#c-dynamic-cast" title="Link to this heading">¶</a></h3>
<p>C++’s <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> presents a difficulty relative to other polymorphic
languages that have a
<cite>top type &lt;https://en.wikipedia.org/wiki/Any_type&gt;</cite> as the use of declaration
diversity for v-table pointers results in distinct signing schemas for each
isolated type hierarchy. As a result it is not possible for the Itanium ABI
defined <code class="docutils literal notranslate"><span class="pre">__dynamic_cast</span></code> entry point to directly authenticate the v-table
pointer of the provided object.</p>
<p>The current implementation uses a forced authentication of the subject object’s
v-table prior to invoking <code class="docutils literal notranslate"><span class="pre">__dynamic_cast</span></code> to partially verify that the
object’s vtable is valid. The <code class="docutils literal notranslate"><span class="pre">__dynamic_cast</span></code> implementation currently relies
on this caller side check to limit the substitutability of the v-table pointer
with an incorrect or invalid v-table. The subsequent implementation of the
dynamic cast algorithm is built on pointer auth protected <code class="docutils literal notranslate"><span class="pre">type_info</span></code> objects.</p>
<p>In future a richer solution may be developed to support vending the correct
authentication schema directly to the <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> implementation.</p>
</section>
<section id="c-std-type-info-v-table-pointers">
<h3><a class="toc-backref" href="#id60" role="doc-backlink">C++ std::type_info v-table pointers</a><a class="headerlink" href="#c-std-type-info-v-table-pointers" title="Link to this heading">¶</a></h3>
<p>The v-table pointer of the <code class="docutils literal notranslate"><span class="pre">std::type_info</span></code> type is signed with the <code class="docutils literal notranslate"><span class="pre">DA</span></code> key
and no additional diversity.</p>
</section>
<section id="c-member-function-pointers">
<h3><a class="toc-backref" href="#id61" role="doc-backlink">C++ member function pointers</a><a class="headerlink" href="#c-member-function-pointers" title="Link to this heading">¶</a></h3>
<p>A member function pointer is signed with the <code class="docutils literal notranslate"><span class="pre">IA</span></code> key, no address diversity,
and a constant discriminator equal to the string hash
(see <a class="reference internal" href="#ptrauth-string-discriminator">ptrauth_string_discriminator</a>) of the member pointer type.  Address
diversity is not permitted by C++ for member function pointers because they must
be trivially-copyable types.</p>
<p>The Itanium C++ ABI specifies that member function pointers to virtual functions
simply store an offset to the correct v-table slot.  This ABI cannot be used
securely with pointer authentication because there is no safe place to store the
constant discriminator for the target v-table slot: if it’s stored with the
offset, an attacker can simply overwrite it with the right discriminator for the
offset.  Even if the programmer never uses pointers to virtual functions, the
existence of this code path makes all member function pointer dereferences
insecure.</p>
<p>arm64e changes this ABI so that virtual function pointers are stored using
dispatch thunks with vague linkage.  Because arm64e supports interoperation with
<code class="docutils literal notranslate"><span class="pre">arm64</span></code> code when pointer authentication is disabled, an arm64e member
function pointer dereference still recognizes the virtual-function
representation but uses an bogus discriminator on that path that should always
trap if pointer authentication is enabled dynamically.</p>
<p>The use of dispatch thunks means that <code class="docutils literal notranslate"><span class="pre">==</span></code> on member function pointers is no
longer reliable for virtual functions, but this is acceptable because the
standard makes no guarantees about it in the first place.</p>
<p>The use of dispatch thunks also is required to support declaration specific
authentication schemas for v-table pointers.</p>
</section>
<section id="c-mangling">
<h3><a class="toc-backref" href="#id62" role="doc-backlink">C++ mangling</a><a class="headerlink" href="#c-mangling" title="Link to this heading">¶</a></h3>
<p>When the <code class="docutils literal notranslate"><span class="pre">__ptrauth</span></code> qualifier appears in a C++ mangled name,
it is mangled as a vendor qualifier with the signature
<code class="docutils literal notranslate"><span class="pre">U9__ptrauthILj&lt;key&gt;ELb&lt;addressDiscriminated&gt;ELj&lt;extraDiscriminator&gt;EE</span></code>.</p>
<p>e.g. <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">__ptrauth(1,</span> <span class="pre">0,</span> <span class="pre">1234)</span></code> will be mangled as
<code class="docutils literal notranslate"><span class="pre">U9__ptrauthILj1ELb0ELj1234EE</span></code>.</p>
<p>If the vtable pointer authentication scheme of a polymorphic class is overridden
we mangle the override information with the vendor qualifier
<code class="docutils literal notranslate"><span class="pre">__vtptrauth(int</span> <span class="pre">key,</span> <span class="pre">bool</span> <span class="pre">addressDiscriminated,</span> <span class="pre">unsigned</span> <span class="pre">extraDiscriminator)</span></code>,
where the extra discriminator is the explicit value the specified discrimination
mode evalutes to.</p>
</section>
<section id="blocks">
<h3><a class="toc-backref" href="#id63" role="doc-backlink">Blocks</a><a class="headerlink" href="#blocks" title="Link to this heading">¶</a></h3>
<p>Block pointers are data pointers which must interoperate with the ObjC <cite>id</cite> type
and therefore cannot be signed themselves. As blocks conform to the ObjC <cite>id</cite>
type, they contain an <code class="docutils literal notranslate"><span class="pre">isa</span></code> pointer signed as described
<a class="reference internal" href="#objc-isa-and-super"><span class="std std-ref">below</span></a>.</p>
<p>The invocation pointer in a block is signed with the <code class="docutils literal notranslate"><span class="pre">IA</span></code> key using address
diversity and a constant dicriminator of 0.  Using a uniform discriminator is
seen as a weakness to be potentially improved, but this is tricky due to the
subtype polymorphism directly permitted for blocks.</p>
<p>Block descriptors and <code class="docutils literal notranslate"><span class="pre">__block</span></code> variables can contain pointers to functions
that can be used to copy or destroy the object.  These functions are signed with
the <code class="docutils literal notranslate"><span class="pre">IA</span></code> key, address diversity, and a constant discriminator of 0.  The
structure of block descriptors is under consideration for improvement.</p>
</section>
<section id="objective-c-runtime">
<h3><a class="toc-backref" href="#id64" role="doc-backlink">Objective-C runtime</a><a class="headerlink" href="#objective-c-runtime" title="Link to this heading">¶</a></h3>
<p>In addition to the compile time ABI design, the Objective-C runtime provides
additional protection to methods and other metadata that have been loaded into
the Objective-C method cache; this protection is private to the runtime.</p>
</section>
<section id="objective-c-methods">
<h3><a class="toc-backref" href="#id65" role="doc-backlink">Objective-C methods</a><a class="headerlink" href="#objective-c-methods" title="Link to this heading">¶</a></h3>
<p>Objective-C method lists sign methods with the <code class="docutils literal notranslate"><span class="pre">IA</span></code> key using address
diversity and a constant discriminator of 0.  Using a uniform constant
discriminator is believed to be acceptable because these tables are only
accessed internally to the Objective-C runtime.</p>
</section>
<section id="objective-c-class-method-list-pointer">
<h3><a class="toc-backref" href="#id66" role="doc-backlink">Objective-C class method list pointer</a><a class="headerlink" href="#objective-c-class-method-list-pointer" title="Link to this heading">¶</a></h3>
<p>The method list pointer in Objective-C classes are signed with the <code class="docutils literal notranslate"><span class="pre">DA</span></code> key
using address diversity, and a constant discriminator of 0xC310.</p>
</section>
<section id="objective-c-class-read-only-data-pointer">
<h3><a class="toc-backref" href="#id67" role="doc-backlink">Objective-C class read-only data pointer</a><a class="headerlink" href="#objective-c-class-read-only-data-pointer" title="Link to this heading">¶</a></h3>
<p>The read-only data pointer in Objective-C classes are signed with the <code class="docutils literal notranslate"><span class="pre">DA</span></code> key
using address diversity, and a constant discriminator of 0x61F8.</p>
</section>
<section id="objective-c-isa-and-super-pointers">
<span id="objc-isa-and-super"></span><h3><a class="toc-backref" href="#id68" role="doc-backlink">Objective-C <code class="docutils literal notranslate"><span class="pre">isa</span></code> and <code class="docutils literal notranslate"><span class="pre">super</span></code> pointers</a><a class="headerlink" href="#objective-c-isa-and-super-pointers" title="Link to this heading">¶</a></h3>
<p>An Objective-C object’s <code class="docutils literal notranslate"><span class="pre">isa</span></code> and <code class="docutils literal notranslate"><span class="pre">super</span></code> pointers are both signed with
the <code class="docutils literal notranslate"><span class="pre">DA</span></code> key using address diversity and constant discriminators of 0x6AE1
and 0x25DA respectively.</p>
</section>
<section id="objective-c-sel-pointers">
<h3><a class="toc-backref" href="#id69" role="doc-backlink">Objective-C <code class="docutils literal notranslate"><span class="pre">SEL</span></code> pointers</a><a class="headerlink" href="#objective-c-sel-pointers" title="Link to this heading">¶</a></h3>
<p>By default, the type of an Objective-C instance variable of type <code class="docutils literal notranslate"><span class="pre">SEL</span></code>, when
the qualifiers do not include an explicit <code class="docutils literal notranslate"><span class="pre">__ptrauth</span></code> qualifier, is adjusted
to be qualified with <code class="docutils literal notranslate"><span class="pre">__ptrauth(ptrauth_key_asdb,</span> <span class="pre">1,</span> <span class="pre">0x57C2)</span></code>.</p>
<p>This provides a measure of implicit at-rest protection to  Objective-C classes
that store selectors, as in the common target-action design pattern. This
prevents attackers from overriding the selector to invoke an arbitrary different
method, which is a major attack vector in Objective-C. Since <code class="docutils literal notranslate"><span class="pre">SEL</span></code> values are
not normally passed around as signed pointers, there is a
<a class="reference internal" href="#signing-oracles"><span class="std std-ref">signing oracle</span></a> associated with the initialization of the
ivar, but the use of address and constant diversity limit the risks.</p>
<p>The implicit qualifier means that the type of the ivar does not match its
declaration, which can cause type errors if the address of the ivar is taken:</p>
<div class="highlight-ObjC notranslate"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="nc">A</span> : <span class="bp">NSObject</span> <span class="p">{</span>
<span class="w">  </span><span class="kt">SEL</span><span class="w"> </span><span class="n">_s</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="kt">void</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="kt">SEL</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>

<span class="k">@implementation</span> <span class="nc">A</span>
<span class="p">-(</span><span class="kt">void</span><span class="p">)</span><span class="nf">g</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_s</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>
</pre></div>
</div>
<p>To fix such an mismatch the schema macro from <cite>&lt;ptrauth.h&gt;</cite>:</p>
<div class="highlight-ObjC notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ptrauth.h&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="kt">SEL</span><span class="w"> </span><span class="n">__ptrauth_objc_sel</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>or less safely, and introducing the possibility of an
<a class="reference internal" href="#signing-oracles"><span class="std std-ref">signing or authentication oracle</span></a>, an unauthencaticated
temporary may be used as intermediate storage.</p>
</section>
</section>
<section id="alternative-implementations">
<h2><a class="toc-backref" href="#id70" role="doc-backlink">Alternative implementations</a><a class="headerlink" href="#alternative-implementations" title="Link to this heading">¶</a></h2>
<section id="signature-storage">
<h3><a class="toc-backref" href="#id71" role="doc-backlink">Signature storage</a><a class="headerlink" href="#signature-storage" title="Link to this heading">¶</a></h3>
<p>It is not critical for the security of pointer authentication that the
signature be stored “together” with the pointer, as it is in Armv8.3. An
implementation could just as well store the signature in a separate word, so
that the <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> a signed pointer would be larger than the <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> a raw
pointer.</p>
<p>Storing the signature in the high bits, as Armv8.3 does, has several trade-offs:</p>
<ul class="simple">
<li><p>Disadvantage: there are substantially fewer bits available for the signature,
weakening the mitigation by making it much easier for an attacker to simply
guess the correct signature.</p></li>
<li><p>Disadvantage: future growth of the address space will necessarily further
weaken the mitigation.</p></li>
<li><p>Advantage: memory layouts don’t change, so it’s possible for
pointer-authentication-enabled code (for example, in a system library) to
efficiently interoperate with existing code, as long as pointer
authentication can be disabled dynamically.</p></li>
<li><p>Advantage: the size of a signed pointer doesn’t grow, which might
significantly increase memory requirements, code size, and register pressure.</p></li>
<li><p>Advantage: the size of a signed pointer is the same as a raw pointer, so
generic APIs which work in types like <cite>void *</cite> (such as <cite>dlsym</cite>) can still
return signed pointers.  This means that clients of these APIs will not
require insecure code in order to correctly receive a function pointer.</p></li>
</ul>
</section>
<section id="hashing-vs-encrypting-pointers">
<h3><a class="toc-backref" href="#id72" role="doc-backlink">Hashing vs. encrypting pointers</a><a class="headerlink" href="#hashing-vs-encrypting-pointers" title="Link to this heading">¶</a></h3>
<p>Armv8.3 implements <code class="docutils literal notranslate"><span class="pre">sign</span></code> by computing a cryptographic hash and storing that
in the spare bits of the pointer.  This means that there are relatively few
possible values for the valid signed pointer, since the bits corresponding to
the raw pointer are known.  Together with an <code class="docutils literal notranslate"><span class="pre">auth</span></code> oracle, this can make it
computationally feasible to discover the correct signature with brute force.
(The implementation should of course endeavor not to introduce <code class="docutils literal notranslate"><span class="pre">auth</span></code>
oracles, but this can be difficult, and attackers can be devious.)</p>
<p>If the implementation can instead <em>encrypt</em> the pointer during <code class="docutils literal notranslate"><span class="pre">sign</span></code> and
<em>decrypt</em> it during <code class="docutils literal notranslate"><span class="pre">auth</span></code>, this brute-force attack becomes far less
feasible, even with an <code class="docutils literal notranslate"><span class="pre">auth</span></code> oracle.  However, there are several problems
with this idea:</p>
<ul class="simple">
<li><p>It’s unclear whether this kind of encryption is even possible without
increasing the storage size of a signed pointer.  If the storage size can be
increased, brute-force attacks can be equally well mitigated by simply storing
a larger signature.</p></li>
<li><p>It would likely be impossible to implement a <code class="docutils literal notranslate"><span class="pre">strip</span></code> operation, which might
make debuggers and other out-of-process tools far more difficult to write, as
well as generally making primitive debugging more challenging.</p></li>
<li><p>Implementations can benefit from being able to extract the raw pointer
immediately from a signed pointer.  An Armv8.3 processor executing an
<code class="docutils literal notranslate"><span class="pre">auth</span></code>-and-load instruction can perform the load and <code class="docutils literal notranslate"><span class="pre">auth</span></code> in parallel;
a processor which instead encrypted the pointer would be forced to perform
these operations serially.</p></li>
</ul>
</section>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="AutomaticReferenceCounting.html">Objective-C Automatic Reference Counting (ARC)</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="MatrixTypes.html">Matrix Types</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2007-2025, The Clang Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>