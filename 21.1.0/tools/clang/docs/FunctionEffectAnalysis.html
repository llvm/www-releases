<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Function Effect Analysis &#8212; Clang 21.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=e491ac2d" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=eafc0fe6" />
    <script src="_static/documentation_options.js?v=c54a4614"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="AddressSanitizer" href="AddressSanitizer.html" />
    <link rel="prev" title="Data flow analysis: an informal introduction" href="DataFlowAnalysisIntro.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Clang 21.1.0 documentation</span></a></h1>
        <h2 class="heading"><span>Function Effect Analysis</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="DataFlowAnalysisIntro.html">Data flow analysis: an informal introduction</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="AddressSanitizer.html">AddressSanitizer</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="function-effect-analysis">
<h1>Function Effect Analysis<a class="headerlink" href="#function-effect-analysis" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id1">Introduction</a></p></li>
<li><p><a class="reference internal" href="#the-nonblocking-and-nonallocating-attributes" id="id2">The <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> and <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code> attributes</a></p>
<ul>
<li><p><a class="reference internal" href="#attribute-syntax" id="id3">Attribute syntax</a></p></li>
<li><p><a class="reference internal" href="#attribute-semantics" id="id4">Attribute semantics</a></p></li>
<li><p><a class="reference internal" href="#type-conversions" id="id5">Type conversions</a></p></li>
<li><p><a class="reference internal" href="#virtual-methods" id="id6">Virtual methods</a></p></li>
<li><p><a class="reference internal" href="#redeclarations-overloads-and-name-mangling" id="id7">Redeclarations, overloads, and name mangling</a></p></li>
<li><p><a class="reference internal" href="#objective-c" id="id8">Objective-C</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#analysis-and-warnings" id="id9">Analysis and warnings</a></p>
<ul>
<li><p><a class="reference internal" href="#constraints" id="id10">Constraints</a></p></li>
<li><p><a class="reference internal" href="#inferring-nonblocking-or-nonallocating" id="id11">Inferring <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> or <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code></a></p></li>
<li><p><a class="reference internal" href="#lambdas-and-blocks" id="id12">Lambdas and blocks</a></p></li>
<li><p><a class="reference internal" href="#implicit-function-calls-in-the-ast" id="id13">Implicit function calls in the AST</a></p></li>
<li><p><a class="reference internal" href="#disabling-diagnostics" id="id14">Disabling diagnostics</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#adoption" id="id15">Adoption</a></p>
<ul>
<li><p><a class="reference internal" href="#c-exceptions" id="id16">C++ exceptions</a></p></li>
<li><p><a class="reference internal" href="#std-function-r-args" id="id17"><code class="docutils literal notranslate"><span class="pre">std::function&lt;R(Args...)&gt;</span></code></a></p></li>
<li><p><a class="reference internal" href="#interactions-with-type-erasure-techniques" id="id18">Interactions with type-erasure techniques</a></p></li>
<li><p><a class="reference internal" href="#static-local-variables" id="id19">Static local variables</a></p></li>
<li><p><a class="reference internal" href="#annotating-libraries" id="id20">Annotating libraries</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>Clang Function Effect Analysis is a language extension which can warn about “unsafe”
constructs. The feature is currently tailored for the Performance Constraint attributes
<code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> and <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code>; functions with these attributes are verified as not
containing any language constructs or calls to other functions which violate the constraint.
(See <a class="reference internal" href="AttributeReference.html"><span class="doc">Attributes in Clang</span></a>.)</p>
</section>
<section id="the-nonblocking-and-nonallocating-attributes">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> and <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code> attributes</a><a class="headerlink" href="#the-nonblocking-and-nonallocating-attributes" title="Link to this heading">¶</a></h2>
<section id="attribute-syntax">
<h3><a class="toc-backref" href="#id3" role="doc-backlink">Attribute syntax</a><a class="headerlink" href="#attribute-syntax" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> and <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code> attributes apply to function types, allowing them to be
attached to functions, blocks, function pointers, lambdas, and member functions.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Functions</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">nonblockingFunction</span><span class="p">()</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonblocking</span><span class="p">]];</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">nonallocatingFunction</span><span class="p">()</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonallocating</span><span class="p">]];</span>

<span class="c1">// Function pointers</span>
<span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">nonblockingFunctionPtr</span><span class="p">)()</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonblocking</span><span class="p">]];</span>

<span class="c1">// Typedefs, type aliases.</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">NBFunctionPtrTypedef</span><span class="p">)()</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonblocking</span><span class="p">]];</span>
<span class="k">using</span><span class="w"> </span><span class="n">NBFunctionPtrTypeAlias_gnu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">nonblocking</span><span class="p">))</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)();</span>
<span class="k">using</span><span class="w"> </span><span class="n">NBFunctionPtrTypeAlias_std</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)()</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonblocking</span><span class="p">]];</span>

<span class="c1">// C++ methods</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">NBMethod</span><span class="p">()</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonblocking</span><span class="p">]];</span>
<span class="p">};</span>

<span class="c1">// C++ lambdas</span>
<span class="k">auto</span><span class="w"> </span><span class="n">nbLambda</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]()</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonblocking</span><span class="p">]]</span><span class="w"> </span><span class="p">{};</span>

<span class="c1">// Blocks</span>
<span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">^</span><span class="n">nbBlock</span><span class="p">)()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">^</span><span class="p">()</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonblocking</span><span class="p">]]</span><span class="w"> </span><span class="p">{};</span>
</pre></div>
</div>
<p>The attribute applies only to the function itself. In particular, it does not apply to any nested
functions or declarations, such as blocks, lambdas, and local classes.</p>
<p>This document uses the C++/C23 syntax <code class="docutils literal notranslate"><span class="pre">[[clang::nonblocking]]</span></code>, since it parallels the placement
of the <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> specifier, and the attributes have other similarities to <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>. The GNU
<code class="docutils literal notranslate"><span class="pre">__attribute__((nonblocking))</span></code> syntax is also supported. Note that it requires a different
placement on a C++ type alias.</p>
<p>Like <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>, <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> and <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code> have an optional argument, a compile-time
constant boolean expression. By default, the argument is <code class="docutils literal notranslate"><span class="pre">true</span></code>, so <code class="docutils literal notranslate"><span class="pre">[[clang::nonblocking]]</span></code>
is equivalent to <code class="docutils literal notranslate"><span class="pre">[[clang::nonblocking(true)]]</span></code>, and declares the function type as never blocking.</p>
</section>
<section id="attribute-semantics">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">Attribute semantics</a><a class="headerlink" href="#attribute-semantics" title="Link to this heading">¶</a></h3>
<p>Together with <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>, the <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code> and <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> attributes define an ordered
series of performance constraints. From weakest to strongest:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">noexcept</span></code> (as per the C++ standard): The function type will never throw an exception.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nonallocating</span></code>: The function type will never allocate memory on the heap or throw an
exception.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nonblocking</span></code>: The function type will never block on a lock, allocate memory on the heap,
or throw an exception.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> includes the <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code> guarantee.</p>
<p>While <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> and <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code> are conceptually a superset of <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>, neither
attribute implicitly specifies <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>. Further, <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> has a specified runtime behavior of
aborting if an exception is thrown, while the <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code> and <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> attributes are
mainly for compile-time analysis and have no runtime behavior, except in code built
with Clang’s <a class="reference internal" href="RealtimeSanitizer.html"><span class="doc">RealtimeSanitizer</span></a>. Nonetheless, Clang emits a
warning if, in C++, a function is declared <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> or <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code> without
<code class="docutils literal notranslate"><span class="pre">noexcept</span></code>. This diagnostic is controlled by <code class="docutils literal notranslate"><span class="pre">-Wperf-constraint-implies-noexcept</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">nonblocking(true)</span></code> and <code class="docutils literal notranslate"><span class="pre">nonallocating(true)</span></code> apply to function <em>types</em>, and by extension, to
function-like declarations. When applied to a declaration with a body, the compiler verifies the
function, as described in the section “Analysis and warnings”, below.</p>
<p><code class="docutils literal notranslate"><span class="pre">blocking</span></code> and <code class="docutils literal notranslate"><span class="pre">allocating</span></code> are synonyms for <code class="docutils literal notranslate"><span class="pre">nonblocking(false)</span></code> and
<code class="docutils literal notranslate"><span class="pre">nonallocating(false)</span></code>, respectively. They can be used on a function-like declaration to
explicitly disable any potential inference of <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> or <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code> during
verification. (Inference is described later in this document). <code class="docutils literal notranslate"><span class="pre">nonblocking(false)</span></code> and
<code class="docutils literal notranslate"><span class="pre">nonallocating(false)</span></code> are legal, but superfluous  when applied to a function <em>type</em>
that is not part of a declarator: <code class="docutils literal notranslate"><span class="pre">float</span> <span class="pre">(int)</span> <span class="pre">[[nonblocking(false)]]</span></code> and
<code class="docutils literal notranslate"><span class="pre">float</span> <span class="pre">(int)</span></code> are identical types.</p>
<p>For functions with no explicit performance constraint, the worst is assumed: the function
allocates memory and potentially blocks, unless it can be inferred otherwise. This is detailed in the
discussion of verification.</p>
<p>The following example describes the meanings of all permutations of the two attributes and arguments:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">nb1_na1</span><span class="p">()</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonblocking</span><span class="p">(</span><span class="nb">true</span><span class="p">)]]</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonallocating</span><span class="p">(</span><span class="nb">true</span><span class="p">)]];</span>
<span class="c1">// Valid; nonallocating(true) is superfluous but doesn&#39;t contradict the guarantee.</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">nb1_na0</span><span class="p">()</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonblocking</span><span class="p">(</span><span class="nb">true</span><span class="p">)]]</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonallocating</span><span class="p">(</span><span class="nb">false</span><span class="p">)]];</span>
<span class="c1">// error: &#39;allocating&#39; and &#39;nonblocking&#39; attributes are not compatible</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">nb0_na1</span><span class="p">()</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonblocking</span><span class="p">(</span><span class="nb">false</span><span class="p">)]]</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonallocating</span><span class="p">(</span><span class="nb">true</span><span class="p">)]];</span>
<span class="c1">// Valid; the function does not allocate memory, but may lock for other reasons.</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">nb0_na0</span><span class="p">()</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonblocking</span><span class="p">(</span><span class="nb">false</span><span class="p">)]]</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonallocating</span><span class="p">(</span><span class="nb">false</span><span class="p">)]];</span>
<span class="c1">// Valid.</span>
</pre></div>
</div>
</section>
<section id="type-conversions">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">Type conversions</a><a class="headerlink" href="#type-conversions" title="Link to this heading">¶</a></h3>
<p>A performance constraint can be removed or weakened via an implicit conversion. An attempt to add
or strengthen a performance constraint is unsafe and results in a warning. The rules for this
are comparable to that for <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> in C++17 and later.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">unannotated</span><span class="p">();</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">nonblocking</span><span class="p">()</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonblocking</span><span class="p">]];</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">nonallocating</span><span class="p">()</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonallocating</span><span class="p">]];</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">example</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// It&#39;s fine to remove a performance constraint.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fp_plain</span><span class="p">)();</span>
<span class="w">  </span><span class="n">fp_plain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unannotated</span><span class="p">;</span>
<span class="w">  </span><span class="n">fp_plain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nonblocking</span><span class="p">;</span>
<span class="w">  </span><span class="n">fp_plain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nonallocating</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Adding/spoofing nonblocking is unsafe.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fp_nonblocking</span><span class="p">)()</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonblocking</span><span class="p">]];</span>
<span class="w">  </span><span class="n">fp_nonblocking</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">  </span><span class="n">fp_nonblocking</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nonblocking</span><span class="p">;</span>
<span class="w">  </span><span class="n">fp_nonblocking</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unannotated</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// ^ warning: attribute &#39;nonblocking&#39; should not be added via type conversion</span>
<span class="w">  </span><span class="n">fp_nonblocking</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nonallocating</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// ^ warning: attribute &#39;nonblocking&#39; should not be added via type conversion</span>

<span class="w">  </span><span class="c1">// Adding/spoofing nonallocating is unsafe.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fp_nonallocating</span><span class="p">)()</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonallocating</span><span class="p">]];</span>
<span class="w">  </span><span class="n">fp_nonallocating</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">  </span><span class="n">fp_nonallocating</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nonallocating</span><span class="p">;</span>
<span class="w">  </span><span class="n">fp_nonallocating</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nonblocking</span><span class="p">;</span><span class="w"> </span><span class="c1">// no warning because nonblocking includes nonallocating</span>
<span class="w">  </span><span class="n">fp_nonallocating</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">unannotated</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// ^ warning: attribute &#39;nonallocating&#39; should not be added via type conversion</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="virtual-methods">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">Virtual methods</a><a class="headerlink" href="#virtual-methods" title="Link to this heading">¶</a></h3>
<p>In C++, when a virtual method has a performance constraint, overriding methods in
subclasses inherit the constraint.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Base</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">unsafe</span><span class="p">();</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">safe</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonblocking</span><span class="p">]];</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Derived</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">unsafe</span><span class="p">()</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonblocking</span><span class="p">]]</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// It&#39;s okay for an overridden method to be more constrained</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">safe</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// This method is implicitly declared `nonblocking`, inherited from Base.</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="redeclarations-overloads-and-name-mangling">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Redeclarations, overloads, and name mangling</a><a class="headerlink" href="#redeclarations-overloads-and-name-mangling" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> and <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code> attributes, like <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>, do not factor into
argument-dependent lookup and overloaded functions/methods.</p>
<p>First, consider that <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> is integral to a function’s type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">f1</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">f1</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>
<span class="c1">// error: exception specification in declaration does not match previous</span>
<span class="c1">//   declaration</span>
</pre></div>
</div>
<p>Unlike <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>, a redeclaration of <code class="docutils literal notranslate"><span class="pre">f2</span></code> with an added or stronger performance constraint is
legal and propagates the attribute to the previous declaration:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">f2</span><span class="p">();</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">f2</span><span class="p">()</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonblocking</span><span class="p">]];</span><span class="w"> </span><span class="c1">// redeclaration with stronger constraint is OK.</span>
</pre></div>
</div>
<p>This greatly eases adoption by making it possible to annotate functions in external libraries
without modifying library headers.</p>
<p>A redeclaration with a removed or weaker performance constraint produces a warning, paralleling
the behavior of <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">f2</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="c1">// warning: attribute &#39;nonblocking&#39; on function does not match previous declaration</span>
</pre></div>
</div>
<p>In C++14, the following two declarations of <cite>f3</cite> are identical (a single function). In C++17 they
are separate overloads:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">f3</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)());</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">f3</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)()</span><span class="w"> </span><span class="k">noexcept</span><span class="p">);</span>
</pre></div>
</div>
<p>Similarly, the following two declarations of <cite>f4</cite> are separate overloads. This pattern may pose
difficulties due to ambiguity:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">f4</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)());</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">f4</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)()</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonblocking</span><span class="p">]]);</span>
</pre></div>
</div>
<p>The attributes have no effect on the mangling of function and method names.</p>
</section>
<section id="objective-c">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Objective-C</a><a class="headerlink" href="#objective-c" title="Link to this heading">¶</a></h3>
<p>The attributes are currently unsupported on Objective-C methods.</p>
</section>
</section>
<section id="analysis-and-warnings">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">Analysis and warnings</a><a class="headerlink" href="#analysis-and-warnings" title="Link to this heading">¶</a></h2>
<section id="constraints">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Constraints</a><a class="headerlink" href="#constraints" title="Link to this heading">¶</a></h3>
<p>Functions declared <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code> or <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code>, when defined, are verified according to the
following rules. Such functions:</p>
<ol class="arabic simple">
<li><p>May not allocate or deallocate memory on the heap. The analysis follows the calls to
<code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">new</span></code> and <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">delete</span></code> generated by the <code class="docutils literal notranslate"><span class="pre">new</span></code> and <code class="docutils literal notranslate"><span class="pre">delete</span></code> keywords, and
treats them like any other function call. The global <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">new</span></code> and <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">delete</span></code>
aren’t declared <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> or <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code> and so they are considered unsafe. (This
is correct because most memory allocators are not lock-free. Note that the placement form of
<code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">new</span></code> is implemented inline in libc++’s <code class="docutils literal notranslate"><span class="pre">&lt;new&gt;</span></code> header, and is verifiably
<code class="docutils literal notranslate"><span class="pre">nonblocking</span></code>, since it merely casts the supplied pointer to the result type.)</p></li>
<li><p>May not throw or catch exceptions. To throw, the compiler must allocate the exception on the
heap. (Also, many subclasses of <code class="docutils literal notranslate"><span class="pre">std::exception</span></code> allocate a string). Exceptions are
deallocated when caught.</p></li>
<li><p>May not make any indirect function call, via a virtual method, function pointer, or
pointer-to-member function, unless the target is explicitly declared with the same
<code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> or <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code> attribute (or stronger).</p></li>
<li><p>May not make direct calls to any other function, with the following exceptions:</p></li>
</ol>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>The callee is also explicitly declared with the same <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> or <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code>
attribute (or stronger).</p></li>
<li><p>The callee is defined in the same translation unit as the caller, does not have the <code class="docutils literal notranslate"><span class="pre">false</span></code>
form of the required attribute, and can be verified to have the same attribute or stronger,
according to these same rules.</p></li>
<li><p>The callee is a built-in function that is known not to block or allocate.</p></li>
<li><p>The callee is declared <code class="docutils literal notranslate"><span class="pre">noreturn</span></code> and, if compiling C++, the callee is also declared
<code class="docutils literal notranslate"><span class="pre">noexcept</span></code>. This special case excludes functions such as <code class="docutils literal notranslate"><span class="pre">abort()</span></code> and <code class="docutils literal notranslate"><span class="pre">std::terminate()</span></code>
from the analysis. (The reason for requiring <code class="docutils literal notranslate"><span class="pre">noexcept</span></code> in C++ is that a function declared
<code class="docutils literal notranslate"><span class="pre">noreturn</span></code> could be a wrapper for <code class="docutils literal notranslate"><span class="pre">throw</span></code>.)</p></li>
</ol>
</div></blockquote>
<ol class="arabic simple" start="5">
<li><p>May not invoke or access an Objective-C method or property, since <code class="docutils literal notranslate"><span class="pre">objc_msgSend()</span></code> calls into
the Objective-C runtime, which may allocate memory or otherwise block.</p></li>
<li><p>May not access thread-local variables. Typically, thread-local variables are allocated on the
heap when first accessed.</p></li>
</ol>
<p>Functions declared <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> have an additional constraint:</p>
<ol class="arabic simple" start="7">
<li><p>May not declare static local variables (e.g. Meyers singletons). The compiler generates a lock
protecting the initialization of the variable.</p></li>
</ol>
<p>Violations of any of these rules result in warnings, in the <code class="docutils literal notranslate"><span class="pre">-Wfunction-effects</span></code> category:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">notInline</span><span class="p">();</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">example</span><span class="p">()</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonblocking</span><span class="p">]]</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// warning: function with &#39;nonblocking&#39; attribute must not allocate or deallocate</span>
<span class="w">  </span><span class="c1">//   memory</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">Logger</span><span class="o">*</span><span class="w"> </span><span class="n">logger</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">createLogger</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// warning: function with &#39;nonblocking&#39; attribute must not have static local variables</span>

<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_warning</span><span class="p">{</span><span class="w"> </span><span class="s">&quot;null&quot;</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="c1">// warning: &#39;nonblocking&quot; function &#39;example&#39; must not throw exceptions</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">notInline</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// warning: &#39;function with &#39;nonblocking&#39; attribute must not call non-&#39;nonblocking&#39; function</span>
<span class="w">  </span><span class="c1">//   &#39;notInline&#39;</span>
<span class="w">  </span><span class="c1">// note (on notInline()): declaration cannot be inferred &#39;nonblocking&#39; because it has no</span>
<span class="w">  </span><span class="c1">//   definition in this translation unit</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="inferring-nonblocking-or-nonallocating">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Inferring <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> or <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code></a><a class="headerlink" href="#inferring-nonblocking-or-nonallocating" title="Link to this heading">¶</a></h3>
<p>In the absence of a <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> or <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code> attribute (whether <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code>),
a function that is called from a performance-constrained function may be analyzed to
infer whether it has a desired attribute. This analysis happens when the function is not a virtual
method, and it has a visible definition within the current translation unit (i.e. its body can be
traversed).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">notInline</span><span class="p">();</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">implicitlySafe</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">implicitlyUnsafe</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">notInline</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">example</span><span class="p">()</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonblocking</span><span class="p">]]</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">implicitlySafe</span><span class="p">();</span><span class="w"> </span><span class="c1">// OK</span>
<span class="w">  </span><span class="n">implicitlyUnsafe</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// warning: function with &#39;nonblocking&#39; attribute must not call non-&#39;nonblocking&#39; function</span>
<span class="w">  </span><span class="c1">//   &#39;implicitlyUnsafe&#39;</span>
<span class="w">  </span><span class="c1">// note (on implicitlyUnsafe): function cannot be inferred &#39;nonblocking&#39; because it calls</span>
<span class="w">  </span><span class="c1">//   non-&#39;nonblocking&#39; function &#39;notInline&#39;</span>
<span class="w">  </span><span class="c1">// note (on notInline()): declaration cannot be inferred &#39;nonblocking&#39; because it has no</span>
<span class="w">  </span><span class="c1">//   definition in this translation unit</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="lambdas-and-blocks">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Lambdas and blocks</a><a class="headerlink" href="#lambdas-and-blocks" title="Link to this heading">¶</a></h3>
<p>As mentioned earlier, the performance constraint attributes apply only to a single function and not
to any code nested inside it, including blocks, lambdas, and local classes. It is possible for a
nonblocking function to schedule the execution of a blocking lambda on another thread. Similarly, a
blocking function may create a <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> lambda for use in a realtime context.</p>
<p>Operations which create, destroy, copy, and move lambdas and blocks are analyzed in terms of the
underlying function calls. For example, the creation of a lambda with captures generates a function
call to an anonymous struct’s constructor, passing the captures as parameters.</p>
</section>
<section id="implicit-function-calls-in-the-ast">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Implicit function calls in the AST</a><a class="headerlink" href="#implicit-function-calls-in-the-ast" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> / <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code> analysis occurs at the Sema phase of analysis in Clang.
During Sema, there are some constructs which will eventually become function calls, but do not
appear as function calls in the AST. For example, <code class="docutils literal notranslate"><span class="pre">auto*</span> <span class="pre">foo</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">Foo;</span></code> becomes a declaration
containing a <code class="docutils literal notranslate"><span class="pre">CXXNewExpr</span></code> which is understood as a function call to the global <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">new</span></code>
(in this example), and a <code class="docutils literal notranslate"><span class="pre">CXXConstructExpr</span></code>, which, for analysis purposes, is a function call to
<code class="docutils literal notranslate"><span class="pre">Foo</span></code>’s constructor. Most gaps in the analysis would be due to incomplete knowledge of AST
constructs which become function calls.</p>
</section>
<section id="disabling-diagnostics">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Disabling diagnostics</a><a class="headerlink" href="#disabling-diagnostics" title="Link to this heading">¶</a></h3>
<p>Function effect diagnostics are controlled by <code class="docutils literal notranslate"><span class="pre">-Wfunction-effects</span></code>.</p>
<p>A construct like this can be used to exempt code from the checks described here:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define NONBLOCKING_UNSAFE(...)                                    \</span>
<span class="cp">  _Pragma(&quot;clang diagnostic push&quot;)                                 \</span>
<span class="cp">  _Pragma(&quot;clang diagnostic ignored \&quot;-Wunknown-warning-option\&quot;&quot;) \</span>
<span class="cp">  _Pragma(&quot;clang diagnostic ignored \&quot;-Wfunction-effects\&quot;&quot;)       \</span>
<span class="cp">  __VA_ARGS__                                                      \</span>
<span class="cp">  _Pragma(&quot;clang diagnostic pop&quot;)</span>
</pre></div>
</div>
<p>Disabling the diagnostic allows for:</p>
<ul class="simple">
<li><p>constructs which do block, but which in practice are used in ways to avoid unbounded blocking,
e.g. a thread pool with semaphores to coordinate multiple realtime threads;</p></li>
<li><p>using libraries which are safe but not yet annotated;</p></li>
<li><p>incremental adoption in a large codebase.</p></li>
</ul>
</section>
</section>
<section id="adoption">
<h2><a class="toc-backref" href="#id15" role="doc-backlink">Adoption</a><a class="headerlink" href="#adoption" title="Link to this heading">¶</a></h2>
<p>There are a few common issues that arise when adopting the <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> and <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code>
attributes.</p>
<section id="c-exceptions">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">C++ exceptions</a><a class="headerlink" href="#c-exceptions" title="Link to this heading">¶</a></h3>
<p>Exceptions pose a challenge to the adoption of the performance constraints. Common library functions
which throw exceptions include:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Method</p></th>
<th class="head"><p>Alternative</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">std::vector&lt;T&gt;::at()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">operator[](size_t)</span></code>, after verifying that the index is in range.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">std::optional&lt;T&gt;::value()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">operator*</span></code>, after checking <code class="docutils literal notranslate"><span class="pre">has_value()</span></code> or <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">bool()</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">std::expected&lt;T,</span> <span class="pre">E&gt;::value()</span></code></p></td>
<td><p>Same as for <code class="docutils literal notranslate"><span class="pre">std::optional&lt;T&gt;::value()</span></code>.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="std-function-r-args">
<h3><a class="toc-backref" href="#id17" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">std::function&lt;R(Args...)&gt;</span></code></a><a class="headerlink" href="#std-function-r-args" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">std::function&lt;R(Args...)&gt;</span></code> is generally incompatible with <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> and <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code>
code, because a typical implementation may allocate heap memory in the constructor.</p>
<p>Alternatives:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">std::function_ref</span></code> (available in C++26 or as <code class="docutils literal notranslate"><span class="pre">llvm::function_ref</span></code>). This is appropriate and
optimal when a functor’s lifetime does not need to extend past the function that created it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inplace_function</span></code> from WG14. This solves the allocation problem by giving the functor wrapper
a fixed size known at compile time and using an inline buffer.</p></li>
</ul>
<p>While these alternatives both address the heap allocation of <code class="docutils literal notranslate"><span class="pre">std::function</span></code>, they are still
obstacles to <code class="docutils literal notranslate"><span class="pre">nonblocking/nonallocating</span></code> verification, for reasons detailed in the next section.</p>
</section>
<section id="interactions-with-type-erasure-techniques">
<h3><a class="toc-backref" href="#id18" role="doc-backlink">Interactions with type-erasure techniques</a><a class="headerlink" href="#interactions-with-type-erasure-techniques" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">std::function&lt;R(Args...)&gt;</span></code> illustrates a common C++ type-erasure technique. Using template
argument deduction, it decomposes a function type into its return and parameter types. Additional
components of the function type, including <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>, <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code>, <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code>, and any
other attributes, are discarded.</p>
<p>Standard library support for these components of a function type is not immediately forthcoming.</p>
<p>Code can work around this limitation in either of two ways:</p>
<ol class="arabic simple">
<li><p>Avoid abstractions like <code class="docutils literal notranslate"><span class="pre">std::function</span></code> and instead work directly with the original lambda type.</p></li>
<li><p>Create a specialized alternative, e.g. <code class="docutils literal notranslate"><span class="pre">nonblocking_function_ref&lt;R(Args...)&gt;</span></code> where all function
pointers used in the implementation and its interface are <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code>.</p></li>
</ol>
<p>As an example of the first approach, when using a lambda as a <em>Callable</em> template parameter, the
attribute is preserved:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
<span class="w">  </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">Elem</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Elem</span><span class="o">&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonblocking</span><span class="p">]]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">mem</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">mem</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
</pre></div>
</div>
<p>Here, the type of the <code class="docutils literal notranslate"><span class="pre">Compare</span></code> template parameter is an anonymous class generated from the
lambda, with an <code class="docutils literal notranslate"><span class="pre">operator()</span></code> method holding the <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> attribute.</p>
<p>A complication arises when a <em>Callable</em> template parameter, instead of being a lambda or class
implementing <code class="docutils literal notranslate"><span class="pre">operator()</span></code>, is a function pointer:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">compare_elems</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Elem</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Elem</span><span class="o">&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonblocking</span><span class="p">]]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">mem</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">mem</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">compare_elems</span><span class="p">);</span>
</pre></div>
</div>
<p>Here, the type of <code class="docutils literal notranslate"><span class="pre">compare_elems</span></code> is decomposed to <code class="docutils literal notranslate"><span class="pre">bool(const</span> <span class="pre">Elem&amp;,</span> <span class="pre">const</span> <span class="pre">Elem&amp;)</span></code>, without
<code class="docutils literal notranslate"><span class="pre">nonblocking</span></code>, when forming the template parameter. This can be solved using the second approach,
creating a specialized alternative which explicitly requires the attribute. In this case, it’s
possible to use a small wrapper to transform the function pointer into a functor:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">nonblocking_fp</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">R</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">nonblocking_fp</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">impl_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">Args</span><span class="p">...)</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">nonblocking</span><span class="p">]];</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="n">impl_t</span><span class="w"> </span><span class="n">mImpl</span><span class="p">{</span><span class="w"> </span><span class="n">nullptr_t</span><span class="w"> </span><span class="p">};</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">nonblocking_fp</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">  </span><span class="n">nonblocking_fp</span><span class="p">(</span><span class="n">impl_t</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">mImpl</span><span class="p">{</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="n">R</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">mImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// deduction guide (like std::function&#39;s)</span>
<span class="k">template</span><span class="o">&lt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">R</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">ArgTypes</span><span class="w"> </span><span class="o">&gt;</span>
<span class="n">nonblocking_fp</span><span class="p">(</span><span class="w"> </span><span class="n">R</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">ArgTypes</span><span class="p">...)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">nonblocking_fp</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">ArgTypes</span><span class="p">...)</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// --</span>

<span class="c1">// Wrap the function pointer in a functor which preserves ``nonblocking``.</span>
<span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">nonblocking_fp</span><span class="p">{</span><span class="w"> </span><span class="n">compare_elems</span><span class="w"> </span><span class="p">});</span>
</pre></div>
</div>
<p>Now, the <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> attribute of <code class="docutils literal notranslate"><span class="pre">compare_elems</span></code> is verified when it is converted to a
<code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> function pointer, as the argument to <code class="docutils literal notranslate"><span class="pre">nonblocking_fp</span></code>’s constructor. The template
parameter is the functor class <code class="docutils literal notranslate"><span class="pre">nonblocking_fp</span></code>.</p>
</section>
<section id="static-local-variables">
<h3><a class="toc-backref" href="#id19" role="doc-backlink">Static local variables</a><a class="headerlink" href="#static-local-variables" title="Link to this heading">¶</a></h3>
<p>Static local variables are often used for lazily-constructed globals (Meyers singletons). Beyond the
compiler’s use of a lock to ensure thread-safe initialization, it is dangerously easy to
inadvertently trigger initialization, involving heap allocation, from a <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> or
<code class="docutils literal notranslate"><span class="pre">nonallocating</span></code> context.</p>
<p>Generally, such singletons need to be replaced by globals, and care must be taken to ensure their
initialization before they are used from <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code> or <code class="docutils literal notranslate"><span class="pre">nonallocating</span></code> contexts.</p>
</section>
<section id="annotating-libraries">
<h3><a class="toc-backref" href="#id20" role="doc-backlink">Annotating libraries</a><a class="headerlink" href="#annotating-libraries" title="Link to this heading">¶</a></h3>
<p>It can be surprising that the analysis does not depend on knowledge of any primitives; it simply
assumes the worst, that all function calls are unsafe unless explicitly marked as safe or able to be
inferred as safe. With <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code>, this appears to suffice for all but the most primitive of
spinlocks.</p>
<p>At least for an operating system’s C functions, it is possible to define an override header which
redeclares safe common functions (e.g. <code class="docutils literal notranslate"><span class="pre">pthread_self()</span></code>) with the addition of <code class="docutils literal notranslate"><span class="pre">nonblocking</span></code>.
This may help in adopting the feature incrementally.</p>
<p>It also helps that many of the functions in the standard C libraries (notably <code class="docutils literal notranslate"><span class="pre">&lt;math.h&gt;</span></code>)
are treated as built-in functions by Clang, which the diagnosis understands to be safe.</p>
<p>Much of the C++ standard library consists of inline templated functions which work well with
inference. A small number of primitives may need explicit <code class="docutils literal notranslate"><span class="pre">nonblocking/nonallocating</span></code> attributes.</p>
</section>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="DataFlowAnalysisIntro.html">Data flow analysis: an informal introduction</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="AddressSanitizer.html">AddressSanitizer</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2007-2025, The Clang Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>