<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Standard C++ Modules &#8212; Clang 21.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=e491ac2d" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=eafc0fe6" />
    <script src="_static/documentation_options.js?v=c54a4614"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Modules" href="Modules.html" />
    <link rel="prev" title="Source-based Code Coverage" href="SourceBasedCodeCoverage.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Clang 21.1.0 documentation</span></a></h1>
        <h2 class="heading"><span>Standard C++ Modules</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="SourceBasedCodeCoverage.html">Source-based Code Coverage</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="Modules.html">Modules</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="standard-c-modules">
<h1>Standard C++ Modules<a class="headerlink" href="#standard-c-modules" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id11">Introduction</a></p></li>
<li><p><a class="reference internal" href="#standard-c-named-modules" id="id12">Standard C++ Named modules</a></p>
<ul>
<li><p><a class="reference internal" href="#background-and-terminology" id="id13">Background and terminology</a></p>
<ul>
<li><p><a class="reference internal" href="#module-and-module-unit" id="id14">Module and module unit</a></p></li>
<li><p><a class="reference internal" href="#built-module-interface" id="id15">Built Module Interface</a></p></li>
<li><p><a class="reference internal" href="#global-module-fragment" id="id16">Global module fragment</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#how-to-build-projects-using-modules" id="id17">How to build projects using modules</a></p>
<ul>
<li><p><a class="reference internal" href="#quick-start" id="id18">Quick Start</a></p></li>
<li><p><a class="reference internal" href="#how-to-enable-standard-c-modules" id="id19">How to enable standard C++ modules</a></p></li>
<li><p><a class="reference internal" href="#how-to-produce-a-bmi" id="id20">How to produce a BMI</a></p></li>
<li><p><a class="reference internal" href="#file-name-requirements" id="id21">File name requirements</a></p></li>
<li><p><a class="reference internal" href="#module-name-requirements" id="id22">Module name requirements</a></p></li>
<li><p><a class="reference internal" href="#specifying-bmi-dependencies" id="id23">Specifying BMI dependencies</a></p></li>
<li><p><a class="reference internal" href="#remember-that-module-units-still-have-an-object-counterpart-to-the-bmi" id="id24">Remember that module units still have an object counterpart to the BMI</a></p></li>
<li><p><a class="reference internal" href="#clang-cl" id="id25">clang-cl</a></p></li>
<li><p><a class="reference internal" href="#consistency-requirements" id="id26">Consistency Requirements</a></p>
<ul>
<li><p><a class="reference internal" href="#options-consistency" id="id27">Options consistency</a></p></li>
<li><p><a class="reference internal" href="#source-files-consistency" id="id28">Source Files Consistency</a></p></li>
<li><p><a class="reference internal" href="#object-definition-consistency" id="id29">Object definition consistency</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#privacy-issue" id="id30">Privacy Issue</a></p></li>
<li><p><a class="reference internal" href="#abi-impacts" id="id31">ABI Impacts</a></p>
<ul>
<li><p><a class="reference internal" href="#name-mangling" id="id32">Name Mangling</a></p></li>
<li><p><a class="reference internal" href="#module-initializers" id="id33">Module Initializers</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#reduced-bmi" id="id34">Reduced BMI</a></p></li>
<li><p><a class="reference internal" href="#experimental-non-cascading-changes" id="id35">Experimental Non-Cascading Changes</a></p>
<ul>
<li><p><a class="reference internal" href="#interactions-with-reduced-bmi" id="id36">Interactions with Reduced BMI</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#performance-tips" id="id37">Performance Tips</a></p>
<ul>
<li><p><a class="reference internal" href="#reduce-duplications" id="id38">Reduce duplications</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#transitioning-to-modules" id="id39">Transitioning to modules</a></p>
<ul>
<li><p><a class="reference internal" href="#abi-non-breaking-styles" id="id40">ABI non-breaking styles</a></p>
<ul>
<li><p><a class="reference internal" href="#export-using-style" id="id41">export-using style</a></p></li>
<li><p><a class="reference internal" href="#export-extern-c-style" id="id42">export extern-C++ style</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#abi-breaking-style" id="id43">ABI breaking style</a></p>
<ul>
<li><p><a class="reference internal" href="#what-if-there-are-headers-only-included-by-the-source-files" id="id44">What if there are headers only included by the source files</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#providing-a-header-to-skip-parsing-redundant-headers" id="id45">Providing a header to skip parsing redundant headers</a></p></li>
<li><p><a class="reference internal" href="#importing-modules" id="id46">Importing modules</a></p>
<ul>
<li><p><a class="reference internal" href="#all-library-dependencies-providing-modules" id="id47">All library dependencies providing modules</a></p></li>
<li><p><a class="reference internal" href="#partial-library-dependencies-providing-modules" id="id48">Partial library dependencies providing modules</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#reachability-of-internal-partition-units" id="id49">Reachability of internal partition units</a></p></li>
<li><p><a class="reference internal" href="#known-issues" id="id50">Known Issues</a></p>
<ul>
<li><p><a class="reference internal" href="#including-headers-after-import-is-not-well-supported" id="id51">Including headers after import is not well-supported</a></p></li>
<li><p><a class="reference internal" href="#ignored-preferred-name-attribute" id="id52">Ignored <code class="docutils literal notranslate"><span class="pre">preferred_name</span></code> Attribute</a></p></li>
<li><p><a class="reference internal" href="#don-t-emit-macros-about-module-declaration" id="id53">Don’t emit macros about module declaration</a></p></li>
<li><p><a class="reference internal" href="#in-consistent-filename-suffix-requirement-for-importable-module-units" id="id54">In consistent filename suffix requirement for importable module units</a></p></li>
<li><p><a class="reference internal" href="#incorrect-odr-violation-diagnostics" id="id55">Incorrect ODR violation diagnostics</a></p></li>
<li><p><a class="reference internal" href="#using-tu-local-entity-in-other-units" id="id56">Using TU-local entity in other units</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#header-units" id="id57">Header Units</a></p>
<ul>
<li><p><a class="reference internal" href="#how-to-build-projects-using-header-units" id="id58">How to build projects using header units</a></p>
<ul>
<li><p><a class="reference internal" href="#id10" id="id59">Quick Start</a></p></li>
<li><p><a class="reference internal" href="#how-to-produce-bmis" id="id60">How to produce BMIs</a></p></li>
<li><p><a class="reference internal" href="#how-to-specify-bmi-dependencies" id="id61">How to specify BMI dependencies</a></p></li>
<li><p><a class="reference internal" href="#compiling-a-header-unit-to-an-object-file" id="id62">Compiling a header unit to an object file</a></p></li>
<li><p><a class="reference internal" href="#include-translation" id="id63">Include translation</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#differences-between-clang-modules-and-header-units" id="id64">Differences between Clang modules and header units</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#discovering-dependencies" id="id65">Discovering Dependencies</a></p>
<ul>
<li><p><a class="reference internal" href="#possible-issues-failed-to-find-system-headers" id="id66">Possible Issues: Failed to find system headers</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#import-modules-with-clang-repl" id="id67">Import modules with clang-repl</a></p></li>
<li><p><a class="reference internal" href="#possible-questions" id="id68">Possible Questions</a></p>
<ul>
<li><p><a class="reference internal" href="#how-modules-speed-up-compilation" id="id69">How modules speed up compilation</a></p></li>
<li><p><a class="reference internal" href="#interoperability-with-clang-modules" id="id70">Interoperability with Clang Modules</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>The term <code class="docutils literal notranslate"><span class="pre">module</span></code> is ambiguous, as it is used to mean multiple things in
Clang. For Clang users, a module may refer to an <code class="docutils literal notranslate"><span class="pre">Objective-C</span> <span class="pre">Module</span></code>,
<a class="reference external" href="Modules.html">Clang Module</a> (also called a <code class="docutils literal notranslate"><span class="pre">Clang</span> <span class="pre">Header</span> <span class="pre">Module</span></code>) or a
<code class="docutils literal notranslate"><span class="pre">C++20</span> <span class="pre">Module</span></code> (or a <code class="docutils literal notranslate"><span class="pre">Standard</span> <span class="pre">C++</span> <span class="pre">Module</span></code>). The implementation of all
these kinds of modules in Clang shares a lot of code, but from the perspective
of users their semantics and command line interfaces are very different. This
document is an introduction to the use of C++20 modules in Clang. In the
remainder of this document, the term <code class="docutils literal notranslate"><span class="pre">module</span></code> will refer to Standard C++20
modules and the term <code class="docutils literal notranslate"><span class="pre">Clang</span> <span class="pre">module</span></code> will refer to the Clang Modules
extension.</p>
<p>In terms of the C++ Standard, modules consist of two components: “Named
Modules” or “Header Units”. This document covers both.</p>
</section>
<section id="standard-c-named-modules">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">Standard C++ Named modules</a><a class="headerlink" href="#standard-c-named-modules" title="Link to this heading">¶</a></h2>
<p>In order to better understand the compiler’s behavior, it is helpful to
understand some terms and definitions for readers who are not familiar with the
C++ feature. This document is not a tutorial on C++; it only introduces
necessary concepts to better understand use of modules in a project.</p>
<section id="background-and-terminology">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Background and terminology</a><a class="headerlink" href="#background-and-terminology" title="Link to this heading">¶</a></h3>
<section id="module-and-module-unit">
<h4><a class="toc-backref" href="#id14" role="doc-backlink">Module and module unit</a><a class="headerlink" href="#module-and-module-unit" title="Link to this heading">¶</a></h4>
<p>A module consists of one or more module units. A module unit is a special kind
of translation unit. A module unit should almost always start with a module
declaration. The syntax of the module declaration is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="k">export</span><span class="p">]</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">module_name</span><span class="p">[</span><span class="o">:</span><span class="n">partition_name</span><span class="p">];</span>
</pre></div>
</div>
<p>Terms enclosed in <code class="docutils literal notranslate"><span class="pre">[]</span></code> are optional. <code class="docutils literal notranslate"><span class="pre">module_name</span></code> and <code class="docutils literal notranslate"><span class="pre">partition_name</span></code>
follow the rules for a C++ identifier, except that they may contain one or more
period (<code class="docutils literal notranslate"><span class="pre">.</span></code>) characters. Note that a <code class="docutils literal notranslate"><span class="pre">.</span></code> in the name has no semantic
meaning and does not imply any hierarchy.</p>
<p>In this document, module units are classified as:</p>
<ul class="simple">
<li><p>Primary module interface unit</p></li>
<li><p>Module implementation unit</p></li>
<li><p>Module partition interface unit</p></li>
<li><p>Internal module partition unit</p></li>
</ul>
<p>A primary module interface unit is a module unit whose module declaration is
<code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">module</span> <span class="pre">module_name;</span></code> where <code class="docutils literal notranslate"><span class="pre">module_name</span></code> denotes the name of the
module. A module should have one and only one primary module interface unit.</p>
<p>A module implementation unit is a module unit whose module declaration is
<code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">module_name;</span></code>. Multiple module implementation units can be declared
in the same module.</p>
<p>A module partition interface unit is a module unit whose module declaration is
<code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">module</span> <span class="pre">module_name:partition_name;</span></code>. The <code class="docutils literal notranslate"><span class="pre">partition_name</span></code> should be
unique within any given module.</p>
<p>An internal module partition unit is a module unit whose module
declaration is <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">module_name:partition_name;</span></code>. The <code class="docutils literal notranslate"><span class="pre">partition_name</span></code>
should be unique within any given module.</p>
<p>In this document, we use the following terms:</p>
<ul class="simple">
<li><p>A <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">interface</span> <span class="pre">unit</span></code> refers to either a <code class="docutils literal notranslate"><span class="pre">primary</span> <span class="pre">module</span> <span class="pre">interface</span> <span class="pre">unit</span></code>
or a <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">partition</span> <span class="pre">interface</span> <span class="pre">unit</span></code>.</p></li>
<li><p>An <code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code> refers to either a <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">interface</span> <span class="pre">unit</span></code> or
an <code class="docutils literal notranslate"><span class="pre">internal</span> <span class="pre">module</span> <span class="pre">partition</span> <span class="pre">unit</span></code>.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">partition</span> <span class="pre">unit</span></code> refers to either a <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">partition</span> <span class="pre">interface</span> <span class="pre">unit</span></code>
or an <code class="docutils literal notranslate"><span class="pre">internal</span> <span class="pre">module</span> <span class="pre">partition</span> <span class="pre">unit</span></code>.</p></li>
</ul>
</section>
<section id="built-module-interface">
<h4><a class="toc-backref" href="#id15" role="doc-backlink">Built Module Interface</a><a class="headerlink" href="#built-module-interface" title="Link to this heading">¶</a></h4>
<p>A <code class="docutils literal notranslate"><span class="pre">Built</span> <span class="pre">Module</span> <span class="pre">Interface</span></code> (or <code class="docutils literal notranslate"><span class="pre">BMI</span></code>) is the precompiled result of an
importable module unit.</p>
</section>
<section id="global-module-fragment">
<h4><a class="toc-backref" href="#id16" role="doc-backlink">Global module fragment</a><a class="headerlink" href="#global-module-fragment" title="Link to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">global</span> <span class="pre">module</span> <span class="pre">fragment</span></code> (or <code class="docutils literal notranslate"><span class="pre">GMF</span></code>) is the code between the <code class="docutils literal notranslate"><span class="pre">module;</span></code>
and the module declaration within a module unit.</p>
</section>
</section>
<section id="how-to-build-projects-using-modules">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">How to build projects using modules</a><a class="headerlink" href="#how-to-build-projects-using-modules" title="Link to this heading">¶</a></h3>
<section id="quick-start">
<h4><a class="toc-backref" href="#id18" role="doc-backlink">Quick Start</a><a class="headerlink" href="#quick-start" title="Link to this heading">¶</a></h4>
<p>Let’s see a “hello world” example that uses modules.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Hello.cppm</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">Hello</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// use.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="n">Hello</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">hello</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then, on the command line, invoke Clang like:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>Hello.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>Hello.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>use.cpp<span class="w"> </span>-fmodule-file<span class="o">=</span><span class="nv">Hello</span><span class="o">=</span>Hello.pcm<span class="w"> </span>Hello.pcm<span class="w"> </span>-o<span class="w"> </span>Hello.out
<span class="gp">$ </span>./Hello.out
<span class="go">Hello World!</span>
</pre></div>
</div>
<p>In this example, we make and use a simple module <code class="docutils literal notranslate"><span class="pre">Hello</span></code> which contains only a
primary module interface unit named <code class="docutils literal notranslate"><span class="pre">Hello.cppm</span></code>.</p>
<p>A more complex “hello world” example which uses the 4 kinds of module units is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// M.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">interface_part</span><span class="p">;</span>
<span class="nl">import</span><span class="w"> </span><span class="p">:</span><span class="n">impl_part</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Hello</span><span class="p">();</span>

<span class="c1">// interface_part.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">interface_part</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">World</span><span class="p">();</span>

<span class="c1">// impl_part.cppm</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">impl_part</span><span class="p">;</span>
<span class="nl">import</span><span class="w"> </span><span class="p">:</span><span class="n">interface_part</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;World.&quot;</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">World</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Impl.cpp</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello &quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// User.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Hello</span><span class="p">();</span>
<span class="w">  </span><span class="n">World</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then, back on the command line, invoke Clang with:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>Precompiling<span class="w"> </span>the<span class="w"> </span>module
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>interface_part.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>M-interface_part.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>impl_part.cppm<span class="w"> </span>--precompile<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>-o<span class="w"> </span>M-impl_part.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M.cppm<span class="w"> </span>--precompile<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>-o<span class="w"> </span>M.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>Impl.cpp<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>Impl.o

<span class="gp"># </span>Compiling<span class="w"> </span>the<span class="w"> </span>user
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>User.cpp<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>User.o

<span class="gp"># </span>Compiling<span class="w"> </span>the<span class="w"> </span>module<span class="w"> </span>and<span class="w"> </span>linking<span class="w"> </span>it<span class="w"> </span>together
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M-interface_part.pcm<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>M-interface_part.o
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M-impl_part.pcm<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>M-impl_part.o
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M.pcm<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>M.o
<span class="gp">$ </span>clang++<span class="w"> </span>User.o<span class="w"> </span>M-interface_part.o<span class="w">  </span>M-impl_part.o<span class="w"> </span>M.o<span class="w"> </span>Impl.o<span class="w"> </span>-o<span class="w"> </span>a.out
</pre></div>
</div>
<p>We explain the options in the following sections.</p>
</section>
<section id="how-to-enable-standard-c-modules">
<h4><a class="toc-backref" href="#id19" role="doc-backlink">How to enable standard C++ modules</a><a class="headerlink" href="#how-to-enable-standard-c-modules" title="Link to this heading">¶</a></h4>
<p>Standard C++ modules are enabled automatically when the language standard mode
is <code class="docutils literal notranslate"><span class="pre">-std=c++20</span></code> or newer.</p>
</section>
<section id="how-to-produce-a-bmi">
<h4><a class="toc-backref" href="#id20" role="doc-backlink">How to produce a BMI</a><a class="headerlink" href="#how-to-produce-a-bmi" title="Link to this heading">¶</a></h4>
<p>To generate a BMI for an importable module unit, use either the <code class="docutils literal notranslate"><span class="pre">--precompile</span></code>
or <code class="docutils literal notranslate"><span class="pre">-fmodule-output</span></code> command line options.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">--precompile</span></code> option generates the BMI as the output of the compilation
with the output path specified using the <code class="docutils literal notranslate"><span class="pre">-o</span></code> option.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">-fmodule-output</span></code> option generates the BMI as a by-product of the
compilation. If <code class="docutils literal notranslate"><span class="pre">-fmodule-output=</span></code> is specified, the BMI will be emitted to
the specified location. If <code class="docutils literal notranslate"><span class="pre">-fmodule-output</span></code> and <code class="docutils literal notranslate"><span class="pre">-c</span></code> are specified, the
BMI will be emitted in the directory of the output file with the name of the
input file with the extension <code class="docutils literal notranslate"><span class="pre">.pcm</span></code>. Otherwise, the BMI will be emitted in
the working directory with the name of the input file with the extension
<code class="docutils literal notranslate"><span class="pre">.pcm</span></code>.</p>
<p>Generating BMIs with <code class="docutils literal notranslate"><span class="pre">--precompile</span></code> is referred to as two-phase compilation
because it takes two steps to compile a source file to an object file.
Generating BMIs with <code class="docutils literal notranslate"><span class="pre">-fmodule-output</span></code> is called one-phase compilation. The
one-phase compilation model is simpler for build systems to implement while the
two-phase compilation has the potential to compile faster due to higher
parallelism. As an example, if there are two module units <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>, and
<code class="docutils literal notranslate"><span class="pre">B</span></code> depends on <code class="docutils literal notranslate"><span class="pre">A</span></code>, the one-phase compilation model needs to compile them
serially, whereas the two-phase compilation model is able to be compiled as
soon as <code class="docutils literal notranslate"><span class="pre">A.pcm</span></code> is available, and thus can be compiled simultaneously as the
<code class="docutils literal notranslate"><span class="pre">A.pcm</span></code> to <code class="docutils literal notranslate"><span class="pre">A.o</span></code> compilation step.</p>
</section>
<section id="file-name-requirements">
<h4><a class="toc-backref" href="#id21" role="doc-backlink">File name requirements</a><a class="headerlink" href="#file-name-requirements" title="Link to this heading">¶</a></h4>
<p>By convention, <code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code> files should use <code class="docutils literal notranslate"><span class="pre">.cppm</span></code> (or
<code class="docutils literal notranslate"><span class="pre">.ccm</span></code>, <code class="docutils literal notranslate"><span class="pre">.cxxm</span></code>, or <code class="docutils literal notranslate"><span class="pre">.c++m</span></code>) as a file extension.
<code class="docutils literal notranslate"><span class="pre">Module</span> <span class="pre">implementation</span> <span class="pre">unit</span></code> files should use <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> (or <code class="docutils literal notranslate"><span class="pre">.cc</span></code>, <code class="docutils literal notranslate"><span class="pre">.cxx</span></code>,
or <code class="docutils literal notranslate"><span class="pre">.c++</span></code>) as a file extension.</p>
<p>A BMI should use <code class="docutils literal notranslate"><span class="pre">.pcm</span></code> as a file extension. The file name of the BMI for a
<code class="docutils literal notranslate"><span class="pre">primary</span> <span class="pre">module</span> <span class="pre">interface</span> <span class="pre">unit</span></code> should be <code class="docutils literal notranslate"><span class="pre">module_name.pcm</span></code>. The file name
of a BMI for a <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">partition</span> <span class="pre">unit</span></code> should be
<code class="docutils literal notranslate"><span class="pre">module_name-partition_name.pcm</span></code>.</p>
<p>Clang may fail to build the module if different extensions are used. For
example, if the filename of an <code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code> ends with <code class="docutils literal notranslate"><span class="pre">.cpp</span></code>
instead of <code class="docutils literal notranslate"><span class="pre">.cppm</span></code>, then Clang cannot generate a BMI for the
<code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code> with the <code class="docutils literal notranslate"><span class="pre">--precompile</span></code> option because the
<code class="docutils literal notranslate"><span class="pre">--precompile</span></code> option would only run the preprocessor (<code class="docutils literal notranslate"><span class="pre">-E</span></code>). If using a
different extension than the conventional one for an <code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code>
you can specify <code class="docutils literal notranslate"><span class="pre">-x</span> <span class="pre">c++-module</span></code> before the file. For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Hello.cpp</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">Hello</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// use.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="n">Hello</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">hello</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, the extension used by the <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">interface</span></code> is <code class="docutils literal notranslate"><span class="pre">.cpp</span></code>
instead of <code class="docutils literal notranslate"><span class="pre">.cppm</span></code>, so it cannot be compiled like the previous example, but
it can be compiled with:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-x<span class="w"> </span>c++-module<span class="w"> </span>Hello.cpp<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>Hello.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>use.cpp<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>Hello.pcm<span class="w"> </span>-o<span class="w"> </span>Hello.out
<span class="gp">$ </span>./Hello.out
<span class="go">Hello World!</span>
</pre></div>
</div>
</section>
<section id="module-name-requirements">
<h4><a class="toc-backref" href="#id22" role="doc-backlink">Module name requirements</a><a class="headerlink" href="#module-name-requirements" title="Link to this heading">¶</a></h4>
<blockquote>
<div><p>[module.unit]p1:</p>
<p>All module-names either beginning with an identifier consisting of std followed by zero
or more digits or containing a reserved identifier ([lex.name]) are reserved and shall not
be specified in a module-declaration; no diagnostic is required. If any identifier in a reserved
module-name is a reserved identifier, the module name is reserved for use by C++ implementations;
otherwise it is reserved for future standardization.</p>
</div></blockquote>
<p>Therefore, none of the following names are valid by default:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>std
std1
std.foo
__test
// and so on ...
</pre></div>
</div>
<p>Using a reserved module name is strongly discouraged, but
<code class="docutils literal notranslate"><span class="pre">-Wno-reserved-module-identifier</span></code> can be used to suppress the warning.</p>
</section>
<section id="specifying-bmi-dependencies">
<h4><a class="toc-backref" href="#id23" role="doc-backlink">Specifying BMI dependencies</a><a class="headerlink" href="#specifying-bmi-dependencies" title="Link to this heading">¶</a></h4>
<p>There are 3 ways to specify a BMI dependency:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path=&lt;path/to/directory&gt;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code> (Deprecated).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=&lt;path/to/BMI&gt;</span></code>.</p></li>
</ol>
<p>The <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code> option specifies the path to search for
BMI dependencies. Multiple paths may be specified, similar to using <code class="docutils literal notranslate"><span class="pre">-I</span></code> to
specify a search path for header files. When importing a module <code class="docutils literal notranslate"><span class="pre">M</span></code>, the
compiler looks for <code class="docutils literal notranslate"><span class="pre">M.pcm</span></code> in the directories specified by
<code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code>. Similarly, when importing a partition module unit
<code class="docutils literal notranslate"><span class="pre">M:P</span></code>, the compiler looks for <code class="docutils literal notranslate"><span class="pre">M-P.pcm</span></code> in the directories specified by
<code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code> option causes the compiler to load the
specified BMI directly. The <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=&lt;path/to/BMI&gt;</span></code>
option causes the compiler to load the specified BMI for the module specified
by <code class="docutils literal notranslate"><span class="pre">&lt;module-name&gt;</span></code> when necessary. The main difference is that
<code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code> will load the BMI eagerly, whereas
<code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=&lt;path/to/BMI&gt;</span></code> will only load the BMI lazily,
as will <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code>. The <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code> option
for named modules is deprecated and will be removed in a future version of
Clang.</p>
<p>When these options are specified in the same invocation of the compiler, the
<code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code> option takes precedence over
<code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=&lt;path/to/BMI&gt;</span></code>, which takes precedence over
<code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path=&lt;path/to/directory&gt;</span></code>.</p>
<p>Note: all BMI dependencies must be specified explicitly, either directly or
indirectly. See <a class="reference external" href="https://github.com/llvm/llvm-project/issues/62707">https://github.com/llvm/llvm-project/issues/62707</a> for details.</p>
<p>When compiling a <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">implementation</span> <span class="pre">unit</span></code>, the BMI of the corresponding
<code class="docutils literal notranslate"><span class="pre">primary</span> <span class="pre">module</span> <span class="pre">interface</span> <span class="pre">unit</span></code> must be specified because a module
implementation unit implicitly imports the primary module interface unit.</p>
<blockquote>
<div><p>[module.unit]p8</p>
<p>A module-declaration that contains neither an export-keyword nor a module-partition implicitly
imports the primary module interface unit of the module as if by a module-import-declaration.</p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path=&lt;path/to/directory&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code>,
and <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=&lt;path/to/BMI&gt;</span></code> options may be specified
multiple times. For example, the command line to compile <code class="docutils literal notranslate"><span class="pre">M.cppm</span></code> in
the previous example could be rewritten as:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M.cppm<span class="w"> </span>--precompile<span class="w"> </span>-fmodule-file<span class="o">=</span>M:interface_part<span class="o">=</span>M-interface_part.pcm<span class="w"> </span>-fmodule-file<span class="o">=</span>M:impl_part<span class="o">=</span>M-impl_part.pcm<span class="w"> </span>-o<span class="w"> </span>M.pcm
</pre></div>
</div>
<p>When there are multiple <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=</span></code> options for the same
<code class="docutils literal notranslate"><span class="pre">&lt;module-name&gt;</span></code>, the last <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=</span></code> overrides the
previous <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=</span></code> option.</p>
</section>
<section id="remember-that-module-units-still-have-an-object-counterpart-to-the-bmi">
<h4><a class="toc-backref" href="#id24" role="doc-backlink">Remember that module units still have an object counterpart to the BMI</a><a class="headerlink" href="#remember-that-module-units-still-have-an-object-counterpart-to-the-bmi" title="Link to this heading">¶</a></h4>
<p>While module interfaces resemble traditional header files, they still require
compilation. Module units are translation units, and need to be compiled to
object files, which then need to be linked together as the following examples
show.</p>
<p>For example, the traditional compilation processes for headers are like:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>src1.cpp -+&gt; clang++ src1.cpp --&gt; src1.o ---,
hdr1.h  --&#39;                                 +-&gt; clang++ src1.o src2.o -&gt;  executable
hdr2.h  --,                                 |
src2.cpp -+&gt; clang++ src2.cpp --&gt; src2.o ---&#39;
</pre></div>
</div>
<p>And the compilation processes for module units are like:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>              src1.cpp ----------------------------------------+&gt; clang++ src1.cpp -------&gt; src1.o -,
(header unit) hdr1.h    -&gt; clang++ hdr1.h ...    -&gt; hdr1.pcm --&#39;                                    +-&gt; clang++ src1.o mod1.o src2.o -&gt;  executable
              mod1.cppm -&gt; clang++ mod1.cppm ... -&gt; mod1.pcm --,--&gt; clang++ mod1.pcm ... -&gt; mod1.o -+
              src2.cpp ----------------------------------------+&gt; clang++ src2.cpp -------&gt; src2.o -&#39;
</pre></div>
</div>
<p>As the diagrams show, we need to compile the BMI from module units to object
files and then link the object files. (However, this cannot be done for the BMI
from header units. See the section on <a class="reference internal" href="#header-units"><span class="std std-ref">header units</span></a> for
more details.</p>
<p>BMIs cannot be shipped in an archive to create a module library. Instead, the
BMIs(<code class="docutils literal notranslate"><span class="pre">*.pcm</span></code>) are compiled into object files(<code class="docutils literal notranslate"><span class="pre">*.o</span></code>) and those object files
are added to the archive instead.</p>
</section>
<section id="clang-cl">
<h4><a class="toc-backref" href="#id25" role="doc-backlink">clang-cl</a><a class="headerlink" href="#clang-cl" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">clang-cl</span></code> supports the same options as <code class="docutils literal notranslate"><span class="pre">clang++</span></code> for modules as detailed above;
there is no need to prefix these options with <code class="docutils literal notranslate"><span class="pre">/clang:</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">cl.exe</span></code>
<cite>options to emit/consume IFC files &lt;https://devblogs.microsoft.com/cppblog/using-cpp-modules-in-msvc-from-the-command-line-part-1/&gt;</cite> are <em>not</em> supported.
The resultant precompiled modules are also not compatible for use with <code class="docutils literal notranslate"><span class="pre">cl.exe</span></code>.</p>
<p>We recommend that build system authors use the above-mentioned <code class="docutils literal notranslate"><span class="pre">clang++</span></code> options  with <code class="docutils literal notranslate"><span class="pre">clang-cl</span></code> to build modules.</p>
</section>
<section id="consistency-requirements">
<h4><a class="toc-backref" href="#id26" role="doc-backlink">Consistency Requirements</a><a class="headerlink" href="#consistency-requirements" title="Link to this heading">¶</a></h4>
<p>Modules can be viewed as a kind of cache to speed up compilation. Thus, like
other caching techniques, it is important to maintain cache consistency which
is why Clang does very strict checking for consistency.</p>
<section id="options-consistency">
<h5><a class="toc-backref" href="#id27" role="doc-backlink">Options consistency</a><a class="headerlink" href="#options-consistency" title="Link to this heading">¶</a></h5>
<p>Compiler options related to the language dialect for a module unit and its
non-module-unit uses need to be consistent. Consider the following example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// M.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>

<span class="c1">// Use.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>M.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++23<span class="w"> </span>Use.cpp<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.
</pre></div>
</div>
<p>Clang rejects the example due to the inconsistent language standard modes. Not
all compiler options are language-dialect options, though. For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>M.pcm
<span class="gp"># </span>Inconsistent<span class="w"> </span>optimization<span class="w"> </span>level.
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-O3<span class="w"> </span>Use.cpp<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.
<span class="gp"># </span>Inconsistent<span class="w"> </span>debugging<span class="w"> </span>level.
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-g<span class="w"> </span>Use.cpp<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.
</pre></div>
</div>
<p>Although the optimization and debugging levels are inconsistent, these
compilations are accepted because the compiler options do not impact the
language dialect.</p>
<p>Note that the compiler <strong>currently</strong> doesn’t reject inconsistent macro
definitions (this may change in the future). For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>M.pcm
<span class="gp"># </span>Inconsistent<span class="w"> </span>optimization<span class="w"> </span>level.
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-O3<span class="w"> </span>-DNDEBUG<span class="w"> </span>Use.cpp<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.
</pre></div>
</div>
<p>Currently, Clang accepts the above example, though it may produce surprising
results if the debugging code depends on consistent use of <code class="docutils literal notranslate"><span class="pre">NDEBUG</span></code> in other
translation units.</p>
</section>
<section id="source-files-consistency">
<h5><a class="toc-backref" href="#id28" role="doc-backlink">Source Files Consistency</a><a class="headerlink" href="#source-files-consistency" title="Link to this heading">¶</a></h5>
<p>Clang may open the input files <a class="footnote-reference brackets" href="#id2" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> of a BMI during the compilation. This implies that
when Clang consumes a BMI, all the input files need to be present in the original path
and with the original contents.</p>
<p>To overcome these requirements and simplify cases like distributed builds and sandboxed
builds, users can use the <code class="docutils literal notranslate"><span class="pre">-fmodules-embed-all-files</span></code> flag to embed all input files
into the BMI so that Clang does not need to open the corresponding file on disk.</p>
<p>When the <code class="docutils literal notranslate"><span class="pre">-fmodules-embed-all-files</span></code> flag are enabled, Clang explicitly emits the source
code into the BMI file, the contents of the BMI file contain a sufficiently verbose
representation to reproduce the original source file.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Input files: The source files which took part in the compilation of the BMI.
For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// M.cppm</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;foo.h&quot;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>

<span class="c1">// foo.h</span>
<span class="cp">#pragma once</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;bar.h&quot;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">M.cppm</span></code>, <code class="docutils literal notranslate"><span class="pre">foo.h</span></code> and <code class="docutils literal notranslate"><span class="pre">bar.h</span></code> are input files for the BMI of <code class="docutils literal notranslate"><span class="pre">M.cppm</span></code>.</p>
</aside>
</aside>
</section>
<section id="object-definition-consistency">
<h5><a class="toc-backref" href="#id29" role="doc-backlink">Object definition consistency</a><a class="headerlink" href="#object-definition-consistency" title="Link to this heading">¶</a></h5>
<p>The C++ language requires that declarations of the same entity in different
translation units have the same definition, which is known as the One
Definition Rule (ODR). Without modules, the compiler cannot perform strong ODR
violation checking because it only sees one translation unit at a time. With
the use of modules, the compiler can perform checks for ODR violations across
translation units.</p>
<p>However, the current ODR checking mechanisms are not perfect. There are a
significant number of false positive ODR violation diagnostics, where the
compiler incorrectly diagnoses two identical declarations as having different
definitions. Further, true positive ODR violations are not always reported.</p>
<p>To give a better user experience, improve compilation performance, and for
consistency with MSVC, ODR checking of declarations in the global module
fragment is disabled by default. These checks can be enabled by specifying
<code class="docutils literal notranslate"><span class="pre">-Xclang</span> <span class="pre">-fno-skip-odr-check-in-gmf</span></code> when compiling. If the check is enabled
and you encounter incorrect or missing diagnostics, please report them via the
<a class="reference external" href="https://github.com/llvm/llvm-project/issues/">community issue tracker</a>.</p>
</section>
</section>
</section>
<section id="privacy-issue">
<h3><a class="toc-backref" href="#id30" role="doc-backlink">Privacy Issue</a><a class="headerlink" href="#privacy-issue" title="Link to this heading">¶</a></h3>
<p>BMIs are not and should not be treated as an information hiding mechanism.
They should always be assumed to contain all the information that was used to
create them, in a recoverable form.</p>
</section>
<section id="abi-impacts">
<h3><a class="toc-backref" href="#id31" role="doc-backlink">ABI Impacts</a><a class="headerlink" href="#abi-impacts" title="Link to this heading">¶</a></h3>
<p>This section describes the new ABI changes brought by modules. Only changes to
the Itanium C++ ABI are covered.</p>
<section id="name-mangling">
<h4><a class="toc-backref" href="#id32" role="doc-backlink">Name Mangling</a><a class="headerlink" href="#name-mangling" title="Link to this heading">¶</a></h4>
<p>The declarations in a module unit which are not in the global module fragment
have new linkage names.</p>
<p>For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">NS</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">export</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The linkage name of <code class="docutils literal notranslate"><span class="pre">NS::foo()</span></code> is <code class="docutils literal notranslate"><span class="pre">_ZN2NSW1M3fooEv</span></code>. This couldn’t be
demangled by previous versions of the debugger or demangler. As of LLVM 15.x,
<code class="docutils literal notranslate"><span class="pre">llvm-cxxfilt</span></code> can be used to demangle this:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>llvm-cxxfilt<span class="w"> </span>_ZN2NSW1M3fooEv
<span class="go">  NS::foo@M()</span>
</pre></div>
</div>
<p>The result should be read as <code class="docutils literal notranslate"><span class="pre">NS::foo()</span></code> in module <code class="docutils literal notranslate"><span class="pre">M</span></code>.</p>
<p>The ABI implies that something cannot be declared in a module unit and defined
in a non-module unit (or vice-versa), as this would result in linking errors.</p>
<p>Despite this, it is possible to implement declarations with a compatible ABI in
a module unit by using a language linkage specifier because the declarations in
the language linkage specifier are attached to the global module fragment. For
example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">NS</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">export</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C++&quot;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now the linkage name of <code class="docutils literal notranslate"><span class="pre">NS::foo()</span></code> will be <code class="docutils literal notranslate"><span class="pre">_ZN2NS3fooEv</span></code>.</p>
</section>
<section id="module-initializers">
<h4><a class="toc-backref" href="#id33" role="doc-backlink">Module Initializers</a><a class="headerlink" href="#module-initializers" title="Link to this heading">¶</a></h4>
<p>All importable module units are required to emit an initializer function to
handle the dynamic initialization of non-inline variables in the module unit.
The importable module unit has to emit the initializer even if there is no
dynamic initialization; otherwise, the importer may call a nonexistent
function. The initializer function emits calls to imported modules first
followed by calls to all to of the dynamic initializers in the current module
unit.</p>
<p>Translation units that explicitly or implicitly import a named module must call
the initializer functions of the imported named module within the sequence of
the dynamic initializers in the translation unit. Initializations of entities
at namespace scope are appearance-ordered. This (recursively) extends to
imported modules at the point of appearance of the import declaration.</p>
<p>If the imported module is known to be empty, the call to its initializer may be
omitted. Additionally, if the imported module is known to have already been
imported, the call to its initializer may be omitted.</p>
</section>
</section>
<section id="reduced-bmi">
<h3><a class="toc-backref" href="#id34" role="doc-backlink">Reduced BMI</a><a class="headerlink" href="#reduced-bmi" title="Link to this heading">¶</a></h3>
<p>To support the two-phase compilation model, Clang puts everything needed to
produce an object into the BMI. However, other consumers of the BMI generally
don’t need that information. This makes the BMI larger and may introduce
unnecessary dependencies for the BMI. To mitigate the problem, Clang has a
compiler option to reduce the information contained in the BMI. These two
formats are known as Full BMI and Reduced BMI, respectively.</p>
<p>Users can use the <code class="docutils literal notranslate"><span class="pre">-fmodules-reduced-bmi</span></code> option to produce a
Reduced BMI.</p>
<p>For the one-phase compilation model (CMake implements this model), with
<code class="docutils literal notranslate"><span class="pre">-fmodules-reduced-bmi</span></code>, the generated BMI will be a Reduced
BMI automatically. (The output path of the BMI is specified by
<code class="docutils literal notranslate"><span class="pre">-fmodule-output=</span></code> as usual with the one-phase compilation model).</p>
<p>It is also possible to produce a Reduced BMI with the two-phase compilation
model. When <code class="docutils literal notranslate"><span class="pre">-fmodules-reduced-bmi</span></code>, <code class="docutils literal notranslate"><span class="pre">--precompile</span></code>, and
<code class="docutils literal notranslate"><span class="pre">-fmodule-output=</span></code> are specified, the generated BMI specified by <code class="docutils literal notranslate"><span class="pre">-o</span></code> will
be a full BMI and the BMI specified by <code class="docutils literal notranslate"><span class="pre">-fmodule-output=</span></code> will be a Reduced
BMI. The dependency graph in this case would look like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>module-unit.cppm --&gt; module-unit.full.pcm -&gt; module-unit.o
                  |
                  -&gt; module-unit.reduced.pcm -&gt; consumer1.cpp
                                             -&gt; consumer2.cpp
                                             -&gt; ...
                                             -&gt; consumer_n.cpp
</pre></div>
</div>
<p>Clang does not emit diagnostics when <code class="docutils literal notranslate"><span class="pre">-fmodules-reduced-bmi</span></code> is
used with a non-module unit. This design permits users of the one-phase
compilation model to try using reduced BMIs without needing to modify the build
system. The two-phase compilation module requires build system support.</p>
<p>In a Reduced BMI, Clang does not emit unreachable entities from the global
module fragment, or definitions of non-inline functions and non-inline
variables. This may not be a transparent change.</p>
<p>Consider the following example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// foo.h</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">N</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">X</span><span class="w"> </span><span class="p">{};</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">d</span><span class="p">();</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">e</span><span class="p">();</span>
<span class="w">  </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">e</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="n">X</span><span class="p">);</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">h</span><span class="p">(</span><span class="n">X</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// M.cppm</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;foo.h&quot;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">use_f</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">N</span><span class="o">::</span><span class="n">X</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">                       </span><span class="c1">// N::X, N, and :: are decl-reachable from use_f</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">123</span><span class="p">);</span><span class="w">             </span><span class="c1">// N::f is decl-reachable from use_f,</span>
<span class="w">                                </span><span class="c1">// N::e is indirectly decl-reachable from use_f</span>
<span class="w">                                </span><span class="c1">//   because it is decl-reachable from N::f, and</span>
<span class="w">                                </span><span class="c1">// N::d is decl-reachable from use_f</span>
<span class="w">                                </span><span class="c1">//   because it is decl-reachable from N::f</span>
<span class="w">                                </span><span class="c1">//   even though it is not used in this call</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">use_g</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">N</span><span class="o">::</span><span class="n">X</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">                       </span><span class="c1">// N::X, N, and :: are decl-reachable from use_g</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">g</span><span class="p">((</span><span class="n">T</span><span class="p">(),</span><span class="w"> </span><span class="n">x</span><span class="p">));</span><span class="w">           </span><span class="c1">// N::g is not decl-reachable from use_g</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">use_h</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">N</span><span class="o">::</span><span class="n">X</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">                       </span><span class="c1">// N::X, N, and :: are decl-reachable from use_h</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">h</span><span class="p">((</span><span class="n">T</span><span class="p">(),</span><span class="w"> </span><span class="n">x</span><span class="p">));</span><span class="w">           </span><span class="c1">// N::h is not decl-reachable from use_h, but</span>
<span class="w">                                </span><span class="c1">// N::h is decl-reachable from use_h&lt;int&gt;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">use_h</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// use_h&lt;int&gt; is decl-reachable from k, so</span>
<span class="w">  </span><span class="c1">// N::h is decl-reachable from k</span>

<span class="c1">// M-impl.cpp</span>
<span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">use_f</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span><span class="w">           </span><span class="c1">// OK</span>
<span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">use_g</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span><span class="w">           </span><span class="c1">// error: no viable function for call to g;</span>
<span class="w">                                </span><span class="c1">// g is not decl-reachable from purview of</span>
<span class="w">                                </span><span class="c1">// module M&#39;s interface, so is discarded</span>
<span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">use_h</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span><span class="w">           </span><span class="c1">// OK</span>
</pre></div>
</div>
<p>In the above example, the function definition of <code class="docutils literal notranslate"><span class="pre">N::g</span></code> is elided from the
Reduced BMI of <code class="docutils literal notranslate"><span class="pre">M.cppm</span></code>. Then the use of <code class="docutils literal notranslate"><span class="pre">use_g&lt;int&gt;</span></code> in <code class="docutils literal notranslate"><span class="pre">M-impl.cpp</span></code>
fails to instantiate. For such issues, users can add references to <code class="docutils literal notranslate"><span class="pre">N::g</span></code> in
the <a class="reference external" href="https://eel.is/c++draft/module.unit#5">module purview</a> of <code class="docutils literal notranslate"><span class="pre">M.cppm</span></code> to
ensure it is reachable, e.g. <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">N::g;</span></code>.</p>
<p>Support for Reduced BMIs is still experimental, but it may become the default
in the future. The expected roadmap for Reduced BMIs as of Clang 19.x is:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-fexperimental-modules-reduced-bmi</span></code> was introduced in v19.x</p></li>
<li><p>For v20.x, <code class="docutils literal notranslate"><span class="pre">-fmodules-reduced-bmi</span></code> is introduced as an equivalent non-experimental
option. It is expected to stay opt-in for 1~2 releases, though the period depends
on user feedback and may be extended.</p></li>
<li><p>Finally, <code class="docutils literal notranslate"><span class="pre">-fmodules-reduced-bmi</span></code> will be the default. When that time
comes, the term BMI will refer to the Reduced BMI and the Full BMI will only
be meaningful to build systems which elect to support two-phase compilation.</p></li>
</ol>
</section>
<section id="experimental-non-cascading-changes">
<h3><a class="toc-backref" href="#id35" role="doc-backlink">Experimental Non-Cascading Changes</a><a class="headerlink" href="#experimental-non-cascading-changes" title="Link to this heading">¶</a></h3>
<p>This section is primarily for build system vendors. For end compiler users,
if you don’t want to read it all, this is helpful to reduce recompilations.
We encourage build system vendors and end users try this out and bring feedback.</p>
<p>Before Clang 19, a change in BMI of any (transitive) dependency would cause the
outputs of the BMI to change. Starting with Clang 19, changes to non-direct
dependencies should not directly affect the output BMI, unless they affect the
results of the compilations. We expect that there are many more opportunities
for this optimization than we currently have realized and would appreciate
feedback about missed optimization opportunities. For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// m-partA.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">m</span><span class="o">:</span><span class="n">partA</span><span class="p">;</span>

<span class="c1">// m-partB.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">m</span><span class="o">:</span><span class="n">partB</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">getB</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">44</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// m.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">partA</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">partB</span><span class="p">;</span>

<span class="c1">// useBOnly.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">useBOnly</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">B</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">getB</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Use.cc</span>
<span class="k">import</span><span class="w"> </span><span class="n">useBOnly</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">get</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">B</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To compile the project (for brevity, some commands are omitted.):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>m-partA.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>m-partA.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>m-partB.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>m-partB.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>m.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>m.pcm<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>useBOnly.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>useBOnly.pcm<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.
<span class="gp">$ </span>md5sum<span class="w"> </span>useBOnly.pcm
<span class="go">07656bf4a6908626795729295f9608da  useBOnly.pcm</span>
</pre></div>
</div>
<p>If the interface of <code class="docutils literal notranslate"><span class="pre">m-partA.cppm</span></code> is changed to:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// m-partA.v1.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">m</span><span class="o">:</span><span class="n">partA</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">getA</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">43</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>and the BMI for <code class="docutils literal notranslate"><span class="pre">useBOnly</span></code> is recompiled as in:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>m-partA.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>m-partA.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>m-partB.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>m-partB.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>m.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>m.pcm<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>useBOnly.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>useBOnly.pcm<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.
<span class="gp">$ </span>md5sum<span class="w"> </span>useBOnly.pcm
<span class="go">07656bf4a6908626795729295f9608da  useBOnly.pcm</span>
</pre></div>
</div>
<p>then the contents of <code class="docutils literal notranslate"><span class="pre">useBOnly.pcm</span></code> remain unchanged.
Consequently, if the build system only bases recompilation decisions on directly imported modules,
it becomes possible to skip the recompilation of <code class="docutils literal notranslate"><span class="pre">Use.cc</span></code>.
It should be fine because the altered interfaces do not affect <code class="docutils literal notranslate"><span class="pre">Use.cc</span></code> in any way;
the changes do not cascade.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">Clang</span></code> generates a BMI, it records the hash values of all potentially contributory BMIs
for the BMI being produced. This ensures that build systems are not required to consider
transitively imported modules when deciding whether to recompile.</p>
<p>What is considered to be a potential contributory BMIs is currently unspecified.
However, it is a severe bug for a BMI to remain unchanged following an
observable change in the module source files that affects the module consumers.</p>
<p>Build systems may utilize this optimization by doing an update-if-changed operation to the BMI
that is consumed from the BMI that is output by the compiler.</p>
<p>We encourage build systems to add an experimental mode that
reuses the cached BMI when <strong>direct</strong> dependencies did not change,
even if <strong>transitive</strong> dependencies did change.</p>
<p>Given there are potential compiler bugs, we recommend that build systems
support this feature as a configurable option so that users
can go back to the transitive change mode safely at any time.</p>
<section id="interactions-with-reduced-bmi">
<h4><a class="toc-backref" href="#id36" role="doc-backlink">Interactions with Reduced BMI</a><a class="headerlink" href="#interactions-with-reduced-bmi" title="Link to this heading">¶</a></h4>
<p>With reduced BMI, non-cascading changes can be more powerful. For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// A.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">A</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">a</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">44</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// B.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">B</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="n">A</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">b</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>A.cppm<span class="w"> </span>-c<span class="w"> </span>-fmodule-output<span class="o">=</span>A.pcm<span class="w">  </span>-fmodules-reduced-bmi<span class="w"> </span>-o<span class="w"> </span>A.o
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>B.cppm<span class="w"> </span>-c<span class="w"> </span>-fmodule-output<span class="o">=</span>B.pcm<span class="w">  </span>-fmodules-reduced-bmi<span class="w"> </span>-o<span class="w"> </span>B.o<span class="w"> </span>-fmodule-file<span class="o">=</span><span class="nv">A</span><span class="o">=</span>A.pcm
<span class="gp">$ </span>md5sum<span class="w"> </span>B.pcm
<span class="go">6c2bd452ca32ab418bf35cd141b060b9  B.pcm</span>
</pre></div>
</div>
<p>And let’s change the implementation for <code class="docutils literal notranslate"><span class="pre">A.cppm</span></code> into:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">A</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">a_impl</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">99</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="k">export</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">a</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a_impl</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>and recompile the example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>A.cppm<span class="w"> </span>-c<span class="w"> </span>-fmodule-output<span class="o">=</span>A.pcm<span class="w">  </span>-fmodules-reduced-bmi<span class="w"> </span>-o<span class="w"> </span>A.o
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>B.cppm<span class="w"> </span>-c<span class="w"> </span>-fmodule-output<span class="o">=</span>B.pcm<span class="w">  </span>-fmodules-reduced-bmi<span class="w"> </span>-o<span class="w"> </span>B.o<span class="w"> </span>-fmodule-file<span class="o">=</span><span class="nv">A</span><span class="o">=</span>A.pcm
<span class="gp">$ </span>md5sum<span class="w"> </span>B.pcm
<span class="go">6c2bd452ca32ab418bf35cd141b060b9  B.pcm</span>
</pre></div>
</div>
<p>We should find the contents of <code class="docutils literal notranslate"><span class="pre">B.pcm</span></code> remains the same. In this case, the build system is
allowed to skip recompilations of TUs which solely and directly depend on module <code class="docutils literal notranslate"><span class="pre">B</span></code>.</p>
<p>This only happens with a reduced BMI. With reduced BMIs, we won’t record the function body
of <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">b()</span></code> in the BMI for <code class="docutils literal notranslate"><span class="pre">B</span></code> so that the module <code class="docutils literal notranslate"><span class="pre">A</span></code> doesn’t contribute to the BMI of <code class="docutils literal notranslate"><span class="pre">B</span></code>
and we have less dependencies.</p>
</section>
</section>
<section id="performance-tips">
<h3><a class="toc-backref" href="#id37" role="doc-backlink">Performance Tips</a><a class="headerlink" href="#performance-tips" title="Link to this heading">¶</a></h3>
<section id="reduce-duplications">
<h4><a class="toc-backref" href="#id38" role="doc-backlink">Reduce duplications</a><a class="headerlink" href="#reduce-duplications" title="Link to this heading">¶</a></h4>
<p>While it is valid to have duplicated declarations in the global module fragments
of different module units, it is not free for Clang to deal with the duplicated
declarations. A translation unit will compile more slowly if there is a lot of
duplicated declarations between the translation unit and modules it imports.
For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// M-partA.cppm</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;big.header.h&quot;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">partA</span><span class="p">;</span>
<span class="p">...</span>

<span class="c1">// M-partB.cppm</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;big.header.h&quot;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">partB</span><span class="p">;</span>
<span class="p">...</span>

<span class="c1">// other partitions</span>
<span class="p">...</span>

<span class="c1">// M-partZ.cppm</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;big.header.h&quot;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">partZ</span><span class="p">;</span>
<span class="p">...</span>

<span class="c1">// M.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">partA</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">partB</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">partZ</span><span class="p">;</span>

<span class="c1">// use.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="p">...</span><span class="w"> </span><span class="c1">// use declarations from module M.</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">big.header.h</span></code> is big enough and there are a lot of partitions, the
compilation of <code class="docutils literal notranslate"><span class="pre">use.cpp</span></code> may be significantly slower than the following
approach:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;big.header.h&quot;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">m</span><span class="o">:</span><span class="n">big</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">wrapper</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="c1">// export the needed declarations</span>

<span class="c1">// M-partA.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">partA</span><span class="p">;</span>
<span class="nl">import</span><span class="w"> </span><span class="p">:</span><span class="n">big</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">wrapper</span><span class="p">;</span>
<span class="p">...</span>

<span class="c1">// M-partB.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">partB</span><span class="p">;</span>
<span class="nl">import</span><span class="w"> </span><span class="p">:</span><span class="n">big</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">wrapper</span><span class="p">;</span>
<span class="p">...</span>

<span class="c1">// other partitions</span>
<span class="p">...</span>

<span class="c1">// M-partZ.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">partZ</span><span class="p">;</span>
<span class="nl">import</span><span class="w"> </span><span class="p">:</span><span class="n">big</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">wrapper</span><span class="p">;</span>
<span class="p">...</span>

<span class="c1">// M.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">partA</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">partB</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">partZ</span><span class="p">;</span>

<span class="c1">// use.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="p">...</span><span class="w"> </span><span class="c1">// use declarations from module M.</span>
</pre></div>
</div>
<p>Reducing the duplication from textual includes is what improves compile-time
performance.</p>
<p>To help users to identify such issues, we add a warning <code class="docutils literal notranslate"><span class="pre">-Wdecls-in-multiple-modules</span></code>.
This warning is disabled by default and it needs to be explicitly enabled or by <code class="docutils literal notranslate"><span class="pre">-Weverything</span></code>.</p>
</section>
</section>
<section id="transitioning-to-modules">
<h3><a class="toc-backref" href="#id39" role="doc-backlink">Transitioning to modules</a><a class="headerlink" href="#transitioning-to-modules" title="Link to this heading">¶</a></h3>
<p>It is best for new code and libraries to use modules from the start if
possible. However, it may be a breaking change for existing code or libraries
to switch to modules. As a result, many existing libraries need to provide
both headers and module interfaces for a while to not break existing users.</p>
<p>This section suggests some suggestions on how to ease the transition process
for existing libraries. <strong>Note that this information is only intended as
guidance, rather than as requirements to use modules in Clang.</strong> It presumes
the project is starting with no module-based dependencies.</p>
<section id="abi-non-breaking-styles">
<h4><a class="toc-backref" href="#id40" role="doc-backlink">ABI non-breaking styles</a><a class="headerlink" href="#abi-non-breaking-styles" title="Link to this heading">¶</a></h4>
<section id="export-using-style">
<h5><a class="toc-backref" href="#id41" role="doc-backlink">export-using style</a><a class="headerlink" href="#export-using-style" title="Link to this heading">¶</a></h5>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_1.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_2.h&quot;</span>
<span class="p">...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_n.h&quot;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">your_library</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">your_namespace</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">decl_1</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">decl_2</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">decl_n</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This example shows how to include all the headers containing declarations which
need to be exported, and uses <cite>using</cite> declarations in an <cite>export</cite> block to
produce the module interface.</p>
</section>
<section id="export-extern-c-style">
<h5><a class="toc-backref" href="#id42" role="doc-backlink">export extern-C++ style</a><a class="headerlink" href="#export-extern-c-style" title="Link to this heading">¶</a></h5>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;third_party/A/headers.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;third_party/B/headers.h&quot;</span>
<span class="p">...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;third_party/Z/headers.h&quot;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">your_library</span><span class="p">;</span>
<span class="cp">#define IN_MODULE_INTERFACE</span>
<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C++&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_1.h&quot;</span>
<span class="w">  </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_2.h&quot;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_n.h&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Headers (from <code class="docutils literal notranslate"><span class="pre">header_1.h</span></code> to <code class="docutils literal notranslate"><span class="pre">header_n.h</span></code>) need to define the macro:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef IN_MODULE_INTERFACE</span>
<span class="cp">#define EXPORT export</span>
<span class="cp">#else</span>
<span class="cp">#define EXPORT</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>and put <code class="docutils literal notranslate"><span class="pre">EXPORT</span></code> on the declarations you want to export.</p>
<p>Also, it is recommended to refactor headers to include third-party headers
conditionally:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef IN_MODULE_INTERFACE</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;third_party/A/headers.h&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_x.h&quot;</span>

<span class="p">...</span>
</pre></div>
</div>
<p>This can be helpful because it gives better diagnostic messages if the module
interface unit is not properly updated when modifying code.</p>
<p>This approach works because the declarations with language linkage are attached
to the global module. Thus, the ABI of the modular form of the library does not
change.</p>
<p>While this style is more involved than the export-using style, it makes it
easier to further refactor the library to other styles.</p>
</section>
</section>
<section id="abi-breaking-style">
<h4><a class="toc-backref" href="#id43" role="doc-backlink">ABI breaking style</a><a class="headerlink" href="#abi-breaking-style" title="Link to this heading">¶</a></h4>
<p>The term <code class="docutils literal notranslate"><span class="pre">ABI</span> <span class="pre">breaking</span></code> may sound like a bad approach. However, this style
forces consumers of the library use it in a consistent way. e.g., either always
include headers for the library or always import modules. The style prevents
the ability to mix includes and imports for the library.</p>
<p>The pattern for ABI breaking style is similar to the export extern-C++ style.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;third_party/A/headers.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;third_party/B/headers.h&quot;</span>
<span class="p">...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;third_party/Z/headers.h&quot;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">your_library</span><span class="p">;</span>
<span class="cp">#define IN_MODULE_INTERFACE</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_1.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_2.h&quot;</span>
<span class="p">...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_n.h&quot;</span>

<span class="cp">#if the number of .cpp files in your project are small</span>
<span class="nl">module</span><span class="w"> </span><span class="p">:</span><span class="k">private</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;source_1.cpp&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;source_2.cpp&quot;</span>
<span class="p">...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;source_n.cpp&quot;</span>
<span class="cp">#else </span><span class="c1">// the number of .cpp files in your project are a lot</span>
<span class="c1">// Using all the declarations from third-party libraries which are</span>
<span class="c1">// used in the .cpp files.</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">third_party_namespace</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">third_party_decl_used_in_cpp_1</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">third_party_decl_used_in_cpp_2</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">third_party_decl_used_in_cpp_n</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>(And add <cite>EXPORT</cite> and conditional include to the headers as suggested in the
export extern-C++ style section.)</p>
<p>The ABI with modules is different and thus we need to compile the source files
into the new ABI. This is done by an additional part of the interface unit:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#if the number of .cpp files in your project are small</span>
<span class="nl">module</span><span class="w"> </span><span class="p">:</span><span class="k">private</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;source_1.cpp&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;source_2.cpp&quot;</span>
<span class="p">...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;source_n.cpp&quot;</span>
<span class="cp">#else </span><span class="c1">// the number of .cpp files in your project are a lot</span>
<span class="c1">// Using all the declarations from third-party libraries which are</span>
<span class="c1">// used in the .cpp files.</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">third_party_namespace</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">third_party_decl_used_in_cpp_1</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">third_party_decl_used_in_cpp_2</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">third_party_decl_used_in_cpp_n</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>If the number of source files is small, everything can be put in the private
module fragment directly (it is recommended to add conditional includes to the
source files as well). However, compile time performance will be bad if there
are a lot of source files to compile.</p>
<p><strong>Note that the private module fragment can only be in the primary module
interface unit and the primary module interface unit containing the private
module fragment should be the only module unit of the corresponding module.</strong></p>
<p>In this case, source files (.cpp files) must be converted to module
implementation units:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef IN_MODULE_INTERFACE</span>
<span class="c1">// List all the includes here.</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;third_party/A/headers.h&quot;</span>
<span class="p">...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header.h&quot;</span>
<span class="cp">#endif</span>

<span class="k">module</span><span class="w"> </span><span class="n">your_library</span><span class="p">;</span>

<span class="c1">// Following off should be unchanged.</span>
<span class="p">...</span>
</pre></div>
</div>
<p>The module implementation unit will import the primary module implicitly. Do
not include any headers in the module implementation units as it avoids
duplicated declarations between translation units. This is why non-exported
using declarations should be added from third-party libraries in the primary
module interface unit.</p>
<p>If the library is provided as <code class="docutils literal notranslate"><span class="pre">libyour_library.so</span></code>, a modular library (e.g.,
<code class="docutils literal notranslate"><span class="pre">libyour_library_modules.so</span></code>) may also need to be provided for ABI
compatibility.</p>
<section id="what-if-there-are-headers-only-included-by-the-source-files">
<h5><a class="toc-backref" href="#id44" role="doc-backlink">What if there are headers only included by the source files</a><a class="headerlink" href="#what-if-there-are-headers-only-included-by-the-source-files" title="Link to this heading">¶</a></h5>
<p>The above practice may be problematic if there are headers only included by the
source files. When using a private module fragment, this issue may be solved by
including those headers in the private module fragment. While it is OK to solve
it by including the implementation headers in the module purview when using
implementation module units, it may be suboptimal because the primary module
interface units now contain entities that do not belong to the interface.</p>
<p>This can potentially be improved by introducing a module partition
implementation unit. An internal module partition unit is an importable
module unit which is internal to the module itself.</p>
</section>
</section>
<section id="providing-a-header-to-skip-parsing-redundant-headers">
<h4><a class="toc-backref" href="#id45" role="doc-backlink">Providing a header to skip parsing redundant headers</a><a class="headerlink" href="#providing-a-header-to-skip-parsing-redundant-headers" title="Link to this heading">¶</a></h4>
<p>Many redeclarations shared between translation units causes Clang to have
slower compile-time performance. Further, there are known issues with
<a class="reference external" href="https://github.com/llvm/llvm-project/issues/61465">include after import</a>.
Even when that issue is resolved, users may still get slower compilation speed
and larger BMIs. For these reasons, it is recommended to not include headers
after importing the corresponding module. However, it is not always easy if the
library is included by other dependencies, as in:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;third_party/A.h&quot;</span><span class="c1"> // #include &quot;your_library/a_header.h&quot;</span>
<span class="k">import</span><span class="w"> </span><span class="n">your_library</span><span class="p">;</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="n">your_library</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;third_party/A.h&quot;</span><span class="c1"> // #include &quot;your_library/a_header.h&quot;</span>
</pre></div>
</div>
<p>For such cases, it is best if the library providing both module and header
interfaces also provides a header which skips parsing so that the library can
be imported with the following approach that skips redundant redeclarations:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="n">your_library</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;your_library_imported.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;third_party/A.h&quot;</span><span class="c1"> // #include &quot;your_library/a_header.h&quot; but got skipped</span>
</pre></div>
</div>
<p>The implementation of <code class="docutils literal notranslate"><span class="pre">your_library_imported.h</span></code> can be a set of controlling
macros or an overall controlling macro if using <cite>#pragma once</cite>. Then headers
can be refactored to:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>
<span class="cp">#ifndef YOUR_LIBRARY_IMPORTED</span>
<span class="p">...</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>If the modules imported by the library provide such headers, remember to add
them to <code class="docutils literal notranslate"><span class="pre">your_library_imported.h</span></code> too.</p>
</section>
<section id="importing-modules">
<h4><a class="toc-backref" href="#id46" role="doc-backlink">Importing modules</a><a class="headerlink" href="#importing-modules" title="Link to this heading">¶</a></h4>
<p>When there are library dependencies providing modules, the module dependencies
should be imported in your module as well. Many existing libraries will fall
into this category once the <code class="docutils literal notranslate"><span class="pre">std</span></code> module is more widely available.</p>
<section id="all-library-dependencies-providing-modules">
<h5><a class="toc-backref" href="#id47" role="doc-backlink">All library dependencies providing modules</a><a class="headerlink" href="#all-library-dependencies-providing-modules" title="Link to this heading">¶</a></h5>
<p>Of course, most of the complexity disappears if all the library dependencies
provide modules.</p>
<p>Headers need to be converted to include third-party headers conditionally. Then,
for the export-using style:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="n">modules_from_third_party</span><span class="p">;</span>
<span class="cp">#define IN_MODULE_INTERFACE</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_1.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_2.h&quot;</span>
<span class="p">...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_n.h&quot;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">your_library</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">your_namespace</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">decl_1</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">decl_2</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">decl_n</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>or, for the export extern-C++ style:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">your_library</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="n">modules_from_third_party</span><span class="p">;</span>
<span class="cp">#define IN_MODULE_INTERFACE</span>
<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C++&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_1.h&quot;</span>
<span class="w">  </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_2.h&quot;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_n.h&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>or, for the ABI-breaking style,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">your_library</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="n">modules_from_third_party</span><span class="p">;</span>
<span class="cp">#define IN_MODULE_INTERFACE</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_1.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_2.h&quot;</span>
<span class="p">...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_n.h&quot;</span>

<span class="cp">#if the number of .cpp files in your project are small</span>
<span class="nl">module</span><span class="w"> </span><span class="p">:</span><span class="k">private</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;source_1.cpp&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;source_2.cpp&quot;</span>
<span class="p">...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;source_n.cpp&quot;</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>Non-exported <code class="docutils literal notranslate"><span class="pre">using</span></code> declarations are unnecessary if using implementation
module units. Instead, third-party modules can be imported directly in
implementation module units.</p>
</section>
<section id="partial-library-dependencies-providing-modules">
<h5><a class="toc-backref" href="#id48" role="doc-backlink">Partial library dependencies providing modules</a><a class="headerlink" href="#partial-library-dependencies-providing-modules" title="Link to this heading">¶</a></h5>
<p>If the library has to mix the use of <code class="docutils literal notranslate"><span class="pre">include</span></code> and <code class="docutils literal notranslate"><span class="pre">import</span></code> in its module,
the primary goal is still the removal of duplicated declarations in translation
units as much as possible. If the imported modules provide headers to skip
parsing their headers, those should be included after the import. If the
imported modules don’t provide such a header, one can be made manually for
improved compile time performance.</p>
</section>
</section>
</section>
<section id="reachability-of-internal-partition-units">
<h3><a class="toc-backref" href="#id49" role="doc-backlink">Reachability of internal partition units</a><a class="headerlink" href="#reachability-of-internal-partition-units" title="Link to this heading">¶</a></h3>
<p>The internal partition units are sometimes called implementation partition units in other documentation.
However, the name may be confusing since implementation partition units are not implementation
units.</p>
<p>According to <a class="reference external" href="https://eel.is/c++draft/module.reach#1">[module.reach]p1</a> and
<a class="reference external" href="https://eel.is/c++draft/module.reach#2">[module.reach]p2</a> (from N4986):</p>
<blockquote>
<div><p>A translation unit U is necessarily reachable from a point P if U is a module
interface unit on which the translation unit containing P has an interface
dependency, or the translation unit containing P imports U, in either case
prior to P.</p>
<p>All translation units that are necessarily reachable are reachable. Additional
translation units on which the point within the program has an interface
dependency may be considered reachable, but it is unspecified which are and
under what circumstances.</p>
</div></blockquote>
<p>For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// a.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="n">B</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">g</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// b.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">B</span><span class="p">;</span>
<span class="nl">import</span><span class="w"> </span><span class="p">:</span><span class="n">C</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">g</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">f</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// c.cppm</span>
<span class="k">module</span><span class="w"> </span><span class="n">B</span><span class="o">:</span><span class="n">C</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">f</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{}</span>
</pre></div>
</div>
<p>The internal partition unit <code class="docutils literal notranslate"><span class="pre">c.cppm</span></code> is not necessarily reachable by
<code class="docutils literal notranslate"><span class="pre">a.cpp</span></code> because <code class="docutils literal notranslate"><span class="pre">c.cppm</span></code> is not a module interface unit and <code class="docutils literal notranslate"><span class="pre">a.cpp</span></code>
doesn’t import <code class="docutils literal notranslate"><span class="pre">c.cppm</span></code>. This leaves it up to the compiler to decide if
<code class="docutils literal notranslate"><span class="pre">c.cppm</span></code> is reachable by <code class="docutils literal notranslate"><span class="pre">a.cpp</span></code> or not. Clang’s behavior is that
indirectly imported internal partition units are not reachable.</p>
<p>The suggested approach for using an internal partition unit in Clang is
to only import them in the implementation unit.</p>
</section>
<section id="known-issues">
<h3><a class="toc-backref" href="#id50" role="doc-backlink">Known Issues</a><a class="headerlink" href="#known-issues" title="Link to this heading">¶</a></h3>
<p>The following describes issues in the current implementation of modules. Please
see
<a class="reference external" href="https://github.com/llvm/llvm-project/labels/clang%3Amodules">the issues list for modules</a>
for a list of issues or to file a new issue if you don’t find an existing one.
When creating a new issue for standard C++ modules, please start the title with
<code class="docutils literal notranslate"><span class="pre">[C++20]</span> <span class="pre">[Modules]</span></code> (or <code class="docutils literal notranslate"><span class="pre">[C++23]</span> <span class="pre">[Modules]</span></code>, etc) and add the label
<code class="docutils literal notranslate"><span class="pre">clang:modules</span></code> if possible.</p>
<p>A high-level overview of support for standards features, including modules, can
be found on the <a class="reference external" href="https://clang.llvm.org/cxx_status.html">C++ Feature Status</a>
page.</p>
<section id="including-headers-after-import-is-not-well-supported">
<h4><a class="toc-backref" href="#id51" role="doc-backlink">Including headers after import is not well-supported</a><a class="headerlink" href="#including-headers-after-import-is-not-well-supported" title="Link to this heading">¶</a></h4>
<p>The following example is accepted:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">import</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"> </span><span class="c1">// assume module &#39;foo&#39; contain the declarations from `&lt;iostream&gt;`</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Test</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>but if the order of <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;iostream&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">foo;</span></code> is reversed,
then the code is currently rejected:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"> </span><span class="c1">// assume module &#39;foo&#39; contain the declarations from `&lt;iostream&gt;`</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Test</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Both of the above examples should be accepted.</p>
<p>This is a limitation of the implementation. In the first example, the compiler
will see and parse <code class="docutils literal notranslate"><span class="pre">&lt;iostream&gt;</span></code> first then it will see the <code class="docutils literal notranslate"><span class="pre">import</span></code>. In
this case, ODR checking and declaration merging will happen in the
deserializer. In the second example, the compiler will see the <code class="docutils literal notranslate"><span class="pre">import</span></code> first
and the <code class="docutils literal notranslate"><span class="pre">#include</span></code> second which results in ODR checking and declarations
merging happening in the semantic analyzer. This is due to a divergence in the
implementation path. This is tracked by
<a class="reference external" href="https://github.com/llvm/llvm-project/issues/61465">#61465</a>.</p>
</section>
<section id="ignored-preferred-name-attribute">
<h4><a class="toc-backref" href="#id52" role="doc-backlink">Ignored <code class="docutils literal notranslate"><span class="pre">preferred_name</span></code> Attribute</a><a class="headerlink" href="#ignored-preferred-name-attribute" title="Link to this heading">¶</a></h4>
<p>When Clang writes BMIs, it will ignore the <code class="docutils literal notranslate"><span class="pre">preferred_name</span></code> attribute on
declarations which use it. Thus, the preferred name will not be displayed in
the debugger as expected. This is tracked by
<a class="reference external" href="https://github.com/llvm/llvm-project/issues/56490">#56490</a>.</p>
</section>
<section id="don-t-emit-macros-about-module-declaration">
<h4><a class="toc-backref" href="#id53" role="doc-backlink">Don’t emit macros about module declaration</a><a class="headerlink" href="#don-t-emit-macros-about-module-declaration" title="Link to this heading">¶</a></h4>
<p>This is covered by <a class="reference external" href="https://wg21.link/P1857R3">P1857R3</a>. It is mentioned here
because we want users to be aware that we don’t yet implement it.</p>
<p>A direct approach to write code that can be compiled by both modules and
non-module builds may look like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MODULE</span>
<span class="n">IMPORT</span><span class="w"> </span><span class="n">header_name</span>
<span class="n">EXPORT_MODULE</span><span class="w"> </span><span class="n">MODULE_NAME</span><span class="p">;</span>
<span class="n">IMPORT</span><span class="w"> </span><span class="n">header_name</span>
<span class="n">EXPORT</span><span class="w"> </span><span class="p">...</span>
</pre></div>
</div>
<p>The intent of this is that this file can be compiled like a module unit or a
non-module unit depending on the definition of some macros. However, this usage
is forbidden by P1857R3 which is not yet implemented in Clang. This means that
is possible to write invalid modules which will no longer be accepted once
P1857R3 is implemented. This is tracked by
<a class="reference external" href="https://github.com/llvm/llvm-project/issues/54047">#54047</a>.</p>
<p>Until then, it is recommended not to mix macros with module declarations.</p>
</section>
<section id="in-consistent-filename-suffix-requirement-for-importable-module-units">
<h4><a class="toc-backref" href="#id54" role="doc-backlink">In consistent filename suffix requirement for importable module units</a><a class="headerlink" href="#in-consistent-filename-suffix-requirement-for-importable-module-units" title="Link to this heading">¶</a></h4>
<p>Currently, Clang requires the file name of an <code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code> to
have <code class="docutils literal notranslate"><span class="pre">.cppm</span></code> (or <code class="docutils literal notranslate"><span class="pre">.ccm</span></code>, <code class="docutils literal notranslate"><span class="pre">.cxxm</span></code>, <code class="docutils literal notranslate"><span class="pre">.c++m</span></code>) as the file extension.
However, the behavior is inconsistent with other compilers. This is tracked by
<a class="reference external" href="https://github.com/llvm/llvm-project/issues/57416">#57416</a>.</p>
</section>
<section id="incorrect-odr-violation-diagnostics">
<h4><a class="toc-backref" href="#id55" role="doc-backlink">Incorrect ODR violation diagnostics</a><a class="headerlink" href="#incorrect-odr-violation-diagnostics" title="Link to this heading">¶</a></h4>
<p>ODR violations are a common issue when using modules. Clang sometimes produces
false-positive diagnostics or fails to produce true-positive diagnostics of the
One Definition Rule. One often-reported example is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// part.cc</span>
<span class="k">module</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">T</span><span class="p">;</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">ns</span><span class="w"> </span><span class="p">{</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">fun</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="kt">void</span><span class="p">)(</span><span class="n">T</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">repro</span><span class="o">:</span><span class="n">part</span><span class="p">;</span>

<span class="c1">// repro.cc</span>
<span class="k">module</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">T</span><span class="p">;</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">ns</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">T</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">ns</span><span class="w"> </span><span class="p">{</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">fun</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="kt">void</span><span class="p">)(</span><span class="n">T</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">repro</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">part</span><span class="p">;</span>
</pre></div>
</div>
<p>Currently the compiler incorrectly diagnoses the inconsistent definition of
<code class="docutils literal notranslate"><span class="pre">fun()</span></code> in two module units. Because both definitions of <code class="docutils literal notranslate"><span class="pre">fun()</span></code> have the
same spelling and <code class="docutils literal notranslate"><span class="pre">T</span></code> refers to the same type entity, there is no ODR
violation. This is tracked by
<a class="reference external" href="https://github.com/llvm/llvm-project/issues/78850">#78850</a>.</p>
</section>
<section id="using-tu-local-entity-in-other-units">
<h4><a class="toc-backref" href="#id56" role="doc-backlink">Using TU-local entity in other units</a><a class="headerlink" href="#using-tu-local-entity-in-other-units" title="Link to this heading">¶</a></h4>
<p>Module units are translation units, so the entities which should be local to
the module unit itself should never be used by other units.</p>
<p>The C++ standard defines the concept of <code class="docutils literal notranslate"><span class="pre">TU-local</span></code> and <code class="docutils literal notranslate"><span class="pre">exposure</span></code> in
<a class="reference external" href="https://eel.is/c++draft/basic.link#14">basic.link/p14</a>,
<a class="reference external" href="https://eel.is/c++draft/basic.link#15">basic.link/p15</a>,
<a class="reference external" href="https://eel.is/c++draft/basic.link#16">basic.link/p16</a>,
<a class="reference external" href="https://eel.is/c++draft/basic.link#17">basic.link/p17</a>, and
<a class="reference external" href="https://eel.is/c++draft/basic.link#18">basic.link/p18</a>.</p>
<p>However, Clang doesn’t formally support these two concepts. This results in
unclear or confusing diagnostic messages. Further, Clang may import
<code class="docutils literal notranslate"><span class="pre">TU-local</span></code> entities to other units without any diagnostics. This is tracked
by <a class="reference external" href="https://github.com/llvm/llvm-project/issues/78173">#78173</a>.</p>
</section>
</section>
</section>
<section id="header-units">
<span id="id9"></span><h2><a class="toc-backref" href="#id57" role="doc-backlink">Header Units</a><a class="headerlink" href="#header-units" title="Link to this heading">¶</a></h2>
<section id="how-to-build-projects-using-header-units">
<h3><a class="toc-backref" href="#id58" role="doc-backlink">How to build projects using header units</a><a class="headerlink" href="#how-to-build-projects-using-header-units" title="Link to this heading">¶</a></h3>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The support for header units, including related command line options, is
experimental. There are still many unanswered question about how tools
should interact with header units. The details described here may change in
the future.</p>
</div>
<section id="id10">
<h4><a class="toc-backref" href="#id59" role="doc-backlink">Quick Start</a><a class="headerlink" href="#id10" title="Link to this heading">¶</a></h4>
<p>The following example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello World.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>could be compiled with:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-xc++-system-header<span class="w"> </span>--precompile<span class="w"> </span>iostream<span class="w"> </span>-o<span class="w"> </span>iostream.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-fmodule-file<span class="o">=</span>iostream.pcm<span class="w"> </span>main.cpp
</pre></div>
</div>
</section>
<section id="how-to-produce-bmis">
<h4><a class="toc-backref" href="#id60" role="doc-backlink">How to produce BMIs</a><a class="headerlink" href="#how-to-produce-bmis" title="Link to this heading">¶</a></h4>
<p>Similar to named modules, <code class="docutils literal notranslate"><span class="pre">--precompile</span></code> can be used to produce a BMI.
However, that requires specifying that the input file is a header by using
<code class="docutils literal notranslate"><span class="pre">-xc++-system-header</span></code> or <code class="docutils literal notranslate"><span class="pre">-xc++-user-header</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">-fmodule-header={user,system}</span></code> option can also be used to produce a BMI
for header units which have a file extension like <cite>.h</cite> or <cite>.hh</cite>. The argument to
<code class="docutils literal notranslate"><span class="pre">-fmodule-header</span></code> specifies either the user search path or the system search
path. The default value for <code class="docutils literal notranslate"><span class="pre">-fmodule-header</span></code> is <code class="docutils literal notranslate"><span class="pre">user</span></code>. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// foo.h</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello World.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// use.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="s">&quot;foo.h&quot;</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Hello</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>could be compiled with:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-fmodule-header<span class="w"> </span>foo.h<span class="w"> </span>-o<span class="w"> </span>foo.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-fmodule-file<span class="o">=</span>foo.pcm<span class="w"> </span>use.cpp
</pre></div>
</div>
<p>For headers which do not have a file extension, <code class="docutils literal notranslate"><span class="pre">-xc++-header</span></code> (or
<code class="docutils literal notranslate"><span class="pre">-xc++-system-header</span></code>, <code class="docutils literal notranslate"><span class="pre">-xc++-user-header</span></code>) must be used to specify the
file as a header. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// use.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="s">&quot;foo.h&quot;</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Hello</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-fmodule-header<span class="o">=</span>system<span class="w"> </span>-xc++-header<span class="w"> </span>iostream<span class="w"> </span>-o<span class="w"> </span>iostream.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-fmodule-file<span class="o">=</span>iostream.pcm<span class="w"> </span>use.cpp
</pre></div>
</div>
</section>
<section id="how-to-specify-bmi-dependencies">
<h4><a class="toc-backref" href="#id61" role="doc-backlink">How to specify BMI dependencies</a><a class="headerlink" href="#how-to-specify-bmi-dependencies" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">-fmodule-file</span></code> can be used to specify a BMI dependency (or multiple times for
more than one BMI dependency).</p>
<p>With the existing implementation, <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code> cannot be used for
header units (because they are nominally anonymous). For header units, use
<code class="docutils literal notranslate"><span class="pre">-fmodule-file</span></code> to include the relevant PCM file for each header unit.</p>
<p>This is expected to be solved in a future version of Clang either by the compiler
finding and specifying <code class="docutils literal notranslate"><span class="pre">-fmodule-file</span></code> automatically, or by the use of a
module-mapper that understands how to map the header name to their PCMs.</p>
</section>
<section id="compiling-a-header-unit-to-an-object-file">
<h4><a class="toc-backref" href="#id62" role="doc-backlink">Compiling a header unit to an object file</a><a class="headerlink" href="#compiling-a-header-unit-to-an-object-file" title="Link to this heading">¶</a></h4>
<p>A header unit cannot be compiled to an object file due to the semantics of
header units. For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-xc++-system-header<span class="w"> </span>--precompile<span class="w"> </span>iostream<span class="w"> </span>-o<span class="w"> </span>iostream.pcm
<span class="gp"># </span>This<span class="w"> </span>is<span class="w"> </span>not<span class="w"> </span>allowed!
<span class="gp">$ </span>clang++<span class="w"> </span>iostream.pcm<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>iostream.o
</pre></div>
</div>
</section>
<section id="include-translation">
<h4><a class="toc-backref" href="#id63" role="doc-backlink">Include translation</a><a class="headerlink" href="#include-translation" title="Link to this heading">¶</a></h4>
<p>The C++ standard allows vendors to convert <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">header-name</span></code> to
<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">header-name;</span></code> when possible. Currently, Clang does this translation
for the <code class="docutils literal notranslate"><span class="pre">#include</span></code> in the global module fragment. For example, the following
example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>is the same as this example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-xc++-system-header<span class="w"> </span>--precompile<span class="w"> </span>iostream<span class="w"> </span>-o<span class="w"> </span>iostream.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-fmodule-file<span class="o">=</span>iostream.pcm<span class="w"> </span>--precompile<span class="w"> </span>M.cppm<span class="w"> </span>-o<span class="w"> </span>M.cpp
</pre></div>
</div>
<p>In the latter example, Clang can find the BMI for <code class="docutils literal notranslate"><span class="pre">&lt;iostream&gt;</span></code> and so it
tries to replace the <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;iostream&gt;</span></code> with <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">&lt;iostream&gt;;</span></code>
automatically.</p>
</section>
</section>
<section id="differences-between-clang-modules-and-header-units">
<h3><a class="toc-backref" href="#id64" role="doc-backlink">Differences between Clang modules and header units</a><a class="headerlink" href="#differences-between-clang-modules-and-header-units" title="Link to this heading">¶</a></h3>
<p>Header units have similar semantics to Clang modules. The semantics of both are
like headers. Therefore, header units can be mimicked by Clang modules as in
the following example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="s">&quot;iostream&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">export</span><span class="w"> </span><span class="o">*</span>
<span class="w">  </span><span class="n">header</span><span class="w"> </span><span class="s">&quot;/path/to/libstdcxx/iostream&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-fimplicit-modules<span class="w"> </span>-fmodule-map-file<span class="o">=</span>.modulemap<span class="w"> </span>main.cpp
</pre></div>
</div>
<p>This example is simplified when using libc++:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>main.cpp<span class="w"> </span>-fimplicit-modules<span class="w"> </span>-fimplicit-module-maps
</pre></div>
</div>
<p>because libc++ already supplies a
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/module.modulemap.in">module map</a>.</p>
<p>This raises the question: why are header units not implemented through Clang
modules?</p>
<p>This is primarily because Clang modules have more hierarchical semantics when
wrapping multiple headers together as one module, which is not supported by
Standard C++ Header units. We want to avoid the impression that these
additional semantics get interpreted as Standard C++ behavior.</p>
<p>Another reason is that there are proposals to introduce module mappers to the
C++ standard (for example, <a class="reference external" href="https://wg21.link/p1184r2">https://wg21.link/p1184r2</a>). Reusing Clang’s
<code class="docutils literal notranslate"><span class="pre">modulemap</span></code> may be more difficult if we need to introduce another module
mapper.</p>
</section>
</section>
<section id="discovering-dependencies">
<h2><a class="toc-backref" href="#id65" role="doc-backlink">Discovering Dependencies</a><a class="headerlink" href="#discovering-dependencies" title="Link to this heading">¶</a></h2>
<p>Without use of modules, all the translation units in a project can be compiled
in parallel. However, the presence of module units requires compiling the
translation units in a topological order.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">clang-scan-deps</span></code> tool can extract dependency information and produce a
JSON file conforming to the specification described in
<a class="reference external" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1689r5.html">P1689</a>.
Only named modules are supported currently.</p>
<p>A compilation database is needed when using <code class="docutils literal notranslate"><span class="pre">clang-scan-deps</span></code>. See
<a class="reference external" href="JSONCompilationDatabase.html">JSON Compilation Database Format Specification</a>
for more information about compilation databases. Note that the <code class="docutils literal notranslate"><span class="pre">output</span></code>
JSON attribute is necessary for <code class="docutils literal notranslate"><span class="pre">clang-scan-deps</span></code> to scan using the P1689
format. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//--- M.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">interface_part</span><span class="p">;</span>
<span class="nl">import</span><span class="w"> </span><span class="p">:</span><span class="n">impl_part</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">Hello</span><span class="p">();</span>

<span class="c1">//--- interface_part.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">interface_part</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">World</span><span class="p">();</span>

<span class="c1">//--- Impl.cpp</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello &quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//--- impl_part.cppm</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">impl_part</span><span class="p">;</span>
<span class="nl">import</span><span class="w"> </span><span class="p">:</span><span class="n">interface_part</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;World.&quot;</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">World</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//--- User.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="n">third_party_module</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Hello</span><span class="p">();</span>
<span class="w">  </span><span class="n">World</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And here is the compilation database:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>[
{
    &quot;directory&quot;: &quot;.&quot;,
    &quot;command&quot;: &quot;&lt;path-to-compiler-executable&gt;/clang++ -std=c++20 M.cppm -c -o M.o&quot;,
    &quot;file&quot;: &quot;M.cppm&quot;,
    &quot;output&quot;: &quot;M.o&quot;
},
{
    &quot;directory&quot;: &quot;.&quot;,
    &quot;command&quot;: &quot;&lt;path-to-compiler-executable&gt;/clang++ -std=c++20 Impl.cpp -c -o Impl.o&quot;,
    &quot;file&quot;: &quot;Impl.cpp&quot;,
    &quot;output&quot;: &quot;Impl.o&quot;
},
{
    &quot;directory&quot;: &quot;.&quot;,
    &quot;command&quot;: &quot;&lt;path-to-compiler-executable&gt;/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o&quot;,
    &quot;file&quot;: &quot;impl_part.cppm&quot;,
    &quot;output&quot;: &quot;impl_part.o&quot;
},
{
    &quot;directory&quot;: &quot;.&quot;,
    &quot;command&quot;: &quot;&lt;path-to-compiler-executable&gt;/clang++ -std=c++20 interface_part.cppm -c -o interface_part.o&quot;,
    &quot;file&quot;: &quot;interface_part.cppm&quot;,
    &quot;output&quot;: &quot;interface_part.o&quot;
},
{
    &quot;directory&quot;: &quot;.&quot;,
    &quot;command&quot;: &quot;&lt;path-to-compiler-executable&gt;/clang++ -std=c++20 User.cpp -c -o User.o&quot;,
    &quot;file&quot;: &quot;User.cpp&quot;,
    &quot;output&quot;: &quot;User.o&quot;
}
]
</pre></div>
</div>
<p>To get the dependency information in P1689 format, use:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang-scan-deps<span class="w"> </span>-format<span class="o">=</span>p1689<span class="w"> </span>-compilation-database<span class="w"> </span>P1689.json
</pre></div>
</div>
<p>to get:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{
  &quot;revision&quot;: 0,
  &quot;rules&quot;: [
    {
      &quot;primary-output&quot;: &quot;Impl.o&quot;,
      &quot;requires&quot;: [
        {
          &quot;logical-name&quot;: &quot;M&quot;,
          &quot;source-path&quot;: &quot;M.cppm&quot;
        }
      ]
    },
    {
      &quot;primary-output&quot;: &quot;M.o&quot;,
      &quot;provides&quot;: [
        {
          &quot;is-interface&quot;: true,
          &quot;logical-name&quot;: &quot;M&quot;,
          &quot;source-path&quot;: &quot;M.cppm&quot;
        }
      ],
      &quot;requires&quot;: [
        {
          &quot;logical-name&quot;: &quot;M:interface_part&quot;,
          &quot;source-path&quot;: &quot;interface_part.cppm&quot;
        },
        {
          &quot;logical-name&quot;: &quot;M:impl_part&quot;,
          &quot;source-path&quot;: &quot;impl_part.cppm&quot;
        }
      ]
    },
    {
      &quot;primary-output&quot;: &quot;User.o&quot;,
      &quot;requires&quot;: [
        {
          &quot;logical-name&quot;: &quot;M&quot;,
          &quot;source-path&quot;: &quot;M.cppm&quot;
        },
        {
          &quot;logical-name&quot;: &quot;third_party_module&quot;
        }
      ]
    },
    {
      &quot;primary-output&quot;: &quot;impl_part.o&quot;,
      &quot;provides&quot;: [
        {
          &quot;is-interface&quot;: false,
          &quot;logical-name&quot;: &quot;M:impl_part&quot;,
          &quot;source-path&quot;: &quot;impl_part.cppm&quot;
        }
      ],
      &quot;requires&quot;: [
        {
          &quot;logical-name&quot;: &quot;M:interface_part&quot;,
          &quot;source-path&quot;: &quot;interface_part.cppm&quot;
        }
      ]
    },
    {
      &quot;primary-output&quot;: &quot;interface_part.o&quot;,
      &quot;provides&quot;: [
        {
          &quot;is-interface&quot;: true,
          &quot;logical-name&quot;: &quot;M:interface_part&quot;,
          &quot;source-path&quot;: &quot;interface_part.cppm&quot;
        }
      ]
    }
  ],
  &quot;version&quot;: 1
}
</pre></div>
</div>
<p>See the P1689 paper for the meaning of the fields.</p>
<p>Getting dependency information per file with finer-grained control (such as
scanning generated source files) is possible. For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang-scan-deps<span class="w"> </span>-format<span class="o">=</span>p1689<span class="w"> </span>--<span class="w"> </span>&lt;path-to-compiler-executable&gt;/clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>impl_part.cppm<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>impl_part.o
</pre></div>
</div>
<p>will produce:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{
  &quot;revision&quot;: 0,
  &quot;rules&quot;: [
    {
      &quot;primary-output&quot;: &quot;impl_part.o&quot;,
      &quot;provides&quot;: [
        {
          &quot;is-interface&quot;: false,
          &quot;logical-name&quot;: &quot;M:impl_part&quot;,
          &quot;source-path&quot;: &quot;impl_part.cppm&quot;
        }
      ],
      &quot;requires&quot;: [
        {
          &quot;logical-name&quot;: &quot;M:interface_part&quot;
        }
      ]
    }
  ],
  &quot;version&quot;: 1
}
</pre></div>
</div>
<p>Individual command line options can be specified after <code class="docutils literal notranslate"><span class="pre">--</span></code>.
<code class="docutils literal notranslate"><span class="pre">clang-scan-deps</span></code> will extract the necessary information from the specified
options. Note that the path to the compiler executable needs to be specified
explicitly instead of using <code class="docutils literal notranslate"><span class="pre">clang++</span></code> directly.</p>
<p>Users may want the scanner to get the transitional dependency information for
headers. Otherwise, the project has to be scanned twice, once for headers and
once for modules. To address this, <code class="docutils literal notranslate"><span class="pre">clang-scan-deps</span></code> will recognize the
specified preprocessor options in the given command line and generate the
corresponding dependency information. For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang-scan-deps<span class="w"> </span>-format<span class="o">=</span>p1689<span class="w"> </span>--<span class="w"> </span>../bin/clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>impl_part.cppm<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>impl_part.o<span class="w"> </span>-MD<span class="w"> </span>-MT<span class="w"> </span>impl_part.ddi<span class="w"> </span>-MF<span class="w"> </span>impl_part.dep
<span class="gp">$ </span>cat<span class="w"> </span>impl_part.dep
</pre></div>
</div>
<p>will produce:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>impl_part.ddi: \
  /usr/include/bits/wchar.h /usr/include/bits/types/wint_t.h \
  /usr/include/bits/types/mbstate_t.h \
  /usr/include/bits/types/__mbstate_t.h /usr/include/bits/types/__FILE.h \
  /usr/include/bits/types/FILE.h /usr/include/bits/types/locale_t.h \
  /usr/include/bits/types/__locale_t.h \
  ...
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">clang-scan-deps</span></code> detects the <code class="docutils literal notranslate"><span class="pre">-MF</span></code> option, it will try to write the
dependency information for headers to the file specified by <code class="docutils literal notranslate"><span class="pre">-MF</span></code>.</p>
<section id="possible-issues-failed-to-find-system-headers">
<h3><a class="toc-backref" href="#id66" role="doc-backlink">Possible Issues: Failed to find system headers</a><a class="headerlink" href="#possible-issues-failed-to-find-system-headers" title="Link to this heading">¶</a></h3>
<p>If encountering an error like <code class="docutils literal notranslate"><span class="pre">fatal</span> <span class="pre">error:</span> <span class="pre">'stddef.h'</span> <span class="pre">file</span> <span class="pre">not</span> <span class="pre">found</span></code>,
the specified <code class="docutils literal notranslate"><span class="pre">&lt;path-to-compiler-executable&gt;/clang++</span></code> probably refers to a
symlink instead a real binary. There are four potential solutions to the
problem:</p>
<ol class="arabic">
<li><p>Point the specified compiler executable to the real binary instead of the
symlink.</p></li>
<li><p>Invoke <code class="docutils literal notranslate"><span class="pre">&lt;path-to-compiler-executable&gt;/clang++</span> <span class="pre">-print-resource-dir</span></code> to get
the corresponding resource directory for your compiler and add that
directory to the include search paths manually in the build scripts.</p></li>
<li><p>For build systems that use a compilation database as the input for
<code class="docutils literal notranslate"><span class="pre">clang-scan-deps</span></code>, the build system can add the
<code class="docutils literal notranslate"><span class="pre">--resource-dir-recipe</span> <span class="pre">invoke-compiler</span></code> option when executing
<code class="docutils literal notranslate"><span class="pre">clang-scan-deps</span></code> to calculate the resource directory dynamically.
The calculation happens only once for a unique <code class="docutils literal notranslate"><span class="pre">&lt;path-to-compiler-executable&gt;/clang++</span></code>.</p></li>
<li><p>For build systems that invoke <code class="docutils literal notranslate"><span class="pre">clang-scan-deps</span></code> per file, repeatedly
calculating the resource directory may be inefficient. In such cases, the
build system can cache the resource directory and specify
<code class="docutils literal notranslate"><span class="pre">-resource-dir</span> <span class="pre">&lt;resource-dir&gt;</span></code> explicitly, as in:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang-scan-deps<span class="w"> </span>-format<span class="o">=</span>p1689<span class="w"> </span>--<span class="w"> </span>&lt;path-to-compiler-executable&gt;/clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-resource-dir<span class="w"> </span>&lt;resource-dir&gt;<span class="w"> </span>mod.cppm<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>mod.o
</pre></div>
</div>
</li>
</ol>
</section>
</section>
<section id="import-modules-with-clang-repl">
<h2><a class="toc-backref" href="#id67" role="doc-backlink">Import modules with clang-repl</a><a class="headerlink" href="#import-modules-with-clang-repl" title="Link to this heading">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">clang-repl</span></code> supports importing C++20 named modules. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// M.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">Hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Hello Interpreter for Modules!&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The named module still needs to be compiled ahead of time.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>M.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>M.pcm<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>M.o
<span class="gp">$ </span>clang++<span class="w"> </span>-shared<span class="w"> </span>M.o<span class="w"> </span>-o<span class="w"> </span>libM.so
</pre></div>
</div>
<p>Note that the module unit needs to be compiled as a dynamic library so that
<code class="docutils literal notranslate"><span class="pre">clang-repl</span></code> can load the object files of the module units. Then it is
possible to import module <code class="docutils literal notranslate"><span class="pre">M</span></code> in clang-repl.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang-repl<span class="w"> </span>-Xcc<span class="o">=</span>-std<span class="o">=</span>c++20<span class="w"> </span>-Xcc<span class="o">=</span>-fprebuilt-module-path<span class="o">=</span>.
<span class="gp"># </span>We<span class="w"> </span>need<span class="w"> </span>to<span class="w"> </span>load<span class="w"> </span>the<span class="w"> </span>dynamic<span class="w"> </span>library<span class="w"> </span>first<span class="w"> </span>before<span class="w"> </span>importing<span class="w"> </span>the<span class="w"> </span>modules.
<span class="go">clang-repl&gt; %lib libM.so</span>
<span class="go">clang-repl&gt; import M;</span>
<span class="go">clang-repl&gt; extern &quot;C&quot; int printf(const char *, ...);</span>
<span class="go">clang-repl&gt; printf(&quot;%s\n&quot;, Hello());</span>
<span class="go">Hello Interpreter for Modules!</span>
<span class="go">clang-repl&gt; %quit</span>
</pre></div>
</div>
</section>
<section id="possible-questions">
<h2><a class="toc-backref" href="#id68" role="doc-backlink">Possible Questions</a><a class="headerlink" href="#possible-questions" title="Link to this heading">¶</a></h2>
<section id="how-modules-speed-up-compilation">
<h3><a class="toc-backref" href="#id69" role="doc-backlink">How modules speed up compilation</a><a class="headerlink" href="#how-modules-speed-up-compilation" title="Link to this heading">¶</a></h3>
<p>A classic theory for the reason why modules speed up the compilation is: if
there are <code class="docutils literal notranslate"><span class="pre">n</span></code> headers and <code class="docutils literal notranslate"><span class="pre">m</span></code> source files and each header is included by
each source file, then the complexity of the compilation is <code class="docutils literal notranslate"><span class="pre">O(n*m)</span></code>.
However, if there are <code class="docutils literal notranslate"><span class="pre">n</span></code> module interfaces and <code class="docutils literal notranslate"><span class="pre">m</span></code> source files, the
complexity of the compilation is <code class="docutils literal notranslate"><span class="pre">O(n+m)</span></code>. Therefore, using modules would be
a significant improvement at scale. More simply, use of modules causes many of
the redundant compilations to no longer be necessary.</p>
<p>While this is accurate at a high level, this depends greatly on the
optimization level, as illustrated below.</p>
<p>First is <code class="docutils literal notranslate"><span class="pre">-O0</span></code>. The compilation process is described in the following graph.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>├-------------frontend----------┼-------------middle end----------------┼----backend----┤
│                               │                                       │               │
└---parsing----sema----codegen--┴----- transformations ---- codegen ----┴---- codegen --┘

├---------------------------------------------------------------------------------------┐
|                                                                                       │
|                                     source file                                       │
|                                                                                       │
└---------------------------------------------------------------------------------------┘

            ├--------┐
            │        │
            │imported│
            │        │
            │  code  │
            │        │
            └--------┘
</pre></div>
</div>
<p>In this case, the source file (which could be a non-module unit or a module
unit) would get processed by the entire pipeline. However, the imported code
would only get involved in semantic analysis, which, for the most part, is name
lookup, overload resolution, and template instantiation. All of these processes
are fast relative to the whole compilation process. More importantly, the
imported code only needs to be processed once during frontend code generation,
as well as the whole middle end and backend. So we could get a big win for the
compilation time in <code class="docutils literal notranslate"><span class="pre">-O0</span></code>.</p>
<p>But with optimizations, things are different (the <code class="docutils literal notranslate"><span class="pre">code</span> <span class="pre">generation</span></code> part for
each end is omitted due to limited space):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>├-------- frontend ---------┼--------------- middle end --------------------┼------ backend ----┤
│                           │                                               │                   │
└--- parsing ---- sema -----┴--- optimizations --- IPO ---- optimizations---┴--- optimizations -┘

├-----------------------------------------------------------------------------------------------┐
│                                                                                               │
│                                         source file                                           │
│                                                                                               │
└-----------------------------------------------------------------------------------------------┘
              ├---------------------------------------┐
              │                                       │
              │                                       │
              │            imported code              │
              │                                       │
              │                                       │
              └---------------------------------------┘
</pre></div>
</div>
<p>It would be very unfortunate if we end up with worse performance when using
modules. The main concern is that when a source file is compiled, the compiler
needs to see the body of imported module units so that it can perform IPO
(InterProcedural Optimization, primarily inlining in practice) to optimize
functions in the current source file with the help of the information provided
by the imported module units. In other words, the imported code would be
processed again and again in importee units by optimizations (including IPO
itself). The optimizations before IPO and IPO itself are the most time-consuming
part in whole compilation process. So from this perspective, it might not be
possible to get the compile time improvements described, but there could be
time savings for optimizations after IPO and the whole backend.</p>
<p>Overall, at <code class="docutils literal notranslate"><span class="pre">-O0</span></code> the implementations of functions defined in a module will
not impact module users, but at higher optimization levels the definitions of
such functions are provided to user compilations for the purposes of
optimization (but definitions of these functions are still not included in the
use’s object file). This means the build speedup at higher optimization levels
may be lower than expected given <code class="docutils literal notranslate"><span class="pre">-O0</span></code> experience, but does provide more
optimization opportunities.</p>
</section>
<section id="interoperability-with-clang-modules">
<h3><a class="toc-backref" href="#id70" role="doc-backlink">Interoperability with Clang Modules</a><a class="headerlink" href="#interoperability-with-clang-modules" title="Link to this heading">¶</a></h3>
<p>We <strong>wish</strong> to support Clang modules and standard C++ modules at the same time,
but the mixing them together is not well used/tested yet. Please file new
GitHub issues as you find interoperability problems.</p>
</section>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="SourceBasedCodeCoverage.html">Source-based Code Coverage</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="Modules.html">Modules</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2007-2025, The Clang Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>