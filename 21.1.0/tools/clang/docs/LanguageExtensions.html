<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Clang Language Extensions &#8212; Clang 21.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=e491ac2d" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=eafc0fe6" />
    <script src="_static/documentation_options.js?v=c54a4614"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Objective-C Literals" href="ObjectiveCLiterals.html" />
    <link rel="prev" title="Assembling a Complete Toolchain" href="Toolchain.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Clang 21.1.0 documentation</span></a></h1>
        <h2 class="heading"><span>Clang Language Extensions</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="Toolchain.html">Assembling a Complete Toolchain</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="ObjectiveCLiterals.html">Objective-C Literals</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="clang-language-extensions">
<h1>Clang Language Extensions<a class="headerlink" href="#clang-language-extensions" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id19">Introduction</a></p></li>
<li><p><a class="reference internal" href="#feature-checking-macros" id="id20">Feature Checking Macros</a></p></li>
<li><p><a class="reference internal" href="#include-file-checking-macros" id="id21">Include File Checking Macros</a></p></li>
<li><p><a class="reference internal" href="#builtin-macros" id="id22">Builtin Macros</a></p></li>
<li><p><a class="reference internal" href="#implementation-defined-keywords" id="id23">Implementation-defined keywords</a></p></li>
<li><p><a class="reference internal" href="#vectors-and-extended-vectors" id="id24">Vectors and Extended Vectors</a></p></li>
<li><p><a class="reference internal" href="#matrix-types" id="id25">Matrix Types</a></p></li>
<li><p><a class="reference internal" href="#half-precision-floating-point" id="id26">Half-Precision Floating Point</a></p></li>
<li><p><a class="reference internal" href="#messages-on-deprecated-and-unavailable-attributes" id="id27">Messages on <code class="docutils literal notranslate"><span class="pre">deprecated</span></code> and <code class="docutils literal notranslate"><span class="pre">unavailable</span></code> Attributes</a></p></li>
<li><p><a class="reference internal" href="#attributes-on-enumerators" id="id28">Attributes on Enumerators</a></p></li>
<li><p><a class="reference internal" href="#c-11-attributes-on-using-declarations" id="id29">C++11 Attributes on using-declarations</a></p></li>
<li><p><a class="reference internal" href="#user-specified-system-frameworks" id="id30">‘User-Specified’ System Frameworks</a></p></li>
<li><p><a class="reference internal" href="#checks-for-standard-language-features" id="id31">Checks for Standard Language Features</a></p></li>
<li><p><a class="reference internal" href="#language-extensions-back-ported-to-previous-standards" id="id32">Language Extensions Back-ported to Previous Standards</a></p></li>
<li><p><a class="reference internal" href="#builtin-type-aliases" id="id33">Builtin type aliases</a></p></li>
<li><p><a class="reference internal" href="#type-trait-primitives" id="id34">Type Trait Primitives</a></p></li>
<li><p><a class="reference internal" href="#blocks" id="id35">Blocks</a></p></li>
<li><p><a class="reference internal" href="#asm-goto-with-output-constraints" id="id36">ASM Goto with Output Constraints</a></p></li>
<li><p><a class="reference internal" href="#asm-goto-versus-branch-target-enforcement" id="id37">ASM Goto versus Branch Target Enforcement</a></p></li>
<li><p><a class="reference internal" href="#constexpr-strings-in-gnu-asm-statements" id="id38">Constexpr strings in GNU ASM statements</a></p></li>
<li><p><a class="reference internal" href="#objective-c-features" id="id39">Objective-C Features</a></p></li>
<li><p><a class="reference internal" href="#initializer-lists-for-complex-numbers-in-c" id="id40">Initializer lists for complex numbers in C</a></p></li>
<li><p><a class="reference internal" href="#opencl-features" id="id41">OpenCL Features</a></p></li>
<li><p><a class="reference internal" href="#webassembly-features" id="id42">WebAssembly Features</a></p></li>
<li><p><a class="reference internal" href="#builtin-functions" id="id43">Builtin Functions</a></p></li>
<li><p><a class="reference internal" href="#non-standard-c-11-attributes" id="id44">Non-standard C++11 Attributes</a></p></li>
<li><p><a class="reference internal" href="#target-specific-extensions" id="id45">Target-Specific Extensions</a></p></li>
<li><p><a class="reference internal" href="#extensions-for-static-analysis" id="id46">Extensions for Static Analysis</a></p></li>
<li><p><a class="reference internal" href="#extensions-for-dynamic-analysis" id="id47">Extensions for Dynamic Analysis</a></p></li>
<li><p><a class="reference internal" href="#extensions-for-selectively-disabling-optimization" id="id48">Extensions for selectively disabling optimization</a></p></li>
<li><p><a class="reference internal" href="#extensions-for-loop-hint-optimizations" id="id49">Extensions for loop hint optimizations</a></p></li>
<li><p><a class="reference internal" href="#extensions-to-specify-floating-point-flags" id="id50">Extensions to specify floating-point flags</a></p></li>
<li><p><a class="reference internal" href="#extensions-for-controlling-atomic-code-generation" id="id51">Extensions for controlling atomic code generation</a></p></li>
<li><p><a class="reference internal" href="#specifying-an-attribute-for-multiple-declarations-pragma-clang-attribute" id="id52">Specifying an attribute for multiple declarations (#pragma clang attribute)</a></p></li>
<li><p><a class="reference internal" href="#specifying-section-names-for-global-objects-pragma-clang-section" id="id53">Specifying section names for global objects (#pragma clang section)</a></p></li>
<li><p><a class="reference internal" href="#specifying-linker-options-on-elf-targets" id="id54">Specifying Linker Options on ELF Targets</a></p></li>
<li><p><a class="reference internal" href="#evaluating-object-size" id="id55">Evaluating Object Size</a></p></li>
<li><p><a class="reference internal" href="#deprecating-macros" id="id56">Deprecating Macros</a></p></li>
<li><p><a class="reference internal" href="#restricted-expansion-macros" id="id57">Restricted Expansion Macros</a></p></li>
<li><p><a class="reference internal" href="#final-macros" id="id58">Final Macros</a></p></li>
<li><p><a class="reference internal" href="#line-control" id="id59">Line Control</a></p></li>
<li><p><a class="reference internal" href="#intrinsics-support-within-constant-expressions" id="id60">Intrinsics Support within Constant Expressions</a></p></li>
<li><p><a class="reference internal" href="#debugging-the-compiler" id="id61">Debugging the Compiler</a></p></li>
<li><p><a class="reference internal" href="#predefined-macros" id="id62">Predefined Macros</a></p></li>
<li><p><a class="reference internal" href="#embed-parameters" id="id63"><code class="docutils literal notranslate"><span class="pre">#embed</span></code> Parameters</a></p></li>
<li><p><a class="reference internal" href="#union-and-aggregate-initialization-in-c" id="id64">Union and aggregate initialization in C</a></p></li>
<li><p><a class="reference internal" href="#empty-objects-in-c" id="id65">Empty Objects in C</a></p></li>
<li><p><a class="reference internal" href="#qualified-function-types-in-c" id="id66">Qualified function types in C</a></p></li>
<li><p><a class="reference internal" href="#underspecified-object-declarations-in-c" id="id67">Underspecified Object Declarations in C</a></p></li>
</ul>
</nav>
<div class="toctree-wrapper compound">
</div>
<section id="introduction">
<h2><a class="toc-backref" href="#id19" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>This document describes the language extensions provided by Clang.  In addition
to the language extensions listed here, Clang aims to support a broad range of
GCC extensions.  Please see the <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html">GCC manual</a> for more information on
these extensions.</p>
</section>
<section id="feature-checking-macros">
<span id="langext-feature-check"></span><h2><a class="toc-backref" href="#id20" role="doc-backlink">Feature Checking Macros</a><a class="headerlink" href="#feature-checking-macros" title="Link to this heading">¶</a></h2>
<p>Language extensions can be very useful, but only if you know you can depend on
them.  In order to allow fine-grain features checks, we support three builtin
function-like macros.  This allows you to directly test for a feature in your
code without having to resort to something like autoconf or fragile “compiler
version checks”.</p>
<section id="has-builtin">
<h3><code class="docutils literal notranslate"><span class="pre">__has_builtin</span></code><a class="headerlink" href="#has-builtin" title="Link to this heading">¶</a></h3>
<p>This function-like macro takes a single identifier argument that is the name of
a builtin function, a builtin pseudo-function (taking one or more type
arguments), or a builtin template.
It evaluates to 1 if the builtin is supported or 0 if not.
It can be used like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef __has_builtin         </span><span class="c1">// Optional of course.</span>
<span class="w">  </span><span class="cp">#define __has_builtin(x) 0  </span><span class="c1">// Compatibility with non-clang compilers.</span>
<span class="cp">#endif</span>

<span class="p">...</span>
<span class="cp">#if __has_builtin(__builtin_trap)</span>
<span class="w">  </span><span class="n">__builtin_trap</span><span class="p">();</span>
<span class="cp">#else</span>
<span class="w">  </span><span class="n">abort</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="p">...</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Prior to Clang 10, <code class="docutils literal notranslate"><span class="pre">__has_builtin</span></code> could not be used to detect most builtin
pseudo-functions.</p>
<p><code class="docutils literal notranslate"><span class="pre">__has_builtin</span></code> should not be used to detect support for a builtin macro;
use <code class="docutils literal notranslate"><span class="pre">#ifdef</span></code> instead.</p>
</div>
</section>
<section id="has-constexpr-builtin">
<h3><code class="docutils literal notranslate"><span class="pre">__has_constexpr_builtin</span></code><a class="headerlink" href="#has-constexpr-builtin" title="Link to this heading">¶</a></h3>
<p>This function-like macro takes a single identifier argument that is the name of
a builtin function, a builtin pseudo-function (taking one or more type
arguments), or a builtin template.
It evaluates to 1 if the builtin is supported and can be constant evaluated or
0 if not. It can be used for writing conditionally constexpr code like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef __has_constexpr_builtin         </span><span class="c1">// Optional of course.</span>
<span class="w">  </span><span class="cp">#define __has_constexpr_builtin(x) 0  </span><span class="c1">// Compatibility with non-clang compilers.</span>
<span class="cp">#endif</span>

<span class="p">...</span>
<span class="cp">#if __has_constexpr_builtin(__builtin_fmax)</span>
<span class="w">  </span><span class="k">constexpr</span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">money_fee</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">amount</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">__builtin_fmax</span><span class="p">(</span><span class="n">amount</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.03</span><span class="p">,</span><span class="w"> </span><span class="mf">10.0</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<p>For example, <code class="docutils literal notranslate"><span class="pre">__has_constexpr_builtin</span></code> is used in libcxx’s implementation of
the <code class="docutils literal notranslate"><span class="pre">&lt;cmath&gt;</span></code> header file to conditionally make a function constexpr whenever
the constant evaluation of the corresponding builtin (for example,
<code class="docutils literal notranslate"><span class="pre">std::fmax</span></code> calls <code class="docutils literal notranslate"><span class="pre">__builtin_fmax</span></code>) is supported in Clang.</p>
</section>
<section id="has-feature-and-has-extension">
<span id="langext-has-feature-has-extension"></span><h3><code class="docutils literal notranslate"><span class="pre">__has_feature</span></code> and <code class="docutils literal notranslate"><span class="pre">__has_extension</span></code><a class="headerlink" href="#has-feature-and-has-extension" title="Link to this heading">¶</a></h3>
<p>These function-like macros take a single identifier argument that is the name
of a feature.  <code class="docutils literal notranslate"><span class="pre">__has_feature</span></code> evaluates to 1 if the feature is both
supported by Clang and standardized in the current language standard or 0 if
not (but see <a class="reference internal" href="#langext-has-feature-back-compat"><span class="std std-ref">below</span></a>), while
<code class="docutils literal notranslate"><span class="pre">__has_extension</span></code> evaluates to 1 if the feature is supported by Clang in the
current language (either as a language extension or a standard language
feature) or 0 if not.  They can be used like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef __has_feature         </span><span class="c1">// Optional of course.</span>
<span class="w">  </span><span class="cp">#define __has_feature(x) 0  </span><span class="c1">// Compatibility with non-clang compilers.</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef __has_extension</span>
<span class="w">  </span><span class="cp">#define __has_extension __has_feature </span><span class="c1">// Compatibility with pre-3.0 compilers.</span>
<span class="cp">#endif</span>

<span class="p">...</span>
<span class="cp">#if __has_feature(cxx_rvalue_references)</span>
<span class="c1">// This code will only be compiled with the -std=c++11 and -std=gnu++11</span>
<span class="c1">// options, because rvalue references are only standardized in C++11.</span>
<span class="cp">#endif</span>

<span class="cp">#if __has_extension(cxx_rvalue_references)</span>
<span class="c1">// This code will be compiled with the -std=c++11, -std=gnu++11, -std=c++98</span>
<span class="c1">// and -std=gnu++98 options, because rvalue references are supported as a</span>
<span class="c1">// language extension in C++98.</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p id="langext-has-feature-back-compat">For backward compatibility, <code class="docutils literal notranslate"><span class="pre">__has_feature</span></code> can also be used to test
for support for non-standardized features, i.e. features not prefixed <code class="docutils literal notranslate"><span class="pre">c_</span></code>,
<code class="docutils literal notranslate"><span class="pre">cxx_</span></code> or <code class="docutils literal notranslate"><span class="pre">objc_</span></code>.</p>
<p>Another use of <code class="docutils literal notranslate"><span class="pre">__has_feature</span></code> is to check for compiler features not related
to the language standard, such as e.g. <a class="reference internal" href="AddressSanitizer.html"><span class="doc">AddressSanitizer</span></a>.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">-pedantic-errors</span></code> option is given, <code class="docutils literal notranslate"><span class="pre">__has_extension</span></code> is equivalent
to <code class="docutils literal notranslate"><span class="pre">__has_feature</span></code>.</p>
<p>The feature tag is described along with the language feature below.</p>
<p>The feature name or extension name can also be specified with a preceding and
following <code class="docutils literal notranslate"><span class="pre">__</span></code> (double underscore) to avoid interference from a macro with
the same name.  For instance, <code class="docutils literal notranslate"><span class="pre">__cxx_rvalue_references__</span></code> can be used instead
of <code class="docutils literal notranslate"><span class="pre">cxx_rvalue_references</span></code>.</p>
</section>
<section id="has-cpp-attribute">
<h3><code class="docutils literal notranslate"><span class="pre">__has_cpp_attribute</span></code><a class="headerlink" href="#has-cpp-attribute" title="Link to this heading">¶</a></h3>
<p>This function-like macro is available in C++20 by default, and is provided as an
extension in earlier language standards. It takes a single argument that is the
name of a double-square-bracket-style attribute. The argument can either be a
single identifier or a scoped identifier. If the attribute is supported, a
nonzero value is returned. If the attribute is a standards-based attribute, this
macro returns a nonzero value based on the year and month in which the attribute
was voted into the working draft. See <a class="reference external" href="https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations">WG21 SD-6</a>
for the list of values returned for standards-based attributes. If the attribute
is not supported by the current compilation target, this macro evaluates to 0.
It can be used like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef __has_cpp_attribute         </span><span class="c1">// For backwards compatibility</span>
<span class="w">  </span><span class="cp">#define __has_cpp_attribute(x) 0</span>
<span class="cp">#endif</span>

<span class="p">...</span>
<span class="cp">#if __has_cpp_attribute(clang::fallthrough)</span>
<span class="cp">#define FALLTHROUGH [[clang::fallthrough]]</span>
<span class="cp">#else</span>
<span class="cp">#define FALLTHROUGH</span>
<span class="cp">#endif</span>
<span class="p">...</span>
</pre></div>
</div>
<p>The attribute scope tokens <code class="docutils literal notranslate"><span class="pre">clang</span></code> and <code class="docutils literal notranslate"><span class="pre">_Clang</span></code> are interchangeable, as are
the attribute scope tokens <code class="docutils literal notranslate"><span class="pre">gnu</span></code> and <code class="docutils literal notranslate"><span class="pre">__gnu__</span></code>. Attribute tokens in either
of these namespaces can be specified with a preceding and following <code class="docutils literal notranslate"><span class="pre">__</span></code>
(double underscore) to avoid interference from a macro with the same name. For
instance, <code class="docutils literal notranslate"><span class="pre">gnu::__const__</span></code> can be used instead of <code class="docutils literal notranslate"><span class="pre">gnu::const</span></code>.</p>
</section>
<section id="has-c-attribute">
<h3><code class="docutils literal notranslate"><span class="pre">__has_c_attribute</span></code><a class="headerlink" href="#has-c-attribute" title="Link to this heading">¶</a></h3>
<p>This function-like macro takes a single argument that is the name of an
attribute exposed with the double square-bracket syntax in C mode. The argument
can either be a single identifier or a scoped identifier. If the attribute is
supported, a nonzero value is returned. If the attribute is not supported by the
current compilation target, this macro evaluates to 0. It can be used like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef __has_c_attribute         </span><span class="c1">// Optional of course.</span>
<span class="w">  </span><span class="cp">#define __has_c_attribute(x) 0  </span><span class="c1">// Compatibility with non-clang compilers.</span>
<span class="cp">#endif</span>

<span class="p">...</span>
<span class="cp">#if __has_c_attribute(fallthrough)</span>
<span class="w">  </span><span class="cp">#define FALLTHROUGH [[fallthrough]]</span>
<span class="cp">#else</span>
<span class="w">  </span><span class="cp">#define FALLTHROUGH</span>
<span class="cp">#endif</span>
<span class="p">...</span>
</pre></div>
</div>
<p>The attribute scope tokens <code class="docutils literal notranslate"><span class="pre">clang</span></code> and <code class="docutils literal notranslate"><span class="pre">_Clang</span></code> are interchangeable, as are
the attribute scope tokens <code class="docutils literal notranslate"><span class="pre">gnu</span></code> and <code class="docutils literal notranslate"><span class="pre">__gnu__</span></code>. Attribute tokens in either
of these namespaces can be specified with a preceding and following <code class="docutils literal notranslate"><span class="pre">__</span></code>
(double underscore) to avoid interference from a macro with the same name. For
instance, <code class="docutils literal notranslate"><span class="pre">gnu::__const__</span></code> can be used instead of <code class="docutils literal notranslate"><span class="pre">gnu::const</span></code>.</p>
</section>
<section id="has-attribute">
<h3><code class="docutils literal notranslate"><span class="pre">__has_attribute</span></code><a class="headerlink" href="#has-attribute" title="Link to this heading">¶</a></h3>
<p>This function-like macro takes a single identifier argument that is the name of
a GNU-style attribute.  It evaluates to 1 if the attribute is supported by the
current compilation target, or 0 if not.  It can be used like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef __has_attribute         </span><span class="c1">// Optional of course.</span>
<span class="w">  </span><span class="cp">#define __has_attribute(x) 0  </span><span class="c1">// Compatibility with non-clang compilers.</span>
<span class="cp">#endif</span>

<span class="p">...</span>
<span class="cp">#if __has_attribute(always_inline)</span>
<span class="cp">#define ALWAYS_INLINE __attribute__((always_inline))</span>
<span class="cp">#else</span>
<span class="cp">#define ALWAYS_INLINE</span>
<span class="cp">#endif</span>
<span class="p">...</span>
</pre></div>
</div>
<p>The attribute name can also be specified with a preceding and following <code class="docutils literal notranslate"><span class="pre">__</span></code>
(double underscore) to avoid interference from a macro with the same name.  For
instance, <code class="docutils literal notranslate"><span class="pre">__always_inline__</span></code> can be used instead of <code class="docutils literal notranslate"><span class="pre">always_inline</span></code>.</p>
</section>
<section id="has-declspec-attribute">
<h3><code class="docutils literal notranslate"><span class="pre">__has_declspec_attribute</span></code><a class="headerlink" href="#has-declspec-attribute" title="Link to this heading">¶</a></h3>
<p>This function-like macro takes a single identifier argument that is the name of
an attribute implemented as a Microsoft-style <code class="docutils literal notranslate"><span class="pre">__declspec</span></code> attribute.  It
evaluates to 1 if the attribute is supported by the current compilation target,
or 0 if not.  It can be used like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef __has_declspec_attribute         </span><span class="c1">// Optional of course.</span>
<span class="w">  </span><span class="cp">#define __has_declspec_attribute(x) 0  </span><span class="c1">// Compatibility with non-clang compilers.</span>
<span class="cp">#endif</span>

<span class="p">...</span>
<span class="cp">#if __has_declspec_attribute(dllexport)</span>
<span class="cp">#define DLLEXPORT __declspec(dllexport)</span>
<span class="cp">#else</span>
<span class="cp">#define DLLEXPORT</span>
<span class="cp">#endif</span>
<span class="p">...</span>
</pre></div>
</div>
<p>The attribute name can also be specified with a preceding and following <code class="docutils literal notranslate"><span class="pre">__</span></code>
(double underscore) to avoid interference from a macro with the same name.  For
instance, <code class="docutils literal notranslate"><span class="pre">__dllexport__</span></code> can be used instead of <code class="docutils literal notranslate"><span class="pre">dllexport</span></code>.</p>
</section>
<section id="is-identifier">
<h3><code class="docutils literal notranslate"><span class="pre">__is_identifier</span></code><a class="headerlink" href="#is-identifier" title="Link to this heading">¶</a></h3>
<p>This function-like macro takes a single identifier argument that might be either
a reserved word or a regular identifier. It evaluates to 1 if the argument is just
a regular identifier and not a reserved word, in the sense that it can then be
used as the name of a user-defined function or variable. Otherwise it evaluates
to 0.  It can be used like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="cp">#ifdef __is_identifier          </span><span class="c1">// Compatibility with non-clang compilers.</span>
<span class="w">  </span><span class="cp">#if __is_identifier(__wchar_t)</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="kt">wchar_t</span><span class="w"> </span><span class="kr">__wchar_t</span><span class="p">;</span>
<span class="w">  </span><span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="kr">__wchar_t</span><span class="w"> </span><span class="n">WideCharacter</span><span class="p">;</span>
<span class="p">...</span>
</pre></div>
</div>
</section>
</section>
<section id="include-file-checking-macros">
<h2><a class="toc-backref" href="#id21" role="doc-backlink">Include File Checking Macros</a><a class="headerlink" href="#include-file-checking-macros" title="Link to this heading">¶</a></h2>
<p>Not all developments systems have the same include files.  The
<a class="reference internal" href="#langext-has-include"><span class="std std-ref">__has_include</span></a> and <a class="reference internal" href="#langext-has-include-next"><span class="std std-ref">__has_include_next</span></a> macros allow
you to check for the existence of an include file before doing a possibly
failing <code class="docutils literal notranslate"><span class="pre">#include</span></code> directive.  Include file checking macros must be used
as expressions in <code class="docutils literal notranslate"><span class="pre">#if</span></code> or <code class="docutils literal notranslate"><span class="pre">#elif</span></code> preprocessing directives.</p>
<section id="has-include">
<span id="langext-has-include"></span><h3><code class="docutils literal notranslate"><span class="pre">__has_include</span></code><a class="headerlink" href="#has-include" title="Link to this heading">¶</a></h3>
<p>This function-like macro takes a single file name string argument that is the
name of an include file.  It evaluates to 1 if the file can be found using the
include paths, or 0 otherwise:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Note the two possible file name string formats.</span>
<span class="cp">#if __has_include(&quot;myinclude.h&quot;) &amp;&amp; __has_include(&lt;stdint.h&gt;)</span>
<span class="cp">#</span><span class="w"> </span><span class="cp">include</span><span class="w"> </span><span class="cpf">&quot;myinclude.h&quot;</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>To test for this feature, use <code class="docutils literal notranslate"><span class="pre">#if</span> <span class="pre">defined(__has_include)</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// To avoid problem with non-clang compilers not having this macro.</span>
<span class="cp">#if defined(__has_include)</span>
<span class="cp">#if __has_include(&quot;myinclude.h&quot;)</span>
<span class="cp">#</span><span class="w"> </span><span class="cp">include</span><span class="w"> </span><span class="cpf">&quot;myinclude.h&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
</pre></div>
</div>
</section>
<section id="has-include-next">
<span id="langext-has-include-next"></span><h3><code class="docutils literal notranslate"><span class="pre">__has_include_next</span></code><a class="headerlink" href="#has-include-next" title="Link to this heading">¶</a></h3>
<p>This function-like macro takes a single file name string argument that is the
name of an include file.  It is like <code class="docutils literal notranslate"><span class="pre">__has_include</span></code> except that it looks for
the second instance of the given file found in the include paths.  It evaluates
to 1 if the second instance of the file can be found using the include paths,
or 0 otherwise:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Note the two possible file name string formats.</span>
<span class="cp">#if __has_include_next(&quot;myinclude.h&quot;) &amp;&amp; __has_include_next(&lt;stdint.h&gt;)</span>
<span class="cp"># include_next &quot;myinclude.h&quot;</span>
<span class="cp">#endif</span>

<span class="c1">// To avoid problem with non-clang compilers not having this macro.</span>
<span class="cp">#if defined(__has_include_next)</span>
<span class="cp">#if __has_include_next(&quot;myinclude.h&quot;)</span>
<span class="cp"># include_next &quot;myinclude.h&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">__has_include_next</span></code>, like the GNU extension <code class="docutils literal notranslate"><span class="pre">#include_next</span></code>
directive, is intended for use in headers only, and will issue a warning if
used in the top-level compilation file.  A warning will also be issued if an
absolute path is used in the file argument.</p>
</section>
<section id="has-warning">
<h3><code class="docutils literal notranslate"><span class="pre">__has_warning</span></code><a class="headerlink" href="#has-warning" title="Link to this heading">¶</a></h3>
<p>This function-like macro takes a string literal that represents a command line
option for a warning and returns true if that is a valid warning option.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#if __has_warning(&quot;-Wformat&quot;)</span>
<span class="p">...</span>
<span class="cp">#endif</span>
</pre></div>
</div>
</section>
</section>
<section id="builtin-macros">
<span id="languageextensions-builtin-macros"></span><h2><a class="toc-backref" href="#id22" role="doc-backlink">Builtin Macros</a><a class="headerlink" href="#builtin-macros" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__BASE_FILE__</span></code></dt><dd><p>Defined to a string that contains the name of the main input file passed to
Clang.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__FILE_NAME__</span></code></dt><dd><p>Clang-specific extension that functions similar to <code class="docutils literal notranslate"><span class="pre">__FILE__</span></code> but only
renders the last path component (the filename) instead of an invocation
dependent full path to that file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__COUNTER__</span></code></dt><dd><p>Defined to an integer value that starts at zero and is incremented each time
the <code class="docutils literal notranslate"><span class="pre">__COUNTER__</span></code> macro is expanded.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__INCLUDE_LEVEL__</span></code></dt><dd><p>Defined to an integral value that is the include depth of the file currently
being translated.  For the main file, this value is zero.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__TIMESTAMP__</span></code></dt><dd><p>Defined to the date and time of the last modification of the current source
file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__clang__</span></code></dt><dd><p>Defined when compiling with Clang</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__clang_major__</span></code></dt><dd><p>Defined to the major marketing version number of Clang (e.g., the 2 in
2.0.1).  Note that marketing version numbers should not be used to check for
language features, as different vendors use different numbering schemes.
Instead, use the <a class="reference internal" href="#langext-feature-check"><span class="std std-ref">Feature Checking Macros</span></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__clang_minor__</span></code></dt><dd><p>Defined to the minor version number of Clang (e.g., the 0 in 2.0.1).  Note
that marketing version numbers should not be used to check for language
features, as different vendors use different numbering schemes.  Instead, use
the <a class="reference internal" href="#langext-feature-check"><span class="std std-ref">Feature Checking Macros</span></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__clang_patchlevel__</span></code></dt><dd><p>Defined to the marketing patch level of Clang (e.g., the 1 in 2.0.1).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__clang_version__</span></code></dt><dd><p>Defined to a string that captures the Clang marketing version, including the
Subversion tag or revision number, e.g., “<code class="docutils literal notranslate"><span class="pre">1.5</span> <span class="pre">(trunk</span> <span class="pre">102332)</span></code>”.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__clang_literal_encoding__</span></code></dt><dd><p>Defined to a narrow string literal that represents the current encoding of
narrow string literals, e.g., <code class="docutils literal notranslate"><span class="pre">&quot;hello&quot;</span></code>. This macro typically expands to
“UTF-8” (but may change in the future if the
<code class="docutils literal notranslate"><span class="pre">-fexec-charset=&quot;Encoding-Name&quot;</span></code> option is implemented.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__clang_wide_literal_encoding__</span></code></dt><dd><p>Defined to a narrow string literal that represents the current encoding of
wide string literals, e.g., <code class="docutils literal notranslate"><span class="pre">L&quot;hello&quot;</span></code>. This macro typically expands to
“UTF-16” or “UTF-32” (but may change in the future if the
<code class="docutils literal notranslate"><span class="pre">-fwide-exec-charset=&quot;Encoding-Name&quot;</span></code> option is implemented.)</p>
</dd>
</dl>
</section>
<section id="implementation-defined-keywords">
<h2><a class="toc-backref" href="#id23" role="doc-backlink">Implementation-defined keywords</a><a class="headerlink" href="#implementation-defined-keywords" title="Link to this heading">¶</a></h2>
<section id="datasizeof">
<h3>__datasizeof<a class="headerlink" href="#datasizeof" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__datasizeof</span></code> behaves like <code class="docutils literal notranslate"><span class="pre">sizeof</span></code>, except that it returns the size of the
type ignoring tail padding.</p>
</section>
<section id="bitint-extint">
<h3>_BitInt, _ExtInt<a class="headerlink" href="#bitint-extint" title="Link to this heading">¶</a></h3>
<p>Clang supports the C23 <code class="docutils literal notranslate"><span class="pre">_BitInt(N)</span></code> feature as an extension in older C modes
and in C++. This type was previously implemented in Clang with the same
semantics, but spelled <code class="docutils literal notranslate"><span class="pre">_ExtInt(N)</span></code>. This spelling has been deprecated in
favor of the standard type.</p>
<p>Note: the ABI for <code class="docutils literal notranslate"><span class="pre">_BitInt(N)</span></code> is still in the process of being stabilized,
so this type should not yet be used in interfaces that require ABI stability.</p>
</section>
<section id="c-keywords-supported-in-all-language-modes">
<h3>C keywords supported in all language modes<a class="headerlink" href="#c-keywords-supported-in-all-language-modes" title="Link to this heading">¶</a></h3>
<p>Clang supports <code class="docutils literal notranslate"><span class="pre">_Alignas</span></code>, <code class="docutils literal notranslate"><span class="pre">_Alignof</span></code>, <code class="docutils literal notranslate"><span class="pre">_Atomic</span></code>, <code class="docutils literal notranslate"><span class="pre">_Complex</span></code>,
<code class="docutils literal notranslate"><span class="pre">_Generic</span></code>, <code class="docutils literal notranslate"><span class="pre">_Imaginary</span></code>, <code class="docutils literal notranslate"><span class="pre">_Noreturn</span></code>, <code class="docutils literal notranslate"><span class="pre">_Static_assert</span></code>,
<code class="docutils literal notranslate"><span class="pre">_Thread_local</span></code>, and <code class="docutils literal notranslate"><span class="pre">_Float16</span></code> in all language modes with the C semantics.</p>
</section>
<section id="alignof-alignof">
<h3>__alignof, __alignof__<a class="headerlink" href="#alignof-alignof" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__alignof</span></code> and <code class="docutils literal notranslate"><span class="pre">__alignof__</span></code> return, in contrast to <code class="docutils literal notranslate"><span class="pre">_Alignof</span></code> and
<code class="docutils literal notranslate"><span class="pre">alignof</span></code>, the preferred alignment of a type. This may be larger than the
required alignment for improved performance.</p>
</section>
<section id="extension">
<h3>__extension__<a class="headerlink" href="#extension" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__extension__</span></code> suppresses extension diagnostics in the statement it is
prepended to.</p>
</section>
<section id="auto-type">
<h3>__auto_type<a class="headerlink" href="#auto-type" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__auto_type</span></code> behaves the same as <code class="docutils literal notranslate"><span class="pre">auto</span></code> in C++11 but is available in all
language modes.</p>
</section>
<section id="imag-imag">
<h3>__imag, __imag__<a class="headerlink" href="#imag-imag" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__imag</span></code> and <code class="docutils literal notranslate"><span class="pre">__imag__</span></code> can be used to get the imaginary part of a complex
value.</p>
</section>
<section id="real-real">
<h3>__real, __real__<a class="headerlink" href="#real-real" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__real</span></code> and <code class="docutils literal notranslate"><span class="pre">__real__</span></code> can be used to get the real part of a complex value.</p>
</section>
<section id="asm-asm">
<h3>__asm, __asm__<a class="headerlink" href="#asm-asm" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__asm</span></code> and <code class="docutils literal notranslate"><span class="pre">__asm__</span></code> are alternate spellings for <code class="docutils literal notranslate"><span class="pre">asm</span></code>, but available in
all language modes.</p>
</section>
<section id="complex-complex">
<h3>__complex, __complex__<a class="headerlink" href="#complex-complex" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__complex</span></code> and <code class="docutils literal notranslate"><span class="pre">__complex__</span></code> are alternate spellings for <code class="docutils literal notranslate"><span class="pre">_Complex</span></code>.</p>
</section>
<section id="const-const-volatile-volatile-restrict-restrict">
<h3>__const, __const__, __volatile, __volatile__, __restrict, __restrict__<a class="headerlink" href="#const-const-volatile-volatile-restrict-restrict" title="Link to this heading">¶</a></h3>
<p>These are alternate spellings for their non-underscore counterparts, but are
available in all language modes.</p>
</section>
<section id="decltype">
<h3>__decltype<a class="headerlink" href="#decltype" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__decltype</span></code> is an alternate spelling for <code class="docutils literal notranslate"><span class="pre">decltype</span></code>, but is also available
in C++ modes before C++11.</p>
</section>
<section id="inline-inline">
<h3>__inline, __inline__<a class="headerlink" href="#inline-inline" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__inline</span></code> and <code class="docutils literal notranslate"><span class="pre">__inline__</span></code> are alternate spellings for <code class="docutils literal notranslate"><span class="pre">inline</span></code>, but are
available in all language modes.</p>
</section>
<section id="nullptr">
<h3>__nullptr<a class="headerlink" href="#nullptr" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__nullptr</span></code> is an alternate spelling for <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>. It is available in all C and C++ language modes.</p>
</section>
<section id="signed-signed">
<h3>__signed, __signed__<a class="headerlink" href="#signed-signed" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__signed</span></code> and <code class="docutils literal notranslate"><span class="pre">__signed__</span></code> are alternate spellings for <code class="docutils literal notranslate"><span class="pre">signed</span></code>.
<code class="docutils literal notranslate"><span class="pre">__unsigned</span></code> and <code class="docutils literal notranslate"><span class="pre">__unsigned__</span></code> are <strong>not</strong> supported.</p>
</section>
<section id="typeof-typeof-typeof-unqual-typeof-unqual">
<h3>__typeof, __typeof__, __typeof_unqual, __typeof_unqual__<a class="headerlink" href="#typeof-typeof-typeof-unqual-typeof-unqual" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__typeof</span></code> and <code class="docutils literal notranslate"><span class="pre">__typeof__</span></code> are alternate spellings for <code class="docutils literal notranslate"><span class="pre">typeof</span></code>, but are
available in all language modes. These spellings result in the operand,
retaining all qualifiers.</p>
<p><code class="docutils literal notranslate"><span class="pre">__typeof_unqual</span></code> and <code class="docutils literal notranslate"><span class="pre">__typeof_unqual__</span></code> are alternate spellings for the
C23 <code class="docutils literal notranslate"><span class="pre">typeof_unqual</span></code> type specifier, but are available in all language modes.
These spellings result in the type of the operand, stripping all qualifiers.</p>
</section>
<section id="char16-t-char32-t">
<h3>__char16_t, __char32_t<a class="headerlink" href="#char16-t-char32-t" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__char16_t</span></code> and <code class="docutils literal notranslate"><span class="pre">__char32_t</span></code> are alternate spellings for <code class="docutils literal notranslate"><span class="pre">char16_t</span></code> and
<code class="docutils literal notranslate"><span class="pre">char32_t</span></code> respectively, but are also available in C++ modes before C++11.
They are only supported in C++. <code class="docutils literal notranslate"><span class="pre">__char8_t</span></code> is not available.</p>
</section>
</section>
<section id="vectors-and-extended-vectors">
<span id="langext-vectors"></span><h2><a class="toc-backref" href="#id24" role="doc-backlink">Vectors and Extended Vectors</a><a class="headerlink" href="#vectors-and-extended-vectors" title="Link to this heading">¶</a></h2>
<p>Supports the GCC, OpenCL, AltiVec, NEON and SVE vector extensions.</p>
<p>OpenCL vector types are created using the <code class="docutils literal notranslate"><span class="pre">ext_vector_type</span></code> attribute.  It
supports the <code class="docutils literal notranslate"><span class="pre">V.xyzw</span></code> syntax and other tidbits as seen in OpenCL.  An example
is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">float4</span><span class="w"> </span><span class="nf">__attribute__</span><span class="p">((</span><span class="n">ext_vector_type</span><span class="p">(</span><span class="mi">4</span><span class="p">)));</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">float2</span><span class="w"> </span><span class="nf">__attribute__</span><span class="p">((</span><span class="n">ext_vector_type</span><span class="p">(</span><span class="mi">2</span><span class="p">)));</span>

<span class="n">float4</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">float2</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">float2</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">float4</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">  </span><span class="n">c</span><span class="p">.</span><span class="n">xz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">  </span><span class="n">c</span><span class="p">.</span><span class="n">yw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_attribute(ext_vector_type)</span></code>.</p>
<p>Giving <code class="docutils literal notranslate"><span class="pre">-maltivec</span></code> option to clang enables support for AltiVec vector syntax
and functions.  For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">  </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec_add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">vector</span><span class="w"> </span><span class="kt">float</span><span class="p">)</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>NEON vector types are created using <code class="docutils literal notranslate"><span class="pre">neon_vector_type</span></code> and
<code class="docutils literal notranslate"><span class="pre">neon_polyvector_type</span></code> attributes.  For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">neon_vector_type</span><span class="p">(</span><span class="mi">8</span><span class="p">)))</span><span class="w"> </span><span class="kt">int8_t</span><span class="w"> </span><span class="n">int8x8_t</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">neon_polyvector_type</span><span class="p">(</span><span class="mi">16</span><span class="p">)))</span><span class="w"> </span><span class="n">poly8_t</span><span class="w"> </span><span class="n">poly8x16_t</span><span class="p">;</span>

<span class="n">int8x8_t</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">int8x8_t</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">int8x8_t</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">  </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>GCC vector types are created using the <code class="docutils literal notranslate"><span class="pre">vector_size(N)</span></code> attribute.  The
argument <code class="docutils literal notranslate"><span class="pre">N</span></code> specifies the number of bytes that will be allocated for an
object of this type.  The size has to be multiple of the size of the vector
element type. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// OK: This declares a vector type with four &#39;int&#39; elements</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">int4</span><span class="w"> </span><span class="nf">__attribute__</span><span class="p">((</span><span class="n">vector_size</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))));</span>

<span class="c1">// ERROR: &#39;11&#39; is not a multiple of sizeof(int)</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">int_impossible</span><span class="w"> </span><span class="nf">__attribute__</span><span class="p">((</span><span class="n">vector_size</span><span class="p">(</span><span class="mi">11</span><span class="p">)));</span>

<span class="n">int4</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">int4</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">int4</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">  </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="boolean-vectors">
<h3>Boolean Vectors<a class="headerlink" href="#boolean-vectors" title="Link to this heading">¶</a></h3>
<p>Clang also supports the ext_vector_type attribute with boolean element types in
C and C++.  For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// legal for Clang, error for GCC:</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">bool4</span><span class="w"> </span><span class="nf">__attribute__</span><span class="p">((</span><span class="n">ext_vector_type</span><span class="p">(</span><span class="mi">4</span><span class="p">)));</span>
<span class="c1">// Objects of bool4 type hold 8 bits, sizeof(bool4) == 1</span>

<span class="n">bool4</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">bool4</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">bool4</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">  </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Boolean vectors are a Clang extension of the ext vector type.  Boolean vectors
are intended, though not guaranteed, to map to vector mask registers.  The size
parameter of a boolean vector type is the number of bits in the vector.  The
boolean vector is dense and each bit in the boolean vector is one vector
element.</p>
<p>The semantics of boolean vectors borrows from C bit-fields with the following
differences:</p>
<ul class="simple">
<li><p>Distinct boolean vectors are always distinct memory objects (there is no
packing).</p></li>
<li><p>Only the operators <cite>?:</cite>, <cite>!</cite>, <cite>~</cite>, <cite>|</cite>, <cite>&amp;</cite>, <cite>^</cite> and comparison are allowed on
boolean vectors.</p></li>
<li><p>Casting a scalar bool value to a boolean vector type means broadcasting the
scalar value onto all lanes (same as general ext_vector_type).</p></li>
<li><p>It is not possible to access or swizzle elements of a boolean vector
(different than general ext_vector_type).</p></li>
</ul>
<p>The size and alignment are both the number of bits rounded up to the next power
of two, but the alignment is at most the maximum vector alignment of the
target.</p>
</section>
<section id="vector-literals">
<h3>Vector Literals<a class="headerlink" href="#vector-literals" title="Link to this heading">¶</a></h3>
<p>Vector literals can be used to create vectors from a set of scalars, or
vectors.  Either parentheses or braces form can be used.  In the parentheses
form the number of literal values specified must be one, i.e. referring to a
scalar value, or must match the size of the vector type being created.  If a
single scalar literal value is specified, the scalar literal value will be
replicated to all the components of the vector type.  In the brackets form any
number of literals can be specified.  For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v4si</span><span class="w"> </span><span class="nf">__attribute__</span><span class="p">((</span><span class="n">__vector_size__</span><span class="p">(</span><span class="mi">16</span><span class="p">)));</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">float4</span><span class="w"> </span><span class="nf">__attribute__</span><span class="p">((</span><span class="n">ext_vector_type</span><span class="p">(</span><span class="mi">4</span><span class="p">)));</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">float2</span><span class="w"> </span><span class="nf">__attribute__</span><span class="p">((</span><span class="n">ext_vector_type</span><span class="p">(</span><span class="mi">2</span><span class="p">)));</span>

<span class="n">v4si</span><span class="w"> </span><span class="n">vsi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">v4si</span><span class="p">){</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">};</span>
<span class="n">float4</span><span class="w"> </span><span class="n">vf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">float4</span><span class="p">)(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">4.0f</span><span class="p">);</span>
<span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">vi1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="p">)(</span><span class="mi">1</span><span class="p">);</span><span class="w">    </span><span class="c1">// vi1 will be (1, 1, 1, 1).</span>
<span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">vi2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="p">){</span><span class="mi">1</span><span class="p">};</span><span class="w">    </span><span class="c1">// vi2 will be (1, 0, 0, 0).</span>
<span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">vi3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="c1">// error</span>
<span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">vi4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="p">){</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">};</span><span class="w"> </span><span class="c1">// vi4 will be (1, 2, 0, 0).</span>
<span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">vi5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">vector</span><span class="w"> </span><span class="kt">int</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="n">float4</span><span class="w"> </span><span class="n">vf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">float4</span><span class="p">)((</span><span class="n">float2</span><span class="p">)(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="n">float2</span><span class="p">)(</span><span class="mf">3.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">4.0f</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="vector-operations">
<h3>Vector Operations<a class="headerlink" href="#vector-operations" title="Link to this heading">¶</a></h3>
<p>The table below shows the support for each operation by vector extension.  A
dash indicates that an operation is not accepted according to a corresponding
specification.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Operator</p></th>
<th class="head"><p>OpenCL</p></th>
<th class="head"><p>AltiVec</p></th>
<th class="head"><p>GCC</p></th>
<th class="head"><p>NEON</p></th>
<th class="head"><p>SVE</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>[]</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-odd"><td><p>unary operators +, –</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-even"><td><p>++, – –</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>+,–,*,/,%</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-even"><td><p>bitwise operators &amp;,|,^,~</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-odd"><td><p>&gt;&gt;,&lt;&lt;</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-even"><td><p>!, &amp;&amp;, ||</p></td>
<td><p>yes</p></td>
<td><p>–</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-odd"><td><p>==, !=, &gt;, &lt;, &gt;=, &lt;=</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-even"><td><p>=</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-odd"><td><p>?: <a class="footnote-reference brackets" href="#id4" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td><p>yes</p></td>
<td><p>–</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-even"><td><p>sizeof</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes <a class="footnote-reference brackets" href="#id5" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-odd"><td><p>C-style cast</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p>reinterpret_cast</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>static_cast</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p>const_cast</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>address &amp;v[i]</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>no <a class="footnote-reference brackets" href="#id6" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
</tbody>
</table>
<p>See also <a class="reference internal" href="#langext-builtin-shufflevector"><span class="std std-ref">__builtin_shufflevector</span></a>, <a class="reference internal" href="#langext-builtin-convertvector"><span class="std std-ref">__builtin_convertvector</span></a>.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id4" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>ternary operator(?:) has different behaviors depending on condition
operand’s vector type. If the condition is a GNU vector (i.e. __vector_size__),
a NEON vector or an SVE vector, it’s only available in C++ and uses normal bool
conversions (that is, != 0).
If it’s an extension (OpenCL) vector, it’s only available in C and OpenCL C.
And it selects base on signedness of the condition operands (OpenCL v1.1 s6.3.9).</p>
</aside>
<aside class="footnote brackets" id="id5" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>sizeof can only be used on vector length specific SVE types.</p>
</aside>
<aside class="footnote brackets" id="id6" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p>Clang does not allow the address of an element to be taken while GCC
allows this. This is intentional for vectors with a boolean element type and
not implemented otherwise.</p>
</aside>
</aside>
</section>
<section id="vector-builtins">
<h3>Vector Builtins<a class="headerlink" href="#vector-builtins" title="Link to this heading">¶</a></h3>
<p><strong>Note: The implementation of vector builtins is work-in-progress and incomplete.</strong></p>
<p>In addition to the operators mentioned above, Clang provides a set of builtins
to perform additional operations on certain scalar and vector types.</p>
<p>Let <code class="docutils literal notranslate"><span class="pre">T</span></code> be one of the following types:</p>
<ul class="simple">
<li><p>an integer type (as in C23 6.2.5p22), but excluding enumerated types and <code class="docutils literal notranslate"><span class="pre">bool</span></code></p></li>
<li><p>the standard floating types float or double</p></li>
<li><p>a half-precision floating point type, if one is supported on the target</p></li>
<li><p>a vector type.</p></li>
</ul>
<p>For scalar types, consider the operation applied to a vector with a single element.</p>
<p><em>Vector Size</em>
To determine the number of elements in a vector, use <code class="docutils literal notranslate"><span class="pre">__builtin_vectorelements()</span></code>.
For fixed-sized vectors, e.g., defined via <code class="docutils literal notranslate"><span class="pre">__attribute__((vector_size(N)))</span></code> or ARM
NEON’s vector types (e.g., <code class="docutils literal notranslate"><span class="pre">uint16x8_t</span></code>), this returns the constant number of
elements at compile-time. For scalable vectors, e.g., SVE or RISC-V V, the number of
elements is not known at compile-time and is determined at runtime. This builtin can
be used, e.g., to increment the loop-counter in vector-type agnostic loops.</p>
<p><em>Elementwise Builtins</em></p>
<p>Each builtin returns a vector equivalent to applying the specified operation
elementwise to the input.</p>
<p>Unless specified otherwise operation(±0) = ±0 and operation(±infinity) = ±infinity</p>
<p>The integer elementwise intrinsics, including <code class="docutils literal notranslate"><span class="pre">__builtin_elementwise_popcount</span></code>,
<code class="docutils literal notranslate"><span class="pre">__builtin_elementwise_bitreverse</span></code>, <code class="docutils literal notranslate"><span class="pre">__builtin_elementwise_add_sat</span></code>,
<code class="docutils literal notranslate"><span class="pre">__builtin_elementwise_sub_sat</span></code> can be called in a <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> context.</p>
<p>No implicit promotion of integer types takes place. The mixing of integer types
of different sizes and signs is forbidden in binary and ternary builtins.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Operation</p></th>
<th class="head"><p>Supported element types</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>T __builtin_elementwise_abs(T x)</p></td>
<td><p>return the absolute value of a number x; the absolute value of
the most negative integer remains the most negative integer</p></td>
<td><p>signed integer and floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_fma(T x, T y, T z)</p></td>
<td><p>fused multiply add, (x * y) +  z.</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-even"><td><p>T __builtin_elementwise_ceil(T x)</p></td>
<td><p>return the smallest integral value greater than or equal to x</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_sin(T x)</p></td>
<td><p>return the sine of x interpreted as an angle in radians</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-even"><td><p>T __builtin_elementwise_cos(T x)</p></td>
<td><p>return the cosine of x interpreted as an angle in radians</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_tan(T x)</p></td>
<td><p>return the tangent of x interpreted as an angle in radians</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-even"><td><p>T __builtin_elementwise_asin(T x)</p></td>
<td><p>return the arcsine of x interpreted as an angle in radians</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_acos(T x)</p></td>
<td><p>return the arccosine of x interpreted as an angle in radians</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-even"><td><p>T __builtin_elementwise_atan(T x)</p></td>
<td><p>return the arctangent of x interpreted as an angle in radians</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_atan2(T y, T x)</p></td>
<td><p>return the arctangent of y/x</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-even"><td><p>T __builtin_elementwise_sinh(T x)</p></td>
<td><p>return the hyperbolic sine of angle x in radians</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_cosh(T x)</p></td>
<td><p>return the hyperbolic cosine of angle x in radians</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-even"><td><p>T __builtin_elementwise_tanh(T x)</p></td>
<td><p>return the hyperbolic tangent of angle x in radians</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_floor(T x)</p></td>
<td><p>return the largest integral value less than or equal to x</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-even"><td><p>T __builtin_elementwise_log(T x)</p></td>
<td><p>return the natural logarithm of x</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_log2(T x)</p></td>
<td><p>return the base 2 logarithm of x</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-even"><td><p>T __builtin_elementwise_log10(T x)</p></td>
<td><p>return the base 10 logarithm of x</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_popcount(T x)</p></td>
<td><p>return the number of 1 bits in x</p></td>
<td><p>integer types</p></td>
</tr>
<tr class="row-even"><td><p>T __builtin_elementwise_pow(T x, T y)</p></td>
<td><p>return x raised to the power of y</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_bitreverse(T x)</p></td>
<td><p>return the integer represented after reversing the bits of x</p></td>
<td><p>integer types</p></td>
</tr>
<tr class="row-even"><td><p>T __builtin_elementwise_exp(T x)</p></td>
<td><p>returns the base-e exponential, e^x, of the specified value</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_exp2(T x)</p></td>
<td><p>returns the base-2 exponential, 2^x, of the specified value</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-even"><td><p>T __builtin_elementwise_exp10(T x)</p></td>
<td><p>returns the base-10 exponential, 10^x, of the specified value</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_sqrt(T x)</p></td>
<td><p>return the square root of a floating-point number</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-even"><td><p>T __builtin_elementwise_roundeven(T x)</p></td>
<td><p>round x to the nearest integer value in floating point format,
rounding halfway cases to even (that is, to the nearest value
that is an even integer), regardless of the current rounding
direction.</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_round(T x)</p></td>
<td><p>round x to the nearest  integer value in floating point format,
rounding halfway cases away from zero, regardless of the
current rounding direction. May raise floating-point
exceptions.</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-even"><td><p>T __builtin_elementwise_trunc(T x)</p></td>
<td><p>return the integral value nearest to but no larger in
magnitude than x</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_nearbyint(T x)</p></td>
<td><p>round x to the nearest  integer value in floating point format,
rounding according to the current rounding direction.
May not raise the inexact floating-point exception. This is
treated the same as <code class="docutils literal notranslate"><span class="pre">__builtin_elementwise_rint</span></code> unless
<a class="reference internal" href="UsersManual.html#floating-point-environment"><span class="std std-ref">FENV_ACCESS is enabled</span></a>.</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-even"><td><p>T __builtin_elementwise_rint(T x)</p></td>
<td><p>round x to the nearest  integer value in floating point format,
rounding according to the current rounding
direction. May raise floating-point exceptions. This is treated
the same as <code class="docutils literal notranslate"><span class="pre">__builtin_elementwise_nearbyint</span></code> unless
<a class="reference internal" href="UsersManual.html#floating-point-environment"><span class="std std-ref">FENV_ACCESS is enabled</span></a>.</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_canonicalize(T x)</p></td>
<td><p>return the platform specific canonical encoding
of a floating-point number</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-even"><td><p>T __builtin_elementwise_copysign(T x, T y)</p></td>
<td><p>return the magnitude of x with the sign of y.</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_fmod(T x, T y)</p></td>
<td><p>return The floating-point remainder of (x/y) whose sign
matches the sign of x.</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-even"><td><p>T __builtin_elementwise_max(T x, T y)</p></td>
<td><p>return x or y, whichever is larger
For floating point types, follows semantics of maxNum
in IEEE 754-2008. See <a class="reference external" href="http://llvm.org/docs/LangRef.html#llvm-min-intrinsics-comparation">LangRef</a>
for the comparison.</p></td>
<td><p>integer and floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_min(T x, T y)</p></td>
<td><p>return x or y, whichever is smaller
For floating point types, follows semantics of minNum
in IEEE 754-2008. See <a class="reference external" href="http://llvm.org/docs/LangRef.html#llvm-min-intrinsics-comparation">LangRef</a>
for the comparison.</p></td>
<td><p>integer and floating point types</p></td>
</tr>
<tr class="row-even"><td><p>T __builtin_elementwise_maxnum(T x, T y)</p></td>
<td><p>return x or y, whichever is larger. Follows IEEE 754-2008
semantics (maxNum) with +0.0&gt;-0.0. See <a class="reference external" href="http://llvm.org/docs/LangRef.html#llvm-min-intrinsics-comparation">LangRef</a>
for the comparison.</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_minnum(T x, T y)</p></td>
<td><p>return x or y, whichever is smaller. Follows IEEE 754-2008
semantics (minNum) with +0.0&gt;-0.0. See <a class="reference external" href="http://llvm.org/docs/LangRef.html#llvm-min-intrinsics-comparation">LangRef</a>
for the comparison.</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-even"><td><p>T __builtin_elementwise_add_sat(T x, T y)</p></td>
<td><p>return the sum of x and y, clamped to the range of
representable values for the signed/unsigned integer type.</p></td>
<td><p>integer types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_sub_sat(T x, T y)</p></td>
<td><p>return the difference of x and y, clamped to the range of
representable values for the signed/unsigned integer type.</p></td>
<td><p>integer types</p></td>
</tr>
<tr class="row-even"><td><p>T __builtin_elementwise_maximum(T x, T y)</p></td>
<td><p>return x or y, whichever is larger. Follows IEEE 754-2019
semantics, see <a class="reference external" href="http://llvm.org/docs/LangRef.html#llvm-min-intrinsics-comparation">LangRef</a>
for the comparison.</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>T __builtin_elementwise_minimum(T x, T y)</p></td>
<td><p>return x or y, whichever is smaller. Follows IEEE 754-2019
semantics, see <a class="reference external" href="http://llvm.org/docs/LangRef.html#llvm-min-intrinsics-comparation">LangRef</a>
for the comparison.</p></td>
<td><p>floating point types</p></td>
</tr>
</tbody>
</table>
<p><em>Reduction Builtins</em></p>
<p>Each builtin returns a scalar equivalent to applying the specified
operation(x, y) as recursive even-odd pairwise reduction to all vector
elements. <code class="docutils literal notranslate"><span class="pre">operation(x,</span> <span class="pre">y)</span></code> is repeatedly applied to each non-overlapping
even-odd element pair with indices <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">*</span> <span class="pre">2</span></code> and <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">*</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">1</span></code> with
<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">in</span> <span class="pre">[0,</span> <span class="pre">Number</span> <span class="pre">of</span> <span class="pre">elements</span> <span class="pre">/</span> <span class="pre">2)</span></code>. If the numbers of elements is not a
power of 2, the vector is widened with neutral elements for the reduction
at the end to the next power of 2.</p>
<p>These reductions support both fixed-sized and scalable vector types.</p>
<p>The integer reduction intrinsics, including <code class="docutils literal notranslate"><span class="pre">__builtin_reduce_max</span></code>,
<code class="docutils literal notranslate"><span class="pre">__builtin_reduce_min</span></code>, <code class="docutils literal notranslate"><span class="pre">__builtin_reduce_add</span></code>, <code class="docutils literal notranslate"><span class="pre">__builtin_reduce_mul</span></code>,
<code class="docutils literal notranslate"><span class="pre">__builtin_reduce_and</span></code>, <code class="docutils literal notranslate"><span class="pre">__builtin_reduce_or</span></code>, and <code class="docutils literal notranslate"><span class="pre">__builtin_reduce_xor</span></code>,
can be called in a <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> context.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_reduce_add</span><span class="p">([</span><span class="n">e3</span><span class="p">,</span><span class="w"> </span><span class="n">e2</span><span class="p">,</span><span class="w"> </span><span class="n">e1</span><span class="p">,</span><span class="w"> </span><span class="n">e0</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_reduced_add</span><span class="p">([</span><span class="n">e3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">e2</span><span class="p">,</span><span class="w"> </span><span class="n">e1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">e0</span><span class="p">])</span>
<span class="w">                                       </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">e3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">e2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">e1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">e0</span><span class="p">)</span>
</pre></div>
</div>
<p>Let <code class="docutils literal notranslate"><span class="pre">VT</span></code> be a vector type and <code class="docutils literal notranslate"><span class="pre">ET</span></code> the element type of <code class="docutils literal notranslate"><span class="pre">VT</span></code>.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Operation</p></th>
<th class="head"><p>Supported element types</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ET __builtin_reduce_max(VT a)</p></td>
<td><p>return the largest element of the vector. The floating point result
will always be a number unless all elements of the vector are NaN.</p></td>
<td><p>integer and floating point types</p></td>
</tr>
<tr class="row-odd"><td><p>ET __builtin_reduce_min(VT a)</p></td>
<td><p>return the smallest element of the vector. The floating point result
will always be a number unless all elements of the vector are NaN.</p></td>
<td><p>integer and floating point types</p></td>
</tr>
<tr class="row-even"><td><p>ET __builtin_reduce_add(VT a)</p></td>
<td><p>+</p></td>
<td><p>integer types</p></td>
</tr>
<tr class="row-odd"><td><p>ET __builtin_reduce_mul(VT a)</p></td>
<td><p>*</p></td>
<td><p>integer types</p></td>
</tr>
<tr class="row-even"><td><p>ET __builtin_reduce_and(VT a)</p></td>
<td><p>&amp;</p></td>
<td><p>integer types</p></td>
</tr>
<tr class="row-odd"><td><p>ET __builtin_reduce_or(VT a)</p></td>
<td><p>|</p></td>
<td><p>integer types</p></td>
</tr>
<tr class="row-even"><td><p>ET __builtin_reduce_xor(VT a)</p></td>
<td><p>^</p></td>
<td><p>integer types</p></td>
</tr>
<tr class="row-odd"><td><p>ET __builtin_reduce_maximum(VT a)</p></td>
<td><p>return the largest element of the vector. Follows IEEE 754-2019
semantics, see <a class="reference external" href="http://llvm.org/docs/LangRef.html#llvm-min-intrinsics-comparation">LangRef</a>
for the comparison.</p></td>
<td><p>floating point types</p></td>
</tr>
<tr class="row-even"><td><p>ET __builtin_reduce_minimum(VT a)</p></td>
<td><p>return the smallest element of the vector. Follows IEEE 754-2019
semantics, see <a class="reference external" href="http://llvm.org/docs/LangRef.html#llvm-min-intrinsics-comparation">LangRef</a>
for the comparison.</p></td>
<td><p>floating point types</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="matrix-types">
<h2><a class="toc-backref" href="#id25" role="doc-backlink">Matrix Types</a><a class="headerlink" href="#matrix-types" title="Link to this heading">¶</a></h2>
<p>Clang provides an extension for matrix types, which is currently being
implemented. See <a class="reference internal" href="MatrixTypes.html#matrixtypes"><span class="std std-ref">the draft specification</span></a> for more details.</p>
<p>For example, the code below uses the matrix types extension to multiply two 4x4
float matrices and add the result to a third 4x4 matrix.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">m4x4_t</span><span class="w"> </span><span class="nf">__attribute__</span><span class="p">((</span><span class="n">matrix_type</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)));</span>

<span class="n">m4x4_t</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">m4x4_t</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">m4x4_t</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">m4x4_t</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The matrix type extension also supports operations on a matrix and a scalar.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">m4x4_t</span><span class="w"> </span><span class="nf">__attribute__</span><span class="p">((</span><span class="n">matrix_type</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)));</span>

<span class="n">m4x4_t</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">m4x4_t</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">23</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The matrix type extension supports division on a matrix and a scalar but not on a matrix and a matrix.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">m4x4_t</span><span class="w"> </span><span class="nf">__attribute__</span><span class="p">((</span><span class="n">matrix_type</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)));</span>

<span class="n">m4x4_t</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">m4x4_t</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">3.0</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The matrix type extension supports compound assignments for addition, subtraction, and multiplication on matrices
and on a matrix and a scalar, provided their types are consistent.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">m4x4_t</span><span class="w"> </span><span class="nf">__attribute__</span><span class="p">((</span><span class="n">matrix_type</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)));</span>

<span class="n">m4x4_t</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">m4x4_t</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">m4x4_t</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">23</span><span class="p">;</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The matrix type extension supports explicit casts. Implicit type conversion between matrix types is not allowed.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ix5x5</span><span class="w"> </span><span class="nf">__attribute__</span><span class="p">((</span><span class="n">matrix_type</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)));</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">fx5x5</span><span class="w"> </span><span class="nf">__attribute__</span><span class="p">((</span><span class="n">matrix_type</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)));</span>

<span class="n">fx5x5</span><span class="w"> </span><span class="nf">f1</span><span class="p">(</span><span class="n">ix5x5</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">fx5x5</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">fx5x5</span><span class="p">)</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">X</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">matrix_4_4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">matrix_type</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)));</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">f2</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">matrix_5_5</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">d</span><span class="p">;</span>
<span class="w">  </span><span class="n">matrix_5_5</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">  </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">matrix_5_5</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span><span class="n">d</span><span class="p">;</span>
<span class="w">  </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">matrix_5_5</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="half-precision-floating-point">
<h2><a class="toc-backref" href="#id26" role="doc-backlink">Half-Precision Floating Point</a><a class="headerlink" href="#half-precision-floating-point" title="Link to this heading">¶</a></h2>
<p>Clang supports three half-precision (16-bit) floating point types:
<code class="docutils literal notranslate"><span class="pre">__fp16</span></code>, <code class="docutils literal notranslate"><span class="pre">_Float16</span></code> and <code class="docutils literal notranslate"><span class="pre">__bf16</span></code>. These types are supported
in all language modes, but their support differs between targets.
A target is said to have “native support” for a type if the target
processor offers instructions for directly performing basic arithmetic
on that type.  In the absence of native support, a type can still be
supported if the compiler can emulate arithmetic on the type by promoting
to <code class="docutils literal notranslate"><span class="pre">float</span></code>; see below for more information on this emulation.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__fp16</span></code> is supported on all targets. The special semantics of this
type mean that no arithmetic is ever performed directly on <code class="docutils literal notranslate"><span class="pre">__fp16</span></code> values;
see below.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_Float16</span></code> is supported on the following targets:</p>
<ul>
<li><p>32-bit ARM (natively on some architecture versions)</p></li>
<li><p>64-bit ARM (AArch64) (natively on ARMv8.2a and above)</p></li>
<li><p>AMDGPU (natively)</p></li>
<li><p>NVPTX (natively)</p></li>
<li><p>SPIR (natively)</p></li>
<li><p>X86 (if SSE2 is available; natively if AVX512-FP16 is also available)</p></li>
<li><p>RISC-V (natively if Zfh or Zhinx is available)</p></li>
<li><p>SystemZ (emulated)</p></li>
<li><p>LoongArch (emulated)</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__bf16</span></code> is supported on the following targets (currently never natively):</p>
<ul>
<li><p>32-bit ARM</p></li>
<li><p>64-bit ARM (AArch64)</p></li>
<li><p>RISC-V</p></li>
<li><p>X86 (when SSE2 is available)</p></li>
<li><p>LoongArch</p></li>
</ul>
</li>
</ul>
<p>(For X86, SSE2 is available on 64-bit and all recent 32-bit processors.)</p>
<p><code class="docutils literal notranslate"><span class="pre">__fp16</span></code> and <code class="docutils literal notranslate"><span class="pre">_Float16</span></code> both use the binary16 format from IEEE
754-2008, which provides a 5-bit exponent and an 11-bit significand
(counting the implicit leading 1). <code class="docutils literal notranslate"><span class="pre">__bf16</span></code> uses the <a class="reference external" href="https://en.wikipedia.org/wiki/Bfloat16_floating-point_format">bfloat16</a> format,
which provides an 8-bit exponent and an 8-bit significand; this is the same
exponent range as <cite>float</cite>, just with greatly reduced precision.</p>
<p><code class="docutils literal notranslate"><span class="pre">_Float16</span></code> and <code class="docutils literal notranslate"><span class="pre">__bf16</span></code> follow the usual rules for arithmetic
floating-point types. Most importantly, this means that arithmetic operations
on operands of these types are formally performed in the type and produce
values of the type. <code class="docutils literal notranslate"><span class="pre">__fp16</span></code> does not follow those rules: most operations
immediately promote operands of type <code class="docutils literal notranslate"><span class="pre">__fp16</span></code> to <code class="docutils literal notranslate"><span class="pre">float</span></code>, and so
arithmetic operations are defined to be performed in <code class="docutils literal notranslate"><span class="pre">float</span></code> and so result in
a value of type <code class="docutils literal notranslate"><span class="pre">float</span></code> (unless further promoted because of other operands).
See below for more information on the exact specifications of these types.</p>
<p>When compiling arithmetic on <code class="docutils literal notranslate"><span class="pre">_Float16</span></code> and <code class="docutils literal notranslate"><span class="pre">__bf16</span></code> for a target without
native support, Clang will perform the arithmetic in <code class="docutils literal notranslate"><span class="pre">float</span></code>, inserting
extensions and truncations as necessary. This can be done in a way that
exactly matches the operation-by-operation behavior of native support,
but that can require many extra truncations and extensions. By default,
when emulating <code class="docutils literal notranslate"><span class="pre">_Float16</span></code> and <code class="docutils literal notranslate"><span class="pre">__bf16</span></code> arithmetic using <code class="docutils literal notranslate"><span class="pre">float</span></code>, Clang
does not truncate intermediate operands back to their true type unless the
operand is the result of an explicit cast or assignment. This is generally
much faster but can generate different results from strict operation-by-operation
emulation. Usually the results are more precise. This is permitted by the
C and C++ standards under the rules for excess precision in intermediate operands;
see the discussion of evaluation formats in the C standard and [expr.pre] in
the C++ standard.</p>
<p>The use of excess precision can be independently controlled for these two
types with the <code class="docutils literal notranslate"><span class="pre">-ffloat16-excess-precision=</span></code> and
<code class="docutils literal notranslate"><span class="pre">-fbfloat16-excess-precision=</span></code> options. Valid values include:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">none</span></code>: meaning to perform strict operation-by-operation emulation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">standard</span></code>: meaning that excess precision is permitted under the rules
described in the standard, i.e. never across explicit casts or statements</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fast</span></code>: meaning that excess precision is permitted whenever the
optimizer sees an opportunity to avoid truncations; currently this has no
effect beyond <code class="docutils literal notranslate"><span class="pre">standard</span></code></p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">_Float16</span></code> type is an interchange floating type specified in
ISO/IEC TS 18661-3:2015 (“Floating-point extensions for C”). It will
be supported on more targets as they define ABIs for it.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__bf16</span></code> type is a non-standard extension, but it generally follows
the rules for arithmetic interchange floating types from ISO/IEC TS
18661-3:2015. In previous versions of Clang, it was a storage-only type
that forbade arithmetic operations. It will be supported on more targets
as they define ABIs for it.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__fp16</span></code> type was originally an ARM extension and is specified
by the <a class="reference external" href="https://github.com/ARM-software/acle/releases">ARM C Language Extensions</a>.
Clang uses the <code class="docutils literal notranslate"><span class="pre">binary16</span></code> format from IEEE 754-2008 for <code class="docutils literal notranslate"><span class="pre">__fp16</span></code>,
not the ARM alternative format. Operators that expect arithmetic operands
immediately promote <code class="docutils literal notranslate"><span class="pre">__fp16</span></code> operands to <code class="docutils literal notranslate"><span class="pre">float</span></code>.</p>
<p>It is recommended that portable code use <code class="docutils literal notranslate"><span class="pre">_Float16</span></code> instead of <code class="docutils literal notranslate"><span class="pre">__fp16</span></code>,
as it has been defined by the C standards committee and has behavior that is
more familiar to most programmers.</p>
<p>Because <code class="docutils literal notranslate"><span class="pre">__fp16</span></code> operands are always immediately promoted to <code class="docutils literal notranslate"><span class="pre">float</span></code>, the
common real type of <code class="docutils literal notranslate"><span class="pre">__fp16</span></code> and <code class="docutils literal notranslate"><span class="pre">_Float16</span></code> for the purposes of the usual
arithmetic conversions is <code class="docutils literal notranslate"><span class="pre">float</span></code>.</p>
<p>A literal can be given <code class="docutils literal notranslate"><span class="pre">_Float16</span></code> type using the suffix <code class="docutils literal notranslate"><span class="pre">f16</span></code>. For example,
<code class="docutils literal notranslate"><span class="pre">3.14f16</span></code>.</p>
<p>Because default argument promotion only applies to the standard floating-point
types, <code class="docutils literal notranslate"><span class="pre">_Float16</span></code> values are not promoted to <code class="docutils literal notranslate"><span class="pre">double</span></code> when passed as variadic
or untyped arguments. As a consequence, some caution must be taken when using
certain library facilities with <code class="docutils literal notranslate"><span class="pre">_Float16</span></code>; for example, there is no <code class="docutils literal notranslate"><span class="pre">printf</span></code> format
specifier for <code class="docutils literal notranslate"><span class="pre">_Float16</span></code>, and (unlike <code class="docutils literal notranslate"><span class="pre">float</span></code>) it will not be implicitly promoted to
<code class="docutils literal notranslate"><span class="pre">double</span></code> when passed to <code class="docutils literal notranslate"><span class="pre">printf</span></code>, so the programmer must explicitly cast it to
<code class="docutils literal notranslate"><span class="pre">double</span></code> before using it with an <code class="docutils literal notranslate"><span class="pre">%f</span></code> or similar specifier.</p>
</section>
<section id="messages-on-deprecated-and-unavailable-attributes">
<h2><a class="toc-backref" href="#id27" role="doc-backlink">Messages on <code class="docutils literal notranslate"><span class="pre">deprecated</span></code> and <code class="docutils literal notranslate"><span class="pre">unavailable</span></code> Attributes</a><a class="headerlink" href="#messages-on-deprecated-and-unavailable-attributes" title="Link to this heading">¶</a></h2>
<p>An optional string message can be added to the <code class="docutils literal notranslate"><span class="pre">deprecated</span></code> and
<code class="docutils literal notranslate"><span class="pre">unavailable</span></code> attributes.  For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">explode</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">deprecated</span><span class="p">(</span><span class="s">&quot;extremely unsafe, use &#39;combust&#39; instead!!!&quot;</span><span class="p">)));</span>
</pre></div>
</div>
<p>If the deprecated or unavailable declaration is used, the message will be
incorporated into the appropriate diagnostic:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>harmless.c:4:3: warning: &#39;explode&#39; is deprecated: extremely unsafe, use &#39;combust&#39; instead!!!
      [-Wdeprecated-declarations]
  explode();
  ^
</pre></div>
</div>
<p>Query for this feature with
<code class="docutils literal notranslate"><span class="pre">__has_extension(attribute_deprecated_with_message)</span></code> and
<code class="docutils literal notranslate"><span class="pre">__has_extension(attribute_unavailable_with_message)</span></code>.</p>
</section>
<section id="attributes-on-enumerators">
<h2><a class="toc-backref" href="#id28" role="doc-backlink">Attributes on Enumerators</a><a class="headerlink" href="#attributes-on-enumerators" title="Link to this heading">¶</a></h2>
<p>Clang allows attributes to be written on individual enumerators.  This allows
enumerators to be deprecated, made unavailable, etc.  The attribute must appear
after the enumerator name and before any initializer, like so:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="nc">OperationMode</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">OM_Invalid</span><span class="p">,</span>
<span class="w">  </span><span class="n">OM_Normal</span><span class="p">,</span>
<span class="w">  </span><span class="n">OM_Terrified</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">deprecated</span><span class="p">)),</span>
<span class="w">  </span><span class="n">OM_AbortOnError</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">deprecated</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Attributes on the <code class="docutils literal notranslate"><span class="pre">enum</span></code> declaration do not apply to individual enumerators.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_extension(enumerator_attributes)</span></code>.</p>
</section>
<section id="c-11-attributes-on-using-declarations">
<h2><a class="toc-backref" href="#id29" role="doc-backlink">C++11 Attributes on using-declarations</a><a class="headerlink" href="#c-11-attributes-on-using-declarations" title="Link to this heading">¶</a></h2>
<p>Clang allows C++-style <code class="docutils literal notranslate"><span class="pre">[[]]</span></code> attributes to be written on using-declarations.
For instance:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">using_if_exists</span><span class="p">]]</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">foo</span><span class="o">::</span><span class="n">baz</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">using_if_exists</span><span class="p">]];</span>
</pre></div>
</div>
<p>You can test for support for this extension with
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_attributes_on_using_declarations)</span></code>.</p>
</section>
<section id="user-specified-system-frameworks">
<h2><a class="toc-backref" href="#id30" role="doc-backlink">‘User-Specified’ System Frameworks</a><a class="headerlink" href="#user-specified-system-frameworks" title="Link to this heading">¶</a></h2>
<p>Clang provides a mechanism by which frameworks can be built in such a way that
they will always be treated as being “system frameworks”, even if they are not
present in a system framework directory.  This can be useful to system
framework developers who want to be able to test building other applications
with development builds of their framework, including the manner in which the
compiler changes warning behavior for system headers.</p>
<p>Framework developers can opt-in to this mechanism by creating a
“<code class="docutils literal notranslate"><span class="pre">.system_framework</span></code>” file at the top-level of their framework.  That is, the
framework should have contents like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.../TestFramework.framework
.../TestFramework.framework/.system_framework
.../TestFramework.framework/Headers
.../TestFramework.framework/Headers/TestFramework.h
...
</pre></div>
</div>
<p>Clang will treat the presence of this file as an indicator that the framework
should be treated as a system framework, regardless of how it was found in the
framework search path.  For consistency, we recommend that such files never be
included in installed versions of the framework.</p>
</section>
<section id="checks-for-standard-language-features">
<h2><a class="toc-backref" href="#id31" role="doc-backlink">Checks for Standard Language Features</a><a class="headerlink" href="#checks-for-standard-language-features" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">__has_feature</span></code> macro can be used to query if certain standard language
features are enabled.  The <code class="docutils literal notranslate"><span class="pre">__has_extension</span></code> macro can be used to query if
language features are available as an extension when compiling for a standard
which does not provide them.  The features which can be tested are listed here.</p>
<p>Since Clang 3.4, the C++ SD-6 feature test macros are also supported.
These are macros with names of the form <code class="docutils literal notranslate"><span class="pre">__cpp_&lt;feature_name&gt;</span></code>, and are
intended to be a portable way to query the supported features of the compiler.
See <a class="reference external" href="https://clang.llvm.org/cxx_status.html#ts">the C++ status page</a> for
information on the version of SD-6 supported by each Clang release, and the
macros provided by that revision of the recommendations.</p>
<section id="c-98">
<h3>C++98<a class="headerlink" href="#c-98" title="Link to this heading">¶</a></h3>
<p>The features listed below are part of the C++98 standard.  These features are
enabled by default when compiling C++ code.</p>
<section id="c-exceptions">
<h4>C++ exceptions<a class="headerlink" href="#c-exceptions" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_exceptions)</span></code> to determine if C++ exceptions have been
enabled.  For example, compiling code with <code class="docutils literal notranslate"><span class="pre">-fno-exceptions</span></code> disables C++
exceptions.</p>
</section>
<section id="c-rtti">
<h4>C++ RTTI<a class="headerlink" href="#c-rtti" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_rtti)</span></code> to determine if C++ RTTI has been enabled.  For
example, compiling code with <code class="docutils literal notranslate"><span class="pre">-fno-rtti</span></code> disables the use of RTTI.</p>
</section>
</section>
<section id="c-11">
<h3>C++11<a class="headerlink" href="#c-11" title="Link to this heading">¶</a></h3>
<p>The features listed below are part of the C++11 standard.  As a result, all
these features are enabled with the <code class="docutils literal notranslate"><span class="pre">-std=c++11</span></code> or <code class="docutils literal notranslate"><span class="pre">-std=gnu++11</span></code> option
when compiling C++ code.</p>
<section id="c-11-sfinae-includes-access-control">
<h4>C++11 SFINAE includes access control<a class="headerlink" href="#c-11-sfinae-includes-access-control" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_access_control_sfinae)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_access_control_sfinae)</span></code> to determine whether
access-control errors (e.g., calling a private constructor) are considered to
be template argument deduction errors (aka SFINAE errors), per <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1170">C++ DR1170</a>.</p>
</section>
<section id="c-11-alias-templates">
<h4>C++11 alias templates<a class="headerlink" href="#c-11-alias-templates" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_alias_templates)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_alias_templates)</span></code> to determine if support for C++11’s
alias declarations and alias templates is enabled.</p>
</section>
<section id="c-11-alignment-specifiers">
<h4>C++11 alignment specifiers<a class="headerlink" href="#c-11-alignment-specifiers" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_alignas)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_alignas)</span></code> to
determine if support for alignment specifiers using <code class="docutils literal notranslate"><span class="pre">alignas</span></code> is enabled.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_alignof)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_alignof)</span></code> to
determine if support for the <code class="docutils literal notranslate"><span class="pre">alignof</span></code> keyword is enabled.</p>
</section>
<section id="c-11-attributes">
<h4>C++11 attributes<a class="headerlink" href="#c-11-attributes" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_attributes)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_attributes)</span></code> to
determine if support for attribute parsing with C++11’s square bracket notation
is enabled.</p>
</section>
<section id="c-11-generalized-constant-expressions">
<h4>C++11 generalized constant expressions<a class="headerlink" href="#c-11-generalized-constant-expressions" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_constexpr)</span></code> to determine if support for generalized
constant expressions (e.g., <code class="docutils literal notranslate"><span class="pre">constexpr</span></code>) is enabled.</p>
</section>
<section id="c-11-decltype">
<h4>C++11 <code class="docutils literal notranslate"><span class="pre">decltype()</span></code><a class="headerlink" href="#c-11-decltype" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_decltype)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_decltype)</span></code> to
determine if support for the <code class="docutils literal notranslate"><span class="pre">decltype()</span></code> specifier is enabled.  C++11’s
<code class="docutils literal notranslate"><span class="pre">decltype</span></code> does not require type-completeness of a function call expression.
Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_decltype_incomplete_return_types)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_decltype_incomplete_return_types)</span></code> to determine if
support for this feature is enabled.</p>
</section>
<section id="c-11-default-template-arguments-in-function-templates">
<h4>C++11 default template arguments in function templates<a class="headerlink" href="#c-11-default-template-arguments-in-function-templates" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_default_function_template_args)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_default_function_template_args)</span></code> to determine if support
for default template arguments in function templates is enabled.</p>
</section>
<section id="c-11-defaulted-functions">
<h4>C++11 <code class="docutils literal notranslate"><span class="pre">default</span></code>ed functions<a class="headerlink" href="#c-11-defaulted-functions" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_defaulted_functions)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_defaulted_functions)</span></code> to determine if support for
defaulted function definitions (with <code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">default</span></code>) is enabled.</p>
</section>
<section id="c-11-delegating-constructors">
<h4>C++11 delegating constructors<a class="headerlink" href="#c-11-delegating-constructors" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_delegating_constructors)</span></code> to determine if support for
delegating constructors is enabled.</p>
</section>
<section id="c-11-deleted-functions">
<h4>C++11 <code class="docutils literal notranslate"><span class="pre">deleted</span></code> functions<a class="headerlink" href="#c-11-deleted-functions" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_deleted_functions)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_deleted_functions)</span></code> to determine if support for deleted
function definitions (with <code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">delete</span></code>) is enabled.</p>
</section>
<section id="c-11-explicit-conversion-functions">
<h4>C++11 explicit conversion functions<a class="headerlink" href="#c-11-explicit-conversion-functions" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_explicit_conversions)</span></code> to determine if support for
<code class="docutils literal notranslate"><span class="pre">explicit</span></code> conversion functions is enabled.</p>
</section>
<section id="c-11-generalized-initializers">
<h4>C++11 generalized initializers<a class="headerlink" href="#c-11-generalized-initializers" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_generalized_initializers)</span></code> to determine if support for
generalized initializers (using braced lists and <code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code>) is
enabled.</p>
</section>
<section id="c-11-implicit-move-constructors-assignment-operators">
<h4>C++11 implicit move constructors/assignment operators<a class="headerlink" href="#c-11-implicit-move-constructors-assignment-operators" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_implicit_moves)</span></code> to determine if Clang will implicitly
generate move constructors and move assignment operators where needed.</p>
</section>
<section id="c-11-inheriting-constructors">
<h4>C++11 inheriting constructors<a class="headerlink" href="#c-11-inheriting-constructors" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_inheriting_constructors)</span></code> to determine if support for
inheriting constructors is enabled.</p>
</section>
<section id="c-11-inline-namespaces">
<h4>C++11 inline namespaces<a class="headerlink" href="#c-11-inline-namespaces" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_inline_namespaces)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_inline_namespaces)</span></code> to determine if support for inline
namespaces is enabled.</p>
</section>
<section id="c-11-lambdas">
<h4>C++11 lambdas<a class="headerlink" href="#c-11-lambdas" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_lambdas)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_lambdas)</span></code> to
determine if support for lambdas is enabled.</p>
</section>
<section id="c-11-local-and-unnamed-types-as-template-arguments">
<h4>C++11 local and unnamed types as template arguments<a class="headerlink" href="#c-11-local-and-unnamed-types-as-template-arguments" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_local_type_template_args)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_local_type_template_args)</span></code> to determine if support for
local and unnamed types as template arguments is enabled.</p>
</section>
<section id="c-11-noexcept">
<h4>C++11 noexcept<a class="headerlink" href="#c-11-noexcept" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_noexcept)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_noexcept)</span></code> to
determine if support for noexcept exception specifications is enabled.</p>
</section>
<section id="c-11-in-class-non-static-data-member-initialization">
<h4>C++11 in-class non-static data member initialization<a class="headerlink" href="#c-11-in-class-non-static-data-member-initialization" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_nonstatic_member_init)</span></code> to determine whether in-class
initialization of non-static data members is enabled.</p>
</section>
<section id="c-11-nullptr">
<h4>C++11 <code class="docutils literal notranslate"><span class="pre">nullptr</span></code><a class="headerlink" href="#c-11-nullptr" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_nullptr)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_nullptr)</span></code> to
determine if support for <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> is enabled.</p>
</section>
<section id="c-11-override-control">
<h4>C++11 <code class="docutils literal notranslate"><span class="pre">override</span> <span class="pre">control</span></code><a class="headerlink" href="#c-11-override-control" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_override_control)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_override_control)</span></code> to determine if support for the
override control keywords is enabled.</p>
</section>
<section id="c-11-reference-qualified-functions">
<h4>C++11 reference-qualified functions<a class="headerlink" href="#c-11-reference-qualified-functions" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_reference_qualified_functions)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_reference_qualified_functions)</span></code> to determine if support
for reference-qualified functions (e.g., member functions with <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> or <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>
applied to <code class="docutils literal notranslate"><span class="pre">*this</span></code>) is enabled.</p>
</section>
<section id="c-11-range-based-for-loop">
<h4>C++11 range-based <code class="docutils literal notranslate"><span class="pre">for</span></code> loop<a class="headerlink" href="#c-11-range-based-for-loop" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_range_for)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_range_for)</span></code> to
determine if support for the range-based for loop is enabled.</p>
</section>
<section id="c-11-raw-string-literals">
<h4>C++11 raw string literals<a class="headerlink" href="#c-11-raw-string-literals" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_raw_string_literals)</span></code> to determine if support for raw
string literals (e.g., <code class="docutils literal notranslate"><span class="pre">R&quot;x(foo\bar)x&quot;</span></code>) is enabled.</p>
</section>
<section id="c-11-rvalue-references">
<h4>C++11 rvalue references<a class="headerlink" href="#c-11-rvalue-references" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_rvalue_references)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_rvalue_references)</span></code> to determine if support for rvalue
references is enabled.</p>
</section>
<section id="c-11-static-assert">
<h4>C++11 <code class="docutils literal notranslate"><span class="pre">static_assert()</span></code><a class="headerlink" href="#c-11-static-assert" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_static_assert)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_static_assert)</span></code> to determine if support for compile-time
assertions using <code class="docutils literal notranslate"><span class="pre">static_assert</span></code> is enabled.</p>
</section>
<section id="c-11-thread-local">
<h4>C++11 <code class="docutils literal notranslate"><span class="pre">thread_local</span></code><a class="headerlink" href="#c-11-thread-local" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_thread_local)</span></code> to determine if support for
<code class="docutils literal notranslate"><span class="pre">thread_local</span></code> variables is enabled.</p>
</section>
<section id="c-11-type-inference">
<h4>C++11 type inference<a class="headerlink" href="#c-11-type-inference" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_auto_type)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_auto_type)</span></code> to
determine C++11 type inference is supported using the <code class="docutils literal notranslate"><span class="pre">auto</span></code> specifier.  If
this is disabled, <code class="docutils literal notranslate"><span class="pre">auto</span></code> will instead be a storage class specifier, as in C
or C++98.</p>
</section>
<section id="c-11-strongly-typed-enumerations">
<h4>C++11 strongly typed enumerations<a class="headerlink" href="#c-11-strongly-typed-enumerations" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_strong_enums)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_strong_enums)</span></code> to determine if support for strongly
typed, scoped enumerations is enabled.</p>
</section>
<section id="c-11-trailing-return-type">
<h4>C++11 trailing return type<a class="headerlink" href="#c-11-trailing-return-type" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_trailing_return)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_trailing_return)</span></code> to determine if support for the
alternate function declaration syntax with trailing return type is enabled.</p>
</section>
<section id="c-11-unicode-string-literals">
<h4>C++11 Unicode string literals<a class="headerlink" href="#c-11-unicode-string-literals" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_unicode_literals)</span></code> to determine if support for Unicode
string literals is enabled.</p>
</section>
<section id="c-11-unrestricted-unions">
<h4>C++11 unrestricted unions<a class="headerlink" href="#c-11-unrestricted-unions" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_unrestricted_unions)</span></code> to determine if support for
unrestricted unions is enabled.</p>
</section>
<section id="c-11-user-defined-literals">
<h4>C++11 user-defined literals<a class="headerlink" href="#c-11-user-defined-literals" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_user_literals)</span></code> to determine if support for
user-defined literals is enabled.</p>
</section>
<section id="c-11-variadic-templates">
<h4>C++11 variadic templates<a class="headerlink" href="#c-11-variadic-templates" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_variadic_templates)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_variadic_templates)</span></code> to determine if support for
variadic templates is enabled.</p>
</section>
</section>
<section id="c-14">
<h3>C++14<a class="headerlink" href="#c-14" title="Link to this heading">¶</a></h3>
<p>The features listed below are part of the C++14 standard.  As a result, all
these features are enabled with the <code class="docutils literal notranslate"><span class="pre">-std=C++14</span></code> or <code class="docutils literal notranslate"><span class="pre">-std=gnu++14</span></code> option
when compiling C++ code.</p>
<section id="c-14-binary-literals">
<h4>C++14 binary literals<a class="headerlink" href="#c-14-binary-literals" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_binary_literals)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_binary_literals)</span></code> to determine whether
binary literals (for instance, <code class="docutils literal notranslate"><span class="pre">0b10010</span></code>) are recognized. Clang supports this
feature as an extension in all language modes.</p>
</section>
<section id="c-14-contextual-conversions">
<h4>C++14 contextual conversions<a class="headerlink" href="#c-14-contextual-conversions" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_contextual_conversions)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_contextual_conversions)</span></code> to determine if the C++14 rules
are used when performing an implicit conversion for an array bound in a
<em>new-expression</em>, the operand of a <em>delete-expression</em>, an integral constant
expression, or a condition in a <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement.</p>
</section>
<section id="c-14-decltype-auto">
<h4>C++14 decltype(auto)<a class="headerlink" href="#c-14-decltype-auto" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_decltype_auto)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_decltype_auto)</span></code> to determine if support
for the <code class="docutils literal notranslate"><span class="pre">decltype(auto)</span></code> placeholder type is enabled.</p>
</section>
<section id="c-14-default-initializers-for-aggregates">
<h4>C++14 default initializers for aggregates<a class="headerlink" href="#c-14-default-initializers-for-aggregates" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_aggregate_nsdmi)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_aggregate_nsdmi)</span></code> to determine if support
for default initializers in aggregate members is enabled.</p>
</section>
<section id="c-14-digit-separators">
<h4>C++14 digit separators<a class="headerlink" href="#c-14-digit-separators" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__cpp_digit_separators</span></code> to determine if support for digit separators
using single quotes (for instance, <code class="docutils literal notranslate"><span class="pre">10'000</span></code>) is enabled. At this time, there
is no corresponding <code class="docutils literal notranslate"><span class="pre">__has_feature</span></code> name</p>
</section>
<section id="c-14-generalized-lambda-capture">
<h4>C++14 generalized lambda capture<a class="headerlink" href="#c-14-generalized-lambda-capture" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_init_captures)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_init_captures)</span></code> to determine if support for
lambda captures with explicit initializers is enabled
(for instance, <code class="docutils literal notranslate"><span class="pre">[n(0)]</span> <span class="pre">{</span> <span class="pre">return</span> <span class="pre">++n;</span> <span class="pre">}</span></code>).</p>
</section>
<section id="c-14-generic-lambdas">
<h4>C++14 generic lambdas<a class="headerlink" href="#c-14-generic-lambdas" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_generic_lambdas)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_generic_lambdas)</span></code> to determine if support for generic
(polymorphic) lambdas is enabled
(for instance, <code class="docutils literal notranslate"><span class="pre">[]</span> <span class="pre">(auto</span> <span class="pre">x)</span> <span class="pre">{</span> <span class="pre">return</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1;</span> <span class="pre">}</span></code>).</p>
</section>
<section id="c-14-relaxed-constexpr">
<h4>C++14 relaxed constexpr<a class="headerlink" href="#c-14-relaxed-constexpr" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_relaxed_constexpr)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_relaxed_constexpr)</span></code> to determine if variable
declarations, local variable modification, and control flow constructs
are permitted in <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> functions.</p>
</section>
<section id="c-14-return-type-deduction">
<h4>C++14 return type deduction<a class="headerlink" href="#c-14-return-type-deduction" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_return_type_deduction)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_return_type_deduction)</span></code> to determine if support
for return type deduction for functions (using <code class="docutils literal notranslate"><span class="pre">auto</span></code> as a return type)
is enabled.</p>
</section>
<section id="c-14-runtime-sized-arrays">
<h4>C++14 runtime-sized arrays<a class="headerlink" href="#c-14-runtime-sized-arrays" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_runtime_array)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_runtime_array)</span></code> to determine if support
for arrays of runtime bound (a restricted form of variable-length arrays)
is enabled.
Clang’s implementation of this feature is incomplete.</p>
</section>
<section id="c-14-variable-templates">
<h4>C++14 variable templates<a class="headerlink" href="#c-14-variable-templates" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_variable_templates)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_variable_templates)</span></code> to determine if support for
templated variable declarations is enabled.</p>
</section>
<section id="c-type-aware-allocators">
<h4>C++ type aware allocators<a class="headerlink" href="#c-type-aware-allocators" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_extension(cxx_type_aware_allocators)</span></code> to determine the existence of
support for the future C++2d type aware allocator feature. For full details see
<a class="reference internal" href="CXXTypeAwareAllocators.html"><span class="doc">C++ Type Aware Allocators</span></a> for additional details.</p>
</section>
</section>
<section id="c11">
<h3>C11<a class="headerlink" href="#c11" title="Link to this heading">¶</a></h3>
<p>The features listed below are part of the C11 standard.  As a result, all these
features are enabled with the <code class="docutils literal notranslate"><span class="pre">-std=c11</span></code> or <code class="docutils literal notranslate"><span class="pre">-std=gnu11</span></code> option when
compiling C code.  Additionally, because these features are all
backward-compatible, they are available as extensions in all language modes.</p>
<section id="c11-alignment-specifiers">
<h4>C11 alignment specifiers<a class="headerlink" href="#c11-alignment-specifiers" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(c_alignas)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(c_alignas)</span></code> to determine
if support for alignment specifiers using <code class="docutils literal notranslate"><span class="pre">_Alignas</span></code> is enabled.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(c_alignof)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(c_alignof)</span></code> to determine
if support for the <code class="docutils literal notranslate"><span class="pre">_Alignof</span></code> keyword is enabled.</p>
</section>
<section id="c11-atomic-operations">
<h4>C11 atomic operations<a class="headerlink" href="#c11-atomic-operations" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(c_atomic)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(c_atomic)</span></code> to determine
if support for atomic types using <code class="docutils literal notranslate"><span class="pre">_Atomic</span></code> is enabled.  Clang also provides
<a class="reference internal" href="#langext-c11-atomic"><span class="std std-ref">a set of builtins</span></a> which can be used to implement
the <code class="docutils literal notranslate"><span class="pre">&lt;stdatomic.h&gt;</span></code> operations on <code class="docutils literal notranslate"><span class="pre">_Atomic</span></code> types. Use
<code class="docutils literal notranslate"><span class="pre">__has_include(&lt;stdatomic.h&gt;)</span></code> to determine if C11’s <code class="docutils literal notranslate"><span class="pre">&lt;stdatomic.h&gt;</span></code> header
is available.</p>
<p>Clang will use the system’s <code class="docutils literal notranslate"><span class="pre">&lt;stdatomic.h&gt;</span></code> header when one is available, and
will otherwise use its own. When using its own, implementations of the atomic
operations are provided as macros. In the cases where C11 also requires a real
function, this header provides only the declaration of that function (along
with a shadowing macro implementation), and you must link to a library which
provides a definition of the function if you use it instead of the macro.</p>
</section>
<section id="c11-generic-selections">
<h4>C11 generic selections<a class="headerlink" href="#c11-generic-selections" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(c_generic_selections)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_extension(c_generic_selections)</span></code> to determine if support for generic
selections is enabled.</p>
<p>As an extension, the C11 generic selection expression is available in all
languages supported by Clang.  The syntax is the same as that given in the C11
standard.</p>
<p>In C, type compatibility is decided according to the rules given in the
appropriate standard, but in C++, which lacks the type compatibility rules used
in C, types are considered compatible only if they are equivalent.</p>
<p>Clang also supports an extended form of <code class="docutils literal notranslate"><span class="pre">_Generic</span></code> with a controlling type
rather than a controlling expression. Unlike with a controlling expression, a
controlling type argument does not undergo any conversions and thus is suitable
for use when trying to match qualified types, incomplete types, or function
types. Variable-length array types lack the necessary compile-time information
to resolve which association they match with and thus are not allowed as a
controlling type argument.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_extension(c_generic_selection_with_controlling_type)</span></code> to determine
if support for this extension is enabled.</p>
</section>
<section id="c11-static-assert">
<h4>C11 <code class="docutils literal notranslate"><span class="pre">_Static_assert()</span></code><a class="headerlink" href="#c11-static-assert" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(c_static_assert)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(c_static_assert)</span></code>
to determine if support for compile-time assertions using <code class="docutils literal notranslate"><span class="pre">_Static_assert</span></code> is
enabled.</p>
</section>
<section id="c11-thread-local">
<h4>C11 <code class="docutils literal notranslate"><span class="pre">_Thread_local</span></code><a class="headerlink" href="#c11-thread-local" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(c_thread_local)</span></code> or <code class="docutils literal notranslate"><span class="pre">__has_extension(c_thread_local)</span></code>
to determine if support for <code class="docutils literal notranslate"><span class="pre">_Thread_local</span></code> variables is enabled.</p>
</section>
</section>
<section id="c2y">
<h3>C2y<a class="headerlink" href="#c2y" title="Link to this heading">¶</a></h3>
<p>The features listed below are part of the C2y standard.  As a result, all these
features are enabled with the <code class="docutils literal notranslate"><span class="pre">-std=c2y</span></code> or <code class="docutils literal notranslate"><span class="pre">-std=gnu2y</span></code> option when
compiling C code.</p>
<section id="c2y-countof">
<h4>C2y <code class="docutils literal notranslate"><span class="pre">_Countof</span></code><a class="headerlink" href="#c2y-countof" title="Link to this heading">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(c_countof)</span></code> (in C2y or later mode) or
<code class="docutils literal notranslate"><span class="pre">__has_extension(c_countof)</span></code> (in C23 or earlier mode) to determine if support
for the <code class="docutils literal notranslate"><span class="pre">_Countof</span></code> operator is enabled. This feature is not available in C++
mode.</p>
</section>
</section>
<section id="modules">
<h3>Modules<a class="headerlink" href="#modules" title="Link to this heading">¶</a></h3>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(modules)</span></code> to determine if Modules have been enabled.
For example, compiling code with <code class="docutils literal notranslate"><span class="pre">-fmodules</span></code> enables the use of Modules.</p>
<p>More information could be found <a class="reference external" href="https://clang.llvm.org/docs/Modules.html">here</a>.</p>
</section>
</section>
<section id="language-extensions-back-ported-to-previous-standards">
<h2><a class="toc-backref" href="#id32" role="doc-backlink">Language Extensions Back-ported to Previous Standards</a><a class="headerlink" href="#language-extensions-back-ported-to-previous-standards" title="Link to this heading">¶</a></h2>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Feature</p></th>
<th class="head"><p>Feature Test Macro</p></th>
<th class="head"><p>Introduced In</p></th>
<th class="head"><p>Backported To</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>variadic templates</p></td>
<td><p>__cpp_variadic_templates</p></td>
<td><p>C++11</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-odd"><td><p>Alias templates</p></td>
<td><p>__cpp_alias_templates</p></td>
<td><p>C++11</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-even"><td><p>Non-static data member initializers</p></td>
<td><p>__cpp_nsdmi</p></td>
<td><p>C++11</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-odd"><td><p>Range-based <code class="docutils literal notranslate"><span class="pre">for</span></code> loop</p></td>
<td><p>__cpp_range_based_for</p></td>
<td><p>C++11</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-even"><td><p>RValue references</p></td>
<td><p>__cpp_rvalue_references</p></td>
<td><p>C++11</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-odd"><td><p>Attributes</p></td>
<td><p>__cpp_attributes</p></td>
<td><p>C++11</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-even"><td><p>Lambdas</p></td>
<td><p>__cpp_lambdas</p></td>
<td><p>C++11</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-odd"><td><p>Generalized lambda captures</p></td>
<td><p>__cpp_init_captures</p></td>
<td><p>C++14</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-even"><td><p>Generic lambda expressions</p></td>
<td><p>__cpp_generic_lambdas</p></td>
<td><p>C++14</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-odd"><td><p>variable templates</p></td>
<td><p>__cpp_variable_templates</p></td>
<td><p>C++14</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-even"><td><p>Binary literals</p></td>
<td><p>__cpp_binary_literals</p></td>
<td><p>C++14</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-odd"><td><p>Relaxed constexpr</p></td>
<td><p>__cpp_constexpr</p></td>
<td><p>C++14</p></td>
<td><p>C++11</p></td>
</tr>
<tr class="row-even"><td><p>Static assert with no message</p></td>
<td><p>__cpp_static_assert &gt;= 201411L</p></td>
<td><p>C++17</p></td>
<td><p>C++11</p></td>
</tr>
<tr class="row-odd"><td><p>Pack expansion in generalized lambda-capture</p></td>
<td><p>__cpp_init_captures</p></td>
<td><p>C++17</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">constexpr</span></code></p></td>
<td><p>__cpp_if_constexpr</p></td>
<td><p>C++17</p></td>
<td><p>C++11</p></td>
</tr>
<tr class="row-odd"><td><p>fold expressions</p></td>
<td><p>__cpp_fold_expressions</p></td>
<td><p>C++17</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-even"><td><p>Lambda capture of *this by value</p></td>
<td><p>__cpp_capture_star_this</p></td>
<td><p>C++17</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-odd"><td><p>Attributes on enums</p></td>
<td><p>__cpp_enumerator_attributes</p></td>
<td><p>C++17</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-even"><td><p>Guaranteed copy elision</p></td>
<td><p>__cpp_guaranteed_copy_elision</p></td>
<td><p>C++17</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-odd"><td><p>Hexadecimal floating literals</p></td>
<td><p>__cpp_hex_float</p></td>
<td><p>C++17</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">inline</span></code> variables</p></td>
<td><p>__cpp_inline_variables</p></td>
<td><p>C++17</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-odd"><td><p>Attributes on namespaces</p></td>
<td><p>__cpp_namespace_attributes</p></td>
<td><p>C++17</p></td>
<td><p>C++11</p></td>
</tr>
<tr class="row-even"><td><p>Structured bindings</p></td>
<td><p>__cpp_structured_bindings</p></td>
<td><p>C++17</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-odd"><td><p>template template arguments</p></td>
<td><p>__cpp_template_template_args</p></td>
<td><p>C++17</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-even"><td><p>Familiar template syntax for generic lambdas</p></td>
<td><p>__cpp_generic_lambdas</p></td>
<td><p>C++20</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">operator[]</span></code></p></td>
<td><p>__cpp_multidimensional_subscript</p></td>
<td><p>C++20</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-even"><td><p>Designated initializers</p></td>
<td><p>__cpp_designated_initializers</p></td>
<td><p>C++20</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-odd"><td><p>Conditional <code class="docutils literal notranslate"><span class="pre">explicit</span></code></p></td>
<td><p>__cpp_conditional_explicit</p></td>
<td><p>C++20</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">enum</span></code></p></td>
<td><p>__cpp_using_enum</p></td>
<td><p>C++20</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">consteval</span></code></p></td>
<td><p>__cpp_if_consteval</p></td>
<td><p>C++23</p></td>
<td><p>C++20</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">operator()</span></code></p></td>
<td><p>__cpp_static_call_operator</p></td>
<td><p>C++23</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-odd"><td><p>Attributes on Lambda-Expressions</p></td>
<td></td>
<td><p>C++23</p></td>
<td><p>C++11</p></td>
</tr>
<tr class="row-even"><td><p>Attributes on Structured Bindings</p></td>
<td><p>__cpp_structured_bindings</p></td>
<td><p>C++26</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-odd"><td><p>Packs in Structured Bindings</p></td>
<td><p>__cpp_structured_bindings</p></td>
<td><p>C++26</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-even"><td><p>Structured binding declaration as a condition</p></td>
<td><p>__cpp_structured_bindings</p></td>
<td><p>C++26</p></td>
<td><p>C++98</p></td>
</tr>
<tr class="row-odd"><td><p>Static assert with user-generated message</p></td>
<td><p>__cpp_static_assert &gt;= 202306L</p></td>
<td><p>C++26</p></td>
<td><p>C++11</p></td>
</tr>
<tr class="row-even"><td><p>Pack Indexing</p></td>
<td><p>__cpp_pack_indexing</p></td>
<td><p>C++26</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">delete</span> <span class="pre">(&quot;should</span> <span class="pre">have</span> <span class="pre">a</span> <span class="pre">reason&quot;);</span></code></p></td>
<td><p>__cpp_deleted_function</p></td>
<td><p>C++26</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-even"><td><p>Variadic Friends</p></td>
<td><p>__cpp_variadic_friend</p></td>
<td><p>C++26</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-odd"><td><p>Trivial Relocatability</p></td>
<td><p>__cpp_trivial_relocatability</p></td>
<td><p>C++26</p></td>
<td><p>C++03</p></td>
</tr>
<tr class="row-even"><td><p>Designated initializers (N494)</p></td>
<td></td>
<td><p>C99</p></td>
<td><p>C89</p></td>
</tr>
<tr class="row-odd"><td><p>Array &amp; element qualification (N2607)</p></td>
<td></td>
<td><p>C23</p></td>
<td><p>C89</p></td>
</tr>
<tr class="row-even"><td><p>Attributes (N2335)</p></td>
<td></td>
<td><p>C23</p></td>
<td><p>C89</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">#embed</span></code> (N3017)</p></td>
<td></td>
<td><p>C23</p></td>
<td><p>C89, C++</p></td>
</tr>
<tr class="row-even"><td><p>Octal literals prefixed with <code class="docutils literal notranslate"><span class="pre">0o</span></code> or <code class="docutils literal notranslate"><span class="pre">0O</span></code></p></td>
<td></td>
<td><p>C2y</p></td>
<td><p>C89, C++</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">_Countof</span></code> (N3369, N3469)</p></td>
<td></td>
<td><p>C2y</p></td>
<td><p>C89</p></td>
</tr>
</tbody>
</table>
</section>
<section id="builtin-type-aliases">
<h2><a class="toc-backref" href="#id33" role="doc-backlink">Builtin type aliases</a><a class="headerlink" href="#builtin-type-aliases" title="Link to this heading">¶</a></h2>
<p>Clang provides a few builtin aliases to improve the throughput of certain metaprogramming facilities.</p>
<section id="builtin-common-type">
<h3>__builtin_common_type<a class="headerlink" href="#builtin-common-type" title="Link to this heading">¶</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BaseTemplate</span><span class="p">,</span>
<span class="w">          </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">TypeMember</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">HasTypeMember</span><span class="p">,</span>
<span class="w">          </span><span class="k">class</span><span class="w"> </span><span class="nc">HasNoTypeMember</span><span class="p">,</span>
<span class="w">          </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">__builtin_common_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
</pre></div>
</div>
<p>This alias is used for implementing <code class="docutils literal notranslate"><span class="pre">std::common_type</span></code>. If <code class="docutils literal notranslate"><span class="pre">std::common_type</span></code> should contain a <code class="docutils literal notranslate"><span class="pre">type</span></code> member,
it is an alias to <code class="docutils literal notranslate"><span class="pre">HasTypeMember&lt;TheCommonType&gt;</span></code>. Otherwise it is an alias to <code class="docutils literal notranslate"><span class="pre">HasNoTypeMember</span></code>. The
<code class="docutils literal notranslate"><span class="pre">BaseTemplate</span></code> is usually <code class="docutils literal notranslate"><span class="pre">std::common_type</span></code>. <code class="docutils literal notranslate"><span class="pre">Ts</span></code> are the arguments to <code class="docutils literal notranslate"><span class="pre">std::common_type</span></code>.</p>
</section>
<section id="type-pack-element">
<h3>__type_pack_element<a class="headerlink" href="#type-pack-element" title="Link to this heading">¶</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">__type_pack_element</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
</pre></div>
</div>
<p>This alias returns the type at <code class="docutils literal notranslate"><span class="pre">Index</span></code> in the parameter pack <code class="docutils literal notranslate"><span class="pre">Ts</span></code>.</p>
</section>
<section id="make-integer-seq">
<h3>__make_integer_seq<a class="headerlink" href="#make-integer-seq" title="Link to this heading">¶</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">IntSeqT</span><span class="p">,</span><span class="w"> </span><span class="n">IntSeqT</span><span class="p">...</span><span class="w"> </span><span class="n">Ints</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">IntSeq</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">__make_integer_seq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
</pre></div>
</div>
<p>This alias returns <code class="docutils literal notranslate"><span class="pre">IntSeq</span></code> instantiated with <code class="docutils literal notranslate"><span class="pre">IntSeqT</span> <span class="pre">=</span> <span class="pre">T``and</span> <span class="pre">``Ints</span></code> being the pack <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">...,</span> <span class="pre">N</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</section>
</section>
<section id="type-trait-primitives">
<h2><a class="toc-backref" href="#id34" role="doc-backlink">Type Trait Primitives</a><a class="headerlink" href="#type-trait-primitives" title="Link to this heading">¶</a></h2>
<p>Type trait primitives are special builtin constant expressions that can be used
by the standard C++ library to facilitate or simplify the implementation of
user-facing type traits in the &lt;type_traits&gt; header.</p>
<p>They are not intended to be used directly by user code because they are
implementation-defined and subject to change – as such they’re tied closely to
the supported set of system headers, currently:</p>
<ul class="simple">
<li><p>LLVM’s own libc++</p></li>
<li><p>GNU libstdc++</p></li>
<li><p>The Microsoft standard C++ library</p></li>
</ul>
<p>Clang supports the <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/Type-Traits.html">GNU C++ type traits</a> and a subset of the
<a class="reference external" href="https://msdn.microsoft.com/en-us/library/ms177194(v=VS.100).aspx">Microsoft Visual C++ type traits</a>,
as well as nearly all of the
<a class="reference external" href="http://docwiki.embarcadero.com/RADStudio/Rio/en/Type_Trait_Functions_(C%2B%2B11)_Index">Embarcadero C++ type traits</a>.</p>
<p>The following type trait primitives are supported by Clang. Those traits marked
(C++) provide implementations for type traits specified by the C++ standard;
<code class="docutils literal notranslate"><span class="pre">__X(...)</span></code> has the same semantics and constraints as the corresponding
<code class="docutils literal notranslate"><span class="pre">std::X_t&lt;...&gt;</span></code> or <code class="docutils literal notranslate"><span class="pre">std::X_v&lt;...&gt;</span></code> type trait.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__array_rank(type)</span></code> (Embarcadero):
Returns the number of levels of array in the type <code class="docutils literal notranslate"><span class="pre">type</span></code>:
<code class="docutils literal notranslate"><span class="pre">0</span></code> if <code class="docutils literal notranslate"><span class="pre">type</span></code> is not an array type, and
<code class="docutils literal notranslate"><span class="pre">__array_rank(element)</span> <span class="pre">+</span> <span class="pre">1</span></code> if <code class="docutils literal notranslate"><span class="pre">type</span></code> is an array of <code class="docutils literal notranslate"><span class="pre">element</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__array_extent(type,</span> <span class="pre">dim)</span></code> (Embarcadero):
The <code class="docutils literal notranslate"><span class="pre">dim</span></code>’th array bound in the type <code class="docutils literal notranslate"><span class="pre">type</span></code>, or <code class="docutils literal notranslate"><span class="pre">0</span></code> if
<code class="docutils literal notranslate"><span class="pre">dim</span> <span class="pre">&gt;=</span> <span class="pre">__array_rank(type)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_is_implicit_lifetime</span></code> (C++, GNU, Microsoft)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_is_virtual_base_of</span></code> (C++, GNU, Microsoft)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__can_pass_in_regs</span></code> (C++)
Returns whether a class can be passed in registers under the current
ABI. This type can only be applied to unqualified class types.
This is not a portable type trait.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_nothrow_assign</span></code> (GNU, Microsoft, Embarcadero):
Deprecated, use <code class="docutils literal notranslate"><span class="pre">__is_nothrow_assignable</span></code> instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_nothrow_move_assign</span></code> (GNU, Microsoft):
Deprecated, use <code class="docutils literal notranslate"><span class="pre">__is_nothrow_assignable</span></code> instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_nothrow_copy</span></code> (GNU, Microsoft):
Deprecated, use <code class="docutils literal notranslate"><span class="pre">__is_nothrow_constructible</span></code> instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_nothrow_constructor</span></code> (GNU, Microsoft):
Deprecated, use <code class="docutils literal notranslate"><span class="pre">__is_nothrow_constructible</span></code> instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_trivial_assign</span></code> (GNU, Microsoft, Embarcadero):
Deprecated, use <code class="docutils literal notranslate"><span class="pre">__is_trivially_assignable</span></code> instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_trivial_move_assign</span></code> (GNU, Microsoft):
Deprecated, use <code class="docutils literal notranslate"><span class="pre">__is_trivially_assignable</span></code> instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_trivial_copy</span></code> (GNU, Microsoft):
Deprecated, use <code class="docutils literal notranslate"><span class="pre">__is_trivially_copyable</span></code> instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_trivial_constructor</span></code> (GNU, Microsoft):
Deprecated, use <code class="docutils literal notranslate"><span class="pre">__is_trivially_constructible</span></code> instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_trivial_move_constructor</span></code> (GNU, Microsoft):
Deprecated, use <code class="docutils literal notranslate"><span class="pre">__is_trivially_constructible</span></code> instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_trivial_destructor</span></code> (GNU, Microsoft, Embarcadero):
Deprecated, use <code class="docutils literal notranslate"><span class="pre">__is_trivially_destructible</span></code> instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_unique_object_representations</span></code> (C++, GNU)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_virtual_destructor</span></code> (C++, GNU, Microsoft, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_abstract</span></code> (C++, GNU, Microsoft, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_aggregate</span></code> (C++, GNU, Microsoft)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_arithmetic</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_array</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_assignable</span></code> (C++, MSVC 2015)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_base_of</span></code> (C++, GNU, Microsoft, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_bounded_array</span></code> (C++, GNU, Microsoft, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_class</span></code> (C++, GNU, Microsoft, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_complete_type(type)</span></code> (Embarcadero):
Return <code class="docutils literal notranslate"><span class="pre">true</span></code> if <code class="docutils literal notranslate"><span class="pre">type</span></code> is a complete type.
Warning: this trait is dangerous because it can return different values at
different points in the same program.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_compound</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_const</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_constructible</span></code> (C++, MSVC 2013)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_convertible</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_nothrow_convertible</span></code> (C++, GNU)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_convertible_to</span></code> (Microsoft):
Synonym for <code class="docutils literal notranslate"><span class="pre">__is_convertible</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_destructible</span></code> (C++, MSVC 2013)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_empty</span></code> (C++, GNU, Microsoft, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_enum</span></code> (C++, GNU, Microsoft, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_final</span></code> (C++, GNU, Microsoft)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_floating_point</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_function</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_fundamental</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_integral</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_interface_class</span></code> (Microsoft):
Returns <code class="docutils literal notranslate"><span class="pre">false</span></code>, even for types defined with <code class="docutils literal notranslate"><span class="pre">__interface</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_layout_compatible</span></code> (C++, GNU, Microsoft)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_literal</span></code> (Clang):
Synonym for <code class="docutils literal notranslate"><span class="pre">__is_literal_type</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_literal_type</span></code> (C++, GNU, Microsoft):
Note, the corresponding standard trait was deprecated in C++17
and removed in C++20.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_lvalue_reference</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_member_object_pointer</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_member_function_pointer</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_member_pointer</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_nothrow_assignable</span></code> (C++, MSVC 2013)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_nothrow_constructible</span></code> (C++, MSVC 2013)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_nothrow_destructible</span></code> (C++, MSVC 2013)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_object</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_pod</span></code> (C++, GNU, Microsoft, Embarcadero):
Note, the corresponding standard trait was deprecated in C++20.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_pointer</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_pointer_interconvertible_base_of</span></code> (C++, GNU, Microsoft)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_polymorphic</span></code> (C++, GNU, Microsoft, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_reference</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_rvalue_reference</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_same</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_same_as</span></code> (GCC): Synonym for <code class="docutils literal notranslate"><span class="pre">__is_same</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_scalar</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_scoped_enum</span></code> (C++, GNU, Microsoft, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_sealed</span></code> (Microsoft):
Synonym for <code class="docutils literal notranslate"><span class="pre">__is_final</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_signed</span></code> (C++, Embarcadero):
Returns false for enumeration types, and returns true for floating-point
types. Note, before Clang 10, returned true for enumeration types if the
underlying type was signed, and returned false for floating-point types.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_standard_layout</span></code> (C++, GNU, Microsoft, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_trivial</span></code> (C++, GNU, Microsoft, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_trivially_assignable</span></code> (C++, GNU, Microsoft)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_trivially_constructible</span></code> (C++, GNU, Microsoft)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_trivially_copyable</span></code> (C++, GNU, Microsoft)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_trivially_destructible</span></code> (C++, MSVC 2013)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_trivially_relocatable</span></code> (Clang) (Deprecated,
use <code class="docutils literal notranslate"><span class="pre">__builtin_is_cpp_trivially_relocatable</span></code> instead).
Returns true if moving an object
of the given type, and then destroying the source object, is known to be
functionally equivalent to copying the underlying bytes and then dropping the
source object on the floor. This is true of trivial types,
C++26 relocatable types, and types which
were made trivially relocatable via the <code class="docutils literal notranslate"><span class="pre">clang::trivial_abi</span></code> attribute.
This trait is deprecated and should be replaced by
<code class="docutils literal notranslate"><span class="pre">__builtin_is_cpp_trivially_relocatable</span></code>. Note however that it is generally
unsafe to relocate a C++-relocatable type with <code class="docutils literal notranslate"><span class="pre">memcpy</span></code> or <code class="docutils literal notranslate"><span class="pre">memmove</span></code>;
use <code class="docutils literal notranslate"><span class="pre">__builtin_trivially_relocate</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_is_cpp_trivially_relocatable</span></code> (C++): Returns true if an object
is trivially relocatable, as defined by the C++26 standard [meta.unary.prop].
Note that when relocating the caller code should ensure that if the object is polymorphic,
the dynamic type is of the most derived type. Padding bytes should not be copied.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_is_replaceable</span></code> (C++): Returns true if an object
is replaceable, as defined by the C++26 standard [meta.unary.prop].</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_trivially_equality_comparable</span></code> (Clang): Returns true if comparing two
objects of the provided type is known to be equivalent to comparing their
object representations. Note that types containing padding bytes are never
trivially equality comparable.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_unbounded_array</span></code> (C++, GNU, Microsoft, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_union</span></code> (C++, GNU, Microsoft, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_unsigned</span></code> (C++, Embarcadero):
Returns false for enumeration types. Note, before Clang 13, returned true for
enumeration types if the underlying type was unsigned.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_void</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_volatile</span></code> (C++, Embarcadero)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__reference_binds_to_temporary(T,</span> <span class="pre">U)</span></code> (Clang):  Determines whether a
reference of type <code class="docutils literal notranslate"><span class="pre">T</span></code> bound to an expression of type <code class="docutils literal notranslate"><span class="pre">U</span></code> would bind to a
materialized temporary object. If <code class="docutils literal notranslate"><span class="pre">T</span></code> is not a reference type the result
is false. Note this trait will also return false when the initialization of
<code class="docutils literal notranslate"><span class="pre">T</span></code> from <code class="docutils literal notranslate"><span class="pre">U</span></code> is ill-formed.
Deprecated, use <code class="docutils literal notranslate"><span class="pre">__reference_constructs_from_temporary</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__reference_constructs_from_temporary(T,</span> <span class="pre">U)</span></code> (C++)
Returns true if a reference <code class="docutils literal notranslate"><span class="pre">T</span></code> can be direct-initialized from a temporary of type
a non-cv-qualified <code class="docutils literal notranslate"><span class="pre">U</span></code>.</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__reference_converts_from_temporary(T,</span> <span class="pre">U)</span></code> (C++)</dt><dd><p>Returns true if a reference <code class="docutils literal notranslate"><span class="pre">T</span></code> can be copy-initialized from a temporary of type
a non-cv-qualified <code class="docutils literal notranslate"><span class="pre">U</span></code>.</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">__underlying_type</span></code> (C++, GNU, Microsoft)</p></li>
</ul>
<p>In addition, the following expression traits are supported:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__is_lvalue_expr(e)</span></code> (Embarcadero):
Returns true if <code class="docutils literal notranslate"><span class="pre">e</span></code> is an lvalue expression.
Deprecated, use <code class="docutils literal notranslate"><span class="pre">__is_lvalue_reference(decltype((e)))</span></code> instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_rvalue_expr(e)</span></code> (Embarcadero):
Returns true if <code class="docutils literal notranslate"><span class="pre">e</span></code> is a prvalue expression.
Deprecated, use <code class="docutils literal notranslate"><span class="pre">!__is_reference(decltype((e)))</span></code> instead.</p></li>
</ul>
<p>There are multiple ways to detect support for a type trait <code class="docutils literal notranslate"><span class="pre">__X</span></code> in the
compiler, depending on the oldest version of Clang you wish to support.</p>
<ul class="simple">
<li><p>From Clang 10 onwards, <code class="docutils literal notranslate"><span class="pre">__has_builtin(__X)</span></code> can be used.</p></li>
<li><p>From Clang 6 onwards, <code class="docutils literal notranslate"><span class="pre">!__is_identifier(__X)</span></code> can be used.</p></li>
<li><p>From Clang 3 onwards, <code class="docutils literal notranslate"><span class="pre">__has_feature(X)</span></code> can be used, but only supports
the following traits:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_nothrow_assign</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_nothrow_copy</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_nothrow_constructor</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_trivial_assign</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_trivial_copy</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_trivial_constructor</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_trivial_destructor</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__has_virtual_destructor</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_abstract</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_base_of</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_class</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_constructible</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_convertible_to</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_empty</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_enum</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_final</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_literal</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_standard_layout</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_pod</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_polymorphic</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_sealed</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_trivial</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_trivially_assignable</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_trivially_constructible</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_trivially_copyable</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__is_union</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__underlying_type</span></code></p></li>
</ul>
</li>
</ul>
<p>A simplistic usage example as might be seen in standard C++ headers follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#if __has_builtin(__is_convertible_to)</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">From</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">To</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">is_convertible_to</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__is_convertible_to</span><span class="p">(</span><span class="n">From</span><span class="p">,</span><span class="w"> </span><span class="n">To</span><span class="p">);</span>
<span class="p">};</span>
<span class="cp">#else</span>
<span class="c1">// Emulate type trait for compatibility with other compilers.</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<section id="builtin-structured-binding-size-c">
<span id="builtin-structured-binding-size-doc"></span><h3>__builtin_structured_binding_size (C++)<a class="headerlink" href="#builtin-structured-binding-size-c" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">__builtin_structured_binding_size(T)</span></code> type trait returns
the <em>structured binding size</em> ([dcl.struct.bind]) of type <code class="docutils literal notranslate"><span class="pre">T</span></code></p>
<p>This is equivalent to the size of the pack <code class="docutils literal notranslate"><span class="pre">p</span></code> in <code class="docutils literal notranslate"><span class="pre">auto&amp;&amp;</span> <span class="pre">[...p]</span> <span class="pre">=</span> <span class="pre">declval&lt;T&amp;&gt;();</span></code>.
If the argument cannot be decomposed, <code class="docutils literal notranslate"><span class="pre">__builtin_structured_binding_size(T)</span></code>
is not a valid expression (<code class="docutils literal notranslate"><span class="pre">__builtin_structured_binding_size</span></code> is SFINAE-friendly).</p>
<p>builtin arrays, builtin SIMD vectors,
builtin complex types, <em>tuple-like</em> types, and decomposable class types
are decomposable types.</p>
<p>A type is considered a valid <em>tuple-like</em> if <code class="docutils literal notranslate"><span class="pre">std::tuple_size_v&lt;T&gt;</span></code> is a valid expression,
even if there is no valid <code class="docutils literal notranslate"><span class="pre">std::tuple_element</span></code> specialization or suitable
<code class="docutils literal notranslate"><span class="pre">get</span></code> function for that type.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">Idx</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">requires</span><span class="w"> </span><span class="p">(</span><span class="n">Idx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">__builtin_structured_binding_size</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">get_binding</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">obj</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">[...</span><span class="n">p</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">...[</span><span class="n">Idx</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">__builtin_structured_binding_size</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">get_binding</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">S</span><span class="p">{})</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="blocks">
<h2><a class="toc-backref" href="#id35" role="doc-backlink">Blocks</a><a class="headerlink" href="#blocks" title="Link to this heading">¶</a></h2>
<p>The syntax and high level language feature description is in
<a class="reference internal" href="BlockLanguageSpec.html"><span class="doc">BlockLanguageSpec</span></a>. Implementation and ABI details for
the clang implementation are in <a class="reference internal" href="Block-ABI-Apple.html"><span class="doc">Block-ABI-Apple</span></a>.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_extension(blocks)</span></code>.</p>
</section>
<section id="asm-goto-with-output-constraints">
<h2><a class="toc-backref" href="#id36" role="doc-backlink">ASM Goto with Output Constraints</a><a class="headerlink" href="#asm-goto-with-output-constraints" title="Link to this heading">¶</a></h2>
<p>Outputs may be used along any branches from the <code class="docutils literal notranslate"><span class="pre">asm</span> <span class="pre">goto</span></code> whether the
branches are taken or not.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_extension(gnu_asm_goto_with_outputs)</span></code>.</p>
<p>Prior to clang-16, the output may only be used safely when the indirect
branches are not taken.  Query for this difference with
<code class="docutils literal notranslate"><span class="pre">__has_extension(gnu_asm_goto_with_outputs_full)</span></code>.</p>
<p>When using tied-outputs (i.e. outputs that are inputs and outputs, not just
outputs) with the <cite>+r</cite> constraint, there is a hidden input that’s created
before the label, so numeric references to operands must account for that.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// %0 and %1 both refer to x</span>
<span class="w">    </span><span class="c1">// %l2 refers to err</span>
<span class="w">    </span><span class="k">asm</span><span class="w"> </span><span class="k">goto</span><span class="p">(</span><span class="s">&quot;# %0 %1 %l2&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;+r&quot;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="nl">err</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This was changed to match GCC in clang-13; for better portability, symbolic
references can be used instead of numeric references.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">asm</span><span class="w"> </span><span class="k">goto</span><span class="p">(</span><span class="s">&quot;# %[x] %l[err]&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="s">&quot;+r&quot;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">err</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="nl">err</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="asm-goto-versus-branch-target-enforcement">
<h2><a class="toc-backref" href="#id37" role="doc-backlink">ASM Goto versus Branch Target Enforcement</a><a class="headerlink" href="#asm-goto-versus-branch-target-enforcement" title="Link to this heading">¶</a></h2>
<p>Some target architectures implement branch target enforcement, by requiring
indirect (register-controlled) branch instructions to jump only to locations
marked by a special instruction (such as AArch64 <code class="docutils literal notranslate"><span class="pre">bti</span></code>).</p>
<p>The assembler code inside an <code class="docutils literal notranslate"><span class="pre">asm</span> <span class="pre">goto</span></code> statement is expected not to use a
branch instruction of that kind to transfer control to any of its destination
labels. Therefore, using a label in an <code class="docutils literal notranslate"><span class="pre">asm</span> <span class="pre">goto</span></code> statement does not cause
clang to put a <code class="docutils literal notranslate"><span class="pre">bti</span></code> or equivalent instruction at the label.</p>
</section>
<section id="constexpr-strings-in-gnu-asm-statements">
<h2><a class="toc-backref" href="#id38" role="doc-backlink">Constexpr strings in GNU ASM statements</a><a class="headerlink" href="#constexpr-strings-in-gnu-asm-statements" title="Link to this heading">¶</a></h2>
<p>In C++11 mode (and greater), Clang supports specifying the template,
constraints, and clobber strings with a parenthesized constant expression
producing an object with the following member functions</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">constexpr</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">data</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>such as <code class="docutils literal notranslate"><span class="pre">std::string</span></code>, <code class="docutils literal notranslate"><span class="pre">std::string_view</span></code>, <code class="docutils literal notranslate"><span class="pre">std::vector&lt;char&gt;</span></code>.
This mechanism follow the same rules as <code class="docutils literal notranslate"><span class="pre">static_assert</span></code> messages in
C++26, see <code class="docutils literal notranslate"><span class="pre">[dcl.pre]/p12</span></code>.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_extension(gnu_asm_constexpr_strings)</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">asm</span><span class="p">((</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="p">(</span><span class="s">&quot;nop&quot;</span><span class="p">))</span><span class="w"> </span><span class="o">:::</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="p">(</span><span class="s">&quot;memory&quot;</span><span class="p">)));</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="objective-c-features">
<h2><a class="toc-backref" href="#id39" role="doc-backlink">Objective-C Features</a><a class="headerlink" href="#objective-c-features" title="Link to this heading">¶</a></h2>
<section id="related-result-types">
<h3>Related result types<a class="headerlink" href="#related-result-types" title="Link to this heading">¶</a></h3>
<p>According to Cocoa conventions, Objective-C methods with certain names
(”<code class="docutils literal notranslate"><span class="pre">init</span></code>”, “<code class="docutils literal notranslate"><span class="pre">alloc</span></code>”, etc.) always return objects that are an instance of
the receiving class’s type.  Such methods are said to have a “related result
type”, meaning that a message send to one of these methods will have the same
static type as an instance of the receiver class.  For example, given the
following classes:</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="bp">NSObject</span>
<span class="p">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">alloc</span><span class="p">;</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@interface</span> <span class="bp">NSArray</span> : <span class="bp">NSObject</span>
<span class="k">@end</span>
</pre></div>
</div>
<p>and this common initialization pattern</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="bp">NSArray</span><span class="w"> </span><span class="o">*</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[[</span><span class="bp">NSArray</span><span class="w"> </span><span class="n">alloc</span><span class="p">]</span><span class="w"> </span><span class="n">init</span><span class="p">];</span>
</pre></div>
</div>
<p>the type of the expression <code class="docutils literal notranslate"><span class="pre">[NSArray</span> <span class="pre">alloc]</span></code> is <code class="docutils literal notranslate"><span class="pre">NSArray*</span></code> because
<code class="docutils literal notranslate"><span class="pre">alloc</span></code> implicitly has a related result type.  Similarly, the type of the
expression <code class="docutils literal notranslate"><span class="pre">[[NSArray</span> <span class="pre">alloc]</span> <span class="pre">init]</span></code> is <code class="docutils literal notranslate"><span class="pre">NSArray*</span></code>, since <code class="docutils literal notranslate"><span class="pre">init</span></code> has a
related result type and its receiver is known to have the type <code class="docutils literal notranslate"><span class="pre">NSArray</span> <span class="pre">*</span></code>.
If neither <code class="docutils literal notranslate"><span class="pre">alloc</span></code> nor <code class="docutils literal notranslate"><span class="pre">init</span></code> had a related result type, the expressions
would have had type <code class="docutils literal notranslate"><span class="pre">id</span></code>, as declared in the method signature.</p>
<p>A method with a related result type can be declared by using the type
<code class="docutils literal notranslate"><span class="pre">instancetype</span></code> as its result type.  <code class="docutils literal notranslate"><span class="pre">instancetype</span></code> is a contextual keyword
that is only permitted in the result type of an Objective-C method, e.g.</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="nc">A</span>
<span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">constructAnA</span><span class="p">;</span>
<span class="k">@end</span>
</pre></div>
</div>
<p>The related result type can also be inferred for some methods.  To determine
whether a method has an inferred related result type, the first word in the
camel-case selector (e.g., “<code class="docutils literal notranslate"><span class="pre">init</span></code>” in “<code class="docutils literal notranslate"><span class="pre">initWithObjects</span></code>”) is considered,
and the method will have a related result type if its return type is compatible
with the type of its class and if:</p>
<ul class="simple">
<li><p>the first word is “<code class="docutils literal notranslate"><span class="pre">alloc</span></code>” or “<code class="docutils literal notranslate"><span class="pre">new</span></code>”, and the method is a class method,
or</p></li>
<li><p>the first word is “<code class="docutils literal notranslate"><span class="pre">autorelease</span></code>”, “<code class="docutils literal notranslate"><span class="pre">init</span></code>”, “<code class="docutils literal notranslate"><span class="pre">retain</span></code>”, or “<code class="docutils literal notranslate"><span class="pre">self</span></code>”,
and the method is an instance method.</p></li>
</ul>
<p>If a method with a related result type is overridden by a subclass method, the
subclass method must also return a type that is compatible with the subclass
type.  For example:</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="bp">NSString</span> : <span class="bp">NSObject</span>
<span class="p">-</span> <span class="p">(</span><span class="n">NSUnrelated</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="nf">init</span><span class="p">;</span><span class="w"> </span><span class="c1">// incorrect usage: NSUnrelated is not NSString or a superclass of NSString</span>
<span class="k">@end</span>
</pre></div>
</div>
<p>Related result types only affect the type of a message send or property access
via the given method.  In all other respects, a method with a related result
type is treated the same way as method that returns <code class="docutils literal notranslate"><span class="pre">id</span></code>.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(objc_instancetype)</span></code> to determine whether the
<code class="docutils literal notranslate"><span class="pre">instancetype</span></code> contextual keyword is available.</p>
</section>
<section id="automatic-reference-counting">
<h3>Automatic reference counting<a class="headerlink" href="#automatic-reference-counting" title="Link to this heading">¶</a></h3>
<p>Clang provides support for <a class="reference internal" href="AutomaticReferenceCounting.html"><span class="doc">automated reference counting</span></a> in Objective-C, which eliminates the need
for manual <code class="docutils literal notranslate"><span class="pre">retain</span></code>/<code class="docutils literal notranslate"><span class="pre">release</span></code>/<code class="docutils literal notranslate"><span class="pre">autorelease</span></code> message sends.  There are three
feature macros associated with automatic reference counting:
<code class="docutils literal notranslate"><span class="pre">__has_feature(objc_arc)</span></code> indicates the availability of automated reference
counting in general, while <code class="docutils literal notranslate"><span class="pre">__has_feature(objc_arc_weak)</span></code> indicates that
automated reference counting also includes support for <code class="docutils literal notranslate"><span class="pre">__weak</span></code> pointers to
Objective-C objects. <code class="docutils literal notranslate"><span class="pre">__has_feature(objc_arc_fields)</span></code> indicates that C structs
are allowed to have fields that are pointers to Objective-C objects managed by
automatic reference counting.</p>
</section>
<section id="weak-references">
<span id="objc-weak"></span><h3>Weak references<a class="headerlink" href="#weak-references" title="Link to this heading">¶</a></h3>
<p>Clang supports ARC-style weak and unsafe references in Objective-C even
outside of ARC mode.  Weak references must be explicitly enabled with
the <code class="docutils literal notranslate"><span class="pre">-fobjc-weak</span></code> option; use <code class="docutils literal notranslate"><span class="pre">__has_feature((objc_arc_weak))</span></code>
to test whether they are enabled.  Unsafe references are enabled
unconditionally.  ARC-style weak and unsafe references cannot be used
when Objective-C garbage collection is enabled.</p>
<p>Except as noted below, the language rules for the <code class="docutils literal notranslate"><span class="pre">__weak</span></code> and
<code class="docutils literal notranslate"><span class="pre">__unsafe_unretained</span></code> qualifiers (and the <code class="docutils literal notranslate"><span class="pre">weak</span></code> and
<code class="docutils literal notranslate"><span class="pre">unsafe_unretained</span></code> property attributes) are just as laid out
in the <a class="reference internal" href="AutomaticReferenceCounting.html"><span class="doc">ARC specification</span></a>.
In particular, note that some classes do not support forming weak
references to their instances, and note that special care must be
taken when storing weak references in memory where initialization
and deinitialization are outside the responsibility of the compiler
(such as in <code class="docutils literal notranslate"><span class="pre">malloc</span></code>-ed memory).</p>
<p>Loading from a <code class="docutils literal notranslate"><span class="pre">__weak</span></code> variable always implicitly retains the
loaded value.  In non-ARC modes, this retain is normally balanced
by an implicit autorelease.  This autorelease can be suppressed
by performing the load in the receiver position of a <code class="docutils literal notranslate"><span class="pre">-retain</span></code>
message send (e.g. <code class="docutils literal notranslate"><span class="pre">[weakReference</span> <span class="pre">retain]</span></code>); note that this performs
only a single retain (the retain done when primitively loading from
the weak reference).</p>
<p>For the most part, <code class="docutils literal notranslate"><span class="pre">__unsafe_unretained</span></code> in non-ARC modes is just the
default behavior of variables and therefore is not needed.  However,
it does have an effect on the semantics of block captures: normally,
copying a block which captures an Objective-C object or block pointer
causes the captured pointer to be retained or copied, respectively,
but that behavior is suppressed when the captured variable is qualified
with <code class="docutils literal notranslate"><span class="pre">__unsafe_unretained</span></code>.</p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">__weak</span></code> qualifier formerly meant the GC qualifier in
all non-ARC modes and was silently ignored outside of GC modes.  It now
means the ARC-style qualifier in all non-GC modes and is no longer
allowed if not enabled by either <code class="docutils literal notranslate"><span class="pre">-fobjc-arc</span></code> or <code class="docutils literal notranslate"><span class="pre">-fobjc-weak</span></code>.
It is expected that <code class="docutils literal notranslate"><span class="pre">-fobjc-weak</span></code> will eventually be enabled by default
in all non-GC Objective-C modes.</p>
</section>
<section id="enumerations-with-a-fixed-underlying-type">
<span id="objc-fixed-enum"></span><h3>Enumerations with a fixed underlying type<a class="headerlink" href="#enumerations-with-a-fixed-underlying-type" title="Link to this heading">¶</a></h3>
<p>Clang provides support for C++11 enumerations with a fixed underlying type
within Objective-C and C <a class="reference external" href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3030.htm">prior to C23</a>.  For example, one can write an enumeration type as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Red</span><span class="p">,</span><span class="w"> </span><span class="n">Green</span><span class="p">,</span><span class="w"> </span><span class="n">Blue</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="n">Color</span><span class="p">;</span>
</pre></div>
</div>
<p>This specifies that the underlying type, which is used to store the enumeration
value, is <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code>.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(objc_fixed_enum)</span></code> to determine whether support for fixed
underlying types is available in Objective-C.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_extension(c_fixed_enum)</span></code> to determine whether support for fixed
underlying types is available in C prior to C23. This will also report <code class="docutils literal notranslate"><span class="pre">true</span></code> in C23
and later modes as the functionality is available even if it’s not an extension in
those modes.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(c_fixed_enum)</span></code> to determine whether support for fixed
underlying types is available in C23 and later.</p>
</section>
<section id="interoperability-with-c-11-lambdas">
<h3>Interoperability with C++11 lambdas<a class="headerlink" href="#interoperability-with-c-11-lambdas" title="Link to this heading">¶</a></h3>
<p>Clang provides interoperability between C++11 lambdas and blocks-based APIs, by
permitting a lambda to be implicitly converted to a block pointer with the
corresponding signature.  For example, consider an API such as <code class="docutils literal notranslate"><span class="pre">NSArray</span></code>’s
array-sorting method:</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="bp">NSArray</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="nf">sortedArrayUsingComparator:</span><span class="p">(</span><span class="n">NSComparator</span><span class="p">)</span><span class="nv">cmptr</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">NSComparator</span></code> is simply a typedef for the block pointer <code class="docutils literal notranslate"><span class="pre">NSComparisonResult</span>
<span class="pre">(^)(id,</span> <span class="pre">id)</span></code>, and parameters of this type are generally provided with block
literals as arguments.  However, one can also use a C++11 lambda so long as it
provides the same signature (in this case, accepting two parameters of type
<code class="docutils literal notranslate"><span class="pre">id</span></code> and returning an <code class="docutils literal notranslate"><span class="pre">NSComparisonResult</span></code>):</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="bp">NSArray</span><span class="w"> </span><span class="o">*</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="l">@[</span><span class="s">@&quot;string 1&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">@&quot;string 21&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">@&quot;string 12&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">@&quot;String 11&quot;</span><span class="p">,</span>
<span class="w">                   </span><span class="s">@&quot;String 02&quot;</span><span class="l">]</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="n">NSStringCompareOptions</span><span class="w"> </span><span class="n">comparisonOptions</span>
<span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">NSCaseInsensitiveSearch</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">NSNumericSearch</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="n">NSWidthInsensitiveSearch</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">NSForcedOrderingSearch</span><span class="p">;</span>
<span class="bp">NSLocale</span><span class="w"> </span><span class="o">*</span><span class="n">currentLocale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="bp">NSLocale</span><span class="w"> </span><span class="n">currentLocale</span><span class="p">];</span>
<span class="bp">NSArray</span><span class="w"> </span><span class="o">*</span><span class="n">sorted</span>
<span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">array</span><span class="w"> </span><span class="n">sortedArrayUsingComparator</span><span class="o">:</span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="kt">id</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="kt">id</span><span class="w"> </span><span class="n">s2</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">NSComparisonResult</span><span class="w"> </span><span class="p">{</span>
<span class="w">             </span><span class="n">NSRange</span><span class="w"> </span><span class="n">string1Range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">s1</span><span class="w"> </span><span class="n">length</span><span class="p">]);</span>
<span class="w">             </span><span class="k">return</span><span class="w"> </span><span class="p">[</span><span class="n">s1</span><span class="w"> </span><span class="n">compare</span><span class="o">:</span><span class="n">s2</span><span class="w"> </span><span class="n">options</span><span class="o">:</span><span class="n">comparisonOptions</span>
<span class="w">             </span><span class="nl">range</span><span class="p">:</span><span class="n">string1Range</span><span class="w"> </span><span class="n">locale</span><span class="o">:</span><span class="n">currentLocale</span><span class="p">];</span>
<span class="w">     </span><span class="p">}];</span>
<span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;sorted: %@&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sorted</span><span class="p">);</span>
</pre></div>
</div>
<p>This code relies on an implicit conversion from the type of the lambda
expression (an unnamed, local class type called the <em>closure type</em>) to the
corresponding block pointer type.  The conversion itself is expressed by a
conversion operator in that closure type that produces a block pointer with the
same signature as the lambda itself, e.g.,</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="n">operator</span><span class="w"> </span><span class="nf">NSComparisonResult</span><span class="w"> </span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span><span class="w"> </span><span class="kt">id</span><span class="p">)()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>This conversion function returns a new block that simply forwards the two
parameters to the lambda object (which it captures by copy), then returns the
result.  The returned block is first copied (with <code class="docutils literal notranslate"><span class="pre">Block_copy</span></code>) and then
autoreleased.  As an optimization, if a lambda expression is immediately
converted to a block pointer (as in the first example, above), then the block
is not copied and autoreleased: rather, it is given the same lifetime as a
block literal written at that point in the program, which avoids the overhead
of copying a block to the heap in the common case.</p>
<p>The conversion from a lambda to a block pointer is only available in
Objective-C++, and not in C++ with blocks, due to its use of Objective-C memory
management (autorelease).</p>
</section>
<section id="object-literals-and-subscripting">
<h3>Object Literals and Subscripting<a class="headerlink" href="#object-literals-and-subscripting" title="Link to this heading">¶</a></h3>
<p>Clang provides support for <a class="reference internal" href="ObjectiveCLiterals.html"><span class="doc">Object Literals and Subscripting</span></a> in Objective-C, which simplifies common Objective-C
programming patterns, makes programs more concise, and improves the safety of
container creation.  There are several feature macros associated with object
literals and subscripting: <code class="docutils literal notranslate"><span class="pre">__has_feature(objc_array_literals)</span></code> tests the
availability of array literals; <code class="docutils literal notranslate"><span class="pre">__has_feature(objc_dictionary_literals)</span></code>
tests the availability of dictionary literals;
<code class="docutils literal notranslate"><span class="pre">__has_feature(objc_subscripting)</span></code> tests the availability of object
subscripting.</p>
</section>
<section id="objective-c-autosynthesis-of-properties">
<h3>Objective-C Autosynthesis of Properties<a class="headerlink" href="#objective-c-autosynthesis-of-properties" title="Link to this heading">¶</a></h3>
<p>Clang provides support for autosynthesis of declared properties.  Using this
feature, clang provides default synthesis of those properties not declared
&#64;dynamic and not having user provided backing getter and setter methods.
<code class="docutils literal notranslate"><span class="pre">__has_feature(objc_default_synthesize_properties)</span></code> checks for availability
of this feature in version of clang being used.</p>
</section>
<section id="objective-c-retaining-behavior-attributes">
<span id="langext-objc-retain-release"></span><h3>Objective-C retaining behavior attributes<a class="headerlink" href="#objective-c-retaining-behavior-attributes" title="Link to this heading">¶</a></h3>
<p>In Objective-C, functions and methods are generally assumed to follow the
<a class="reference external" href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html">Cocoa Memory Management</a>
conventions for ownership of object arguments and
return values. However, there are exceptions, and so Clang provides attributes
to allow these exceptions to be documented. This are used by ARC and the
<a class="reference external" href="https://clang-analyzer.llvm.org">static analyzer</a> Some exceptions may be
better described using the <code class="docutils literal notranslate"><span class="pre">objc_method_family</span></code> attribute instead.</p>
<p><strong>Usage</strong>: The <code class="docutils literal notranslate"><span class="pre">ns_returns_retained</span></code>, <code class="docutils literal notranslate"><span class="pre">ns_returns_not_retained</span></code>,
<code class="docutils literal notranslate"><span class="pre">ns_returns_autoreleased</span></code>, <code class="docutils literal notranslate"><span class="pre">cf_returns_retained</span></code>, and
<code class="docutils literal notranslate"><span class="pre">cf_returns_not_retained</span></code> attributes can be placed on methods and functions
that return Objective-C or CoreFoundation objects. They are commonly placed at
the end of a function prototype or method declaration:</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="kt">id</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="bp">__attribute__</span><span class="p">((</span><span class="n">ns_returns_retained</span><span class="p">));</span>

<span class="p">-</span> <span class="p">(</span><span class="bp">NSString</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="nf">bar:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">x</span><span class="w"> </span><span class="bp">__attribute__</span><span class="p">((</span><span class="n">ns_returns_retained</span><span class="p">));</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">*_returns_retained</span></code> attributes specify that the returned object has a +1
retain count.  The <code class="docutils literal notranslate"><span class="pre">*_returns_not_retained</span></code> attributes specify that the return
object has a +0 retain count, even if the normal convention for its selector
would be +1.  <code class="docutils literal notranslate"><span class="pre">ns_returns_autoreleased</span></code> specifies that the returned object is
+0, but is guaranteed to live at least as long as the next flush of an
autorelease pool.</p>
<p><strong>Usage</strong>: The <code class="docutils literal notranslate"><span class="pre">ns_consumed</span></code> and <code class="docutils literal notranslate"><span class="pre">cf_consumed</span></code> attributes can be placed on
a parameter declaration; they specify that the argument is expected to have a
+1 retain count, which will be balanced in some way by the function or method.
The <code class="docutils literal notranslate"><span class="pre">ns_consumes_self</span></code> attribute can only be placed on an Objective-C
method; it specifies that the method expects its <code class="docutils literal notranslate"><span class="pre">self</span></code> parameter to have a
+1 retain count, which it will balance in some way.</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="bp">__attribute__</span><span class="p">((</span><span class="n">ns_consumed</span><span class="p">))</span><span class="w"> </span><span class="bp">NSString</span><span class="w"> </span><span class="o">*</span><span class="n">string</span><span class="p">);</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">bar</span><span class="w"> </span><span class="bp">__attribute__</span><span class="p">((</span><span class="n">ns_consumes_self</span><span class="p">));</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">baz:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span> <span class="nv">__attribute__</span><span class="p">((</span><span class="n">ns_consumed</span><span class="p">))</span> <span class="nv">x</span><span class="p">;</span>
</pre></div>
</div>
<p>Further examples of these attributes are available in the static analyzer’s
<a class="reference external" href="analyzer/user-docs/Annotations.html#cocoa-mem">list of annotations for analysis</a>.</p>
<p>Query for these features with <code class="docutils literal notranslate"><span class="pre">__has_attribute(ns_consumed)</span></code>,
<code class="docutils literal notranslate"><span class="pre">__has_attribute(ns_returns_retained)</span></code>, etc.</p>
</section>
<section id="objective-c-available">
<h3>Objective-C &#64;available<a class="headerlink" href="#objective-c-available" title="Link to this heading">¶</a></h3>
<p>It is possible to use the newest SDK but still build a program that can run on
older versions of macOS and iOS by passing <code class="docutils literal notranslate"><span class="pre">-mmacos-version-min=</span></code> /
<code class="docutils literal notranslate"><span class="pre">-miphoneos-version-min=</span></code>.</p>
<p>Before LLVM 5.0, when calling a function that exists only in the OS that’s
newer than the target OS (as determined by the minimum deployment version),
programmers had to carefully check if the function exists at runtime, using
null checks for weakly-linked C functions, <code class="docutils literal notranslate"><span class="pre">+class</span></code> for Objective-C classes,
and <code class="docutils literal notranslate"><span class="pre">-respondsToSelector:</span></code> or <code class="docutils literal notranslate"><span class="pre">+instancesRespondToSelector:</span></code> for
Objective-C methods.  If such a check was missed, the program would compile
fine, run fine on newer systems, but crash on older systems.</p>
<p>As of LLVM 5.0, <code class="docutils literal notranslate"><span class="pre">-Wunguarded-availability</span></code> uses the <a class="reference external" href="https://clang.llvm.org/docs/AttributeReference.html#availability">availability attributes</a> together
with the new <code class="docutils literal notranslate"><span class="pre">&#64;available()</span></code> keyword to assist with this issue.
When a method that’s introduced in the OS newer than the target OS is called, a
-Wunguarded-availability warning is emitted if that call is not guarded:</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">my_fun</span><span class="p">(</span><span class="n">NSSomeClass</span><span class="o">*</span><span class="w"> </span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// If fancyNewMethod was added in e.g. macOS 10.12, but the code is</span>
<span class="w">  </span><span class="c1">// built with -mmacos-version-min=10.11, then this unconditional call</span>
<span class="w">  </span><span class="c1">// will emit a -Wunguarded-availability warning:</span>
<span class="w">  </span><span class="p">[</span><span class="n">var</span><span class="w"> </span><span class="n">fancyNewMethod</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To fix the warning and to avoid the crash on macOS 10.11, wrap it in
<code class="docutils literal notranslate"><span class="pre">if(&#64;available())</span></code>:</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">my_fun</span><span class="p">(</span><span class="n">NSSomeClass</span><span class="o">*</span><span class="w"> </span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(@</span><span class="n">available</span><span class="p">(</span><span class="n">macOS</span><span class="w"> </span><span class="mf">10.12</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">[</span><span class="n">var</span><span class="w"> </span><span class="n">fancyNewMethod</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Put fallback behavior for old macOS versions (and for non-mac</span>
<span class="w">    </span><span class="c1">// platforms) here.</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">*</span></code> is required and means that platforms not explicitly listed will take
the true branch, and the compiler will emit <code class="docutils literal notranslate"><span class="pre">-Wunguarded-availability</span></code>
warnings for unlisted platforms based on those platform’s deployment target.
More than one platform can be listed in <code class="docutils literal notranslate"><span class="pre">&#64;available()</span></code>:</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">my_fun</span><span class="p">(</span><span class="n">NSSomeClass</span><span class="o">*</span><span class="w"> </span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(@</span><span class="n">available</span><span class="p">(</span><span class="n">macOS</span><span class="w"> </span><span class="mf">10.12</span><span class="p">,</span><span class="w"> </span><span class="n">iOS</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">[</span><span class="n">var</span><span class="w"> </span><span class="n">fancyNewMethod</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the caller of <code class="docutils literal notranslate"><span class="pre">my_fun()</span></code> already checks that <code class="docutils literal notranslate"><span class="pre">my_fun()</span></code> is only called
on 10.12, then add an <a class="reference external" href="https://clang.llvm.org/docs/AttributeReference.html#availability">availability attribute</a> to it,
which will also suppress the warning and require that calls to my_fun() are
checked:</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="n">API_AVAILABLE</span><span class="p">(</span><span class="n">macos</span><span class="p">(</span><span class="mf">10.12</span><span class="p">))</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">my_fun</span><span class="p">(</span><span class="n">NSSomeClass</span><span class="o">*</span><span class="w"> </span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">[</span><span class="n">var</span><span class="w"> </span><span class="n">fancyNewMethod</span><span class="p">];</span><span class="w">  </span><span class="c1">// Now ok.</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&#64;available()</span></code> is only available in Objective-C code.  To use the feature
in C and C++ code, use the <code class="docutils literal notranslate"><span class="pre">__builtin_available()</span></code> spelling instead.</p>
<p>If existing code uses null checks or <code class="docutils literal notranslate"><span class="pre">-respondsToSelector:</span></code>, it should
be changed to use <code class="docutils literal notranslate"><span class="pre">&#64;available()</span></code> (or <code class="docutils literal notranslate"><span class="pre">__builtin_available</span></code>) instead.</p>
<p><code class="docutils literal notranslate"><span class="pre">-Wunguarded-availability</span></code> is disabled by default, but
<code class="docutils literal notranslate"><span class="pre">-Wunguarded-availability-new</span></code>, which only emits this warning for APIs
that have been introduced in macOS &gt;= 10.13, iOS &gt;= 11, watchOS &gt;= 4 and
tvOS &gt;= 11, is enabled by default.</p>
</section>
<section id="objective-c-abi-protocol-qualifier-mangling-of-parameters">
<span id="langext-overloading"></span><h3>Objective-C++ ABI: protocol-qualifier mangling of parameters<a class="headerlink" href="#objective-c-abi-protocol-qualifier-mangling-of-parameters" title="Link to this heading">¶</a></h3>
<p>Starting with LLVM 3.4, Clang produces a new mangling for parameters whose
type is a qualified-<code class="docutils literal notranslate"><span class="pre">id</span></code> (e.g., <code class="docutils literal notranslate"><span class="pre">id&lt;Foo&gt;</span></code>).  This mangling allows such
parameters to be differentiated from those with the regular unqualified <code class="docutils literal notranslate"><span class="pre">id</span></code>
type.</p>
<p>This was a non-backward compatible mangling change to the ABI.  This change
allows proper overloading, and also prevents mangling conflicts with template
parameters of protocol-qualified type.</p>
<p>Query the presence of this new mangling with
<code class="docutils literal notranslate"><span class="pre">__has_feature(objc_protocol_qualifier_mangling)</span></code>.</p>
</section>
</section>
<section id="initializer-lists-for-complex-numbers-in-c">
<h2><a class="toc-backref" href="#id40" role="doc-backlink">Initializer lists for complex numbers in C</a><a class="headerlink" href="#initializer-lists-for-complex-numbers-in-c" title="Link to this heading">¶</a></h2>
<p>clang supports an extension which allows the following in C:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;math.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;complex.h&gt;</span>
<span class="n">complex</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="n">INFINITY</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// Init to (1, Inf)</span>
</pre></div>
</div>
<p>This construct is useful because there is no way to separately initialize the
real and imaginary parts of a complex variable in standard C, given that clang
does not support <code class="docutils literal notranslate"><span class="pre">_Imaginary</span></code>.  (Clang also supports the <code class="docutils literal notranslate"><span class="pre">__real__</span></code> and
<code class="docutils literal notranslate"><span class="pre">__imag__</span></code> extensions from gcc, which help in some cases, but are not usable
in static initializers.)</p>
<p>Note that this extension does not allow eliding the braces; the meaning of the
following two lines is different:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">complex</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// [0] = (1, 1)</span>
<span class="n">complex</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// [0] = (1, 0), [1] = (1, 0)</span>
</pre></div>
</div>
<p>This extension also works in C++ mode, as far as that goes, but does not apply
to the C++ <code class="docutils literal notranslate"><span class="pre">std::complex</span></code>.  (In C++11, list initialization allows the same
syntax to be used with <code class="docutils literal notranslate"><span class="pre">std::complex</span></code> with the same meaning.)</p>
<p>For GCC compatibility, <code class="docutils literal notranslate"><span class="pre">__builtin_complex(re,</span> <span class="pre">im)</span></code> can also be used to
construct a complex number from the given real and imaginary components.</p>
</section>
<section id="opencl-features">
<h2><a class="toc-backref" href="#id41" role="doc-backlink">OpenCL Features</a><a class="headerlink" href="#opencl-features" title="Link to this heading">¶</a></h2>
<p>Clang supports internal OpenCL extensions documented below.</p>
<section id="cl-clang-bitfields">
<h3><code class="docutils literal notranslate"><span class="pre">__cl_clang_bitfields</span></code><a class="headerlink" href="#cl-clang-bitfields" title="Link to this heading">¶</a></h3>
<p>With this extension it is possible to enable bitfields in structs
or unions using the OpenCL extension pragma mechanism detailed in
<a class="reference external" href="https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview">the OpenCL Extension Specification, section 1.2</a>.</p>
<p>Use of bitfields in OpenCL kernels can result in reduced portability as struct
layout is not guaranteed to be consistent when compiled by different compilers.
If structs with bitfields are used as kernel function parameters, it can result
in incorrect functionality when the layout is different between the host and
device code.</p>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma OPENCL EXTENSION __cl_clang_bitfields : enable</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">with_bitfield</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// compiled - no diagnostic generated</span>
<span class="p">};</span>

<span class="cp">#pragma OPENCL EXTENSION __cl_clang_bitfields : disable</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">without_bitfield</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// error - bitfields are not supported</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="cl-clang-function-pointers">
<h3><code class="docutils literal notranslate"><span class="pre">__cl_clang_function_pointers</span></code><a class="headerlink" href="#cl-clang-function-pointers" title="Link to this heading">¶</a></h3>
<p>With this extension it is possible to enable various language features that
are relying on function pointers using regular OpenCL extension pragma
mechanism detailed in <a class="reference external" href="https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview">the OpenCL Extension Specification,
section 1.2</a>.</p>
<p>In C++ for OpenCL this also enables:</p>
<ul class="simple">
<li><p>Use of member function pointers;</p></li>
<li><p>Unrestricted use of references to functions;</p></li>
<li><p>Virtual member functions.</p></li>
</ul>
<p>Such functionality is not conformant and does not guarantee to compile
correctly in any circumstances. It can be used if:</p>
<ul class="simple">
<li><p>the kernel source does not contain call expressions to (member-) function
pointers, or virtual functions. For example this extension can be used in
metaprogramming algorithms to be able to specify/detect types generically.</p></li>
<li><p>the generated kernel binary does not contain indirect calls because they
are eliminated using compiler optimizations e.g. devirtualization.</p></li>
<li><p>the selected target supports the function pointer like functionality e.g.
most CPU targets.</p></li>
</ul>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma OPENCL EXTENSION __cl_clang_function_pointers : enable</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)();</span><span class="w"> </span><span class="c1">// compiled - no diagnostic generated</span>
<span class="p">}</span>

<span class="cp">#pragma OPENCL EXTENSION __cl_clang_function_pointers : disable</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)();</span><span class="w"> </span><span class="c1">// error - pointers to function are not allowed</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="cl-clang-variadic-functions">
<h3><code class="docutils literal notranslate"><span class="pre">__cl_clang_variadic_functions</span></code><a class="headerlink" href="#cl-clang-variadic-functions" title="Link to this heading">¶</a></h3>
<p>With this extension it is possible to enable variadic arguments in functions
using regular OpenCL extension pragma mechanism detailed in <a class="reference external" href="https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview">the OpenCL
Extension Specification, section 1.2</a>.</p>
<p>This is not conformant behavior and it can only be used portably when the
functions with variadic prototypes do not get generated in binary e.g. the
variadic prototype is used to specify a function type with any number of
arguments in metaprogramming algorithms in C++ for OpenCL.</p>
<p>This extensions can also be used when the kernel code is intended for targets
supporting the variadic arguments e.g. majority of CPU targets.</p>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma OPENCL EXTENSION __cl_clang_variadic_functions : enable</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"> </span><span class="c1">// compiled - no diagnostic generated</span>

<span class="cp">#pragma OPENCL EXTENSION __cl_clang_variadic_functions : disable</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"> </span><span class="c1">// error - variadic prototype is not allowed</span>
</pre></div>
</div>
</section>
<section id="cl-clang-non-portable-kernel-param-types">
<h3><code class="docutils literal notranslate"><span class="pre">__cl_clang_non_portable_kernel_param_types</span></code><a class="headerlink" href="#cl-clang-non-portable-kernel-param-types" title="Link to this heading">¶</a></h3>
<p>With this extension it is possible to enable the use of some restricted types
in kernel parameters specified in <a class="reference external" href="https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html#kernel_function">C++ for OpenCL v1.0 s2.4</a>.
The restrictions can be relaxed using regular OpenCL extension pragma mechanism
detailed in <a class="reference external" href="https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview">the OpenCL Extension Specification, section 1.2</a>.</p>
<p>This is not a conformant behavior and it can only be used when the
kernel arguments are not accessed on the host side or the data layout/size
between the host and device is known to be compatible.</p>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Plain Old Data type.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Pod</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Not POD type because of the constructor.</span>
<span class="c1">// Standard layout type because there is only one access control.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">OnlySL</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">  </span><span class="n">OnlySL</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>

<span class="c1">// Not standard layout type because of two different access controls.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">NotSL</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#pragma OPENCL EXTENSION __cl_clang_non_portable_kernel_param_types : enable</span>
<span class="n">kernel</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel_main</span><span class="p">(</span>
<span class="w">  </span><span class="n">Pod</span><span class="w"> </span><span class="n">a</span><span class="p">,</span>

<span class="w">  </span><span class="n">OnlySL</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">  </span><span class="n">global</span><span class="w"> </span><span class="n">NotSL</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="p">,</span>
<span class="w">  </span><span class="n">global</span><span class="w"> </span><span class="n">OnlySL</span><span class="w"> </span><span class="o">*</span><span class="n">d</span>
<span class="p">);</span>
<span class="cp">#pragma OPENCL EXTENSION __cl_clang_non_portable_kernel_param_types : disable</span>
</pre></div>
</div>
</section>
<section id="remove-address-space-builtin-function">
<h3>Remove address space builtin function<a class="headerlink" href="#remove-address-space-builtin-function" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__remove_address_space</span></code> allows to derive types in C++ for OpenCL
that have address space qualifiers removed. This utility only affects
address space qualifiers, therefore, other type qualifiers such as
<code class="docutils literal notranslate"><span class="pre">const</span></code> or <code class="docutils literal notranslate"><span class="pre">volatile</span></code> remain unchanged.</p>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">par</span><span class="p">){</span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="n">var1</span><span class="p">;</span><span class="w"> </span><span class="c1">// error - local function variable with global address space</span>
<span class="w">  </span><span class="n">__private</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">var2</span><span class="p">;</span><span class="w"> </span><span class="c1">// error - conflicting address space qualifiers</span>
<span class="w">  </span><span class="n">__private</span><span class="w"> </span><span class="n">__remove_address_space</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="w"> </span><span class="n">var3</span><span class="p">;</span><span class="w"> </span><span class="c1">// var3 is __private int</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">bar</span><span class="p">(){</span>
<span class="w">  </span><span class="n">__global</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span>
<span class="w">  </span><span class="n">foo</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="legacy-1-x-atomics-with-generic-address-space">
<h3>Legacy 1.x atomics with generic address space<a class="headerlink" href="#legacy-1-x-atomics-with-generic-address-space" title="Link to this heading">¶</a></h3>
<p>Clang allows use of atomic functions from the OpenCL 1.x standards
with the generic address space pointer in C++ for OpenCL mode.</p>
<p>This is a non-portable feature and might not be supported by all
targets.</p>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">__generic</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">atomic_add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="webassembly-features">
<h2><a class="toc-backref" href="#id42" role="doc-backlink">WebAssembly Features</a><a class="headerlink" href="#webassembly-features" title="Link to this heading">¶</a></h2>
<p>Clang supports the WebAssembly features documented below. For further
information related to the semantics of the builtins, please refer to the <a class="reference external" href="https://webassembly.github.io/spec/core/">WebAssembly Specification</a>.
In this section, when we refer to reference types, we are referring to
WebAssembly reference types, not C++ reference types unless stated
otherwise.</p>
<section id="builtin-wasm-table-set">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_wasm_table_set</span></code><a class="headerlink" href="#builtin-wasm-table-set" title="Link to this heading">¶</a></h3>
<p>This builtin function stores a value in a WebAssembly table.
It takes three arguments.
The first argument is the table to store a value into, the second
argument is the index to which to store the value into, and the
third argument is a value of reference type to store in the table.
It returns nothing.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">__externref_t</span><span class="w"> </span><span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="k">extern</span><span class="w"> </span><span class="n">__externref_t</span><span class="w"> </span><span class="n">JSObj</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">store</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">__builtin_wasm_table_set</span><span class="p">(</span><span class="n">table</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">JSObj</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="builtin-wasm-table-get">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_wasm_table_get</span></code><a class="headerlink" href="#builtin-wasm-table-get" title="Link to this heading">¶</a></h3>
<p>This builtin function is the counterpart to <code class="docutils literal notranslate"><span class="pre">__builtin_wasm_table_set</span></code>
and loads a value from a WebAssembly table of reference typed values.
It takes 2 arguments.
The first argument is a table of reference typed values and the
second argument is an index from which to load the value. It returns
the loaded reference typed value.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">__externref_t</span><span class="w"> </span><span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="n">__externref_t</span><span class="w"> </span><span class="nf">load</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">__externref_t</span><span class="w"> </span><span class="n">Obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_wasm_table_get</span><span class="p">(</span><span class="n">table</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Obj</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="builtin-wasm-table-size">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_wasm_table_size</span></code><a class="headerlink" href="#builtin-wasm-table-size" title="Link to this heading">¶</a></h3>
<p>This builtin function returns the size of the WebAssembly table.
Takes the table as an argument and returns an unsigned integer (<code class="docutils literal notranslate"><span class="pre">size_t</span></code>)
with the current table size.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">__funcref</span><span class="w"> </span><span class="n">funcref_t</span><span class="p">)();</span>
<span class="k">static</span><span class="w"> </span><span class="n">funcref_t</span><span class="w"> </span><span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="kt">size_t</span><span class="w"> </span><span class="nf">getSize</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">__builtin_wasm_table_size</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="builtin-wasm-table-grow">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_wasm_table_grow</span></code><a class="headerlink" href="#builtin-wasm-table-grow" title="Link to this heading">¶</a></h3>
<p>This builtin function grows the WebAssembly table by a certain amount.
Currently, as all WebAssembly tables created in C/C++ are zero-sized,
this always needs to be called to grow the table.</p>
<p>It takes three arguments. The first argument is the WebAssembly table
to grow. The second argument is the reference typed value to store in
the new table entries (the initialization value), and the third argument
is the amount to grow the table by. It returns the previous table size
or -1. It will return -1 if not enough space could be allocated.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">__funcref</span><span class="w"> </span><span class="n">funcref_t</span><span class="p">)();</span>
<span class="k">static</span><span class="w"> </span><span class="n">funcref_t</span><span class="w"> </span><span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="c1">// grow returns the new table size or -1 on error.</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">grow</span><span class="p">(</span><span class="n">funcref_t</span><span class="w"> </span><span class="n">fn</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">delta</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">prevSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_wasm_table_grow</span><span class="p">(</span><span class="n">table</span><span class="p">,</span><span class="w"> </span><span class="n">fn</span><span class="p">,</span><span class="w"> </span><span class="n">delta</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prevSize</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">prevSize</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">delta</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="builtin-wasm-table-fill">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_wasm_table_fill</span></code><a class="headerlink" href="#builtin-wasm-table-fill" title="Link to this heading">¶</a></h3>
<p>This builtin function sets all the entries of a WebAssembly table to a given
reference typed value. It takes four arguments. The first argument is
the WebAssembly table, the second argument is the index that starts the
range, the third argument is the value to set in the new entries, and
the fourth and the last argument is the size of the range. It returns
nothing.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">__externref_t</span><span class="w"> </span><span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="c1">// resets a table by setting all of its entries to a given value.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span><span class="n">__externref_t</span><span class="w"> </span><span class="n">Obj</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">Size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_wasm_table_size</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
<span class="w">  </span><span class="n">__builtin_wasm_table_fill</span><span class="p">(</span><span class="n">table</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">Obj</span><span class="p">,</span><span class="w"> </span><span class="n">Size</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="builtin-wasm-table-copy">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_wasm_table_copy</span></code><a class="headerlink" href="#builtin-wasm-table-copy" title="Link to this heading">¶</a></h3>
<p>This builtin function copies elements from a source WebAssembly table
to a possibly overlapping destination region. It takes five arguments.
The first argument is the destination WebAssembly table, and the second
argument is the source WebAssembly table. The third argument is the
destination index from where the copy starts, the fourth argument is the
source index from there the copy starts, and the fifth and last argument
is the number of elements to copy. It returns nothing.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">__externref_t</span><span class="w"> </span><span class="n">tableSrc</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="k">static</span><span class="w"> </span><span class="n">__externref_t</span><span class="w"> </span><span class="n">tableDst</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="c1">// Copy nelem elements from [src, src + nelem - 1] in tableSrc to</span>
<span class="c1">// [dst, dst + nelem - 1] in tableDst</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">nelem</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">__builtin_wasm_table_copy</span><span class="p">(</span><span class="n">tableDst</span><span class="p">,</span><span class="w"> </span><span class="n">tableSrc</span><span class="p">,</span><span class="w"> </span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">nelem</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="builtin-functions">
<h2><a class="toc-backref" href="#id43" role="doc-backlink">Builtin Functions</a><a class="headerlink" href="#builtin-functions" title="Link to this heading">¶</a></h2>
<p>Clang supports a number of builtin library functions with the same syntax as
GCC, including things like <code class="docutils literal notranslate"><span class="pre">__builtin_nan</span></code>, <code class="docutils literal notranslate"><span class="pre">__builtin_constant_p</span></code>,
<code class="docutils literal notranslate"><span class="pre">__builtin_choose_expr</span></code>, <code class="docutils literal notranslate"><span class="pre">__builtin_types_compatible_p</span></code>,
<code class="docutils literal notranslate"><span class="pre">__builtin_assume_aligned</span></code>, <code class="docutils literal notranslate"><span class="pre">__sync_fetch_and_add</span></code>, etc.  In addition to
the GCC builtins, Clang supports a number of builtins that GCC does not, which
are listed here.</p>
<p>Please note that Clang does not and will not support all of the GCC builtins
for vector operations.  Instead of using builtins, you should use the functions
defined in target-specific header files like <code class="docutils literal notranslate"><span class="pre">&lt;xmmintrin.h&gt;</span></code>, which define
portable wrappers for these.  Many of the Clang versions of these functions are
implemented directly in terms of <a class="reference internal" href="#langext-vectors"><span class="std std-ref">extended vector support</span></a> instead of builtins, in order to reduce the number of
builtins that we need to implement.</p>
<section id="builtin-alloca">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_alloca</span></code><a class="headerlink" href="#builtin-alloca" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_alloca</span></code> is used to dynamically allocate memory on the stack. Memory
is automatically freed upon function termination.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_alloca</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nbelems</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nbelems</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">mem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">__builtin_alloca</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
<span class="w">  </span><span class="n">init</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="w">  </span><span class="n">process</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="w">  </span><span class="cm">/* mem is automatically freed at this point */</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_alloca</span></code> is meant to be used to allocate a dynamic amount of memory
on the stack. This amount is subject to stack allocation limits.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_alloca)</span></code>.</p>
</section>
<section id="builtin-alloca-with-align">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_alloca_with_align</span></code><a class="headerlink" href="#builtin-alloca-with-align" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_alloca_with_align</span></code> is used to dynamically allocate memory on the
stack while controlling its alignment. Memory is automatically freed upon
function termination.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_alloca_with_align</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">align</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nbelems</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">nbelems</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">mem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">__builtin_alloca_with_align</span><span class="p">(</span>
<span class="w">                      </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span>
<span class="w">                      </span><span class="n">CHAR_BIT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">alignof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
<span class="w">  </span><span class="n">init</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="w">  </span><span class="n">process</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="w">  </span><span class="cm">/* mem is automatically freed at this point */</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_alloca_with_align</span></code> is meant to be used to allocate a dynamic amount of memory
on the stack. It is similar to <code class="docutils literal notranslate"><span class="pre">__builtin_alloca</span></code> but accepts a second
argument whose value is the alignment constraint, as a power of 2 in <em>bits</em>.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_alloca_with_align)</span></code>.</p>
</section>
<section id="builtin-assume">
<span id="langext-builtin-assume"></span><h3><code class="docutils literal notranslate"><span class="pre">__builtin_assume</span></code><a class="headerlink" href="#builtin-assume" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_assume</span></code> is used to provide the optimizer with a boolean
invariant that is defined to be true.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_assume</span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">__builtin_assume</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// The optimizer may short-circuit this check using the invariant.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="n">do_something</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">do_something_else</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The boolean argument to this function is defined to be true. The optimizer may
analyze the form of the expression provided as the argument and deduce from
that information used to optimize the program. If the condition is violated
during execution, the behavior is undefined. The argument itself is never
evaluated, so any side effects of the expression will be discarded.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_assume)</span></code>.</p>
</section>
<section id="builtin-assume-separate-storage">
<span id="langext-builtin-assume-separate-storage"></span><h3><code class="docutils literal notranslate"><span class="pre">__builtin_assume_separate_storage</span></code><a class="headerlink" href="#builtin-assume-separate-storage" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_assume_separate_storage</span></code> is used to provide the optimizer with the
knowledge that its two arguments point to separately allocated objects.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_assume_separate_storage</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">__builtin_assume_separate_storage</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// The optimizer may optimize this to return 0 without reloading from *x.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The arguments to this function are assumed to point into separately allocated
storage (either different variable definitions or different dynamic storage
allocations). The optimizer may use this fact to aid in alias analysis. If the
arguments point into the same storage, the behavior is undefined. Note that the
definition of “storage” here refers to the outermost enclosing allocation of any
particular object (so for example, it’s never correct to call this function
passing the addresses of fields in the same struct, elements of the same array,
etc.).</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_assume_separate_storage)</span></code>.</p>
</section>
<section id="builtin-assume-dereferenceable">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_assume_dereferenceable</span></code><a class="headerlink" href="#builtin-assume-dereferenceable" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_assume_dereferenceable</span></code> is used to provide the optimizer with the
knowledge that the pointer argument P is dereferenceable up to at least the
specified number of bytes.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_assume_dereferenceable</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">__builtin_assume_dereferenceable</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// The optimizer may execute the load of x unconditionally due to</span>
<span class="w">      </span><span class="c1">// __builtin_assume_dereferenceable guaranteeing sizeof(int) bytes can</span>
<span class="w">      </span><span class="c1">// be loaded speculatively without trapping.</span>
<span class="w">      </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The arguments to this function provide a start pointer <code class="docutils literal notranslate"><span class="pre">P</span></code> and a size <code class="docutils literal notranslate"><span class="pre">S</span></code>.
<code class="docutils literal notranslate"><span class="pre">S</span></code> must be at least 1 and a constant. The optimizer may assume that <code class="docutils literal notranslate"><span class="pre">S</span></code>
bytes are dereferenceable starting at <code class="docutils literal notranslate"><span class="pre">P</span></code>. Note that this does not necessarily
imply that <code class="docutils literal notranslate"><span class="pre">P</span></code> is non-null as <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> can be dereferenced in some cases.
The assumption also does not imply that <code class="docutils literal notranslate"><span class="pre">P</span></code> is not dereferenceable past <code class="docutils literal notranslate"><span class="pre">S</span></code>
bytes.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_assume_dereferenceable)</span></code>.</p>
</section>
<section id="builtin-offsetof">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_offsetof</span></code><a class="headerlink" href="#builtin-offsetof" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_offsetof</span></code> is used to implement the <code class="docutils literal notranslate"><span class="pre">offsetof</span></code> macro, which
calculates the offset (in bytes) to a given member of the given type.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_offsetof</span><span class="p">(</span><span class="n">type</span><span class="o">-</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">member</span><span class="o">-</span><span class="n">designator</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">offset_to_i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_offsetof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ext1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_offsetof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">U</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="c1">// C extension</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">offset_to_subobject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_offsetof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>This builtin is usable in an integer constant expression which returns a value
of type <code class="docutils literal notranslate"><span class="pre">size_t</span></code>. The value returned is the offset in bytes to the subobject
designated by the member-designator from the beginning of an object of type
<code class="docutils literal notranslate"><span class="pre">type-name</span></code>. Clang extends the required standard functionality in the
following way:</p>
<ul class="simple">
<li><p>In C language modes, the first argument may be the definition of a new type.
Any type declared this way is scoped to the nearest scope containing the call
to the builtin.</p></li>
</ul>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_offsetof)</span></code>.</p>
</section>
<section id="builtin-get-vtable-pointer">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_get_vtable_pointer</span></code><a class="headerlink" href="#builtin-get-vtable-pointer" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_get_vtable_pointer</span></code> loads and authenticates the primary vtable
pointer from an instance of a polymorphic C++ class. This builtin is needed
for directly loading the vtable pointer when on platforms using
<a class="reference internal" href="PointerAuthentication.html"><span class="doc">Pointer Authentication</span></a>.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_get_vtable_pointer</span><span class="p">(</span><span class="n">PolymorphicClass</span><span class="o">*</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">PolymorphicClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">PolymorphicClass</span><span class="p">();</span>
<span class="p">};</span>

<span class="n">PolymorphicClass</span><span class="w"> </span><span class="n">anInstance</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">vtablePointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_get_vtable_pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anInstance</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__builtin_get_vtable_pointer</span></code> builtin loads the primary vtable
pointer from a polymorphic C++ type. If the target platform authenticates
vtable pointers, this builtin will perform the authentication and produce
the underlying raw pointer. The object being queried must be polymorphic,
and so must also be a complete type.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_get_vtable_pointer)</span></code>.</p>
</section>
<section id="builtin-call-with-static-chain">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_call_with_static_chain</span></code><a class="headerlink" href="#builtin-call-with-static-chain" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_call_with_static_chain</span></code> is used to perform a static call while
setting updating the static chain register.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="w"> </span><span class="n">__builtin_call_with_static_chain</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_call_with_static_chain</span><span class="p">(</span><span class="n">foo</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="n">foo</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>This builtin returns <code class="docutils literal notranslate"><span class="pre">expr</span></code> after checking that <code class="docutils literal notranslate"><span class="pre">expr</span></code> is a non-member
static call expression. The call to that expression is made while using <code class="docutils literal notranslate"><span class="pre">ptr</span></code>
as a function pointer stored in a dedicated register to implement <em>static chain</em>
calling convention, as used by some language to implement closures or nested
functions.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_call_with_static_chain)</span></code>.</p>
</section>
<section id="builtin-readcyclecounter">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_readcyclecounter</span></code><a class="headerlink" href="#builtin-readcyclecounter" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_readcyclecounter</span></code> is used to access the cycle counter register (or
a similar low-latency, high-accuracy clock) on those targets that support it.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_readcyclecounter</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_readcyclecounter</span><span class="p">();</span>
<span class="n">do_something</span><span class="p">();</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_readcyclecounter</span><span class="p">();</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">cycles_to_do_something</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="p">;</span><span class="w"> </span><span class="c1">// assuming no overflow</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__builtin_readcyclecounter()</span></code> builtin returns the cycle counter value,
which may be either global or process/thread-specific depending on the target.
As the backing counters often overflow quickly (on the order of seconds) this
should only be used for timing small intervals.  When not supported by the
target, the return value is always zero.  This builtin takes no arguments and
produces an unsigned long long result.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_readcyclecounter)</span></code>. Note
that even if present, its use may depend on run-time privilege or other OS
controlled state.</p>
</section>
<section id="builtin-readsteadycounter">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_readsteadycounter</span></code><a class="headerlink" href="#builtin-readsteadycounter" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_readsteadycounter</span></code> is used to access the fixed frequency counter
register (or a similar steady-rate clock) on those targets that support it.
The function is similar to <code class="docutils literal notranslate"><span class="pre">__builtin_readcyclecounter</span></code> above except that the
frequency is fixed, making it suitable for measuring elapsed time.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_readsteadycounter</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_readsteadycounter</span><span class="p">();</span>
<span class="n">do_something</span><span class="p">();</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_readsteadycounter</span><span class="p">();</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">secs_to_do_something</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">t1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">tick_rate</span><span class="p">;</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__builtin_readsteadycounter()</span></code> builtin returns the frequency counter value.
When not supported by the target, the return value is always zero. This builtin
takes no arguments and produces an unsigned long long result. The builtin does
not guarantee any particular frequency, only that it is stable. Knowledge of the
counter’s true frequency will need to be provided by the user.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_readsteadycounter)</span></code>.</p>
</section>
<section id="builtin-cpu-supports">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_cpu_supports</span></code><a class="headerlink" href="#builtin-cpu-supports" title="Link to this heading">¶</a></h3>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">__builtin_cpu_supports</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">features</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Example of Use:</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__builtin_cpu_supports</span><span class="p">(</span><span class="s">&quot;sve&quot;</span><span class="p">))</span>
<span class="w">  </span><span class="n">sve_code</span><span class="p">();</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__builtin_cpu_supports</span></code> function detects if the run-time CPU supports
features specified in string argument. It returns a positive integer if all
features are supported and 0 otherwise. Feature names are target specific. On
AArch64 features are combined using <code class="docutils literal notranslate"><span class="pre">+</span></code> like this
<code class="docutils literal notranslate"><span class="pre">__builtin_cpu_supports(&quot;flagm+sha3+lse+rcpc2+fcma+memtag+bti+sme2&quot;)</span></code>.
If a feature name is not supported, Clang will issue a warning and replace
builtin by the constant 0.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_cpu_supports)</span></code>.</p>
</section>
<section id="builtin-dump-struct">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_dump_struct</span></code><a class="headerlink" href="#builtin-dump-struct" title="Link to this heading">¶</a></h3>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_dump_struct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">some_struct</span><span class="p">,</span><span class="w"> </span><span class="n">some_printf_func</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">...);</span>
</pre></div>
</div>
<p><strong>Examples</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">f</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">__builtin_dump_struct</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">printf</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Example output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct S {
  int x = 100
  int y = 42
  float f = 3.141593
  struct T t = {
    int i = 1997
  }
}
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">constexpr_sprintf</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">format</span><span class="p">,</span>
<span class="w">                                 </span><span class="k">auto</span><span class="w"> </span><span class="p">...</span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">dump_struct</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">  </span><span class="n">__builtin_dump_struct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">constexpr_sprintf</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">dump_struct</span><span class="p">(</span><span class="n">T</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">})</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">(</span><span class="s">struct T {</span>
<span class="s">  int a = 1</span>
<span class="s">  int b = 2</span>
<span class="s">}</span>
<span class="dl">)</span><span class="s">&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__builtin_dump_struct</span></code> function is used to print the fields of a simple
structure and their values for debugging purposes. The first argument of the
builtin should be a pointer to a complete record type to dump. The second argument <code class="docutils literal notranslate"><span class="pre">f</span></code>
should be some callable expression, and can be a function object or an overload
set. The builtin calls <code class="docutils literal notranslate"><span class="pre">f</span></code>, passing any further arguments <code class="docutils literal notranslate"><span class="pre">args...</span></code>
followed by a <code class="docutils literal notranslate"><span class="pre">printf</span></code>-compatible format string and the corresponding
arguments. <code class="docutils literal notranslate"><span class="pre">f</span></code> may be called more than once, and <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">args</span></code> will be
evaluated once per call. In C++, <code class="docutils literal notranslate"><span class="pre">f</span></code> may be a template or overload set and
resolve to different functions for each call.</p>
<p>In the format string, a suitable format specifier will be used for builtin
types that Clang knows how to format. This includes standard builtin types, as
well as aggregate structures, <code class="docutils literal notranslate"><span class="pre">void*</span></code> (printed with <code class="docutils literal notranslate"><span class="pre">%p</span></code>), and <code class="docutils literal notranslate"><span class="pre">const</span>
<span class="pre">char*</span></code> (printed with <code class="docutils literal notranslate"><span class="pre">%s</span></code>). A <code class="docutils literal notranslate"><span class="pre">*%p</span></code> specifier will be used for a field
that Clang doesn’t know how to format, and the corresponding argument will be a
pointer to the field. This allows a C++ templated formatting function to detect
this case and implement custom formatting. A <code class="docutils literal notranslate"><span class="pre">*</span></code> will otherwise not precede a
format specifier.</p>
<p>This builtin does not return a value.</p>
<p>This builtin can be used in constant expressions.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_dump_struct)</span></code></p>
</section>
<section id="builtin-shufflevector">
<span id="langext-builtin-shufflevector"></span><h3><code class="docutils literal notranslate"><span class="pre">__builtin_shufflevector</span></code><a class="headerlink" href="#builtin-shufflevector" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_shufflevector</span></code> is used to express generic vector
permutation/shuffle/swizzle operations.  This builtin is also very important
for the implementation of various target-specific header files like
<code class="docutils literal notranslate"><span class="pre">&lt;xmmintrin.h&gt;</span></code>. This builtin can be used within constant expressions.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_shufflevector</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span><span class="w"> </span><span class="n">vec2</span><span class="p">,</span><span class="w"> </span><span class="n">index1</span><span class="p">,</span><span class="w"> </span><span class="n">index2</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
</pre></div>
</div>
<p><strong>Examples</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// identity operation - return 4-element vector v1.</span>
<span class="n">__builtin_shufflevector</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>

<span class="c1">// &quot;Splat&quot; element 0 of V1 into a 4-element result.</span>
<span class="n">__builtin_shufflevector</span><span class="p">(</span><span class="n">V1</span><span class="p">,</span><span class="w"> </span><span class="n">V1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>

<span class="c1">// Reverse 4-element vector V1.</span>
<span class="n">__builtin_shufflevector</span><span class="p">(</span><span class="n">V1</span><span class="p">,</span><span class="w"> </span><span class="n">V1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>

<span class="c1">// Concatenate every other element of 4-element vectors V1 and V2.</span>
<span class="n">__builtin_shufflevector</span><span class="p">(</span><span class="n">V1</span><span class="p">,</span><span class="w"> </span><span class="n">V2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span>

<span class="c1">// Concatenate every other element of 8-element vectors V1 and V2.</span>
<span class="n">__builtin_shufflevector</span><span class="p">(</span><span class="n">V1</span><span class="p">,</span><span class="w"> </span><span class="n">V2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">)</span>

<span class="c1">// Shuffle v1 with some elements being undefined. Not allowed in constexpr.</span>
<span class="n">__builtin_shufflevector</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The first two arguments to <code class="docutils literal notranslate"><span class="pre">__builtin_shufflevector</span></code> are vectors that have
the same element type.  The remaining arguments are a list of integers that
specify the elements indices of the first two vectors that should be extracted
and returned in a new vector.  These element indices are numbered sequentially
starting with the first vector, continuing into the second vector.  Thus, if
<code class="docutils literal notranslate"><span class="pre">vec1</span></code> is a 4-element vector, index 5 would refer to the second element of
<code class="docutils literal notranslate"><span class="pre">vec2</span></code>. An index of -1 can be used to indicate that the corresponding element
in the returned vector is a don’t care and can be optimized by the backend.
Values of -1 are not supported in constant expressions.</p>
<p>The result of <code class="docutils literal notranslate"><span class="pre">__builtin_shufflevector</span></code> is a vector with the same element
type as <code class="docutils literal notranslate"><span class="pre">vec1</span></code>/<code class="docutils literal notranslate"><span class="pre">vec2</span></code> but that has an element count equal to the number of
indices specified.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_shufflevector)</span></code>.</p>
</section>
<section id="builtin-convertvector">
<span id="langext-builtin-convertvector"></span><h3><code class="docutils literal notranslate"><span class="pre">__builtin_convertvector</span></code><a class="headerlink" href="#builtin-convertvector" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_convertvector</span></code> is used to express generic vector
type-conversion operations. The input vector and the output vector
type must have the same number of elements. This builtin can be used within
constant expressions.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_convertvector</span><span class="p">(</span><span class="n">src_vec</span><span class="p">,</span><span class="w"> </span><span class="n">dst_vec_type</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Examples</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">vector4double</span><span class="w"> </span><span class="nf">__attribute__</span><span class="p">((</span><span class="n">__vector_size__</span><span class="p">(</span><span class="mi">32</span><span class="p">)));</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w">  </span><span class="n">vector4float</span><span class="w">  </span><span class="nf">__attribute__</span><span class="p">((</span><span class="n">__vector_size__</span><span class="p">(</span><span class="mi">16</span><span class="p">)));</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">short</span><span class="w">  </span><span class="n">vector4short</span><span class="w">  </span><span class="nf">__attribute__</span><span class="p">((</span><span class="n">__vector_size__</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>
<span class="n">vector4float</span><span class="w"> </span><span class="n">vf</span><span class="p">;</span><span class="w"> </span><span class="n">vector4short</span><span class="w"> </span><span class="n">vs</span><span class="p">;</span>

<span class="c1">// convert from a vector of 4 floats to a vector of 4 doubles.</span>
<span class="n">__builtin_convertvector</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span><span class="w"> </span><span class="n">vector4double</span><span class="p">)</span>
<span class="c1">// equivalent to:</span>
<span class="p">(</span><span class="n">vector4double</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">vf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">vf</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">vf</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">vf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// convert from a vector of 4 shorts to a vector of 4 floats.</span>
<span class="n">__builtin_convertvector</span><span class="p">(</span><span class="n">vs</span><span class="p">,</span><span class="w"> </span><span class="n">vector4float</span><span class="p">)</span>
<span class="c1">// equivalent to:</span>
<span class="p">(</span><span class="n">vector4float</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="n">vs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="n">vs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="n">vs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="n">vs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The first argument to <code class="docutils literal notranslate"><span class="pre">__builtin_convertvector</span></code> is a vector, and the second
argument is a vector type with the same number of elements as the first
argument.</p>
<p>The result of <code class="docutils literal notranslate"><span class="pre">__builtin_convertvector</span></code> is a vector with the same element
type as the second argument, with a value defined in terms of the action of a
C-style cast applied to each element of the first argument.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_convertvector)</span></code>.</p>
</section>
<section id="builtin-bitreverse">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_bitreverse</span></code><a class="headerlink" href="#builtin-bitreverse" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_bitreverse8</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_bitreverse16</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_bitreverse32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_bitreverse64</span></code></p></li>
</ul>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_bitreverse32</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Examples</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">rev_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_bitreverse8</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="n">rev_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_bitreverse16</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">rev_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_bitreverse32</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="kt">uint64_t</span><span class="w"> </span><span class="n">rev_z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_bitreverse64</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">__builtin_bitreverse</span></code>’ family of builtins is used to reverse
the bitpattern of an integer value; for example <code class="docutils literal notranslate"><span class="pre">0b10110110</span></code> becomes
<code class="docutils literal notranslate"><span class="pre">0b01101101</span></code>. These builtins can be used within constant expressions.</p>
</section>
<section id="builtin-rotateleft">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_rotateleft</span></code><a class="headerlink" href="#builtin-rotateleft" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateleft8</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateleft16</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateleft32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateleft64</span></code></p></li>
</ul>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_rotateleft32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Examples</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">rot_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_rotateleft8</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="n">rot_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_rotateleft16</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">rot_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_rotateleft32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="kt">uint64_t</span><span class="w"> </span><span class="n">rot_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_rotateleft64</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">__builtin_rotateleft</span></code>’ family of builtins is used to rotate
the bits in the first argument by the amount in the second argument.
For example, <code class="docutils literal notranslate"><span class="pre">0b10000110</span></code> rotated left by 11 becomes <code class="docutils literal notranslate"><span class="pre">0b00110100</span></code>.
The shift value is treated as an unsigned amount modulo the size of
the arguments. Both arguments and the result have the bitwidth specified
by the name of the builtin. These builtins can be used within constant
expressions.</p>
</section>
<section id="builtin-rotateright">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_rotateright</span></code><a class="headerlink" href="#builtin-rotateright" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateright8</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateright16</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateright32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateright64</span></code></p></li>
</ul>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_rotateright32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Examples</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">rot_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_rotateright8</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="kt">uint16_t</span><span class="w"> </span><span class="n">rot_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_rotateright16</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">rot_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_rotateright32</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="kt">uint64_t</span><span class="w"> </span><span class="n">rot_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_rotateright64</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">__builtin_rotateright</span></code>’ family of builtins is used to rotate
the bits in the first argument by the amount in the second argument.
For example, <code class="docutils literal notranslate"><span class="pre">0b10000110</span></code> rotated right by 3 becomes <code class="docutils literal notranslate"><span class="pre">0b11010000</span></code>.
The shift value is treated as an unsigned amount modulo the size of
the arguments. Both arguments and the result have the bitwidth specified
by the name of the builtin. These builtins can be used within constant
expressions.</p>
</section>
<section id="builtin-unreachable">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_unreachable</span></code><a class="headerlink" href="#builtin-unreachable" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_unreachable</span></code> is used to indicate that a specific point in the
program cannot be reached, even if the compiler might otherwise think it can.
This is useful to improve optimization and eliminates certain warnings.  For
example, without the <code class="docutils literal notranslate"><span class="pre">__builtin_unreachable</span></code> in the example below, the
compiler assumes that the inline asm can fall through and prints a “function
declared ‘<code class="docutils literal notranslate"><span class="pre">noreturn</span></code>’ should not return” warning.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_unreachable</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Example of use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">myabort</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">noreturn</span><span class="p">));</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">myabort</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;int3&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">__builtin_unreachable</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__builtin_unreachable()</span></code> builtin has completely undefined behavior.
Since it has undefined behavior, it is a statement that it is never reached and
the optimizer can take advantage of this to produce better code.  This builtin
takes no arguments and produces a void result.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_unreachable)</span></code>.</p>
</section>
<section id="builtin-unpredictable">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_unpredictable</span></code><a class="headerlink" href="#builtin-unpredictable" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_unpredictable</span></code> is used to indicate that a branch condition is
unpredictable by hardware mechanisms such as branch prediction logic.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_unpredictable</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Example of use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__builtin_unpredictable</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__builtin_unpredictable()</span></code> builtin is expected to be used with control
flow conditions such as in <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">switch</span></code> statements.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_unpredictable)</span></code>.</p>
</section>
<section id="builtin-expect">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_expect</span></code><a class="headerlink" href="#builtin-expect" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_expect</span></code> is used to indicate that the value of an expression is
anticipated to be the same as a statically known result.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">long</span><span class="w"> </span><span class="n">__builtin_expect</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Example of use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__builtin_expect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">bar</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__builtin_expect()</span></code> builtin is typically used with control flow
conditions such as in <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">switch</span></code> statements to help branch
prediction. It means that its first argument <code class="docutils literal notranslate"><span class="pre">expr</span></code> is expected to take the
value of its second argument <code class="docutils literal notranslate"><span class="pre">val</span></code>. It always returns <code class="docutils literal notranslate"><span class="pre">expr</span></code>.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_expect)</span></code>.</p>
</section>
<section id="builtin-expect-with-probability">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_expect_with_probability</span></code><a class="headerlink" href="#builtin-expect-with-probability" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_expect_with_probability</span></code> is similar to <code class="docutils literal notranslate"><span class="pre">__builtin_expect</span></code> but it
takes a probability as third argument.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">long</span><span class="w"> </span><span class="n">__builtin_expect_with_probability</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Example of use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__builtin_expect_with_probability</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mf">.3</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">bar</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__builtin_expect_with_probability()</span></code> builtin is typically used with
control flow conditions such as in <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">switch</span></code> statements to help
branch prediction. It means that its first argument <code class="docutils literal notranslate"><span class="pre">expr</span></code> is expected to take
the value of its second argument <code class="docutils literal notranslate"><span class="pre">val</span></code> with probability <code class="docutils literal notranslate"><span class="pre">p</span></code>. <code class="docutils literal notranslate"><span class="pre">p</span></code> must be
within <code class="docutils literal notranslate"><span class="pre">[0.0</span> <span class="pre">;</span> <span class="pre">1.0]</span></code> bounds. This builtin always returns the value of <code class="docutils literal notranslate"><span class="pre">expr</span></code>.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_expect_with_probability)</span></code>.</p>
</section>
<section id="builtin-prefetch">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_prefetch</span></code><a class="headerlink" href="#builtin-prefetch" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_prefetch</span></code> is used to communicate with the cache handler to bring
data into the cache before it gets used.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">__builtin_prefetch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rw</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">locality</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Example of use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_prefetch</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__builtin_prefetch(addr,</span> <span class="pre">rw,</span> <span class="pre">locality)</span></code> builtin is expected to be used to
avoid cache misses when the developer has a good understanding of which data
are going to be used next. <code class="docutils literal notranslate"><span class="pre">addr</span></code> is the address that needs to be brought into
the cache. <code class="docutils literal notranslate"><span class="pre">rw</span></code> indicates the expected access mode: <code class="docutils literal notranslate"><span class="pre">0</span></code> for <em>read</em> and <code class="docutils literal notranslate"><span class="pre">1</span></code>
for <em>write</em>. In case of <em>read write</em> access, <code class="docutils literal notranslate"><span class="pre">1</span></code> is to be used. <code class="docutils literal notranslate"><span class="pre">locality</span></code>
indicates the expected persistence of data in cache, from <code class="docutils literal notranslate"><span class="pre">0</span></code> which means that
data can be discarded from cache after its next use to <code class="docutils literal notranslate"><span class="pre">3</span></code> which means that
data is going to be reused a lot once in cache. <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">2</span></code> provide
intermediate behavior between these two extremes.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_prefetch)</span></code>.</p>
</section>
<section id="sync-swap">
<h3><code class="docutils literal notranslate"><span class="pre">__sync_swap</span></code><a class="headerlink" href="#sync-swap" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__sync_swap</span></code> is used to atomically swap integers or pointers in memory.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">type</span><span class="w"> </span><span class="n">__sync_swap</span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
</pre></div>
</div>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">old_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__sync_swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">new_value</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__sync_swap()</span></code> builtin extends the existing <code class="docutils literal notranslate"><span class="pre">__sync_*()</span></code> family of
atomic intrinsics to allow code to atomically swap the current value with the
new value.  More importantly, it helps developers write more efficient and
correct code by avoiding expensive loops around
<code class="docutils literal notranslate"><span class="pre">__sync_bool_compare_and_swap()</span></code> or relying on the platform specific
implementation details of <code class="docutils literal notranslate"><span class="pre">__sync_lock_test_and_set()</span></code>.  The
<code class="docutils literal notranslate"><span class="pre">__sync_swap()</span></code> builtin is a full barrier.</p>
</section>
<section id="builtin-addressof">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_addressof</span></code><a class="headerlink" href="#builtin-addressof" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_addressof</span></code> performs the functionality of the built-in <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>
operator, ignoring any <code class="docutils literal notranslate"><span class="pre">operator&amp;</span></code> overload.  This is useful in constant
expressions in C++11, where there is no other way to take the address of an
object that overloads <code class="docutils literal notranslate"><span class="pre">operator&amp;</span></code>. Clang automatically adds
<code class="docutils literal notranslate"><span class="pre">[[clang::lifetimebound]]</span></code> to the parameter of <code class="docutils literal notranslate"><span class="pre">__builtin_addressof</span></code>.</p>
<p><strong>Example of use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addressof</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">__builtin_addressof</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="builtin-function-start">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_function_start</span></code><a class="headerlink" href="#builtin-function-start" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_function_start</span></code> returns the address of a function body.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">__builtin_function_start</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Example of use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">a</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_function_start</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>

<span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">a</span><span class="p">();</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">A::a</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">A::a</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>

<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pa1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_function_start</span><span class="p">((</span><span class="kt">void</span><span class="p">(</span><span class="n">A</span><span class="o">::*</span><span class="p">)(</span><span class="kt">int</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">a</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pa2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_function_start</span><span class="p">((</span><span class="kt">void</span><span class="p">(</span><span class="n">A</span><span class="o">::*</span><span class="p">)())</span><span class="w"> </span><span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__builtin_function_start</span></code> builtin accepts an argument that can be
constant-evaluated to a function, and returns the address of the function
body.  This builtin is not supported on all targets.</p>
<p>The returned pointer may differ from the normally taken function address
and is not safe to call.  For example, with <code class="docutils literal notranslate"><span class="pre">-fsanitize=cfi</span></code>, taking a
function address produces a callable pointer to a CFI jump table, while
<code class="docutils literal notranslate"><span class="pre">__builtin_function_start</span></code> returns an address that fails
<a class="reference internal" href="ControlFlowIntegrity.html"><span class="doc">cfi-icall</span></a> checks.</p>
</section>
<section id="builtin-operator-new-and-builtin-operator-delete">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_operator_new</span></code> and <code class="docutils literal notranslate"><span class="pre">__builtin_operator_delete</span></code><a class="headerlink" href="#builtin-operator-new-and-builtin-operator-delete" title="Link to this heading">¶</a></h3>
<p>A call to <code class="docutils literal notranslate"><span class="pre">__builtin_operator_new(args)</span></code> is exactly the same as a call to
<code class="docutils literal notranslate"><span class="pre">::operator</span> <span class="pre">new(args)</span></code>, except that it allows certain optimizations
that the C++ standard does not permit for a direct function call to
<code class="docutils literal notranslate"><span class="pre">::operator</span> <span class="pre">new</span></code> (in particular, removing <code class="docutils literal notranslate"><span class="pre">new</span></code> / <code class="docutils literal notranslate"><span class="pre">delete</span></code> pairs and
merging allocations), and that the call is required to resolve to a
<a class="reference external" href="https://en.cppreference.com/w/cpp/memory/new/operator_new">replaceable global allocation function</a>.</p>
<p>Likewise, <code class="docutils literal notranslate"><span class="pre">__builtin_operator_delete</span></code> is exactly the same as a call to
<code class="docutils literal notranslate"><span class="pre">::operator</span> <span class="pre">delete(args)</span></code>, except that it permits optimizations
and that the call is required to resolve to a
<a class="reference external" href="https://en.cppreference.com/w/cpp/memory/new/operator_delete">replaceable global deallocation function</a>.</p>
<p>These builtins are intended for use in the implementation of <code class="docutils literal notranslate"><span class="pre">std::allocator</span></code>
and other similar allocation libraries, and are only available in C++.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_operator_new)</span></code> or
<code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_operator_delete)</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>If the value is at least <code class="docutils literal notranslate"><span class="pre">201802L</span></code>, the builtins behave as described above.</p></li>
<li><p>If the value is non-zero, the builtins may not support calling arbitrary
replaceable global (de)allocation functions, but do support calling at least
<code class="docutils literal notranslate"><span class="pre">::operator</span> <span class="pre">new(size_t)</span></code> and <code class="docutils literal notranslate"><span class="pre">::operator</span> <span class="pre">delete(void*)</span></code>.</p></li>
</ul>
</div></blockquote>
</section>
<section id="builtin-trivially-relocate">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_trivially_relocate</span></code><a class="headerlink" href="#builtin-trivially-relocate" title="Link to this heading">¶</a></h3>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">__builtin_trivially_relocate</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
<p>Trivially relocates <code class="docutils literal notranslate"><span class="pre">count</span></code> objects of relocatable, complete type <code class="docutils literal notranslate"><span class="pre">T</span></code>
from <code class="docutils literal notranslate"><span class="pre">src</span></code> to <code class="docutils literal notranslate"><span class="pre">dest</span></code> and returns <code class="docutils literal notranslate"><span class="pre">dest</span></code>.
This builtin is used to implement <code class="docutils literal notranslate"><span class="pre">std::trivially_relocate</span></code>.</p>
</section>
<section id="builtin-invoke">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_invoke</span></code><a class="headerlink" href="#builtin-invoke" title="Link to this heading">¶</a></h3>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Callee</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span><span class="w"> </span><span class="n">__builtin_invoke</span><span class="p">(</span><span class="n">Callee</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">callee</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_invoke</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">std::invoke</span></code>.</p>
</section>
<section id="builtin-preserve-access-index">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_preserve_access_index</span></code><a class="headerlink" href="#builtin-preserve-access-index" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_preserve_access_index</span></code> specifies a code section where
array subscript access and structure/union member access are relocatable
under bpf compile-once run-everywhere framework. Debuginfo (typically
with <code class="docutils literal notranslate"><span class="pre">-g</span></code>) is needed, otherwise, the compiler will exit with an error.
The return type for the intrinsic is the same as the type of the
argument.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">type</span><span class="w"> </span><span class="n">__builtin_preserve_access_index</span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">t</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">  </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">c</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">t</span><span class="w"> </span><span class="o">*</span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">pb</span><span class="w"> </span><span class="o">=</span><span class="n">__builtin_preserve_access_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">b</span><span class="p">);</span>
<span class="n">__builtin_preserve_access_index</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">j</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="builtin-debugtrap">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_debugtrap</span></code><a class="headerlink" href="#builtin-debugtrap" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_debugtrap</span></code> causes the program to stop its execution in such a way that a debugger can catch it.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_debugtrap</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Description</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_debugtrap</span></code> is lowered to the ` <code class="docutils literal notranslate"><span class="pre">llvm.debugtrap</span></code> &lt;<a class="reference external" href="https://llvm.org/docs/LangRef.html#llvm-debugtrap-intrinsic">https://llvm.org/docs/LangRef.html#llvm-debugtrap-intrinsic</a>&gt;`_ builtin. It should have the same effect as setting a breakpoint on the line where the builtin is called.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_debugtrap)</span></code>.</p>
</section>
<section id="builtin-trap">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_trap</span></code><a class="headerlink" href="#builtin-trap" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_trap</span></code> causes the program to stop its execution abnormally.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_trap</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Description</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_trap</span></code> is lowered to the ` <code class="docutils literal notranslate"><span class="pre">llvm.trap</span></code> &lt;<a class="reference external" href="https://llvm.org/docs/LangRef.html#llvm-trap-intrinsic">https://llvm.org/docs/LangRef.html#llvm-trap-intrinsic</a>&gt;`_ builtin.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_trap)</span></code>.</p>
</section>
<section id="builtin-arm-trap">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_arm_trap</span></code><a class="headerlink" href="#builtin-arm-trap" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_arm_trap</span></code> is an AArch64 extension to <code class="docutils literal notranslate"><span class="pre">__builtin_trap</span></code> which also accepts a compile-time constant value, encoded directly into the trap instruction for later inspection.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_arm_trap</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">payload</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Description</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_arm_trap</span></code> is lowered to the <code class="docutils literal notranslate"><span class="pre">llvm.aarch64.break</span></code> builtin, and then to <code class="docutils literal notranslate"><span class="pre">brk</span> <span class="pre">#payload</span></code>.</p>
</section>
<section id="builtin-verbose-trap">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_verbose_trap</span></code><a class="headerlink" href="#builtin-verbose-trap" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_verbose_trap</span></code> causes the program to stop its execution abnormally
and shows a human-readable description of the reason for the termination when a
debugger is attached or in a symbolicated crash log.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__builtin_verbose_trap</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">category</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">reason</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Description</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_verbose_trap</span></code> is lowered to the ` <code class="docutils literal notranslate"><span class="pre">llvm.trap</span></code> &lt;<a class="reference external" href="https://llvm.org/docs/LangRef.html#llvm-trap-intrinsic">https://llvm.org/docs/LangRef.html#llvm-trap-intrinsic</a>&gt;`_ builtin.
Additionally, clang emits debugging information that represents an artificial
inline frame whose name encodes the category and reason strings passed to the builtin,
prefixed by a “magic” prefix.</p>
<p>For example, consider the following code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">    </span><span class="n">__builtin_verbose_trap</span><span class="p">(</span><span class="s">&quot;check null&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Argument must not be null!&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The debugging information would look as if it were produced for the following code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__attribute__</span><span class="p">((</span><span class="n">always_inline</span><span class="p">))</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="s">&quot;__clang_trap_msg$check null$Argument must not be null!&quot;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">__builtin_trap</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">    </span><span class="s">&quot;__clang_trap_msg$check null$Argument must not be null!&quot;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>However, the generated code would not actually contain a call to the artificial
function — it only exists in the debugging information.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_verbose_trap)</span></code>. Note that
users need to enable debug information to enable this feature. A call to this
builtin is equivalent to a call to <code class="docutils literal notranslate"><span class="pre">__builtin_trap</span></code> if debug information isn’t
enabled.</p>
<p>The optimizer can merge calls to trap with different messages, which degrades
the debugging experience.</p>
</section>
<section id="builtin-allow-runtime-check">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_allow_runtime_check</span></code><a class="headerlink" href="#builtin-allow-runtime-check" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_allow_runtime_check</span></code> returns true if the check at the current
program location should be executed. It is expected to be used to implement
<code class="docutils literal notranslate"><span class="pre">assert</span></code> like checks which can be safely removed by optimizer.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">__builtin_allow_runtime_check</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">kind</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Example of use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__builtin_allow_runtime_check</span><span class="p">(</span><span class="s">&quot;mycheck&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">ExpensiveCheck</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">abort</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Description</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_allow_runtime_check</span></code> is lowered to the <a class="reference external" href="https://llvm.org/docs/LangRef.html#llvm-allow-runtime-check-intrinsic">llvm.allow.runtime.check</a>
intrinsic.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__builtin_allow_runtime_check()</span></code> can be used within control structures
like <code class="docutils literal notranslate"><span class="pre">if</span></code> to guard expensive runtime checks. The return value is determined
by the following compiler options and may differ per call site:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-mllvm</span> <span class="pre">-lower-allow-check-percentile-cutoff-hot=N</span></code>: Disable checks in hot
code marked by the profile summary with a hotness cutoff in the range
<code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">999999]</span></code> (a larger N disables more checks).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-mllvm</span> <span class="pre">-lower-allow-check-random-rate=P</span></code>: Keep a check with probability P,
a floating point number in the range <code class="docutils literal notranslate"><span class="pre">[0.0,</span> <span class="pre">1.0]</span></code>.</p></li>
<li><p>If both options are specified, a check is disabled if either condition is satisfied.</p></li>
<li><p>If neither is specified, all checks are allowed.</p></li>
</ul>
<p>Parameter <code class="docutils literal notranslate"><span class="pre">kind</span></code>, currently unused, is a string literal specifying the check
kind. Future compiler versions may use this to allow for more granular control,
such as applying different hotness cutoffs to different check kinds.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_allow_runtime_check)</span></code>.</p>
</section>
<section id="builtin-nondeterministic-value">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_nondeterministic_value</span></code><a class="headerlink" href="#builtin-nondeterministic-value" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_nondeterministic_value</span></code> returns a valid nondeterministic value of the same type as the provided argument.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">type</span><span class="w"> </span><span class="n">__builtin_nondeterministic_value</span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Examples</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_nondeterministic_value</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_nondeterministic_value</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="n">__m256i</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_nondeterministic_value</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Description</strong></p>
<p>Each call to <code class="docutils literal notranslate"><span class="pre">__builtin_nondeterministic_value</span></code> returns a valid value of the type given by the argument.</p>
<p>The types currently supported are: integer types, floating-point types, vector types.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_nondeterministic_value)</span></code>.</p>
</section>
<section id="builtin-sycl-unique-stable-name">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_sycl_unique_stable_name</span></code><a class="headerlink" href="#builtin-sycl-unique-stable-name" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_sycl_unique_stable_name()</span></code> is a builtin that takes a type and
produces a string literal containing a unique name for the type that is stable
across split compilations, mainly to support SYCL/Data Parallel C++ language.</p>
<p>In cases where the split compilation needs to share a unique token for a type
across the boundary (such as in an offloading situation), this name can be used
for lookup purposes, such as in the SYCL Integration Header.</p>
<p>The value of this builtin is computed entirely at compile time, so it can be
used in constant expressions. This value encodes lambda functions based on a
stable numbering order in which they appear in their local declaration contexts.
Once this builtin is evaluated in a constexpr context, it is erroneous to use
it in an instantiation which changes its value.</p>
<p>In order to produce the unique name, the current implementation of the builtin
uses Itanium mangling even if the host compilation uses a different name
mangling scheme at runtime. The mangler marks all the lambdas required to name
the SYCL kernel and emits a stable local ordering of the respective lambdas.
The resulting pattern is demanglable.  When non-lambda types are passed to the
builtin, the mangler emits their usual pattern without any special treatment.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Computes a unique stable name for the given type.</span>
<span class="n">constexpr</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">__builtin_sycl_unique_stable_name</span><span class="p">(</span><span class="w"> </span><span class="n">type</span><span class="o">-</span><span class="n">id</span><span class="w"> </span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="builtin-popcountg">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_popcountg</span></code><a class="headerlink" href="#builtin-popcountg" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_popcountg</span></code> returns the number of 1 bits in the argument. The
argument can be of any unsigned integer type.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">__builtin_popcountg</span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Examples</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">x_pop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_popcountg</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">y_pop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_popcountg</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

<span class="kt">unsigned</span><span class="w"> </span><span class="nf">_BitInt</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">z_pop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_popcountg</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_popcountg</span></code> is meant to be a type-generic alternative to the
<code class="docutils literal notranslate"><span class="pre">__builtin_popcount{,l,ll}</span></code> builtins, with support for other integer types,
such as <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">__int128</span></code> and C23 <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">_BitInt(N)</span></code>.</p>
</section>
<section id="builtin-clzg-and-builtin-ctzg">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_clzg</span></code> and <code class="docutils literal notranslate"><span class="pre">__builtin_ctzg</span></code><a class="headerlink" href="#builtin-clzg-and-builtin-ctzg" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_clzg</span></code> (respectively <code class="docutils literal notranslate"><span class="pre">__builtin_ctzg</span></code>) returns the number of
leading (respectively trailing) 0 bits in the first argument. The first argument
can be of any unsigned integer type.</p>
<p>If the first argument is 0 and an optional second argument of <code class="docutils literal notranslate"><span class="pre">int</span></code> type is
provided, then the second argument is returned. If the first argument is 0, but
only one argument is provided, then the behavior is undefined.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">__builtin_clzg</span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="n">x</span><span class="p">[,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">fallback</span><span class="p">])</span>
<span class="kt">int</span><span class="w"> </span><span class="n">__builtin_ctzg</span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="n">x</span><span class="p">[,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">fallback</span><span class="p">])</span>
</pre></div>
</div>
<p><strong>Examples</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">x_lz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_clzg</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="n">x_tz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_ctzg</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">y_lz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_clzg</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="n">y_tz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_ctzg</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

<span class="kt">unsigned</span><span class="w"> </span><span class="nf">_BitInt</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">z_lz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_clzg</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="n">z_tz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_ctzg</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_clzg</span></code> (respectively <code class="docutils literal notranslate"><span class="pre">__builtin_ctzg</span></code>) is meant to be a
type-generic alternative to the <code class="docutils literal notranslate"><span class="pre">__builtin_clz{,l,ll}</span></code> (respectively
<code class="docutils literal notranslate"><span class="pre">__builtin_ctz{,l,ll}</span></code>) builtins, with support for other integer types, such
as <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">__int128</span></code> and C23 <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">_BitInt(N)</span></code>.</p>
</section>
<section id="builtin-counted-by-ref">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_counted_by_ref</span></code><a class="headerlink" href="#builtin-counted-by-ref" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_counted_by_ref</span></code> returns a pointer to the count field from the
<code class="docutils literal notranslate"><span class="pre">counted_by</span></code> attribute.</p>
<p>The argument must be a flexible array member. If the argument isn’t a flexible
array member or doesn’t have the <code class="docutils literal notranslate"><span class="pre">counted_by</span></code> attribute, the builtin returns
<code class="docutils literal notranslate"><span class="pre">(void</span> <span class="pre">*)0</span></code>.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">__builtin_counted_by_ref</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">array</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Examples</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define alloc(P, FAM, COUNT) ({                                 \</span>
<span class="cp">   size_t __ignored_assignment;                                 \</span>
<span class="cp">   typeof(P) __p = NULL;                                        \</span>
<span class="cp">   __p = malloc(MAX(sizeof(*__p),                               \</span>
<span class="cp">                    sizeof(*__p) + sizeof(*__p-&gt;FAM) * COUNT)); \</span>
<span class="cp">                                                                \</span>
<span class="cp">   *_Generic(                                                   \</span>
<span class="cp">     __builtin_counted_by_ref(__p-&gt;FAM),                        \</span>
<span class="cp">       void *: &amp;__ignored_assignment,                           \</span>
<span class="cp">       default: __builtin_counted_by_ref(__p-&gt;FAM)) = COUNT;    \</span>
<span class="cp">                                                                \</span>
<span class="cp">   __p;                                                         \</span>
<span class="cp">})</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__builtin_counted_by_ref</span></code> builtin allows the programmer to prevent a
common error associated with the <code class="docutils literal notranslate"><span class="pre">counted_by</span></code> attribute. When using the
<code class="docutils literal notranslate"><span class="pre">counted_by</span></code> attribute, the <code class="docutils literal notranslate"><span class="pre">count</span></code> field <strong>must</strong> be set before the
flexible array member can be accessed. Otherwise, the sanitizers may view such
accesses as false positives. For instance, it’s not uncommon for programmers to
initialize the flexible array before setting the <code class="docutils literal notranslate"><span class="pre">count</span></code> field:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">s</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">dummy</span><span class="p">;</span>
<span class="w">  </span><span class="kt">short</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="w">  </span><span class="kt">long</span><span class="w"> </span><span class="n">array</span><span class="p">[]</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">counted_by</span><span class="p">(</span><span class="n">count</span><span class="p">)));</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">s</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">s</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">COUNT</span><span class="p">);</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">COUNT</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">  </span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>

<span class="n">ptr</span><span class="o">-&gt;</span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">COUNT</span><span class="p">;</span>
</pre></div>
</div>
<p>Enforcing the rule that <code class="docutils literal notranslate"><span class="pre">ptr-&gt;count</span> <span class="pre">=</span> <span class="pre">COUNT;</span></code> must occur after every
allocation of a struct with a flexible array member with the <code class="docutils literal notranslate"><span class="pre">counted_by</span></code>
attribute is prone to failure in large code bases. This builtin mitigates this
for allocators (like in Linux) that are implemented in a way where the counter
assignment can happen automatically.</p>
<p><strong>Note:</strong> The value returned by <code class="docutils literal notranslate"><span class="pre">__builtin_counted_by_ref</span></code> cannot be assigned
to a variable, have its address taken, or passed into or returned from a
function, because doing so violates bounds safety conventions.</p>
</section>
<section id="multiprecision-arithmetic-builtins">
<h3>Multiprecision Arithmetic Builtins<a class="headerlink" href="#multiprecision-arithmetic-builtins" title="Link to this heading">¶</a></h3>
<p>Clang provides a set of builtins which expose multiprecision arithmetic in a
manner amenable to C. They all have the following form:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">carryin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">carryout</span><span class="p">;</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_addc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">carryout</span><span class="p">);</span>
</pre></div>
</div>
<p>Thus one can form a multiprecision addition chain in the following manner:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">carryin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">carryout</span><span class="p">;</span>
<span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_addc</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">carryout</span><span class="p">);</span>
<span class="n">carryin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">carryout</span><span class="p">;</span>
<span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_addc</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">carryout</span><span class="p">);</span>
<span class="n">carryin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">carryout</span><span class="p">;</span>
<span class="n">z</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_addc</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">carryout</span><span class="p">);</span>
<span class="n">carryin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">carryout</span><span class="p">;</span>
<span class="n">z</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_addc</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">carryout</span><span class="p">);</span>
</pre></div>
</div>
<p>The complete list of builtins are:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">      </span><span class="nf">__builtin_addcb</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">carryout</span><span class="p">);</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w">     </span><span class="nf">__builtin_addcs</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="o">*</span><span class="n">carryout</span><span class="p">);</span>
<span class="kt">unsigned</span><span class="w">           </span><span class="nf">__builtin_addc</span><span class="w">  </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="o">*</span><span class="n">carryout</span><span class="p">);</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">      </span><span class="nf">__builtin_addcl</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">carryout</span><span class="p">);</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">__builtin_addcll</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">carryout</span><span class="p">);</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">      </span><span class="nf">__builtin_subcb</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">carryout</span><span class="p">);</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w">     </span><span class="nf">__builtin_subcs</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="o">*</span><span class="n">carryout</span><span class="p">);</span>
<span class="kt">unsigned</span><span class="w">           </span><span class="nf">__builtin_subc</span><span class="w">  </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="o">*</span><span class="n">carryout</span><span class="p">);</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">      </span><span class="nf">__builtin_subcl</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">carryout</span><span class="p">);</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">__builtin_subcll</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">carryin</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">carryout</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="checked-arithmetic-builtins">
<h3>Checked Arithmetic Builtins<a class="headerlink" href="#checked-arithmetic-builtins" title="Link to this heading">¶</a></h3>
<p>Clang provides a set of builtins that implement checked arithmetic for security
critical applications in a manner that is fast and easily expressible in C. As
an example of their usage:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">errorcode_t</span><span class="w"> </span><span class="nf">security_critical_application</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__builtin_mul_overflow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">result</span><span class="p">))</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">kErrorCodeHackers</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">use_multiply</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Clang provides the following checked arithmetic builtins:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_add_overflow</span><span class="w">   </span><span class="p">(</span><span class="n">type1</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">type2</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">type3</span><span class="w"> </span><span class="o">*</span><span class="n">sum</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_sub_overflow</span><span class="w">   </span><span class="p">(</span><span class="n">type1</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">type2</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">type3</span><span class="w"> </span><span class="o">*</span><span class="n">diff</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_mul_overflow</span><span class="w">   </span><span class="p">(</span><span class="n">type1</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">type2</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">type3</span><span class="w"> </span><span class="o">*</span><span class="n">prod</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_uadd_overflow</span><span class="w">  </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="o">*</span><span class="n">sum</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_uaddl_overflow</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">sum</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_uaddll_overflow</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">sum</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_usub_overflow</span><span class="w">  </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="o">*</span><span class="n">diff</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_usubl_overflow</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">diff</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_usubll_overflow</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">diff</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_umul_overflow</span><span class="w">  </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="o">*</span><span class="n">prod</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_umull_overflow</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">prod</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_umulll_overflow</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">prod</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_sadd_overflow</span><span class="w">  </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">sum</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_saddl_overflow</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">sum</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_saddll_overflow</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">sum</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_ssub_overflow</span><span class="w">  </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">diff</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_ssubl_overflow</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">diff</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_ssubll_overflow</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">diff</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_smul_overflow</span><span class="w">  </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">prod</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_smull_overflow</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">prod</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_smulll_overflow</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">prod</span><span class="p">);</span>
</pre></div>
</div>
<p>Each builtin performs the specified mathematical operation on the
first two arguments and stores the result in the third argument.  If
possible, the result will be equal to mathematically-correct result
and the builtin will return 0.  Otherwise, the builtin will return
1 and the result will be equal to the unique value that is equivalent
to the mathematically-correct result modulo two raised to the <em>k</em>
power, where <em>k</em> is the number of bits in the result type.  The
behavior of these builtins is well-defined for all argument values.</p>
<p>The first three builtins work generically for operands of any integer type,
including boolean types.  The operands need not have the same type as each
other, or as the result.  The other builtins may implicitly promote or
convert their operands before performing the operation.</p>
<p>Query for this feature with <code class="docutils literal notranslate"><span class="pre">__has_builtin(__builtin_add_overflow)</span></code>, etc.</p>
</section>
<section id="floating-point-builtins">
<h3>Floating point builtins<a class="headerlink" href="#floating-point-builtins" title="Link to this heading">¶</a></h3>
</section>
<section id="builtin-isfpclass">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_isfpclass</span></code><a class="headerlink" href="#builtin-isfpclass" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_isfpclass</span></code> is used to test if the specified floating-point values
fall into one of the specified floating-point classes.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">__builtin_isfpclass</span><span class="p">(</span><span class="n">fp_type</span><span class="w"> </span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mask</span><span class="p">)</span>
<span class="n">int_vector</span><span class="w"> </span><span class="n">__builtin_isfpclass</span><span class="p">(</span><span class="n">fp_vector</span><span class="w"> </span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mask</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Example of use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__builtin_isfpclass</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">448</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="c1">// `x` is positive finite value</span>
<span class="w">       </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__builtin_isfpclass()</span></code> builtin is a generalization of functions <code class="docutils literal notranslate"><span class="pre">isnan</span></code>,
<code class="docutils literal notranslate"><span class="pre">isinf</span></code>, <code class="docutils literal notranslate"><span class="pre">isfinite</span></code> and some others defined by the C standard. It tests if
the floating-point value, specified by the first argument, falls into any of data
classes, specified by the second argument. The latter is an integer constant
bitmask expression, in which each data class is represented by a bit
using the encoding:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Mask value</p></th>
<th class="head"><p>Data class</p></th>
<th class="head"><p>Macro</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0001</p></td>
<td><p>Signaling NaN</p></td>
<td><p>__FPCLASS_SNAN</p></td>
</tr>
<tr class="row-odd"><td><p>0x0002</p></td>
<td><p>Quiet NaN</p></td>
<td><p>__FPCLASS_QNAN</p></td>
</tr>
<tr class="row-even"><td><p>0x0004</p></td>
<td><p>Negative infinity</p></td>
<td><p>__FPCLASS_NEGINF</p></td>
</tr>
<tr class="row-odd"><td><p>0x0008</p></td>
<td><p>Negative normal</p></td>
<td><p>__FPCLASS_NEGNORMAL</p></td>
</tr>
<tr class="row-even"><td><p>0x0010</p></td>
<td><p>Negative subnormal</p></td>
<td><p>__FPCLASS_NEGSUBNORMAL</p></td>
</tr>
<tr class="row-odd"><td><p>0x0020</p></td>
<td><p>Negative zero</p></td>
<td><p>__FPCLASS_NEGZERO</p></td>
</tr>
<tr class="row-even"><td><p>0x0040</p></td>
<td><p>Positive zero</p></td>
<td><p>__FPCLASS_POSZERO</p></td>
</tr>
<tr class="row-odd"><td><p>0x0080</p></td>
<td><p>Positive subnormal</p></td>
<td><p>__FPCLASS_POSSUBNORMAL</p></td>
</tr>
<tr class="row-even"><td><p>0x0100</p></td>
<td><p>Positive normal</p></td>
<td><p>__FPCLASS_POSNORMAL</p></td>
</tr>
<tr class="row-odd"><td><p>0x0200</p></td>
<td><p>Positive infinity</p></td>
<td><p>__FPCLASS_POSINF</p></td>
</tr>
</tbody>
</table>
<p>For convenience preprocessor defines macros for these values. The function
returns 1 if <code class="docutils literal notranslate"><span class="pre">expr</span></code> falls into one of the specified data classes, 0 otherwise.</p>
<p>In the example above the mask value 448 (0x1C0) contains the bits selecting
positive zero, positive subnormal and positive normal classes.
<code class="docutils literal notranslate"><span class="pre">__builtin_isfpclass(x,</span> <span class="pre">448)</span></code> would return true only if <code class="docutils literal notranslate"><span class="pre">x</span></code> if of any of
these data classes. Using suitable mask value, the function can implement any of
the standard classification functions, for example, <code class="docutils literal notranslate"><span class="pre">__builtin_isfpclass(x,</span> <span class="pre">3)</span></code>
is identical to <code class="docutils literal notranslate"><span class="pre">isnan</span></code>,``__builtin_isfpclass(x, 504)`` - to <code class="docutils literal notranslate"><span class="pre">isfinite</span></code>
and so on.</p>
<p>If the first argument is a vector, the function is equivalent to the set of
scalar calls of <code class="docutils literal notranslate"><span class="pre">__builtin_isfpclass</span></code> applied to the input elementwise.</p>
<p>The result of <code class="docutils literal notranslate"><span class="pre">__builtin_isfpclass</span></code> is a boolean value, if the first argument
is a scalar, or an integer vector with the same element count as the first
argument. The element type in this vector has the same bit length as the
element of the first argument type.</p>
<p>This function never raises floating-point exceptions and does not canonicalize
its input. The floating-point argument is not promoted, its data class is
determined based on its representation in its actual semantic type.</p>
</section>
<section id="builtin-canonicalize">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_canonicalize</span></code><a class="headerlink" href="#builtin-canonicalize" title="Link to this heading">¶</a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="nf">__builtin_canonicalize</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
<span class="kt">float</span><span class="w"> </span><span class="nf">__builtin_canonicalizef</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>
<span class="kt">long</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">__builtin_canonicalizel</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">double</span><span class="p">);</span>
</pre></div>
</div>
<p>Returns the platform specific canonical encoding of a floating point
number. This canonicalization is useful for implementing certain
numeric primitives such as frexp. See <a class="reference external" href="https://llvm.org/docs/LangRef.html#llvm-canonicalize-intrinsic">LLVM canonicalize intrinsic</a> for
more information on the semantics.</p>
</section>
<section id="builtin-flt-rounds-and-builtin-set-flt-rounds">
<h3><code class="docutils literal notranslate"><span class="pre">__builtin_flt_rounds</span></code> and <code class="docutils literal notranslate"><span class="pre">__builtin_set_flt_rounds</span></code><a class="headerlink" href="#builtin-flt-rounds-and-builtin-set-flt-rounds" title="Link to this heading">¶</a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">__builtin_flt_rounds</span><span class="p">();</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__builtin_set_flt_rounds</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</pre></div>
</div>
<p>Returns and sets current floating point rounding mode. The encoding of returned
values and input parameters is same as the result of FLT_ROUNDS, specified by C
standard:
- <code class="docutils literal notranslate"><span class="pre">0</span></code>  - toward zero
- <code class="docutils literal notranslate"><span class="pre">1</span></code>  - to nearest, ties to even
- <code class="docutils literal notranslate"><span class="pre">2</span></code>  - toward positive infinity
- <code class="docutils literal notranslate"><span class="pre">3</span></code>  - toward negative infinity
- <code class="docutils literal notranslate"><span class="pre">4</span></code>  - to nearest, ties away from zero
The effect of passing some other value to <code class="docutils literal notranslate"><span class="pre">__builtin_flt_rounds</span></code> is
implementation-defined. <code class="docutils literal notranslate"><span class="pre">__builtin_set_flt_rounds</span></code> is currently only supported
to work on x86, x86_64, powerpc, powerpc64, Arm and AArch64 targets. These builtins
read and modify the floating-point environment, which is not always allowed and may
have unexpected behavior. Please see the section on <a class="reference external" href="https://clang.llvm.org/docs/UsersManual.html#accessing-the-floating-point-environment">Accessing the floating point environment</a> for more information.</p>
</section>
<section id="string-builtins">
<h3>String builtins<a class="headerlink" href="#string-builtins" title="Link to this heading">¶</a></h3>
<p>Clang provides constant expression evaluation support for builtins forms of
the following functions from the C standard library headers
<code class="docutils literal notranslate"><span class="pre">&lt;string.h&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;wchar.h&gt;</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">memchr</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">memcmp</span></code> (and its deprecated BSD / POSIX alias <code class="docutils literal notranslate"><span class="pre">bcmp</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">strchr</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">strcmp</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">strlen</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">strncmp</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wcschr</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wcscmp</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wcslen</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wcsncmp</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wmemchr</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wmemcmp</span></code></p></li>
</ul>
<p>In each case, the builtin form has the name of the C library function prefixed
by <code class="docutils literal notranslate"><span class="pre">__builtin_</span></code>. Example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_memchr</span><span class="p">(</span><span class="s">&quot;foobar&quot;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;b&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
</pre></div>
</div>
<p>In addition to the above, one further builtin is provided:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">__builtin_char_memchr</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">haystack</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">needle</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_char_memchr(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> is identical to
<code class="docutils literal notranslate"><span class="pre">(char*)__builtin_memchr(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> except that its use is permitted within
constant expressions in C++11 onwards (where a cast from <code class="docutils literal notranslate"><span class="pre">void*</span></code> to <code class="docutils literal notranslate"><span class="pre">char*</span></code>
is disallowed in general).</p>
<p>Constant evaluation support for the <code class="docutils literal notranslate"><span class="pre">__builtin_mem*</span></code> functions is provided
only for arrays of <code class="docutils literal notranslate"><span class="pre">char</span></code>, <code class="docutils literal notranslate"><span class="pre">signed</span> <span class="pre">char</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code>, or <code class="docutils literal notranslate"><span class="pre">char8_t</span></code>,
despite these functions accepting an argument of type <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void*</span></code>.</p>
<p>Support for constant expression evaluation for the above builtins can be detected
with <code class="docutils literal notranslate"><span class="pre">__has_feature(cxx_constexpr_string_builtins)</span></code>.</p>
</section>
<section id="variadic-function-builtins">
<h3>Variadic function builtins<a class="headerlink" href="#variadic-function-builtins" title="Link to this heading">¶</a></h3>
<p>Clang provides several builtins for working with variadic functions from the C
standard library <code class="docutils literal notranslate"><span class="pre">&lt;stdarg.h&gt;</span></code> header:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_va_list</span></code></p></li>
</ul>
<p>A predefined typedef for the target-specific <code class="docutils literal notranslate"><span class="pre">va_list</span></code> type. It is undefined
behavior to use a byte-wise copy of this type produced by calling <code class="docutils literal notranslate"><span class="pre">memcpy</span></code>,
<code class="docutils literal notranslate"><span class="pre">memmove</span></code>, or similar. Valid explicit copies are only produced by calling
<code class="docutils literal notranslate"><span class="pre">va_copy</span></code> or <code class="docutils literal notranslate"><span class="pre">__builtin_va_copy</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__builtin_va_start(__builtin_va_list</span> <span class="pre">list,</span> <span class="pre">&lt;parameter-name&gt;)</span></code></p></li>
</ul>
<p>A builtin function for the target-specific <code class="docutils literal notranslate"><span class="pre">va_start</span></code> function-like macro.
The <code class="docutils literal notranslate"><span class="pre">parameter-name</span></code> argument is the name of the parameter preceding the
ellipsis (<code class="docutils literal notranslate"><span class="pre">...</span></code>) in the function signature. Alternatively, in C23 mode or
later, it may be the integer literal <code class="docutils literal notranslate"><span class="pre">0</span></code> if there is no parameter preceding
the ellipsis. This function initializes the given <code class="docutils literal notranslate"><span class="pre">__builtin_va_list</span></code> object.
It is undefined behavior to call this function on an already initialized
<code class="docutils literal notranslate"><span class="pre">__builtin_va_list</span></code> object.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__builtin_c23_va_start(__builtin_va_list</span> <span class="pre">list,</span> <span class="pre">...)</span></code></p></li>
</ul>
<p>A builtin function for the target-specific <code class="docutils literal notranslate"><span class="pre">va_start</span></code> function-like macro,
available only in C23 and later. The builtin accepts zero or one argument for
the ellipsis (<code class="docutils literal notranslate"><span class="pre">...</span></code>). If such an argument is provided, it should be the name
of the parameter preceding the ellipsis, which is used for compatibility with
C versions before C23. It is an error to provide two or more variadic arguments.
This function initializes the given <code class="docutils literal notranslate"><span class="pre">__builtin_va_list</span></code> object. It is
undefined behavior to call this function on an already initialized
<code class="docutils literal notranslate"><span class="pre">__builtin_va_list</span></code> object.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__builtin_va_end(__builtin_va_list</span> <span class="pre">list)</span></code></p></li>
</ul>
<p>A builtin function for the target-specific <code class="docutils literal notranslate"><span class="pre">va_end</span></code> function-like macro. This
function finalizes the given <code class="docutils literal notranslate"><span class="pre">__builtin_va_list</span></code> object such that it is no
longer usable unless re-initialized with a call to <code class="docutils literal notranslate"><span class="pre">__builtin_va_start</span></code> or
<code class="docutils literal notranslate"><span class="pre">__builtin_va_copy</span></code>. It is undefined behavior to call this function with a
<code class="docutils literal notranslate"><span class="pre">list</span></code> that has not been initialized by either <code class="docutils literal notranslate"><span class="pre">__builtin_va_start</span></code> or
<code class="docutils literal notranslate"><span class="pre">__builtin_va_copy</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;type-name&gt;</span> <span class="pre">__builtin_va_arg(__builtin_va_list</span> <span class="pre">list,</span> <span class="pre">&lt;type-name&gt;)</span></code></p></li>
</ul>
<p>A builtin function for the target-specific <code class="docutils literal notranslate"><span class="pre">va_arg</span></code> function-like macro. This
function returns the value of the next variadic argument to the call. It is
undefined behavior to call this builtin when there is no next variadic argument
to retrieve or if the next variadic argument does not have a type compatible
with the given <code class="docutils literal notranslate"><span class="pre">type-name</span></code>. The return type of the function is the
<code class="docutils literal notranslate"><span class="pre">type-name</span></code> given as the second argument. It is undefined behavior to call
this function with a <code class="docutils literal notranslate"><span class="pre">list</span></code> that has not been initialized by either
<code class="docutils literal notranslate"><span class="pre">__builtin_va_start</span></code> or <code class="docutils literal notranslate"><span class="pre">__builtin_va_copy</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">__builtin_va_copy(__builtin_va_list</span> <span class="pre">dest,</span> <span class="pre">__builtin_va_list</span> <span class="pre">src)</span></code></p></li>
</ul>
<p>A builtin function for the target-specific <code class="docutils literal notranslate"><span class="pre">va_copy</span></code> function-like macro.
This function initializes <code class="docutils literal notranslate"><span class="pre">dest</span></code> as a copy of <code class="docutils literal notranslate"><span class="pre">src</span></code>. It is undefined
behavior to call this function with an already initialized <code class="docutils literal notranslate"><span class="pre">dest</span></code> argument.</p>
</section>
<section id="memory-builtins">
<h3>Memory builtins<a class="headerlink" href="#memory-builtins" title="Link to this heading">¶</a></h3>
<p>Clang provides constant expression evaluation support for builtin forms of the
following functions from the C standard library headers
<code class="docutils literal notranslate"><span class="pre">&lt;string.h&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;wchar.h&gt;</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">memcpy</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">memmove</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wmemcpy</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">wmemmove</span></code></p></li>
</ul>
<p>In each case, the builtin form has the name of the C library function prefixed
by <code class="docutils literal notranslate"><span class="pre">__builtin_</span></code>.</p>
<p>Constant evaluation support is only provided when the source and destination
are pointers to arrays with the same trivially copyable element type, and the
given size is an exact multiple of the element size that is no greater than
the number of elements accessible through the source and destination operands.</p>
<section id="guaranteed-inlined-copy">
<h4>Guaranteed inlined copy<a class="headerlink" href="#guaranteed-inlined-copy" title="Link to this heading">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">__builtin_memcpy_inline</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_memcpy_inline</span></code> has been designed as a building block for efficient
<code class="docutils literal notranslate"><span class="pre">memcpy</span></code> implementations. It is identical to <code class="docutils literal notranslate"><span class="pre">__builtin_memcpy</span></code> but also
guarantees not to call any external functions. See LLVM IR <a class="reference external" href="https://llvm.org/docs/LangRef.html#llvm-memcpy-inline-intrinsic">llvm.memcpy.inline</a> intrinsic
for more information.</p>
<p>This is useful to implement a custom version of <code class="docutils literal notranslate"><span class="pre">memcpy</span></code>, implement a
<code class="docutils literal notranslate"><span class="pre">libc</span></code> memcpy or work around the absence of a <code class="docutils literal notranslate"><span class="pre">libc</span></code>.</p>
<p>Note that the <cite>size</cite> argument must be a compile time constant.</p>
<p>Note that this intrinsic cannot yet be called in a <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> context.</p>
</section>
<section id="guaranteed-inlined-memset">
<h4>Guaranteed inlined memset<a class="headerlink" href="#guaranteed-inlined-memset" title="Link to this heading">¶</a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">__builtin_memset_inline</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_memset_inline</span></code> has been designed as a building block for efficient
<code class="docutils literal notranslate"><span class="pre">memset</span></code> implementations. It is identical to <code class="docutils literal notranslate"><span class="pre">__builtin_memset</span></code> but also
guarantees not to call any external functions. See LLVM IR <a class="reference external" href="https://llvm.org/docs/LangRef.html#llvm-memset-inline-intrinsic">llvm.memset.inline</a> intrinsic
for more information.</p>
<p>This is useful to implement a custom version of <code class="docutils literal notranslate"><span class="pre">memset</span></code>, implement a
<code class="docutils literal notranslate"><span class="pre">libc</span></code> memset or work around the absence of a <code class="docutils literal notranslate"><span class="pre">libc</span></code>.</p>
<p>Note that the <cite>size</cite> argument must be a compile time constant.</p>
<p>Note that this intrinsic cannot yet be called in a <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> context.</p>
</section>
</section>
<section id="is-bitwise-cloneable">
<h3><code class="docutils literal notranslate"><span class="pre">__is_bitwise_cloneable</span></code><a class="headerlink" href="#is-bitwise-cloneable" title="Link to this heading">¶</a></h3>
<p>A type trait is used to check whether a type can be safely copied by memcpy.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">__is_bitwise_cloneable</span><span class="p">(</span><span class="n">Type</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>Objects of bitwise cloneable types can be bitwise copied by memcpy/memmove. The
Clang compiler warrants that this behavior is well defined, and won’t be
broken by compiler optimizations and sanitizers.</p>
<p>For implicit-lifetime types, the lifetime of the new object is implicitly
started after the copy. For other types (e.g., classes with virtual methods),
the lifetime isn’t started, and using the object results in undefined behavior
according to the C++ Standard.</p>
<p>This builtin can be used in constant expressions.</p>
</section>
<section id="atomic-min-max-builtins-with-memory-ordering">
<h3>Atomic Min/Max builtins with memory ordering<a class="headerlink" href="#atomic-min-max-builtins-with-memory-ordering" title="Link to this heading">¶</a></h3>
<p>There are two atomic builtins with min/max in-memory comparison and swap.
The syntax and semantics are similar to GCC-compatible __atomic_* builtins.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__atomic_fetch_min</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__atomic_fetch_max</span></code></p></li>
</ul>
<p>The builtins work with signed and unsigned integers and require to specify memory ordering.
The return value is the original value that was stored in memory before comparison.</p>
<p>Example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__atomic_fetch_min</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">pi</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ui</span><span class="p">,</span><span class="w"> </span><span class="n">__ATOMIC_RELAXED</span><span class="p">);</span>
</pre></div>
</div>
<p>The third argument is one of the memory ordering specifiers <code class="docutils literal notranslate"><span class="pre">__ATOMIC_RELAXED</span></code>,
<code class="docutils literal notranslate"><span class="pre">__ATOMIC_CONSUME</span></code>, <code class="docutils literal notranslate"><span class="pre">__ATOMIC_ACQUIRE</span></code>, <code class="docutils literal notranslate"><span class="pre">__ATOMIC_RELEASE</span></code>,
<code class="docutils literal notranslate"><span class="pre">__ATOMIC_ACQ_REL</span></code>, or <code class="docutils literal notranslate"><span class="pre">__ATOMIC_SEQ_CST</span></code> following C++11 memory model semantics.</p>
<p>In terms of acquire-release ordering barriers these two operations are always
considered as operations with <em>load-store</em> semantics, even when the original value
is not actually modified after comparison.</p>
</section>
<section id="c11-atomic-builtins">
<span id="langext-c11-atomic"></span><h3>__c11_atomic builtins<a class="headerlink" href="#c11-atomic-builtins" title="Link to this heading">¶</a></h3>
<p>Clang provides a set of builtins which are intended to be used to implement
C11’s <code class="docutils literal notranslate"><span class="pre">&lt;stdatomic.h&gt;</span></code> header.  These builtins provide the semantics of the
<code class="docutils literal notranslate"><span class="pre">_explicit</span></code> form of the corresponding C11 operation, and are named with a
<code class="docutils literal notranslate"><span class="pre">__c11_</span></code> prefix.  The supported operations, and the differences from
the corresponding C11 operations, are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_init</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_thread_fence</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_signal_fence</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_is_lock_free</span></code> (The argument is the size of the
<code class="docutils literal notranslate"><span class="pre">_Atomic(...)</span></code> object, instead of its address)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_store</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_load</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_exchange</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_compare_exchange_strong</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_compare_exchange_weak</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_fetch_add</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_fetch_sub</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_fetch_and</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_fetch_or</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_fetch_xor</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_fetch_nand</span></code> (Nand is not presented in <code class="docutils literal notranslate"><span class="pre">&lt;stdatomic.h&gt;</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_fetch_max</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__c11_atomic_fetch_min</span></code></p></li>
</ul>
<p>The macros <code class="docutils literal notranslate"><span class="pre">__ATOMIC_RELAXED</span></code>, <code class="docutils literal notranslate"><span class="pre">__ATOMIC_CONSUME</span></code>, <code class="docutils literal notranslate"><span class="pre">__ATOMIC_ACQUIRE</span></code>,
<code class="docutils literal notranslate"><span class="pre">__ATOMIC_RELEASE</span></code>, <code class="docutils literal notranslate"><span class="pre">__ATOMIC_ACQ_REL</span></code>, and <code class="docutils literal notranslate"><span class="pre">__ATOMIC_SEQ_CST</span></code> are
provided, with values corresponding to the enumerators of C11’s
<code class="docutils literal notranslate"><span class="pre">memory_order</span></code> enumeration.</p>
<p>(Note that Clang additionally provides GCC-compatible <code class="docutils literal notranslate"><span class="pre">__atomic_*</span></code>
builtins and OpenCL 2.0 <code class="docutils literal notranslate"><span class="pre">__opencl_atomic_*</span></code> builtins. The OpenCL 2.0
atomic builtins are an explicit form of the corresponding OpenCL 2.0
builtin function, and are named with a <code class="docutils literal notranslate"><span class="pre">__opencl_</span></code> prefix. The macros
<code class="docutils literal notranslate"><span class="pre">__OPENCL_MEMORY_SCOPE_WORK_ITEM</span></code>, <code class="docutils literal notranslate"><span class="pre">__OPENCL_MEMORY_SCOPE_WORK_GROUP</span></code>,
<code class="docutils literal notranslate"><span class="pre">__OPENCL_MEMORY_SCOPE_DEVICE</span></code>, <code class="docutils literal notranslate"><span class="pre">__OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES</span></code>,
and <code class="docutils literal notranslate"><span class="pre">__OPENCL_MEMORY_SCOPE_SUB_GROUP</span></code> are provided, with values
corresponding to the enumerators of OpenCL’s <code class="docutils literal notranslate"><span class="pre">memory_scope</span></code> enumeration.)</p>
</section>
<section id="scoped-atomic-builtins">
<h3>__scoped_atomic builtins<a class="headerlink" href="#scoped-atomic-builtins" title="Link to this heading">¶</a></h3>
<p>Clang provides a set of atomics taking a memory scope argument. These atomics
are identical to the standard GNU / GCC atomic builtins but taking an extra
memory scope argument. These are designed to be a generic alternative to the
<code class="docutils literal notranslate"><span class="pre">__opencl_atomic_*</span></code> builtin functions for targets that support atomic memory
scopes.</p>
<p>Atomic memory scopes are designed to assist optimizations for systems with
several levels of memory hierarchy like GPUs. The following memory scopes are
currently supported:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__MEMORY_SCOPE_SYSTEM</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__MEMORY_SCOPE_DEVICE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__MEMORY_SCOPE_WRKGRP</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__MEMORY_SCOPE_WVFRNT</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__MEMORY_SCOPE_SINGLE</span></code></p></li>
</ul>
<p>This controls whether or not the atomic operation is ordered with respect to the
whole system, the current device, an OpenCL workgroup, wavefront, or just a
single thread. If these are used on a target that does not support atomic
scopes, then they will behave exactly as the standard GNU atomic builtins.</p>
</section>
<section id="low-level-arm-exclusive-memory-builtins">
<h3>Low-level ARM exclusive memory builtins<a class="headerlink" href="#low-level-arm-exclusive-memory-builtins" title="Link to this heading">¶</a></h3>
<p>Clang provides overloaded builtins giving direct access to the three key ARM
instructions for implementing atomic operations.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="w"> </span><span class="nf">__builtin_arm_ldrex</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="n">T</span><span class="w"> </span><span class="nf">__builtin_arm_ldaex</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">__builtin_arm_strex</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">__builtin_arm_stlex</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__builtin_arm_clrex</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p>The types <code class="docutils literal notranslate"><span class="pre">T</span></code> currently supported are:</p>
<ul class="simple">
<li><p>Integer types with width at most 64 bits (or 128 bits on AArch64).</p></li>
<li><p>Floating-point types</p></li>
<li><p>Pointer types.</p></li>
</ul>
<p>Note that the compiler does not guarantee it will not insert stores which clear
the exclusive monitor in between an <code class="docutils literal notranslate"><span class="pre">ldrex</span></code> type operation and its paired
<code class="docutils literal notranslate"><span class="pre">strex</span></code>. In practice this is only usually a risk when the extra store is on
the same cache line as the variable being modified and Clang will only insert
stack stores on its own, so it is best not to use these operations on variables
with automatic storage duration.</p>
<p>Also, loads and stores may be implicit in code written between the <code class="docutils literal notranslate"><span class="pre">ldrex</span></code> and
<code class="docutils literal notranslate"><span class="pre">strex</span></code>. Clang will not necessarily mitigate the effects of these either, so
care should be exercised.</p>
<p>For these reasons the higher level atomic primitives should be preferred where
possible.</p>
</section>
<section id="non-temporal-load-store-builtins">
<h3>Non-temporal load/store builtins<a class="headerlink" href="#non-temporal-load-store-builtins" title="Link to this heading">¶</a></h3>
<p>Clang provides overloaded builtins allowing generation of non-temporal memory
accesses.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="w"> </span><span class="nf">__builtin_nontemporal_load</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__builtin_nontemporal_store</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">);</span>
</pre></div>
</div>
<p>The types <code class="docutils literal notranslate"><span class="pre">T</span></code> currently supported are:</p>
<ul class="simple">
<li><p>Integer types.</p></li>
<li><p>Floating-point types.</p></li>
<li><p>Vector types.</p></li>
</ul>
<p>Note that the compiler does not guarantee that non-temporal loads or stores
will be used.</p>
</section>
<section id="c-coroutines-support-builtins">
<h3>C++ Coroutines support builtins<a class="headerlink" href="#c-coroutines-support-builtins" title="Link to this heading">¶</a></h3>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is a work in progress. Compatibility across Clang/LLVM releases is not
guaranteed.</p>
</div>
<p>Clang provides experimental builtins to support C++ Coroutines as defined by
<a class="reference external" href="https://wg21.link/P0057">https://wg21.link/P0057</a>. The following four are intended to be used by the
standard library to implement the <code class="docutils literal notranslate"><span class="pre">std::coroutine_handle</span></code> type.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w">  </span><span class="nf">__builtin_coro_resume</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">void</span><span class="w">  </span><span class="nf">__builtin_coro_destroy</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">bool</span><span class="w">  </span><span class="nf">__builtin_coro_done</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">__builtin_coro_promise</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">alignment</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">from_promise</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Example of use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">resume</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">__builtin_coro_resume</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">destroy</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">__builtin_coro_destroy</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">done</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">__builtin_coro_done</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="k">protected</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Promise</span><span class="o">&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">coroutine_handle</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="w">  </span><span class="n">Promise</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">promise</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Promise</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span>
<span class="w">      </span><span class="n">__builtin_coro_promise</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="k">alignof</span><span class="p">(</span><span class="n">Promise</span><span class="p">),</span><span class="w"> </span><span class="cm">/*from-promise=*/</span><span class="nb">false</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">coroutine_handle</span><span class="w"> </span><span class="nf">from_promise</span><span class="p">(</span><span class="n">Promise</span><span class="w"> </span><span class="o">&amp;</span><span class="n">promise</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">coroutine_handle</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="n">p</span><span class="p">.</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_coro_promise</span><span class="p">(</span><span class="o">&amp;</span><span class="n">promise</span><span class="p">,</span><span class="w"> </span><span class="k">alignof</span><span class="p">(</span><span class="n">Promise</span><span class="p">),</span>
<span class="w">                                                    </span><span class="cm">/*from-promise=*/</span><span class="nb">true</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Other coroutine builtins are either for internal clang use or for use during
development of the coroutine feature. See <a class="reference external" href="https://llvm.org/docs/Coroutines.html#intrinsics">Coroutines in LLVM</a> for
more information on their semantics. Note that builtins matching the intrinsics
that take token as the first parameter (llvm.coro.begin, llvm.coro.alloc,
llvm.coro.free and llvm.coro.suspend) omit the token parameter and fill it to
an appropriate value during the emission.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">size_t</span><span class="w"> </span><span class="n">__builtin_coro_size</span><span class="p">()</span>
<span class="kt">void</span><span class="w">  </span><span class="o">*</span><span class="n">__builtin_coro_frame</span><span class="p">()</span>
<span class="kt">void</span><span class="w">  </span><span class="o">*</span><span class="n">__builtin_coro_free</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">coro_frame</span><span class="p">)</span>

<span class="kt">void</span><span class="w">  </span><span class="o">*</span><span class="n">__builtin_coro_id</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">align</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">promise</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">fnaddr</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">parts</span><span class="p">)</span>
<span class="kt">bool</span><span class="w">   </span><span class="n">__builtin_coro_alloc</span><span class="p">()</span>
<span class="kt">void</span><span class="w">  </span><span class="o">*</span><span class="n">__builtin_coro_begin</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">memory</span><span class="p">)</span>
<span class="kt">void</span><span class="w">   </span><span class="n">__builtin_coro_end</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">coro_frame</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">unwind</span><span class="p">)</span>
<span class="kt">char</span><span class="w">   </span><span class="n">__builtin_coro_suspend</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">final</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that there is no builtin matching the <cite>llvm.coro.save</cite> intrinsic. LLVM
automatically will insert one if the first argument to <cite>llvm.coro.suspend</cite> is
token <cite>none</cite>. If a user calls <cite>__builtin_suspend</cite>, clang will insert <cite>token none</cite>
as the first argument to the intrinsic.</p>
</section>
<section id="source-location-builtins">
<h3>Source location builtins<a class="headerlink" href="#source-location-builtins" title="Link to this heading">¶</a></h3>
<p>Clang provides builtins to support C++ standard library implementation
of <code class="docutils literal notranslate"><span class="pre">std::source_location</span></code> as specified in C++20.  With the exception
of <code class="docutils literal notranslate"><span class="pre">__builtin_COLUMN</span></code>, <code class="docutils literal notranslate"><span class="pre">__builtin_FILE_NAME</span></code> and <code class="docutils literal notranslate"><span class="pre">__builtin_FUNCSIG</span></code>,
these builtins are also implemented by GCC.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">__builtin_FILE</span><span class="p">();</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">__builtin_FILE_NAME</span><span class="p">();</span><span class="w"> </span><span class="c1">// Clang only</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">__builtin_FUNCTION</span><span class="p">();</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">__builtin_FUNCSIG</span><span class="p">();</span><span class="w"> </span><span class="c1">// Microsoft</span>
<span class="kt">unsigned</span><span class="w">    </span><span class="nf">__builtin_LINE</span><span class="p">();</span>
<span class="kt">unsigned</span><span class="w">    </span><span class="nf">__builtin_COLUMN</span><span class="p">();</span><span class="w"> </span><span class="c1">// Clang only</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">source_location</span><span class="o">::</span><span class="n">__impl</span><span class="w"> </span><span class="o">*</span><span class="nf">__builtin_source_location</span><span class="p">();</span>
</pre></div>
</div>
<p><strong>Example of use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">my_assert</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">pred</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_LINE</span><span class="p">(),</span><span class="w"> </span><span class="c1">// Captures line of caller</span>
<span class="w">               </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_FILE</span><span class="p">(),</span>
<span class="w">               </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_FUNCTION</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pred</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s:%d assertion failed in function %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="n">function</span><span class="p">);</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">abort</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">MyAggregateType</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_LINE</span><span class="p">();</span><span class="w"> </span><span class="c1">// captures line where aggregate initialization occurs</span>
<span class="p">};</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">MyAggregateType</span><span class="p">{</span><span class="mi">42</span><span class="p">}.</span><span class="n">line</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">__LINE__</span><span class="p">);</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">MyClassType</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_LINE</span><span class="p">();</span><span class="w"> </span><span class="c1">// captures line of the constructor used during initialization</span>
<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="n">MyClassType</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">assert</span><span class="p">(</span><span class="n">line</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">__LINE__</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The builtins <code class="docutils literal notranslate"><span class="pre">__builtin_LINE</span></code>, <code class="docutils literal notranslate"><span class="pre">__builtin_FUNCTION</span></code>, <code class="docutils literal notranslate"><span class="pre">__builtin_FUNCSIG</span></code>,
<code class="docutils literal notranslate"><span class="pre">__builtin_FILE</span></code> and <code class="docutils literal notranslate"><span class="pre">__builtin_FILE_NAME</span></code> return the values, at the
“invocation point”, for <code class="docutils literal notranslate"><span class="pre">__LINE__</span></code>, <code class="docutils literal notranslate"><span class="pre">__FUNCTION__</span></code>, <code class="docutils literal notranslate"><span class="pre">__FUNCSIG__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__FILE__</span></code> and <code class="docutils literal notranslate"><span class="pre">__FILE_NAME__</span></code> respectively. <code class="docutils literal notranslate"><span class="pre">__builtin_COLUMN</span></code> similarly
returns the column, though there is no corresponding macro. These builtins are
constant expressions.</p>
<p>When the builtins appear as part of a default function argument the invocation
point is the location of the caller. When the builtins appear as part of a
default member initializer, the invocation point is the location of the
constructor or aggregate initialization used to create the object. Otherwise
the invocation point is the same as the location of the builtin.</p>
<p>When the invocation point of <code class="docutils literal notranslate"><span class="pre">__builtin_FUNCTION</span></code> is not a function scope, the
empty string is returned.</p>
<p>The builtin <code class="docutils literal notranslate"><span class="pre">__builtin_COLUMN</span></code> returns the offset from the start of the line,
beginning from column 1. <a class="reference external" href="https://eel.is/c++draft/support.srcloc#tab:support.srcloc.current-row-3-column-2-sentence-2">This may differ from other implementations.</a></p>
<p>The builtin <code class="docutils literal notranslate"><span class="pre">__builtin_source_location</span></code> returns a pointer to constant static
data of type <code class="docutils literal notranslate"><span class="pre">std::source_location::__impl</span></code>. This type must have already been
defined, and must contain exactly four fields: <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*_M_file_name</span></code>,
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*_M_function_name</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;any-integral-type&gt;</span> <span class="pre">_M_line</span></code>, and
<code class="docutils literal notranslate"><span class="pre">&lt;any-integral-type&gt;</span> <span class="pre">_M_column</span></code>. The fields will be populated in the same
manner as the above four builtins, except that <code class="docutils literal notranslate"><span class="pre">_M_function_name</span></code> is populated
with <code class="docutils literal notranslate"><span class="pre">__PRETTY_FUNCTION__</span></code> rather than <code class="docutils literal notranslate"><span class="pre">__FUNCTION__</span></code>.</p>
</section>
<section id="alignment-builtins">
<h3>Alignment builtins<a class="headerlink" href="#alignment-builtins" title="Link to this heading">¶</a></h3>
<p>Clang provides builtins to support checking and adjusting alignment of
pointers and integers.
These builtins can be used to avoid relying on implementation-defined behavior
of arithmetic on integers derived from pointers.
Additionally, these builtins retain type information and, unlike bitwise
arithmetic, they can perform semantic checking on the alignment value.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Type</span><span class="w"> </span><span class="nf">__builtin_align_up</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">alignment</span><span class="p">);</span>
<span class="n">Type</span><span class="w"> </span><span class="nf">__builtin_align_down</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">alignment</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">__builtin_is_aligned</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">alignment</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Example of use</strong>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">global_alloc_buffer</span><span class="p">;</span>
<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">my_aligned_allocator</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">alloc_size</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">alignment</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_align_up</span><span class="p">(</span><span class="n">global_alloc_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">alignment</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// result now contains the value of global_alloc_buffer rounded up to the</span>
<span class="w">  </span><span class="c1">// next multiple of alignment.</span>
<span class="w">  </span><span class="n">global_alloc_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">alloc_size</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">get_start_of_page</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">__builtin_align_down</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">example</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__builtin_is_aligned</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">do_fast_aligned_copy</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">do_unaligned_copy</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// In addition to pointers, the builtins can also be used on integer types</span>
<span class="c1">// and are evaluatable inside constant expressions.</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">__builtin_align_up</span><span class="p">(</span><span class="mi">123</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">__builtin_align_down</span><span class="p">(</span><span class="mi">123u</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">64u</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">__builtin_is_aligned</span><span class="p">(</span><span class="mi">123</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Description</strong>:</p>
<p>The builtins <code class="docutils literal notranslate"><span class="pre">__builtin_align_up</span></code>, <code class="docutils literal notranslate"><span class="pre">__builtin_align_down</span></code>, return their
first argument aligned up/down to the next multiple of the second argument.
If the value is already sufficiently aligned, it is returned unchanged.
The builtin <code class="docutils literal notranslate"><span class="pre">__builtin_is_aligned</span></code> returns whether the first argument is
aligned to a multiple of the second argument.
All of these builtins expect the alignment to be expressed as a number of bytes.</p>
<p>These builtins can be used for all integer types as well as (non-function)
pointer types. For pointer types, these builtins operate in terms of the integer
address of the pointer and return a new pointer of the same type (including
qualifiers such as <code class="docutils literal notranslate"><span class="pre">const</span></code>) with an adjusted address.
When aligning pointers up or down, the resulting value must be within the same
underlying allocation or one past the end (see C17 6.5.6p8, C++ [expr.add]).
This means that arbitrary integer values stored in pointer-type variables must
not be passed to these builtins. For those use cases, the builtins can still be
used, but the operation must be performed on the pointer cast to <code class="docutils literal notranslate"><span class="pre">uintptr_t</span></code>.</p>
<p>If Clang can determine that the alignment is not a power of two at compile time,
it will result in a compilation failure. If the alignment argument is not a
power of two at run time, the behavior of these builtins is undefined.</p>
</section>
</section>
<section id="non-standard-c-11-attributes">
<h2><a class="toc-backref" href="#id44" role="doc-backlink">Non-standard C++11 Attributes</a><a class="headerlink" href="#non-standard-c-11-attributes" title="Link to this heading">¶</a></h2>
<p>Clang’s non-standard C++11 attributes live in the <code class="docutils literal notranslate"><span class="pre">clang</span></code> attribute
namespace.</p>
<p>Clang supports GCC’s <code class="docutils literal notranslate"><span class="pre">gnu</span></code> attribute namespace. All GCC attributes which
are accepted with the <code class="docutils literal notranslate"><span class="pre">__attribute__((foo))</span></code> syntax are also accepted as
<code class="docutils literal notranslate"><span class="pre">[[gnu::foo]]</span></code>. This only extends to attributes which are specified by GCC
(see the list of <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html">GCC function attributes</a>, <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/Variable-Attributes.html">GCC variable
attributes</a>, and
<a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html">GCC type attributes</a>). As with the GCC
implementation, these attributes must appertain to the <em>declarator-id</em> in a
declaration, which means they must go either at the start of the declaration or
immediately after the name being declared.</p>
<p>For example, this applies the GNU <code class="docutils literal notranslate"><span class="pre">unused</span></code> attribute to <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">f</span></code>, and
also applies the GNU <code class="docutils literal notranslate"><span class="pre">noreturn</span></code> attribute to <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
<p>Examples:
.. code-block:: c++</p>
<blockquote>
<div><p>[[gnu::unused]] int a, f [[gnu::noreturn]] ();</p>
</div></blockquote>
</section>
<section id="target-specific-extensions">
<h2><a class="toc-backref" href="#id45" role="doc-backlink">Target-Specific Extensions</a><a class="headerlink" href="#target-specific-extensions" title="Link to this heading">¶</a></h2>
<p>Clang supports some language features conditionally on some targets.</p>
<section id="amdgpu-language-extensions">
<h3>AMDGPU Language Extensions<a class="headerlink" href="#amdgpu-language-extensions" title="Link to this heading">¶</a></h3>
<section id="builtin-amdgcn-fence">
<h4>__builtin_amdgcn_fence<a class="headerlink" href="#builtin-amdgcn-fence" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_amdgcn_fence</span></code> emits a fence.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">unsigned</span></code> atomic ordering, e.g. <code class="docutils literal notranslate"><span class="pre">__ATOMIC_ACQUIRE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code> synchronization scope, e.g. <code class="docutils literal notranslate"><span class="pre">workgroup</span></code></p></li>
<li><p>Zero or more <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code> address spaces names.</p></li>
</ul>
<p>The address spaces arguments must be one of the following string literals:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;local&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;global&quot;</span></code></p></li>
</ul>
<p>If one or more address space name are provided, the code generator will attempt
to emit potentially faster instructions that order access to at least those
address spaces.
Emitting such instructions may not always be possible and the compiler is free
to fence more aggressively.</p>
<p>If no address spaces names are provided, all address spaces are fenced.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Fence all address spaces.</span>
<span class="n">__builtin_amdgcn_fence</span><span class="p">(</span><span class="n">__ATOMIC_SEQ_CST</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;workgroup&quot;</span><span class="p">);</span>
<span class="n">__builtin_amdgcn_fence</span><span class="p">(</span><span class="n">__ATOMIC_ACQUIRE</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;agent&quot;</span><span class="p">);</span>

<span class="c1">// Fence only requested address spaces.</span>
<span class="n">__builtin_amdgcn_fence</span><span class="p">(</span><span class="n">__ATOMIC_SEQ_CST</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;workgroup&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;local&quot;</span><span class="p">)</span>
<span class="n">__builtin_amdgcn_fence</span><span class="p">(</span><span class="n">__ATOMIC_SEQ_CST</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;workgroup&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;local&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;global&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="arm-aarch64-language-extensions">
<h3>ARM/AArch64 Language Extensions<a class="headerlink" href="#arm-aarch64-language-extensions" title="Link to this heading">¶</a></h3>
<section id="memory-barrier-intrinsics">
<h4>Memory Barrier Intrinsics<a class="headerlink" href="#memory-barrier-intrinsics" title="Link to this heading">¶</a></h4>
<p>Clang implements the <code class="docutils literal notranslate"><span class="pre">__dmb</span></code>, <code class="docutils literal notranslate"><span class="pre">__dsb</span></code> and <code class="docutils literal notranslate"><span class="pre">__isb</span></code> intrinsics as defined
in the <a class="reference external" href="https://github.com/ARM-software/acle/releases">Arm C Language Extensions</a>.
Note that these intrinsics are implemented as motion barriers that block
reordering of memory accesses and side effect instructions. Other instructions
like simple arithmetic may be reordered around the intrinsic. If you expect to
have no reordering at all, use inline assembly instead.</p>
</section>
<section id="pointer-authentication">
<h4>Pointer Authentication<a class="headerlink" href="#pointer-authentication" title="Link to this heading">¶</a></h4>
<p>See <a class="reference internal" href="PointerAuthentication.html"><span class="doc">Pointer Authentication</span></a>.</p>
</section>
</section>
<section id="x86-x86-64-language-extensions">
<h3>X86/X86-64 Language Extensions<a class="headerlink" href="#x86-x86-64-language-extensions" title="Link to this heading">¶</a></h3>
<p>The X86 backend has these language extensions:</p>
<section id="memory-references-to-specified-segments">
<h4>Memory references to specified segments<a class="headerlink" href="#memory-references-to-specified-segments" title="Link to this heading">¶</a></h4>
<p>Annotating a pointer with address space #256 causes it to be code generated
relative to the X86 GS segment register, address space #257 causes it to be
relative to the X86 FS segment, and address space #258 causes it to be
relative to the X86 SS segment.  Note that this is a very very low-level
feature that should only be used if you know what you’re doing (for example in
an OS kernel).</p>
<p>Here is an example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define GS_RELATIVE __attribute__((address_space(256)))</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">GS_RELATIVE</span><span class="w"> </span><span class="o">*</span><span class="n">P</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">P</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Which compiles to (on X86-32):</p>
<div class="highlight-gas notranslate"><div class="highlight"><pre><span></span><span class="nl">_foo:</span>
<span class="w">        </span><span class="nf">movl</span><span class="w">    </span><span class="mi">4</span><span class="p">(</span><span class="nv">%esp</span><span class="p">),</span><span class="w"> </span><span class="nv">%eax</span>
<span class="w">        </span><span class="nf">movl</span><span class="w">    </span><span class="nv">%gs</span><span class="p">:(</span><span class="nv">%eax</span><span class="p">),</span><span class="w"> </span><span class="nv">%eax</span>
<span class="w">        </span><span class="nf">ret</span>
</pre></div>
</div>
<p>You can also use the GCC compatibility macros <code class="docutils literal notranslate"><span class="pre">__seg_fs</span></code> and <code class="docutils literal notranslate"><span class="pre">__seg_gs</span></code> for
the same purpose. The preprocessor symbols <code class="docutils literal notranslate"><span class="pre">__SEG_FS</span></code> and <code class="docutils literal notranslate"><span class="pre">__SEG_GS</span></code>
indicate their support.</p>
</section>
</section>
<section id="powerpc-language-extensions">
<h3>PowerPC Language Extensions<a class="headerlink" href="#powerpc-language-extensions" title="Link to this heading">¶</a></h3>
<section id="set-the-floating-point-rounding-mode">
<h4>Set the Floating Point Rounding Mode<a class="headerlink" href="#set-the-floating-point-rounding-mode" title="Link to this heading">¶</a></h4>
<p>PowerPC64/PowerPC64le supports the builtin function <code class="docutils literal notranslate"><span class="pre">__builtin_setrnd</span></code> to set
the floating point rounding mode. This function will use the least significant
two bits of integer argument to set the floating point rounding mode.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="nf">__builtin_setrnd</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">mode</span><span class="p">);</span>
</pre></div>
</div>
<p>The effective values for mode are:</p>
<blockquote>
<div><ul class="simple">
<li><p>0 - round to nearest</p></li>
<li><p>1 - round to zero</p></li>
<li><p>2 - round to +infinity</p></li>
<li><p>3 - round to -infinity</p></li>
</ul>
</div></blockquote>
<p>Note that the mode argument will modulo 4, so if the integer argument is greater
than 3, it will only use the least significant two bits of the mode.
Namely, <code class="docutils literal notranslate"><span class="pre">__builtin_setrnd(102))</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">__builtin_setrnd(2)</span></code>.</p>
</section>
<section id="powerpc-cache-builtins">
<h4>PowerPC cache builtins<a class="headerlink" href="#powerpc-cache-builtins" title="Link to this heading">¶</a></h4>
<p>The PowerPC architecture specifies instructions implementing cache operations.
Clang provides builtins that give direct programmer access to these cache
instructions.</p>
<p>Currently the following builtins are implemented in clang:</p>
<p><code class="docutils literal notranslate"><span class="pre">__builtin_dcbf</span></code> copies the contents of a modified block from the data cache
to main memory and flushes the copy from the data cache.</p>
<p><strong>Syntax</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">__dcbf</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">addr</span><span class="p">);</span><span class="w"> </span><span class="cm">/* Data Cache Block Flush */</span>
</pre></div>
</div>
<p><strong>Example of Use</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">__builtin_dcbf</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="extensions-for-static-analysis">
<h2><a class="toc-backref" href="#id46" role="doc-backlink">Extensions for Static Analysis</a><a class="headerlink" href="#extensions-for-static-analysis" title="Link to this heading">¶</a></h2>
<p>Clang supports additional attributes that are useful for documenting program
invariants and rules for static analysis tools, such as the <a class="reference external" href="https://clang-analyzer.llvm.org/">Clang Static
Analyzer</a>. These attributes are documented
in the analyzer’s <a class="reference external" href="analyzer/user-docs/Annotations.html">list of annotations for analysis</a>.</p>
</section>
<section id="extensions-for-dynamic-analysis">
<h2><a class="toc-backref" href="#id47" role="doc-backlink">Extensions for Dynamic Analysis</a><a class="headerlink" href="#extensions-for-dynamic-analysis" title="Link to this heading">¶</a></h2>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(address_sanitizer)</span></code> to check if the code is being built
with <a class="reference internal" href="AddressSanitizer.html"><span class="doc">AddressSanitizer</span></a>.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(thread_sanitizer)</span></code> to check if the code is being built
with <a class="reference internal" href="ThreadSanitizer.html"><span class="doc">ThreadSanitizer</span></a>.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(memory_sanitizer)</span></code> to check if the code is being built
with <a class="reference internal" href="MemorySanitizer.html"><span class="doc">MemorySanitizer</span></a>.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(dataflow_sanitizer)</span></code> to check if the code is being built
with <a class="reference internal" href="DataFlowSanitizer.html"><span class="doc">DataFlowSanitizer</span></a>.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">__has_feature(safe_stack)</span></code> to check if the code is being built
with <a class="reference internal" href="SafeStack.html"><span class="doc">SafeStack</span></a>.</p>
</section>
<section id="extensions-for-selectively-disabling-optimization">
<h2><a class="toc-backref" href="#id48" role="doc-backlink">Extensions for selectively disabling optimization</a><a class="headerlink" href="#extensions-for-selectively-disabling-optimization" title="Link to this heading">¶</a></h2>
<p>Clang provides a mechanism for selectively disabling optimizations in functions
and methods.</p>
<p>To disable optimizations in a single function definition, the GNU-style or C++11
non-standard attribute <code class="docutils literal notranslate"><span class="pre">optnone</span></code> can be used.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// The following functions will not be optimized.</span>
<span class="c1">// GNU-style attribute</span>
<span class="n">__attribute__</span><span class="p">((</span><span class="n">optnone</span><span class="p">))</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ... code</span>
<span class="p">}</span>
<span class="c1">// C++11 attribute</span>
<span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">optnone</span><span class="p">]]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">bar</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ... code</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To facilitate disabling optimization for a range of function definitions, a
range-based pragma is provided. Its syntax is <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">optimize</span></code>
followed by <code class="docutils literal notranslate"><span class="pre">off</span></code> or <code class="docutils literal notranslate"><span class="pre">on</span></code>.</p>
<p>All function definitions in the region between an <code class="docutils literal notranslate"><span class="pre">off</span></code> and the following
<code class="docutils literal notranslate"><span class="pre">on</span></code> will be decorated with the <code class="docutils literal notranslate"><span class="pre">optnone</span></code> attribute unless doing so would
conflict with explicit attributes already present on the function (e.g. the
ones that control inlining).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang optimize off</span>
<span class="c1">// This function will be decorated with optnone.</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ... code</span>
<span class="p">}</span>

<span class="c1">// optnone conflicts with always_inline, so bar() will not be decorated.</span>
<span class="n">__attribute__</span><span class="p">((</span><span class="n">always_inline</span><span class="p">))</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">bar</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ... code</span>
<span class="p">}</span>
<span class="cp">#pragma clang optimize on</span>
</pre></div>
</div>
<p>If no <code class="docutils literal notranslate"><span class="pre">on</span></code> is found to close an <code class="docutils literal notranslate"><span class="pre">off</span></code> region, the end of the region is the
end of the compilation unit.</p>
<p>Note that a stray <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">optimize</span> <span class="pre">on</span></code> does not selectively enable
additional optimizations when compiling at low optimization levels. This feature
can only be used to selectively disable optimizations.</p>
<p>The pragma has an effect on functions only at the point of their definition; for
function templates, this means that the state of the pragma at the point of an
instantiation is not necessarily relevant. Consider the following example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">twice</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#pragma clang optimize off</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">thrice</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">container</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">twice</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">thrice</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#pragma clang optimize on</span>
</pre></div>
</div>
<p>In this example, the definition of the template function <code class="docutils literal notranslate"><span class="pre">twice</span></code> is outside
the pragma region, whereas the definition of <code class="docutils literal notranslate"><span class="pre">thrice</span></code> is inside the region.
The <code class="docutils literal notranslate"><span class="pre">container</span></code> function is also in the region and will not be optimized, but
it causes the instantiation of <code class="docutils literal notranslate"><span class="pre">twice</span></code> and <code class="docutils literal notranslate"><span class="pre">thrice</span></code> with an <code class="docutils literal notranslate"><span class="pre">int</span></code> type; of
these two instantiations, <code class="docutils literal notranslate"><span class="pre">twice</span></code> will be optimized (because its definition
was outside the region) and <code class="docutils literal notranslate"><span class="pre">thrice</span></code> will not be optimized.</p>
<p>Clang also implements MSVC’s range-based pragma,
<code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">optimize(&quot;[optimization-list]&quot;,</span> <span class="pre">on</span> <span class="pre">|</span> <span class="pre">off)</span></code>. At the moment, Clang only
supports an empty optimization list, whereas MSVC supports the arguments, <code class="docutils literal notranslate"><span class="pre">s</span></code>,
<code class="docutils literal notranslate"><span class="pre">g</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code>, and <code class="docutils literal notranslate"><span class="pre">y</span></code>. Currently, the implementation of <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">optimize</span></code> behaves
the same as <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">optimize</span></code>. All functions
between <code class="docutils literal notranslate"><span class="pre">off</span></code> and <code class="docutils literal notranslate"><span class="pre">on</span></code> will be decorated with the <code class="docutils literal notranslate"><span class="pre">optnone</span></code> attribute.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma optimize(&quot;&quot;, off)</span>
<span class="c1">// This function will be decorated with optnone.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">f1</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>

<span class="cp">#pragma optimize(&quot;&quot;, on)</span>
<span class="c1">// This function will be optimized with whatever was specified on</span>
<span class="c1">// the commandline.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">f2</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>

<span class="c1">// This will warn with Clang&#39;s current implementation.</span>
<span class="cp">#pragma optimize(&quot;g&quot;, on)</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">f3</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
</pre></div>
</div>
<p>For MSVC, an empty optimization list and <code class="docutils literal notranslate"><span class="pre">off</span></code> parameter will turn off
all optimizations, <code class="docutils literal notranslate"><span class="pre">s</span></code>, <code class="docutils literal notranslate"><span class="pre">g</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code>, and <code class="docutils literal notranslate"><span class="pre">y</span></code>. An empty optimization and
<code class="docutils literal notranslate"><span class="pre">on</span></code> parameter will reset the optimizations to the ones specified on the
commandline.</p>
<table class="docutils align-default" id="id18">
<caption><span class="caption-text">Parameters (unsupported by Clang)</span><a class="headerlink" href="#id18" title="Link to this table">¶</a></caption>
<tbody>
<tr class="row-odd"><td><p>Parameter</p></td>
<td><p>Type of optimization</p></td>
</tr>
<tr class="row-even"><td><p>g</p></td>
<td><p>Deprecated</p></td>
</tr>
<tr class="row-odd"><td><p>s or t</p></td>
<td><p>Short or fast sequences of machine code</p></td>
</tr>
<tr class="row-even"><td><p>y</p></td>
<td><p>Enable frame pointers</p></td>
</tr>
</tbody>
</table>
</section>
<section id="extensions-for-loop-hint-optimizations">
<h2><a class="toc-backref" href="#id49" role="doc-backlink">Extensions for loop hint optimizations</a><a class="headerlink" href="#extensions-for-loop-hint-optimizations" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">loop</span></code> directive is used to specify hints for optimizing the
subsequent for, while, do-while, or c++11 range-based for loop. The directive
provides options for vectorization, interleaving, predication, unrolling and
distribution. Loop hints can be specified before any loop and will be ignored if
the optimization is not safe to apply.</p>
<p>There are loop hints that control transformations (e.g. vectorization, loop
unrolling) and there are loop hints that set transformation options (e.g.
<code class="docutils literal notranslate"><span class="pre">vectorize_width</span></code>, <code class="docutils literal notranslate"><span class="pre">unroll_count</span></code>).  Pragmas setting transformation options
imply the transformation is enabled, as if it was enabled via the corresponding
transformation pragma (e.g. <code class="docutils literal notranslate"><span class="pre">vectorize(enable)</span></code>). If the transformation is
disabled  (e.g. <code class="docutils literal notranslate"><span class="pre">vectorize(disable)</span></code>), that takes precedence over
transformations option pragmas implying that transformation.</p>
<section id="vectorization-interleaving-and-predication">
<h3>Vectorization, Interleaving, and Predication<a class="headerlink" href="#vectorization-interleaving-and-predication" title="Link to this heading">¶</a></h3>
<p>A vectorized loop performs multiple iterations of the original loop
in parallel using vector instructions. The instruction set of the target
processor determines which vector instructions are available and their vector
widths. This restricts the types of loops that can be vectorized. The vectorizer
automatically determines if the loop is safe and profitable to vectorize. A
vector instruction cost model is used to select the vector width.</p>
<p>Interleaving multiple loop iterations allows modern processors to further
improve instruction-level parallelism (ILP) using advanced hardware features,
such as multiple execution units and out-of-order execution. The vectorizer uses
a cost model that depends on the register pressure and generated code size to
select the interleaving count.</p>
<p>Vectorization is enabled by <code class="docutils literal notranslate"><span class="pre">vectorize(enable)</span></code> and interleaving is enabled
by <code class="docutils literal notranslate"><span class="pre">interleave(enable)</span></code>. This is useful when compiling with <code class="docutils literal notranslate"><span class="pre">-Os</span></code> to
manually enable vectorization or interleaving.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang loop vectorize(enable)</span>
<span class="cp">#pragma clang loop interleave(enable)</span>
<span class="k">for</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The vector width is specified by
<code class="docutils literal notranslate"><span class="pre">vectorize_width(_value_[,</span> <span class="pre">fixed|scalable])</span></code>, where _value_ is a positive
integer and the type of vectorization can be specified with an optional
second parameter. The default for the second parameter is ‘fixed’ and
refers to fixed width vectorization, whereas ‘scalable’ indicates the
compiler should use scalable vectors instead. Another use of vectorize_width
is <code class="docutils literal notranslate"><span class="pre">vectorize_width(fixed|scalable)</span></code> where the user can hint at the type
of vectorization to use without specifying the exact width. In both variants
of the pragma the vectorizer may decide to fall back on fixed width
vectorization if the target does not support scalable vectors.</p>
<p>The interleave count is specified by <code class="docutils literal notranslate"><span class="pre">interleave_count(_value_)</span></code>, where
_value_ is a positive integer. This is useful for specifying the optimal
width/count of the set of target architectures supported by your application.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang loop vectorize_width(2)</span>
<span class="cp">#pragma clang loop interleave_count(2)</span>
<span class="k">for</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Specifying a width/count of 1 disables the optimization, and is equivalent to
<code class="docutils literal notranslate"><span class="pre">vectorize(disable)</span></code> or <code class="docutils literal notranslate"><span class="pre">interleave(disable)</span></code>.</p>
<p>Vector predication is enabled by <code class="docutils literal notranslate"><span class="pre">vectorize_predicate(enable)</span></code>, for example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang loop vectorize(enable)</span>
<span class="cp">#pragma clang loop vectorize_predicate(enable)</span>
<span class="k">for</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This predicates (masks) all instructions in the loop, which allows the scalar
remainder loop (the tail) to be folded into the main vectorized loop. This
might be more efficient when vector predication is efficiently supported by the
target platform.</p>
</section>
<section id="loop-unrolling">
<h3>Loop Unrolling<a class="headerlink" href="#loop-unrolling" title="Link to this heading">¶</a></h3>
<p>Unrolling a loop reduces the loop control overhead and exposes more
opportunities for ILP. Loops can be fully or partially unrolled. Full unrolling
eliminates the loop and replaces it with an enumerated sequence of loop
iterations. Full unrolling is only possible if the loop trip count is known at
compile time. Partial unrolling replicates the loop body within the loop and
reduces the trip count.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">unroll(enable)</span></code> is specified the unroller will attempt to fully unroll the
loop if the trip count is known at compile time. If the fully unrolled code size
is greater than an internal limit the loop will be partially unrolled up to this
limit. If the trip count is not known at compile time the loop will be partially
unrolled with a heuristically chosen unroll factor.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang loop unroll(enable)</span>
<span class="k">for</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">unroll(full)</span></code> is specified the unroller will attempt to fully unroll the
loop if the trip count is known at compile time identically to
<code class="docutils literal notranslate"><span class="pre">unroll(enable)</span></code>. However, with <code class="docutils literal notranslate"><span class="pre">unroll(full)</span></code> the loop will not be unrolled
if the loop count is not known at compile time.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang loop unroll(full)</span>
<span class="k">for</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The unroll count can be specified explicitly with <code class="docutils literal notranslate"><span class="pre">unroll_count(_value_)</span></code> where
_value_ is a positive integer. If this value is greater than the trip count the
loop will be fully unrolled. Otherwise the loop is partially unrolled subject
to the same code size limit as with <code class="docutils literal notranslate"><span class="pre">unroll(enable)</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang loop unroll_count(8)</span>
<span class="k">for</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Unrolling of a loop can be prevented by specifying <code class="docutils literal notranslate"><span class="pre">unroll(disable)</span></code>.</p>
<p>Loop unroll parameters can be controlled by options
<cite>-mllvm -unroll-count=n</cite> and <cite>-mllvm -pragma-unroll-threshold=n</cite>.</p>
</section>
<section id="loop-distribution">
<h3>Loop Distribution<a class="headerlink" href="#loop-distribution" title="Link to this heading">¶</a></h3>
<p>Loop Distribution allows splitting a loop into multiple loops.  This is
beneficial for example when the entire loop cannot be vectorized but some of the
resulting loops can.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">distribute(enable))</span></code> is specified and the loop has memory dependencies
that inhibit vectorization, the compiler will attempt to isolate the offending
operations into a new loop.  This optimization is not enabled by default, only
loops marked with the pragma are considered.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang loop distribute(enable)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nl">S1</span><span class="p">:</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="nl">S2</span><span class="p">:</span><span class="w"> </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This loop will be split into two loops between statements S1 and S2.  The
second loop containing S2 will be vectorized.</p>
<p>Loop Distribution is currently not enabled by default in the optimizer because
it can hurt performance in some cases.  For example, instruction-level
parallelism could be reduced by sequentializing the execution of the
statements S1 and S2 above.</p>
<p>If Loop Distribution is turned on globally with
<code class="docutils literal notranslate"><span class="pre">-mllvm</span> <span class="pre">-enable-loop-distribution</span></code>, specifying <code class="docutils literal notranslate"><span class="pre">distribute(disable)</span></code> can
be used the disable it on a per-loop basis.</p>
</section>
<section id="additional-information">
<h3>Additional Information<a class="headerlink" href="#additional-information" title="Link to this heading">¶</a></h3>
<p>For convenience multiple loop hints can be specified on a single line.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang loop vectorize_width(4) interleave_count(8)</span>
<span class="k">for</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If an optimization cannot be applied any hints that apply to it will be ignored.
For example, the hint <code class="docutils literal notranslate"><span class="pre">vectorize_width(4)</span></code> is ignored if the loop is not
proven safe to vectorize. To identify and diagnose optimization issues use
<cite>-Rpass</cite>, <cite>-Rpass-missed</cite>, and <cite>-Rpass-analysis</cite> command line options. See the
user guide for details.</p>
</section>
</section>
<section id="extensions-to-specify-floating-point-flags">
<h2><a class="toc-backref" href="#id50" role="doc-backlink">Extensions to specify floating-point flags</a><a class="headerlink" href="#extensions-to-specify-floating-point-flags" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">fp</span></code> pragma allows floating-point options to be specified
for a section of the source code. This pragma can only appear at file scope or
at the start of a compound statement (excluding comments). When using within a
compound statement, the pragma is active within the scope of the compound
statement.</p>
<p>Currently, the following settings can be controlled with this pragma:</p>
<p><code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">fp</span> <span class="pre">reassociate</span></code> allows control over the reassociation
of floating point expressions. When enabled, this pragma allows the expression
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">(y</span> <span class="pre">+</span> <span class="pre">z)</span></code> to be reassociated as <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y)</span> <span class="pre">+</span> <span class="pre">z</span></code>.
Reassociation can also occur across multiple statements.
This pragma can be used to disable reassociation when it is otherwise
enabled for the translation unit with the <code class="docutils literal notranslate"><span class="pre">-fassociative-math</span></code> flag.
The pragma can take two values: <code class="docutils literal notranslate"><span class="pre">on</span></code> and <code class="docutils literal notranslate"><span class="pre">off</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Enable floating point reassociation across statements</span>
<span class="w">  </span><span class="cp">#pragma clang fp reassociate(on)</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">fp</span> <span class="pre">reciprocal</span></code> allows control over using reciprocal
approximations in floating point expressions. When enabled, this
pragma allows the expression <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code> to be approximated as <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span>
<span class="pre">(1.0</span> <span class="pre">/</span> <span class="pre">y)</span></code>.  This pragma can be used to disable reciprocal
approximation when it is otherwise enabled for the translation unit
with the <code class="docutils literal notranslate"><span class="pre">-freciprocal-math</span></code> flag or other fast-math options. The
pragma can take two values: <code class="docutils literal notranslate"><span class="pre">on</span></code> and <code class="docutils literal notranslate"><span class="pre">off</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Enable floating point reciprocal approximation</span>
<span class="w">  </span><span class="cp">#pragma clang fp reciprocal(on)</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">fp</span> <span class="pre">contract</span></code> specifies whether the compiler should
contract a multiply and an addition (or subtraction) into a fused FMA
operation when supported by the target.</p>
<p>The pragma can take three values: <code class="docutils literal notranslate"><span class="pre">on</span></code>, <code class="docutils literal notranslate"><span class="pre">fast</span></code> and <code class="docutils literal notranslate"><span class="pre">off</span></code>.  The <code class="docutils literal notranslate"><span class="pre">on</span></code>
option is identical to using <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">STDC</span> <span class="pre">FP_CONTRACT(ON)</span></code> and it allows
fusion as specified the language standard.  The <code class="docutils literal notranslate"><span class="pre">fast</span></code> option allows fusion
in cases when the language standard does not make this possible (e.g. across
statements in C).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="cp">#pragma clang fp contract(fast)</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The pragma can also be used with <code class="docutils literal notranslate"><span class="pre">off</span></code> which turns FP contraction off for a
section of the code. This can be useful when fast contraction is otherwise
enabled for the translation unit with the <code class="docutils literal notranslate"><span class="pre">-ffp-contract=fast-honor-pragmas</span></code> flag.
Note that <code class="docutils literal notranslate"><span class="pre">-ffp-contract=fast</span></code> will override pragmas to fuse multiply and
addition across statements regardless of any controlling pragmas.</p>
<p><code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">fp</span> <span class="pre">exceptions</span></code> specifies floating point exception behavior. It
may take one of the values: <code class="docutils literal notranslate"><span class="pre">ignore</span></code>, <code class="docutils literal notranslate"><span class="pre">maytrap</span></code> or <code class="docutils literal notranslate"><span class="pre">strict</span></code>. Meaning of
these values is same as for <a class="reference external" href="http://llvm.org/docs/LangRef.html#constrained-floating-point-intrinsics">constrained floating point intrinsics</a>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Preserve floating point exceptions</span>
<span class="w">  </span><span class="cp">#pragma clang fp exceptions(strict)</span>
<span class="w">  </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fetestexcept</span><span class="p">(</span><span class="n">FE_OVERFLOW</span><span class="p">))</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">fp</span></code> pragma may contain any number of options:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="cp">#pragma clang fp exceptions(maytrap) contract(fast) reassociate(on)</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">fp</span> <span class="pre">eval_method</span></code> allows floating-point behavior to be specified
for a section of the source code. This pragma can appear at file or namespace
scope, or at the start of a compound statement (excluding comments).
The pragma is active within the scope of the compound statement.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">clang</span> <span class="pre">fp</span> <span class="pre">eval_method(source)</span></code> is enabled, the section of code
governed by the pragma behaves as though the command-line option
<code class="docutils literal notranslate"><span class="pre">-ffp-eval-method=source</span></code> is enabled. Rounds intermediate results to
source-defined precision.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">clang</span> <span class="pre">fp</span> <span class="pre">eval_method(double)</span></code> is enabled, the section of code
governed by the pragma behaves as though the command-line option
<code class="docutils literal notranslate"><span class="pre">-ffp-eval-method=double</span></code> is enabled. Rounds intermediate results to
<code class="docutils literal notranslate"><span class="pre">double</span></code> precision.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">clang</span> <span class="pre">fp</span> <span class="pre">eval_method(extended)</span></code> is enabled, the section of code
governed by the pragma behaves as though the command-line option
<code class="docutils literal notranslate"><span class="pre">-ffp-eval-method=extended</span></code> is enabled. Rounds intermediate results to
target-dependent <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">double</span></code> precision. In Win32 programming, for instance,
the long double data type maps to the double, 64-bit precision data type.</p>
<p>The full syntax this pragma supports is
<code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">fp</span> <span class="pre">eval_method(source|double|extended)</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// The compiler will use long double as the floating-point evaluation</span>
<span class="w">  </span><span class="c1">// method.</span>
<span class="w">  </span><span class="cp">#pragma clang fp eval_method(extended)</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">e</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note: <code class="docutils literal notranslate"><span class="pre">math.h</span></code> defines the typedefs <code class="docutils literal notranslate"><span class="pre">float_t</span></code> and <code class="docutils literal notranslate"><span class="pre">double_t</span></code> based on the active
evaluation method at the point where the header is included, not where the
typedefs are used.  Because of this, it is unwise to combine these typedefs with
<code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">fp</span> <span class="pre">eval_method</span></code>.  To catch obvious bugs, Clang will emit an
error for any references to these typedefs within the scope of this pragma;
however, this is not a fool-proof protection, and programmers must take care.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">float_control</span></code> pragma allows precise floating-point
semantics and floating-point exception behavior to be specified
for a section of the source code. This pragma can only appear at file or
namespace scope, within a language linkage specification or at the start of a
compound statement (excluding comments). When used within a compound statement,
the pragma is active within the scope of the compound statement.  This pragma
is modeled after a Microsoft pragma with the same spelling and syntax.  For
pragmas specified at file or namespace scope, or within a language linkage
specification, a stack is supported so that the <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">float_control</span></code>
settings can be pushed or popped.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">float_control(precise,</span> <span class="pre">on)</span></code> is enabled, the section of code
governed by the pragma uses precise floating point semantics, effectively
<code class="docutils literal notranslate"><span class="pre">-ffast-math</span></code> is disabled and <code class="docutils literal notranslate"><span class="pre">-ffp-contract=on</span></code>
(fused multiply add) is enabled. This pragma enables <code class="docutils literal notranslate"><span class="pre">-fmath-errno</span></code>.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">float_control(precise,</span> <span class="pre">off)</span></code> is enabled, unsafe-floating point
optimizations are enabled in the section of code governed by the pragma.
Effectively <code class="docutils literal notranslate"><span class="pre">-ffast-math</span></code> is enabled and <code class="docutils literal notranslate"><span class="pre">-ffp-contract=fast</span></code>. This pragma
disables <code class="docutils literal notranslate"><span class="pre">-fmath-errno</span></code>.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">float_control(except,</span> <span class="pre">on)</span></code> is enabled, the section of code
governed by the pragma behaves as though the command-line option
<code class="docutils literal notranslate"><span class="pre">-ffp-exception-behavior=strict</span></code> is enabled,
when <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">float_control(except,</span> <span class="pre">off)</span></code> is enabled, the section of code
governed by the pragma behaves as though the command-line option
<code class="docutils literal notranslate"><span class="pre">-ffp-exception-behavior=ignore</span></code> is enabled.</p>
<p>The full syntax this pragma supports is
<code class="docutils literal notranslate"><span class="pre">float_control(except|precise,</span> <span class="pre">on|off</span> <span class="pre">[,</span> <span class="pre">push])</span></code> and
<code class="docutils literal notranslate"><span class="pre">float_control(push|pop)</span></code>.
The <code class="docutils literal notranslate"><span class="pre">push</span></code> and <code class="docutils literal notranslate"><span class="pre">pop</span></code> forms, including using <code class="docutils literal notranslate"><span class="pre">push</span></code> as the optional
third argument, can only occur at file scope.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// This block will be compiled with -fno-fast-math and -ffp-contract=on</span>
<span class="w">  </span><span class="cp">#pragma float_control(precise, on)</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">e</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="extensions-for-controlling-atomic-code-generation">
<h2><a class="toc-backref" href="#id51" role="doc-backlink">Extensions for controlling atomic code generation</a><a class="headerlink" href="#extensions-for-controlling-atomic-code-generation" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">[[clang::atomic]]</span></code> statement attribute enables users to control how
atomic operations are lowered in LLVM IR by conveying additional metadata to
the backend. The primary goal is to allow users to specify certain options,
like whether the affected atomic operations might be used with specific types of memory or
whether to ignore denormal mode correctness in floating-point operations,
without affecting the correctness of code that does not rely on these properties.</p>
<p>In LLVM, lowering of atomic operations (e.g., <code class="docutils literal notranslate"><span class="pre">atomicrmw</span></code>) can differ based
on the target’s capabilities. Some backends support native atomic instructions
only for certain operation types or alignments, or only in specific memory
regions. Likewise, floating-point atomic instructions may or may not respect
IEEE denormal requirements. When the user is unconcerned about denormal-mode
compliance (for performance reasons) or knows that certain atomic operations
will not be performed on a particular type of memory, extra hints are needed to
tell the backend how to proceed.</p>
<p>A classic example is an architecture where floating-point atomic add does not
fully conform to IEEE denormal-mode handling. If the user does not mind ignoring
that aspect, they would prefer to emit a faster hardware atomic instruction,
rather than a fallback or CAS loop. Conversely, on certain GPUs (e.g., AMDGPU),
memory accessed via PCIe may only support a subset of atomic operations. To ensure
correct and efficient lowering, the compiler must know whether the user needs
the atomic operations to work with that type of memory.</p>
<p>The allowed atomic attribute values are now <code class="docutils literal notranslate"><span class="pre">remote_memory</span></code>, <code class="docutils literal notranslate"><span class="pre">fine_grained_memory</span></code>,
and <code class="docutils literal notranslate"><span class="pre">ignore_denormal_mode</span></code>, each optionally prefixed with <code class="docutils literal notranslate"><span class="pre">no_</span></code>. The meanings
are as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">remote_memory</span></code> means atomic operations may be performed on remote
memory, i.e. memory accessed through off-chip interconnects (e.g., PCIe).
On ROCm platforms using HIP, remote memory refers to memory accessed via
PCIe and is subject to specific atomic operation support. See
<a class="reference external" href="https://rocm.docs.amd.com/en/latest/conceptual/pcie-atomics.html">ROCm PCIe Atomics</a> for further details. Prefixing with <code class="docutils literal notranslate"><span class="pre">no_remote_memory</span></code> indicates that
atomic operations should not be performed on remote memory.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fine_grained_memory</span></code> means atomic operations may be performed on fine-grained
memory, i.e. memory regions that support fine-grained coherence, where updates to
memory are visible to other parts of the system even while modifications are ongoing.
For example, in HIP, fine-grained coherence ensures that host and device share
up-to-date data without explicit synchronization (see
<a class="reference external" href="https://rocm.docs.amd.com/projects/HIP/en/docs-6.3.3/how-to/hip_runtime_api/memory_management/coherence_control.html#coherence-control">HIP Definition</a>).
Similarly, OpenCL 2.0 provides fine-grained synchronization in shared virtual memory
allocations, allowing concurrent modifications by host and device (see
<a class="reference external" href="https://www.intel.com/content/www/us/en/developer/articles/technical/opencl-20-shared-virtual-memory-overview.html">OpenCL 2.0 Overview</a>).
Prefixing with <code class="docutils literal notranslate"><span class="pre">no_fine_grained_memory</span></code> indicates that atomic operations should not
be performed on fine-grained memory.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ignore_denormal_mode</span></code> means that atomic operations are allowed to ignore
correctness for denormal mode in floating-point operations, potentially improving
performance on architectures that handle denormals inefficiently. The negated form,
if specified as <code class="docutils literal notranslate"><span class="pre">no_ignore_denormal_mode</span></code>, would enforce strict denormal mode
correctness.</p></li>
</ul>
<p>Any unspecified option is inherited from the global defaults, which can be set
by a compiler flag or the target’s built-in defaults.</p>
<p>Within the same atomic attribute, duplicate and conflicting values are accepted,
and the last of any conflicting values wins. Multiple atomic attributes are
allowed for the same compound statement, and the last atomic attribute wins.</p>
<p>Without any atomic metadata, LLVM IR defaults to conservative settings for
correctness: atomic operations enforce denormal mode correctness and are assumed
to potentially use remote and fine-grained memory (i.e., the equivalent of
<code class="docutils literal notranslate"><span class="pre">remote_memory</span></code>, <code class="docutils literal notranslate"><span class="pre">fine_grained_memory</span></code>, and <code class="docutils literal notranslate"><span class="pre">no_ignore_denormal_mode</span></code>).</p>
<p>The attribute may be applied only to a compound statement and looks like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">atomic</span><span class="p">(</span><span class="n">remote_memory</span><span class="p">,</span><span class="w"> </span><span class="n">fine_grained_memory</span><span class="p">,</span><span class="w"> </span><span class="n">ignore_denormal_mode</span><span class="p">)]]</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Atomic instructions in this block carry extra metadata reflecting</span>
<span class="w">    </span><span class="c1">// these user-specified options.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A new compiler option now globally sets the defaults for these atomic-lowering
options. The command-line format has changed to:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang<span class="w"> </span>-fatomic-remote-memory<span class="w"> </span>-fno-atomic-fine-grained-memory<span class="w"> </span>-fatomic-ignore-denormal-mode<span class="w"> </span>file.cpp
</pre></div>
</div>
<p>Each option has a corresponding flag:
<code class="docutils literal notranslate"><span class="pre">-fatomic-remote-memory</span></code> / <code class="docutils literal notranslate"><span class="pre">-fno-atomic-remote-memory</span></code>,
<code class="docutils literal notranslate"><span class="pre">-fatomic-fine-grained-memory</span></code> / <code class="docutils literal notranslate"><span class="pre">-fno-atomic-fine-grained-memory</span></code>,
and <code class="docutils literal notranslate"><span class="pre">-fatomic-ignore-denormal-mode</span></code> / <code class="docutils literal notranslate"><span class="pre">-fno-atomic-ignore-denormal-mode</span></code>.</p>
<p>Code using the <code class="docutils literal notranslate"><span class="pre">[[clang::atomic]]</span></code> attribute can then selectively override
the command-line defaults on a per-block basis. For instance:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Suppose the global defaults assume:</span>
<span class="c1">//   remote_memory, fine_grained_memory, and no_ignore_denormal_mode</span>
<span class="c1">// (for conservative correctness)</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Locally override the settings: disable remote_memory and enable</span>
<span class="w">    </span><span class="c1">// fine_grained_memory.</span>
<span class="w">    </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">atomic</span><span class="p">(</span><span class="n">no_remote_memory</span><span class="p">,</span><span class="w"> </span><span class="n">fine_grained_memory</span><span class="p">)]]</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// In this block:</span>
<span class="w">        </span><span class="c1">//   - Atomic operations are not performed on remote memory.</span>
<span class="w">        </span><span class="c1">//   - Atomic operations are performed on fine-grained memory.</span>
<span class="w">        </span><span class="c1">//   - The setting for denormal mode remains as the global default</span>
<span class="w">        </span><span class="c1">//     (typically no_ignore_denormal_mode, enforcing strict denormal mode correctness).</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Function bodies do not accept statement attributes, so this will not work:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">()</span><span class="w"> </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">atomic</span><span class="p">(</span><span class="n">remote_memory</span><span class="p">)]]</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// Wrong: applies to function type</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Use the attribute on a compound statement within the function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">atomic</span><span class="p">(</span><span class="n">remote_memory</span><span class="p">)]]</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Atomic operations in this block carry the specified metadata.</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">[[clang::atomic]]</span></code> attribute affects only the code generation of atomic
instructions within the annotated compound statement. Clang attaches target-specific
metadata to those atomic instructions in the emitted LLVM IR to guide backend lowering.
This metadata is fixed at the Clang code generation phase and is not modified by later
LLVM passes (such as function inlining).</p>
<p>For example, consider:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">atomic</span><span class="p">(</span><span class="n">remote_memory</span><span class="p">)]]</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Atomic instructions lowered with metadata.</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">[[</span><span class="n">clang</span><span class="o">::</span><span class="n">atomic</span><span class="p">(</span><span class="n">no_remote_memory</span><span class="p">)]]</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">func</span><span class="p">();</span><span class="w"> </span><span class="c1">// Inlined by LLVM, but the metadata from &#39;func()&#39; remains unchanged.</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Although current usage focuses on AMDGPU, the mechanism is general. Other
backends can ignore or implement their own responses to these flags if desired.
If a target does not understand or enforce these hints, the IR remains valid,
and the resulting program is still correct (although potentially less optimized
for that user’s needs).</p>
</section>
<section id="specifying-an-attribute-for-multiple-declarations-pragma-clang-attribute">
<h2><a class="toc-backref" href="#id52" role="doc-backlink">Specifying an attribute for multiple declarations (#pragma clang attribute)</a><a class="headerlink" href="#specifying-an-attribute-for-multiple-declarations-pragma-clang-attribute" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">attribute</span></code> directive can be used to apply an attribute to
multiple declarations. The <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">attribute</span> <span class="pre">push</span></code> variation of the
directive pushes a new “scope” of <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">attribute</span></code> that attributes
can be added to. The <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">attribute</span> <span class="pre">(...)</span></code> variation adds an
attribute to that scope, and the <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">attribute</span> <span class="pre">pop</span></code> variation pops
the scope. You can also use <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">attribute</span> <span class="pre">push</span> <span class="pre">(...)</span></code>, which is a
shorthand for when you want to add one attribute to a new scope. Multiple push
directives can be nested inside each other.</p>
<p>The attributes that are used in the <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">attribute</span></code> directives
can be written using the GNU-style syntax:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang attribute push (__attribute__((annotate(&quot;custom&quot;))), apply_to = function)</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">function</span><span class="p">();</span><span class="w"> </span><span class="c1">// The function now has the annotate(&quot;custom&quot;) attribute</span>

<span class="cp">#pragma clang attribute pop</span>
</pre></div>
</div>
<p>The attributes can also be written using the C++11 style syntax:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang attribute push ([[noreturn]], apply_to = function)</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">function</span><span class="p">();</span><span class="w"> </span><span class="c1">// The function now has the [[noreturn]] attribute</span>

<span class="cp">#pragma clang attribute pop</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">__declspec</span></code> style syntax is also supported:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang attribute push (__declspec(dllexport), apply_to = function)</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">function</span><span class="p">();</span><span class="w"> </span><span class="c1">// The function now has the __declspec(dllexport) attribute</span>

<span class="cp">#pragma clang attribute pop</span>
</pre></div>
</div>
<p>A single push directive can contain multiple attributes, however,
only one syntax style can be used within a single directive:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang attribute push ([[noreturn, noinline]], apply_to = function)</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">function1</span><span class="p">();</span><span class="w"> </span><span class="c1">// The function now has the [[noreturn]] and [[noinline]] attributes</span>

<span class="cp">#pragma clang attribute pop</span>

<span class="cp">#pragma clang attribute push (__attribute((noreturn, noinline)), apply_to = function)</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">function2</span><span class="p">();</span><span class="w"> </span><span class="c1">// The function now has the __attribute((noreturn)) and __attribute((noinline)) attributes</span>

<span class="cp">#pragma clang attribute pop</span>
</pre></div>
</div>
<p>Because multiple push directives can be nested, if you’re writing a macro that
expands to <code class="docutils literal notranslate"><span class="pre">_Pragma(&quot;clang</span> <span class="pre">attribute&quot;)</span></code> it’s good hygiene (though not
required) to add a namespace to your push/pop directives. A pop directive with a
namespace will pop the innermost push that has that same namespace. This will
ensure that another macro’s <code class="docutils literal notranslate"><span class="pre">pop</span></code> won’t inadvertently pop your attribute. Note
that an <code class="docutils literal notranslate"><span class="pre">pop</span></code> without a namespace will pop the innermost <code class="docutils literal notranslate"><span class="pre">push</span></code> without a
namespace. <code class="docutils literal notranslate"><span class="pre">push``es</span> <span class="pre">with</span> <span class="pre">a</span> <span class="pre">namespace</span> <span class="pre">can</span> <span class="pre">only</span> <span class="pre">be</span> <span class="pre">popped</span> <span class="pre">by</span> <span class="pre">``pop</span></code> with the
same namespace. For instance:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define ASSUME_NORETURN_BEGIN _Pragma(&quot;clang attribute AssumeNoreturn.push ([[noreturn]], apply_to = function)&quot;)</span>
<span class="cp">#define ASSUME_NORETURN_END   _Pragma(&quot;clang attribute AssumeNoreturn.pop&quot;)</span>

<span class="cp">#define ASSUME_UNAVAILABLE_BEGIN _Pragma(&quot;clang attribute Unavailable.push (__attribute__((unavailable)), apply_to=function)&quot;)</span>
<span class="cp">#define ASSUME_UNAVAILABLE_END   _Pragma(&quot;clang attribute Unavailable.pop&quot;)</span>


<span class="n">ASSUME_NORETURN_BEGIN</span>
<span class="n">ASSUME_UNAVAILABLE_BEGIN</span>
<span class="kt">void</span><span class="w"> </span><span class="n">function</span><span class="p">();</span><span class="w"> </span><span class="c1">// function has [[noreturn]] and __attribute__((unavailable))</span>
<span class="n">ASSUME_NORETURN_END</span>
<span class="kt">void</span><span class="w"> </span><span class="n">other_function</span><span class="p">();</span><span class="w"> </span><span class="c1">// function has __attribute__((unavailable))</span>
<span class="n">ASSUME_UNAVAILABLE_END</span>
</pre></div>
</div>
<p>Without the namespaces on the macros, <code class="docutils literal notranslate"><span class="pre">other_function</span></code> will be annotated with
<code class="docutils literal notranslate"><span class="pre">[[noreturn]]</span></code> instead of <code class="docutils literal notranslate"><span class="pre">__attribute__((unavailable))</span></code>. This may seem like
a contrived example, but its very possible for this kind of situation to appear
in real code if the pragmas are spread out across a large file. You can test if
your version of clang supports namespaces on <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">attribute</span></code> with
<code class="docutils literal notranslate"><span class="pre">__has_extension(pragma_clang_attribute_namespaces)</span></code>.</p>
<section id="subject-match-rules">
<h3>Subject Match Rules<a class="headerlink" href="#subject-match-rules" title="Link to this heading">¶</a></h3>
<p>The set of declarations that receive a single attribute from the attribute stack
depends on the subject match rules that were specified in the pragma. Subject
match rules are specified after the attribute. The compiler expects an
identifier that corresponds to the subject set specifier. The <code class="docutils literal notranslate"><span class="pre">apply_to</span></code>
specifier is currently the only supported subject set specifier. It allows you
to specify match rules that form a subset of the attribute’s allowed subject
set, i.e. the compiler doesn’t require all of the attribute’s subjects. For
example, an attribute like <code class="docutils literal notranslate"><span class="pre">[[nodiscard]]</span></code> whose subject set includes
<code class="docutils literal notranslate"><span class="pre">enum</span></code>, <code class="docutils literal notranslate"><span class="pre">record</span></code> and <code class="docutils literal notranslate"><span class="pre">hasType(functionType)</span></code>, requires the presence of at
least one of these rules after <code class="docutils literal notranslate"><span class="pre">apply_to</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang attribute push([[nodiscard]], apply_to = enum)</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">Enum1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">A1</span><span class="p">,</span><span class="w"> </span><span class="n">B1</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// The enum will receive [[nodiscard]]</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Record1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// The struct will *not* receive [[nodiscard]]</span>

<span class="cp">#pragma clang attribute pop</span>

<span class="cp">#pragma clang attribute push([[nodiscard]], apply_to = any(record, enum))</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">Enum2</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">A2</span><span class="p">,</span><span class="w"> </span><span class="n">B2</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// The enum will receive [[nodiscard]]</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Record2</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// The struct *will* receive [[nodiscard]]</span>

<span class="cp">#pragma clang attribute pop</span>

<span class="c1">// This is an error, since [[nodiscard]] can&#39;t be applied to namespaces:</span>
<span class="cp">#pragma clang attribute push([[nodiscard]], apply_to = any(record, namespace))</span>

<span class="cp">#pragma clang attribute pop</span>
</pre></div>
</div>
<p>Multiple match rules can be specified using the <code class="docutils literal notranslate"><span class="pre">any</span></code> match rule, as shown
in the example above. The <code class="docutils literal notranslate"><span class="pre">any</span></code> rule applies attributes to all declarations
that are matched by at least one of the rules in the <code class="docutils literal notranslate"><span class="pre">any</span></code>. It doesn’t nest
and can’t be used inside the other match rules. Redundant match rules or rules
that conflict with one another should not be used inside of <code class="docutils literal notranslate"><span class="pre">any</span></code>. Failing to
specify a rule within the <code class="docutils literal notranslate"><span class="pre">any</span></code> rule results in an error.</p>
<p>Clang supports the following match rules:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">function</span></code>: Can be used to apply attributes to functions. This includes C++
member functions, static functions, operators, and constructors/destructors.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">function(is_member)</span></code>: Can be used to apply attributes to C++ member
functions. This includes members like static functions, operators, and
constructors/destructors.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hasType(functionType)</span></code>: Can be used to apply attributes to functions, C++
member functions, and variables/fields whose type is a function pointer. It
does not apply attributes to Objective-C methods or blocks.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type_alias</span></code>: Can be used to apply attributes to <code class="docutils literal notranslate"><span class="pre">typedef</span></code> declarations
and C++11 type aliases.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">record</span></code>: Can be used to apply attributes to <code class="docutils literal notranslate"><span class="pre">struct</span></code>, <code class="docutils literal notranslate"><span class="pre">class</span></code>, and
<code class="docutils literal notranslate"><span class="pre">union</span></code> declarations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">record(unless(is_union))</span></code>: Can be used to apply attributes only to
<code class="docutils literal notranslate"><span class="pre">struct</span></code> and <code class="docutils literal notranslate"><span class="pre">class</span></code> declarations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">enum</span></code>: Can be used to apply attributes to enumeration declarations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">enum_constant</span></code>: Can be used to apply attributes to enumerators.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">variable</span></code>: Can be used to apply attributes to variables, including
local variables, parameters, global variables, and static member variables.
It does not apply attributes to instance member variables or Objective-C
ivars.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">variable(is_thread_local)</span></code>: Can be used to apply attributes to thread-local
variables only.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">variable(is_global)</span></code>: Can be used to apply attributes to global variables
only.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">variable(is_local)</span></code>: Can be used to apply attributes to local variables
only.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">variable(is_parameter)</span></code>: Can be used to apply attributes to parameters
only.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">variable(unless(is_parameter))</span></code>: Can be used to apply attributes to all
the variables that are not parameters.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">field</span></code>: Can be used to apply attributes to non-static member variables
in a record. This includes Objective-C ivars.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">namespace</span></code>: Can be used to apply attributes to <code class="docutils literal notranslate"><span class="pre">namespace</span></code> declarations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">objc_interface</span></code>: Can be used to apply attributes to <code class="docutils literal notranslate"><span class="pre">&#64;interface</span></code>
declarations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">objc_protocol</span></code>: Can be used to apply attributes to <code class="docutils literal notranslate"><span class="pre">&#64;protocol</span></code>
declarations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">objc_category</span></code>: Can be used to apply attributes to category declarations,
including class extensions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">objc_method</span></code>: Can be used to apply attributes to Objective-C methods,
including instance and class methods. Implicit methods like implicit property
getters and setters do not receive the attribute.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">objc_method(is_instance)</span></code>: Can be used to apply attributes to Objective-C
instance methods.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">objc_property</span></code>: Can be used to apply attributes to <code class="docutils literal notranslate"><span class="pre">&#64;property</span></code>
declarations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block</span></code>: Can be used to apply attributes to block declarations. This does
not include variables/fields of block pointer type.</p></li>
</ul>
<p>The use of <code class="docutils literal notranslate"><span class="pre">unless</span></code> in match rules is currently restricted to a strict set of
sub-rules that are used by the supported attributes. That means that even though
<code class="docutils literal notranslate"><span class="pre">variable(unless(is_parameter))</span></code> is a valid match rule,
<code class="docutils literal notranslate"><span class="pre">variable(unless(is_thread_local))</span></code> is not.</p>
</section>
<section id="supported-attributes">
<h3>Supported Attributes<a class="headerlink" href="#supported-attributes" title="Link to this heading">¶</a></h3>
<p>Not all attributes can be used with the <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">attribute</span></code> directive.
Notably, statement attributes like <code class="docutils literal notranslate"><span class="pre">[[fallthrough]]</span></code> or type attributes
like <code class="docutils literal notranslate"><span class="pre">address_space</span></code> aren’t supported by this directive. You can determine
whether or not an attribute is supported by the pragma by referring to the
<a class="reference internal" href="AttributeReference.html"><span class="doc">individual documentation for that attribute</span></a>.</p>
<p>The attributes are applied to all matching declarations individually, even when
the attribute is semantically incorrect. The attributes that aren’t applied to
any declaration are not verified semantically.</p>
</section>
</section>
<section id="specifying-section-names-for-global-objects-pragma-clang-section">
<h2><a class="toc-backref" href="#id53" role="doc-backlink">Specifying section names for global objects (#pragma clang section)</a><a class="headerlink" href="#specifying-section-names-for-global-objects-pragma-clang-section" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">section</span></code> directive provides a means to assign section-names
to global variables, functions and static variables.</p>
<p>The section names can be specified as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang section bss=&quot;myBSS&quot; data=&quot;myData&quot; rodata=&quot;myRodata&quot; relro=&quot;myRelro&quot; text=&quot;myText&quot;</span>
</pre></div>
</div>
<p>The section names can be reverted back to default name by supplying an empty
string to the section kind, for example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma clang section bss=&quot;&quot; data=&quot;&quot; text=&quot;&quot; rodata=&quot;&quot; relro=&quot;&quot;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">section</span></code> directive obeys the following rules:</p>
<ul class="simple">
<li><p>The pragma applies to all global variable, statics and function declarations
from the pragma to the end of the translation unit.</p></li>
<li><p>The pragma clang section is enabled automatically, without need of any flags.</p></li>
<li><p>This feature is only defined to work sensibly for ELF, Mach-O and COFF targets.</p></li>
<li><p>If section name is specified through _attribute_((section(“myname”))), then
the attribute name gains precedence.</p></li>
<li><p>Global variables that are initialized to zero will be placed in the named
bss section, if one is present.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">section</span></code> directive does not try to infer section-kind
from the name. For example, naming a section “<code class="docutils literal notranslate"><span class="pre">.bss.mySec</span></code>” does NOT mean
it will be a bss section name.</p></li>
<li><p>The decision about which section-kind applies to each global is taken in the back-end.
Once the section-kind is known, appropriate section name, as specified by the user using
<code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">section</span></code> directive, is applied to that global.</p></li>
</ul>
</section>
<section id="specifying-linker-options-on-elf-targets">
<h2><a class="toc-backref" href="#id54" role="doc-backlink">Specifying Linker Options on ELF Targets</a><a class="headerlink" href="#specifying-linker-options-on-elf-targets" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">comment(lib,</span> <span class="pre">...)</span></code> directive is supported on all ELF targets.
The second parameter is the library name (without the traditional Unix prefix of
<code class="docutils literal notranslate"><span class="pre">lib</span></code>).  This allows you to provide an implicit link of dependent libraries.</p>
</section>
<section id="evaluating-object-size">
<h2><a class="toc-backref" href="#id55" role="doc-backlink">Evaluating Object Size</a><a class="headerlink" href="#evaluating-object-size" title="Link to this heading">¶</a></h2>
<p>Clang supports the builtins <code class="docutils literal notranslate"><span class="pre">__builtin_object_size</span></code> and
<code class="docutils literal notranslate"><span class="pre">__builtin_dynamic_object_size</span></code>. The semantics are compatible with GCC’s
builtins of the same names, but the details are slightly different.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">size_t</span><span class="w"> </span><span class="n">__builtin_</span><span class="p">[</span><span class="n">dynamic_</span><span class="p">]</span><span class="n">object_size</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">type</span><span class="p">)</span>
</pre></div>
</div>
<p>Returns the number of accessible bytes <code class="docutils literal notranslate"><span class="pre">n</span></code> past <code class="docutils literal notranslate"><span class="pre">ptr</span></code>. The value returned
depends on <code class="docutils literal notranslate"><span class="pre">type</span></code>, which is required to be an integer constant between 0 and
3:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">&amp;</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0</span></code>, the least <code class="docutils literal notranslate"><span class="pre">n</span></code> is returned such that accesses to
<code class="docutils literal notranslate"><span class="pre">(const</span> <span class="pre">char*)ptr</span> <span class="pre">+</span> <span class="pre">n</span></code> and beyond are known to be out of bounds. This is
<code class="docutils literal notranslate"><span class="pre">(size_t)-1</span></code> if no better bound is known.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">&amp;</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">2</span></code>, the greatest <code class="docutils literal notranslate"><span class="pre">n</span></code> is returned such that accesses to
<code class="docutils literal notranslate"><span class="pre">(const</span> <span class="pre">char*)ptr</span> <span class="pre">+</span> <span class="pre">i</span></code> are known to be in bounds, for 0 &lt;= <code class="docutils literal notranslate"><span class="pre">i</span></code> &lt; <code class="docutils literal notranslate"><span class="pre">n</span></code>.
This is <code class="docutils literal notranslate"><span class="pre">(size_t)0</span></code> if no better bound is known.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span><span class="w"> </span><span class="n">small</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span><span class="w"> </span><span class="n">large</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">cond</span><span class="p">;</span>
<span class="c1">// Returns 100: writes of more than 100 bytes are known to be out of bounds.</span>
<span class="kt">int</span><span class="w"> </span><span class="n">n100</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_object_size</span><span class="p">(</span><span class="n">cond</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">small</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">large</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="c1">// Returns 10: writes of 10 or fewer bytes are known to be in bounds.</span>
<span class="kt">int</span><span class="w"> </span><span class="n">n10</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_object_size</span><span class="p">(</span><span class="n">cond</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">small</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">large</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">&amp;</span> <span class="pre">1</span> <span class="pre">==</span> <span class="pre">0</span></code>, pointers are considered to be in bounds if they point
into the same storage as <code class="docutils literal notranslate"><span class="pre">ptr</span></code> – that is, the same stack object, global
variable, or heap allocation.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">&amp;</span> <span class="pre">1</span> <span class="pre">==</span> <span class="pre">1</span></code>, pointers are considered to be in bounds if they point
to the same subobject that <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to. If <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to an array
element, other elements of the same array, but not of enclosing arrays, are
considered in bounds.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">X</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">__builtin_object_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">__builtin_object_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">.</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">__builtin_object_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">.</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">10</span><span class="p">][</span><span class="mi">10</span><span class="p">];</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">__builtin_object_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1000</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">__builtin_object_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">900</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">__builtin_object_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">90</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">__builtin_object_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">9</span><span class="p">);</span>
</pre></div>
</div>
<p>The values returned by this builtin are a best effort conservative approximation
of the correct answers. When <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">&amp;</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0</span></code>, the true value is less than or
equal to the value returned by the builtin, and when <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">&amp;</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">1</span></code>, the true
value is greater than or equal to the value returned by the builtin.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">__builtin_object_size</span></code>, the value is determined entirely at compile time.
With optimization enabled, better results will be produced, especially when the
call to <code class="docutils literal notranslate"><span class="pre">__builtin_object_size</span></code> is in a different function from the formation
of the pointer. Unlike in GCC, enabling optimization in Clang does not allow
more information about subobjects to be determined, so the <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">&amp;</span> <span class="pre">1</span> <span class="pre">==</span> <span class="pre">1</span></code>
case will often give imprecise results when used across a function call boundary
even when optimization is enabled.</p>
<p><a class="reference external" href="https://clang.llvm.org/docs/AttributeReference.html#pass-object-size-pass-dynamic-object-size">The pass_object_size and pass_dynamic_object_size attributes</a>
can be used to invisibly pass the object size for a pointer parameter alongside
the pointer in a function call. This allows more precise object sizes to be
determined both when building without optimizations and in the <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">&amp;</span> <span class="pre">1</span> <span class="pre">==</span> <span class="pre">1</span></code>
case.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">__builtin_dynamic_object_size</span></code>, the result is not limited to being a
compile time constant. Instead, a small amount of runtime evaluation is
permitted to determine the size of the object, in order to give a more precise
result. <code class="docutils literal notranslate"><span class="pre">__builtin_dynamic_object_size</span></code> is meant to be used as a drop-in
replacement for <code class="docutils literal notranslate"><span class="pre">__builtin_object_size</span></code> in libraries that support it. For
instance, here is a program that <code class="docutils literal notranslate"><span class="pre">__builtin_dynamic_object_size</span></code> will make
safer:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">copy_into_buffer</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="w">  </span><span class="n">strlcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;some string&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="s">&quot;some string&quot;</span><span class="p">));</span>
<span class="w">  </span><span class="c1">// Previous line preprocesses to:</span>
<span class="w">  </span><span class="c1">// __builtin___strlcpy_chk(buffer, &quot;some string&quot;, strlen(&quot;some string&quot;), __builtin_object_size(buffer, 0))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since the size of <code class="docutils literal notranslate"><span class="pre">buffer</span></code> can’t be known at compile time, Clang will fold
<code class="docutils literal notranslate"><span class="pre">__builtin_object_size(buffer,</span> <span class="pre">0)</span></code> into <code class="docutils literal notranslate"><span class="pre">-1</span></code>. However, if this was written
as <code class="docutils literal notranslate"><span class="pre">__builtin_dynamic_object_size(buffer,</span> <span class="pre">0)</span></code>, Clang will fold it into
<code class="docutils literal notranslate"><span class="pre">size</span></code>, providing some extra runtime safety.</p>
</section>
<section id="deprecating-macros">
<h2><a class="toc-backref" href="#id56" role="doc-backlink">Deprecating Macros</a><a class="headerlink" href="#deprecating-macros" title="Link to this heading">¶</a></h2>
<p>Clang supports the pragma <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">deprecated</span></code>, which can be used to
provide deprecation warnings for macro uses. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define MIN(x, y) x &lt; y ? x : y</span>
<span class="cp">#pragma clang deprecated(MIN, &quot;use std::min instead&quot;)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">min</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">MIN</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="c1">// warning: MIN is deprecated: use std::min instead</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">deprecated</span></code> should be preferred for this purpose over
<code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">GCC</span> <span class="pre">warning</span></code> because the warning can be controlled with
<code class="docutils literal notranslate"><span class="pre">-Wdeprecated</span></code>.</p>
</section>
<section id="restricted-expansion-macros">
<h2><a class="toc-backref" href="#id57" role="doc-backlink">Restricted Expansion Macros</a><a class="headerlink" href="#restricted-expansion-macros" title="Link to this heading">¶</a></h2>
<p>Clang supports the pragma <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">restrict_expansion</span></code>, which can be
used restrict macro expansion in headers. This can be valuable when providing
headers with ABI stability requirements. Any expansion of the annotated macro
processed by the preprocessor after the <code class="docutils literal notranslate"><span class="pre">#pragma</span></code> annotation will log a
warning. Redefining the macro or undefining the macro will not be diagnosed, nor
will expansion of the macro within the main source file. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define TARGET_ARM 1</span>
<span class="cp">#pragma clang restrict_expansion(TARGET_ARM, &quot;&lt;reason&gt;&quot;)</span>

<span class="c1">/// Foo.h</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#if TARGET_ARM </span><span class="c1">// warning: TARGET_ARM is marked unsafe in headers: &lt;reason&gt;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">X</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">X</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="c1">/// main.c</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;foo.h&quot;</span>
<span class="cp">#if TARGET_ARM </span><span class="c1">// No warning in main source file</span>
<span class="n">X_TYPE</span><span class="w"> </span><span class="kt">uint32_t</span>
<span class="cp">#else</span>
<span class="n">X_TYPE</span><span class="w"> </span><span class="kt">uint64_t</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>This warning is controlled by <code class="docutils literal notranslate"><span class="pre">-Wpedantic-macros</span></code>.</p>
</section>
<section id="final-macros">
<h2><a class="toc-backref" href="#id58" role="doc-backlink">Final Macros</a><a class="headerlink" href="#final-macros" title="Link to this heading">¶</a></h2>
<p>Clang supports the pragma <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">clang</span> <span class="pre">final</span></code>, which can be used to
mark macros as final, meaning they cannot be undef’d or re-defined. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define FINAL_MACRO 1</span>
<span class="cp">#pragma clang final(FINAL_MACRO)</span>

<span class="cp">#define FINAL_MACRO </span><span class="c1">// warning: FINAL_MACRO is marked final and should not be redefined</span>
<span class="cp">#undef FINAL_MACRO  </span><span class="c1">// warning: FINAL_MACRO is marked final and should not be undefined</span>
</pre></div>
</div>
<p>This is useful for enforcing system-provided macros that should not be altered
in user headers or code. This is controlled by <code class="docutils literal notranslate"><span class="pre">-Wpedantic-macros</span></code>. Final
macros will always warn on redefinition, including situations with identical
bodies and in system headers.</p>
</section>
<section id="line-control">
<h2><a class="toc-backref" href="#id59" role="doc-backlink">Line Control</a><a class="headerlink" href="#line-control" title="Link to this heading">¶</a></h2>
<p>Clang supports an extension for source line control, which takes the
form of a preprocessor directive starting with an unsigned integral
constant. In addition to the standard <code class="docutils literal notranslate"><span class="pre">#line</span></code> directive, this form
allows control of an include stack and header file type, which is used
in issuing diagnostics. These lines are emitted in preprocessed
output.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp"># &lt;line:number&gt; &lt;filename:string&gt; &lt;header-type:numbers&gt;</span>
</pre></div>
</div>
<p>The filename is optional, and if unspecified indicates no change in
source filename. The header-type is an optional, whitespace-delimited,
sequence of magic numbers as follows.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Push the current source file name onto the include stack and
enter a new file.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2</span></code>: Pop the include stack and return to the specified file. If
the filename is <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>, the name popped from the include stack is
used. Otherwise there is no requirement that the specified filename
matches the current source when originally pushed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3</span></code>: Enter a system-header region. System headers often contain
implementation-specific source that would normally emit a diagnostic.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">4</span></code>: Enter an implicit <code class="docutils literal notranslate"><span class="pre">extern</span> <span class="pre">&quot;C&quot;</span></code> region. This is not required on
modern systems where system headers are C++-aware.</p></li>
</ul>
<p>At most a single <code class="docutils literal notranslate"><span class="pre">1</span></code> or <code class="docutils literal notranslate"><span class="pre">2</span></code> can be present, and values must be in
ascending order.</p>
<p>Examples are:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp"># 57 </span><span class="c1">// Advance (or return) to line 57 of the current source file</span>
<span class="cp"># 57 &quot;frob&quot; </span><span class="c1">// Set to line 57 of &quot;frob&quot;</span>
<span class="cp"># 1 &quot;foo.h&quot; 1 </span><span class="c1">// Enter &quot;foo.h&quot; at line 1</span>
<span class="cp"># 59 &quot;main.c&quot; 2 </span><span class="c1">// Leave current include and return to &quot;main.c&quot;</span>
<span class="cp"># 1 &quot;/usr/include/stdio.h&quot; 1 3 </span><span class="c1">// Enter a system header</span>
<span class="cp"># 60 &quot;&quot; 2 </span><span class="c1">// return to &quot;main.c&quot;</span>
<span class="cp"># 1 &quot;/usr/ancient/header.h&quot; 1 4 </span><span class="c1">// Enter an implicit extern &quot;C&quot; header</span>
</pre></div>
</div>
</section>
<section id="intrinsics-support-within-constant-expressions">
<h2><a class="toc-backref" href="#id60" role="doc-backlink">Intrinsics Support within Constant Expressions</a><a class="headerlink" href="#intrinsics-support-within-constant-expressions" title="Link to this heading">¶</a></h2>
<p>The following builtin intrinsics can be used in constant expressions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_addcb</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_addcs</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_addc</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_addcl</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_addcll</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_bitreverse8</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_bitreverse16</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_bitreverse32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_bitreverse64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_bswap16</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_bswap32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_bswap64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_clrsb</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_clrsbl</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_clrsbll</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_clz</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_clzl</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_clzll</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_clzs</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_clzg</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_ctz</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_ctzl</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_ctzll</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_ctzs</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_ctzg</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_ffs</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_ffsl</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_ffsll</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_fmax</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_fmin</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_fpclassify</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_inf</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_isinf</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_isinf_sign</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_isfinite</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_isnan</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_isnormal</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_nan</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_nans</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_parity</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_parityl</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_parityll</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_popcount</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_popcountl</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_popcountll</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_popcountg</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateleft8</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateleft16</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateleft32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateleft64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateright8</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateright16</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateright32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_rotateright64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_subcb</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_subcs</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_subc</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_subcl</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__builtin_subcll</span></code></p></li>
</ul>
<p>The following x86-specific intrinsics can be used in constant expressions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">_addcarry_u32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_addcarry_u64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_bit_scan_forward</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_bit_scan_reverse</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__bsfd</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__bsfq</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__bsrd</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__bsrq</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__bswap</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__bswapd</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__bswap64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__bswapq</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_castf32_u32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_castf64_u64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_castu32_f32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_castu64_f64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__lzcnt16</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__lzcnt</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__lzcnt64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_mm_popcnt_u32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_mm_popcnt_u64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_popcnt32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_popcnt64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__popcntd</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__popcntq</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__popcnt16</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__popcnt</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__popcnt64</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rolb</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rolw</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rold</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rolq</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rorb</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rorw</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rord</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__rorq</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_rotl</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_rotr</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_rotwl</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_rotwr</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_lrotl</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_lrotr</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_subborrow_u32</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_subborrow_u64</span></code></p></li>
</ul>
</section>
<section id="debugging-the-compiler">
<h2><a class="toc-backref" href="#id61" role="doc-backlink">Debugging the Compiler</a><a class="headerlink" href="#debugging-the-compiler" title="Link to this heading">¶</a></h2>
<p>Clang supports a number of pragma directives that help debugging the compiler itself.
Syntax is the following: <cite>#pragma clang __debug &lt;command&gt; &lt;arguments&gt;</cite>.
Note, all of debugging pragmas are subject to change.</p>
<section id="dump">
<h3><cite>dump</cite><a class="headerlink" href="#dump" title="Link to this heading">¶</a></h3>
<p>Accepts either a single identifier or an expression. When a single identifier is passed,
the lookup results for the identifier are printed to <cite>stderr</cite>. When an expression is passed,
the AST for the expression is printed to <cite>stderr</cite>. The expression is an unevaluated operand,
so things like overload resolution and template instantiations are performed,
but the expression has no runtime effects.
Type- and value-dependent expressions are not supported yet.</p>
<p>This facility is designed to aid with testing name lookup machinery.</p>
</section>
</section>
<section id="predefined-macros">
<h2><a class="toc-backref" href="#id62" role="doc-backlink">Predefined Macros</a><a class="headerlink" href="#predefined-macros" title="Link to this heading">¶</a></h2>
<section id="gcc-destructive-size-and-gcc-constructive-size">
<h3><cite>__GCC_DESTRUCTIVE_SIZE</cite> and <cite>__GCC_CONSTRUCTIVE_SIZE</cite><a class="headerlink" href="#gcc-destructive-size-and-gcc-constructive-size" title="Link to this heading">¶</a></h3>
<p>Specify the mimum offset between two objects to avoid false sharing and the
maximum size of contiguous memory to promote true sharing, respectively. These
macros are predefined in all C and C++ language modes, but can be redefined on
the command line with <code class="docutils literal notranslate"><span class="pre">-D</span></code> to specify different values as needed or can be
undefined on the command line with <code class="docutils literal notranslate"><span class="pre">-U</span></code> to disable support for the feature.</p>
<p><strong>Note: the values the macros expand to are not guaranteed to be stable. They
are are affected by architectures and CPU tuning flags, can change between
releases of Clang and will not match the values defined by other compilers such
as GCC.</strong></p>
<p>Compiling different TUs depending on these flags (including use of
<code class="docutils literal notranslate"><span class="pre">std::hardware_constructive_interference</span></code> or
<code class="docutils literal notranslate"><span class="pre">std::hardware_destructive_interference</span></code>)  with different compilers, macro
definitions, or architecture flags will lead to ODR violations and should be
avoided.</p>
</section>
</section>
<section id="embed-parameters">
<h2><a class="toc-backref" href="#id63" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">#embed</span></code> Parameters</a><a class="headerlink" href="#embed-parameters" title="Link to this heading">¶</a></h2>
<section id="clang-offset">
<h3><code class="docutils literal notranslate"><span class="pre">clang::offset</span></code><a class="headerlink" href="#clang-offset" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">clang::offset</span></code> embed parameter may appear zero or one time in the
embed parameter sequence. Its preprocessor argument clause shall be present and
have the form:</p>
<p>..code-block: text</p>
<blockquote>
<div><p>( constant-expression )</p>
</div></blockquote>
<p>and shall be an integer constant expression. The integer constant expression
shall not evaluate to a value less than 0. The token <code class="docutils literal notranslate"><span class="pre">defined</span></code> shall not
appear within the constant expression.</p>
<p>The offset will be used when reading the contents of the embedded resource to
specify the starting offset to begin embedding from. The resources is treated
as being empty if the specified offset is larger than the number of bytes in
the resource. The offset will be applied <em>before</em> any <code class="docutils literal notranslate"><span class="pre">limit</span></code> parameters are
applied.</p>
</section>
</section>
<section id="union-and-aggregate-initialization-in-c">
<h2><a class="toc-backref" href="#id64" role="doc-backlink">Union and aggregate initialization in C</a><a class="headerlink" href="#union-and-aggregate-initialization-in-c" title="Link to this heading">¶</a></h2>
<p>In C23 (N2900), when an object is initialized from initializer <code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">{}</span></code>, all
elements of arrays, all members of structs, and the first members of unions are
empty-initialized recursively. In addition, all padding bits are initialized to
zero.</p>
<p>Clang guarantees the following behaviors:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Clang supports initializer <code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">{}</span></code> mentioned above in all C
standards.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> When unions are initialized from initializer <code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">{}</span></code>, bytes outside
of the first members of unions are also initialized to zero.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> When unions, structures and arrays are initialized from initializer
<code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">{</span> <span class="pre">initializer-list</span> <span class="pre">}</span></code>, all members not explicitly initialized in
the initializer list are empty-initialized recursively. In addition, all
padding bits are initialized to zero.</p></li>
</ul>
<p>Currently, the above extension only applies to C source code, not C++.</p>
</section>
<section id="empty-objects-in-c">
<h2><a class="toc-backref" href="#id65" role="doc-backlink">Empty Objects in C</a><a class="headerlink" href="#empty-objects-in-c" title="Link to this heading">¶</a></h2>
<p>The declaration of a structure or union type which has no named members is
undefined behavior (C23 and earlier) or implementation-defined behavior (C2y).
Clang allows the declaration of a structure or union type with no named members
in all C language modes. <cite>sizeof</cite> for such a type returns <cite>0</cite>, which is
different behavior than in C++ (where the size of such an object is typically
<cite>1</cite>).</p>
</section>
<section id="qualified-function-types-in-c">
<h2><a class="toc-backref" href="#id66" role="doc-backlink">Qualified function types in C</a><a class="headerlink" href="#qualified-function-types-in-c" title="Link to this heading">¶</a></h2>
<p>Declaring a function with a qualified type in C is undefined behavior (C23 and
earlier) or implementation-defined behavior (C2y). Clang allows a function type
to be specified with the <code class="docutils literal notranslate"><span class="pre">const</span></code> and <code class="docutils literal notranslate"><span class="pre">volatile</span></code> qualifiers, but ignores the
qualifications.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">func</span><span class="p">;</span><span class="w"> </span><span class="c1">// Qualifier on function type has no effect.</span>
</pre></div>
</div>
<p>Note, Clang does not allow an <code class="docutils literal notranslate"><span class="pre">_Atomic</span></code> function type because
of explicit constraints against atomically qualified (arrays and) function
types.</p>
</section>
<section id="underspecified-object-declarations-in-c">
<h2><a class="toc-backref" href="#id67" role="doc-backlink">Underspecified Object Declarations in C</a><a class="headerlink" href="#underspecified-object-declarations-in-c" title="Link to this heading">¶</a></h2>
<p>C23 introduced the notion of <a class="reference external" href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3006.htm">underspecified object declarations</a>
(note, the final standards text is different from WG14 N3006 due to changes
during national body comment review). When an object is declared with the
<code class="docutils literal notranslate"><span class="pre">constexpr</span></code> storage class specifier or has a deduced type (with the <code class="docutils literal notranslate"><span class="pre">auto</span></code>
specifier), it is said to be “underspecified”. Underspecified declarations have
different requirements than non-underspecified declarations. In particular, the
identifier being declared cannot be used in its initialization. e.g.,</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// Invalid</span>
<span class="n">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="c1">// Invalid</span>
</pre></div>
</div>
<p>The standard leaves it implementation-defined whether an underspecified
declaration may introduce additional identifiers as part of the declaration.</p>
<p>Clang allows additional identifiers to be declared in the following cases:</p>
<ul class="simple">
<li><p>A compound literal may introduce a new type. e.g.,</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="p">}){</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">      </span><span class="c1">// Accepted by Clang</span>
<span class="n">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="p">}){</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">}.</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// Accepted by Clang</span>
</pre></div>
</div>
<ul class="simple">
<li><p>The type specifier for a <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> declaration may define a new type.
e.g.,</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">constexpr</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// Accepted by Clang</span>
</pre></div>
</div>
<ul class="simple">
<li><p>A function declarator may be declared with parameters, including parameters
which introduce a new type. e.g.,</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">constexpr</span><span class="w"> </span><span class="nf">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span><span class="w">              </span><span class="c1">// Accepted by Clang</span>
<span class="k">auto</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="n">s</span><span class="p">))</span><span class="n">nullptr</span><span class="p">;</span><span class="w"> </span><span class="c1">// Accepted by Clang</span>
</pre></div>
</div>
<ul class="simple">
<li><p>The initializer may contain a GNU statement expression which defines new
types or objects. e.g.,</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">({</span><span class="w">                              </span><span class="c1">// Accepted by Clang</span>
<span class="w">  </span><span class="n">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span>
<span class="w">  </span><span class="n">constexpr</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="n">s</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="p">});</span>
<span class="k">auto</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">({</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"> </span><span class="p">});</span><span class="w"> </span><span class="c1">// Accepted by Clang</span>
</pre></div>
</div>
<p>Clang intentionally does not implement the changed scoping rules from C23
for underspecified declarations. Doing so would significantly complicate the
implementation in order to get reasonable diagnostic behavior and also means
Clang fails to reject some code that should be rejected. e.g.,</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// This should be rejected because &#39;x&#39; is not in scope within the initializer</span>
<span class="c1">// of an underspecified declaration. Clang accepts because it treats the scope</span>
<span class="c1">// of the identifier as beginning immediately after the declarator, same as with</span>
<span class="c1">// a non-underspecified declaration.</span>
<span class="n">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="c1">// Clang rejects this code with a diagnostic about using the variable within its</span>
<span class="c1">// own initializer rather than rejecting the code with an undeclared identifier</span>
<span class="c1">// diagnostic.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
</pre></div>
</div>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="Toolchain.html">Assembling a Complete Toolchain</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="ObjectiveCLiterals.html">Objective-C Literals</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2007-2025, The Clang Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>