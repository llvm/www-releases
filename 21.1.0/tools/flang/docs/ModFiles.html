<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Module Files &#8212; The Flang Compiler</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=e491ac2d" />
    <script src="_static/documentation_options.js?v=1d8edcb3"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="OpenACC in Flang" href="OpenACC.html" />
    <link rel="prev" title="Semantics: Resolving Labels and Construct Names" href="LabelResolution.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>The Flang Compiler</span></a></h1>
        <h2 class="heading"><span>Module Files</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="LabelResolution.html">Semantics: Resolving Labels and Construct Names</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="OpenACC.html">OpenACC in Flang</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <!--===- docs/ModFiles.md 
  
   Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
   See https://llvm.org/LICENSE.txt for license information.
   SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
  
-->
<section id="module-files">
<h1>Module Files<a class="headerlink" href="#module-files" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#name" id="id1">Name</a></p></li>
<li><p><a class="reference internal" href="#format" id="id2">Format</a></p>
<ul>
<li><p><a class="reference internal" href="#header" id="id3">Header</a></p></li>
<li><p><a class="reference internal" href="#body" id="id4">Body</a></p>
<ul>
<li><p><a class="reference internal" href="#symbols-included" id="id5">Symbols included</a></p></li>
<li><p><a class="reference internal" href="#use-association" id="id6">USE association</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#reading-and-writing-module-files" id="id7">Reading and writing module files</a></p>
<ul>
<li><p><a class="reference internal" href="#options" id="id8">Options</a></p></li>
<li><p><a class="reference internal" href="#writing-module-files" id="id9">Writing module files</a></p></li>
<li><p><a class="reference internal" href="#reading-module-files" id="id10">Reading module files</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#error-messages-referring-to-modules" id="id11">Error messages referring to modules</a></p></li>
<li><p><a class="reference internal" href="#hermetic-modules-files" id="id12">Hermetic modules files</a></p></li>
</ul>
</nav>
<p>Module files hold information from a module (or submodule) that is
necessary to compile program units in other source files that depend on that module.
Program units in the same source file as the module do not read
module files, as this compiler parses entire source files and processes
the program units it contains in dependency order.</p>
<section id="name">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">Name</a><a class="headerlink" href="#name" title="Link to this heading">¶</a></h2>
<p>Module files are named according to the module’s name, suffixed with <code class="docutils literal notranslate"><span class="pre">.mod</span></code>.
This is consistent with other compilers and expected by makefiles and
other build systems.</p>
<p>Module files for submodules are named with their ancestor module’s name
as a prefix, separated by a hyphen.
E.g., <code class="docutils literal notranslate"><span class="pre">module-submod.mod</span></code> is generated for submodule <code class="docutils literal notranslate"><span class="pre">submod'</span> <span class="pre">of</span> <span class="pre">module</span> </code>module`.
Some other compilers use a distinct filename suffix for submodules,
but this one doesn’t.</p>
<p>The disadvantage of using the same name as other compilers is that it is not
clear which compiler created a <code class="docutils literal notranslate"><span class="pre">.mod</span></code> file and files from multiple compilers
cannot be in the same directory. This can be solved by adding something
between the module name and extension, e.g. <code class="docutils literal notranslate"><span class="pre">&lt;modulename&gt;-f18.mod</span></code>.  When
this is needed, Flang accepts the option <code class="docutils literal notranslate"><span class="pre">-module-suffix</span></code> to alter the suffix.</p>
</section>
<section id="format">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Format</a><a class="headerlink" href="#format" title="Link to this heading">¶</a></h2>
<p>Module files are Fortran free form source code.
(One can, in principle, copy <code class="docutils literal notranslate"><span class="pre">foo.mod</span></code> into <code class="docutils literal notranslate"><span class="pre">tmp.f90</span></code>, recompile it,
and obtain a matching <code class="docutils literal notranslate"><span class="pre">foo.mod</span></code> file.)
They include the declarations of all visible locally defined entities along
with the private entities on which they depend.</p>
<section id="header">
<h3><a class="toc-backref" href="#id3" role="doc-backlink">Header</a><a class="headerlink" href="#header" title="Link to this heading">¶</a></h3>
<p>Module files begin with a UTF-8 byte order mark and a few lines of
Fortran comments.
(Pro tip: use <code class="docutils literal notranslate"><span class="pre">dd</span> <span class="pre">if=foo.mod</span> <span class="pre">bs=1</span> <span class="pre">skip=3</span> <span class="pre">2&gt;/dev/null</span></code> to skip the byte order
mark and dump the rest of the module.)
The first comment begins <code class="docutils literal notranslate"><span class="pre">!mod$</span></code> and contains a version number
and hash code.
Further <code class="docutils literal notranslate"><span class="pre">!need$</span></code> comments contain the names and hash codes of other modules
on which this module depends, and whether those modules are intrinsic
or not to Fortran.</p>
<p>The header comments do not contain timestamps or original source file paths.</p>
</section>
<section id="body">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">Body</a><a class="headerlink" href="#body" title="Link to this heading">¶</a></h3>
<p>The body comprises minimal Fortran source for the required declarations.
Their order generally matches the order they appeared in the original
source code for the module.
All types are explicit, and all non-character literal constants are
marked with explicit kind values.</p>
<p>Declarations of objects, interfaces, types, and other entities are
regenerated from the compiler’s symbol table.
So entity declarations that spanned multiple statements in the source
program are effectively collapsed into a single <em>type-declaration-statement</em>.
Constant expressions that appear in initializers, bounds, and other sites
appear in the module file as their folded values.
Any compiler directives (<code class="docutils literal notranslate"><span class="pre">!omp$</span></code>, <code class="docutils literal notranslate"><span class="pre">!acc$</span></code>, &amp;c.) relevant to the declarations
of names are also included in the module file.</p>
<p>Executable statements are omitted.
If we ever want to do Fortran-level inline expansion of procedures
in the future,
we will have to “unparse” the executable parts of their definitions.</p>
<section id="symbols-included">
<h4><a class="toc-backref" href="#id5" role="doc-backlink">Symbols included</a><a class="headerlink" href="#symbols-included" title="Link to this heading">¶</a></h4>
<p>All public symbols from the module are included.</p>
<p>In addition, some private symbols are needed:</p>
<ul class="simple">
<li><p>private types that appear in the public API</p></li>
<li><p>private components of non-private derived types</p></li>
<li><p>private parameters used in non-private declarations (initial values, kind parameters)</p></li>
</ul>
</section>
<section id="use-association">
<h4><a class="toc-backref" href="#id6" role="doc-backlink">USE association</a><a class="headerlink" href="#use-association" title="Link to this heading">¶</a></h4>
<p>Entities that have been included in a module by means of USE association
are represented in the module file with <code class="docutils literal notranslate"><span class="pre">USE</span></code> statements.
Name aliases are sometimes necessary when an entity from another
module is needed for a declaration and conflicts with another
entity of the same name, or is <code class="docutils literal notranslate"><span class="pre">PRIVATE</span></code>.
These aliases have currency symbols (<code class="docutils literal notranslate"><span class="pre">$</span></code>) in them.
When a module
is parsed from a module file, no error is emitted for associating
such an alias with a <code class="docutils literal notranslate"><span class="pre">PRIVATE</span></code> name.
A module parsed from another source file that is not a module file
(notably, the output of the <code class="docutils literal notranslate"><span class="pre">-fdebug-unparse-with-modules</span></code> option)
will emit only warnings.</p>
</section>
</section>
</section>
<section id="reading-and-writing-module-files">
<h2><a class="toc-backref" href="#id7" role="doc-backlink">Reading and writing module files</a><a class="headerlink" href="#reading-and-writing-module-files" title="Link to this heading">¶</a></h2>
<section id="options">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Options</a><a class="headerlink" href="#options" title="Link to this heading">¶</a></h3>
<p>The compiler has command-line options to specify where to search
for module files and where to write them. By default it will be the current
directory for both.</p>
<p><code class="docutils literal notranslate"><span class="pre">-I</span></code> specifies directories to search for include files and module
files.
<code class="docutils literal notranslate"><span class="pre">-J</span></code>, and its alias <code class="docutils literal notranslate"><span class="pre">-module-dir</span></code>, specify a directory into which module files are written
as well as to search for them.</p>
<p><code class="docutils literal notranslate"><span class="pre">-fintrinsic-modules-path</span></code> is available to specify an alternative location
for Fortran’s intrinsic modules.</p>
</section>
<section id="writing-module-files">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">Writing module files</a><a class="headerlink" href="#writing-module-files" title="Link to this heading">¶</a></h3>
<p>When writing a module file, if the existing one matches what would be written,
the timestamp is not updated.</p>
<p>Module files are written only after semantic analysis completes without
a fatal error message.</p>
</section>
<section id="reading-module-files">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Reading module files</a><a class="headerlink" href="#reading-module-files" title="Link to this heading">¶</a></h3>
<p>When the compiler finds a <code class="docutils literal notranslate"><span class="pre">.mod</span></code> file it needs to read, it firsts checks the first
line and verifies it is a valid module file.
The header checksum must match the file’s contents.
(Pro tip: if a developer needs to hack the contents of a module file, they can
recompile it afterwards as Fortran source to regenerate it with its new hash.)</p>
<p>The known hashes of dependent modules are used to disambiguate modules whose
names match module files in multiple search directories, as well as to
detect dependent modules whose recompilation has rendered a module file
obsolete.</p>
<p>The hash codes used in module files also serve as a means of protection from
updates to code in other packages.
If a project A uses module files from package B, and package B is updated in
a way that causes its module files to be updated, then the modules in A that
depend on those modules in B will no longer be accepted for use until they
have also been regenerated.
This feature can catch errors that other compilers cannot.</p>
<p>When processing <code class="docutils literal notranslate"><span class="pre">.mod</span></code> files we know they are valid Fortran with these properties:</p>
<ol class="arabic simple">
<li><p>The input (without the header) is already in the “cooked input” format.</p></li>
<li><p>No preprocessing is necessary.</p></li>
<li><p>No errors can occur.</p></li>
</ol>
</section>
</section>
<section id="error-messages-referring-to-modules">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Error messages referring to modules</a><a class="headerlink" href="#error-messages-referring-to-modules" title="Link to this heading">¶</a></h2>
<p>With this design, diagnostics can refer to names in modules and can emit a
normalized declaration of an entity.</p>
</section>
<section id="hermetic-modules-files">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">Hermetic modules files</a><a class="headerlink" href="#hermetic-modules-files" title="Link to this heading">¶</a></h2>
<p>Top-level module files for libraries can be build with <code class="docutils literal notranslate"><span class="pre">-fhermetic-module-files</span></code>.
This option causes these module files to contain copies of all of the non-intrinsic
modules on which they depend, so that non-top-level local modules and the
modules of dependent libraries need not also be packaged with the library.
When the compiler reads a hermetic module file, the copies of the dependent
modules are read into their own scope, and will not conflict with other modules
of the same name that client code might <code class="docutils literal notranslate"><span class="pre">USE</span></code>.</p>
<p>One can use the <code class="docutils literal notranslate"><span class="pre">-fhermetic-module-files</span></code> option when building the top-level
module files of a library for which not all of the implementation modules
will (or can) be shipped.</p>
<p>It is also possible to convert a default module file to a hermetic one after
the fact.
Since module files are Fortran source, simply copy the module file to a new
temporary free form Fortran source file and recompile it (<code class="docutils literal notranslate"><span class="pre">-fsyntax-only</span></code>)
with the <code class="docutils literal notranslate"><span class="pre">-fhermetic-module-files</span></code> flag, and that will regenerate the module
file in place with all of its dependent modules included.</p>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="LabelResolution.html">Semantics: Resolving Labels and Construct Names</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="OpenACC.html">OpenACC in Flang</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2017-2025, The Flang Team.
      Last updated on Aug 26, 2025.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>