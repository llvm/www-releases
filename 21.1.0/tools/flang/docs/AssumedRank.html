<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Assumed-Rank Objects &#8212; The Flang Compiler</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=e491ac2d" />
    <script src="_static/documentation_options.js?v=1d8edcb3"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Bijective Internal Name Uniquing" href="BijectiveInternalNameUniquing.html" />
    <link rel="prev" title="Assumed-shape arrays repacking" href="ArrayRepacking.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>The Flang Compiler</span></a></h1>
        <h2 class="heading"><span>Assumed-Rank Objects</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="ArrayRepacking.html">Assumed-shape arrays repacking</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="BijectiveInternalNameUniquing.html">Bijective Internal Name Uniquing</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <!--===- docs/AssumedRank.md

   Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
   See https://llvm.org/LICENSE.txt for license information.
   SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

-->
<section id="assumed-rank-objects">
<h1>Assumed-Rank Objects<a class="headerlink" href="#assumed-rank-objects" title="Link to this heading">¶</a></h1>
<p>An assumed-rank dummy data object is a dummy argument that takes its rank from
its effective argument. It is a dummy argument, or the associated entity of a
SELECT RANK in the <code class="docutils literal notranslate"><span class="pre">RANK</span> <span class="pre">DEFAULT</span></code> block. Its rank is not known at compile
time. The rank can be anything from 0 (scalar) to the maximum allowed rank in
Fortran (currently 15 according to Fortran 2018 standard section 5.4.6 point
1).</p>
<p>This document summarizes the contexts where assumed-rank objects can appear,
and then describes how they are implemented and lowered to HLFIR and FIR. All
section references are made to the Fortran 2018 standard.</p>
<section id="fortran-standard-references">
<h2>Fortran Standard References<a class="headerlink" href="#fortran-standard-references" title="Link to this heading">¶</a></h2>
<p>Here is a list of sections and constraints from the Fortran standard involving
assumed-ranks.</p>
<ul class="simple">
<li><p>7.3.2.2 TYPE</p>
<ul>
<li><p>C711</p></li>
</ul>
</li>
<li><p>7.5.6.1 FINAL statement</p>
<ul>
<li><p>C789</p></li>
</ul>
</li>
<li><p>8.5.7 CONTIGUOUS attribute</p>
<ul>
<li><p>C830</p></li>
</ul>
</li>
<li><p>8.5.8 DIMENSION attribute</p></li>
<li><p>8.5.8.7 Assumed-rank entity</p>
<ul>
<li><p>C837</p></li>
<li><p>C838</p></li>
<li><p>C839</p></li>
</ul>
</li>
<li><p>11.1.10 SELECT RANK</p></li>
<li><p>15.5.2.13 Restrictions on entities associated with dummy arguments</p>
<ul>
<li><p>1 (3) (b) and (c)</p></li>
<li><p>1 (4) (b) and (c)</p></li>
</ul>
</li>
<li><p>15.5.2.4 Ordinary dummy variables - point 17</p></li>
<li><p>18 Interoperability with C</p>
<ul>
<li><p>18.3.6 point 2 (5)</p></li>
</ul>
</li>
</ul>
<section id="summary-of-the-constraints">
<h3>Summary of the constraints:<a class="headerlink" href="#summary-of-the-constraints" title="Link to this heading">¶</a></h3>
<p>Assumed-rank can:</p>
<ul class="simple">
<li><p>be pointers, allocatables (or have neither of those atttributes).</p></li>
<li><p>be monomorphic or polymorphic (both <code class="docutils literal notranslate"><span class="pre">TYPE(*)</span></code> and <code class="docutils literal notranslate"><span class="pre">CLASS(*)</span></code>)</p></li>
<li><p>have all the attributes, except VALUE and CODIMENSION (C837). Notably, they
can have the CONTIGUOUS or OPTIONAL attributes (C830).</p></li>
<li><p>appear as an actual argument of an assumed-rank dummy (C838)</p></li>
<li><p>appear as the selector of SELECT RANK (C838)</p></li>
<li><p>appear as the argument of C_LOC and C_SIZEOF from ISO_C_BINDING (C838)</p></li>
<li><p>appear as the first argument of inquiry intrinsic functions (C838). These
inquiry functions listed in table 16.1 are detailed in the “Assumed-rank
features” section below.</p></li>
<li><p>appear in BIND(C) and non BIND(C interface (18.1 point 3)</p></li>
<li><p>be finalized on entry as INTENT(OUT) under some conditions that prevents the
assumed-rank to be associated with an assumed-size.</p></li>
<li><p>be associated with any kind of scalars and arrays, including assumed-size.</p></li>
</ul>
<p>Assumed-rank cannot:</p>
<ul class="simple">
<li><p>be coarrays (C837)</p></li>
<li><p>have the VALUE attribute (C837)</p></li>
<li><p>be something that is not a named variable (they cannot be the result of a
function or a component reference)</p></li>
<li><p>appear in a designator other than the case listed above (C838). Notably, they
cannot be directly addressed, they cannot be used in elemental operations or
transformational intrinsics, they cannot be used in IO, they cannot be
assigned to….</p></li>
<li><p>be finalized on entry as INTENT(OUT) if it could be associated with an
assumed-size (C839).</p></li>
<li><p>be used in a reference to a procedure without an explicit interface
(15.4.2.2. point 3 (c)).</p></li>
</ul>
<p>With regard to aliasing, assumed-rank dummy objects follow the same rules as
for assumed shapes, with the addition of 15.5.2.13 (c) which adds a rule when
the actual is a scalar (adding that TARGET assumed-rank may alias if the actual
argument is a scalar even if they have the CONTIGUOUS attribute, while it is OK
to assume that CONTIGUOUS TARGET assumed shape do not alias with other
dummies).</p>
</section>
</section>
<hr class="docutils" />
<section id="assumed-rank-representations-in-flang">
<h2>Assumed-Rank Representations in Flang<a class="headerlink" href="#assumed-rank-representations-in-flang" title="Link to this heading">¶</a></h2>
<section id="representation-in-semantics">
<h3>Representation in Semantics<a class="headerlink" href="#representation-in-semantics" title="Link to this heading">¶</a></h3>
<p>In semantics (there is no concept of assumed-rank expression needed in
<code class="docutils literal notranslate"><span class="pre">evaluate::Expr</span></code>). Such symbols have either <code class="docutils literal notranslate"><span class="pre">semantics::ObjectEntityDetails</span></code> (
dummy data objects) with a <code class="docutils literal notranslate"><span class="pre">semantics::ArraySpec</span></code> that encodes the
“assumed-rank-shape” (can be tested with IsAssumedRank()), or they have
<code class="docutils literal notranslate"><span class="pre">semantics::AssocEntityDetails</span></code> (associated entity in the RANK DEFAULT case).</p>
<p>Inside a select rank, a <code class="docutils literal notranslate"><span class="pre">semantics::Symbol</span></code> is created for the associated
entity with <code class="docutils literal notranslate"><span class="pre">semantics::AssocEntityDetails</span></code> that points to the the selector
and holds the rank outside of the RANK DEFAULT case.</p>
<p>Assumed-rank dummies are also represented in the
<code class="docutils literal notranslate"><span class="pre">evaluate::characteristics::TypeAndShape</span></code> (with the AssumedRank attribute) to
represent assumed-rank in procedure characteristics.</p>
</section>
<section id="runtime-representation-of-assumed-ranks">
<h3>Runtime Representation of Assumed-Ranks<a class="headerlink" href="#runtime-representation-of-assumed-ranks" title="Link to this heading">¶</a></h3>
<p>Assumed-ranks are implemented as CFI_cdesc_t (18.5.3) with the addition of an
f18 specific addendum when required for the type. This is the usual f18
descriptor, and no changes is required to represent assumed-ranks in this data
structure. In fact, there is no difference between the runtime descriptor
created for an assumed shape and the runtime descriptor created when the
corresponding entity is passed as an assumed-rank.</p>
<p>This means that any descriptor can be passed to an assumed-rank dummy (with
care to ensure that the POINTER/ALLOCATABLE attribute match the dummy argument
attributes as usual). Notably, any runtime interface that takes descriptor
arguments of any ranks already work with assumed-rank entities without any
changes or special cases.</p>
<p>This also implies that the runtime cannot tell that an entity is an
assumed-rank based on its descriptor, but there seems to be not need for this
so far (“rank based” dispatching for user defined assignments and IO is not
possible with assumed-ranks, and finalization is possible, but there is no need
for the runtime to distinguish between finalization of an assumed-rank and
finalization of other entities: only the runtime rank matters).</p>
<p>The only difference and difficulty is that descriptor storage size of
assumed-rank cannot be precisely known at compile time, and this impacts the
way descriptor copies are generated in inline code. The size can still be
maximized using the maximum rank, which the runtime code already does when
creating temporary descriptor in many cases. Inline code also needs care if it
needs to access the descriptor addendum (like the type descriptor), since its
offset will not be a compile time constant as usual.</p>
<p>Note that an alternative to maximizing the allocation of assumed-rank temporary
descriptor could be to use automatic allocation based on the rank of the input
descriptor, but this would make stack allocation analysis more complex (tools
will likely not have the Fortran knowledge that this allocation size is bounded
for instance) while the stack “over” allocation is likely reasonable (24 bytes
per dimension). Hence the selection of the simple approach using static size
allocation to the maximum rank.</p>
</section>
<section id="representation-in-fir-and-hlfir">
<h3>Representation in FIR and HLFIR<a class="headerlink" href="#representation-in-fir-and-hlfir" title="Link to this heading">¶</a></h3>
<p>SSA values for assumed-rank entities have an MLIR type containing a
<code class="docutils literal notranslate"><span class="pre">!fir.array&lt;*xT&gt;</span></code> sequence type wrapped in a <code class="docutils literal notranslate"><span class="pre">!fir.box</span></code> or <code class="docutils literal notranslate"><span class="pre">!fir.class</span></code> type
(additionally wrapped in a <code class="docutils literal notranslate"><span class="pre">!fir.ref</span></code> type for pointers and allocatables).</p>
<p>Examples:
<code class="docutils literal notranslate"><span class="pre">INTEGER</span> <span class="pre">::</span> <span class="pre">x(..)</span></code>  -&gt; <code class="docutils literal notranslate"><span class="pre">!fir.box&lt;!fir.array&lt;*</span> <span class="pre">x</span> <span class="pre">i32&gt;&gt;</span></code>
<code class="docutils literal notranslate"><span class="pre">CLASS(*)</span> <span class="pre">::</span> <span class="pre">x(..)</span></code>  -&gt; <code class="docutils literal notranslate"><span class="pre">!fir.class&lt;!fir.array&lt;*</span> <span class="pre">x</span> <span class="pre">none&gt;&gt;</span></code>
<code class="docutils literal notranslate"><span class="pre">TYPE(*)</span> <span class="pre">::</span> <span class="pre">x(..)</span></code>  -&gt; <code class="docutils literal notranslate"><span class="pre">!fir.box&lt;!fir.array&lt;*</span> <span class="pre">x</span> <span class="pre">none&gt;&gt;</span></code>
<code class="docutils literal notranslate"><span class="pre">REAL,</span> <span class="pre">ALLOCATABLE</span> <span class="pre">::</span> <span class="pre">x(..)</span></code>  -&gt; <code class="docutils literal notranslate"><span class="pre">!fir.ref&lt;!fir.box&lt;!fir.heap&lt;!fir.array&lt;*</span> <span class="pre">x</span> <span class="pre">f32&gt;&gt;&gt;&gt;</span></code>
<code class="docutils literal notranslate"><span class="pre">TYPE(t),</span> <span class="pre">POINTER</span> <span class="pre">::</span> <span class="pre">x(..)</span></code>  -&gt; <code class="docutils literal notranslate"><span class="pre">!fir.ref&lt;!fir.box&lt;!fir.ptr&lt;!fir.array&lt;*</span> <span class="pre">x</span> <span class="pre">!fir.type&lt;t&gt;&gt;&gt;&gt;&gt;</span></code></p>
<p>All these FIR types are implemented as the address of a CFI_cdesc_t in code
generation.</p>
<p>There is no need to allow assumed-rank “expression” in HLFIR (hlfir.expr) since
assumed-rank cannot appear in expressions (except as the actual argument to an
assumed-rank dummy). Assumed-rank are variables. Also, since they cannot have
the VALUE attribute, there is no need to use the hlfir.as_expr +
hlfir.associate idiom to make copies for them.</p>
<p>FIR/HLFIR operation where assumed-rank may appear:</p>
<ul class="simple">
<li><p>as <code class="docutils literal notranslate"><span class="pre">hlfir.declare</span></code> and <code class="docutils literal notranslate"><span class="pre">fir.declare</span></code> operand and result.</p></li>
<li><p>as <code class="docutils literal notranslate"><span class="pre">fir.convert</span></code> operand and/or result.</p></li>
<li><p>as <code class="docutils literal notranslate"><span class="pre">fir.load</span></code> operand and result (POINTER and ALLOCATABLE dereference).</p></li>
<li><p>as a block argument (dummy argument).</p></li>
<li><p>as <code class="docutils literal notranslate"><span class="pre">fir.rebox_assumed_rank</span></code> operand/result (new operation to change some
fields of assumed-rank descriptors).</p></li>
<li><p>as <code class="docutils literal notranslate"><span class="pre">fir.box_rank</span></code> operand (rank inquiry).</p></li>
<li><p>as <code class="docutils literal notranslate"><span class="pre">fir.box_dim</span></code> operand (brutal user inquiry about the bounds of an
assumed-rank in a compile time constant dimension).</p></li>
<li><p>as <code class="docutils literal notranslate"><span class="pre">fir.box_addr</span></code> operand (to get the base address in inlined code for
C_LOC).</p></li>
<li><p>as <code class="docutils literal notranslate"><span class="pre">fir.box_elesize</span></code> operand (to implement LEN and STORAGE_SIZE).</p></li>
<li><p>as <code class="docutils literal notranslate"><span class="pre">fir.absent</span></code> result (passing absent actual to OPTIONAL assumed-rank dummy)</p></li>
<li><p>as <code class="docutils literal notranslate"><span class="pre">fir.is_present</span></code> operand (PRESENT inquiry)</p></li>
<li><p>as <code class="docutils literal notranslate"><span class="pre">hlfir.copy_in</span></code> and <code class="docutils literal notranslate"><span class="pre">hlfir.copy_out</span></code> operand and result (copy in and
copy-out of assumed-rank)</p></li>
<li><p>as <code class="docutils literal notranslate"><span class="pre">fir.alloca</span></code> type and result (when creating an assumed-rank POINTER dummy
from a non POINTER dummy).</p></li>
<li><p>as <code class="docutils literal notranslate"><span class="pre">fir.store</span></code> operands (same case as <code class="docutils literal notranslate"><span class="pre">fir.alloca</span></code>).</p></li>
</ul>
<p>FIR/HLFIR Operations that should not need to accept assumed-ranks but where it
could still be relevant:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fir.box_tdesc</span></code> and <code class="docutils literal notranslate"><span class="pre">fir.box_typecode</span></code> (polymorphic assumed-rank cannot
appear in a SELECT TYPE directly without using a SELECT RANK). Given the
CFI_cdesc_t structure, no change would be needed for <code class="docutils literal notranslate"><span class="pre">fir.box_typecode</span></code> to
support assumed-ranks, but <code class="docutils literal notranslate"><span class="pre">fir.box_tdesc</span></code> would require change since the
position of the type descriptor pointer depends on the rank.</p></li>
<li><p>as <code class="docutils literal notranslate"><span class="pre">fir.allocmem</span></code> / <code class="docutils literal notranslate"><span class="pre">fir.global</span></code> result (assumed-ranks are never local/global
entities).</p></li>
<li><p>as <code class="docutils literal notranslate"><span class="pre">fir.embox</span></code> result (When creating descriptor for an explicit shape, the
descriptor can be created with the entity rank, and then casted via
<code class="docutils literal notranslate"><span class="pre">fir.convert</span></code>).</p></li>
</ul>
<p>It is not expected for any other FIR or HLFIR operations to handle assumed-rank
SSA values.</p>
<section id="summary-of-the-impact-in-fir">
<h4>Summary of the impact in FIR<a class="headerlink" href="#summary-of-the-impact-in-fir" title="Link to this heading">¶</a></h4>
<p>One new operation is needed, <code class="docutils literal notranslate"><span class="pre">fir.rebox_assumed_rank</span></code>, the rational being that
fir.rebox codegen is already quite complex and not all the aspects of fir.rebox
matters for assumed-ranks (only simple field changes are required with
assumed-ranks). Also, this operation will be allowed to take an operand in
memory to avoid expensive fir.load of pointer/allocatable inputs. The operation
will also allow creating rank-one assumed-size descriptor from an input
assumed-rank descriptor to cover the SELECT RANK <code class="docutils literal notranslate"><span class="pre">RANK(*)</span></code> case.</p>
<p>It is proposed that the FIR descriptor inquiry operation (fir.box_addr,
fir.box_rank, fir.box_dim, fir.box_elesize at least) be allowed to take
fir.ref&lt;fir.box&gt; arguments (allocatable and pointer descriptors) directly
instead of generating a fir.load first. A conditional “read” effect will be
added in such case. Again, the purpose is to avoid generating descriptor copies
for the sole purpose of satisfying the SSA IR constraints. This change will
likely benefit the non assumed-rank case too (even though LLVM is quite good at
removing pointless descriptor copies in these cases).</p>
<p>It will be ensured that all the operation listed above accept assumed-rank
operands (both the verifiers and coedgen). The codegen of <code class="docutils literal notranslate"><span class="pre">fir.load</span></code>,
<code class="docutils literal notranslate"><span class="pre">fir.alloca</span></code>, <code class="docutils literal notranslate"><span class="pre">fir.store</span></code>, <code class="docutils literal notranslate"><span class="pre">hlfir.copy_in</span></code> and <code class="docutils literal notranslate"><span class="pre">hlfir.copy_out</span></code> will need
special handling for assumed-ranks.</p>
</section>
</section>
<section id="representation-in-llvm-ir">
<h3>Representation in LLVM IR<a class="headerlink" href="#representation-in-llvm-ir" title="Link to this heading">¶</a></h3>
<p>Assumed-rank descriptor types are lowered to the LLVM type of a CFI_cdesc_t
descriptor with no dimension array field and no addendum. That way, any inline
code attempt to directly access dimensions and addendum with constant offset
will be invalid for more safety, but it will still be easy to generate LLVM GEP
to address the first descriptor fields in LLVM (to get the base address, rank,
type code and attributes).</p>
<p><code class="docutils literal notranslate"><span class="pre">!fir.box&lt;!fir.array&lt;*</span> <span class="pre">x</span> <span class="pre">i32&gt;&gt;</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">!llvm.struct&lt;(ptr,</span> <span class="pre">i64,</span> <span class="pre">i32,</span> <span class="pre">i8,</span> <span class="pre">i8,</span> <span class="pre">i8,</span> <span class="pre">i8&gt;</span></code></p>
</section>
</section>
<section id="assumed-rank-features">
<h2>Assumed-rank Features<a class="headerlink" href="#assumed-rank-features" title="Link to this heading">¶</a></h2>
<p>This section list the different Fortran features where assumed-rank objects are
involved and describes the related implementation design.</p>
<section id="assumed-rank-in-procedure-references">
<h3>Assumed-rank in procedure references<a class="headerlink" href="#assumed-rank-in-procedure-references" title="Link to this heading">¶</a></h3>
<p>Assumed-rank arguments are implemented as being the address of a CFI_cdesc_t.</p>
<p>When passing an actual argument to an assumed-rank dummy, the following points
need special attention and are further described below:</p>
<ul class="simple">
<li><p>Copy-in/copy-out when required</p></li>
<li><p>Creation of forwarding of the assumed-rank dummy descriptor (including when
the actual is an assumed-size).</p></li>
<li><p>Finalization, deallocation, and initialization of INTENT(OUT) assumed-rank
dummy.</p></li>
</ul>
<p>OPTIONAL assumed-ranks are implemented like other non assumed-rank OPTIONAL
objects passed by descriptor: an absent assumed-rank is represented by a null
pointer to a CFI_cdesc_t.</p>
<p>The passing interface for assumed-rank described above and below is compliant
by default with the BIND(C) case, except for the assumed-rank dummy descriptor
lower bounds, which are only set to zeros in BIND(C) interface because it
implies in most of the cases to create a new descriptor.</p>
<p>VALUE is forbidden for assumed-rank dummies, so there is nothing to be done for
it (although since copy-in/copy-out is possible, the compiler must anyway deal
with creating assumed-rank copies, so it would likely not be an issue to relax
this constraint).</p>
<section id="copy-in-and-copy-out">
<h4>Copy-in and Copy out<a class="headerlink" href="#copy-in-and-copy-out" title="Link to this heading">¶</a></h4>
<p>Copy-in and copy-out is required when passing an actual that is not contiguous
to a non POINTER CONTIGUOUS assumed-rank.</p>
<p>When the actual argument is ranked, the copy-in/copy-out can be performed on
the ranked actual argument where the dynamic type has been aligned with the
dummy type if needed (passing CLASS(T) to TYPE(T)) as illustrated below.</p>
<div class="highlight-Fortran notranslate"><div class="highlight"><pre><span></span><span class="k">module </span><span class="n">m</span>
<span class="k">type </span><span class="n">t</span>
<span class="w"> </span><span class="kt">integer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">i</span>
<span class="k">end type</span>
<span class="k">contains</span>
<span class="k">subroutine </span><span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w"> </span><span class="k">class</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span><span class="p">(:)</span>
<span class="w"> </span><span class="k">interface</span>
<span class="k">  subroutine </span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="k">import</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">t</span>
<span class="w">    </span><span class="k">type</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="w"> </span><span class="k">contiguous</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span><span class="p">(..)</span>
<span class="w">  </span><span class="k">end subroutine</span>
<span class="k"> end interface</span>
<span class="w"> </span><span class="c">! copy-in and copy-out is required aroud bar</span>
<span class="w"> </span><span class="k">call </span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">end</span>
<span class="k">end module</span>
</pre></div>
</div>
<p>When the actual is also an assumed-rank special the same copy-in/copy-out need
may arise, and the <code class="docutils literal notranslate"><span class="pre">hlfir.copy_in</span></code> and <code class="docutils literal notranslate"><span class="pre">hlfir.copy_out</span></code> are also used to cover
this case. The <code class="docutils literal notranslate"><span class="pre">hlfir.copy_in</span></code>operation is implemented using the <code class="docutils literal notranslate"><span class="pre">IsContiguous</span></code>
runtime (can be used as-is) and the <code class="docutils literal notranslate"><span class="pre">AssignTemporary</span></code> temporary runtime.</p>
<p>The difference with the ranked case is that more care is needed to create the
output descriptor passed to <code class="docutils literal notranslate"><span class="pre">AssignTemporary</span></code>: it must be allocated to the
maximum rank with the same type as the input descriptor and only the descriptor
fields prior to the array dimensions will be initialized to those of an
unallocated descriptor prior to the runtime call (<code class="docutils literal notranslate"><span class="pre">AssignTemporary</span></code> copies the
addendum if needed).</p>
<div class="highlight-Fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">foo2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w"> </span><span class="k">class</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span><span class="p">(..)</span>
<span class="w"> </span><span class="k">interface</span>
<span class="k">  subroutine </span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="k">import</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">t</span>
<span class="w">    </span><span class="k">type</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="w"> </span><span class="k">contiguous</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span><span class="p">(..)</span>
<span class="w">  </span><span class="k">end subroutine</span>
<span class="k"> end interface</span>
<span class="w"> </span><span class="c">! copy-in and copy-out is required aroud bar</span>
<span class="w"> </span><span class="k">call </span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
</section>
<section id="creating-the-descriptor-for-assumed-rank-dummies">
<h4>Creating the descriptor for assumed-rank dummies<a class="headerlink" href="#creating-the-descriptor-for-assumed-rank-dummies" title="Link to this heading">¶</a></h4>
<p>There are four cases to distinguish:</p>
<ol class="arabic simple">
<li><p>Actual does not have a descriptor (and is therefore ranked)</p></li>
<li><p>Actual has a descriptor that can be forwarded for the dummy</p></li>
<li><p>Actual has a ranked descriptor that cannot be forwarded for the dummy</p></li>
<li><p>Actual has an assumed-rank descriptor that cannot be forwarded for the dummy</p></li>
</ol>
<p>For the first case, a descriptor will be created for the dummy with <code class="docutils literal notranslate"><span class="pre">fir.embox</span></code>
has if it has the rank of the actual argument. This is the same logic as when
dealing with assumed shape or INTENT(IN) POINTER dummy arguments, except that
an extra cast to the assumed-rank descriptor type is added (no-op at runtime).
Care must be taken to set the final dimension extent to -1 in the descriptor
created for an assumed-size actual argument. Note that the descriptor created
for an assumed-size still has the rank of the assumed-size, a rank-one
descriptor will be created for it if needed in a RANK(*) block (nothing says
that an assumed-size should be passed as a rank-one array in 15.5.2.4 point 17).</p>
<p>For the second case, a cast is added to assumed-rank descriptor type if it is
not one already and the descriptor is forwarded.</p>
<p>For the third case, a new ranked descriptor with the dummy attribute/lower
bounds is created from the actual argument descriptor with <code class="docutils literal notranslate"><span class="pre">fir.rebox</span></code> as it is
done when passing to an assume shape dummy, and a cast to the assumed-rank
descriptor is added .</p>
<p>The last case is the same as the third one, except the that the descriptor
manipulation is more complex since the storage size of the descriptor is
unknown. <code class="docutils literal notranslate"><span class="pre">fir.rebox</span></code> codegen is already quite complex since it deals with
creating descriptor for descriptor based array sections and pointer remapping.
Both of those are meaningless in this case where the output descriptor is the
same as the input one, except for the lower bounds, attribute, and derived type
pointer field that may need to be changed to match the values describing the
dummy. A simpler <code class="docutils literal notranslate"><span class="pre">fir.rebox_assumed_rank</span></code> operation is added for this use case.
Notably, this operation can take fir.ref&lt;fir.box&gt; inputs to avoid creating an
expensive and useless fir.load of POINTER/ALLOCATABLE descriptors.</p>
<p>Fortran requires the compiler to fall in the 3rd and 4th case and create
descriptor temporary for the dummy a lot more than one would think and hope. An
annex section below discusses cases that force the compiler to create a new
descriptor for the dummy even if the actual already has a descriptor. These are
the same situations than with non assumed-rank arguments, but when passing
assumed-rank to assumed-ranks, the cost of this extra copy is higher.</p>
</section>
<section id="intent-out-assumed-rank-finalization-deallocation-initialization">
<h4>Intent(out) assumed-rank finalization, deallocation, initialization<a class="headerlink" href="#intent-out-assumed-rank-finalization-deallocation-initialization" title="Link to this heading">¶</a></h4>
<p>The standard prevents INTENT(OUT) assumed-rank requiring finalization to be
associated with assumed-size arrays (C839) because there would be no way to
finalize such entities. But INTENT(OUT) finalization is still possible if the
actual is not an assumed-size and not a nonpointer nonallocatable assumed-rank.</p>
<p>Flang therefore needs to implement finalization, deallocation and
initialization of INTENT(OUT) as usual. Non pointer non allocatable INTENT(OUT)
finalization is done via a call to <code class="docutils literal notranslate"><span class="pre">Destroy</span></code> runtime API that takes a
descriptor and can be directly used with an assumed-rank descriptor with no
change. The initialization is done via a call to the <code class="docutils literal notranslate"><span class="pre">Initialize</span></code> runtime API
that takes a descriptor and can also directly be used with an assumed
descriptor. Conditional deallocation of INTENT(OUT) allocatable is done via an
inline allocation status check and either an inline deallocate for intrinsic
types, or a runtime call to <code class="docutils literal notranslate"><span class="pre">Deallocate</span></code> for the other cases. For
assumed-ranks, the runtime call is always used regardless of the type to avoid
inline descriptor manipulations. <code class="docutils literal notranslate"><span class="pre">Deallocate</span></code> runtime API also works with
assumed-rank descriptors with no changes (like any runtime API taking
descriptors of any rank).</p>
<div class="highlight-Fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w"> </span><span class="k">class</span><span class="p">(</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span><span class="p">(..)</span>
<span class="w"> </span><span class="k">interface</span>
<span class="k">  subroutine </span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="k">class</span><span class="p">(</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span><span class="p">(..)</span>
<span class="w">  </span><span class="k">end subroutine</span>
<span class="k"> end interface</span>
<span class="w"> </span><span class="c">! x may require finalization and initialization on bar entry.</span>
<span class="w"> </span><span class="k">call </span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">end</span>
<span class="k">subroutine </span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">  </span><span class="k">class</span><span class="p">(</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span><span class="p">(..)</span>
<span class="k">end subroutine</span>
</pre></div>
</div>
</section>
</section>
<section id="select-rank">
<h3>Select Rank<a class="headerlink" href="#select-rank" title="Link to this heading">¶</a></h3>
<p>Select rank is implemented with a rank inquiry (and last extent for <code class="docutils literal notranslate"><span class="pre">RANK(*)</span></code>),
followed by a jump in the related block where the selector descriptor is cast
to a descriptor with the associated entity rank for the current block for the
<code class="docutils literal notranslate"><span class="pre">RANK(cst)</span></code> cases. In the <code class="docutils literal notranslate"><span class="pre">RANK</span> <span class="pre">DEFAULT</span></code>, the input descriptor is kept with no
cast, and in the RANK(*), a rank-one descriptor is created with the same
dynamic type as the input.
These new descriptor values are mapped to the associated entity symbol and
lowering precede as usual. This is very similar to how Select Type is
implemented. The <code class="docutils literal notranslate"><span class="pre">RANK(*)</span></code> is a bit odd, it detects assumed-ranks associated
with an assumed-size arrays regardless of the rank, and takes precedence over
any rank based matching.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">-1</span></code> is a magic extent number that encodes that a descriptor describes
an entity that is an assumed-size (user specified extents of explicit shape
arrays are always normalized to zero when negative, so <code class="docutils literal notranslate"><span class="pre">-1</span></code> is a safe value to
identify a descriptor created for an assumed-size). It is actually well
specified for the BIND(C) (18.5.2 point 1.) and is always used as such in flang
descriptors.</p>
<p>The implementation of SELECT RANK is done as follow:</p>
<ul class="simple">
<li><p>Read the rank <code class="docutils literal notranslate"><span class="pre">r</span></code> in the descriptor</p></li>
<li><p>If there is a <code class="docutils literal notranslate"><span class="pre">RANK(*)</span></code>, read the extent in dimension <code class="docutils literal notranslate"><span class="pre">r</span></code>. If it is <code class="docutils literal notranslate"><span class="pre">-1</span></code>,
jump to the <code class="docutils literal notranslate"><span class="pre">RANK(*)</span></code> block. Otherwise, continue to the steps below.</p></li>
<li><p>For each <code class="docutils literal notranslate"><span class="pre">RANK(constant)</span></code> case, compare <code class="docutils literal notranslate"><span class="pre">constant</span></code> to <code class="docutils literal notranslate"><span class="pre">r</span></code>. Stop at first
match and jump to related block. The order of the comparisons does not matter
(there cannot be more than one match).</p></li>
<li><p>Jump to <code class="docutils literal notranslate"><span class="pre">RANK</span> <span class="pre">DEFAULT</span></code> block is any. Otherwise jump to the end of the
construct.</p></li>
</ul>
<p>The blocks for each cases jumps at the end of the construct at the end. As
opposed to SELECT TYPE, no clean-up should be needed at the construct level
since the select-rank selector is a named entity and cannot be a temporary with
a lifetime of the construct.</p>
<p>Except for the <code class="docutils literal notranslate"><span class="pre">RANK(*)</span></code> case, the branching logic is implemented in FIR with a
<code class="docutils literal notranslate"><span class="pre">fir.select_case</span></code> operating on the rank.</p>
<p>Example:</p>
<div class="highlight-Fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">test</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">  </span><span class="k">interface</span>
<span class="k">    subroutine </span><span class="n">assumed_size</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">      </span><span class="kt">real</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="w">    </span><span class="k">end subroutine</span>
<span class="k">    subroutine </span><span class="n">scalar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">      </span><span class="kt">real</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span>
<span class="w">    </span><span class="k">end subroutine</span>
<span class="k">    subroutine </span><span class="n">rank_one</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">      </span><span class="kt">real</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span><span class="p">(:)</span>
<span class="w">    </span><span class="k">end subroutine</span>
<span class="k">    subroutine </span><span class="n">many_dim_array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">      </span><span class="kt">real</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span><span class="p">(..)</span>
<span class="w">    </span><span class="k">end subroutine</span>
<span class="k">  end interface</span>
<span class="k">  </span>
<span class="k">  </span><span class="kt">real</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span><span class="p">(..)</span>
<span class="w">  </span><span class="k">select </span><span class="n">rank</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">  </span><span class="n">rank</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="w">    </span><span class="k">call </span><span class="n">assumed_size</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="w">  </span><span class="n">rank</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">call </span><span class="n">scalar</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="w">  </span><span class="n">rank</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="k">call </span><span class="n">rank_one</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="w">  </span><span class="n">rank</span><span class="w"> </span><span class="n">default</span>
<span class="w">    </span><span class="k">call </span><span class="n">many_dim_array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="w">  </span><span class="k">end select</span>
<span class="k">end subroutine</span>
</pre></div>
</div>
<p>Pseudo FIR for the example (some converts and SSA constants creation are not shown for more clarity):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>func.func @_QPtest(%arg0: !fir.box&lt;!fir.array&lt;?xf32&gt;&gt;) {
  %x:2 = hlfir.declare %arg0 {uniq_name = &quot;_QFtestEx&quot;} : (!fir.box&lt;!fir.array&lt;*xf32&gt;&gt;) -&gt; (!fir.box&lt;!fir.array&lt;*xf32&gt;&gt;, !fir.box&lt;!fir.array&lt;*xf32&gt;&gt;)
  %r = fir.box_rank %x#1 : (!fir.box&lt;!fir.array&lt;*xf32&gt;&gt;) -&gt; i32
  %last_extent = fir.call @_FortranASizeDim(%x#1, %r, %sourcename, %sourceline)
  %is_assumed_size = arith.cmpi eq %last_extent, %c-1: (i64, i64) -&gt; i1
  cf.cond_br %is_assumed_size, ^bb_assumed_size, ^bb_not_assumed_size
^bb_assumed_size:
  %r1_box = fir.rebox_assumed_rank %x#0 : (!fir.box&lt;!fir.array&lt;*xf32&gt;&gt;) -&gt; !fir.box&lt;!fir.array&lt;?xf32&gt;&gt;
  %addr = fir.box_addr %addr, !fir.box&lt;!fir.array&lt;?xf32&gt;&gt; -&gt; !fir.ref&lt;!fir.array&lt;?xf32&gt;&gt;
  fir.call @_QPassumed_size(%addr) (!fir.ref&lt;!fir.array&lt;?xf32&gt;&gt;) -&gt; ()
  cf.br ^bb_end
^bb_not_assumed_size:
  fir.select_case %3 : i32 [#fir.point, %c0, ^bb_scalar, #fir.point, %c1, ^bb_rank1, unit, ^bb_default]
^bb_scalar:
  %scalar_cast = fir.convert %x#1 : (!fir.box&lt;!fir.array&lt;*xf32&gt;&gt;) -&gt; !fir.box&lt;f32&gt;
  %x_scalar = fir.box_addr %scalar_cast: (!fir.box&lt;f32&gt;) -&gt; !fir.ref&lt;f32&gt;
  fir.call @_QPscalar(%x_scalar) (!fir.ref&lt;f32&gt;) -&gt; ()
  cf.br ^bb_end
^bb_rank1:
  %rank1_cast = fir.convert %x#1 : (!fir.box&lt;!fir.array&lt;*xf32&gt;&gt;) -&gt; !fir.box&lt;!fir.array&lt;?xf32&gt;&gt;
  fir.call @_QPrank_one(%rank1_cast) (!fir.box&lt;!fir.array&lt;?xf32&gt;&gt;) -&gt; ()
  cf.br ^bb_end
^bb_default:
  fir.call @_QPmany_dim_array(%x#1) (!fir.box&lt;!fir.array&lt;*xf32&gt;&gt;) -&gt; ()
  cf.br ^bb_end
^bb_end
  return
}
</pre></div>
</div>
</section>
<section id="inquiry-intrinsic-functions">
<h3>Inquiry intrinsic functions<a class="headerlink" href="#inquiry-intrinsic-functions" title="Link to this heading">¶</a></h3>
<section id="allocated-and-associated">
<h4>ALLOCATED and ASSOCIATED<a class="headerlink" href="#allocated-and-associated" title="Link to this heading">¶</a></h4>
<p>Implemented inline with <code class="docutils literal notranslate"><span class="pre">fir.box_addr</span></code> (reading the descriptor first address
inline). Currently, FIR descriptor inquiry happens at the “descriptor value”
level (require a fir.load of the POINTER or ALLOCATABLE !fir.ref&lt;!fir.box&lt;&gt;&gt;),
to satisfy the SSA value semantics, the fir.load creates a copy of the
underlying descriptor storage. With assume ranks, this copy will be “expensive”
and harder to optimize out given the descriptor storage size is not a compile
time constant. To avoid this extra cost, ALLOCATABLE and POINTER assumed-ranks
will be cast to scalar descriptors before the <code class="docutils literal notranslate"><span class="pre">fir.load</span></code>.</p>
<div class="highlight-Fortran notranslate"><div class="highlight"><pre><span></span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span><span class="p">(..)</span>
<span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="nb">allocated</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>%1 = fir.convert %x : (!fir.ref&lt;!fir.box&lt;!fir.heap&lt;!fir.array&lt;* x f32&gt;&gt;&gt;&gt;) -&gt; !fir.ref&lt;!fir.box&lt;!fir.heap&lt;f32&gt;&gt;&gt;
%2 = fir.load %x : !fir.ref&lt;!fir.box&lt;!fir.heap&lt;f32&gt;&gt;&gt;
%addr = fir.box_addr %2 : (!fir.box&lt;!fir.heap&lt;f32&gt;&gt;) -&gt; fir.ref&lt;f32&gt;
# .... &quot;addr != null&quot; as usual
</pre></div>
</div>
</section>
<section id="len-and-storage-size">
<h4>LEN and STORAGE_SIZE<a class="headerlink" href="#len-and-storage-size" title="Link to this heading">¶</a></h4>
<p>Implemented inline with <code class="docutils literal notranslate"><span class="pre">fir.box_elesize</span></code> with the same approach as
ALLOCATED/ASSOCIATED when dealing with fir.box load for POINTERS and
ALLOCATABLES.</p>
<div class="highlight-Fortran notranslate"><div class="highlight"><pre><span></span><span class="kt">character</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span><span class="p">(..)</span>
<span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>%ele_size = fir.box_elesize %x : (!fir.box&lt;!fir.array&lt;*x!fir.char&lt;?&gt;&gt;&gt;) -&gt; i64
# .... divide by character KIND byte size if needed as usual 
</pre></div>
</div>
</section>
<section id="present">
<h4>PRESENT<a class="headerlink" href="#present" title="Link to this heading">¶</a></h4>
<p>Implemented inline with <code class="docutils literal notranslate"><span class="pre">fir.is_present</span></code> which ends-up implemented as a check
that the descriptor address is not null just like with OPTIONAL assumed shapes
and OPTIONAL pointers and allocatables.</p>
<div class="highlight-Fortran notranslate"><div class="highlight"><pre><span></span><span class="kt">real</span><span class="p">,</span><span class="w"> </span><span class="k">optional</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span><span class="p">(..)</span>
<span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="nb">present</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>%is_present = fir.is_prent %x : (!fir.box&lt;!fir.array&lt;*xf32&gt;&gt;) -&gt; i1
</pre></div>
</div>
</section>
<section id="rank">
<h4>RANK<a class="headerlink" href="#rank" title="Link to this heading">¶</a></h4>
<p>Implemented inline with <code class="docutils literal notranslate"><span class="pre">fir.box_rank</span></code> which simply reads the descriptor rank
field.</p>
<div class="highlight-Fortran notranslate"><div class="highlight"><pre><span></span><span class="kt">real</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span><span class="p">(..)</span>
<span class="k">print</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>%rank = fir.box_rank %x : (!fir.box&lt;!fir.array&lt;*xf32&gt;&gt;) -&gt; i32
</pre></div>
</div>
</section>
<section id="size">
<h4>SIZE<a class="headerlink" href="#size" title="Link to this heading">¶</a></h4>
<p>Using the runtime can be queried as it is done for assumed shapes. When DIM is
present and is constant, <code class="docutils literal notranslate"><span class="pre">fir.box_dim</span></code> can also be used with the option to add
a runtime check that RANK &lt;= DIM. Pointers and allocatables are dereferenced,
which in FIR currently creates a descriptor copy that cannot be simplified
like for the previous inquiries by inserting a cast before the fir.load (the
dimension info must be correctly copied).</p>
</section>
<section id="lbound-shape-and-ubound">
<h4>LBOUND, SHAPE, and UBOUND<a class="headerlink" href="#lbound-shape-and-ubound" title="Link to this heading">¶</a></h4>
<p>When DIM is present an is present, the runtime can be used as it is currently
with assumed shapes. When DIM is absent, the result is a rank-one array whose
extent is the rank. The runtime has an entry for UBOUND that takes a descriptor
and allocate the result as needed, so the same logic as for assumed shape can
be used.</p>
<p>There is no such entry for LBOUND/SHAPE currently, it would likely be best to
add one rather than to jungle with inline code. Pointers and allocatables
dereference is similar as with SIZE.</p>
</section>
<section id="extends-type-of-same-type-as-and-is-contiguous">
<h4>EXTENDS_TYPE_OF, SAME_TYPE_AS, and IS_CONTIGUOUS<a class="headerlink" href="#extends-type-of-same-type-as-and-is-contiguous" title="Link to this heading">¶</a></h4>
<p>Using the runtime as it is done currently with assumed shapes. Pointers and
allocatables dereference is similar as with SIZE.</p>
</section>
<section id="c-loc-from-iso-c-binding">
<h4>C_LOC from ISO_C_BINDING<a class="headerlink" href="#c-loc-from-iso-c-binding" title="Link to this heading">¶</a></h4>
<p>Implemented with <code class="docutils literal notranslate"><span class="pre">fir.box_addr</span></code> as with other C_LOC cases for entities that
have descriptors.</p>
</section>
<section id="c-size-of-from-iso-c-binding">
<h4>C_SIZE_OF from ISO_C_BINDING<a class="headerlink" href="#c-size-of-from-iso-c-binding" title="Link to this heading">¶</a></h4>
<p>Implemented as STORAGE_SIZE * SIZE.</p>
</section>
<section id="floating-point-inquiries-and-new-line">
<h4>Floating point inquiries and NEW_LINE<a class="headerlink" href="#floating-point-inquiries-and-new-line" title="Link to this heading">¶</a></h4>
<p>BIT_SIZE, DIGITS, EPSILON, HUGE, KIND, MAXEXPONENT, MINEXPONENT, NEW_LINE,
PRECISION, RADIX, RANGE, TINY all accept assumed-rank, but are always constant
folded by semantics based on the type and lowering does not need to deal with
them.</p>
</section>
<section id="coarray-inquiries">
<h4>Coarray inquiries<a class="headerlink" href="#coarray-inquiries" title="Link to this heading">¶</a></h4>
<p>Assumed-rank cannot be coarrays (C837), but they can still technically appear
in COSHAPE (which should obviously return zero). They cannot appear in LBOUND,
LCOBOUND, UBOUND, UCOBOUND that require the argument to be a coarray.</p>
</section>
</section>
</section>
<section id="annex-1-descriptor-temporary-for-the-dummy-arguments">
<h2>Annex 1 - Descriptor temporary for the dummy arguments<a class="headerlink" href="#annex-1-descriptor-temporary-for-the-dummy-arguments" title="Link to this heading">¶</a></h2>
<p>When passing an actual argument that is descriptor to a dummy that must be
passed by descriptor, one could expect that the descriptor of the actual can
just be forwarded to the dummy, but this is unfortunately not possible in quite
some cases. This is not specific to assumed-ranks, but since the cost of
descriptor temporaries is higher for assumed-ranked, it is discussed here.</p>
<p>Below are the reasons for which a new descriptor may be required:</p>
<ol class="arabic simple">
<li><p>passing a POINTER to a non POINTER</p></li>
<li><p>setting the descriptor CFI_cdesc_t <code class="docutils literal notranslate"><span class="pre">attribute</span></code> according to the dummy
POINTER/ALLOCATABLE attributes (18.3.6 point 4 for the BIND(C) case).</p></li>
<li><p>setting the CFI_cdesc_t lower bounds to zero for a BIND(C) assumed
shape/rank dummy (18.5.3 point 3).</p></li>
<li><p>setting the derived type pointer to the dummy dynamic type when passing a
CLASS() actual to a TYPE() dummy.</p></li>
</ol>
<p>Justification of 1.:
When passing a POINTER to a non POINTER, the target of the pointer is passed,
and nothing prevents the association status of the actual argument to change
during the call (e.g. if the POINTER is another argument of the call, or is a
module variable, it may be re-associated in the call). These association status
change of the actual should not impact the dummy, so they must not share the
same descriptor.</p>
<p>Justification of 2.:
In the BIND(C) case, this is required by 18.3.6 point 4. Outside of the BIND(C)
case, this should still be done because any runtime call where the dummy
descriptor is forwarded may misbehave if the ALLOCATABLE/POINTER attribute is
not the one of the dummy (e.g. reallocation could be triggered instead of
padding/trimming characters).</p>
<p>Justification of 3:
18.5.3 point 3.</p>
<p>Justification of 4:
If the descriptor derived type info pointer is not the one of the dummy dynamic
type, many runtime call like IO and assignment will misbehave when being
provided the dummy descriptor.</p>
<p>For point 2., 3., and 4., one could be tempted to change the descriptor fields
before and after the call, but this is risky since this would assume nothing
will access the actual argument descriptor during the call. And even without
bringing any potential asynchronous behavior of OpenMP/OpenACC/Cuda Fortran
extensions, the actual argument descriptor may be passed inside a call in
another arguments with “different” lower bounds POINTER or ALLOCATABLE (but
could also be accessed via host of use association in general).</p>
</section>
<section id="annex-2-assumed-rank-objects-and-ignore-tkr">
<h2>Annex 2 - Assumed-Rank Objects and IGNORE_TKR<a class="headerlink" href="#annex-2-assumed-rank-objects-and-ignore-tkr" title="Link to this heading">¶</a></h2>
<p>It is possible to:</p>
<ul class="simple">
<li><p>Set IGNORE_TKR(TK) on assumed-rank dummies (but TYPE(*) is better when
possible).</p></li>
<li><p>Pass an assumed-rank to an IGNORE_TKR(R) dummy that is not passed
by descriptor (explicit shape and assumed-size). Note that copy-in and
copy-out will be performed for the dummy</p></li>
</ul>
<p>It is not possible to:</p>
<ul class="simple">
<li><p>Set IGNORE_TKR(R) on an assumed-rank dummy.</p></li>
</ul>
<p>Example:</p>
<div class="highlight-Fortran notranslate"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">test</span><span class="p">(</span><span class="n">assumed_rank_actual</span><span class="p">)</span>
<span class="k">interface</span>
<span class="k"> subroutine </span><span class="n">assumed_size_dummy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="c">!dir$ ignore_tkr(tkr) x</span>
<span class="w">    </span><span class="kt">integer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="w"> </span><span class="k">end subroutine</span>
<span class="k"> subroutine </span><span class="n">any_type_assumed_rank</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">    </span><span class="c">!dir$ ignore_tkr(tk) x</span>
<span class="w">    </span><span class="kt">integer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span><span class="p">(..)</span>
<span class="w"> </span><span class="k">end subroutine</span>
<span class="k">end interface</span>
<span class="k">  </span><span class="kt">real</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">assumed_rank_actual</span><span class="p">(..)</span>
<span class="w">  </span><span class="k">call </span><span class="n">assumed_size_dummy</span><span class="p">(</span><span class="n">assumed_rank_actual</span><span class="p">)</span><span class="w"> </span><span class="c">!OK</span>
<span class="w">  </span><span class="k">call </span><span class="n">any_type_assumed_rank</span><span class="p">(</span><span class="n">assumed_rank_actual</span><span class="p">)</span><span class="w"> </span><span class="c">!OK</span>
<span class="k">end subroutine</span>
</pre></div>
</div>
</section>
<section id="annex-3-test-plan">
<h2>Annex 3 - Test Plan<a class="headerlink" href="#annex-3-test-plan" title="Link to this heading">¶</a></h2>
<p>MPI_f08 module makes usage of assumed-rank (see
https://www.mpi-forum.org/docs/mpi-3.1/mpi31-report.pdf).  As such compiling
MPI_f08 modules of MPI libraries and some applications making usage of MPI_f08
will be a good test for the implementation of this feature.</p>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="ArrayRepacking.html">Assumed-shape arrays repacking</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="BijectiveInternalNameUniquing.html">Bijective Internal Name Uniquing</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2017-2025, The Flang Team.
      Last updated on Aug 26, 2025.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>