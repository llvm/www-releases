
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>User Guide for NVPTX Back-end &#8212; LLVM 21.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/llvm-theme.css?v=96924833" />
    <script src="_static/documentation_options.js?v=c54a4614"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="LLVM’s Analysis and Transform Passes" href="Passes.html" />
    <link rel="prev" title="Using the New Pass Manager" href="NewPassManager.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="Passes.html" title="LLVM’s Analysis and Transform Passes"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="NewPassManager.html" title="Using the New Pass Manager"
             accesskey="P">previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" accesskey="U">User Guides</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">User Guide for NVPTX Back-end</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="https://llvm.org/docs/UserGuides.html">User Guides</a></li>
    <li><a href="https://llvm.org/docs/Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/Contributing.html">Contributing to LLVM</a></li>
    <li><a href="https://llvm.org/docs/HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#discord">Discord</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/FAQ.html">FAQ</a></li>
    <li><a href="https://llvm.org/docs/Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project/">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/NVPTXUsage.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="user-guide-for-nvptx-back-end">
<h1>User Guide for NVPTX Back-end<a class="headerlink" href="#user-guide-for-nvptx-back-end" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id129">Introduction</a></p></li>
<li><p><a class="reference internal" href="#conventions" id="id130">Conventions</a></p>
<ul>
<li><p><a class="reference internal" href="#marking-functions-as-kernels" id="id131">Marking Functions as Kernels</a></p></li>
<li><p><a class="reference internal" href="#function-attributes" id="id132">Function Attributes</a></p></li>
<li><p><a class="reference internal" href="#address-spaces" id="id133">Address Spaces</a></p></li>
<li><p><a class="reference internal" href="#triples" id="id134">Triples</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#nvptx-architecture-hierarchy-and-ordering" id="id135">NVPTX Architecture Hierarchy and Ordering</a></p></li>
<li><p><a class="reference internal" href="#nvptx-intrinsics" id="id136">NVPTX Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#reading-ptx-special-registers" id="id137">Reading PTX Special Registers</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-nvvm-read-ptx-sreg" id="id138">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.read.ptx.sreg.*</span></code>’</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#barriers" id="id139">Barriers</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-nvvm-barrier-cta" id="id140">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.barrier.cta.*</span></code>’</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#electing-a-thread" id="id141">Electing a thread</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-nvvm-elect-sync" id="id142">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.elect.sync</span></code>’</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#membar-fences" id="id143">Membar/Fences</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-nvvm-fence-proxy-tensormap-generic" id="id144">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fence.proxy.tensormap_generic.*</span></code>’</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#address-space-intrinsics" id="id145">Address Space Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-nvvm-isspacep-intrinsics" id="id146">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.isspacep.*</span></code>’ Intrinsics</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-mapa-intrinsics" id="id147">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.mapa.*</span></code>’ Intrinsics</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#arithmetic-intrinsics" id="id148">Arithmetic Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-nvvm-fabs-intrinsic" id="id149">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fabs.*</span></code>’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-fabs-ftz-intrinsic" id="id150">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fabs.ftz.*</span></code>’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-idp2a-us-us-intrinsics" id="id151">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp2a.[us].[us]</span></code>’ Intrinsics</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-idp4a-us-us-intrinsics" id="id152">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp4a.[us].[us]</span></code>’ Intrinsics</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#bit-manipulation-intrinsics" id="id153">Bit Manipulation Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-nvvm-fshl-clamp-intrinsic" id="id154">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fshl.clamp.*</span></code>’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-fshr-clamp-intrinsic" id="id155">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fshr.clamp.*</span></code>’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-flo-u-intrinsic" id="id156">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.flo.u.*</span></code>’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-flo-s-intrinsic" id="id157">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.flo.s.*</span></code>’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-zext-sext-wrap-clamp-intrinsics" id="id158">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.{zext,sext}.{wrap,clamp}</span></code>’ Intrinsics</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-bmsk-wrap-clamp-intrinsic" id="id159">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.bmsk.{wrap,clamp}</span></code>’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-prmt-intrinsic" id="id160">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.prmt</span></code>’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-prmt-intrinsics" id="id161">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.prmt.*</span></code>’ Intrinsics</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#tma-family-of-intrinsics" id="id162">TMA family of Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-global-to-shared-cluster" id="id163">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.global.to.shared.cluster</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-shared-cta-to-global" id="id164">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.shared.cta.to.global</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-shared-cta-to-cluster" id="id165">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.shared.cta.to.cluster</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-prefetch-l2" id="id166">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.prefetch.L2</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-prefetch" id="id167">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.prefetch.*</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-applypriority" id="id168">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.applypriority.*</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-discard" id="id169"><code class="docutils literal notranslate"><span class="pre">llvm.nvvm.discard.*</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-tensor-g2s-tile-1-5-d" id="id170">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.g2s.tile.[1-5]d</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-tensor-g2s-im2col-3-5-d" id="id171">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.g2s.im2col.[3-5]d</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-tensor-s2g-tile-1-5-d" id="id172">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.s2g.tile.[1-5]d</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-tensor-s2g-im2col-3-5-d" id="id173">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.s2g.im2col.[3-5]d</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-tensor-prefetch-tile-1-5-d" id="id174">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.prefetch.tile.[1-5]d</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-tensor-prefetch-im2col-3-5-d" id="id175">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.prefetch.im2col.[3-5]d</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-tensor-reduce-red-op-tile-1-5-d" id="id176">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.reduce.[red_op].tile.[1-5]d</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-cp-async-bulk-tensor-reduce-red-op-im2col-3-5-d" id="id177">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.reduce.[red_op].im2col.[3-5]d</span></code>’</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#warp-group-intrinsics" id="id178">Warp Group Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-nvvm-wgmma-fence-sync-aligned" id="id179">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.wgmma.fence.sync.aligned</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-wgmma-commit-group-sync-aligned" id="id180">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.wgmma.commit_group.sync.aligned</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-wgmma-wait-group-sync-aligned" id="id181">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.wgmma.wait_group.sync.aligned</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-griddepcontrol" id="id182">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.griddepcontrol.*</span></code>’</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#tcgen05-family-of-intrinsics" id="id183">TCGEN05 family of Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-nvvm-tcgen05-alloc" id="id184">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.tcgen05.alloc</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-tcgen05-dealloc" id="id185">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.tcgen05.dealloc</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-tcgen05-relinq-alloc-permit" id="id186">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.tcgen05.relinq.alloc.permit</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-tcgen05-commit" id="id187">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.tcgen05.commit</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-tcgen05-wait" id="id188">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.tcgen05.wait</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-tcgen05-fence" id="id189">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.tcgen05.fence</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-tcgen05-shift" id="id190">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.tcgen05.shift</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-tcgen05-cp" id="id191">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.tcgen05.cp</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-tcgen05-ld" id="id192">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.tcgen05.ld.*</span></code>’</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-tcgen05-st" id="id193">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.tcgen05.st.*</span></code>’</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#store-intrinsics" id="id194">Store Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-nvvm-st-bulk" id="id195">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.st.bulk.*</span></code>’</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#clusterlaunchcontrol-intrinsics" id="id196">clusterlaunchcontrol Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-nvvm-clusterlaunchcontrol-try-cancel-intrinsics" id="id197">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.clusterlaunchcontrol.try_cancel*</span></code>’ Intrinsics</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-clusterlaunchcontrol-query-cancel-is-canceled-intrinsic" id="id198">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.clusterlaunchcontrol.query_cancel.is_canceled</span></code>’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-nvvm-clusterlaunchcontrol-query-cancel-get-first-ctaid-intrinsics" id="id199">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.clusterlaunchcontrol.query_cancel.get_first_ctaid.*</span></code>’ Intrinsics</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#perf-monitor-event-intrinsics" id="id200">Perf Monitor Event Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-nvvm-pm-event-mask-intrinsic" id="id201">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.pm.event.mask</span></code>’ Intrinsic</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#other-intrinsics" id="id202">Other Intrinsics</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#linking-with-libdevice" id="id203">Linking with Libdevice</a></p>
<ul>
<li><p><a class="reference internal" href="#reflection-parameters" id="id204">Reflection Parameters</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#executing-ptx" id="id205">Executing PTX</a></p></li>
<li><p><a class="reference internal" href="#common-issues" id="id206">Common Issues</a></p>
<ul>
<li><p><a class="reference internal" href="#ptxas-complains-of-undefined-function-nvvm-reflect" id="id207">ptxas complains of undefined function: __nvvm_reflect</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#tutorial-a-simple-compute-kernel" id="id208">Tutorial: A Simple Compute Kernel</a></p>
<ul>
<li><p><a class="reference internal" href="#the-kernel" id="id209">The Kernel</a></p></li>
<li><p><a class="reference internal" href="#dissecting-the-kernel" id="id210">Dissecting the Kernel</a></p>
<ul>
<li><p><a class="reference internal" href="#data-layout" id="id211">Data Layout</a></p></li>
<li><p><a class="reference internal" href="#target-intrinsics" id="id212">Target Intrinsics</a></p></li>
<li><p><a class="reference internal" href="#id128" id="id213">Address Spaces</a></p></li>
<li><p><a class="reference internal" href="#kernel-metadata" id="id214">Kernel Metadata</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#running-the-kernel" id="id215">Running the Kernel</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#tutorial-linking-with-libdevice" id="id216">Tutorial: Linking with Libdevice</a></p></li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id129" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>To support GPU programming, the NVPTX back-end supports a subset of LLVM IR
along with a defined set of conventions used to represent GPU programming
concepts. This document provides an overview of the general usage of the back-
end, including a description of the conventions used and the set of accepted
LLVM IR.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This document assumes a basic familiarity with CUDA and the PTX
assembly language. Information about the CUDA Driver API and the PTX assembly
language can be found in the <a class="reference external" href="http://docs.nvidia.com/cuda/index.html">CUDA documentation</a>.</p>
</div>
</section>
<section id="conventions">
<h2><a class="toc-backref" href="#id130" role="doc-backlink">Conventions</a><a class="headerlink" href="#conventions" title="Link to this heading">¶</a></h2>
<section id="marking-functions-as-kernels">
<h3><a class="toc-backref" href="#id131" role="doc-backlink">Marking Functions as Kernels</a><a class="headerlink" href="#marking-functions-as-kernels" title="Link to this heading">¶</a></h3>
<p>In PTX, there are two types of functions: <em>device functions</em>, which are only
callable by device code, and <em>kernel functions</em>, which are callable by host
code. By default, the back-end will emit device functions. The <code class="docutils literal notranslate"><span class="pre">ptx_kernel</span></code>
calling convention is used to declare a function as a kernel function.</p>
<p>The following example shows a kernel function calling a device function in LLVM
IR. The function <code class="docutils literal notranslate"><span class="pre">&#64;my_kernel</span></code> is callable from host code, but <code class="docutils literal notranslate"><span class="pre">&#64;my_fmad</span></code> is
not.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="vg">@my_fmad</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%z</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%mul</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">fmul</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="nv">%y</span>
<span class="w">  </span><span class="nv">%add</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">fadd</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%mul</span><span class="p">,</span><span class="w"> </span><span class="nv">%z</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%add</span>
<span class="p">}</span>

<span class="k">define</span><span class="w"> </span><span class="k">ptx_kernel</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@my_kernel</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%val</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%ptr</span>
<span class="w">  </span><span class="nv">%ret</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="vg">@my_fmad</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="nv">%val</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%val</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%val</span><span class="p">)</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%ret</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%ptr</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="k">void</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When compiled, the PTX kernel functions are callable by host-side code.</p>
</section>
<section id="function-attributes">
<span id="nvptx-fnattrs"></span><h3><a class="toc-backref" href="#id132" role="doc-backlink">Function Attributes</a><a class="headerlink" href="#function-attributes" title="Link to this heading">¶</a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&quot;nvvm.maxclusterrank&quot;=&quot;&lt;n&gt;&quot;</span></code></dt><dd><p>This attribute specifies the maximum number of blocks per cluster. Must be
non-zero. Only supported for Hopper+.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&quot;nvvm.minctasm&quot;=&quot;&lt;n&gt;&quot;</span></code></dt><dd><p>This indicates a hint/directive to the compiler/driver, asking it to put at
least these many CTAs on an SM.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&quot;nvvm.maxnreg&quot;=&quot;&lt;n&gt;&quot;</span></code></dt><dd><p>This attribute indicates the maximum number of registers to be used for the
kernel function.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&quot;nvvm.maxntid&quot;=&quot;&lt;x&gt;[,&lt;y&gt;[,&lt;z&gt;]]&quot;</span></code></dt><dd><p>This attribute declares the maximum number of threads in the thread block
(CTA). The maximum number of threads is the product of the maximum extent in
each dimension. Exceeding the maximum number of threads results in a runtime
error or kernel launch failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&quot;nvvm.reqntid&quot;=&quot;&lt;x&gt;[,&lt;y&gt;[,&lt;z&gt;]]&quot;</span></code></dt><dd><p>This attribute declares the exact number of threads in the thread block
(CTA). The number of threads is the product of the value in each dimension.
Specifying a different CTA dimension at launch will result in a runtime
error or kernel launch failure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&quot;nvvm.cluster_dim&quot;=&quot;&lt;x&gt;[,&lt;y&gt;[,&lt;z&gt;]]&quot;</span></code></dt><dd><p>This attribute declares the number of thread blocks (CTAs) in the cluster.
The total number of CTAs is the product of the number of CTAs in each
dimension. Specifying a different cluster dimension at launch will result in
a runtime error or kernel launch failure. Only supported for Hopper+.</p>
</dd>
</dl>
</section>
<section id="address-spaces">
<span id="id1"></span><h3><a class="toc-backref" href="#id133" role="doc-backlink">Address Spaces</a><a class="headerlink" href="#address-spaces" title="Link to this heading">¶</a></h3>
<p>The NVPTX back-end uses the following address space mapping:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Address Space</p></th>
<th class="head"><p>Memory Space</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>Generic</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>Global</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>Internal Use</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>Shared</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>Constant</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>Local</p></td>
</tr>
<tr class="row-even"><td><p>7</p></td>
<td><p>Shared Cluster</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Every global variable and pointer type is assigned to one of these address
spaces, with 0 being the default address space. Intrinsics are provided which
can be used to convert pointers between the generic and non-generic address
spaces.</p>
<p>As an example, the following IR will define an array <code class="docutils literal notranslate"><span class="pre">&#64;g</span></code> that resides in
global device memory.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="vg">@g</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">internal</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="k">global</span><span class="w"> </span><span class="p">[</span><span class="m">4</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i32</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="p">]</span>
</pre></div>
</div>
<p>LLVM IR functions can read and write to this array, and host-side code can
copy data to it by name with the CUDA Driver API.</p>
<p>Note that since address space 0 is the generic space, it is illegal to have
global variables in address space 0.  Address space 0 is the default address
space in LLVM, so the <code class="docutils literal notranslate"><span class="pre">addrspace(N)</span></code> annotation is <em>required</em> for global
variables.</p>
</section>
<section id="triples">
<h3><a class="toc-backref" href="#id134" role="doc-backlink">Triples</a><a class="headerlink" href="#triples" title="Link to this heading">¶</a></h3>
<p>The NVPTX target uses the module triple to select between 32/64-bit code
generation and the driver-compiler interface to use. The triple architecture
can be one of <code class="docutils literal notranslate"><span class="pre">nvptx</span></code> (32-bit PTX) or <code class="docutils literal notranslate"><span class="pre">nvptx64</span></code> (64-bit PTX). The
operating system should be one of <code class="docutils literal notranslate"><span class="pre">cuda</span></code> or <code class="docutils literal notranslate"><span class="pre">nvcl</span></code>, which determines the
interface used by the generated code to communicate with the driver.  Most
users will want to use <code class="docutils literal notranslate"><span class="pre">cuda</span></code> as the operating system, which makes the
generated PTX compatible with the CUDA Driver API.</p>
<p>Example: 32-bit PTX for CUDA Driver API: <code class="docutils literal notranslate"><span class="pre">nvptx-nvidia-cuda</span></code></p>
<p>Example: 64-bit PTX for CUDA Driver API: <code class="docutils literal notranslate"><span class="pre">nvptx64-nvidia-cuda</span></code></p>
</section>
</section>
<section id="nvptx-architecture-hierarchy-and-ordering">
<span id="nvptx-arch-hierarchy"></span><h2><a class="toc-backref" href="#id135" role="doc-backlink">NVPTX Architecture Hierarchy and Ordering</a><a class="headerlink" href="#nvptx-architecture-hierarchy-and-ordering" title="Link to this heading">¶</a></h2>
<p>GPU architectures: sm_2Y/sm_3Y/sm_5Y/sm_6Y/sm_7Y/sm_8Y/sm_9Y/sm_10Y/sm_12Y
(‘Y’ represents version within the architecture)
The architectures have name of form <code class="docutils literal notranslate"><span class="pre">sm_XYz</span></code> where <code class="docutils literal notranslate"><span class="pre">X</span></code> represent the generation
number, <code class="docutils literal notranslate"><span class="pre">Y</span></code> represents the version within the architecture, and <code class="docutils literal notranslate"><span class="pre">z</span></code> represents
the optional feature suffix.
If <code class="docutils literal notranslate"><span class="pre">X1Y1</span> <span class="pre">&lt;=</span> <span class="pre">X2Y2</span></code>, then GPU capabilities of <code class="docutils literal notranslate"><span class="pre">sm_X1Y1</span></code> are included in <code class="docutils literal notranslate"><span class="pre">sm_X2Y2</span></code>.
For example, take <code class="docutils literal notranslate"><span class="pre">sm_90</span></code> (9 represents <code class="docutils literal notranslate"><span class="pre">X</span></code>, 0 represents <code class="docutils literal notranslate"><span class="pre">Y</span></code>, and no feature
suffix) and <code class="docutils literal notranslate"><span class="pre">sm_103</span></code> architectures (10 represents <code class="docutils literal notranslate"><span class="pre">X</span></code>, 3 represents <code class="docutils literal notranslate"><span class="pre">Y</span></code>, and no
feature suffix). Since 90 &lt;= 103, <code class="docutils literal notranslate"><span class="pre">sm_90</span></code> is compatible with <code class="docutils literal notranslate"><span class="pre">sm_103</span></code>.</p>
<p>The family-specific variants have <code class="docutils literal notranslate"><span class="pre">f</span></code> feature suffix and they follow
following order:
<code class="docutils literal notranslate"><span class="pre">sm_X{Y2}f</span> <span class="pre">&gt;</span> <span class="pre">sm_X{Y1}f</span></code> iff <code class="docutils literal notranslate"><span class="pre">Y2</span> <span class="pre">&gt;</span> <span class="pre">Y1</span></code>
<code class="docutils literal notranslate"><span class="pre">sm_XY{f}</span> <span class="pre">&gt;</span> <span class="pre">sm_{XY}{}</span></code></p>
<p>For example, take <code class="docutils literal notranslate"><span class="pre">sm_100f</span></code> (10 represents <code class="docutils literal notranslate"><span class="pre">X</span></code>, 0 represents <code class="docutils literal notranslate"><span class="pre">Y</span></code>, and <code class="docutils literal notranslate"><span class="pre">f</span></code>
represents <code class="docutils literal notranslate"><span class="pre">z</span></code>) and <code class="docutils literal notranslate"><span class="pre">sm_103f</span></code> (10 represents <code class="docutils literal notranslate"><span class="pre">X</span></code>, 3 represents <code class="docutils literal notranslate"><span class="pre">Y</span></code>, and <code class="docutils literal notranslate"><span class="pre">f</span></code>
represents <code class="docutils literal notranslate"><span class="pre">z</span></code>) architecture variants. Since <code class="docutils literal notranslate"><span class="pre">Y1</span> <span class="pre">&lt;</span> <span class="pre">Y2</span></code>, <code class="docutils literal notranslate"><span class="pre">sm_100f</span></code> is compatible with
<code class="docutils literal notranslate"><span class="pre">sm_103f</span></code>. Similarly based on the second rule, <code class="docutils literal notranslate"><span class="pre">sm_90</span></code> is compatible with <code class="docutils literal notranslate"><span class="pre">sm_103f</span></code>.</p>
<p>Some counter examples, take <code class="docutils literal notranslate"><span class="pre">sm_100f</span></code> and <code class="docutils literal notranslate"><span class="pre">sm_120f</span></code> (12 represents <code class="docutils literal notranslate"><span class="pre">X</span></code>, 0
represents <code class="docutils literal notranslate"><span class="pre">Y</span></code>, and <code class="docutils literal notranslate"><span class="pre">f</span></code> represents <code class="docutils literal notranslate"><span class="pre">z</span></code>) architecture variants. Since both
belongs to different family i.e. <code class="docutils literal notranslate"><span class="pre">X1</span> <span class="pre">!=</span> <span class="pre">X2</span></code>, <code class="docutils literal notranslate"><span class="pre">sm_100f</span></code> is not compatible with
<code class="docutils literal notranslate"><span class="pre">sm_120f</span></code>.</p>
<p>The architecture-specific variants have <code class="docutils literal notranslate"><span class="pre">a</span></code> feature suffix and they follow
following order:
<code class="docutils literal notranslate"><span class="pre">sm_XY{a}</span> <span class="pre">&gt;</span> <span class="pre">sm_XY{f}</span> <span class="pre">&gt;</span> <span class="pre">sm_{XY}{}</span></code></p>
<p>For example, take <code class="docutils literal notranslate"><span class="pre">sm_103a</span></code> (10 represents <code class="docutils literal notranslate"><span class="pre">X</span></code>, 3 represents <code class="docutils literal notranslate"><span class="pre">Y</span></code>, and <code class="docutils literal notranslate"><span class="pre">a</span></code>
represents <code class="docutils literal notranslate"><span class="pre">z</span></code>), <code class="docutils literal notranslate"><span class="pre">sm_103f</span></code>, and <code class="docutils literal notranslate"><span class="pre">sm_103</span></code> architecture variants. The <code class="docutils literal notranslate"><span class="pre">sm_103</span></code> is
compatible with <code class="docutils literal notranslate"><span class="pre">sm_103a</span></code> and <code class="docutils literal notranslate"><span class="pre">sm_103f</span></code>, and <code class="docutils literal notranslate"><span class="pre">sm_103f</span></code> is compatible with <code class="docutils literal notranslate"><span class="pre">sm_103a</span></code>.</p>
<p>Encoding := Arch * 10 + 2 (for ‘f’) + 1 (for ‘a’)
Arch := X * 10 + Y</p>
<p>For example, <code class="docutils literal notranslate"><span class="pre">sm_103f</span></code> is encoded as 1032 (103 * 10 + 2) and <code class="docutils literal notranslate"><span class="pre">sm_103a</span></code> is
encoded as 1033 (103 * 10 + 2 + 1).</p>
<p>This encoding allows simple partial ordering of the architectures.</p>
<ul class="simple">
<li><p>Compare Family and Arch by dividing FullSMVersion by 100 and 10
respectively before the comparison.</p></li>
<li><p>Compare within the family by comparing FullSMVersion, given both belongs to
the same family.</p></li>
<li><p>Detect <code class="docutils literal notranslate"><span class="pre">a</span></code> variants by checking FullSMVersion &amp; 1.</p></li>
</ul>
</section>
<section id="nvptx-intrinsics">
<span id="id2"></span><h2><a class="toc-backref" href="#id136" role="doc-backlink">NVPTX Intrinsics</a><a class="headerlink" href="#nvptx-intrinsics" title="Link to this heading">¶</a></h2>
<section id="reading-ptx-special-registers">
<h3><a class="toc-backref" href="#id137" role="doc-backlink">Reading PTX Special Registers</a><a class="headerlink" href="#reading-ptx-special-registers" title="Link to this heading">¶</a></h3>
<section id="llvm-nvvm-read-ptx-sreg">
<h4><a class="toc-backref" href="#id138" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.read.ptx.sreg.*</span></code>’</a><a class="headerlink" href="#llvm-nvvm-read-ptx-sreg" title="Link to this heading">¶</a></h4>
<section id="syntax">
<h5>Syntax:<a class="headerlink" href="#syntax" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.tid.x</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.tid.y</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.tid.z</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.ntid.x</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.ntid.y</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.ntid.z</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.ctaid.x</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.ctaid.y</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.ctaid.z</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.nctaid.x</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.nctaid.y</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.nctaid.z</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.warpsize</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="overview">
<h5>Overview:<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.read.ptx.sreg.*</span></code>’ intrinsics provide access to the PTX
special registers, in particular the kernel launch bounds.  These registers
map in the following way to CUDA builtins:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>CUDA Builtin</p></th>
<th class="head"><p>PTX Special Register Intrinsic</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">threadId</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.read.ptx.sreg.tid.*</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">blockIdx</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.read.ptx.sreg.ctaid.*</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">blockDim</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.read.ptx.sreg.ntid.*</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">gridDim</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.read.ptx.sreg.nctaid.*</span></code></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</section>
</section>
</section>
<section id="barriers">
<h3><a class="toc-backref" href="#id139" role="doc-backlink">Barriers</a><a class="headerlink" href="#barriers" title="Link to this heading">¶</a></h3>
<section id="llvm-nvvm-barrier-cta">
<h4><a class="toc-backref" href="#id140" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.barrier.cta.*</span></code>’</a><a class="headerlink" href="#llvm-nvvm-barrier-cta" title="Link to this heading">¶</a></h4>
<section id="id3">
<h5>Syntax:<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.barrier.cta.sync.count</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%id</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.barrier.cta.sync.all</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%id</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.barrier.cta.arrive.count</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%id</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">)</span>

<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.barrier.cta.sync.aligned.count</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%id</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.barrier.cta.sync.aligned.all</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%id</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.barrier.cta.arrive.aligned.count</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%id</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id4">
<h5>Overview:<a class="headerlink" href="#id4" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.barrier.cta.*</span></code>’ family of intrinsics perform barrier
synchronization and communication within a CTA. They can be used by the threads
within the CTA for synchronization and communication.</p>
</section>
<section id="semantics">
<h5>Semantics:<a class="headerlink" href="#semantics" title="Link to this heading">¶</a></h5>
<p>Operand %id specifies a logical barrier resource and must fall within the range
0 through 15. When present, operand %n specifies the number of threads
participating in the barrier. When specifying a thread count, the value must be
a multiple of the warp size. With the ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.barrier.cta.sync.*</span></code>’
variants, the ‘<code class="docutils literal notranslate"><span class="pre">.all</span></code>’ suffix indicates that all threads in the CTA should
participate in the barrier while the ‘<code class="docutils literal notranslate"><span class="pre">.count</span></code>’ suffix indicates that only
the threads specified by the %n operand should participate in the barrier.</p>
<p>All forms of the ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.barrier.cta.*</span></code>’ intrinsic cause the executing
thread to wait for all non-exited threads from its warp and then marks the
warp’s arrival at the barrier. In addition to signaling its arrival at the
barrier, the ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.barrier.cta.sync.*</span></code>’ intrinsics cause the executing
thread to wait for non-exited threads of all other warps participating in the
barrier to arrive. On the other hand, the ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.barrier.cta.arrive.*</span></code>’
intrinsic does not cause the executing thread to wait for threads of other
participating warps.</p>
<p>When a barrier completes, the waiting threads are restarted without delay,
and the barrier is reinitialized so that it can be immediately reused.</p>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.barrier.cta.*</span></code>’ intrinsic has an optional ‘<code class="docutils literal notranslate"><span class="pre">.aligned</span></code>’
modifier to indicate textual alignment of the barrier. When specified, it
indicates that all threads in the CTA will execute the same
‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.barrier.cta.*</span></code>’ instruction. In conditionally executed code, an
aligned ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.barrier.cta.*</span></code>’ instruction should only be used if it is
known that all threads in the CTA evaluate the condition identically, otherwise
behavior is undefined.</p>
</section>
</section>
</section>
<section id="electing-a-thread">
<h3><a class="toc-backref" href="#id141" role="doc-backlink">Electing a thread</a><a class="headerlink" href="#electing-a-thread" title="Link to this heading">¶</a></h3>
<section id="llvm-nvvm-elect-sync">
<h4><a class="toc-backref" href="#id142" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.elect.sync</span></code>’</a><a class="headerlink" href="#llvm-nvvm-elect-sync" title="Link to this heading">¶</a></h4>
<section id="id5">
<h5>Syntax:<a class="headerlink" href="#id5" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="p">{</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="p">}</span><span class="w"> </span><span class="vg">@llvm.nvvm.elect.sync</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%membermask</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id6">
<h5>Overview:<a class="headerlink" href="#id6" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.elect.sync</span></code>’ intrinsic generates the <code class="docutils literal notranslate"><span class="pre">elect.sync</span></code>
PTX instruction, which elects one predicated active leader thread from
a set of threads specified by <code class="docutils literal notranslate"><span class="pre">membermask</span></code>. The behavior is undefined
if the executing thread is not in <code class="docutils literal notranslate"><span class="pre">membermask</span></code>. The laneid of the
elected thread is captured in the i32 return value. The i1 return
value is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> for the leader thread and <code class="docutils literal notranslate"><span class="pre">False</span></code> for all
the other threads. Election of a leader thread happens deterministically,
i.e. the same leader thread is elected for the same <code class="docutils literal notranslate"><span class="pre">membermask</span></code>
every time. For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-elect-sync">https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-elect-sync</a>.</p>
</section>
</section>
</section>
<section id="membar-fences">
<h3><a class="toc-backref" href="#id143" role="doc-backlink">Membar/Fences</a><a class="headerlink" href="#membar-fences" title="Link to this heading">¶</a></h3>
<section id="llvm-nvvm-fence-proxy-tensormap-generic">
<h4><a class="toc-backref" href="#id144" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fence.proxy.tensormap_generic.*</span></code>’</a><a class="headerlink" href="#llvm-nvvm-fence-proxy-tensormap-generic" title="Link to this heading">¶</a></h4>
<section id="id7">
<h5>Syntax:<a class="headerlink" href="#id7" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.fence.proxy.tensormap_generic.release.cta</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.fence.proxy.tensormap_generic.release.cluster</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.fence.proxy.tensormap_generic.release.gpu</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.fence.proxy.tensormap_generic.release.sys</span><span class="p">()</span>

<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.fence.proxy.tensormap_generic.acquire.cta</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%size</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.fence.proxy.tensormap_generic.acquire.cluster</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%size</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.fence.proxy.tensormap_generic.acquire.gpu</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%size</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.fence.proxy.tensormap_generic.acquire.sys</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%size</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id8">
<h5>Overview:<a class="headerlink" href="#id8" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.fence.proxy.tensormap_generic.*</span></code> is a uni-directional fence used to establish ordering between a prior memory access performed via the generic <cite>proxy&lt;https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#proxies&gt;_</cite> and a subsequent memory access performed via the tensormap proxy. <code class="docutils literal notranslate"><span class="pre">nvvm.fence.proxy.tensormap_generic.release</span></code> can form a release sequence that synchronizes with an acquire sequence that contains the <code class="docutils literal notranslate"><span class="pre">nvvm.fence.proxy.tensormap_generic.acquire</span></code> proxy fence. The following table describes the mapping between LLVM Intrinsic and the PTX instruction:</p>
<blockquote>
<div><table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>NVVM Intrinsic</p></th>
<th class="head"><p>PTX Instruction</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.fence.proxy.tensormap_generic.release.*</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fence.proxy.tensormap::generic.release.*</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.fence.proxy.tensormap_generic.acquire.*</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fence.proxy.tensormap::generic.acquire.*</span> <span class="pre">[addr],</span> <span class="pre">size</span></code></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The address operand <code class="docutils literal notranslate"><span class="pre">addr</span></code> and the operand <code class="docutils literal notranslate"><span class="pre">size</span></code> together specify the memory range <code class="docutils literal notranslate"><span class="pre">[addr,</span> <span class="pre">addr+size)</span></code> on which the ordering guarantees on the memory accesses across the proxies is to be provided. The only supported value for the <code class="docutils literal notranslate"><span class="pre">size</span></code> operand is <code class="docutils literal notranslate"><span class="pre">128</span></code> and must be an immediate. Generic Addressing is used unconditionally, and the address specified by the operand addr must fall within the <code class="docutils literal notranslate"><span class="pre">.global</span></code> state space. Otherwise, the behavior is undefined. For more information, see <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-membar">PTX ISA</a>.</p>
</section>
</section>
</section>
<section id="address-space-intrinsics">
<h3><a class="toc-backref" href="#id145" role="doc-backlink">Address Space Intrinsics</a><a class="headerlink" href="#address-space-intrinsics" title="Link to this heading">¶</a></h3>
<section id="llvm-nvvm-isspacep-intrinsics">
<h4><a class="toc-backref" href="#id146" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.isspacep.*</span></code>’ Intrinsics</a><a class="headerlink" href="#llvm-nvvm-isspacep-intrinsics" title="Link to this heading">¶</a></h4>
<section id="id9">
<h5>Syntax:<a class="headerlink" href="#id9" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.nvvm.isspacep.const</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.nvvm.isspacep.global</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.nvvm.isspacep.local</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.nvvm.isspacep.shared</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.nvvm.isspacep.shared.cluster</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id10">
<h5>Overview:<a class="headerlink" href="#id10" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.isspacep.*</span></code>’ intrinsics determine whether the provided generic
pointer references memory which falls within a particular address space.</p>
</section>
<section id="id11">
<h5>Semantics:<a class="headerlink" href="#id11" title="Link to this heading">¶</a></h5>
<p>If the given pointer in the generic address space refers to memory which falls
within the state space of the intrinsic (and therefore could be safely address
space casted to this space), 1 is returned, otherwise 0 is returned.</p>
</section>
</section>
<section id="llvm-nvvm-mapa-intrinsics">
<h4><a class="toc-backref" href="#id147" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.mapa.*</span></code>’ Intrinsics</a><a class="headerlink" href="#llvm-nvvm-mapa-intrinsics" title="Link to this heading">¶</a></h4>
<section id="id12">
<h5>Syntax:<a class="headerlink" href="#id12" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.nvvm.mapa</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%rank</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">7</span><span class="p">)</span><span class="w"> </span><span class="vg">@llvm.nvvm.mapa.shared.cluster</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%p</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%rank</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id13">
<h5>Overview:<a class="headerlink" href="#id13" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.mapa.*</span></code>’ intrinsics map a shared memory pointer <code class="docutils literal notranslate"><span class="pre">p</span></code> of another CTA with <code class="docutils literal notranslate"><span class="pre">%rank</span></code> to the current CTA.
The <code class="docutils literal notranslate"><span class="pre">llvm.nvvm.mapa</span></code> form expects a generic pointer to shared memory and returns a generic pointer to shared cluster memory.
The <code class="docutils literal notranslate"><span class="pre">llvm.nvvm.mapa.shared.cluster</span></code> form expects a pointer to shared memory and returns a pointer to shared cluster memory.
They corresponds directly to the <code class="docutils literal notranslate"><span class="pre">mapa</span></code> and <code class="docutils literal notranslate"><span class="pre">mapa.shared.cluster</span></code> PTX instructions.</p>
</section>
<section id="id14">
<h5>Semantics:<a class="headerlink" href="#id14" title="Link to this heading">¶</a></h5>
<p>If the given pointer in the generic address space refers to memory which falls
within the state space of the intrinsic (and therefore could be safely address
space casted to this space), 1 is returned, otherwise 0 is returned.</p>
</section>
</section>
</section>
<section id="arithmetic-intrinsics">
<h3><a class="toc-backref" href="#id148" role="doc-backlink">Arithmetic Intrinsics</a><a class="headerlink" href="#arithmetic-intrinsics" title="Link to this heading">¶</a></h3>
<section id="llvm-nvvm-fabs-intrinsic">
<h4><a class="toc-backref" href="#id149" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fabs.*</span></code>’ Intrinsic</a><a class="headerlink" href="#llvm-nvvm-fabs-intrinsic" title="Link to this heading">¶</a></h4>
<section id="id15">
<h5>Syntax:<a class="headerlink" href="#id15" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="vg">@llvm.nvvm.fabs.f32</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="nv">%a</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="vg">@llvm.nvvm.fabs.f64</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="nv">%a</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">half</span><span class="w"> </span><span class="vg">@llvm.nvvm.fabs.f16</span><span class="p">(</span><span class="kt">half</span><span class="w"> </span><span class="nv">%a</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="p">&lt;</span><span class="m">2</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">half</span><span class="p">&gt;</span><span class="w"> </span><span class="vg">@llvm.nvvm.fabs.v2f16</span><span class="p">(&lt;</span><span class="m">2</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">half</span><span class="p">&gt;</span><span class="w"> </span><span class="nv">%a</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">bfloat</span><span class="w"> </span><span class="vg">@llvm.nvvm.fabs.bf16</span><span class="p">(</span><span class="kt">bfloat</span><span class="w"> </span><span class="nv">%a</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="p">&lt;</span><span class="m">2</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">bfloat</span><span class="p">&gt;</span><span class="w"> </span><span class="vg">@llvm.nvvm.fabs.v2bf16</span><span class="p">(&lt;</span><span class="m">2</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">bfloat</span><span class="p">&gt;</span><span class="w"> </span><span class="nv">%a</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id16">
<h5>Overview:<a class="headerlink" href="#id16" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fabs.*</span></code>’ intrinsics return the absolute value of the operand.</p>
</section>
<section id="id17">
<h5>Semantics:<a class="headerlink" href="#id17" title="Link to this heading">¶</a></h5>
<p>Unlike, ‘<code class="docutils literal notranslate"><span class="pre">llvm.fabs.*</span></code>’, these intrinsics do not perfectly preserve NaN
values. Instead, a NaN input yeilds an unspecified NaN output.</p>
</section>
</section>
<section id="llvm-nvvm-fabs-ftz-intrinsic">
<h4><a class="toc-backref" href="#id150" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fabs.ftz.*</span></code>’ Intrinsic</a><a class="headerlink" href="#llvm-nvvm-fabs-ftz-intrinsic" title="Link to this heading">¶</a></h4>
<section id="id18">
<h5>Syntax:<a class="headerlink" href="#id18" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="vg">@llvm.nvvm.fabs.ftz.f32</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="nv">%a</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">half</span><span class="w"> </span><span class="vg">@llvm.nvvm.fabs.ftz.f16</span><span class="p">(</span><span class="kt">half</span><span class="w"> </span><span class="nv">%a</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="p">&lt;</span><span class="m">2</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">half</span><span class="p">&gt;</span><span class="w"> </span><span class="vg">@llvm.nvvm.fabs.ftz.v2f16</span><span class="p">(&lt;</span><span class="m">2</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">half</span><span class="p">&gt;</span><span class="w"> </span><span class="nv">%a</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id19">
<h5>Overview:<a class="headerlink" href="#id19" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fabs.ftz.*</span></code>’ intrinsics return the absolute value of the
operand, flushing subnormals to sign preserving zero.</p>
</section>
<section id="id20">
<h5>Semantics:<a class="headerlink" href="#id20" title="Link to this heading">¶</a></h5>
<p>Before the absolute value is taken, the input is flushed to sign preserving
zero if it is a subnormal. In addition, unlike ‘<code class="docutils literal notranslate"><span class="pre">llvm.fabs.*</span></code>’, a NaN input
yields an unspecified NaN output.</p>
</section>
</section>
<section id="llvm-nvvm-idp2a-us-us-intrinsics">
<h4><a class="toc-backref" href="#id151" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp2a.[us].[us]</span></code>’ Intrinsics</a><a class="headerlink" href="#llvm-nvvm-idp2a-us-us-intrinsics" title="Link to this heading">¶</a></h4>
<section id="id21">
<h5>Syntax:<a class="headerlink" href="#id21" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.idp2a.s.s</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">immarg</span><span class="w"> </span><span class="nv">%is.hi</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%c</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.idp2a.s.u</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">immarg</span><span class="w"> </span><span class="nv">%is.hi</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%c</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.idp2a.u.s</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">immarg</span><span class="w"> </span><span class="nv">%is.hi</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%c</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.idp2a.u.u</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">immarg</span><span class="w"> </span><span class="nv">%is.hi</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%c</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id22">
<h5>Overview:<a class="headerlink" href="#id22" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp2a.[us].[us]</span></code>’ intrinsics performs a 2-element vector dot
product followed by addition. They corresponds directly to the <code class="docutils literal notranslate"><span class="pre">dp2a</span></code> PTX
instruction.</p>
</section>
<section id="id23">
<h5>Semantics:<a class="headerlink" href="#id23" title="Link to this heading">¶</a></h5>
<p>The 32-bit value in <code class="docutils literal notranslate"><span class="pre">%a</span></code> is broken into 2 16-bit values which are extended to
32 bits. For the ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp2a.u.[us]</span></code>’ variants zero-extension is used,
while for the ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp2a.s.[us]</span></code>’ sign-extension is used. Two bytes are
selected from <code class="docutils literal notranslate"><span class="pre">%b</span></code>, if <code class="docutils literal notranslate"><span class="pre">%is.hi</span></code> is true, the most significant bytes are
selected, otherwise the least significant bytes are selected. These bytes are
then extended to 32-bits. For the ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp2a.[us].u</span></code>’ variants
zero-extension is used, while for the ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp2a.[us].s</span></code>’
sign-extension is used. The dot product of these 2-element vectors is added to
<code class="docutils literal notranslate"><span class="pre">%c</span></code> to produce the return.</p>
</section>
</section>
<section id="llvm-nvvm-idp4a-us-us-intrinsics">
<h4><a class="toc-backref" href="#id152" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp4a.[us].[us]</span></code>’ Intrinsics</a><a class="headerlink" href="#llvm-nvvm-idp4a-us-us-intrinsics" title="Link to this heading">¶</a></h4>
<section id="id24">
<h5>Syntax:<a class="headerlink" href="#id24" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.idp4a.s.s</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%c</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.idp4a.s.u</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%c</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.idp4a.u.s</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%c</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.idp4a.u.u</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%c</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id25">
<h5>Overview:<a class="headerlink" href="#id25" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp4a.[us].[us]</span></code>’ intrinsics perform a 4-element vector dot
product followed by addition. They corresponds directly to the <code class="docutils literal notranslate"><span class="pre">dp4a</span></code> PTX
instruction.</p>
</section>
<section id="id26">
<h5>Semantics:<a class="headerlink" href="#id26" title="Link to this heading">¶</a></h5>
<p>Each of the 4 bytes in both <code class="docutils literal notranslate"><span class="pre">%a</span></code> and <code class="docutils literal notranslate"><span class="pre">%b</span></code> are extended to 32-bit integers
forming 2 <code class="docutils literal notranslate"><span class="pre">&lt;4</span> <span class="pre">x</span> <span class="pre">i32&gt;</span></code>. For <code class="docutils literal notranslate"><span class="pre">%a</span></code>, zero-extension is used in the
‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp4a.u.[us]</span></code>’ variants, while sign-extension is used with
‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp4a.s.[us]</span></code>’ variants. Similarly, for <code class="docutils literal notranslate"><span class="pre">%b</span></code>, zero-extension is
used in the ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp4a.[us].u</span></code>’ variants, while sign-extension is used
with ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.idp4a.[us].s</span></code>’ variants. The dot product of these 4-element
vectors is added to <code class="docutils literal notranslate"><span class="pre">%c</span></code> to produce the return.</p>
</section>
</section>
</section>
<section id="bit-manipulation-intrinsics">
<h3><a class="toc-backref" href="#id153" role="doc-backlink">Bit Manipulation Intrinsics</a><a class="headerlink" href="#bit-manipulation-intrinsics" title="Link to this heading">¶</a></h3>
<section id="llvm-nvvm-fshl-clamp-intrinsic">
<h4><a class="toc-backref" href="#id154" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fshl.clamp.*</span></code>’ Intrinsic</a><a class="headerlink" href="#llvm-nvvm-fshl-clamp-intrinsic" title="Link to this heading">¶</a></h4>
<section id="id27">
<h5>Syntax:<a class="headerlink" href="#id27" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.fshl.clamp.i32</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%hi</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%lo</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id28">
<h5>Overview:<a class="headerlink" href="#id28" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fshl.clamp</span></code>’ family of intrinsics performs a clamped funnel
shift left. These intrinsics are very similar to ‘<code class="docutils literal notranslate"><span class="pre">llvm.fshl</span></code>’, except the
shift amount is clamped at the integer width (instead of modulo it). Currently,
only <code class="docutils literal notranslate"><span class="pre">i32</span></code> is supported.</p>
</section>
<section id="id29">
<h5>Semantics:<a class="headerlink" href="#id29" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fshl.clamp</span></code>’ family of intrinsic functions performs a clamped
funnel shift left: the first two values are concatenated as { %hi : %lo } (%hi
is the most significant bits of the wide value), the combined value is shifted
left, and the most significant bits are extracted to produce a result that is
the same size as the original arguments. The shift amount is the minimum of the
value of %n and the bit width of the integer type.</p>
</section>
</section>
<section id="llvm-nvvm-fshr-clamp-intrinsic">
<h4><a class="toc-backref" href="#id155" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fshr.clamp.*</span></code>’ Intrinsic</a><a class="headerlink" href="#llvm-nvvm-fshr-clamp-intrinsic" title="Link to this heading">¶</a></h4>
<section id="id30">
<h5>Syntax:<a class="headerlink" href="#id30" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.fshr.clamp.i32</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%hi</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%lo</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id31">
<h5>Overview:<a class="headerlink" href="#id31" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fshr.clamp</span></code>’ family of intrinsics perform a clamped funnel
shift right. These intrinsics are very similar to ‘<code class="docutils literal notranslate"><span class="pre">llvm.fshr</span></code>’, except the
shift amount is clamped at the integer width (instead of modulo it). Currently,
only <code class="docutils literal notranslate"><span class="pre">i32</span></code> is supported.</p>
</section>
<section id="id32">
<h5>Semantics:<a class="headerlink" href="#id32" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.fshr.clamp</span></code>’ family of intrinsic functions performs a clamped
funnel shift right: the first two values are concatenated as { %hi : %lo } (%hi
is the most significant bits of the wide value), the combined value is shifted
right, and the least significant bits are extracted to produce a result that is
the same size as the original arguments. The shift amount is the minimum of the
value of %n and the bit width of the integer type.</p>
</section>
</section>
<section id="llvm-nvvm-flo-u-intrinsic">
<h4><a class="toc-backref" href="#id156" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.flo.u.*</span></code>’ Intrinsic</a><a class="headerlink" href="#llvm-nvvm-flo-u-intrinsic" title="Link to this heading">¶</a></h4>
<section id="id33">
<h5>Syntax:<a class="headerlink" href="#id33" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.flo.u.i32</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%shiftamt</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.flo.u.i64</span><span class="p">(</span><span class="kt">i64</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%shiftamt</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id34">
<h5>Overview:<a class="headerlink" href="#id34" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.flo.u</span></code>’ family of intrinsics identifies the bit position of the
leading one, returning either it’s offset from the most or least significant bit.</p>
</section>
<section id="id35">
<h5>Semantics:<a class="headerlink" href="#id35" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.flo.u</span></code>’ family of intrinsics returns the bit position of the
most significant 1. If %shiftamt is true, The result is the shift amount needed
to left-shift the found bit into the most-significant bit position, otherwise
the result is the shift amount needed to right-shift the found bit into the
least-significant bit position. 0xffffffff is returned if no 1 bit is found.</p>
</section>
</section>
<section id="llvm-nvvm-flo-s-intrinsic">
<h4><a class="toc-backref" href="#id157" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.flo.s.*</span></code>’ Intrinsic</a><a class="headerlink" href="#llvm-nvvm-flo-s-intrinsic" title="Link to this heading">¶</a></h4>
<section id="id36">
<h5>Syntax:<a class="headerlink" href="#id36" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.flo.s.i32</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%shiftamt</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.flo.s.i64</span><span class="p">(</span><span class="kt">i64</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%shiftamt</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id37">
<h5>Overview:<a class="headerlink" href="#id37" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.flo.s</span></code>’ family of intrinsics identifies the bit position of the
leading non-sign bit, returning either it’s offset from the most or least
significant bit.</p>
</section>
<section id="id38">
<h5>Semantics:<a class="headerlink" href="#id38" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.flo.s</span></code>’ family of intrinsics returns the bit position of the
most significant 0 for negative inputs and the most significant 1 for
non-negative inputs. If %shiftamt is true, The result is the shift amount needed
to left-shift the found bit into the most-significant bit position, otherwise
the result is the shift amount needed to right-shift the found bit into the
least-significant bit position. 0xffffffff is returned if no 1 bit is found.</p>
</section>
</section>
<section id="llvm-nvvm-zext-sext-wrap-clamp-intrinsics">
<h4><a class="toc-backref" href="#id158" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.{zext,sext}.{wrap,clamp}</span></code>’ Intrinsics</a><a class="headerlink" href="#llvm-nvvm-zext-sext-wrap-clamp-intrinsics" title="Link to this heading">¶</a></h4>
<section id="id39">
<h5>Syntax:<a class="headerlink" href="#id39" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.zext.wrap</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.zext.clamp</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.sext.wrap</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.sext.clamp</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id40">
<h5>Overview:<a class="headerlink" href="#id40" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.{zext,sext}.{wrap,clamp}</span></code>’ family of intrinsics extracts the
low bits of the input value, and zero- or sign-extends them back to the original
width.</p>
</section>
<section id="id41">
<h5>Semantics:<a class="headerlink" href="#id41" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.{zext,sext}.{wrap,clamp}</span></code>’ family of intrinsics returns
extension of N lowest bits of operand %a. For the ‘<code class="docutils literal notranslate"><span class="pre">wrap</span></code>’ variants, N is the
value of operand %b modulo 32. For the ‘<code class="docutils literal notranslate"><span class="pre">clamp</span></code>’ variants, N is the value of
operand %b clamped to the range [0, 32]. The N lowest bits are then
zero-extended the case of the ‘<code class="docutils literal notranslate"><span class="pre">zext</span></code>’ variants, or sign-extended the case of
the ‘<code class="docutils literal notranslate"><span class="pre">sext</span></code>’ variants. If N is 0, the result is 0.</p>
</section>
</section>
<section id="llvm-nvvm-bmsk-wrap-clamp-intrinsic">
<h4><a class="toc-backref" href="#id159" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.bmsk.{wrap,clamp}</span></code>’ Intrinsic</a><a class="headerlink" href="#llvm-nvvm-bmsk-wrap-clamp-intrinsic" title="Link to this heading">¶</a></h4>
<section id="id42">
<h5>Syntax:<a class="headerlink" href="#id42" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.bmsk.wrap</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.bmsk.clamp</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id43">
<h5>Overview:<a class="headerlink" href="#id43" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.bmsk.{wrap,clamp}</span></code>’ family of intrinsics creates a bit mask
given a starting bit position and a bit width.</p>
</section>
<section id="id44">
<h5>Semantics:<a class="headerlink" href="#id44" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.bmsk.{wrap,clamp}</span></code>’ family of intrinsics returns a value with
all bits set to 0 except for %b bits starting at bit position %a. For the
‘<code class="docutils literal notranslate"><span class="pre">wrap</span></code>’ variants, the values of %a and %b modulo 32 are used. For the
‘<code class="docutils literal notranslate"><span class="pre">clamp</span></code>’ variants, the values of %a and %b are clamped to the range [0, 32],
which in practice is equivalent to using them as is.</p>
</section>
</section>
<section id="llvm-nvvm-prmt-intrinsic">
<h4><a class="toc-backref" href="#id160" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.prmt</span></code>’ Intrinsic</a><a class="headerlink" href="#llvm-nvvm-prmt-intrinsic" title="Link to this heading">¶</a></h4>
<section id="id45">
<h5>Syntax:<a class="headerlink" href="#id45" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.prmt</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%lo</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%hi</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%selector</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id46">
<h5>Overview:<a class="headerlink" href="#id46" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.prmt</span></code>’ constructs a permutation of the bytes of the first two
operands, selecting based on the third operand.</p>
</section>
<section id="id47">
<h5>Semantics:<a class="headerlink" href="#id47" title="Link to this heading">¶</a></h5>
<p>The bytes in the first two source operands are numbered from 0 to 7:
{%hi, %lo} = {{b7, b6, b5, b4}, {b3, b2, b1, b0}}. For each byte in the target
register, a 4-bit selection value is defined.</p>
<p>The 3 lsbs of the selection value specify which of the 8 source bytes should be
moved into the target position. The msb defines if the byte value should be
copied, or if the sign (msb of the byte) should be replicated over all 8 bits
of the target position (sign extend of the byte value); msb=0 means copy the
literal value; msb=1 means replicate the sign.</p>
<p>These 4-bit selection values are pulled from the lower 16-bits of the %selector
operand, with the least significant selection value corresponding to the least
significant byte of the destination.</p>
</section>
</section>
<section id="llvm-nvvm-prmt-intrinsics">
<h4><a class="toc-backref" href="#id161" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.prmt.*</span></code>’ Intrinsics</a><a class="headerlink" href="#llvm-nvvm-prmt-intrinsics" title="Link to this heading">¶</a></h4>
<section id="id48">
<h5>Syntax:<a class="headerlink" href="#id48" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.prmt.f4e</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%lo</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%hi</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%selector</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.prmt.b4e</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%lo</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%hi</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%selector</span><span class="p">)</span>

<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.prmt.rc8</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%lo</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%selector</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.prmt.ecl</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%lo</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%selector</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.prmt.ecr</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%lo</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%selector</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.prmt.rc16</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%lo</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%selector</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id49">
<h5>Overview:<a class="headerlink" href="#id49" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.prmt.*</span></code>’ family of intrinsics constructs a permutation of the
bytes of the first one or two operands, selecting based on the 2 least
significant bits of the final operand.</p>
</section>
<section id="id50">
<h5>Semantics:<a class="headerlink" href="#id50" title="Link to this heading">¶</a></h5>
<p>As with the generic ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.prmt</span></code>’ intrinsic, the bytes in the first one
or two source operands are numbered. The first source operand (%lo) is numbered
{b3, b2, b1, b0}, in the case of the ‘<code class="docutils literal notranslate"><span class="pre">f4e</span></code>’ and ‘<code class="docutils literal notranslate"><span class="pre">b4e</span></code>’ variants, the
second source operand (%hi) is numbered {b7, b6, b5, b4}.</p>
<p>Depending on the 2 least significant bits of the %selector operand, the result
of the permutation is defined as follows:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Mode</p></td>
<td><p>%selector[1:0]</p></td>
<td><p>Output</p></td>
</tr>
<tr class="row-even"><td rowspan="4"><p>‘<code class="docutils literal notranslate"><span class="pre">f4e</span></code>’</p></td>
<td><p>0</p></td>
<td><p>{3, 2, 1, 0}</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>{4, 3, 2, 1}</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>{5, 4, 3, 2}</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>{6, 5, 4, 3}</p></td>
</tr>
<tr class="row-even"><td rowspan="4"><p>‘<code class="docutils literal notranslate"><span class="pre">b4e</span></code>’</p></td>
<td><p>0</p></td>
<td><p>{5, 6, 7, 0}</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>{6, 7, 0, 1}</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>{7, 0, 1, 2}</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>{0, 1, 2, 3}</p></td>
</tr>
<tr class="row-even"><td rowspan="4"><p>‘<code class="docutils literal notranslate"><span class="pre">rc8</span></code>’</p></td>
<td><p>0</p></td>
<td><p>{0, 0, 0, 0}</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>{1, 1, 1, 1}</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>{2, 2, 2, 2}</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>{3, 3, 3, 3}</p></td>
</tr>
<tr class="row-even"><td rowspan="4"><p>‘<code class="docutils literal notranslate"><span class="pre">ecl</span></code>’</p></td>
<td><p>0</p></td>
<td><p>{3, 2, 1, 0}</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>{3, 2, 1, 1}</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>{3, 2, 2, 2}</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>{3, 3, 3, 3}</p></td>
</tr>
<tr class="row-even"><td rowspan="4"><p>‘<code class="docutils literal notranslate"><span class="pre">ecr</span></code>’</p></td>
<td><p>0</p></td>
<td><p>{0, 0, 0, 0}</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>{1, 1, 1, 0}</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>{2, 2, 1, 0}</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>{3, 2, 1, 0}</p></td>
</tr>
<tr class="row-even"><td rowspan="4"><p>‘<code class="docutils literal notranslate"><span class="pre">rc16</span></code>’</p></td>
<td><p>0</p></td>
<td><p>{1, 0, 1, 0}</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>{3, 2, 3, 2}</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>{1, 0, 1, 0}</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>{3, 2, 3, 2}</p></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
<section id="tma-family-of-intrinsics">
<h3><a class="toc-backref" href="#id162" role="doc-backlink">TMA family of Intrinsics</a><a class="headerlink" href="#tma-family-of-intrinsics" title="Link to this heading">¶</a></h3>
<section id="llvm-nvvm-cp-async-bulk-global-to-shared-cluster">
<h4><a class="toc-backref" href="#id163" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.global.to.shared.cluster</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-global-to-shared-cluster" title="Link to this heading">¶</a></h4>
<section id="id51">
<h5>Syntax:<a class="headerlink" href="#id51" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.global.to.shared.cluster</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">7</span><span class="p">)</span><span class="w"> </span><span class="nv">%dst</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%mbar</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%size</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%mc</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_mc</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id52">
<h5>Overview:<a class="headerlink" href="#id52" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.global.to.shared.cluster</span></code>’ intrinsic
corresponds to the <code class="docutils literal notranslate"><span class="pre">cp.async.bulk.shared::cluster.global.*</span></code> family
of PTX instructions. These instructions initiate an asynchronous
copy of bulk data from global memory to shared::cluster memory.
The 32-bit operand <code class="docutils literal notranslate"><span class="pre">%size</span></code> specifies the amount of memory to be
copied and it must be a multiple of 16.</p>
<ul class="simple">
<li><p>The last two arguments to these intrinsics are boolean flags
indicating support for cache_hint and/or multicast modifiers.
These flag arguments must be compile-time constants. The backend
looks through these flags and lowers the intrinsics appropriately.</p></li>
<li><p>The Nth argument (denoted by <code class="docutils literal notranslate"><span class="pre">i1</span> <span class="pre">%flag_ch</span></code>) when set, indicates
a valid cache_hint (<code class="docutils literal notranslate"><span class="pre">i64</span> <span class="pre">%ch</span></code>) and generates the <code class="docutils literal notranslate"><span class="pre">.L2::cache_hint</span></code>
variant of the PTX instruction.</p></li>
<li><p>The [N-1]th argument (denoted by <code class="docutils literal notranslate"><span class="pre">i1</span> <span class="pre">%flag_mc</span></code>) when set, indicates
the presence of a multicast mask (<code class="docutils literal notranslate"><span class="pre">i16</span> <span class="pre">%mc</span></code>) and generates the PTX
instruction with the <code class="docutils literal notranslate"><span class="pre">.multicast::cluster</span></code> modifier.</p></li>
</ul>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk">https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk</a>.</p>
</section>
</section>
<section id="llvm-nvvm-cp-async-bulk-shared-cta-to-global">
<h4><a class="toc-backref" href="#id164" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.shared.cta.to.global</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-shared-cta-to-global" title="Link to this heading">¶</a></h4>
<section id="id53">
<h5>Syntax:<a class="headerlink" href="#id53" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.shared.cta.to.global</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%dst</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%size</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.shared.cta.to.global.bytemask</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%size</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%mask</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id54">
<h5>Overview:<a class="headerlink" href="#id54" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.shared.cta.to.global</span></code>’ intrinsic
corresponds to the <code class="docutils literal notranslate"><span class="pre">cp.async.bulk.global.shared::cta.*</span></code> set of PTX
instructions. These instructions initiate an asynchronous copy from
shared::cta to global memory. The 32-bit operand <code class="docutils literal notranslate"><span class="pre">%size</span></code> specifies
the amount of memory to be copied (in bytes) and it must be a multiple
of 16. For the <code class="docutils literal notranslate"><span class="pre">.bytemask</span></code> variant, the 16-bit wide mask operand
specifies whether the i-th byte of each 16-byte wide chunk of source
data is copied to the destination.</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">i1</span> <span class="pre">%flag_ch</span></code> argument to these intrinsics is a boolean
flag indicating support for cache_hint. This flag argument must
be a compile-time constant. When set, it indicates a valid
cache_hint (<code class="docutils literal notranslate"><span class="pre">i64</span> <span class="pre">%ch</span></code>) and generates the <code class="docutils literal notranslate"><span class="pre">.L2::cache_hint</span></code>
variant of the PTX instruction.</p></li>
</ul>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk">https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk</a>.</p>
</section>
</section>
<section id="llvm-nvvm-cp-async-bulk-shared-cta-to-cluster">
<h4><a class="toc-backref" href="#id165" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.shared.cta.to.cluster</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-shared-cta-to-cluster" title="Link to this heading">¶</a></h4>
<section id="id56">
<h5>Syntax:<a class="headerlink" href="#id56" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.shared.cta.to.cluster</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">7</span><span class="p">)</span><span class="w"> </span><span class="nv">%dst</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%mbar</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%size</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id57">
<h5>Overview:<a class="headerlink" href="#id57" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.shared.cta.to.cluster</span></code>’ intrinsic
corresponds to the <code class="docutils literal notranslate"><span class="pre">cp.async.bulk.shared::cluster.shared::cta.*</span></code>
PTX instruction. This instruction initiates an asynchronous copy from
shared::cta to shared::cluster memory. The destination has to be in
the shared memory of a different CTA within the cluster. The 32-bit
operand <code class="docutils literal notranslate"><span class="pre">%size</span></code> specifies the amount of memory to be copied and
it must be a multiple of 16.</p>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk">https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk</a>.</p>
</section>
</section>
<section id="llvm-nvvm-cp-async-bulk-prefetch-l2">
<h4><a class="toc-backref" href="#id166" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.prefetch.L2</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-prefetch-l2" title="Link to this heading">¶</a></h4>
<section id="id59">
<h5>Syntax:<a class="headerlink" href="#id59" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.prefetch.L2</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%size</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id60">
<h5>Overview:<a class="headerlink" href="#id60" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.prefetch.L2</span></code>’ intrinsic
corresponds to the <code class="docutils literal notranslate"><span class="pre">cp.async.bulk.prefetch.L2.*</span></code> family
of PTX instructions. These instructions initiate an asynchronous
prefetch of bulk data from global memory to the L2 cache.
The 32-bit operand <code class="docutils literal notranslate"><span class="pre">%size</span></code> specifies the amount of memory to be
prefetched in terms of bytes and it must be a multiple of 16.</p>
<ul class="simple">
<li><p>The last argument to these intrinsics is boolean flag indicating
support for cache_hint. These flag argument must be compile-time
constant. When set, it indicates a valid cache_hint (<code class="docutils literal notranslate"><span class="pre">i64</span> <span class="pre">%ch</span></code>)
and generates the <code class="docutils literal notranslate"><span class="pre">.L2::cache_hint</span></code> variant of the PTX instruction.</p></li>
</ul>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-prefetch">https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-prefetch</a>.</p>
</section>
</section>
<section id="llvm-nvvm-prefetch">
<h4><a class="toc-backref" href="#id167" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.prefetch.*</span></code>’</a><a class="headerlink" href="#llvm-nvvm-prefetch" title="Link to this heading">¶</a></h4>
<section id="id61">
<h5>Syntax:<a class="headerlink" href="#id61" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w">  </span><span class="vg">@llvm.nvvm.prefetch.global.L1</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%global_ptr</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w">  </span><span class="vg">@llvm.nvvm.prefetch.global.L2</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%global_ptr</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w">  </span><span class="vg">@llvm.nvvm.prefetch.local.L1</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">5</span><span class="p">)</span><span class="w"> </span><span class="nv">%local_ptr</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w">  </span><span class="vg">@llvm.nvvm.prefetch.local.L2</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">5</span><span class="p">)</span><span class="w"> </span><span class="nv">%local_ptr</span><span class="p">)</span>

<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w">  </span><span class="vg">@llvm.nvvm.prefetch.L1</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%ptr</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w">  </span><span class="vg">@llvm.nvvm.prefetch.L2</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%ptr</span><span class="p">)</span>

<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w">  </span><span class="vg">@llvm.nvvm.prefetch.global.L2.evict.normal</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%global_ptr</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w">  </span><span class="vg">@llvm.nvvm.prefetch.global.L2.evict.last</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%global_ptr</span><span class="p">)</span>

<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w">  </span><span class="vg">@llvm.nvvm.prefetchu.L1</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%ptr</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id62">
<h5>Overview:<a class="headerlink" href="#id62" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.prefetch.*</span></code>’ and ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.prefetchu.*</span></code>’ intrinsic
correspond to the ‘<code class="docutils literal notranslate"><span class="pre">prefetch.*</span></code>;’ and ‘<code class="docutils literal notranslate"><span class="pre">prefetchu.*</span></code>’ family of PTX instructions.
The ‘<code class="docutils literal notranslate"><span class="pre">prefetch.*</span></code>’ instructions bring the cache line containing the
specified address in global or local memory address space into the
specified cache level (L1 or L2). The ‘<cite>prefetchu.*`</cite>’ instruction brings the cache line
containing the specified generic address into the specified uniform cache level.
If no address space is specified, it is assumed to be generic address. The intrinsic
uses and eviction priority which can be accessed by the ‘<code class="docutils literal notranslate"><span class="pre">.level::eviction_priority</span></code>’ modifier.</p>
<ul class="simple">
<li><p>A prefetch to a shared memory location performs no operation.</p></li>
<li><p>A prefetch into the uniform cache requires a generic address,
and no operation occurs if the address maps to a const, local, or shared memory location.</p></li>
</ul>
<p>For more information, refer to the PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-prefetch-prefetchu">https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-prefetch-prefetchu</a>.</p>
</section>
</section>
<section id="llvm-nvvm-applypriority">
<h4><a class="toc-backref" href="#id168" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.applypriority.*</span></code>’</a><a class="headerlink" href="#llvm-nvvm-applypriority" title="Link to this heading">¶</a></h4>
<section id="id63">
<h5>Syntax:<a class="headerlink" href="#id63" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w">  </span><span class="vg">@llvm.nvvm.applypriority.global.L2.evict.normal</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%global_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%size</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w">  </span><span class="vg">@llvm.nvvm.applypriority.L2.evict.normal</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%size</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id64">
<h5>Overview:<a class="headerlink" href="#id64" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.applypriority.*</span></code>’  applies the cache eviction priority specified by the
.level::eviction_priority qualifier to the address range [a..a+size) in the specified cache
level. If no state space is specified then Generic Addressing is used. If the specified address
does not fall within the address window of .global state space then the behavior is undefined.
The operand size is an integer constant that specifies the amount of data, in bytes, in the specified cache
level on which the priority is to be applied. The only supported value for the size operand is 128.</p>
<p>For more information, refer to the PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-applypriority">https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-applypriority</a>.</p>
</section>
</section>
<section id="llvm-nvvm-discard">
<h4><a class="toc-backref" href="#id169" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">llvm.nvvm.discard.*</span></code>’</a><a class="headerlink" href="#llvm-nvvm-discard" title="Link to this heading">¶</a></h4>
<section id="id65">
<h5>Syntax:<a class="headerlink" href="#id65" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w">  </span><span class="vg">@llvm.nvvm.discard.global.L2</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%global_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="k">immarg</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w">  </span><span class="vg">@llvm.nvvm.discard.L2</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="k">immarg</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id66">
<h5>Overview:<a class="headerlink" href="#id66" title="Link to this heading">¶</a></h5>
<p>The <em>effects</em> of the <code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.discard.L2*</span></code> intrinsics are those of a non-atomic
non-volatile <code class="docutils literal notranslate"><span class="pre">llvm.memset</span></code> that writes <code class="docutils literal notranslate"><span class="pre">undef</span></code> to the destination
address range <code class="docutils literal notranslate"><span class="pre">[%ptr,</span> <span class="pre">%ptr</span> <span class="pre">+</span> <span class="pre">immarg)</span></code>. The <code class="docutils literal notranslate"><span class="pre">%ptr</span></code> must be aligned by 128 bytes.
Subsequent reads from the address range may read <code class="docutils literal notranslate"><span class="pre">undef</span></code> until the memory is overwritten
with a different value.
These operations <em>hint</em> the implementation that data in the L2 cache can be destructively
discarded without writing it back to memory.
The operand <code class="docutils literal notranslate"><span class="pre">immarg</span></code> is an integer constant that specifies the length in bytes of the
address range <code class="docutils literal notranslate"><span class="pre">[%ptr,</span> <span class="pre">%ptr</span> <span class="pre">+</span> <span class="pre">immarg)</span></code> to write <code class="docutils literal notranslate"><span class="pre">undef</span></code> into.
The only supported value for the <code class="docutils literal notranslate"><span class="pre">immarg</span></code> operand is <code class="docutils literal notranslate"><span class="pre">128</span></code>.
If generic addressing is used and the specified address does not fall within the
address window of global memory (<code class="docutils literal notranslate"><span class="pre">addrspace(1)</span></code>) the behavior is undefined.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.discard.L2</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="m">128</span><span class="p">)</span><span class="w">  </span><span class="c">;; writes `undef` to [p, p+128)</span>
<span class="nv">%a</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p.</span><span class="w"> </span><span class="c">;; loads 8 bytes containing undef</span>
<span class="nv">%b</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%p</span><span class="w">  </span><span class="c">;; loads 8 bytes containing undef</span>
<span class="c">;; comparing %a and %b compares `undef` values!</span>
<span class="nv">%fa</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">freeze</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%a</span><span class="w">  </span><span class="c">;; freezes undef to stable bit-pattern</span>
<span class="nv">%fb</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">freeze</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%b</span><span class="w">  </span><span class="c">;; freezes undef to stable bit-pattern</span>
<span class="c">;; %fa may compare different to %fb!</span>
</pre></div>
</div>
<p>For more information, refer to the  <a class="reference external" href="https://nvidia.github.io/cccl/libcudacxx/extended_api/memory_access_properties/discard_memory.html">CUDA C++ discard documentation</a> and to the <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-discard">PTX ISA discard documentation</a> .</p>
</section>
</section>
<section id="llvm-nvvm-cp-async-bulk-tensor-g2s-tile-1-5-d">
<h4><a class="toc-backref" href="#id170" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.g2s.tile.[1-5]d</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-tensor-g2s-tile-1-5-d" title="Link to this heading">¶</a></h4>
<section id="id67">
<h5>Syntax:<a class="headerlink" href="#id67" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.g2s.tile.1d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">7</span><span class="p">)</span><span class="w"> </span><span class="nv">%dst</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%bar</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%mc</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_mc</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%flag_cta_group</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.g2s.tile.2d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.g2s.tile.3d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.g2s.tile.4d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.g2s.tile.5d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d4</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
</pre></div>
</div>
</section>
<section id="id68">
<h5>Overview:<a class="headerlink" href="#id68" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.tensor.g2s.tile.[1-5]d</span></code>’ intrinsics
correspond to the <code class="docutils literal notranslate"><span class="pre">cp.async.bulk.tensor.[1-5]d.*</span></code> set of PTX instructions.
These instructions initiate an asynchronous copy of tensor data from
global memory to shared::cluster memory (indicated by the <code class="docutils literal notranslate"><span class="pre">g2s</span></code> prefix)
in <code class="docutils literal notranslate"><span class="pre">tile</span></code> mode. In tile mode, the multi-dimensional layout of the
source tensor is preserved at the destination. The dimension of the
tensor data ranges from 1d to 5d with the coordinates specified
by the <code class="docutils literal notranslate"><span class="pre">i32</span> <span class="pre">%d0</span> <span class="pre">...</span> <span class="pre">i32</span> <span class="pre">%d4</span></code> arguments.</p>
<ul class="simple">
<li><p>The last three arguments to these intrinsics are flags
indicating support for multicast, cache_hint and cta_group::1/2
modifiers. These flag arguments must be compile-time constants.
The backend looks through these flags and lowers the intrinsics
appropriately.</p></li>
<li><p>The argument denoted by <code class="docutils literal notranslate"><span class="pre">i1</span> <span class="pre">%flag_ch</span></code> when set, indicates
a valid cache_hint (<code class="docutils literal notranslate"><span class="pre">i64</span> <span class="pre">%ch</span></code>) and generates the <code class="docutils literal notranslate"><span class="pre">.L2::cache_hint</span></code>
variant of the PTX instruction.</p></li>
<li><p>The argument denoted by <code class="docutils literal notranslate"><span class="pre">i1</span> <span class="pre">%flag_mc</span></code> when set, indicates
the presence of a multicast mask (<code class="docutils literal notranslate"><span class="pre">i16</span> <span class="pre">%mc</span></code>) and generates
the PTX instruction with the <code class="docutils literal notranslate"><span class="pre">.multicast::cluster</span></code> modifier.</p></li>
<li><p>The argument denoted by <code class="docutils literal notranslate"><span class="pre">i32</span> <span class="pre">%flag_cta_group</span></code> takes values within
the range [0, 3) i.e. {0,1,2}. When the value of <code class="docutils literal notranslate"><span class="pre">%flag_cta_group</span></code>
is not within the range, it may raise an error from the Verifier.
The default value is ‘0’ with no cta_group modifier in the
instruction. The values of ‘1’ and ‘2’ lower to <code class="docutils literal notranslate"><span class="pre">cta_group::1</span></code>
and <code class="docutils literal notranslate"><span class="pre">cta_group::2</span></code> variants of the PTX instruction respectively.</p></li>
</ul>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor">https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor</a>.</p>
</section>
</section>
<section id="llvm-nvvm-cp-async-bulk-tensor-g2s-im2col-3-5-d">
<h4><a class="toc-backref" href="#id171" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.g2s.im2col.[3-5]d</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-tensor-g2s-im2col-3-5-d" title="Link to this heading">¶</a></h4>
<section id="id69">
<h5>Syntax:<a class="headerlink" href="#id69" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.g2s.im2col.3d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%dst</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%bar</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col0</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%mc</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_mc</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%flag_cta_group</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.g2s.im2col.4d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col0</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col1</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.g2s.im2col.5d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d4</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col0</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col1</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col2</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
</pre></div>
</div>
</section>
<section id="id70">
<h5>Overview:<a class="headerlink" href="#id70" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.tensor.g2s.im2col.[3-5]d</span></code>’ intrinsics
correspond to the <code class="docutils literal notranslate"><span class="pre">cp.async.bulk.tensor.[1-5]d.*</span></code> set of PTX instructions.
These instructions initiate an asynchronous copy of tensor data from
global memory to shared::cluster memory (indicated by the <code class="docutils literal notranslate"><span class="pre">g2s</span></code> prefix)
in <code class="docutils literal notranslate"><span class="pre">im2col</span></code> mode. In im2col mode, some dimensions of the source tensor
are unrolled into a single dimensional column at the destination. In this
mode, the tensor has to be at least three-dimensional. Along with the tensor
coordinates, im2col offsets are also specified (denoted by
<code class="docutils literal notranslate"><span class="pre">i16</span> <span class="pre">im2col0...i16</span> <span class="pre">%im2col2</span></code>). The number of im2col offsets is two less
than the number of dimensions of the tensor operation. The last three arguments
to these intrinsics are flags, with the same functionality as described
in the <code class="docutils literal notranslate"><span class="pre">tile</span></code> mode intrinsics above.</p>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor">https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor</a>.</p>
</section>
</section>
<section id="llvm-nvvm-cp-async-bulk-tensor-s2g-tile-1-5-d">
<h4><a class="toc-backref" href="#id172" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.s2g.tile.[1-5]d</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-tensor-s2g-tile-1-5-d" title="Link to this heading">¶</a></h4>
<section id="id72">
<h5>Syntax:<a class="headerlink" href="#id72" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.s2g.tile.1d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.s2g.tile.2d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.s2g.tile.3d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.s2g.tile.4d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.s2g.tile.5d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d4</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
</pre></div>
</div>
</section>
<section id="id73">
<h5>Overview:<a class="headerlink" href="#id73" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.tensor.s2g.tile.[1-5]d</span></code>’ intrinsics
correspond to the <code class="docutils literal notranslate"><span class="pre">cp.async.bulk.tensor.[1-5]d.*</span></code> set of PTX instructions.
These instructions initiate an asynchronous copy of tensor data from
shared::cta to global memory (indicated by the <code class="docutils literal notranslate"><span class="pre">s2g</span></code> prefix)
in <code class="docutils literal notranslate"><span class="pre">tile</span></code> mode. The dimension of the tensor data ranges from 1d to 5d
with the coordinates specified by the <code class="docutils literal notranslate"><span class="pre">i32</span> <span class="pre">%d0</span> <span class="pre">...</span> <span class="pre">i32</span> <span class="pre">%d4</span></code> arguments.</p>
<ul class="simple">
<li><p>The last argument to these intrinsics is a boolean flag
indicating support for cache_hint. This flag argument must
be a compile-time constant. When set, it indicates a valid
cache_hint (<code class="docutils literal notranslate"><span class="pre">i64</span> <span class="pre">%ch</span></code>) and generates the <code class="docutils literal notranslate"><span class="pre">.L2::cache_hint</span></code>
variant of the PTX instruction.</p></li>
</ul>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor">https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor</a>.</p>
</section>
</section>
<section id="llvm-nvvm-cp-async-bulk-tensor-s2g-im2col-3-5-d">
<h4><a class="toc-backref" href="#id173" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.s2g.im2col.[3-5]d</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-tensor-s2g-im2col-3-5-d" title="Link to this heading">¶</a></h4>
<section id="id75">
<h5>Syntax:<a class="headerlink" href="#id75" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.s2g.im2col.3d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.s2g.im2col.4d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.s2g.im2col.5d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d4</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
</pre></div>
</div>
</section>
<section id="id76">
<h5>Overview:<a class="headerlink" href="#id76" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.tensor.s2g.im2col.[1-5]d</span></code>’ intrinsics
correspond to the <code class="docutils literal notranslate"><span class="pre">cp.async.bulk.tensor.[1-5]d.*</span></code> set of PTX instructions.
These instructions initiate an asynchronous copy of tensor data from
shared::cta to global memory (indicated by the <code class="docutils literal notranslate"><span class="pre">s2g</span></code> prefix)
in <code class="docutils literal notranslate"><span class="pre">im2col</span></code> mode. In this mode, the tensor has to be at least
three-dimensional. Unlike the <code class="docutils literal notranslate"><span class="pre">g2s</span></code> variants, there are no
im2col_offsets for these intrinsics. The last argument to these
intrinsics is a boolean flag, with the same functionality as
described in the <code class="docutils literal notranslate"><span class="pre">s2g.tile</span></code> mode intrinsics above.</p>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor">https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor</a>.</p>
</section>
</section>
<section id="llvm-nvvm-cp-async-bulk-tensor-prefetch-tile-1-5-d">
<h4><a class="toc-backref" href="#id174" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.prefetch.tile.[1-5]d</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-tensor-prefetch-tile-1-5-d" title="Link to this heading">¶</a></h4>
<section id="id78">
<h5>Syntax:<a class="headerlink" href="#id78" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.prefetch.tile.1d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.prefetch.tile.2d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.prefetch.tile.3d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.prefetch.tile.4d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.prefetch.tile.5d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d4</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
</pre></div>
</div>
</section>
<section id="id79">
<h5>Overview:<a class="headerlink" href="#id79" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.tensor.prefetch.tile.[1-5]d</span></code>’ intrinsics
correspond to the <code class="docutils literal notranslate"><span class="pre">cp.async.bulk.prefetch.tensor.[1-5]d.L2.global*</span></code> set
of PTX instructions. These instructions initiate an asynchronous prefetch
of tensor data from global memory to the L2 cache. In tile mode, the
multi-dimensional layout of the source tensor is preserved at the destination.
The dimension of the tensor data ranges from 1d to 5d with the coordinates
specified by the <code class="docutils literal notranslate"><span class="pre">i32</span> <span class="pre">%d0</span> <span class="pre">...</span> <span class="pre">i32</span> <span class="pre">%d4</span></code> arguments.</p>
<ul class="simple">
<li><p>The last argument to these intrinsics is a boolean flag
indicating support for cache_hint. This flag argument must
be a compile-time constant. When set, it indicates a valid
cache_hint (<code class="docutils literal notranslate"><span class="pre">i64</span> <span class="pre">%ch</span></code>) and generates the <code class="docutils literal notranslate"><span class="pre">.L2::cache_hint</span></code>
variant of the PTX instruction.</p></li>
</ul>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-prefetch-tensor">https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-prefetch-tensor</a>.</p>
</section>
</section>
<section id="llvm-nvvm-cp-async-bulk-tensor-prefetch-im2col-3-5-d">
<h4><a class="toc-backref" href="#id175" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.prefetch.im2col.[3-5]d</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-tensor-prefetch-im2col-3-5-d" title="Link to this heading">¶</a></h4>
<section id="id80">
<h5>Syntax:<a class="headerlink" href="#id80" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.prefetch.im2col.3d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.prefetch.im2col.4d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col0</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col1</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.prefetch.im2col.5d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d4</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col0</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col1</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%im2col2</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
</pre></div>
</div>
</section>
<section id="id81">
<h5>Overview:<a class="headerlink" href="#id81" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.tensor.prefetch.im2col.[3-5]d</span></code>’ intrinsics
correspond to the <code class="docutils literal notranslate"><span class="pre">cp.async.bulk.prefetch.tensor.[1-5]d.L2.global*</span></code> set
of PTX instructions. These instructions initiate an asynchronous prefetch
of tensor data from global memory to the L2 cache. In im2col mode, some
dimensions of the source tensor are unrolled into a single dimensional
column at the destination. In this mode, the tensor has to be at least
three-dimensional. Along with the tensor coordinates, im2col offsets are
also specified (denoted by <code class="docutils literal notranslate"><span class="pre">i16</span> <span class="pre">im2col0...i16</span> <span class="pre">%im2col2</span></code>). The number
of im2col offsets is two less than the number of dimensions of the tensor
operation. The last argument to these intrinsics is a boolean flag, with
the same functionality as described in the <code class="docutils literal notranslate"><span class="pre">tile</span></code> mode intrinsics above.</p>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-prefetch-tensor">https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async-bulk-prefetch-tensor</a>.</p>
</section>
</section>
<section id="llvm-nvvm-cp-async-bulk-tensor-reduce-red-op-tile-1-5-d">
<h4><a class="toc-backref" href="#id176" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.reduce.[red_op].tile.[1-5]d</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-tensor-reduce-red-op-tile-1-5-d" title="Link to this heading">¶</a></h4>
<section id="id83">
<h5>Syntax:<a class="headerlink" href="#id83" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.add.tile.1d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.min.tile.1d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.max.tile.1d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.inc.tile.1d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.dec.tile.1d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.and.tile.1d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.or.tile.1d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.xor.tile.1d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>

<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.</span><span class="p">&lt;</span><span class="err">red_op</span><span class="p">&gt;.</span><span class="err">tile</span><span class="p">.</span><span class="m">2</span><span class="err">d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.</span><span class="p">&lt;</span><span class="err">red_op</span><span class="p">&gt;.</span><span class="err">tile</span><span class="p">.</span><span class="m">3</span><span class="err">d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.</span><span class="p">&lt;</span><span class="err">red_op</span><span class="p">&gt;.</span><span class="err">tile</span><span class="p">.</span><span class="m">4</span><span class="err">d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.</span><span class="p">&lt;</span><span class="err">red_op</span><span class="p">&gt;.</span><span class="err">tile</span><span class="p">.</span><span class="m">5</span><span class="err">d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d4</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
</pre></div>
</div>
</section>
<section id="id84">
<h5>Overview:<a class="headerlink" href="#id84" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.tensor.reduce.&lt;red_op&gt;.tile.[1-5]d</span></code>’ intrinsics
correspond to the <code class="docutils literal notranslate"><span class="pre">cp.reduce.async.bulk.tensor.[1-5]d.*</span></code> set of PTX instructions.
These instructions initiate an asynchronous reduction operation of tensor data
in global memory with the tensor data in shared{::cta} memory, using <code class="docutils literal notranslate"><span class="pre">tile</span></code> mode.
The dimension of the tensor data ranges from 1d to 5d with the coordinates
specified by the <code class="docutils literal notranslate"><span class="pre">i32</span> <span class="pre">%d0</span> <span class="pre">...</span> <span class="pre">i32</span> <span class="pre">%d4</span></code> arguments. The supported reduction
operations are {add, min, max, inc, dec, and, or, xor} as described in the
<code class="docutils literal notranslate"><span class="pre">tile.1d</span></code> intrinsics.</p>
<ul class="simple">
<li><p>The last argument to these intrinsics is a boolean flag
indicating support for cache_hint. This flag argument must
be a compile-time constant. When set, it indicates a valid
cache_hint (<code class="docutils literal notranslate"><span class="pre">i64</span> <span class="pre">%ch</span></code>) and generates the <code class="docutils literal notranslate"><span class="pre">.L2::cache_hint</span></code>
variant of the PTX instruction.</p></li>
</ul>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-reduce-async-bulk-tensor">https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-reduce-async-bulk-tensor</a>.</p>
</section>
</section>
<section id="llvm-nvvm-cp-async-bulk-tensor-reduce-red-op-im2col-3-5-d">
<h4><a class="toc-backref" href="#id177" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.cp.async.bulk.tensor.reduce.[red_op].im2col.[3-5]d</span></code>’</a><a class="headerlink" href="#llvm-nvvm-cp-async-bulk-tensor-reduce-red-op-im2col-3-5-d" title="Link to this heading">¶</a></h4>
<section id="id85">
<h5>Syntax:<a class="headerlink" href="#id85" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.</span><span class="p">&lt;</span><span class="err">red_op</span><span class="p">&gt;.</span><span class="err">im</span><span class="m">2</span><span class="err">col</span><span class="p">.</span><span class="m">3</span><span class="err">d</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%src</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%ch</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%flag_ch</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.</span><span class="p">&lt;</span><span class="err">red_op</span><span class="p">&gt;.</span><span class="err">im</span><span class="m">2</span><span class="err">col</span><span class="p">.</span><span class="m">4</span><span class="err">d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.cp.async.bulk.tensor.reduce.</span><span class="p">&lt;</span><span class="err">red_op</span><span class="p">&gt;.</span><span class="err">im</span><span class="m">2</span><span class="err">col</span><span class="p">.</span><span class="m">5</span><span class="err">d</span><span class="p">(...,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d3</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%d4</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
</pre></div>
</div>
</section>
<section id="id86">
<h5>Overview:<a class="headerlink" href="#id86" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.cp.async.bulk.tensor.reduce.&lt;red_op&gt;.im2col.[3-5]d</span></code>’ intrinsics
correspond to the <code class="docutils literal notranslate"><span class="pre">cp.reduce.async.bulk.tensor.[3-5]d.*</span></code> set of PTX instructions.
These instructions initiate an asynchronous reduction operation of tensor data
in global memory with the tensor data in shared{::cta} memory, using <code class="docutils literal notranslate"><span class="pre">im2col</span></code> mode.
In this mode, the tensor has to be at least three-dimensional. The supported reduction
operations supported are the same as the ones in the tile mode. The last argument to
these intrinsics is a boolean flag, with the same functionality as described in the
<code class="docutils literal notranslate"><span class="pre">tile</span></code> mode intrinsics above.</p>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-reduce-async-bulk-tensor">https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-reduce-async-bulk-tensor</a>.</p>
</section>
</section>
</section>
<section id="warp-group-intrinsics">
<h3><a class="toc-backref" href="#id178" role="doc-backlink">Warp Group Intrinsics</a><a class="headerlink" href="#warp-group-intrinsics" title="Link to this heading">¶</a></h3>
<section id="llvm-nvvm-wgmma-fence-sync-aligned">
<h4><a class="toc-backref" href="#id179" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.wgmma.fence.sync.aligned</span></code>’</a><a class="headerlink" href="#llvm-nvvm-wgmma-fence-sync-aligned" title="Link to this heading">¶</a></h4>
<section id="id88">
<h5>Syntax:<a class="headerlink" href="#id88" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.wgmma.fence.sync.aligned</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="id89">
<h5>Overview:<a class="headerlink" href="#id89" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.wgmma.fence.sync.aligned</span></code>’ intrinsic generates the
<code class="docutils literal notranslate"><span class="pre">wgmma.fence.sync.aligned</span></code> PTX instruction, which establishes an ordering
between prior accesses to any warpgroup registers and subsequent accesses to
the same registers by a <code class="docutils literal notranslate"><span class="pre">wgmma.mma_async</span></code> instruction.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">wgmma.fence</span></code> instruction must be issued by all warps of the warpgroup in
the following locations:</p>
<ul class="simple">
<li><p>Before the first <code class="docutils literal notranslate"><span class="pre">wgmma.mma_async</span></code> operation in a warpgroup.</p></li>
<li><p>Between a register access by a thread in the warpgroup and any
<code class="docutils literal notranslate"><span class="pre">wgmma.mma_async</span></code> instruction that accesses the same registers, except when
these are accumulator register accesses across multiple <code class="docutils literal notranslate"><span class="pre">wgmma.mma_async</span></code>
instructions of the same shape in which case an ordering guarantee is
provided by default.</p></li>
</ul>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-instructions-wgmma-fence">https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-instructions-wgmma-fence</a>.</p>
</section>
</section>
<section id="llvm-nvvm-wgmma-commit-group-sync-aligned">
<h4><a class="toc-backref" href="#id180" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.wgmma.commit_group.sync.aligned</span></code>’</a><a class="headerlink" href="#llvm-nvvm-wgmma-commit-group-sync-aligned" title="Link to this heading">¶</a></h4>
<section id="id90">
<h5>Syntax:<a class="headerlink" href="#id90" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.wgmma.commit_group.sync.aligned</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="id91">
<h5>Overview:<a class="headerlink" href="#id91" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.wgmma.commit_group.sync.aligned</span></code>’ intrinsic generates the
<code class="docutils literal notranslate"><span class="pre">wgmma.commit_group.sync.aligned</span></code> PTX instruction, which creates a new
wgmma-group per warpgroup and batches all prior <code class="docutils literal notranslate"><span class="pre">wgmma.mma_async</span></code>
instructions initiated by the executing warp but not committed to any
wgmma-group into the new wgmma-group. If there are no uncommitted <code class="docutils literal notranslate"><span class="pre">wgmma</span>
<span class="pre">mma_async</span></code> instructions then, <code class="docutils literal notranslate"><span class="pre">wgmma.commit_group</span></code> results in an empty
wgmma-group.</p>
<p>An executing thread can wait for the completion of all <code class="docutils literal notranslate"><span class="pre">wgmma.mma_async</span></code>
operations in a wgmma-group by using <code class="docutils literal notranslate"><span class="pre">wgmma.wait_group</span></code>.</p>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-instructions-wgmma-commit-group">https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-instructions-wgmma-commit-group</a>.</p>
</section>
</section>
<section id="llvm-nvvm-wgmma-wait-group-sync-aligned">
<h4><a class="toc-backref" href="#id181" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.wgmma.wait_group.sync.aligned</span></code>’</a><a class="headerlink" href="#llvm-nvvm-wgmma-wait-group-sync-aligned" title="Link to this heading">¶</a></h4>
<section id="id92">
<h5>Syntax:<a class="headerlink" href="#id92" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.wgmma.wait_group.sync.aligned</span><span class="p">(</span><span class="kt">i64</span><span class="w"> </span><span class="k">immarg</span><span class="w"> </span><span class="err">N</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id93">
<h5>Overview:<a class="headerlink" href="#id93" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.wgmma.wait_group.sync.aligned</span></code>’ intrinsic generates the
<code class="docutils literal notranslate"><span class="pre">wgmma.commit_group.sync.aligned</span> <span class="pre">N</span></code> PTX instruction, which will cause the
executing thread to wait until only <code class="docutils literal notranslate"><span class="pre">N</span></code> or fewer of the most recent
wgmma-groups are pending and all the prior wgmma-groups committed by the
executing threads are complete. For example, when <code class="docutils literal notranslate"><span class="pre">N</span></code> is 0, the executing
thread waits on all the prior wgmma-groups to complete. Operand <code class="docutils literal notranslate"><span class="pre">N</span></code> is an
integer constant.</p>
<p>Accessing the accumulator register or the input register containing the
fragments of matrix A of a <code class="docutils literal notranslate"><span class="pre">wgmma.mma_async</span></code> instruction without first
performing a <code class="docutils literal notranslate"><span class="pre">wgmma.wait_group</span></code> instruction that waits on a wgmma-group
including that <code class="docutils literal notranslate"><span class="pre">wgmma.mma_async</span></code> instruction is undefined behavior.</p>
<p>For more information, refer PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-instructions-wgmma-wait-group">https://docs.nvidia.com/cuda/parallel-thread-execution/#asynchronous-warpgroup-level-matrix-instructions-wgmma-wait-group</a>.</p>
</section>
</section>
<section id="llvm-nvvm-griddepcontrol">
<h4><a class="toc-backref" href="#id182" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.griddepcontrol.*</span></code>’</a><a class="headerlink" href="#llvm-nvvm-griddepcontrol" title="Link to this heading">¶</a></h4>
<section id="id94">
<h5>Syntax:<a class="headerlink" href="#id94" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.griddepcontrol.launch_dependents</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.griddepcontrol.wait</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="id95">
<h5>Overview:<a class="headerlink" href="#id95" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">griddepcontrol</span></code> intrinsics allows the dependent grids and prerequisite grids as defined by the runtime, to control execution in the following way:</p>
<p><code class="docutils literal notranslate"><span class="pre">griddepcontrol.launch_dependents</span></code> intrinsic signals that the dependents can be scheduled, before the current grid completes. The intrinsic can be invoked by multiple threads in the current CTA and repeated invocations of the intrinsic will have no additional side effects past that of the first invocation.</p>
<p><code class="docutils literal notranslate"><span class="pre">griddepcontrol.wait</span></code> intrinsic causes the executing thread to wait until all prerequisite grids in flight have completed and all the memory operations from the prerequisite grids are performed and made visible to the current grid.</p>
<p>For more information, refer
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-griddepcontrol">PTX ISA</a>.</p>
</section>
</section>
</section>
<section id="tcgen05-family-of-intrinsics">
<h3><a class="toc-backref" href="#id183" role="doc-backlink">TCGEN05 family of Intrinsics</a><a class="headerlink" href="#tcgen05-family-of-intrinsics" title="Link to this heading">¶</a></h3>
<p>The llvm.nvvm.tcgen05.* intrinsics model the TCGEN05 family of instructions
exposed by PTX. These intrinsics use ‘Tensor Memory’ (henceforth <code class="docutils literal notranslate"><span class="pre">tmem</span></code>).
NVPTX represents this memory using <code class="docutils literal notranslate"><span class="pre">addrspace(6)</span></code> and is always 32-bits.</p>
<p>For more information, refer to the PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-memory">https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-memory</a>.</p>
<p>The tensor-memory pointers may only be used with the tcgen05 intrinsics.
There are specialized load/store instructions provided (tcgen05.ld/st) to
work with tensor-memory.</p>
<p>See the PTX ISA for more information on tensor-memory load/store instructions
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-memory-and-register-load-store-instructions">https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-memory-and-register-load-store-instructions</a>.</p>
<section id="llvm-nvvm-tcgen05-alloc">
<h4><a class="toc-backref" href="#id184" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.tcgen05.alloc</span></code>’</a><a class="headerlink" href="#llvm-nvvm-tcgen05-alloc" title="Link to this heading">¶</a></h4>
<section id="id96">
<h5>Syntax:<a class="headerlink" href="#id96" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.alloc.cg1</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%dst</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%ncols</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.alloc.cg2</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%dst</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%ncols</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.alloc.shared.cg1</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%dst</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%ncols</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.alloc.shared.cg2</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%dst</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%ncols</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id97">
<h5>Overview:<a class="headerlink" href="#id97" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.tcgen05.alloc.*</span></code>’ intrinsics correspond to the
<code class="docutils literal notranslate"><span class="pre">tcgen05.alloc.cta_group*.sync.aligned.b32</span></code> family of PTX instructions.
The <code class="docutils literal notranslate"><span class="pre">tcgen05.alloc</span></code> is a potentially blocking instruction which dynamically
allocates the specified number of columns in the Tensor Memory and writes
the address of the allocated Tensor Memory into shared memory at the
location specified by <code class="docutils literal notranslate"><span class="pre">%dst</span></code>. The 32-bit operand <code class="docutils literal notranslate"><span class="pre">%ncols</span></code> specifies
the number of columns to be allocated and it must be a power-of-two.
The <code class="docutils literal notranslate"><span class="pre">.shared</span></code> variant explicitly uses shared memory address space for
the <code class="docutils literal notranslate"><span class="pre">%dst</span></code> operand. The <code class="docutils literal notranslate"><span class="pre">.cg1</span></code> and <code class="docutils literal notranslate"><span class="pre">.cg2</span></code> variants generate
<code class="docutils literal notranslate"><span class="pre">cta_group::1</span></code> and <code class="docutils literal notranslate"><span class="pre">cta_group::2</span></code> variants of the instruction respectively.</p>
<p>For more information, refer to the PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-memory-allocation-and-management-instructions">https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-memory-allocation-and-management-instructions</a>.</p>
</section>
</section>
<section id="llvm-nvvm-tcgen05-dealloc">
<h4><a class="toc-backref" href="#id185" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.tcgen05.dealloc</span></code>’</a><a class="headerlink" href="#llvm-nvvm-tcgen05-dealloc" title="Link to this heading">¶</a></h4>
<section id="id98">
<h5>Syntax:<a class="headerlink" href="#id98" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.dealloc.cg1</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%ncols</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.dealloc.cg2</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%ncols</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id99">
<h5>Overview:<a class="headerlink" href="#id99" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.tcgen05.dealloc.*</span></code>’ intrinsics correspond to the
<code class="docutils literal notranslate"><span class="pre">tcgen05.dealloc.*</span></code> set of PTX instructions. The <code class="docutils literal notranslate"><span class="pre">tcgen05.dealloc</span></code>
instructions deallocates the Tensor Memory specified by the Tensor Memory
address <code class="docutils literal notranslate"><span class="pre">%tmem_addr</span></code>. The operand <code class="docutils literal notranslate"><span class="pre">%tmem_addr</span></code> must point to a previous
Tensor Memory allocation. The 32-bit operand <code class="docutils literal notranslate"><span class="pre">%ncols</span></code> specifies the number
of columns to be de-allocated. The <code class="docutils literal notranslate"><span class="pre">.cg1</span></code> and <code class="docutils literal notranslate"><span class="pre">.cg2</span></code> variants generate
<code class="docutils literal notranslate"><span class="pre">cta_group::1</span></code> and <code class="docutils literal notranslate"><span class="pre">cta_group::2</span></code> variants of the instruction respectively.</p>
<p>For more information, refer to the PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-memory-allocation-and-management-instructions">https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-memory-allocation-and-management-instructions</a>.</p>
</section>
</section>
<section id="llvm-nvvm-tcgen05-relinq-alloc-permit">
<h4><a class="toc-backref" href="#id186" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.tcgen05.relinq.alloc.permit</span></code>’</a><a class="headerlink" href="#llvm-nvvm-tcgen05-relinq-alloc-permit" title="Link to this heading">¶</a></h4>
<section id="id101">
<h5>Syntax:<a class="headerlink" href="#id101" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.relinq.alloc.permit.cg1</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.relinq.alloc.permit.cg2</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="id102">
<h5>Overview:<a class="headerlink" href="#id102" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.tcgen05.relinq.alloc.permit.*</span></code>’ intrinsics correspond
to the <code class="docutils literal notranslate"><span class="pre">tcgen05.relinquish_alloc_permit.*</span></code> set of PTX instructions.
This instruction specifies that the CTA of the executing thread is
relinquishing the right to allocate Tensor Memory. So, it is illegal
for a CTA to perform <code class="docutils literal notranslate"><span class="pre">tcgen05.alloc</span></code> after any of its constituent
threads execute <code class="docutils literal notranslate"><span class="pre">tcgen05.relinquish_alloc_permit</span></code>. The <code class="docutils literal notranslate"><span class="pre">.cg1</span></code>
and <code class="docutils literal notranslate"><span class="pre">.cg2</span></code> variants generate <code class="docutils literal notranslate"><span class="pre">cta_group::1</span></code> and <code class="docutils literal notranslate"><span class="pre">cta_group::2</span></code>
flavors of the instruction respectively.</p>
<p>For more information, refer to the PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-memory-allocation-and-management-instructions">https://docs.nvidia.com/cuda/parallel-thread-execution/#tensor-memory-allocation-and-management-instructions</a>.</p>
</section>
</section>
<section id="llvm-nvvm-tcgen05-commit">
<h4><a class="toc-backref" href="#id187" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.tcgen05.commit</span></code>’</a><a class="headerlink" href="#llvm-nvvm-tcgen05-commit" title="Link to this heading">¶</a></h4>
<section id="id104">
<h5>Syntax:<a class="headerlink" href="#id104" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.commit.</span><span class="p">{</span><span class="err">cg</span><span class="m">1</span><span class="p">,</span><span class="err">cg</span><span class="m">2</span><span class="p">}(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%mbar</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.commit.shared.</span><span class="p">{</span><span class="err">cg</span><span class="m">1</span><span class="p">,</span><span class="err">cg</span><span class="m">2</span><span class="p">}(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%mbar</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.commit.mc.</span><span class="p">{</span><span class="err">cg</span><span class="m">1</span><span class="p">,</span><span class="err">cg</span><span class="m">2</span><span class="p">}(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%mbar</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%mc</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.commit.mc.shared.</span><span class="p">{</span><span class="err">cg</span><span class="m">1</span><span class="p">,</span><span class="err">cg</span><span class="m">2</span><span class="p">}(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%mbar</span><span class="p">,</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="nv">%mc</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id105">
<h5>Overview:<a class="headerlink" href="#id105" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.tcgen05.commit.*</span></code>’ intrinsics correspond to the
<code class="docutils literal notranslate"><span class="pre">tcgen05.commit.{cg1/cg2}.mbarrier::arrive::one.*</span></code> set of PTX instructions.
The <code class="docutils literal notranslate"><span class="pre">tcgen05.commit</span></code> is an asynchronous instruction which makes the mbarrier
object (<code class="docutils literal notranslate"><span class="pre">%mbar</span></code>) track the completion of all prior asynchronous tcgen05 operations.
The <code class="docutils literal notranslate"><span class="pre">.mc</span></code> variants allow signaling on the mbarrier objects of multiple CTAs
(specified by <code class="docutils literal notranslate"><span class="pre">%mc</span></code>) in the cluster. The <code class="docutils literal notranslate"><span class="pre">.cg1</span></code> and <code class="docutils literal notranslate"><span class="pre">.cg2</span></code> variants generate
<code class="docutils literal notranslate"><span class="pre">cta_group::1</span></code> and <code class="docutils literal notranslate"><span class="pre">cta_group::2</span></code> flavors of the instruction respectively.</p>
<p>For more information, refer to the PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tcgen-async-sync-operations-commit">https://docs.nvidia.com/cuda/parallel-thread-execution/#tcgen-async-sync-operations-commit</a>.</p>
</section>
</section>
<section id="llvm-nvvm-tcgen05-wait">
<h4><a class="toc-backref" href="#id188" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.tcgen05.wait</span></code>’</a><a class="headerlink" href="#llvm-nvvm-tcgen05-wait" title="Link to this heading">¶</a></h4>
<section id="id106">
<h5>Syntax:<a class="headerlink" href="#id106" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.wait.ld</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.wait.st</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="id107">
<h5>Overview:<a class="headerlink" href="#id107" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.tcgen05.wait.ld/st</span></code>’ intrinsics correspond to
the <code class="docutils literal notranslate"><span class="pre">tcgen05.wait::{ld/st}.sync.aligned</span></code> pair of PTX instructions.
The <code class="docutils literal notranslate"><span class="pre">tcgen05.wait::ld</span></code> causes the executing thread to block until
all prior <code class="docutils literal notranslate"><span class="pre">tcgen05.ld</span></code> operations issued by the executing thread
have completed. The <code class="docutils literal notranslate"><span class="pre">tcgen05.wait::st</span></code> causes the executing thread
to block until all prior <code class="docutils literal notranslate"><span class="pre">tcgen05.st</span></code> operations issued by the
executing thread have completed.</p>
<p>For more information, refer to the PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tcgen05-instructions-tcgen05-wait">https://docs.nvidia.com/cuda/parallel-thread-execution/#tcgen05-instructions-tcgen05-wait</a>.</p>
</section>
</section>
<section id="llvm-nvvm-tcgen05-fence">
<h4><a class="toc-backref" href="#id189" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.tcgen05.fence</span></code>’</a><a class="headerlink" href="#llvm-nvvm-tcgen05-fence" title="Link to this heading">¶</a></h4>
<section id="id108">
<h5>Syntax:<a class="headerlink" href="#id108" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.fence.before.thread.sync</span><span class="p">()</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.fence.after.thread.sync</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="id109">
<h5>Overview:<a class="headerlink" href="#id109" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.tcgen05.fence.*</span></code>’ intrinsics correspond to
the <code class="docutils literal notranslate"><span class="pre">tcgen05.fence::{before/after}_thread_sync</span></code> pair of PTX instructions.
These instructions act as code motion fences for asynchronous tcgen05
operations.</p>
<p>For more information, refer to the PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tensorcore-5th-generation-instructions-tcgen05-fence">https://docs.nvidia.com/cuda/parallel-thread-execution/#tensorcore-5th-generation-instructions-tcgen05-fence</a>.</p>
</section>
</section>
<section id="llvm-nvvm-tcgen05-shift">
<h4><a class="toc-backref" href="#id190" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.tcgen05.shift</span></code>’</a><a class="headerlink" href="#llvm-nvvm-tcgen05-shift" title="Link to this heading">¶</a></h4>
<section id="id110">
<h5>Syntax:<a class="headerlink" href="#id110" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.shift.down.cg1</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.shift.down.cg2</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id111">
<h5>Overview:<a class="headerlink" href="#id111" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.tcgen05.shift.{cg1/cg2}</span></code>’ intrinsics correspond to
the <code class="docutils literal notranslate"><span class="pre">tcgen05.shift.{cg1/cg2}</span></code> PTX instructions. The <code class="docutils literal notranslate"><span class="pre">tcgen05.shift</span></code>
is an asynchronous instruction which initiates the shifting of 32-byte
elements downwards across all the rows, except the last, by one row.
The address operand <code class="docutils literal notranslate"><span class="pre">%tmem_addr</span></code> specifies the base address of the
matrix in the Tensor Memory whose rows must be down shifted.</p>
<p>For more information, refer to the PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tcgen05-instructions-tcgen05-shift">https://docs.nvidia.com/cuda/parallel-thread-execution/#tcgen05-instructions-tcgen05-shift</a>.</p>
</section>
</section>
<section id="llvm-nvvm-tcgen05-cp">
<h4><a class="toc-backref" href="#id191" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.tcgen05.cp</span></code>’</a><a class="headerlink" href="#llvm-nvvm-tcgen05-cp" title="Link to this heading">¶</a></h4>
<section id="id112">
<h5>Syntax:<a class="headerlink" href="#id112" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.cp.4x256b.</span><span class="p">{</span><span class="err">cg</span><span class="m">1</span><span class="p">,</span><span class="err">cg</span><span class="m">2</span><span class="p">}(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%sdesc</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.cp.128x256b.</span><span class="p">{</span><span class="err">cg</span><span class="m">1</span><span class="p">,</span><span class="err">cg</span><span class="m">2</span><span class="p">}(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%sdesc</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.cp.128x128b.</span><span class="p">{</span><span class="err">cg</span><span class="m">1</span><span class="p">,</span><span class="err">cg</span><span class="m">2</span><span class="p">}(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%sdesc</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.cp.32x128b_warpx4.</span><span class="p">{</span><span class="err">cg</span><span class="m">1</span><span class="p">,</span><span class="err">cg</span><span class="m">2</span><span class="p">}(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%sdesc</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.cp.64x128b_warpx2_02_13.</span><span class="p">{</span><span class="err">cg</span><span class="m">1</span><span class="p">,</span><span class="err">cg</span><span class="m">2</span><span class="p">}(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%sdesc</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.cp.64x128b_warpx2_01_23.</span><span class="p">{</span><span class="err">cg</span><span class="m">1</span><span class="p">,</span><span class="err">cg</span><span class="m">2</span><span class="p">}(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%sdesc</span><span class="p">)</span>

<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.cp.4x256b.b6x16_p32.</span><span class="p">{</span><span class="err">cg</span><span class="m">1</span><span class="p">,</span><span class="err">cg</span><span class="m">2</span><span class="p">}(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%sdesc</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.cp.128x256b.b6x16_p32.</span><span class="p">{</span><span class="err">cg</span><span class="m">1</span><span class="p">,</span><span class="err">cg</span><span class="m">2</span><span class="p">}(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%sdesc</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.cp.128x128b.b6x16_p32.</span><span class="p">{</span><span class="err">cg</span><span class="m">1</span><span class="p">,</span><span class="err">cg</span><span class="m">2</span><span class="p">}(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%sdesc</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.cp.32x128b_warpx4.b6x16_p32.</span><span class="p">{</span><span class="err">cg</span><span class="m">1</span><span class="p">,</span><span class="err">cg</span><span class="m">2</span><span class="p">}(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%sdesc</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.cp.64x128b_warpx2_02_13.b6x16_p32.</span><span class="p">{</span><span class="err">cg</span><span class="m">1</span><span class="p">,</span><span class="err">cg</span><span class="m">2</span><span class="p">}(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%sdesc</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.cp.64x128b_warpx2_01_23.b6x16_p32.</span><span class="p">{</span><span class="err">cg</span><span class="m">1</span><span class="p">,</span><span class="err">cg</span><span class="m">2</span><span class="p">}(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%sdesc</span><span class="p">)</span>

<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.cp.4x256b.b4x16_p64.</span><span class="p">{</span><span class="err">cg</span><span class="m">1</span><span class="p">,</span><span class="err">cg</span><span class="m">2</span><span class="p">}(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%sdesc</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.cp.128x256b.b4x16_p64.</span><span class="p">{</span><span class="err">cg</span><span class="m">1</span><span class="p">,</span><span class="err">cg</span><span class="m">2</span><span class="p">}(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%sdesc</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.cp.128x128b.b4x16_p64.</span><span class="p">{</span><span class="err">cg</span><span class="m">1</span><span class="p">,</span><span class="err">cg</span><span class="m">2</span><span class="p">}(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%sdesc</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.cp.32x128b_warpx4.b4x16_p64.</span><span class="p">{</span><span class="err">cg</span><span class="m">1</span><span class="p">,</span><span class="err">cg</span><span class="m">2</span><span class="p">}(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%sdesc</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.cp.64x128b_warpx2_02_13.b4x16_p64.</span><span class="p">{</span><span class="err">cg</span><span class="m">1</span><span class="p">,</span><span class="err">cg</span><span class="m">2</span><span class="p">}(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%sdesc</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.cp.64x128b_warpx2_01_23.b4x16_p64.</span><span class="p">{</span><span class="err">cg</span><span class="m">1</span><span class="p">,</span><span class="err">cg</span><span class="m">2</span><span class="p">}(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%sdesc</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id113">
<h5>Overview:<a class="headerlink" href="#id113" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.tcgen05.cp.{shape}.{src_fmt}.{cg1/cg2}</span></code>’ intrinsics
correspond to the <code class="docutils literal notranslate"><span class="pre">tcgen05.cp.*</span></code> family of PTX instructions.
The <code class="docutils literal notranslate"><span class="pre">tcgen05.cp</span></code> instruction initiates an asynchronous copy operation from
shared memory to the location specified by <code class="docutils literal notranslate"><span class="pre">%tmem_addr</span></code> in Tensor Memory.
The 64-bit register operand <code class="docutils literal notranslate"><span class="pre">%sdesc</span></code> is the matrix descriptor representing
the source matrix in shared memory that needs to be copied.</p>
<p>The valid shapes for the copy operation are:
{128x256b, 4x256b, 128x128b, 64x128b_warpx2_02_13, 64x128b_warpx2_01_23, 32x128b_warpx4}.</p>
<p>Shapes <code class="docutils literal notranslate"><span class="pre">64x128b</span></code> and <code class="docutils literal notranslate"><span class="pre">32x128b</span></code> require dedicated multicast qualifiers,
which are appended to the corresponding intrinsic names.</p>
<p>Optionally, the data can be decompressed from the source format in the shared memory
to the destination format in Tensor Memory during the copy operation. Currently,
only <code class="docutils literal notranslate"><span class="pre">.b8x16</span></code> is supported as destination format. The valid source formats are
<code class="docutils literal notranslate"><span class="pre">.b6x16_p32</span></code> and <code class="docutils literal notranslate"><span class="pre">.b4x16_p64</span></code>.</p>
<p>When the source format is <code class="docutils literal notranslate"><span class="pre">.b6x16_p32</span></code>, a contiguous set of 16 elements of 6-bits
each followed by four bytes of padding (<code class="docutils literal notranslate"><span class="pre">_p32</span></code>) in shared memory is decompressed
into 16 elements of 8-bits (<code class="docutils literal notranslate"><span class="pre">.b8x16</span></code>) each in the Tensor Memory.</p>
<p>When the source format is <code class="docutils literal notranslate"><span class="pre">.b4x16_p64</span></code>, a contiguous set of 16 elements of 4-bits
each followed by eight bytes of padding (<code class="docutils literal notranslate"><span class="pre">_p64</span></code>) in shared memory is decompressed
into 16 elements of 8-bits (<code class="docutils literal notranslate"><span class="pre">.b8x16</span></code>) each in the Tensor Memory.</p>
<p>For more information on the decompression schemes, refer to the PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#optional-decompression">https://docs.nvidia.com/cuda/parallel-thread-execution/#optional-decompression</a>.</p>
<p>For more information on the tcgen05.cp instruction, refer to the PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tcgen05-instructions-tcgen05-cp">https://docs.nvidia.com/cuda/parallel-thread-execution/#tcgen05-instructions-tcgen05-cp</a>.</p>
</section>
</section>
<section id="llvm-nvvm-tcgen05-ld">
<h4><a class="toc-backref" href="#id192" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.tcgen05.ld.*</span></code>’</a><a class="headerlink" href="#llvm-nvvm-tcgen05-ld" title="Link to this heading">¶</a></h4>
<section id="id114">
<h5>Syntax:<a class="headerlink" href="#id114" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="p">&lt;</span><span class="err">n</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i32</span><span class="p">&gt;</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.ld.</span><span class="p">&lt;</span><span class="err">shape</span><span class="p">&gt;.&lt;</span><span class="err">num</span><span class="p">&gt;(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%pack</span><span class="p">)</span>

<span class="k">declare</span><span class="w"> </span><span class="p">&lt;</span><span class="err">n</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i32</span><span class="p">&gt;</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.ld.16x32bx2.</span><span class="p">&lt;</span><span class="err">num</span><span class="p">&gt;(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%offset</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%pack</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id115">
<h5>Overview:<a class="headerlink" href="#id115" title="Link to this heading">¶</a></h5>
<p>This group of intrinsics asynchronously load data from the Tensor Memory at the location specified
by the 32-bit address operand <cite>tmem_addr</cite> into the destination registers, collectively across all threads
of the warps.</p>
<p>All the threads in the warp must specify the same value of <cite>tmem_addr</cite>, which must be the base address
of the collective load operation. Otherwise, the behavior is undefined.</p>
<p>The <cite>shape</cite> qualifier and the <cite>num</cite> qualifier together determines the total dimension of the data (‘n’) which
is loaded from the Tensor Memory. The <cite>shape</cite> qualifier indicates the base dimension of data. The <cite>num</cite> qualifier
indicates the repeat factor on the base dimension resulting in the total dimension of the data that is accessed.</p>
<p>Allowed values for the ‘num’ are <cite>x1, x2, x4, x8, x16, x32, x64, x128</cite>.</p>
<p>Allowed values for the ‘shape’ in the first intrinsic are <cite>16x64b, 16x128b, 16x256b, 32x32b</cite>.</p>
<p>Allowed value for the ‘shape’ in the second intrinsic is <cite>16x32bx2</cite>.</p>
<p>The result of the intrinsic is a vector consisting of one or more 32-bit registers derived from <cite>shape</cite> and
<cite>num</cite> as shown below.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>num/shape</p></th>
<th class="head"><p>16x32bx2/16x64b/32x32b</p></th>
<th class="head"><p>16x128b</p></th>
<th class="head"><p>16x256b</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>x1</p></td>
<td><p>1</p></td>
<td><p>2</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-odd"><td><p>x2</p></td>
<td><p>2</p></td>
<td><p>4</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-even"><td><p>x4</p></td>
<td><p>4</p></td>
<td><p>8</p></td>
<td><p>16</p></td>
</tr>
<tr class="row-odd"><td><p>x8</p></td>
<td><p>8</p></td>
<td><p>16</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-even"><td><p>x16</p></td>
<td><p>16</p></td>
<td><p>32</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>x32</p></td>
<td><p>32</p></td>
<td><p>64</p></td>
<td><p>128</p></td>
</tr>
<tr class="row-even"><td><p>x64</p></td>
<td><p>64</p></td>
<td><p>128</p></td>
<td><p>NA</p></td>
</tr>
<tr class="row-odd"><td><p>x128</p></td>
<td><p>128</p></td>
<td><p>NA</p></td>
<td><p>NA</p></td>
</tr>
</tbody>
</table>
<p>The last argument <cite>i1 %pack</cite> is a compile-time constant which when set, indicates that the adjacent columns are packed into a single 32-bit element during the load</p>
<p>For more information, refer to the
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tcgen05-instructions-tcgen05-ld">PTX ISA</a>.</p>
</section>
</section>
<section id="llvm-nvvm-tcgen05-st">
<h4><a class="toc-backref" href="#id193" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.tcgen05.st.*</span></code>’</a><a class="headerlink" href="#llvm-nvvm-tcgen05-st" title="Link to this heading">¶</a></h4>
<section id="id116">
<h5>Syntax:<a class="headerlink" href="#id116" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.st.</span><span class="p">&lt;</span><span class="err">shape</span><span class="p">&gt;.&lt;</span><span class="err">num</span><span class="p">&gt;(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="p">&lt;</span><span class="err">n</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i32</span><span class="p">&gt;</span><span class="w"> </span><span class="nv">%args</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%unpack</span><span class="p">)</span>

<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.tcgen05.st.16x32bx2.</span><span class="p">&lt;</span><span class="err">num</span><span class="p">&gt;(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">6</span><span class="p">)</span><span class="w"> </span><span class="nv">%tmem_addr</span><span class="p">,</span><span class="w"> </span><span class="p">&lt;</span><span class="err">n</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i32</span><span class="p">&gt;</span><span class="w"> </span><span class="nv">%args</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%offset</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%unpack</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id117">
<h5>Overview:<a class="headerlink" href="#id117" title="Link to this heading">¶</a></h5>
<p>This group of intrinsics asynchronously store data from the source vector into the Tensor Memory at the location
specified by the 32-bit address operand ‘tmem_addr` collectively across all threads of the warps.</p>
<p>All the threads in the warp must specify the same value of <cite>tmem_addr</cite>, which must be the base address of the
collective load operation. Otherwise, the behavior is undefined.</p>
<p>The <cite>shape</cite> qualifier and the <cite>num</cite> qualifier together determines the total dimension of the data (‘n’) which
is loaded from the Tensor Memory. The <cite>shape</cite> qualifier indicates the base dimension of data. The <cite>num</cite> qualifier
indicates the repeat factor on the base dimension resulting in the total dimension of the data that is accessed.</p>
<p>Allowed values for the ‘num’ are <cite>x1, x2, x4, x8, x16, x32, x64, x128</cite>.</p>
<p>Allowed values for the ‘shape’ in the first intrinsic are <cite>16x64b, 16x128b, 16x256b, 32x32b</cite>.</p>
<p>Allowed value for the ‘shape’ in the second intrinsic is <cite>16x32bx2</cite>.</p>
<p><cite>args</cite> argument is a vector consisting of one or more 32-bit registers derived from <cite>shape</cite> and
<cite>num</cite> as listed in the table listed in the <cite>tcgen05.ld</cite> section.</p>
<p>Each shape support an <cite>unpack</cite> mode to allow a 32-bit element in the register to be unpacked into two 16-bit elements and store them in adjacent columns. <cite>unpack</cite> mode can be enabled by setting the <cite>%unpack</cite> operand to 1 and can be disabled by setting it to 0.</p>
<p>The last argument <cite>i1 %unpack</cite> is a compile-time constant which when set, indicates that a 32-bit element in the register to be unpacked into two 16-bit elements and store them in adjacent columns.</p>
<p>For more information, refer to the
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#tcgen05-instructions-tcgen05-st">PTX ISA</a>.</p>
</section>
</section>
</section>
<section id="store-intrinsics">
<h3><a class="toc-backref" href="#id194" role="doc-backlink">Store Intrinsics</a><a class="headerlink" href="#store-intrinsics" title="Link to this heading">¶</a></h3>
<section id="llvm-nvvm-st-bulk">
<h4><a class="toc-backref" href="#id195" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.st.bulk.*</span></code>’</a><a class="headerlink" href="#llvm-nvvm-st-bulk" title="Link to this heading">¶</a></h4>
<section id="id118">
<h5>Syntax:<a class="headerlink" href="#id118" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.st.bulk</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%dst</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%size</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="k">immarg</span><span class="w"> </span><span class="nv">%initval</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.st.bulk.shared.cta</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%dst</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%size</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="k">immarg</span><span class="w"> </span><span class="nv">%initval</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id119">
<h5>Overview:<a class="headerlink" href="#id119" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.st.bulk.*</span></code>’ intrinsics initialize a region of shared memory
starting from the location specified by the destination address operand <cite>%dst</cite>.</p>
<p>The integer operand <cite>%size</cite> specifies the amount of memory to be initialized in
terms of number of bytes and must be a multiple of 8. Otherwise, the behavior
is undefined.</p>
<p>The integer immediate operand <cite>%initval</cite> specifies the initialization value for
the memory locations. The only numeric value allowed is 0.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.st.bulk.shared.cta</span></code> and <code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.st.bulk</span></code> intrinsics are
similar but the latter uses generic addressing (see <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#generic-addressing">Generic Addressing</a>).</p>
<p>For more information, refer <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-st-bulk">PTX ISA</a>.</p>
</section>
</section>
</section>
<section id="clusterlaunchcontrol-intrinsics">
<h3><a class="toc-backref" href="#id196" role="doc-backlink">clusterlaunchcontrol Intrinsics</a><a class="headerlink" href="#clusterlaunchcontrol-intrinsics" title="Link to this heading">¶</a></h3>
<section id="llvm-nvvm-clusterlaunchcontrol-try-cancel-intrinsics">
<h4><a class="toc-backref" href="#id197" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.clusterlaunchcontrol.try_cancel*</span></code>’ Intrinsics</a><a class="headerlink" href="#llvm-nvvm-clusterlaunchcontrol-try-cancel-intrinsics" title="Link to this heading">¶</a></h4>
<section id="id120">
<h5>Syntax:<a class="headerlink" href="#id120" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.clusterlaunchcontrol.try_cancel.async.shared</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%addr</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%mbar</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.clusterlaunchcontrol.try_cancel.async.multicast.shared</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%addr</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="nv">%mbar</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id121">
<h5>Overview:<a class="headerlink" href="#id121" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">clusterlaunchcontrol.try_cancel</span></code> intrinsics requests atomically cancelling
the launch of a cluster that has not started running yet. It asynchronously non-atomically writes
a 16-byte opaque response to shared memory, pointed to by 16-byte-aligned <code class="docutils literal notranslate"><span class="pre">addr</span></code> indicating whether the
operation succeeded or failed. <code class="docutils literal notranslate"><span class="pre">addr</span></code> and 8-byte-aligned <code class="docutils literal notranslate"><span class="pre">mbar</span></code> must refer to <code class="docutils literal notranslate"><span class="pre">shared::cta</span></code>
otherwise the behavior is undefined. The completion of the asynchronous operation
is tracked using the mbarrier completion mechanism at <code class="docutils literal notranslate"><span class="pre">.cluster</span></code> scope referenced
by the shared memory pointer, <code class="docutils literal notranslate"><span class="pre">mbar</span></code>. On success, the opaque response contains
the CTA id of the first CTA of the canceled cluster; no other successful response
from other <code class="docutils literal notranslate"><span class="pre">clusterlaunchcontrol.try_cancel</span></code> operations from the same grid will
contain that id.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">multicast</span></code> variant specifies that the response is asynchronously non-atomically written to
the corresponding shared memory location of each CTA in the requesting cluster.
The completion of the write of each local response is tracked by independent
mbarriers at the corresponding shared memory location of each CTA in the
cluster.</p>
<p>For more information, refer <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/?a#parallel-synchronization-and-communication-instructions-clusterlaunchcontrol-try-cancel">PTX ISA</a>.</p>
</section>
</section>
<section id="llvm-nvvm-clusterlaunchcontrol-query-cancel-is-canceled-intrinsic">
<h4><a class="toc-backref" href="#id198" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.clusterlaunchcontrol.query_cancel.is_canceled</span></code>’ Intrinsic</a><a class="headerlink" href="#llvm-nvvm-clusterlaunchcontrol-query-cancel-is-canceled-intrinsic" title="Link to this heading">¶</a></h4>
<section id="id122">
<h5>Syntax:<a class="headerlink" href="#id122" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.nvvm.clusterlaunchcontrol.query_cancel.is_canceled</span><span class="p">(</span><span class="kt">i128</span><span class="w"> </span><span class="nv">%try_cancel_response</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id123">
<h5>Overview:<a class="headerlink" href="#id123" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">llvm.nvvm.clusterlaunchcontrol.query_cancel.is_canceled</span></code> intrinsic decodes the opaque response written by the
<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.clusterlaunchcontrol.try_cancel</span></code> operation.</p>
<p>The intrinsic returns <code class="docutils literal notranslate"><span class="pre">0</span></code> (false) if the request failed. If the request succeeded,
it returns <code class="docutils literal notranslate"><span class="pre">1</span></code> (true). A true result indicates that:</p>
<ul class="simple">
<li><p>the thread block cluster whose first CTA id matches that of the response
handle will not run, and</p></li>
<li><p>no other successful response of another <code class="docutils literal notranslate"><span class="pre">try_cancel</span></code> request in the grid will contain
the first CTA id of that cluster</p></li>
</ul>
<p>For more information, refer <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/?a#parallel-synchronization-and-communication-instructions-clusterlaunchcontrol-query-cancel">PTX ISA</a>.</p>
</section>
</section>
<section id="llvm-nvvm-clusterlaunchcontrol-query-cancel-get-first-ctaid-intrinsics">
<h4><a class="toc-backref" href="#id199" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.clusterlaunchcontrol.query_cancel.get_first_ctaid.*</span></code>’ Intrinsics</a><a class="headerlink" href="#llvm-nvvm-clusterlaunchcontrol-query-cancel-get-first-ctaid-intrinsics" title="Link to this heading">¶</a></h4>
<section id="id124">
<h5>Syntax:<a class="headerlink" href="#id124" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.clusterlaunchcontrol.query_cancel.get_first_ctaid.x</span><span class="p">(</span><span class="kt">i128</span><span class="w"> </span><span class="nv">%try_cancel_response</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.clusterlaunchcontrol.query_cancel.get_first_ctaid.y</span><span class="p">(</span><span class="kt">i128</span><span class="w"> </span><span class="nv">%try_cancel_response</span><span class="p">)</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.clusterlaunchcontrol.query_cancel.get_first_ctaid.z</span><span class="p">(</span><span class="kt">i128</span><span class="w"> </span><span class="nv">%try_cancel_response</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id125">
<h5>Overview:<a class="headerlink" href="#id125" title="Link to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">clusterlaunchcontrol.query_cancel.get_first_ctaid.*</span></code> intrinsic can be
used to decode the successful opaque response written by the
<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.clusterlaunchcontrol.try_cancel</span></code> operation.</p>
<p>If the request succeeded:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm.nvvm.clusterlaunchcontrol.query_cancel.get_first_ctaid.{x,y,z}</span></code> returns
the coordinate of the first CTA in the canceled cluster, either x, y, or z.</p></li>
</ul>
<p>If the request failed, the behavior of these intrinsics is undefined.</p>
<p>For more information, refer <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/?a#parallel-synchronization-and-communication-instructions-clusterlaunchcontrol-query-cancel">PTX ISA</a>.</p>
</section>
</section>
</section>
<section id="perf-monitor-event-intrinsics">
<h3><a class="toc-backref" href="#id200" role="doc-backlink">Perf Monitor Event Intrinsics</a><a class="headerlink" href="#perf-monitor-event-intrinsics" title="Link to this heading">¶</a></h3>
<section id="llvm-nvvm-pm-event-mask-intrinsic">
<h4><a class="toc-backref" href="#id201" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.pm.event.mask</span></code>’ Intrinsic</a><a class="headerlink" href="#llvm-nvvm-pm-event-mask-intrinsic" title="Link to this heading">¶</a></h4>
<section id="id126">
<h5>Syntax:<a class="headerlink" href="#id126" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.nvvm.pm.event.mask</span><span class="p">(</span><span class="kt">i16</span><span class="w"> </span><span class="k">immarg</span><span class="w"> </span><span class="nv">%mask_val</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id127">
<h5>Overview:<a class="headerlink" href="#id127" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.nvvm.pm.event.mask</span></code>’ intrinsic triggers one or more
performance monitor events. Each bit in the 16-bit immediate operand
<code class="docutils literal notranslate"><span class="pre">%mask_val</span></code> controls an event.</p>
<p>For more information on the pmevent instructions, refer to the PTX ISA
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#miscellaneous-instructions-pmevent">https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#miscellaneous-instructions-pmevent</a>.</p>
</section>
</section>
</section>
<section id="other-intrinsics">
<h3><a class="toc-backref" href="#id202" role="doc-backlink">Other Intrinsics</a><a class="headerlink" href="#other-intrinsics" title="Link to this heading">¶</a></h3>
<p>For the full set of NVPTX intrinsics, please see the
<code class="docutils literal notranslate"><span class="pre">include/llvm/IR/IntrinsicsNVVM.td</span></code> file in the LLVM source tree.</p>
</section>
</section>
<section id="linking-with-libdevice">
<span id="libdevice"></span><h2><a class="toc-backref" href="#id203" role="doc-backlink">Linking with Libdevice</a><a class="headerlink" href="#linking-with-libdevice" title="Link to this heading">¶</a></h2>
<p>The CUDA Toolkit comes with an LLVM bitcode library called <code class="docutils literal notranslate"><span class="pre">libdevice</span></code> that
implements many common mathematical functions. This library can be used as a
high-performance math library for any compilers using the LLVM NVPTX target.
The library can be found under <code class="docutils literal notranslate"><span class="pre">nvvm/libdevice/</span></code> in the CUDA Toolkit and
there is a separate version for each compute architecture.</p>
<p>For a list of all math functions implemented in libdevice, see
<a class="reference external" href="http://docs.nvidia.com/cuda/libdevice-users-guide/index.html">libdevice Users Guide</a>.</p>
<p>To accommodate various math-related compiler flags that can affect code
generation of libdevice code, the library code depends on a special LLVM IR
pass (<code class="docutils literal notranslate"><span class="pre">NVVMReflect</span></code>) to handle conditional compilation within LLVM IR. This
pass looks for calls to the <code class="docutils literal notranslate"><span class="pre">&#64;__nvvm_reflect</span></code> function and replaces them
with constants based on the defined reflection parameters. Such conditional
code often follows a pattern:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="nf">my_function</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__nvvm_reflect</span><span class="p">(</span><span class="s">&quot;FASTMATH&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">my_function_fast</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">  </span><span class="k">else</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">my_function_precise</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The default value for all unspecified reflection parameters is zero.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">NVVMReflect</span></code> pass should be executed early in the optimization
pipeline, immediately after the link stage. The <code class="docutils literal notranslate"><span class="pre">internalize</span></code> pass is also
recommended to remove unused math functions from the resulting PTX. For an
input IR module <code class="docutils literal notranslate"><span class="pre">module.bc</span></code>, the following compilation flow is recommended:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">NVVMReflect</span></code> pass will attempt to remove dead code even without
optimizations. This allows potentially incompatible instructions to be avoided
at all optimizations levels by using the <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH</span></code> argument.</p>
<ol class="arabic simple">
<li><p>Save list of external functions in <code class="docutils literal notranslate"><span class="pre">module.bc</span></code></p></li>
<li><p>Link <code class="docutils literal notranslate"><span class="pre">module.bc</span></code> with <code class="docutils literal notranslate"><span class="pre">libdevice.compute_XX.YY.bc</span></code></p></li>
<li><p>Internalize all functions not in list from (1)</p></li>
<li><p>Eliminate all unused internal functions</p></li>
<li><p>Run <code class="docutils literal notranslate"><span class="pre">NVVMReflect</span></code> pass</p></li>
<li><p>Run standard optimization pipeline</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">linkonce</span></code> and <code class="docutils literal notranslate"><span class="pre">linkonce_odr</span></code> linkage types are not suitable for the
libdevice functions. It is possible to link two IR modules that have been
linked against libdevice using different reflection variables.</p>
</div>
<p>Since the <code class="docutils literal notranslate"><span class="pre">NVVMReflect</span></code> pass replaces conditionals with constants, it will
often leave behind dead code of the form:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nl">entry:</span>
<span class="w">  </span><span class="p">..</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">true</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%foo</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%bar</span>
<span class="nl">foo:</span>
<span class="w">  </span><span class="p">..</span>
<span class="nl">bar:</span>
<span class="w">  </span><span class="c">; Dead code</span>
<span class="w">  </span><span class="p">..</span>
</pre></div>
</div>
<p>Therefore, it is recommended that <code class="docutils literal notranslate"><span class="pre">NVVMReflect</span></code> is executed early in the
optimization pipeline before dead-code elimination.</p>
<p>The NVPTX TargetMachine knows how to schedule <code class="docutils literal notranslate"><span class="pre">NVVMReflect</span></code> at the beginning
of your pass manager; just use the following code when setting up your pass
manager and the PassBuilder will use <code class="docutils literal notranslate"><span class="pre">registerPassBuilderCallbacks</span></code> to let
NVPTXTargetMachine::registerPassBuilderCallbacks add the pass to the
pass manager:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TargetMachine</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="n">PassBuilder</span><span class="w"> </span><span class="nf">PB</span><span class="p">(</span><span class="n">TM</span><span class="p">);</span>
<span class="n">ModulePassManager</span><span class="w"> </span><span class="n">MPM</span><span class="p">;</span>
<span class="n">PB</span><span class="p">.</span><span class="n">parsePassPipeline</span><span class="p">(</span><span class="n">MPM</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>
</pre></div>
</div>
<section id="reflection-parameters">
<h3><a class="toc-backref" href="#id204" role="doc-backlink">Reflection Parameters</a><a class="headerlink" href="#reflection-parameters" title="Link to this heading">¶</a></h3>
<p>The libdevice library currently uses the following reflection parameters to
control code generation:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Flag</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__CUDA_FTZ=[0,1]</span></code></p></td>
<td><p>Use optimized code paths that flush subnormals to zero</p></td>
</tr>
</tbody>
</table>
<p>The value of this flag is determined by the “nvvm-reflect-ftz” module flag.
The following sets the ftz flag to 1.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv">!llvm.module.flags</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="nv nv-Anonymous">!0</span><span class="p">}</span>
<span class="nv nv-Anonymous">!0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="kt">i32</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="nv">!&quot;nvvm-reflect-ftz&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">1</span><span class="p">}</span>
</pre></div>
</div>
<p>(<code class="docutils literal notranslate"><span class="pre">i32</span> <span class="pre">4</span></code> indicates that the value set here overrides the value in another
module we link with.  See the <cite>LangRef &lt;LangRef.html#module-flags-metadata&gt;</cite>
for details.)</p>
</section>
</section>
<section id="executing-ptx">
<h2><a class="toc-backref" href="#id205" role="doc-backlink">Executing PTX</a><a class="headerlink" href="#executing-ptx" title="Link to this heading">¶</a></h2>
<p>The most common way to execute PTX assembly on a GPU device is to use the CUDA
Driver API. This API is a low-level interface to the GPU driver and allows for
JIT compilation of PTX code to native GPU machine code.</p>
<p>Initializing the Driver API:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CUdevice</span><span class="w"> </span><span class="n">device</span><span class="p">;</span>
<span class="n">CUcontext</span><span class="w"> </span><span class="n">context</span><span class="p">;</span>

<span class="c1">// Initialize the driver API</span>
<span class="n">cuInit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">// Get a handle to the first compute device</span>
<span class="n">cuDeviceGet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="c1">// Create a compute device context</span>
<span class="n">cuCtxCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">);</span>
</pre></div>
</div>
<p>JIT compiling a PTX string to a device binary:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CUmodule</span><span class="w"> </span><span class="k">module</span><span class="p">;</span>
<span class="n">CUfunction</span><span class="w"> </span><span class="n">function</span><span class="p">;</span>

<span class="c1">// JIT compile a null-terminated PTX string</span>
<span class="n">cuModuleLoadData</span><span class="p">(</span><span class="o">&amp;</span><span class="k">module</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">PTXString</span><span class="p">);</span>

<span class="c1">// Get a handle to the &quot;myfunction&quot; kernel function</span>
<span class="n">cuModuleGetFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">function</span><span class="p">,</span><span class="w"> </span><span class="k">module</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;myfunction&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>For full examples of executing PTX assembly, please see the <a class="reference external" href="https://developer.nvidia.com/cuda-downloads">CUDA Samples</a> distribution.</p>
</section>
<section id="common-issues">
<h2><a class="toc-backref" href="#id206" role="doc-backlink">Common Issues</a><a class="headerlink" href="#common-issues" title="Link to this heading">¶</a></h2>
<section id="ptxas-complains-of-undefined-function-nvvm-reflect">
<h3><a class="toc-backref" href="#id207" role="doc-backlink">ptxas complains of undefined function: __nvvm_reflect</a><a class="headerlink" href="#ptxas-complains-of-undefined-function-nvvm-reflect" title="Link to this heading">¶</a></h3>
<p>When linking with libdevice, the <code class="docutils literal notranslate"><span class="pre">NVVMReflect</span></code> pass must be used. See
<a class="reference internal" href="#libdevice"><span class="std std-ref">Linking with Libdevice</span></a> for more information.</p>
</section>
</section>
<section id="tutorial-a-simple-compute-kernel">
<h2><a class="toc-backref" href="#id208" role="doc-backlink">Tutorial: A Simple Compute Kernel</a><a class="headerlink" href="#tutorial-a-simple-compute-kernel" title="Link to this heading">¶</a></h2>
<p>To start, let us take a look at a simple compute kernel written directly in
LLVM IR. The kernel implements vector addition, where each thread computes one
element of the output vector C from the input vectors A and B.  To make this
easier, we also assume that only a single CTA (thread block) will be launched,
and that it will be one dimensional.</p>
<section id="the-kernel">
<h3><a class="toc-backref" href="#id209" role="doc-backlink">The Kernel</a><a class="headerlink" href="#the-kernel" title="Link to this heading">¶</a></h3>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">target</span><span class="w"> </span><span class="k">datalayout</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v16:16:16-v32:32:32-v64:64:64-v128:128:128-n16:32:64&quot;</span>
<span class="k">target</span><span class="w"> </span><span class="k">triple</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;nvptx64-nvidia-cuda&quot;</span>

<span class="c">; Intrinsic to read X component of thread ID</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.tid.x</span><span class="p">()</span><span class="w"> </span><span class="k">readnone</span><span class="w"> </span><span class="k">nounwind</span>

<span class="k">define</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@kernel</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%A</span><span class="p">,</span>
<span class="w">                    </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%B</span><span class="p">,</span>
<span class="w">                    </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%C</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="c">; What is my ID?</span>
<span class="w">  </span><span class="nv">%id</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.tid.x</span><span class="p">()</span><span class="w"> </span><span class="k">readnone</span><span class="w"> </span><span class="k">nounwind</span>

<span class="w">  </span><span class="c">; Compute pointers into A, B, and C</span>
<span class="w">  </span><span class="nv">%ptrA</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%A</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%id</span>
<span class="w">  </span><span class="nv">%ptrB</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%B</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%id</span>
<span class="w">  </span><span class="nv">%ptrC</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%C</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%id</span>

<span class="w">  </span><span class="c">; Read A, B</span>
<span class="w">  </span><span class="nv">%valA</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%ptrA</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
<span class="w">  </span><span class="nv">%valB</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%ptrB</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>

<span class="w">  </span><span class="c">; Compute C = A + B</span>
<span class="w">  </span><span class="nv">%valC</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">fadd</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%valA</span><span class="p">,</span><span class="w"> </span><span class="nv">%valB</span>

<span class="w">  </span><span class="c">; Store back to C</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%valC</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%ptrC</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>

<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="k">void</span>
<span class="p">}</span>

<span class="nv">!nvvm.annotations</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="nv nv-Anonymous">!0</span><span class="p">}</span>
<span class="nv nv-Anonymous">!0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@kernel</span><span class="p">,</span><span class="w"> </span><span class="nv">!&quot;kernel&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">1</span><span class="p">}</span>
</pre></div>
</div>
<p>We can use the LLVM <code class="docutils literal notranslate"><span class="pre">llc</span></code> tool to directly run the NVPTX code generator:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># llc -mcpu=sm_20 kernel.ll -o kernel.ptx
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you want to generate 32-bit code, change <code class="docutils literal notranslate"><span class="pre">p:64:64:64</span></code> to <code class="docutils literal notranslate"><span class="pre">p:32:32:32</span></code>
in the module data layout string and use <code class="docutils literal notranslate"><span class="pre">nvptx-nvidia-cuda</span></code> as the
target triple.</p>
</div>
<p>The output we get from <code class="docutils literal notranslate"><span class="pre">llc</span></code> (as of LLVM 3.4):</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>//
// Generated by LLVM NVPTX Back-End
//

.version 3.1
.target sm_20
.address_size 64

  // .globl kernel
                                        // @kernel
.visible .entry kernel(
  .param .u64 kernel_param_0,
  .param .u64 kernel_param_1,
  .param .u64 kernel_param_2
)
{
  .reg .f32   %f&lt;4&gt;;
  .reg .s32   %r&lt;2&gt;;
  .reg .s64   %rl&lt;8&gt;;

// %bb.0:                                // %entry
  ld.param.u64    %rl1, [kernel_param_0];
  mov.u32         %r1, %tid.x;
  mul.wide.s32    %rl2, %r1, 4;
  add.s64         %rl3, %rl1, %rl2;
  ld.param.u64    %rl4, [kernel_param_1];
  add.s64         %rl5, %rl4, %rl2;
  ld.param.u64    %rl6, [kernel_param_2];
  add.s64         %rl7, %rl6, %rl2;
  ld.global.f32   %f1, [%rl3];
  ld.global.f32   %f2, [%rl5];
  add.f32         %f3, %f1, %f2;
  st.global.f32   [%rl7], %f3;
  ret;
}
</pre></div>
</div>
</section>
<section id="dissecting-the-kernel">
<h3><a class="toc-backref" href="#id210" role="doc-backlink">Dissecting the Kernel</a><a class="headerlink" href="#dissecting-the-kernel" title="Link to this heading">¶</a></h3>
<p>Now let us dissect the LLVM IR that makes up this kernel.</p>
<section id="data-layout">
<h4><a class="toc-backref" href="#id211" role="doc-backlink">Data Layout</a><a class="headerlink" href="#data-layout" title="Link to this heading">¶</a></h4>
<p>The data layout string determines the size in bits of common data types, their
ABI alignment, and their storage size.  For NVPTX, you should use one of the
following:</p>
<p>32-bit PTX:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">target</span><span class="w"> </span><span class="k">datalayout</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v16:16:16-v32:32:32-v64:64:64-v128:128:128-n16:32:64&quot;</span>
</pre></div>
</div>
<p>64-bit PTX:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">target</span><span class="w"> </span><span class="k">datalayout</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v16:16:16-v32:32:32-v64:64:64-v128:128:128-n16:32:64&quot;</span>
</pre></div>
</div>
</section>
<section id="target-intrinsics">
<h4><a class="toc-backref" href="#id212" role="doc-backlink">Target Intrinsics</a><a class="headerlink" href="#target-intrinsics" title="Link to this heading">¶</a></h4>
<p>In this example, we use the <code class="docutils literal notranslate"><span class="pre">&#64;llvm.nvvm.read.ptx.sreg.tid.x</span></code> intrinsic to
read the X component of the current thread’s ID, which corresponds to a read
of register <code class="docutils literal notranslate"><span class="pre">%tid.x</span></code> in PTX. The NVPTX back-end supports a large set of
intrinsics.  A short list is shown below; please see
<code class="docutils literal notranslate"><span class="pre">include/llvm/IR/IntrinsicsNVVM.td</span></code> for the full list.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Intrinsic</p></th>
<th class="head"><p>CUDA Equivalent</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">i32</span> <span class="pre">&#64;llvm.nvvm.read.ptx.sreg.tid.{x,y,z}</span></code></p></td>
<td><p>threadIdx.{x,y,z}</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">i32</span> <span class="pre">&#64;llvm.nvvm.read.ptx.sreg.ctaid.{x,y,z}</span></code></p></td>
<td><p>blockIdx.{x,y,z}</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">i32</span> <span class="pre">&#64;llvm.nvvm.read.ptx.sreg.ntid.{x,y,z}</span></code></p></td>
<td><p>blockDim.{x,y,z}</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">i32</span> <span class="pre">&#64;llvm.nvvm.read.ptx.sreg.nctaid.{x,y,z}</span></code></p></td>
<td><p>gridDim.{x,y,z}</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">&#64;llvm.nvvm.barrier0()</span></code></p></td>
<td><p>__syncthreads()</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id128">
<h4><a class="toc-backref" href="#id213" role="doc-backlink">Address Spaces</a><a class="headerlink" href="#id128" title="Link to this heading">¶</a></h4>
<p>You may have noticed that all of the pointer types in the LLVM IR example had
an explicit address space specifier. What is address space 1? NVIDIA GPU
devices (generally) have four types of memory:</p>
<ul class="simple">
<li><p>Global: Large, off-chip memory</p></li>
<li><p>Shared: Small, on-chip memory shared among all threads in a CTA</p></li>
<li><p>Local: Per-thread, private memory</p></li>
<li><p>Constant: Read-only memory shared across all threads</p></li>
</ul>
<p>These different types of memory are represented in LLVM IR as address spaces.
There is also a fifth address space used by the NVPTX code generator that
corresponds to the “generic” address space.  This address space can represent
addresses in any other address space (with a few exceptions).  This allows
users to write IR functions that can load/store memory using the same
instructions. Intrinsics are provided to convert pointers between the generic
and non-generic address spaces.</p>
<p>See <a class="reference internal" href="#address-spaces"><span class="std std-ref">Address Spaces</span></a> and <a class="reference internal" href="#nvptx-intrinsics"><span class="std std-ref">NVPTX Intrinsics</span></a> for more information.</p>
</section>
<section id="kernel-metadata">
<h4><a class="toc-backref" href="#id214" role="doc-backlink">Kernel Metadata</a><a class="headerlink" href="#kernel-metadata" title="Link to this heading">¶</a></h4>
<p>In PTX, a function can be either a <cite>kernel</cite> function (callable from the host
program), or a <cite>device</cite> function (callable only from GPU code). You can think
of <cite>kernel</cite> functions as entry-points in the GPU program. To mark an LLVM IR
function as a <cite>kernel</cite> function, we make use of special LLVM metadata. The
NVPTX back-end will look for a named metadata node called
<code class="docutils literal notranslate"><span class="pre">nvvm.annotations</span></code>. This named metadata must contain a list of metadata that
describe the IR. For our purposes, we need to declare a metadata node that
assigns the “kernel” attribute to the LLVM IR function that should be emitted
as a PTX <cite>kernel</cite> function. These metadata nodes take the form:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>!{&lt;function ref&gt;, metadata !&quot;kernel&quot;, i32 1}
</pre></div>
</div>
<p>For the previous example, we have:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv">!nvvm.annotations</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="nv nv-Anonymous">!0</span><span class="p">}</span>
<span class="nv nv-Anonymous">!0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@kernel</span><span class="p">,</span><span class="w"> </span><span class="nv">!&quot;kernel&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">1</span><span class="p">}</span>
</pre></div>
</div>
<p>Here, we have a single metadata declaration in <code class="docutils literal notranslate"><span class="pre">nvvm.annotations</span></code>. This
metadata annotates our <code class="docutils literal notranslate"><span class="pre">&#64;kernel</span></code> function with the <code class="docutils literal notranslate"><span class="pre">kernel</span></code> attribute.</p>
</section>
</section>
<section id="running-the-kernel">
<h3><a class="toc-backref" href="#id215" role="doc-backlink">Running the Kernel</a><a class="headerlink" href="#running-the-kernel" title="Link to this heading">¶</a></h3>
<p>Generating PTX from LLVM IR is all well and good, but how do we execute it on
a real GPU device? The CUDA Driver API provides a convenient mechanism for
loading and JIT compiling PTX to a native GPU device, and launching a kernel.
The API is similar to OpenCL.  A simple example showing how to load and
execute our vector addition code is shown below. Note that for brevity this
code does not perform much error checking!</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You can also use the <code class="docutils literal notranslate"><span class="pre">ptxas</span></code> tool provided by the CUDA Toolkit to offline
compile PTX to machine code (SASS) for a specific GPU architecture. Such
binaries can be loaded by the CUDA Driver API in the same way as PTX. This
can be useful for reducing startup time by precompiling the PTX kernels.</p>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;fstream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cassert&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;cuda.h&quot;</span>


<span class="kt">void</span><span class="w"> </span><span class="nf">checkCudaErrors</span><span class="p">(</span><span class="n">CUresult</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">CUDA_SUCCESS</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// main - Program entry point</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">CUdevice</span><span class="w">    </span><span class="n">device</span><span class="p">;</span>
<span class="w">  </span><span class="n">CUmodule</span><span class="w">    </span><span class="n">cudaModule</span><span class="p">;</span>
<span class="w">  </span><span class="n">CUcontext</span><span class="w">   </span><span class="n">context</span><span class="p">;</span>
<span class="w">  </span><span class="n">CUfunction</span><span class="w">  </span><span class="n">function</span><span class="p">;</span>
<span class="w">  </span><span class="n">CUlinkState</span><span class="w"> </span><span class="n">linker</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w">         </span><span class="n">devCount</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// CUDA initialization</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuInit</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuDeviceGetCount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devCount</span><span class="p">));</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuDeviceGet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>

<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">name</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuDeviceGetName</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">));</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Using CUDA Device [0]: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">devMajor</span><span class="p">,</span><span class="w"> </span><span class="n">devMinor</span><span class="p">;</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuDeviceComputeCapability</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devMajor</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">devMinor</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">));</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Device Compute Capability: &quot;</span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">devMajor</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">devMinor</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">devMajor</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;ERROR: Device 0 is not SM 2.0 or greater</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="s">&quot;kernel.ptx&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;kernel.ptx not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="p">((</span><span class="n">std</span><span class="o">::</span><span class="n">istreambuf_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span>
<span class="w">                    </span><span class="n">std</span><span class="o">::</span><span class="n">istreambuf_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">());</span>

<span class="w">  </span><span class="c1">// Create driver context</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuCtxCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Create module for object</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuModuleLoadDataEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cudaModule</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Get kernel function</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuModuleGetFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">function</span><span class="p">,</span><span class="w"> </span><span class="n">cudaModule</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;kernel&quot;</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Device data</span>
<span class="w">  </span><span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">devBufferA</span><span class="p">;</span>
<span class="w">  </span><span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">devBufferB</span><span class="p">;</span>
<span class="w">  </span><span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">devBufferC</span><span class="p">;</span>

<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devBufferA</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="mi">16</span><span class="p">));</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devBufferB</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="mi">16</span><span class="p">));</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devBufferC</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="mi">16</span><span class="p">));</span>

<span class="w">  </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">hostA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="w">  </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">hostB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="w">  </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">hostC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

<span class="w">  </span><span class="c1">// Populate input</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">hostA</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="n">hostB</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="n">hostC</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">devBufferA</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hostA</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="mi">16</span><span class="p">));</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">devBufferB</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hostB</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="mi">16</span><span class="p">));</span>


<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">blockSizeX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">blockSizeY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">blockSizeZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">gridSizeX</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">gridSizeY</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">gridSizeZ</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Kernel parameters</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">KernelParams</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="n">devBufferA</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">devBufferB</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">devBufferC</span><span class="w"> </span><span class="p">};</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Launching kernel</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Kernel launch</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuLaunchKernel</span><span class="p">(</span><span class="n">function</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeX</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeY</span><span class="p">,</span><span class="w"> </span><span class="n">gridSizeZ</span><span class="p">,</span>
<span class="w">                                 </span><span class="n">blockSizeX</span><span class="p">,</span><span class="w"> </span><span class="n">blockSizeY</span><span class="p">,</span><span class="w"> </span><span class="n">blockSizeZ</span><span class="p">,</span>
<span class="w">                                 </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">KernelParams</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Retrieve device data</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuMemcpyDtoH</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hostC</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">devBufferC</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="o">*</span><span class="mi">16</span><span class="p">));</span>


<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Results:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">hostA</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; + &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">hostB</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">hostC</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>


<span class="w">  </span><span class="c1">// Clean up after ourselves</span>
<span class="w">  </span><span class="k">delete</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">hostA</span><span class="p">;</span>
<span class="w">  </span><span class="k">delete</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">hostB</span><span class="p">;</span>
<span class="w">  </span><span class="k">delete</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">hostC</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Clean-up</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">devBufferA</span><span class="p">));</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">devBufferB</span><span class="p">));</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuMemFree</span><span class="p">(</span><span class="n">devBufferC</span><span class="p">));</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuModuleUnload</span><span class="p">(</span><span class="n">cudaModule</span><span class="p">));</span>
<span class="w">  </span><span class="n">checkCudaErrors</span><span class="p">(</span><span class="n">cuCtxDestroy</span><span class="p">(</span><span class="n">context</span><span class="p">));</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You will need to link with the CUDA driver and specify the path to cuda.h.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># clang++ sample.cpp -o sample -O2 -g -I/usr/local/cuda-5.5/include -lcuda
</pre></div>
</div>
<p>We don’t need to specify a path to <code class="docutils literal notranslate"><span class="pre">libcuda.so</span></code> since this is installed in a
system location by the driver, not the CUDA toolkit.</p>
<p>If everything goes as planned, you should see the following output when
running the compiled program:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Using CUDA Device [0]: GeForce GTX 680
Device Compute Capability: 3.0
Launching kernel
Results:
0 + 0 = 0
1 + 2 = 3
2 + 4 = 6
3 + 6 = 9
4 + 8 = 12
5 + 10 = 15
6 + 12 = 18
7 + 14 = 21
8 + 16 = 24
9 + 18 = 27
10 + 20 = 30
11 + 22 = 33
12 + 24 = 36
13 + 26 = 39
14 + 28 = 42
15 + 30 = 45
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You will likely see a different device identifier based on your hardware</p>
</div>
</section>
</section>
<section id="tutorial-linking-with-libdevice">
<h2><a class="toc-backref" href="#id216" role="doc-backlink">Tutorial: Linking with Libdevice</a><a class="headerlink" href="#tutorial-linking-with-libdevice" title="Link to this heading">¶</a></h2>
<p>In this tutorial, we show a simple example of linking LLVM IR with the
libdevice library. We will use the same kernel as the previous tutorial,
except that we will compute <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">pow(A,</span> <span class="pre">B)</span></code> instead of <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">A</span> <span class="pre">+</span> <span class="pre">B</span></code>.
Libdevice provides an <code class="docutils literal notranslate"><span class="pre">__nv_powf</span></code> function that we will use.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">target</span><span class="w"> </span><span class="k">datalayout</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v16:16:16-v32:32:32-v64:64:64-v128:128:128-n16:32:64&quot;</span>
<span class="k">target</span><span class="w"> </span><span class="k">triple</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;nvptx64-nvidia-cuda&quot;</span>

<span class="c">; Intrinsic to read X component of thread ID</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.tid.x</span><span class="p">()</span><span class="w"> </span><span class="k">readnone</span><span class="w"> </span><span class="k">nounwind</span>
<span class="c">; libdevice function</span>
<span class="k">declare</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="vg">@__nv_powf</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="p">)</span>

<span class="k">define</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@kernel</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%A</span><span class="p">,</span>
<span class="w">                    </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%B</span><span class="p">,</span>
<span class="w">                    </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%C</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="c">; What is my ID?</span>
<span class="w">  </span><span class="nv">%id</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.nvvm.read.ptx.sreg.tid.x</span><span class="p">()</span><span class="w"> </span><span class="k">readnone</span><span class="w"> </span><span class="k">nounwind</span>

<span class="w">  </span><span class="c">; Compute pointers into A, B, and C</span>
<span class="w">  </span><span class="nv">%ptrA</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%A</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%id</span>
<span class="w">  </span><span class="nv">%ptrB</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%B</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%id</span>
<span class="w">  </span><span class="nv">%ptrC</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%C</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%id</span>

<span class="w">  </span><span class="c">; Read A, B</span>
<span class="w">  </span><span class="nv">%valA</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%ptrA</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
<span class="w">  </span><span class="nv">%valB</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%ptrB</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>

<span class="w">  </span><span class="c">; Compute C = pow(A, B)</span>
<span class="w">  </span><span class="nv">%valC</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="vg">@__nv_powf</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="nv">%valA</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%valB</span><span class="p">)</span>

<span class="w">  </span><span class="c">; Store back to C</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nv">%valC</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">addrspace</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv">%ptrC</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>

<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="k">void</span>
<span class="p">}</span>

<span class="nv">!nvvm.annotations</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="nv nv-Anonymous">!0</span><span class="p">}</span>
<span class="nv nv-Anonymous">!0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@kernel</span><span class="p">,</span><span class="w"> </span><span class="nv">!&quot;kernel&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">1</span><span class="p">}</span>
</pre></div>
</div>
<p>To compile this kernel, we perform the following steps:</p>
<ol class="arabic simple">
<li><p>Link with libdevice</p></li>
<li><p>Internalize all but the public kernel function</p></li>
<li><p>Run <code class="docutils literal notranslate"><span class="pre">NVVMReflect</span></code> and set <code class="docutils literal notranslate"><span class="pre">__CUDA_FTZ</span></code> to 0</p></li>
<li><p>Optimize the linked module</p></li>
<li><p>Codegen the module</p></li>
</ol>
<p>These steps can be performed by the LLVM <code class="docutils literal notranslate"><span class="pre">llvm-link</span></code>, <code class="docutils literal notranslate"><span class="pre">opt</span></code>, and <code class="docutils literal notranslate"><span class="pre">llc</span></code>
tools. In a complete compiler, these steps can also be performed entirely
programmatically by setting up an appropriate pass configuration (see
<a class="reference internal" href="#libdevice"><span class="std std-ref">Linking with Libdevice</span></a>).</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># llvm-link t2.bc libdevice.compute_20.10.bc -o t2.linked.bc
# opt -internalize -internalize-public-api-list=kernel -nvvm-reflect-list=__CUDA_FTZ=0 -nvvm-reflect -O3 t2.linked.bc -o t2.opt.bc
# llc -mcpu=sm_20 t2.opt.bc -o t2.ptx
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">-nvvm-reflect-list=_CUDA_FTZ=0</span></code> is not strictly required, as any
undefined variables will default to zero. It is shown here for evaluation
purposes.</p>
</div>
<p>This gives us the following PTX (excerpt):</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>//
// Generated by LLVM NVPTX Back-End
//

.version 3.1
.target sm_20
.address_size 64

  // .globl kernel
                                        // @kernel
.visible .entry kernel(
  .param .u64 kernel_param_0,
  .param .u64 kernel_param_1,
  .param .u64 kernel_param_2
)
{
  .reg .pred  %p&lt;30&gt;;
  .reg .f32   %f&lt;111&gt;;
  .reg .s32   %r&lt;21&gt;;
  .reg .s64   %rl&lt;8&gt;;

// %bb.0:                                // %entry
  ld.param.u64  %rl2, [kernel_param_0];
  mov.u32   %r3, %tid.x;
  ld.param.u64  %rl3, [kernel_param_1];
  mul.wide.s32  %rl4, %r3, 4;
  add.s64   %rl5, %rl2, %rl4;
  ld.param.u64  %rl6, [kernel_param_2];
  add.s64   %rl7, %rl3, %rl4;
  add.s64   %rl1, %rl6, %rl4;
  ld.global.f32   %f1, [%rl5];
  ld.global.f32   %f2, [%rl7];
  setp.eq.f32 %p1, %f1, 0f3F800000;
  setp.eq.f32 %p2, %f2, 0f00000000;
  or.pred   %p3, %p1, %p2;
  @%p3 bra  BB0_1;
  bra.uni   BB0_2;
BB0_1:
  mov.f32   %f110, 0f3F800000;
  st.global.f32   [%rl1], %f110;
  ret;
BB0_2:                                  // %__nv_isnanf.exit.i
  abs.f32   %f4, %f1;
  setp.gtu.f32  %p4, %f4, 0f7F800000;
  @%p4 bra  BB0_4;
// %bb.3:                                // %__nv_isnanf.exit5.i
  abs.f32   %f5, %f2;
  setp.le.f32 %p5, %f5, 0f7F800000;
  @%p5 bra  BB0_5;
BB0_4:                                  // %.critedge1.i
  add.f32   %f110, %f1, %f2;
  st.global.f32   [%rl1], %f110;
  ret;
BB0_5:                                  // %__nv_isinff.exit.i

  ...

BB0_26:                                 // %__nv_truncf.exit.i.i.i.i.i
  mul.f32   %f90, %f107, 0f3FB8AA3B;
  cvt.rzi.f32.f32 %f91, %f90;
  mov.f32   %f92, 0fBF317200;
  fma.rn.f32  %f93, %f91, %f92, %f107;
  mov.f32   %f94, 0fB5BFBE8E;
  fma.rn.f32  %f95, %f91, %f94, %f93;
  mul.f32   %f89, %f95, 0f3FB8AA3B;
  // inline asm
  ex2.approx.ftz.f32 %f88,%f89;
  // inline asm
  add.f32   %f96, %f91, 0f00000000;
  ex2.approx.f32  %f97, %f96;
  mul.f32   %f98, %f88, %f97;
  setp.lt.f32 %p15, %f107, 0fC2D20000;
  selp.f32  %f99, 0f00000000, %f98, %p15;
  setp.gt.f32 %p16, %f107, 0f42D20000;
  selp.f32  %f110, 0f7F800000, %f99, %p16;
  setp.eq.f32 %p17, %f110, 0f7F800000;
  @%p17 bra   BB0_28;
// %bb.27:
  fma.rn.f32  %f110, %f110, %f108, %f110;
BB0_28:                                 // %__internal_accurate_powf.exit.i
  setp.lt.f32 %p18, %f1, 0f00000000;
  setp.eq.f32 %p19, %f3, 0f3F800000;
  and.pred    %p20, %p18, %p19;
  @!%p20 bra  BB0_30;
  bra.uni   BB0_29;
BB0_29:
  mov.b32    %r9, %f110;
  xor.b32   %r10, %r9, -2147483648;
  mov.b32    %f110, %r10;
BB0_30:                                 // %__nv_powf.exit
  st.global.f32   [%rl1], %f110;
  ret;
}
</pre></div>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="Passes.html" title="LLVM’s Analysis and Transform Passes"
             >next</a> |</li>
        <li class="right" >
          <a href="NewPassManager.html" title="Using the New Pass Manager"
             >previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" >User Guides</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">User Guide for NVPTX Back-end</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2003-2025, LLVM Project.
      Last updated on 2025-08-26.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>