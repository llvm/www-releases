
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Convergence And Uniformity &#8212; LLVM 21.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/llvm-theme.css?v=96924833" />
    <script src="_static/documentation_options.js?v=c54a4614"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Convergent Operation Semantics" href="ConvergentOperations.html" />
    <link rel="prev" title="llvm-remarkutil - Remark utility" href="CommandGuide/llvm-remarkutil.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="ConvergentOperations.html" title="Convergent Operation Semantics"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="CommandGuide/llvm-remarkutil.html" title="llvm-remarkutil - Remark utility"
             accesskey="P">previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="Reference.html" accesskey="U">Reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Convergence And Uniformity</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="https://llvm.org/docs/UserGuides.html">User Guides</a></li>
    <li><a href="https://llvm.org/docs/Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/Contributing.html">Contributing to LLVM</a></li>
    <li><a href="https://llvm.org/docs/HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#discord">Discord</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/FAQ.html">FAQ</a></li>
    <li><a href="https://llvm.org/docs/Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project/">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/ConvergenceAndUniformity.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="convergence-and-uniformity">
<span id="id1"></span><h1>Convergence And Uniformity<a class="headerlink" href="#convergence-and-uniformity" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id3">Introduction</a></p></li>
<li><p><a class="reference internal" href="#motivation" id="id4">Motivation</a></p></li>
<li><p><a class="reference internal" href="#terminology" id="id5">Terminology</a></p></li>
<li><p><a class="reference internal" href="#threads-and-dynamic-instances" id="id6">Threads and Dynamic Instances</a></p></li>
<li><p><a class="reference internal" href="#convergence" id="id7">Convergence</a></p>
<ul>
<li><p><a class="reference internal" href="#maximal-convergence" id="id8">Maximal Convergence</a></p></li>
<li><p><a class="reference internal" href="#dependence-on-cycles-headers" id="id9">Dependence on Cycles Headers</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#uniformity" id="id10">Uniformity</a></p>
<ul>
<li><p><a class="reference internal" href="#divergent-cycle-exits" id="id11">Divergent Cycle Exits</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#static-uniformity-analysis" id="id12">Static Uniformity Analysis</a></p>
<ul>
<li><p><a class="reference internal" href="#divergent-branch-inside-a-cycle" id="id13">Divergent Branch inside a Cycle</a></p></li>
<li><p><a class="reference internal" href="#diverged-paths-reaching-a-cycle" id="id14">Diverged Paths reaching a Cycle</a></p></li>
<li><p><a class="reference internal" href="#reducible-cycle" id="id15">Reducible Cycle</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#controlled-convergence" id="id16">Controlled Convergence</a></p></li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>In some environments, groups of threads execute the same program in parallel,
where efficient communication within a group is established using special
primitives called <a class="reference internal" href="ConvergentOperations.html#convergent-operations"><span class="std std-ref">convergent operations</span></a>. The
outcome of a convergent operation is sensitive to the set of threads that
participate in it.</p>
<p>The intuitive picture of <em>convergence</em> is built around threads executing in
“lock step” — a set of threads is thought of as <em>converged</em> if they are all
executing “the same sequence of instructions together”. Such threads may
<em>diverge</em> at a <em>divergent branch</em>, and they may later <em>reconverge</em> at some
common program point.</p>
<p>In this intuitive picture, when converged threads execute an instruction, the
resulting value is said to be <em>uniform</em> if it is the same in those threads, and
<em>divergent</em> otherwise. Correspondingly, a branch is said to be a uniform branch
if its condition is uniform, and it is a divergent branch otherwise.</p>
<p>But the assumption of lock-step execution is not necessary for describing
communication at convergent operations. It also constrains the implementation
(compiler as well as hardware) by overspecifying how threads execute in such a
parallel environment. To eliminate this assumption:</p>
<ul class="simple">
<li><p>We define convergence as a relation between the execution of each instruction
by different threads and not as a relation between the threads themselves.
This definition is reasonable for known targets and is compatible with the
semantics of <a class="reference internal" href="ConvergentOperations.html#convergent-operations"><span class="std std-ref">convergent operations</span></a> in LLVM IR.</p></li>
<li><p>We also define uniformity in terms of this convergence. The output of an
instruction can be examined for uniformity across multiple threads only if the
corresponding executions of that instruction are converged.</p></li>
</ul>
<p>This document describes a static analysis for determining convergence at each
instruction in a function. The analysis extends previous work on divergence
analysis <a class="reference internal" href="#divergencespmd" id="id2"><span>[DivergenceSPMD]</span></a> to cover irreducible control-flow. The described
analysis is used in LLVM to implement a UniformityAnalysis that determines the
uniformity of value(s) computed at each instruction in an LLVM IR or MIR
function.</p>
<div role="list" class="citation-list">
<div class="citation" id="divergencespmd" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">DivergenceSPMD</a><span class="fn-bracket">]</span></span>
<p>Julian Rosemann, Simon Moll, and Sebastian
Hack. 2021. An Abstract Interpretation for SPMD Divergence on
Reducible Control Flow Graphs. Proc. ACM Program. Lang. 5, POPL,
Article 31 (January 2021), 35 pages.
<a class="reference external" href="https://doi.org/10.1145/3434312">https://doi.org/10.1145/3434312</a></p>
</div>
</div>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">Motivation</a><a class="headerlink" href="#motivation" title="Link to this heading">¶</a></h2>
<p>Divergent branches constrain
program transforms such as changing the CFG or moving a convergent
operation to a different point of the CFG. Performing these
transformations across a divergent branch can change the sets of
threads that execute convergent operations convergently. While these
constraints are out of scope for this document,
uniformity analysis allows these transformations to identify
uniform branches where these constraints do not hold.</p>
<p>Uniformity is also useful by itself on targets that execute threads in
groups with shared execution resources (e.g. waves, warps, or
subgroups):</p>
<ul class="simple">
<li><p>Uniform outputs can potentially be computed or stored on shared
resources.</p></li>
<li><p>These targets must “linearize” a divergent branch to ensure that
each side of the branch is followed by the corresponding threads in
the same group. But linearization is unnecessary at uniform
branches, since the whole group of threads follows either one side
of the branch or the other.</p></li>
</ul>
</section>
<section id="terminology">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">Terminology</a><a class="headerlink" href="#terminology" title="Link to this heading">¶</a></h2>
<dl class="simple">
<dt>Cycles</dt><dd><p>Described in <a class="reference internal" href="CycleTerminology.html#cycle-terminology"><span class="std std-ref">LLVM Cycle Terminology</span></a>.</p>
</dd>
<dt>Closed path</dt><dd><p>Described in <a class="reference internal" href="CycleTerminology.html#cycle-closed-path"><span class="std std-ref">Closed Paths and Cycles</span></a>.</p>
</dd>
<dt>Disjoint paths</dt><dd><p>Two paths in a CFG are said to be disjoint if the only nodes common
to both are the start node or the end node, or both.</p>
</dd>
<dt>Join node</dt><dd><p>A join node of a branch is a node reachable along disjoint paths
starting from that branch.</p>
</dd>
<dt>Diverged path</dt><dd><p>A diverged path is a path that starts from a divergent branch and
either reaches a join node of the branch or reaches the end of the
function without passing through any join node of the branch.</p>
</dd>
</dl>
</section>
<section id="threads-and-dynamic-instances">
<span id="convergence-dynamic-instances"></span><h2><a class="toc-backref" href="#id6" role="doc-backlink">Threads and Dynamic Instances</a><a class="headerlink" href="#threads-and-dynamic-instances" title="Link to this heading">¶</a></h2>
<p>Each occurrence of an instruction in the program source is called a
<em>static instance</em>. When a thread executes a program, each execution of
a static instance produces a distinct <em>dynamic instance</em> of that
instruction.</p>
<p>Each thread produces a unique sequence of dynamic instances:</p>
<ul class="simple">
<li><p>The sequence is generated along branch decisions and loop
traversals.</p></li>
<li><p>Starts with a dynamic instance of a “first” instruction.</p></li>
<li><p>Continues with dynamic instances of successive “next”
instructions.</p></li>
</ul>
<p>Threads are independent; some targets may choose to execute them in
groups in order to share resources when possible.</p>
<figure class="align-default" id="convergence-natural-loop">
<img alt="_images/convergence-natural-loop.png" src="_images/convergence-natural-loop.png" />
</figure>
<table class="docutils align-left" id="convergence-thread-example">
<tbody>
<tr class="row-odd"><td></td>
<td></td>
<td><p>1</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>4</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
<td><p>9</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Thread 1</p></td>
<td><p>Entry1</p></td>
<td><p>H1</p></td>
<td><p>B1</p></td>
<td><p>L1</p></td>
<td><p>H3</p></td>
<td></td>
<td><p>L3</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Exit</p></td>
</tr>
<tr class="row-odd"><td><p>Thread 2</p></td>
<td><p>Entry1</p></td>
<td><p>H2</p></td>
<td></td>
<td><p>L2</p></td>
<td><p>H4</p></td>
<td><p>B2</p></td>
<td><p>L4</p></td>
<td><p>H5</p></td>
<td><p>B3</p></td>
<td><p>L5</p></td>
<td><p>Exit</p></td>
</tr>
</tbody>
</table>
<p>In the above table, each row is a different thread, listing the
dynamic instances produced by that thread from left to right. Each
thread executes the same program that starts with an <code class="docutils literal notranslate"><span class="pre">Entry</span></code> node
and ends with an <code class="docutils literal notranslate"><span class="pre">Exit</span></code> node, but different threads may take
different paths through the control flow of the program. The columns
are numbered merely for convenience, and empty cells have no special
meaning. Dynamic instances listed in the same column are converged.</p>
</section>
<section id="convergence">
<span id="convergence-definition"></span><h2><a class="toc-backref" href="#id7" role="doc-backlink">Convergence</a><a class="headerlink" href="#convergence" title="Link to this heading">¶</a></h2>
<p><em>Convergence-before</em> is a strict partial order over dynamic instances
that is defined as the transitive closure of:</p>
<ol class="arabic simple">
<li><p>If dynamic instance <code class="docutils literal notranslate"><span class="pre">P</span></code> is executed strictly before <code class="docutils literal notranslate"><span class="pre">Q</span></code> in the
same thread, then <code class="docutils literal notranslate"><span class="pre">P</span></code> is <em>convergence-before</em> <code class="docutils literal notranslate"><span class="pre">Q</span></code>.</p></li>
<li><p>If dynamic instance <code class="docutils literal notranslate"><span class="pre">P</span></code> is executed strictly before <code class="docutils literal notranslate"><span class="pre">Q1</span></code> in the
same thread, and <code class="docutils literal notranslate"><span class="pre">Q1</span></code> is <em>converged-with</em> <code class="docutils literal notranslate"><span class="pre">Q2</span></code>, then <code class="docutils literal notranslate"><span class="pre">P</span></code> is
<em>convergence-before</em> <code class="docutils literal notranslate"><span class="pre">Q2</span></code>.</p></li>
<li><p>If dynamic instance <code class="docutils literal notranslate"><span class="pre">P1</span></code> is <em>converged-with</em> <code class="docutils literal notranslate"><span class="pre">P2</span></code>, and <code class="docutils literal notranslate"><span class="pre">P2</span></code>
is executed strictly before <code class="docutils literal notranslate"><span class="pre">Q</span></code> in the same thread, then <code class="docutils literal notranslate"><span class="pre">P1</span></code>
is <em>convergence-before</em> <code class="docutils literal notranslate"><span class="pre">Q</span></code>.</p></li>
</ol>
<table class="docutils align-left" id="convergence-order-example">
<tbody>
<tr class="row-odd"><td></td>
<td><p>1</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>4</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
<td><p>9</p></td>
</tr>
<tr class="row-even"><td><p>Thread 1</p></td>
<td><p>Entry</p></td>
<td><p>…</p></td>
<td></td>
<td></td>
<td></td>
<td><p>S2</p></td>
<td><p>T</p></td>
<td><p>…</p></td>
<td><p>Exit</p></td>
</tr>
<tr class="row-odd"><td><p>Thread 2</p></td>
<td><p>Entry</p></td>
<td><p>…</p></td>
<td></td>
<td><p>Q2</p></td>
<td><p>R</p></td>
<td><p>S1</p></td>
<td></td>
<td><p>…</p></td>
<td><p>Exit</p></td>
</tr>
<tr class="row-even"><td><p>Thread 3</p></td>
<td><p>Entry</p></td>
<td><p>…</p></td>
<td><p>P</p></td>
<td><p>Q1</p></td>
<td></td>
<td></td>
<td></td>
<td><p>…</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>The above table shows partial sequences of dynamic instances from
different threads. Dynamic instances in the same column are assumed
to be converged (i.e., related to each other in the converged-with
relation). The resulting convergence order includes the edges <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">-&gt;</span>
<span class="pre">Q2</span></code>, <code class="docutils literal notranslate"><span class="pre">Q1</span> <span class="pre">-&gt;</span> <span class="pre">R</span></code>, <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">-&gt;</span> <span class="pre">R</span></code>, <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">-&gt;</span> <span class="pre">T</span></code>, etc.</p>
<p><em>Converged-with</em> is a transitive symmetric relation over dynamic instances
produced by <em>different threads</em> for the <em>same static instance</em>.</p>
<p>It is impractical to provide any one definition for the <em>converged-with</em>
relation, since different environments may wish to relate dynamic instances in
different ways. The fact that <em>convergence-before</em> is a strict partial order is
a constraint on the <em>converged-with</em> relation. It is trivially satisfied if
different dynamic instances are never converged. Below, we provide a relation
called <a class="reference internal" href="#convergence-maximal"><span class="std std-ref">maximal converged-with</span></a>, which satisifies
<em>convergence-before</em> and is suitable for known targets.</p>
<div class="admonition note" id="convergence-note-convergence">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>The convergence-before relation is not
directly observable. Program transforms are in general free to
change the order of instructions, even though that obviously
changes the convergence-before relation.</p></li>
<li><p>Converged dynamic instances need not be executed at the same
time or even on the same resource. Converged dynamic instances
of a convergent operation may appear to do so but that is an
implementation detail.</p></li>
<li><p>The fact that <code class="docutils literal notranslate"><span class="pre">P</span></code> is convergence-before
<code class="docutils literal notranslate"><span class="pre">Q</span></code> does not automatically imply that <code class="docutils literal notranslate"><span class="pre">P</span></code> happens-before
<code class="docutils literal notranslate"><span class="pre">Q</span></code> in a memory model sense.</p></li>
</ol>
</div>
<section id="maximal-convergence">
<span id="convergence-maximal"></span><h3><a class="toc-backref" href="#id8" role="doc-backlink">Maximal Convergence</a><a class="headerlink" href="#maximal-convergence" title="Link to this heading">¶</a></h3>
<p>This section defines a constraint that may be used to
produce a <em>maximal converged-with</em> relation without violating the
strict <em>convergence-before</em> order. This maximal converged-with
relation is reasonable for real targets and is compatible with
convergent operations.</p>
<p>The maximal converged-with relation is defined in terms of cycle
headers, with the assumption that threads converge at the header on every
“iteration” of the cycle. Informally, two threads execute the same iteration of
a cycle if they both previously executed the cycle header the same number of
times after they entered that cycle. In general, this needs to account for the
iterations of parent cycles as well.</p>
<blockquote>
<div><p><strong>Maximal converged-with:</strong></p>
<p>Dynamic instances <code class="docutils literal notranslate"><span class="pre">X1</span></code> and <code class="docutils literal notranslate"><span class="pre">X2</span></code> produced by different threads
for the same static instance <code class="docutils literal notranslate"><span class="pre">X</span></code> are converged in the maximal
converged-with relation if and only if:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">X</span></code> is not contained in any cycle, or,</p></li>
<li><p>For every cycle <code class="docutils literal notranslate"><span class="pre">C</span></code> with header <code class="docutils literal notranslate"><span class="pre">H</span></code> that contains <code class="docutils literal notranslate"><span class="pre">X</span></code>:</p>
<ul>
<li><p>every dynamic instance <code class="docutils literal notranslate"><span class="pre">H1</span></code> of <code class="docutils literal notranslate"><span class="pre">H</span></code> that precedes <code class="docutils literal notranslate"><span class="pre">X1</span></code> in
the respective thread is convergence-before <code class="docutils literal notranslate"><span class="pre">X2</span></code>, and,</p></li>
<li><p>every dynamic instance <code class="docutils literal notranslate"><span class="pre">H2</span></code> of <code class="docutils literal notranslate"><span class="pre">H</span></code> that precedes <code class="docutils literal notranslate"><span class="pre">X2</span></code> in
the respective thread is convergence-before <code class="docutils literal notranslate"><span class="pre">X1</span></code>,</p></li>
<li><p>without assuming that <code class="docutils literal notranslate"><span class="pre">X1</span></code> is converged with <code class="docutils literal notranslate"><span class="pre">X2</span></code>.</p></li>
</ul>
</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Cycle headers may not be unique to a given CFG if it is irreducible. Each
cycle hierarchy for the same CFG results in a different maximal
converged-with relation.</p>
<p>For brevity, the rest of the document restricts the term
<em>converged</em> to mean “related under the maximal converged-with
relation for the given cycle hierarchy”.</p>
</div>
<p>Maximal convergence can now be demonstrated in the earlier example as follows:</p>
<table class="docutils align-left">
<tbody>
<tr class="row-odd"><td></td>
<td></td>
<td><p>1</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>4</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
<td><p>9</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Thread 1</p></td>
<td><p>Entry1</p></td>
<td><p>H1</p></td>
<td><p>B1</p></td>
<td><p>L1</p></td>
<td><p>H3</p></td>
<td></td>
<td><p>L3</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Exit</p></td>
</tr>
<tr class="row-odd"><td><p>Thread 2</p></td>
<td><p>Entry2</p></td>
<td><p>H2</p></td>
<td></td>
<td><p>L2</p></td>
<td><p>H4</p></td>
<td><p>B2</p></td>
<td><p>L4</p></td>
<td><p>H5</p></td>
<td><p>B3</p></td>
<td><p>L5</p></td>
<td><p>Exit</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Entry1</span></code> and <code class="docutils literal notranslate"><span class="pre">Entry2</span></code> are converged.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">H1</span></code> and <code class="docutils literal notranslate"><span class="pre">H2</span></code> are converged.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">B1</span></code> and <code class="docutils literal notranslate"><span class="pre">B2</span></code> are not converged due to <code class="docutils literal notranslate"><span class="pre">H4</span></code> which is not
convergence-before <code class="docutils literal notranslate"><span class="pre">B1</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">H3</span></code> and <code class="docutils literal notranslate"><span class="pre">H4</span></code> are converged.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">H3</span></code> is not converged with <code class="docutils literal notranslate"><span class="pre">H5</span></code> due to <code class="docutils literal notranslate"><span class="pre">H4</span></code> which is not
convergence-before <code class="docutils literal notranslate"><span class="pre">H3</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">L1</span></code> and <code class="docutils literal notranslate"><span class="pre">L2</span></code> are converged.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">L3</span></code> and <code class="docutils literal notranslate"><span class="pre">L4</span></code> are converged.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">L3</span></code> is not converged with <code class="docutils literal notranslate"><span class="pre">L5</span></code> due to <code class="docutils literal notranslate"><span class="pre">H5</span></code> which is not
convergence-before <code class="docutils literal notranslate"><span class="pre">L3</span></code>.</p></li>
</ul>
</section>
<section id="dependence-on-cycles-headers">
<span id="convergence-cycle-headers"></span><h3><a class="toc-backref" href="#id9" role="doc-backlink">Dependence on Cycles Headers</a><a class="headerlink" href="#dependence-on-cycles-headers" title="Link to this heading">¶</a></h3>
<p>Contradictions in <em>convergence-before</em> are possible only between two
nodes that are inside some cycle. The dynamic instances of such nodes
may be interleaved in the same thread, and this interleaving may be
different for different threads. Cycle headers serve as implicit
<em>points of convergence</em> in the maximal converged-with relation.
When a thread executes a node <code class="docutils literal notranslate"><span class="pre">X</span></code> once and then executes it again,
it must have followed a closed path in the CFG that includes <code class="docutils literal notranslate"><span class="pre">X</span></code>.
Such a path must pass through the header of at least one cycle — the
smallest cycle that includes the entire closed path. In a given
thread, two dynamic instances of <code class="docutils literal notranslate"><span class="pre">X</span></code> are either separated by the
execution of at least one cycle header, or <code class="docutils literal notranslate"><span class="pre">X</span></code> itself is a cycle
header.</p>
<p>Consider a sequence of nested cycles <code class="docutils literal notranslate"><span class="pre">C1</span></code>, <code class="docutils literal notranslate"><span class="pre">C2</span></code>, …, <code class="docutils literal notranslate"><span class="pre">Ck</span></code> such
that <code class="docutils literal notranslate"><span class="pre">C1</span></code> is the outermost cycle and <code class="docutils literal notranslate"><span class="pre">Ck</span></code> is the innermost cycle,
with headers <code class="docutils literal notranslate"><span class="pre">H1</span></code>, <code class="docutils literal notranslate"><span class="pre">H2</span></code>, …, <code class="docutils literal notranslate"><span class="pre">Hk</span></code> respectively. When a thread
enters the cycle <code class="docutils literal notranslate"><span class="pre">Ck</span></code>, any of the following is possible:</p>
<ol class="arabic simple">
<li><p>The thread directly entered cycle <code class="docutils literal notranslate"><span class="pre">Ck</span></code> without having executed
any of the headers <code class="docutils literal notranslate"><span class="pre">H1</span></code> to <code class="docutils literal notranslate"><span class="pre">Hk</span></code>.</p></li>
<li><p>The thread executed some or all of the nested headers one or more
times.</p></li>
</ol>
<p>The maximal converged-with relation captures the following intuition
about cycles:</p>
<ol class="arabic">
<li><p>When two threads enter a top-level cycle <code class="docutils literal notranslate"><span class="pre">C1</span></code>, they execute
converged dynamic instances of every node that is a <a class="reference internal" href="CycleTerminology.html#cycle-parent-block"><span class="std std-ref">child</span></a> of <code class="docutils literal notranslate"><span class="pre">C1</span></code>.</p></li>
<li><p>When two threads enter a nested cycle <code class="docutils literal notranslate"><span class="pre">Ck</span></code>, they execute
converged dynamic instances of every node that is a child of
<code class="docutils literal notranslate"><span class="pre">Ck</span></code>, until either thread exits <code class="docutils literal notranslate"><span class="pre">Ck</span></code>, if and only if they
executed converged dynamic instances of the last nested header that
either thread encountered.</p>
<p>Note that when a thread exits a nested cycle <code class="docutils literal notranslate"><span class="pre">Ck</span></code>, it must follow
a closed path outside <code class="docutils literal notranslate"><span class="pre">Ck</span></code> to reenter it. This requires executing
the header of some outer cycle, as described earlier.</p>
</li>
</ol>
<p>Consider two dynamic instances <code class="docutils literal notranslate"><span class="pre">X1</span></code> and <code class="docutils literal notranslate"><span class="pre">X2</span></code> produced by threads <code class="docutils literal notranslate"><span class="pre">T1</span></code>
and <code class="docutils literal notranslate"><span class="pre">T2</span></code> for a node <code class="docutils literal notranslate"><span class="pre">X</span></code> that is a child of nested cycle <code class="docutils literal notranslate"><span class="pre">Ck</span></code>.
Maximal convergence relates <code class="docutils literal notranslate"><span class="pre">X1</span></code> and <code class="docutils literal notranslate"><span class="pre">X2</span></code> as follows:</p>
<ol class="arabic simple">
<li><p>If neither thread executed any header from <code class="docutils literal notranslate"><span class="pre">H1</span></code> to <code class="docutils literal notranslate"><span class="pre">Hk</span></code>, then
<code class="docutils literal notranslate"><span class="pre">X1</span></code> and <code class="docutils literal notranslate"><span class="pre">X2</span></code> are converged.</p></li>
<li><p>Otherwise, if there are no converged dynamic instances <code class="docutils literal notranslate"><span class="pre">Q1</span></code> and
<code class="docutils literal notranslate"><span class="pre">Q2</span></code> of any header <code class="docutils literal notranslate"><span class="pre">Q</span></code> from <code class="docutils literal notranslate"><span class="pre">H1</span></code> to <code class="docutils literal notranslate"><span class="pre">Hk</span></code> (where <code class="docutils literal notranslate"><span class="pre">Q</span></code> is
possibly the same as <code class="docutils literal notranslate"><span class="pre">X</span></code>), such that <code class="docutils literal notranslate"><span class="pre">Q1</span></code> precedes <code class="docutils literal notranslate"><span class="pre">X1</span></code> and
<code class="docutils literal notranslate"><span class="pre">Q2</span></code> precedes <code class="docutils literal notranslate"><span class="pre">X2</span></code> in the respective threads, then <code class="docutils literal notranslate"><span class="pre">X1</span></code> and
<code class="docutils literal notranslate"><span class="pre">X2</span></code> are not converged.</p></li>
<li><p>Otherwise, consider the pair <code class="docutils literal notranslate"><span class="pre">Q1</span></code> and <code class="docutils literal notranslate"><span class="pre">Q2</span></code> of converged dynamic
instances of a header <code class="docutils literal notranslate"><span class="pre">Q</span></code> from <code class="docutils literal notranslate"><span class="pre">H1</span></code> to <code class="docutils literal notranslate"><span class="pre">Hk</span></code> that occur most
recently before <code class="docutils literal notranslate"><span class="pre">X1</span></code> and <code class="docutils literal notranslate"><span class="pre">X2</span></code> in the respective threads. Then
<code class="docutils literal notranslate"><span class="pre">X1</span></code> and <code class="docutils literal notranslate"><span class="pre">X2</span></code> are converged if and only if there is no dynamic
instance of any header from <code class="docutils literal notranslate"><span class="pre">H1</span></code> to <code class="docutils literal notranslate"><span class="pre">Hk</span></code> that occurs between
<code class="docutils literal notranslate"><span class="pre">Q1</span></code> and <code class="docutils literal notranslate"><span class="pre">X1</span></code> in thread <code class="docutils literal notranslate"><span class="pre">T1</span></code>, or between <code class="docutils literal notranslate"><span class="pre">Q2</span></code> and <code class="docutils literal notranslate"><span class="pre">X2</span></code> in
thread <code class="docutils literal notranslate"><span class="pre">T2</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">Q1</span></code> and <code class="docutils literal notranslate"><span class="pre">Q2</span></code> represent the last
point of convergence, with no other header being executed before
executing <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p></li>
</ol>
<p><strong>Example:</strong></p>
<figure class="align-default" id="convergence-both-diverged-nested">
<img alt="_images/convergence-both-diverged-nested.png" src="_images/convergence-both-diverged-nested.png" />
</figure>
<p>The above figure shows two nested irreducible cycles with headers
<code class="docutils literal notranslate"><span class="pre">R</span></code> and <code class="docutils literal notranslate"><span class="pre">S</span></code>. The nodes <code class="docutils literal notranslate"><span class="pre">Entry</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code> have divergent
branches. The table below shows the convergence between three threads
taking different paths through the CFG. Dynamic instances listed in
the same column are converged.</p>
<blockquote>
<div><table class="docutils align-left">
<tbody>
<tr class="row-odd"><td></td>
<td><p>1</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>4</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
<td><p>10</p></td>
</tr>
<tr class="row-even"><td><p>Thread1</p></td>
<td><p>Entry</p></td>
<td><p>P1</p></td>
<td><p>Q1</p></td>
<td><p>S1</p></td>
<td><p>P3</p></td>
<td><p>Q3</p></td>
<td><p>R1</p></td>
<td><p>S2</p></td>
<td><p>Exit</p></td>
</tr>
<tr class="row-odd"><td><p>Thread2</p></td>
<td><p>Entry</p></td>
<td><p>P2</p></td>
<td><p>Q2</p></td>
<td></td>
<td></td>
<td></td>
<td><p>R2</p></td>
<td><p>S3</p></td>
<td><p>Exit</p></td>
</tr>
<tr class="row-even"><td><p>Thread3</p></td>
<td><p>Entry</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p>R3</p></td>
<td><p>S4</p></td>
<td><p>Exit</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">P2</span></code> and <code class="docutils literal notranslate"><span class="pre">P3</span></code> are not converged due to <code class="docutils literal notranslate"><span class="pre">S1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Q2</span></code> and <code class="docutils literal notranslate"><span class="pre">Q3</span></code> are not converged due to <code class="docutils literal notranslate"><span class="pre">S1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">S1</span></code> and <code class="docutils literal notranslate"><span class="pre">S3</span></code> are not converged due to <code class="docutils literal notranslate"><span class="pre">R2</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">S1</span></code> and <code class="docutils literal notranslate"><span class="pre">S4</span></code> are not converged due to <code class="docutils literal notranslate"><span class="pre">R3</span></code></p></li>
</ul>
<p>Informally, <code class="docutils literal notranslate"><span class="pre">T1</span></code> and <code class="docutils literal notranslate"><span class="pre">T2</span></code> execute the inner cycle a different
number of times, without executing the header of the outer cycle. All
threads converge in the outer cycle when they first execute the header
of the outer cycle.</p>
</section>
</section>
<section id="uniformity">
<span id="convergence-uniformity"></span><h2><a class="toc-backref" href="#id10" role="doc-backlink">Uniformity</a><a class="headerlink" href="#uniformity" title="Link to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p>The output of two converged dynamic instances is uniform if and
only if it compares equal for those two dynamic instances.</p></li>
<li><p>The output of a static instance <code class="docutils literal notranslate"><span class="pre">X</span></code> is uniform <em>for a given set
of threads</em> if and only if it is uniform for every pair of
converged dynamic instances of <code class="docutils literal notranslate"><span class="pre">X</span></code> produced by those threads.</p></li>
</ol>
<p>A non-uniform value is said to be <em>divergent</em>.</p>
<p>For a set <code class="docutils literal notranslate"><span class="pre">S</span></code> of threads, the uniformity of each output of a static
instance is determined as follows:</p>
<ol class="arabic simple">
<li><p>The semantics of the instruction may specify the output to be
uniform.</p></li>
<li><p>Otherwise, the output is divergent if the static instance is not
<a class="reference internal" href="#convergence-m-converged"><span class="std std-ref">m-converged</span></a>.</p></li>
<li><p>Otherwise, if the static instance is m-converged:</p>
<ol class="arabic simple">
<li><p>If it is a PHI node, its output is uniform if and only
if for every pair of converged dynamic instances produced by all
threads in <code class="docutils literal notranslate"><span class="pre">S</span></code>:</p>
<ol class="loweralpha simple">
<li><p>Both instances choose the same output from converged
dynamic instances, and,</p></li>
<li><p>That output is uniform for all threads in <code class="docutils literal notranslate"><span class="pre">S</span></code>.</p></li>
</ol>
</li>
<li><p>Otherwise, the output is uniform if and only if the input
operands are uniform for all threads in <code class="docutils literal notranslate"><span class="pre">S</span></code>.</p></li>
</ol>
</li>
</ol>
<section id="divergent-cycle-exits">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Divergent Cycle Exits</a><a class="headerlink" href="#divergent-cycle-exits" title="Link to this heading">¶</a></h3>
<p>When a divergent branch occurs inside a cycle, it is possible that a
diverged path continues to an exit of the cycle. This is called a
divergent cycle exit. If the cycle is irreducible, the diverged path
may re-enter and eventually reach a join within the cycle. Such a join
should be examined for the <a class="reference internal" href="#convergence-diverged-entry"><span class="std std-ref">diverged entry</span></a> criterion.</p>
<p>Nodes along the diverged path that lie outside the cycle experience
<em>temporal divergence</em>, when two threads executing convergently inside
the cycle produce uniform values, but exit the cycle along the same
divergent path after executing the header a different number of times
(informally, on different iterations of the cycle). For a node <code class="docutils literal notranslate"><span class="pre">N</span></code>
inside the cycle the outputs may be uniform for the two threads, but
any use <code class="docutils literal notranslate"><span class="pre">U</span></code> outside the cycle receives a value from non-converged
dynamic instances of <code class="docutils literal notranslate"><span class="pre">N</span></code>. An output of <code class="docutils literal notranslate"><span class="pre">U</span></code> may be divergent,
depending on the semantics of the instruction.</p>
</section>
</section>
<section id="static-uniformity-analysis">
<span id="uniformity-analysis"></span><h2><a class="toc-backref" href="#id12" role="doc-backlink">Static Uniformity Analysis</a><a class="headerlink" href="#static-uniformity-analysis" title="Link to this heading">¶</a></h2>
<p>Irreducible control flow results in different cycle hierarchies
depending on the choice of headers during depth-first traversal. As a
result, a static analysis cannot always determine the convergence of
nodes in irreducible cycles, and any uniformity analysis is limited to
those static instances whose convergence is independent of the cycle
hierarchy:</p>
<blockquote id="convergence-m-converged">
<div><p><strong>m-converged static instances:</strong></p>
<p>A static instance <code class="docutils literal notranslate"><span class="pre">X</span></code> is <em>m-converged</em> for a given CFG if and only
if the maximal converged-with relation for its dynamic instances is
the same in every cycle hierarchy that can be constructed for that CFG.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In other words, two dynamic instances <code class="docutils literal notranslate"><span class="pre">X1</span></code> and <code class="docutils literal notranslate"><span class="pre">X2</span></code> of an
m-converged static instance <code class="docutils literal notranslate"><span class="pre">X</span></code> are converged in some cycle
hierarchy if and only if they are also converged in every other
cycle hierarchy for the same CFG.</p>
<p>As noted earlier, for brevity, we restrict the term <em>converged</em> to
mean “related under the maximal converged-with relation for a given
cycle hierarchy”.</p>
</div>
</div></blockquote>
<p>Each node <code class="docutils literal notranslate"><span class="pre">X</span></code> in a given CFG is reported to be m-converged if and
only if every cycle that contains <code class="docutils literal notranslate"><span class="pre">X</span></code> satisfies the following necessary
conditions:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Every divergent branch inside the cycle satisfies the
<a class="reference internal" href="#convergence-diverged-entry"><span class="std std-ref">diverged entry criterion</span></a>, and,</p></li>
<li><p>There are no <a class="reference internal" href="#convergence-diverged-outside"><span class="std std-ref">diverged paths reaching the
cycle</span></a> from a divergent branch
outside it.</p></li>
</ol>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A reducible cycle <a class="reference internal" href="#convergence-reducible-cycle"><span class="std std-ref">trivially satisfies</span></a> the above conditions. In particular,
if the whole CFG is reducible, then all nodes in the CFG are
m-converged.</p>
</div>
<p>The uniformity of each output of a static instance
is determined using the criteria
<a class="reference internal" href="#convergence-uniformity"><span class="std std-ref">described earlier</span></a>. The discovery of
divergent outputs may cause their uses (including branches) to also
become divergent. The analysis propagates this divergence until a
fixed point is reached.</p>
<p>The convergence inferred using these criteria is a safe subset of the
maximal converged-with relation for any cycle hierarchy. In
particular, it is sufficient to determine if a static instance is
m-converged for a given cycle hierarchy <code class="docutils literal notranslate"><span class="pre">T</span></code>, even if that fact is
not detected when examining some other cycle hierarchy <code class="docutils literal notranslate"><span class="pre">T'</span></code>.</p>
<p>This property allows compiler transforms to use the uniformity
analysis without being affected by DFS choices made in the underlying
cycle analysis. When two transforms use different instances of the
uniformity analysis for the same CFG, a “divergent value” result in
one analysis instance cannot contradict a “uniform value” result in
the other.</p>
<p>Generic transforms such as SimplifyCFG, CSE, and loop transforms
commonly change the program in ways that change the maximal
converged-with relations. This also means that a value that was
previously uniform can become divergent after such a transform.
Uniformity has to be recomputed after such transforms.</p>
<section id="divergent-branch-inside-a-cycle">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Divergent Branch inside a Cycle</a><a class="headerlink" href="#divergent-branch-inside-a-cycle" title="Link to this heading">¶</a></h3>
<figure class="align-default" id="convergence-divergent-inside">
<img alt="_images/convergence-divergent-inside.png" src="_images/convergence-divergent-inside.png" />
</figure>
<p>The above figure shows a divergent branch <code class="docutils literal notranslate"><span class="pre">Q</span></code> inside an irreducible
cyclic region. When two threads diverge at <code class="docutils literal notranslate"><span class="pre">Q</span></code>, the convergence of
dynamic instances within the cyclic region depends on the cycle
hierarchy chosen:</p>
<ol class="arabic simple">
<li><p>In an implementation that detects a single cycle <code class="docutils literal notranslate"><span class="pre">C</span></code> with header
<code class="docutils literal notranslate"><span class="pre">P</span></code>, convergence inside the cycle is determined by <code class="docutils literal notranslate"><span class="pre">P</span></code>.</p></li>
<li><p>In an implementation that detects two nested cycles with headers
<code class="docutils literal notranslate"><span class="pre">R</span></code> and <code class="docutils literal notranslate"><span class="pre">S</span></code>, convergence inside those cycles is determined by
their respective headers.</p></li>
</ol>
<p id="convergence-diverged-entry">A conservative approach would be to simply report all nodes inside
irreducible cycles as having divergent outputs. But it is desirable to
recognize m-converged nodes in the CFG in order to maximize
uniformity. This section describes one such pattern of nodes derived
from <em>closed paths</em>, which are a property of the CFG and do not depend
on the cycle hierarchy.</p>
<blockquote>
<div><p><strong>Diverged Entry Criterion:</strong></p>
<p>The dynamic instances of all the nodes in a closed path <code class="docutils literal notranslate"><span class="pre">P</span></code> are
m-converged only if for every divergent branch <code class="docutils literal notranslate"><span class="pre">B</span></code> and its
join node <code class="docutils literal notranslate"><span class="pre">J</span></code> that lie on <code class="docutils literal notranslate"><span class="pre">P</span></code>, there is no entry to <code class="docutils literal notranslate"><span class="pre">P</span></code> which
lies on a diverged path from <code class="docutils literal notranslate"><span class="pre">B</span></code> to <code class="docutils literal notranslate"><span class="pre">J</span></code>.</p>
</div></blockquote>
<figure class="align-default" id="convergence-closed-path">
<img alt="_images/convergence-closed-path.png" src="_images/convergence-closed-path.png" />
</figure>
<p>Consider the closed path <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">-&gt;</span> <span class="pre">Q</span> <span class="pre">-&gt;</span> <span class="pre">R</span> <span class="pre">-&gt;</span> <span class="pre">S</span></code> in the above figure.
<code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">R</span></code> are <a class="reference internal" href="CycleTerminology.html#cycle-closed-path"><span class="std std-ref">entries to the closed
path</span></a>. <code class="docutils literal notranslate"><span class="pre">Q</span></code> is a divergent branch and <code class="docutils literal notranslate"><span class="pre">S</span></code> is a
join for that branch, with diverged paths <code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">-&gt;</span> <span class="pre">R</span> <span class="pre">-&gt;</span> <span class="pre">S</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">-&gt;</span>
<span class="pre">S</span></code>.</p>
<ul>
<li><p>If a diverged entry <code class="docutils literal notranslate"><span class="pre">R</span></code> exists, then in some cycle hierarchy,
<code class="docutils literal notranslate"><span class="pre">R</span></code> is the header of the smallest cycle <code class="docutils literal notranslate"><span class="pre">C</span></code> containing the
closed path and a <a class="reference internal" href="CycleTerminology.html#cycle-definition"><span class="std std-ref">child cycle</span></a> <code class="docutils literal notranslate"><span class="pre">C'</span></code>
exists in the set <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">-</span> <span class="pre">R</span></code>, containing both branch <code class="docutils literal notranslate"><span class="pre">Q</span></code> and join
<code class="docutils literal notranslate"><span class="pre">S</span></code>. When threads diverge at <code class="docutils literal notranslate"><span class="pre">Q</span></code>, one subset <code class="docutils literal notranslate"><span class="pre">M</span></code> continues
inside cycle <code class="docutils literal notranslate"><span class="pre">C'</span></code>, while the complement <code class="docutils literal notranslate"><span class="pre">N</span></code> exits <code class="docutils literal notranslate"><span class="pre">C'</span></code> and
reaches <code class="docutils literal notranslate"><span class="pre">R</span></code>. Dynamic instances of <code class="docutils literal notranslate"><span class="pre">S</span></code> executed by threads in set
<code class="docutils literal notranslate"><span class="pre">M</span></code> are not converged with those executed in set <code class="docutils literal notranslate"><span class="pre">N</span></code> due to the
presence of <code class="docutils literal notranslate"><span class="pre">R</span></code>. Informally, threads that diverge at <code class="docutils literal notranslate"><span class="pre">Q</span></code>
reconverge in the same iteration of the outer cycle <code class="docutils literal notranslate"><span class="pre">C</span></code>, but they
may have executed the inner cycle <code class="docutils literal notranslate"><span class="pre">C'</span></code> differently.</p>
<table class="docutils align-left">
<tbody>
<tr class="row-odd"><td></td>
<td><p>1</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>4</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
<td><p>9</p></td>
<td><p>10</p></td>
<td><p>11</p></td>
</tr>
<tr class="row-even"><td><p>Thread1</p></td>
<td><p>Entry</p></td>
<td><p>P1</p></td>
<td><p>Q1</p></td>
<td></td>
<td></td>
<td></td>
<td><p>R1</p></td>
<td><p>S1</p></td>
<td><p>P3</p></td>
<td><p>…</p></td>
<td><p>Exit</p></td>
</tr>
<tr class="row-odd"><td><p>Thread2</p></td>
<td><p>Entry</p></td>
<td><p>P2</p></td>
<td><p>Q2</p></td>
<td><p>S2</p></td>
<td><p>P4</p></td>
<td><p>Q4</p></td>
<td><p>R2</p></td>
<td><p>S4</p></td>
<td></td>
<td></td>
<td><p>Exit</p></td>
</tr>
</tbody>
</table>
<p>In the table above, <code class="docutils literal notranslate"><span class="pre">S2</span></code> is not converged with <code class="docutils literal notranslate"><span class="pre">S1</span></code> due to <code class="docutils literal notranslate"><span class="pre">R1</span></code>.</p>
</li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">R</span></code> does not exist, or if any node other than <code class="docutils literal notranslate"><span class="pre">R</span></code> is the
header of <code class="docutils literal notranslate"><span class="pre">C</span></code>, then no such child cycle <code class="docutils literal notranslate"><span class="pre">C'</span></code> is detected.
Threads that diverge at <code class="docutils literal notranslate"><span class="pre">Q</span></code> execute converged dynamic instances of
<code class="docutils literal notranslate"><span class="pre">S</span></code> since they do not encounter the cycle header on any path from
<code class="docutils literal notranslate"><span class="pre">Q</span></code> to <code class="docutils literal notranslate"><span class="pre">S</span></code>. Informally, threads that diverge at <code class="docutils literal notranslate"><span class="pre">Q</span></code>
reconverge at <code class="docutils literal notranslate"><span class="pre">S</span></code> in the same iteration of <code class="docutils literal notranslate"><span class="pre">C</span></code>.</p>
<table class="docutils align-left">
<tbody>
<tr class="row-odd"><td></td>
<td><p>1</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>4</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
<td><p>9</p></td>
<td><p>10</p></td>
</tr>
<tr class="row-even"><td><p>Thread1</p></td>
<td><p>Entry</p></td>
<td><p>P1</p></td>
<td><p>Q1</p></td>
<td><p>R1</p></td>
<td><p>S1</p></td>
<td><p>P3</p></td>
<td><p>Q3</p></td>
<td><p>R3</p></td>
<td><p>S3</p></td>
<td><p>Exit</p></td>
</tr>
<tr class="row-odd"><td><p>Thread2</p></td>
<td><p>Entry</p></td>
<td><p>P2</p></td>
<td><p>Q2</p></td>
<td></td>
<td><p>S2</p></td>
<td><p>P4</p></td>
<td><p>Q4</p></td>
<td><p>R2</p></td>
<td><p>S4</p></td>
<td><p>Exit</p></td>
</tr>
</tbody>
</table>
</li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>In general, the cycle <code class="docutils literal notranslate"><span class="pre">C</span></code> in the above statements is not
expected to be the same cycle for different headers. Cycles and
their headers are tightly coupled; for different headers in the
same outermost cycle, the child cycles detected may be different.
The property relevant to the above examples is that for every
closed path, there is a cycle <code class="docutils literal notranslate"><span class="pre">C</span></code> that contains the path and
whose header is on that path.</p>
</div>
</div></blockquote>
<p>The diverged entry criterion must be checked for every closed path
passing through a divergent branch <code class="docutils literal notranslate"><span class="pre">B</span></code> and its join <code class="docutils literal notranslate"><span class="pre">J</span></code>. Since
<a class="reference internal" href="CycleTerminology.html#cycle-closed-path-header"><span class="std std-ref">every closed path passes through the header of some
cycle</span></a>, this amounts to checking every cycle
<code class="docutils literal notranslate"><span class="pre">C</span></code> that contains <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">J</span></code>. When the header of <code class="docutils literal notranslate"><span class="pre">C</span></code>
dominates the join <code class="docutils literal notranslate"><span class="pre">J</span></code>, there can be no entry to any path from the
header to <code class="docutils literal notranslate"><span class="pre">J</span></code>, which includes any diverged path from <code class="docutils literal notranslate"><span class="pre">B</span></code> to <code class="docutils literal notranslate"><span class="pre">J</span></code>.
This is also true for any closed paths passing through the header of
an outer cycle that contains <code class="docutils literal notranslate"><span class="pre">C</span></code>.</p>
<p>Thus, the diverged entry criterion can be conservatively simplified
as follows:</p>
<blockquote>
<div><p>For a divergent branch <code class="docutils literal notranslate"><span class="pre">B</span></code> and its join node <code class="docutils literal notranslate"><span class="pre">J</span></code>, the nodes in a
cycle <code class="docutils literal notranslate"><span class="pre">C</span></code> that contains both <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">J</span></code> are m-converged only
if:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">B</span></code> strictly dominates <code class="docutils literal notranslate"><span class="pre">J</span></code>, or,</p></li>
<li><p>The header <code class="docutils literal notranslate"><span class="pre">H</span></code> of <code class="docutils literal notranslate"><span class="pre">C</span></code> strictly dominates <code class="docutils literal notranslate"><span class="pre">J</span></code>, or,</p></li>
<li><p>Recursively, there is cycle <code class="docutils literal notranslate"><span class="pre">C'</span></code> inside <code class="docutils literal notranslate"><span class="pre">C</span></code> that satisfies the
same condition.</p></li>
</ul>
</div></blockquote>
<p>When <code class="docutils literal notranslate"><span class="pre">J</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">H</span></code> or <code class="docutils literal notranslate"><span class="pre">B</span></code>, the trivial dominance is
insufficient to make any statement about entries to diverged paths.</p>
</section>
<section id="diverged-paths-reaching-a-cycle">
<span id="convergence-diverged-outside"></span><h3><a class="toc-backref" href="#id14" role="doc-backlink">Diverged Paths reaching a Cycle</a><a class="headerlink" href="#diverged-paths-reaching-a-cycle" title="Link to this heading">¶</a></h3>
<figure class="align-default" id="convergence-divergent-outside">
<img alt="_images/convergence-divergent-outside.png" src="_images/convergence-divergent-outside.png" />
</figure>
<p>The figure shows two cycle hierarchies with a divergent branch in
<code class="docutils literal notranslate"><span class="pre">Entry</span></code> instead of <code class="docutils literal notranslate"><span class="pre">Q</span></code>. For two threads that enter the closed path
<code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">-&gt;</span> <span class="pre">Q</span> <span class="pre">-&gt;</span> <span class="pre">R</span> <span class="pre">-&gt;</span> <span class="pre">S</span></code> at <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">R</span></code> respectively, the convergence
of dynamic instances generated along the path depends on whether <code class="docutils literal notranslate"><span class="pre">P</span></code>
or <code class="docutils literal notranslate"><span class="pre">R</span></code> is the header.</p>
<ul>
<li><p>Convergence when <code class="docutils literal notranslate"><span class="pre">P</span></code> is the header.</p>
<table class="docutils align-left">
<tbody>
<tr class="row-odd"><td></td>
<td><p>1</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>4</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
<td><p>9</p></td>
<td><p>10</p></td>
<td><p>11</p></td>
<td><p>12</p></td>
<td><p>13</p></td>
</tr>
<tr class="row-even"><td><p>Thread1</p></td>
<td><p>Entry</p></td>
<td></td>
<td></td>
<td></td>
<td><p>P1</p></td>
<td><p>Q1</p></td>
<td><p>R1</p></td>
<td><p>S1</p></td>
<td><p>P3</p></td>
<td><p>Q3</p></td>
<td></td>
<td><p>S3</p></td>
<td><p>Exit</p></td>
</tr>
<tr class="row-odd"><td><p>Thread2</p></td>
<td><p>Entry</p></td>
<td></td>
<td><p>R2</p></td>
<td><p>S2</p></td>
<td><p>P2</p></td>
<td><p>Q2</p></td>
<td></td>
<td><p>S2</p></td>
<td><p>P4</p></td>
<td><p>Q4</p></td>
<td><p>R3</p></td>
<td><p>S4</p></td>
<td><p>Exit</p></td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</li>
<li><p>Convergence when <code class="docutils literal notranslate"><span class="pre">R</span></code> is the header.</p>
<table class="docutils align-left">
<tbody>
<tr class="row-odd"><td></td>
<td><p>1</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>4</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
<td><p>9</p></td>
<td><p>10</p></td>
<td><p>11</p></td>
<td><p>12</p></td>
</tr>
<tr class="row-even"><td><p>Thread1</p></td>
<td><p>Entry</p></td>
<td></td>
<td><p>P1</p></td>
<td><p>Q1</p></td>
<td><p>R1</p></td>
<td><p>S1</p></td>
<td><p>P3</p></td>
<td><p>Q3</p></td>
<td><p>S3</p></td>
<td></td>
<td></td>
<td><p>Exit</p></td>
</tr>
<tr class="row-odd"><td><p>Thread2</p></td>
<td><p>Entry</p></td>
<td></td>
<td></td>
<td></td>
<td><p>R2</p></td>
<td><p>S2</p></td>
<td><p>P2</p></td>
<td><p>Q2</p></td>
<td><p>S2</p></td>
<td><p>P4</p></td>
<td><p>…</p></td>
<td><p>Exit</p></td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</li>
</ul>
<p>Thus, when diverged paths reach different entries of an irreducible
cycle from outside the cycle, the static analysis conservatively
reports every node in the cycle as not m-converged.</p>
</section>
<section id="reducible-cycle">
<span id="convergence-reducible-cycle"></span><h3><a class="toc-backref" href="#id15" role="doc-backlink">Reducible Cycle</a><a class="headerlink" href="#reducible-cycle" title="Link to this heading">¶</a></h3>
<p>If <code class="docutils literal notranslate"><span class="pre">C</span></code> is a reducible cycle with header <code class="docutils literal notranslate"><span class="pre">H</span></code>, then in any DFS,
<code class="docutils literal notranslate"><span class="pre">H</span></code> <a class="reference internal" href="CycleTerminology.html#cycle-reducible-headers"><span class="std std-ref">must be the header of some cycle</span></a>
<code class="docutils literal notranslate"><span class="pre">C'</span></code> that contains <code class="docutils literal notranslate"><span class="pre">C</span></code>. Independent of the DFS, there is no entry
to the subgraph <code class="docutils literal notranslate"><span class="pre">C</span></code> other than <code class="docutils literal notranslate"><span class="pre">H</span></code> itself. Thus, we have the
following:</p>
<ol class="arabic simple">
<li><p>The diverged entry criterion is trivially satisfied for a divergent
branch and its join, where both are inside subgraph <code class="docutils literal notranslate"><span class="pre">C</span></code>.</p></li>
<li><p>When diverged paths reach the subgraph <code class="docutils literal notranslate"><span class="pre">C</span></code> from outside, their
convergence is always determined by the same header <code class="docutils literal notranslate"><span class="pre">H</span></code>.</p></li>
</ol>
<p>Clearly, this can be determined only in a cycle hierarchy <code class="docutils literal notranslate"><span class="pre">T</span></code> where
<code class="docutils literal notranslate"><span class="pre">C</span></code> is detected as a reducible cycle. No such conclusion can be made
in a different cycle hierarchy <code class="docutils literal notranslate"><span class="pre">T'</span></code> where <code class="docutils literal notranslate"><span class="pre">C</span></code> is part of a larger
cycle <code class="docutils literal notranslate"><span class="pre">C'</span></code> with the same header, but this does not contradict the
conclusion in <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
</section>
</section>
<section id="controlled-convergence">
<h2><a class="toc-backref" href="#id16" role="doc-backlink">Controlled Convergence</a><a class="headerlink" href="#controlled-convergence" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="ConvergentOperations.html#dynamic-instances-and-convergence-tokens"><span class="std std-ref">Convergence control tokens</span></a>
provide an explicit semantics for determining which threads are converged at a
given point in the program. The impact of this is incorporated in a
<a class="reference internal" href="ConvergentOperations.html#controlled-maximal-converged-with"><span class="std std-ref">controlled maximal converged-with</span></a>
relation over dynamic instances and a <a class="reference internal" href="ConvergentOperations.html#controlled-m-converged"><span class="std std-ref">controlled m-converged</span></a> property of static instances. The <a class="reference internal" href="#uniformity-analysis"><span class="std std-ref">uniformity
analysis</span></a> implemented in LLVM includes this for targets
that support convergence control tokens.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="ConvergentOperations.html" title="Convergent Operation Semantics"
             >next</a> |</li>
        <li class="right" >
          <a href="CommandGuide/llvm-remarkutil.html" title="llvm-remarkutil - Remark utility"
             >previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="Reference.html" >Reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Convergence And Uniformity</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2003-2025, LLVM Project.
      Last updated on 2025-08-26.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>