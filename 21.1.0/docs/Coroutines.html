
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Coroutines in LLVM &#8212; LLVM 21.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/llvm-theme.css?v=96924833" />
    <script src="_static/documentation_options.js?v=c54a4614"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Dependence Graphs in LLVM" href="DependenceGraphs/index.html" />
    <link rel="prev" title="Convergent Operation Semantics" href="ConvergentOperations.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="DependenceGraphs/index.html" title="Dependence Graphs in LLVM"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="ConvergentOperations.html" title="Convergent Operation Semantics"
             accesskey="P">previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="Reference.html" accesskey="U">Reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Coroutines in LLVM</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="https://llvm.org/docs/UserGuides.html">User Guides</a></li>
    <li><a href="https://llvm.org/docs/Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/Contributing.html">Contributing to LLVM</a></li>
    <li><a href="https://llvm.org/docs/HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#discord">Discord</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/FAQ.html">FAQ</a></li>
    <li><a href="https://llvm.org/docs/Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project/">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/Coroutines.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="coroutines-in-llvm">
<h1>Coroutines in LLVM<a class="headerlink" href="#coroutines-in-llvm" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id83">Introduction</a></p>
<ul>
<li><p><a class="reference internal" href="#switched-resume-lowering" id="id84">Switched-Resume Lowering</a></p></li>
<li><p><a class="reference internal" href="#returned-continuation-lowering" id="id85">Returned-Continuation Lowering</a></p></li>
<li><p><a class="reference internal" href="#async-lowering" id="id86">Async Lowering</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#coroutines-by-example" id="id87">Coroutines by Example</a></p>
<ul>
<li><p><a class="reference internal" href="#coroutine-representation" id="id88">Coroutine Representation</a></p></li>
<li><p><a class="reference internal" href="#coroutine-transformation" id="id89">Coroutine Transformation</a></p></li>
<li><p><a class="reference internal" href="#avoiding-heap-allocations" id="id90">Avoiding Heap Allocations</a></p></li>
<li><p><a class="reference internal" href="#multiple-suspend-points" id="id91">Multiple Suspend Points</a></p></li>
<li><p><a class="reference internal" href="#distinct-save-and-suspend" id="id92">Distinct Save and Suspend</a></p></li>
<li><p><a class="reference internal" href="#coroutine-promise" id="id93">Coroutine Promise</a></p></li>
<li><p><a class="reference internal" href="#final-suspend" id="id94">Final Suspend</a></p></li>
<li><p><a class="reference internal" href="#custom-abis-and-plugin-libraries" id="id95">Custom ABIs and Plugin Libraries</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#parameter-attributes" id="id96">Parameter Attributes</a></p>
<ul>
<li><p><a class="reference internal" href="#byval" id="id97">ByVal</a></p></li>
<li><p><a class="reference internal" href="#swift-error" id="id98">Swift Error</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#intrinsics" id="id99">Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#coroutine-manipulation-intrinsics" id="id100">Coroutine Manipulation Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-coro-destroy-intrinsic" id="id101">‘llvm.coro.destroy’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-resume-intrinsic" id="id102">‘llvm.coro.resume’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-done-intrinsic" id="id103">‘llvm.coro.done’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-promise-intrinsic" id="id104">‘llvm.coro.promise’ Intrinsic</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#coroutine-structure-intrinsics" id="id105">Coroutine Structure Intrinsics</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-coro-size-intrinsic" id="id106">‘llvm.coro.size’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-align-intrinsic" id="id107">‘llvm.coro.align’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-begin-intrinsic" id="id108">‘llvm.coro.begin’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-begin-custom-abi-intrinsic" id="id109">‘llvm.coro.begin.custom.abi’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-free-intrinsic" id="id110">‘llvm.coro.free’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-alloc-intrinsic" id="id111">‘llvm.coro.alloc’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-noop-intrinsic" id="id112">‘llvm.coro.noop’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-frame-intrinsic" id="id113">‘llvm.coro.frame’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-id-intrinsic" id="id114">‘llvm.coro.id’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-id-async-intrinsic" id="id115">‘llvm.coro.id.async’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-id-retcon-intrinsic" id="id116">‘llvm.coro.id.retcon’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-id-retcon-once-intrinsic" id="id117">‘llvm.coro.id.retcon.once’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-end-intrinsic" id="id118">‘llvm.coro.end’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-end-results-intrinsic" id="id119">‘llvm.coro.end.results’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-end-async-intrinsic" id="id120">‘llvm.coro.end.async’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-suspend-intrinsic" id="id121">‘llvm.coro.suspend’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-save-intrinsic" id="id122">‘llvm.coro.save’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-suspend-async-intrinsic" id="id123">‘llvm.coro.suspend.async’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-prepare-async-intrinsic" id="id124">‘llvm.coro.prepare.async’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-suspend-retcon-intrinsic" id="id125">‘llvm.coro.suspend.retcon’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-await-suspend-void-intrinsic" id="id126">‘llvm.coro.await.suspend.void’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-await-suspend-bool-intrinsic" id="id127">‘llvm.coro.await.suspend.bool’ Intrinsic</a></p></li>
<li><p><a class="reference internal" href="#llvm-coro-await-suspend-handle-intrinsic" id="id128">‘llvm.coro.await.suspend.handle’ Intrinsic</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#coroutine-transformation-passes" id="id129">Coroutine Transformation Passes</a></p>
<ul>
<li><p><a class="reference internal" href="#coroearly" id="id130">CoroEarly</a></p></li>
<li><p><a class="reference internal" href="#corosplit" id="id131">CoroSplit</a></p></li>
<li><p><a class="reference internal" href="#coroannotationelide" id="id132">CoroAnnotationElide</a></p></li>
<li><p><a class="reference internal" href="#coroelide" id="id133">CoroElide</a></p></li>
<li><p><a class="reference internal" href="#corocleanup" id="id134">CoroCleanup</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#attributes" id="id135">Attributes</a></p>
<ul>
<li><p><a class="reference internal" href="#coro-only-destroy-when-complete" id="id136">coro_only_destroy_when_complete</a></p></li>
<li><p><a class="reference internal" href="#coro-elide-safe" id="id137">coro_elide_safe</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#metadata" id="id138">Metadata</a></p>
<ul>
<li><p><a class="reference internal" href="#coro-outside-frame-metadata" id="id139">‘<code class="docutils literal notranslate"><span class="pre">coro.outside.frame</span></code>’ Metadata</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#areas-requiring-attention" id="id140">Areas Requiring Attention</a></p></li>
</ul>
</nav>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Compatibility across LLVM releases is not guaranteed.</p>
</div>
<section id="introduction">
<h2><a class="toc-backref" href="#id83" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p id="coroutine-handle">LLVM coroutines are functions that have one or more <a class="reference internal" href="#suspend-points">suspend points</a>.
When a suspend point is reached, the execution of a coroutine is suspended and
control is returned back to its caller. A suspended coroutine can be resumed
to continue execution from the last suspend point or it can be destroyed.</p>
<p>In the following example, we call function <cite>f</cite> (which may or may not be a
coroutine itself) that returns a handle to a suspended coroutine
(<strong>coroutine handle</strong>) that is used by <cite>main</cite> to resume the coroutine twice and
then destroy it:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%hdl</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@f</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">4</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.coro.resume</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.coro.resume</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.coro.destroy</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span>
<span class="p">}</span>
</pre></div>
</div>
<p id="coroutine-frame">In addition to the function stack frame which exists when a coroutine is
executing, there is an additional region of storage that contains objects that
keep the coroutine state when a coroutine is suspended. This region of storage
is called the <strong>coroutine frame</strong>. It is created when a coroutine is called
and destroyed when a coroutine either runs to completion or is destroyed
while suspended.</p>
<p>LLVM currently supports two styles of coroutine lowering. These styles
support substantially different sets of features, have substantially
different ABIs, and expect substantially different patterns of frontend
code generation. However, the styles also have a great deal in common.</p>
<p>In all cases, an LLVM coroutine is initially represented as an ordinary LLVM
function that has calls to <a class="reference internal" href="#coroutine-intrinsics">coroutine intrinsics</a> defining the structure of
the coroutine. The coroutine function is then, in the most general case,
rewritten by the coroutine lowering passes to become the “ramp function”,
the initial entrypoint of the coroutine, which executes until a suspend point
is first reached. The remainder of the original coroutine function is split
out into some number of “resume functions”. Any state which must persist
across suspensions is stored in the coroutine frame. The resume functions
must somehow be able to handle either a “normal” resumption, which continues
the normal execution of the coroutine, or an “abnormal” resumption, which
must unwind the coroutine without attempting to suspend it.</p>
<section id="switched-resume-lowering">
<h3><a class="toc-backref" href="#id84" role="doc-backlink">Switched-Resume Lowering</a><a class="headerlink" href="#switched-resume-lowering" title="Link to this heading">¶</a></h3>
<p>In LLVM’s standard switched-resume lowering, signaled by the use of
<cite>llvm.coro.id</cite>, the coroutine frame is stored as part of a “coroutine
object” which represents a handle to a particular invocation of the
coroutine.  All coroutine objects support a common ABI allowing certain
features to be used without knowing anything about the coroutine’s
implementation:</p>
<ul class="simple">
<li><p>A coroutine object can be queried to see if it has reached completion
with <cite>llvm.coro.done</cite>.</p></li>
<li><p>A coroutine object can be resumed normally if it has not already reached
completion with <cite>llvm.coro.resume</cite>.</p></li>
<li><p>A coroutine object can be destroyed, invalidating the coroutine object,
with <cite>llvm.coro.destroy</cite>.  This must be done separately even if the
coroutine has reached completion normally.</p></li>
<li><p>“Promise” storage, which is known to have a certain size and alignment,
can be projected out of the coroutine object with <cite>llvm.coro.promise</cite>.
The coroutine implementation must have been compiled to define a promise
of the same size and alignment.</p></li>
</ul>
<p>In general, interacting with a coroutine object in any of these ways while
it is running has undefined behavior.</p>
<p>The coroutine function is split into three functions, representing three
different ways that control can enter the coroutine:</p>
<ol class="arabic simple">
<li><p>the ramp function that is initially invoked, which takes arbitrary
arguments and returns a pointer to the coroutine object;</p></li>
<li><p>a coroutine resume function that is invoked when the coroutine is resumed,
which takes a pointer to the coroutine object and returns <cite>void</cite>;</p></li>
<li><p>a coroutine destroy function that is invoked when the coroutine is
destroyed, which takes a pointer to the coroutine object and returns
<cite>void</cite>.</p></li>
</ol>
<p>Because the resume and destroy functions are shared across all suspend
points, suspend points must store the index of the active suspend in
the coroutine object, and the resume/destroy functions must switch over
that index to get back to the correct point.  Hence the name of this
lowering.</p>
<p>Pointers to the resume and destroy functions are stored in the coroutine
object at known offsets which are fixed for all coroutines.  A completed
coroutine is represented with a null resume function.</p>
<p>There is a somewhat complex protocol of intrinsics for allocating and
deallocating the coroutine object.  It is complex in order to allow the
allocation to be elided due to inlining.  This protocol is discussed
in further detail below.</p>
<p>The frontend may generate code to call the coroutine function directly;
this will become a call to the ramp function and will return a pointer
to the coroutine object.  The frontend should always resume or destroy
the coroutine using the corresponding intrinsics.</p>
</section>
<section id="returned-continuation-lowering">
<h3><a class="toc-backref" href="#id85" role="doc-backlink">Returned-Continuation Lowering</a><a class="headerlink" href="#returned-continuation-lowering" title="Link to this heading">¶</a></h3>
<p>In returned-continuation lowering, signaled by the use of
<cite>llvm.coro.id.retcon</cite> or <cite>llvm.coro.id.retcon.once</cite>, some aspects of
the ABI must be handled more explicitly by the frontend.</p>
<p>In this lowering, every suspend point takes a list of “yielded values”
which are returned back to the caller along with a function pointer,
called the continuation function.  The coroutine is resumed by simply
calling this continuation function pointer.  The original coroutine
is divided into the ramp function and then an arbitrary number of
these continuation functions, one for each suspend point.</p>
<p>LLVM actually supports two closely-related returned-continuation
lowerings:</p>
<ul>
<li><p>In normal returned-continuation lowering, the coroutine may suspend
itself multiple times. This means that a continuation function
itself returns another continuation pointer, as well as a list of
yielded values.</p>
<p>The coroutine indicates that it has run to completion by returning
a null continuation pointer. Any yielded values will be <cite>undef</cite>
should be ignored.</p>
</li>
<li><p>In yield-once returned-continuation lowering, the coroutine must
suspend itself exactly once (or throw an exception).  The ramp
function returns a continuation function pointer and yielded
values, the continuation function may optionally return ordinary
results when the coroutine has run to completion.</p></li>
</ul>
<p>The coroutine frame is maintained in a fixed-size buffer that is
passed to the <cite>coro.id</cite> intrinsic, which guarantees a certain size
and alignment statically. The same buffer must be passed to the
continuation function(s). The coroutine will allocate memory if the
buffer is insufficient, in which case it will need to store at
least that pointer in the buffer; therefore the buffer must always
be at least pointer-sized. How the coroutine uses the buffer may
vary between suspend points.</p>
<p>In addition to the buffer pointer, continuation functions take an
argument indicating whether the coroutine is being resumed normally
(zero) or abnormally (non-zero).</p>
<p>LLVM is currently ineffective at statically eliminating allocations
after fully inlining returned-continuation coroutines into a caller.
This may be acceptable if LLVM’s coroutine support is primarily being
used for low-level lowering and inlining is expected to be applied
earlier in the pipeline.</p>
</section>
<section id="async-lowering">
<h3><a class="toc-backref" href="#id86" role="doc-backlink">Async Lowering</a><a class="headerlink" href="#async-lowering" title="Link to this heading">¶</a></h3>
<p>In async-continuation lowering, signaled by the use of <cite>llvm.coro.id.async</cite>,
handling of control-flow must be handled explicitly by the frontend.</p>
<p>In this lowering, a coroutine is assumed to take the current <cite>async context</cite> as
one of its arguments (the argument position is determined by
<cite>llvm.coro.id.async</cite>). It is used to marshal arguments and return values of the
coroutine. Therefore an async coroutine returns <cite>void</cite>.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="k">swiftcc</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@async_coroutine</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%async.ctxt</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Values live across a suspend point need to be stored in the coroutine frame to
be available in the continuation function. This frame is stored as a tail to the
<cite>async context</cite>.</p>
<p>Every suspend point takes an <cite>context projection function</cite> argument which
describes how-to obtain the continuations <cite>async context</cite> and every suspend
point has an associated <cite>resume function</cite> denoted by the
<cite>llvm.coro.async.resume</cite> intrinsic. The coroutine is resumed by calling this
<cite>resume function</cite> passing the <cite>async context</cite> as the one of its arguments
argument. The <cite>resume function</cite> can restore its (the caller’s) <cite>async context</cite>
by applying a <cite>context projection function</cite> that is provided by the frontend as
a parameter to the <cite>llvm.coro.suspend.async</cite> intrinsic.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// For example:</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">async_context</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">async_context</span><span class="w"> </span><span class="o">*</span><span class="n">caller_context</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>

<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">context_projection_function</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">async_context</span><span class="w"> </span><span class="o">*</span><span class="n">callee_ctxt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">callee_ctxt</span><span class="o">-&gt;</span><span class="n">caller_context</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv">%resume_func_ptr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.coro.async.resume</span><span class="p">()</span>
<span class="k">call</span><span class="w"> </span><span class="p">{</span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="p">}</span><span class="w"> </span><span class="p">(</span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="vg">@llvm.coro.suspend.async</span><span class="p">(</span>
<span class="w">                                            </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%resume_func_ptr</span><span class="p">,</span>
<span class="w">                                            </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%context_projection_function</span>
</pre></div>
</div>
<p>The frontend should provide a <cite>async function pointer</cite> struct associated with
each async coroutine by <cite>llvm.coro.id.async</cite>’s argument. The initial size and
alignment of the <cite>async context</cite> must be provided as arguments to the
<cite>llvm.coro.id.async</cite> intrinsic. Lowering will update the size entry with the
coroutine frame  requirements. The frontend is responsible for allocating the
memory for the <cite>async context</cite> but can use the <cite>async function pointer</cite> struct
to obtain the required size.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">async_function_pointer</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">relative_function_pointer_to_async_impl</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">context_size</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Lowering will split an async coroutine into a ramp function and one resume
function per suspend point.</p>
<p>How control-flow is passed between caller, suspension point, and back to
resume function is left up to the frontend.</p>
<p>The suspend point takes a function and its arguments. The function is intended
to model the transfer to the callee function. It will be tail called by
lowering and therefore must have the same signature and calling convention as
the async coroutine.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">call</span><span class="w"> </span><span class="p">{</span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="p">}</span><span class="w"> </span><span class="p">(</span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="vg">@llvm.coro.suspend.async</span><span class="p">(</span>
<span class="w">                 </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%resume_func_ptr</span><span class="p">,</span>
<span class="w">                 </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%context_projection_function</span><span class="p">,</span>
<span class="w">                 </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%suspend_function</span><span class="p">,</span>
<span class="w">                 </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%arg1</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%arg2</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%arg3</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="coroutines-by-example">
<h2><a class="toc-backref" href="#id87" role="doc-backlink">Coroutines by Example</a><a class="headerlink" href="#coroutines-by-example" title="Link to this heading">¶</a></h2>
<p>The examples below are all of switched-resume coroutines.</p>
<section id="coroutine-representation">
<h3><a class="toc-backref" href="#id88" role="doc-backlink">Coroutine Representation</a><a class="headerlink" href="#coroutine-representation" title="Link to this heading">¶</a></h3>
<p>Let’s look at an example of an LLVM coroutine with the behavior sketched
by the following pseudo-code.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">for</span><span class="p">(;;)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">print</span><span class="p">(</span><span class="n">n</span><span class="o">++</span><span class="p">);</span>
<span class="w">     </span><span class="o">&lt;</span><span class="n">suspend</span><span class="o">&gt;</span><span class="w"> </span><span class="c1">// returns a coroutine handle on first suspend</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This coroutine calls some function <cite>print</cite> with value <cite>n</cite> as an argument and
suspends execution. Every time this coroutine resumes, it calls <cite>print</cite> again with an argument one bigger than the last time. This coroutine never completes by itself and must be destroyed explicitly. If we use this coroutine with
a <cite>main</cite> shown in the previous section. It will call <cite>print</cite> with values 4, 5
and 6 after which the coroutine will be destroyed.</p>
<p>The LLVM IR for this coroutine looks like this:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@f</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">)</span><span class="w"> </span><span class="err">presplitcorouti</span><span class="k">ne</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%id</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="vg">@llvm.coro.id</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">null</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">null</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">null</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%size</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.coro.size.i32</span><span class="p">()</span>
<span class="w">  </span><span class="nv">%alloc</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@malloc</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%size</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%hdl</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">noalias</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.coro.begin</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%id</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%alloc</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%loop</span>
<span class="nl">loop:</span>
<span class="w">  </span><span class="nv">%n.val</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%n</span><span class="p">,</span><span class="w"> </span><span class="nv">%entry</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%inc</span><span class="p">,</span><span class="w"> </span><span class="nv">%loop</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="nv">%inc</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="k">nsw</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n.val</span><span class="p">,</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n.val</span><span class="p">)</span>
<span class="w">  </span><span class="nv nv-Anonymous">%0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="vg">@llvm.coro.suspend</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="k">none</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">)</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv nv-Anonymous">%0</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%suspend</span><span class="w"> </span><span class="p">[</span><span class="kt">i8</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%loop</span>
<span class="w">                                </span><span class="kt">i8</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%cleanup</span><span class="p">]</span>
<span class="nl">cleanup:</span>
<span class="w">  </span><span class="nv">%mem</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.coro.free</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%id</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@free</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%mem</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%suspend</span>
<span class="nl">suspend:</span>
<span class="w">  </span><span class="nv">%unused</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.coro.end</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">,</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="k">none</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <cite>entry</cite> block establishes the coroutine frame. The <a class="reference internal" href="#coro-size">coro.size</a> intrinsic is
lowered to a constant representing the size required for the coroutine frame.
The <a class="reference internal" href="#coro-begin">coro.begin</a> intrinsic initializes the coroutine frame and returns the
coroutine handle. The second parameter of <cite>coro.begin</cite> is given a block of memory
to be used if the coroutine frame needs to be allocated dynamically.</p>
<p>The <a class="reference internal" href="#coro-id">coro.id</a> intrinsic serves as coroutine identity useful in cases when the
<a class="reference internal" href="#coro-begin">coro.begin</a> intrinsic get duplicated by optimization passes such as
jump-threading.</p>
<p>The <cite>cleanup</cite> block destroys the coroutine frame. The <a class="reference internal" href="#coro-free">coro.free</a> intrinsic,
given the coroutine handle, returns a pointer of the memory block to be freed or
<cite>null</cite> if the coroutine frame was not allocated dynamically. The <cite>cleanup</cite>
block is entered when coroutine runs to completion by itself or destroyed via
call to the <a class="reference internal" href="#coro-destroy">coro.destroy</a> intrinsic.</p>
<p>The <cite>suspend</cite> block contains code to be executed when coroutine runs to
completion or suspended. The <a class="reference internal" href="#coro-end">coro.end</a> intrinsic marks the point where
a coroutine needs to return control back to the caller if it is not an initial
invocation of the coroutine.</p>
<p>The <cite>loop</cite> blocks represents the body of the coroutine. The <a class="reference internal" href="#coro-suspend">coro.suspend</a>
intrinsic in combination with the following switch indicates what happens to
control flow when a coroutine is suspended (default case), resumed (case 0) or
destroyed (case 1).</p>
</section>
<section id="coroutine-transformation">
<h3><a class="toc-backref" href="#id89" role="doc-backlink">Coroutine Transformation</a><a class="headerlink" href="#coroutine-transformation" title="Link to this heading">¶</a></h3>
<p>One of the steps of coroutine lowering is building the coroutine frame. The
def-use chains are analyzed to determine which objects need be kept alive across
suspend points. In the coroutine shown in the previous section, use of virtual register
<cite>%inc</cite> is separated from the definition by a suspend point, therefore, it
cannot reside on the stack frame since the latter goes away once the coroutine
is suspended and control is returned back to the caller. An i32 slot is
allocated in the coroutine frame and <cite>%inc</cite> is spilled and reloaded from that
slot as needed.</p>
<p>We also store addresses of the resume and destroy functions so that the
<cite>coro.resume</cite> and <cite>coro.destroy</cite> intrinsics can resume and destroy the coroutine
when its identity cannot be determined statically at compile time. For our
example, the coroutine frame will be:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv">%f.frame</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>After resume and destroy parts are outlined, function <cite>f</cite> will contain only the
code responsible for creation and initialization of the coroutine frame and
execution of the coroutine until a suspend point is reached:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@f</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%id</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="vg">@llvm.coro.id</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">null</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">null</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">null</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%alloc</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">noalias</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@malloc</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">24</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%frame</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">noalias</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.coro.begin</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%id</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%alloc</span><span class="p">)</span>
<span class="w">  </span><span class="nv nv-Anonymous">%1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="nv">%f.frame</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%frame</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@f.resume</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv nv-Anonymous">%1</span>
<span class="w">  </span><span class="nv nv-Anonymous">%2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="nv">%f.frame</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%frame</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@f.destroy</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv nv-Anonymous">%2</span>

<span class="w">  </span><span class="nv">%inc</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="k">nsw</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">,</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="nv">%inc.spill.addr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="k">inbounds</span><span class="w"> </span><span class="nv">%f.Frame</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%FramePtr</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">2</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%inc</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%inc.spill.addr</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">)</span>

<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%frame</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Outlined resume part of the coroutine will reside in function <cite>f.resume</cite>:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="k">internal</span><span class="w"> </span><span class="k">fastcc</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@f.resume</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%frame.ptr.resume</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%inc.spill.addr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="nv">%f.frame</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%frame.ptr.resume</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">2</span>
<span class="w">  </span><span class="nv">%inc.spill</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%inc.spill.addr</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
<span class="w">  </span><span class="nv">%inc</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%inc.spill</span><span class="p">,</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%inc</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%inc.spill.addr</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
<span class="w">  </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%inc</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="k">void</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Whereas function <cite>f.destroy</cite> will contain the cleanup code for the coroutine:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="k">internal</span><span class="w"> </span><span class="k">fastcc</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@f.destroy</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%frame.ptr.destroy</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@free</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%frame.ptr.destroy</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="k">void</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="avoiding-heap-allocations">
<h3><a class="toc-backref" href="#id90" role="doc-backlink">Avoiding Heap Allocations</a><a class="headerlink" href="#avoiding-heap-allocations" title="Link to this heading">¶</a></h3>
<p>A particular coroutine usage pattern, which is illustrated by the <cite>main</cite>
function in the overview section, where a coroutine is created, manipulated and
destroyed by the same calling function, is common for coroutines implementing
RAII idiom and is suitable for allocation elision optimization which avoid
dynamic allocation by storing the coroutine frame as a static <cite>alloca</cite> in its
caller.</p>
<p>In the entry block, we will call <a class="reference internal" href="#coro-alloc">coro.alloc</a> intrinsic that will return <cite>true</cite>
when dynamic allocation is required, and <cite>false</cite> if dynamic allocation is
elided.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%id</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="vg">@llvm.coro.id</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">null</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">null</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">null</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%need.dyn.alloc</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.coro.alloc</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%id</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%need.dyn.alloc</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%dyn.alloc</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%coro.begin</span>
<span class="nl">dyn.alloc:</span>
<span class="w">  </span><span class="nv">%size</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.coro.size.i32</span><span class="p">()</span>
<span class="w">  </span><span class="nv">%alloc</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@CustomAlloc</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%size</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%coro.begin</span>
<span class="nl">coro.begin:</span>
<span class="w">  </span><span class="nv">%phi</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="k">null</span><span class="p">,</span><span class="w"> </span><span class="nv">%entry</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%alloc</span><span class="p">,</span><span class="w"> </span><span class="nv">%dyn.alloc</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="nv">%hdl</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">noalias</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.coro.begin</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%id</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%phi</span><span class="p">)</span>
</pre></div>
</div>
<p>In the cleanup block, we will make freeing the coroutine frame conditional on
<a class="reference internal" href="#coro-free">coro.free</a> intrinsic. If allocation is elided, <a class="reference internal" href="#coro-free">coro.free</a> returns <cite>null</cite>
thus skipping the deallocation code:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nl">cleanup:</span>
<span class="w">  </span><span class="nv">%mem</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.coro.free</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%id</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%need.dyn.free</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">ne</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%mem</span><span class="p">,</span><span class="w"> </span><span class="k">null</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%need.dyn.free</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%dyn.free</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%if.end</span>
<span class="nl">dyn.free:</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@CustomFree</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%mem</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%if.end</span>
<span class="nl">if.end:</span>
<span class="w">  </span><span class="p">...</span>
</pre></div>
</div>
<p>With allocations and deallocations represented as described as above, after
coroutine heap allocation elision optimization, the resulting main will be:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">4</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">5</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">6</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="multiple-suspend-points">
<h3><a class="toc-backref" href="#id91" role="doc-backlink">Multiple Suspend Points</a><a class="headerlink" href="#multiple-suspend-points" title="Link to this heading">¶</a></h3>
<p>Let’s consider the coroutine that has more than one suspend point:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">for</span><span class="p">(;;)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">print</span><span class="p">(</span><span class="n">n</span><span class="o">++</span><span class="p">);</span>
<span class="w">     </span><span class="o">&lt;</span><span class="n">suspend</span><span class="o">&gt;</span>
<span class="w">     </span><span class="n">print</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">);</span>
<span class="w">     </span><span class="o">&lt;</span><span class="n">suspend</span><span class="o">&gt;</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Matching LLVM code would look like (with the rest of the code remaining the same
as the code in the previous section):</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nl">loop:</span>
<span class="w">  </span><span class="nv">%n.addr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%n</span><span class="p">,</span><span class="w"> </span><span class="nv">%entry</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%inc</span><span class="p">,</span><span class="w"> </span><span class="nv">%loop.resume</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n.addr</span><span class="p">)</span><span class="w"> </span><span class="vg">#4</span>
<span class="w">  </span><span class="nv nv-Anonymous">%2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="vg">@llvm.coro.suspend</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="k">none</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">)</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv nv-Anonymous">%2</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%suspend</span><span class="w"> </span><span class="p">[</span><span class="kt">i8</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%loop.resume</span>
<span class="w">                                </span><span class="kt">i8</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%cleanup</span><span class="p">]</span>
<span class="nl">loop.resume:</span>
<span class="w">  </span><span class="nv">%inc</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="k">nsw</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n.addr</span><span class="p">,</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="nv">%sub</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">xor</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n.addr</span><span class="p">,</span><span class="w"> </span><span class="m">-1</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%sub</span><span class="p">)</span>
<span class="w">  </span><span class="nv nv-Anonymous">%3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="vg">@llvm.coro.suspend</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="k">none</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">)</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv nv-Anonymous">%3</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%suspend</span><span class="w"> </span><span class="p">[</span><span class="kt">i8</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%loop</span>
<span class="w">                                </span><span class="kt">i8</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%cleanup</span><span class="p">]</span>
</pre></div>
</div>
<p>In this case, the coroutine frame would include a suspend index that will
indicate at which suspend point the coroutine needs to resume.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv">%f.frame</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>The resume function will use an index to jump to an appropriate basic block and will look
as follows:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="k">internal</span><span class="w"> </span><span class="k">fastcc</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@f.Resume</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%FramePtr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry.Resume:</span>
<span class="w">  </span><span class="nv">%index.addr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="k">inbounds</span><span class="w"> </span><span class="nv">%f.Frame</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%FramePtr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">2</span>
<span class="w">  </span><span class="nv">%index</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i8</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%index.addr</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="nv">%switch</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">eq</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%index</span><span class="p">,</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="nv">%n.addr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">getelementptr</span><span class="w"> </span><span class="k">inbounds</span><span class="w"> </span><span class="nv">%f.Frame</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%FramePtr</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">3</span>
<span class="w">  </span><span class="nv">%n</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%n.addr</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>

<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%switch</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%loop.resume</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%loop</span>

<span class="nl">loop.resume:</span>
<span class="w">  </span><span class="nv">%sub</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">sub</span><span class="w"> </span><span class="k">nsw</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nv">%n</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%sub</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%suspend</span>
<span class="nl">loop:</span>
<span class="w">  </span><span class="nv">%inc</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="k">nsw</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">,</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%inc</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%n.addr</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
<span class="w">  </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%inc</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%suspend</span>

<span class="nl">suspend:</span>
<span class="w">  </span><span class="nv">%storemerge</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nv">%loop</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="nv">%loop.resume</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%storemerge</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%index.addr</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="k">void</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If different cleanup code needs to get executed for different suspend points,
a similar switch will be in the <cite>f.destroy</cite> function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Using suspend index in a coroutine state and having a switch in <cite>f.resume</cite> and
<cite>f.destroy</cite> is one of the possible implementation strategies. We explored
another option where a distinct <cite>f.resume1</cite>, <cite>f.resume2</cite>, etc. are created for
every suspend point, and instead of storing an index, the resume and destroy
function pointers are updated at every suspend. Early testing showed that the
current approach is easier on the optimizer than the latter so it is a
lowering strategy implemented at the moment.</p>
</div>
</section>
<section id="distinct-save-and-suspend">
<h3><a class="toc-backref" href="#id92" role="doc-backlink">Distinct Save and Suspend</a><a class="headerlink" href="#distinct-save-and-suspend" title="Link to this heading">¶</a></h3>
<p>In the previous example, setting a resume index (or some other state change that
needs to happen to prepare a coroutine for resumption) happens at the same time as
a suspension of a coroutine. However, in certain cases, it is necessary to control
when coroutine is prepared for resumption and when it is suspended.</p>
<p>In the following example, a coroutine represents some activity that is driven
by completions of asynchronous operations <cite>async_op1</cite> and <cite>async_op2</cite> which get
a coroutine handle as a parameter and resume the coroutine once async
operation is finished.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>void g() {
   for (;;)
     if (cond()) {
        async_op1(&lt;coroutine-handle&gt;); // will resume once async_op1 completes
        &lt;suspend&gt;
        do_one();
     }
     else {
        async_op2(&lt;coroutine-handle&gt;); // will resume once async_op2 completes
        &lt;suspend&gt;
        do_two();
     }
   }
}
</pre></div>
</div>
<p>In this case, coroutine should be ready for resumption prior to a call to
<cite>async_op1</cite> and <cite>async_op2</cite>. The <a class="reference internal" href="#coro-save">coro.save</a> intrinsic is used to indicate a
point when coroutine should be ready for resumption (namely, when a resume index
should be stored in the coroutine frame, so that it can be resumed at the
correct resume point):</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nl">if.true:</span>
<span class="w">  </span><span class="nv">%save1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="vg">@llvm.coro.save</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@async_op1</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%suspend1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.coro.suspend</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%save1</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">)</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%suspend1</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%suspend</span><span class="w"> </span><span class="p">[</span><span class="kt">i8</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%resume1</span>
<span class="w">                                       </span><span class="kt">i8</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%cleanup</span><span class="p">]</span>
<span class="nl">if.false:</span>
<span class="w">  </span><span class="nv">%save2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="vg">@llvm.coro.save</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@async_op2</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%suspend2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.coro.suspend</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%save2</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">)</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%suspend2</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%suspend</span><span class="w"> </span><span class="p">[</span><span class="kt">i8</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%resume2</span>
<span class="w">                                       </span><span class="kt">i8</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%cleanup</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="coroutine-promise">
<span id="id1"></span><h3><a class="toc-backref" href="#id93" role="doc-backlink">Coroutine Promise</a><a class="headerlink" href="#coroutine-promise" title="Link to this heading">¶</a></h3>
<p>A coroutine author or a frontend may designate a distinguished <cite>alloca</cite> that can
be used to communicate with the coroutine. This distinguished alloca is called
<strong>coroutine promise</strong> and is provided as the second parameter to the
<a class="reference internal" href="#coro-id">coro.id</a> intrinsic.</p>
<p>The following coroutine designates a 32-bit integer <cite>promise</cite> and uses it to
store the current value produced by a coroutine.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@f</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%promise</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i32</span>
<span class="w">  </span><span class="nv">%id</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="vg">@llvm.coro.id</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%promise</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">null</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">null</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%need.dyn.alloc</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.coro.alloc</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%id</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%need.dyn.alloc</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%dyn.alloc</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%coro.begin</span>
<span class="nl">dyn.alloc:</span>
<span class="w">  </span><span class="nv">%size</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.coro.size.i32</span><span class="p">()</span>
<span class="w">  </span><span class="nv">%alloc</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@malloc</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%size</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%coro.begin</span>
<span class="nl">coro.begin:</span>
<span class="w">  </span><span class="nv">%phi</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="k">null</span><span class="p">,</span><span class="w"> </span><span class="nv">%entry</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%alloc</span><span class="p">,</span><span class="w"> </span><span class="nv">%dyn.alloc</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="nv">%hdl</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">noalias</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.coro.begin</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%id</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%phi</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%loop</span>
<span class="nl">loop:</span>
<span class="w">  </span><span class="nv">%n.val</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%n</span><span class="p">,</span><span class="w"> </span><span class="nv">%coro.begin</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%inc</span><span class="p">,</span><span class="w"> </span><span class="nv">%loop</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="nv">%inc</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="k">nsw</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n.val</span><span class="p">,</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n.val</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%promise</span>
<span class="w">  </span><span class="nv nv-Anonymous">%0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="vg">@llvm.coro.suspend</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="k">none</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">)</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv nv-Anonymous">%0</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%suspend</span><span class="w"> </span><span class="p">[</span><span class="kt">i8</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%loop</span>
<span class="w">                                </span><span class="kt">i8</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%cleanup</span><span class="p">]</span>
<span class="nl">cleanup:</span>
<span class="w">  </span><span class="nv">%mem</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.coro.free</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%id</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@free</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%mem</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%suspend</span>
<span class="nl">suspend:</span>
<span class="w">  </span><span class="nv">%unused</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.coro.end</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">,</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="k">none</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A coroutine consumer can rely on the <a class="reference internal" href="#coro-promise">coro.promise</a> intrinsic to access the
coroutine promise.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%hdl</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@f</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">4</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%promise.addr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.coro.promise</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%val0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%promise.addr</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%val0</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.coro.resume</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%val1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%promise.addr</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%val1</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.coro.resume</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%val2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%promise.addr</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%val2</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.coro.destroy</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span>
<span class="p">}</span>
</pre></div>
</div>
<p>After example in this section is compiled, result of the compilation will be:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">4</span><span class="p">)</span>
<span class="w">  </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">5</span><span class="p">)</span>
<span class="w">  </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">6</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="final-suspend">
<span id="final"></span><span id="id2"></span><h3><a class="toc-backref" href="#id94" role="doc-backlink">Final Suspend</a><a class="headerlink" href="#final-suspend" title="Link to this heading">¶</a></h3>
<p>A coroutine author or a frontend may designate a particular suspend to be final,
by setting the second argument of the <a class="reference internal" href="#coro-suspend">coro.suspend</a> intrinsic to <cite>true</cite>.
Such a suspend point has two properties:</p>
<ul class="simple">
<li><p>it is possible to check whether a suspended coroutine is at the final suspend
point via <a class="reference internal" href="#coro-done">coro.done</a> intrinsic;</p></li>
<li><p>a resumption of a coroutine stopped at the final suspend point leads to
undefined behavior. The only possible action for a coroutine at a final
suspend point is destroying it via <a class="reference internal" href="#coro-destroy">coro.destroy</a> intrinsic.</p></li>
</ul>
<p>From the user perspective, the final suspend point represents an idea of a
coroutine reaching the end. From the compiler perspective, it is an optimization
opportunity for reducing number of resume points (and therefore switch cases) in
the resume function.</p>
<p>The following is an example of a function that keeps resuming the coroutine
until the final suspend point is reached after which point the coroutine is
destroyed:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%hdl</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@f</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">4</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%while</span>
<span class="nl">while:</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.coro.resume</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%done</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.coro.done</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%done</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%end</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%while</span>
<span class="nl">end:</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.coro.destroy</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Usually, final suspend point is a frontend injected suspend point that does not
correspond to any explicitly authored suspend point of the high level language.
For example, for a Python generator that has only one suspend point:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">coroutine</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">yield</span> <span class="n">i</span>
</pre></div>
</div>
<p>Python frontend would inject two more suspend points, so that the actual code
looks like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">coroutine</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">current_value</span><span class="p">;</span>
<span class="w">  </span><span class="o">&lt;</span><span class="n">designate</span><span class="w"> </span><span class="n">current_value</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">coroutine</span><span class="w"> </span><span class="n">promise</span><span class="o">&gt;</span>
<span class="w">  </span><span class="o">&lt;</span><span class="n">SUSPEND</span><span class="o">&gt;</span><span class="w"> </span><span class="c1">// injected suspend point, so that the coroutine starts suspended</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">current_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">SUSPEND</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// corresponds to &quot;yield i&quot;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="o">&lt;</span><span class="n">SUSPEND</span><span class="w"> </span><span class="n">final</span><span class="o">=</span><span class="nb">true</span><span class="o">&gt;</span><span class="w"> </span><span class="c1">// injected final suspend point</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and python iterator <cite>__next__</cite> would look like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">__next__</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">hdl</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">coro</span><span class="p">.</span><span class="n">resume</span><span class="p">(</span><span class="n">hdl</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">coro</span><span class="p">.</span><span class="n">done</span><span class="p">(</span><span class="n">hdl</span><span class="p">))</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="n">StopIteration</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">coro</span><span class="p">.</span><span class="n">promise</span><span class="p">(</span><span class="n">hdl</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="custom-abis-and-plugin-libraries">
<h3><a class="toc-backref" href="#id95" role="doc-backlink">Custom ABIs and Plugin Libraries</a><a class="headerlink" href="#custom-abis-and-plugin-libraries" title="Link to this heading">¶</a></h3>
<p>Plugin libraries can extend coroutine lowering enabling a wide variety of users
to utilize the coroutine transformation passes. An existing coroutine lowering
is extended by:</p>
<ol class="arabic simple">
<li><p>defining custom ABIs that inherit from the existing ABIs,</p></li>
<li><p>give a list of generators for the custom ABIs when constructing the <a class="reference internal" href="#corosplit">CoroSplit</a> pass, and</p></li>
<li><p>use <a class="reference internal" href="#coro-begin-custom-abi">coro.begin.custom.abi</a> in place of <a class="reference internal" href="#coro-begin">coro.begin</a> that has an additional parameter for the index of the generator/ABI to be used for the coroutine.</p></li>
</ol>
<p>A custom ABI overriding the SwitchABI’s materialization looks like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">CustomSwitchABI</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">coro</span><span class="o">::</span><span class="n">SwitchABI</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">CustomSwitchABI</span><span class="p">(</span><span class="n">Function</span><span class="w"> </span><span class="o">&amp;</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">coro</span><span class="o">::</span><span class="n">Shape</span><span class="w"> </span><span class="o">&amp;</span><span class="n">S</span><span class="p">)</span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="n">coro</span><span class="o">::</span><span class="n">SwitchABI</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="p">,</span><span class="w"> </span><span class="n">ExtraMaterializable</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Giving a list of custom ABI generators while constructing the <cite>CoroSplit</cite>
pass looks like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CoroSplitPass</span><span class="o">::</span><span class="n">BaseABITy</span><span class="w"> </span><span class="n">GenCustomABI</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">Function</span><span class="w"> </span><span class="o">&amp;</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">coro</span><span class="o">::</span><span class="n">Shape</span><span class="w"> </span><span class="o">&amp;</span><span class="n">S</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">CustomSwitchABI</span><span class="o">&gt;</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">CGSCCPassManager</span><span class="w"> </span><span class="n">CGPM</span><span class="p">;</span>
<span class="n">CGPM</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">CoroSplitPass</span><span class="p">({</span><span class="n">GenCustomABI</span><span class="p">}));</span>
</pre></div>
</div>
<p>The LLVM IR for a coroutine using a Coroutine with a custom ABI looks like:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@f</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">)</span><span class="w"> </span><span class="err">presplitcoroutine_custom_abi</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%id</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="vg">@llvm.coro.id</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">null</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">null</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">null</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%size</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.coro.size.i32</span><span class="p">()</span>
<span class="w">  </span><span class="nv">%alloc</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@malloc</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%size</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%hdl</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">noalias</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.coro.begin.custom.abi</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%id</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%alloc</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%loop</span>
<span class="nl">loop:</span>
<span class="w">  </span><span class="nv">%n.val</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%n</span><span class="p">,</span><span class="w"> </span><span class="nv">%entry</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%inc</span><span class="p">,</span><span class="w"> </span><span class="nv">%loop</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="nv">%inc</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="k">nsw</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n.val</span><span class="p">,</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n.val</span><span class="p">)</span>
<span class="w">  </span><span class="nv nv-Anonymous">%0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="vg">@llvm.coro.suspend</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="k">none</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">)</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv nv-Anonymous">%0</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%suspend</span><span class="w"> </span><span class="p">[</span><span class="kt">i8</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%loop</span>
<span class="w">                                </span><span class="kt">i8</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%cleanup</span><span class="p">]</span>
<span class="nl">cleanup:</span>
<span class="w">  </span><span class="nv">%mem</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.coro.free</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%id</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@free</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%mem</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%suspend</span>
<span class="nl">suspend:</span>
<span class="w">  </span><span class="nv">%unused</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.coro.end</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">,</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="k">none</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="parameter-attributes">
<h2><a class="toc-backref" href="#id96" role="doc-backlink">Parameter Attributes</a><a class="headerlink" href="#parameter-attributes" title="Link to this heading">¶</a></h2>
<p>Some parameter attributes, used to communicate additional information about the result or parameters of a function, require special handling.</p>
<section id="byval">
<h3><a class="toc-backref" href="#id97" role="doc-backlink">ByVal</a><a class="headerlink" href="#byval" title="Link to this heading">¶</a></h3>
<p>A ByVal parameter on an argument indicates that the pointee should be treated as being passed by value to the function.
Prior to the coroutine transforms loads and stores to/from the pointer are generated where the value is needed.
Consequently, a ByVal argument is treated much like an alloca.
Space is allocated for it on the coroutine frame and the uses of the argument pointer are replaced with a pointer to the coroutine frame.</p>
</section>
<section id="swift-error">
<h3><a class="toc-backref" href="#id98" role="doc-backlink">Swift Error</a><a class="headerlink" href="#swift-error" title="Link to this heading">¶</a></h3>
<p>Clang supports the swiftcall calling convention in many common targets, and a user could call a function that takes a swifterror argument from a C++ coroutine.
The swifterror parameter attribute exists to model and optimize Swift error handling.
A swifterror alloca or parameter can only be loaded, stored, or passed as a swifterror call argument, and a swifterror call argument can only be a direct reference to a swifterror alloca or parameter.
These rules, not coincidentally, mean that you can always perfectly model the data flow in the alloca, and LLVM CodeGen actually has to do that in order to emit code.</p>
<p>For coroutine lowering the default treatment of allocas breaks those rules — splitting will try to replace the alloca with an entry in the coro frame, which can lead to trying to pass that as a swifterror argument.
To pass a swifterror argument in a split function, we need to still have the alloca around; but we also potentially need the coro frame slot, since useful data can (in theory) be stored in the swifterror alloca slot across suspensions in the presplit coroutine.
When split a coroutine it is consequently necessary to keep both the frame slot as well as the alloca itself and then keep them in sync.</p>
</section>
</section>
<section id="intrinsics">
<h2><a class="toc-backref" href="#id99" role="doc-backlink">Intrinsics</a><a class="headerlink" href="#intrinsics" title="Link to this heading">¶</a></h2>
<section id="coroutine-manipulation-intrinsics">
<h3><a class="toc-backref" href="#id100" role="doc-backlink">Coroutine Manipulation Intrinsics</a><a class="headerlink" href="#coroutine-manipulation-intrinsics" title="Link to this heading">¶</a></h3>
<p>Intrinsics described in this section are used to manipulate an existing
coroutine. They can be used in any function which happen to have a pointer
to a <a class="reference internal" href="#coroutine-frame">coroutine frame</a> or a pointer to a <a class="reference internal" href="#coroutine-promise">coroutine promise</a>.</p>
<section id="llvm-coro-destroy-intrinsic">
<span id="coro-destroy"></span><h4><a class="toc-backref" href="#id101" role="doc-backlink">‘llvm.coro.destroy’ Intrinsic</a><a class="headerlink" href="#llvm-coro-destroy-intrinsic" title="Link to this heading">¶</a></h4>
<section id="syntax">
<h5>Syntax:<a class="headerlink" href="#syntax" title="Link to this heading">¶</a></h5>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">destroy</span><span class="p">(</span><span class="n">ptr</span> <span class="o">&lt;</span><span class="n">handle</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="overview">
<h5>Overview:<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.destroy</span></code>’ intrinsic destroys a suspended
switched-resume coroutine.</p>
</section>
<section id="arguments">
<h5>Arguments:<a class="headerlink" href="#arguments" title="Link to this heading">¶</a></h5>
<p>The argument is a coroutine handle to a suspended coroutine.</p>
</section>
<section id="semantics">
<h5>Semantics:<a class="headerlink" href="#semantics" title="Link to this heading">¶</a></h5>
<p>When possible, the <cite>coro.destroy</cite> intrinsic is replaced with a direct call to
the coroutine destroy function. Otherwise it is replaced with an indirect call
based on the function pointer for the destroy function stored in the coroutine
frame. Destroying a coroutine that is not suspended leads to undefined behavior.</p>
</section>
</section>
<section id="llvm-coro-resume-intrinsic">
<span id="coro-resume"></span><h4><a class="toc-backref" href="#id102" role="doc-backlink">‘llvm.coro.resume’ Intrinsic</a><a class="headerlink" href="#llvm-coro-resume-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">resume</span><span class="p">(</span><span class="n">ptr</span> <span class="o">&lt;</span><span class="n">handle</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id3">
<h5>Overview:<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.resume</span></code>’ intrinsic resumes a suspended switched-resume coroutine.</p>
</section>
<section id="id4">
<h5>Arguments:<a class="headerlink" href="#id4" title="Link to this heading">¶</a></h5>
<p>The argument is a handle to a suspended coroutine.</p>
</section>
<section id="id5">
<h5>Semantics:<a class="headerlink" href="#id5" title="Link to this heading">¶</a></h5>
<p>When possible, the <cite>coro.resume</cite> intrinsic is replaced with a direct call to the
coroutine resume function. Otherwise it is replaced with an indirect call based
on the function pointer for the resume function stored in the coroutine frame.
Resuming a coroutine that is not suspended leads to undefined behavior.</p>
</section>
</section>
<section id="llvm-coro-done-intrinsic">
<span id="coro-done"></span><h4><a class="toc-backref" href="#id103" role="doc-backlink">‘llvm.coro.done’ Intrinsic</a><a class="headerlink" href="#llvm-coro-done-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i1</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">done</span><span class="p">(</span><span class="n">ptr</span> <span class="o">&lt;</span><span class="n">handle</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id6">
<h5>Overview:<a class="headerlink" href="#id6" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.done</span></code>’ intrinsic checks whether a suspended
switched-resume coroutine is at the final suspend point or not.</p>
</section>
<section id="id7">
<h5>Arguments:<a class="headerlink" href="#id7" title="Link to this heading">¶</a></h5>
<p>The argument is a handle to a suspended coroutine.</p>
</section>
<section id="id8">
<h5>Semantics:<a class="headerlink" href="#id8" title="Link to this heading">¶</a></h5>
<p>Using this intrinsic on a coroutine that does not have a <a class="reference internal" href="#final-suspend">final suspend</a> point
or on a coroutine that is not suspended leads to undefined behavior.</p>
</section>
</section>
<section id="llvm-coro-promise-intrinsic">
<span id="coro-promise"></span><h4><a class="toc-backref" href="#id104" role="doc-backlink">‘llvm.coro.promise’ Intrinsic</a><a class="headerlink" href="#llvm-coro-promise-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">ptr</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">promise</span><span class="p">(</span><span class="n">ptr</span> <span class="o">&lt;</span><span class="n">ptr</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">alignment</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">from</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id9">
<h5>Overview:<a class="headerlink" href="#id9" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.promise</span></code>’ intrinsic obtains a pointer to a
<a class="reference internal" href="#coroutine-promise">coroutine promise</a> given a switched-resume coroutine handle and vice versa.</p>
</section>
<section id="id10">
<h5>Arguments:<a class="headerlink" href="#id10" title="Link to this heading">¶</a></h5>
<p>The first argument is a handle to a coroutine if <cite>from</cite> is false. Otherwise,
it is a pointer to a coroutine promise.</p>
<p>The second argument is an alignment requirements of the promise.
If a frontend designated <cite>%promise = alloca i32</cite> as a promise, the alignment
argument to <cite>coro.promise</cite> should be the alignment of <cite>i32</cite> on the target
platform. If a frontend designated <cite>%promise = alloca i32, align 16</cite> as a
promise, the alignment argument should be 16.
This argument only accepts constants.</p>
<p>The third argument is a boolean indicating a direction of the transformation.
If <cite>from</cite> is true, the intrinsic returns a coroutine handle given a pointer
to a promise. If <cite>from</cite> is false, the intrinsics return a pointer to a promise
from a coroutine handle. This argument only accepts constants.</p>
</section>
<section id="id11">
<h5>Semantics:<a class="headerlink" href="#id11" title="Link to this heading">¶</a></h5>
<p>Using this intrinsic on a coroutine that does not have a coroutine promise
leads to undefined behavior. It is possible to read and modify coroutine
promise of the coroutine which is currently executing. The coroutine author and
a coroutine user are responsible to makes sure there is no data races.</p>
</section>
<section id="example">
<h5>Example:<a class="headerlink" href="#example" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@f</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%promise</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i32</span>
<span class="w">  </span><span class="c">; the second argument to coro.id points to the coroutine promise.</span>
<span class="w">  </span><span class="nv">%id</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="vg">@llvm.coro.id</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%promise</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">null</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">null</span><span class="p">)</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="nv">%hdl</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">noalias</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.coro.begin</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%id</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%alloc</span><span class="p">)</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">42</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%promise</span><span class="w"> </span><span class="c">; store something into the promise</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span>
<span class="p">}</span>

<span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%hdl</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@f</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">4</span><span class="p">)</span><span class="w"> </span><span class="c">; starts the coroutine and returns its handle</span>
<span class="w">  </span><span class="nv">%promise.addr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.coro.promise</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%val</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%promise.addr</span><span class="w"> </span><span class="c">; load a value from the promise</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@print</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%val</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.coro.destroy</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="coroutine-structure-intrinsics">
<span id="coroutine-intrinsics"></span><h3><a class="toc-backref" href="#id105" role="doc-backlink">Coroutine Structure Intrinsics</a><a class="headerlink" href="#coroutine-structure-intrinsics" title="Link to this heading">¶</a></h3>
<p>Intrinsics described in this section are used within a coroutine to describe
the coroutine structure. They should not be used outside of a coroutine.</p>
<section id="llvm-coro-size-intrinsic">
<span id="coro-size"></span><h4><a class="toc-backref" href="#id106" role="doc-backlink">‘llvm.coro.size’ Intrinsic</a><a class="headerlink" href="#llvm-coro-size-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i32</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">i32</span><span class="p">()</span>
<span class="n">declare</span> <span class="n">i64</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">i64</span><span class="p">()</span>
</pre></div>
</div>
<section id="id12">
<h5>Overview:<a class="headerlink" href="#id12" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.size</span></code>’ intrinsic returns the number of bytes
required to store a <a class="reference internal" href="#coroutine-frame">coroutine frame</a>.  This is only supported for
switched-resume coroutines.</p>
</section>
<section id="id13">
<h5>Arguments:<a class="headerlink" href="#id13" title="Link to this heading">¶</a></h5>
<p>None</p>
</section>
<section id="id14">
<h5>Semantics:<a class="headerlink" href="#id14" title="Link to this heading">¶</a></h5>
<p>The <cite>coro.size</cite> intrinsic is lowered to a constant representing the size of
the coroutine frame.</p>
</section>
</section>
<section id="llvm-coro-align-intrinsic">
<span id="coro-align"></span><h4><a class="toc-backref" href="#id107" role="doc-backlink">‘llvm.coro.align’ Intrinsic</a><a class="headerlink" href="#llvm-coro-align-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i32</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">align</span><span class="o">.</span><span class="n">i32</span><span class="p">()</span>
<span class="n">declare</span> <span class="n">i64</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">align</span><span class="o">.</span><span class="n">i64</span><span class="p">()</span>
</pre></div>
</div>
<section id="id15">
<h5>Overview:<a class="headerlink" href="#id15" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.align</span></code>’ intrinsic returns the alignment of a <a class="reference internal" href="#coroutine-frame">coroutine frame</a>.
This is only supported for switched-resume coroutines.</p>
</section>
<section id="id16">
<h5>Arguments:<a class="headerlink" href="#id16" title="Link to this heading">¶</a></h5>
<p>None</p>
</section>
<section id="id17">
<h5>Semantics:<a class="headerlink" href="#id17" title="Link to this heading">¶</a></h5>
<p>The <cite>coro.align</cite> intrinsic is lowered to a constant representing the alignment of
the coroutine frame.</p>
</section>
</section>
<section id="llvm-coro-begin-intrinsic">
<span id="coro-begin"></span><h4><a class="toc-backref" href="#id108" role="doc-backlink">‘llvm.coro.begin’ Intrinsic</a><a class="headerlink" href="#llvm-coro-begin-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">ptr</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">begin</span><span class="p">(</span><span class="n">token</span> <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">mem</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id18">
<h5>Overview:<a class="headerlink" href="#id18" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.begin</span></code>’ intrinsic returns an address of the coroutine frame.</p>
</section>
<section id="id19">
<h5>Arguments:<a class="headerlink" href="#id19" title="Link to this heading">¶</a></h5>
<p>The first argument is a token returned by a call to ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.id</span></code>’
identifying the coroutine.</p>
<p>The second argument is a pointer to a block of memory where coroutine frame
will be stored if it is allocated dynamically.  This pointer is ignored
for returned-continuation coroutines.</p>
</section>
<section id="id20">
<h5>Semantics:<a class="headerlink" href="#id20" title="Link to this heading">¶</a></h5>
<p>Depending on the alignment requirements of the objects in the coroutine frame
and/or on the codegen compactness reasons the pointer returned from <cite>coro.begin</cite>
may be at offset to the <cite>%mem</cite> argument. (This could be beneficial if
instructions that express relative access to data can be more compactly encoded
with small positive and negative offsets).</p>
<p>A frontend should emit exactly one <cite>coro.begin</cite> intrinsic per coroutine.</p>
</section>
</section>
<section id="llvm-coro-begin-custom-abi-intrinsic">
<span id="coro-begin-custom-abi"></span><h4><a class="toc-backref" href="#id109" role="doc-backlink">‘llvm.coro.begin.custom.abi’ Intrinsic</a><a class="headerlink" href="#llvm-coro-begin-custom-abi-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">ptr</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">begin</span><span class="o">.</span><span class="n">custom</span><span class="o">.</span><span class="n">abi</span><span class="p">(</span><span class="n">token</span> <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">mem</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span><span class="p">)</span>
</pre></div>
</div>
<section id="id21">
<h5>Overview:<a class="headerlink" href="#id21" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.begin.custom.abi</span></code>’ intrinsic is used in place of the
<cite>coro.begin</cite> intrinsic that has an additional parameter to specify the custom
ABI for the coroutine. The return is identical to that of the <cite>coro.begin</cite>
intrinsic.</p>
</section>
<section id="id22">
<h5>Arguments:<a class="headerlink" href="#id22" title="Link to this heading">¶</a></h5>
<p>The first and second arguments are identical to those of the <cite>coro.begin</cite>
intrinsic.</p>
<p>The third argument is an i32 index of the generator list given to the
<cite>CoroSplit</cite> pass specifying the custom ABI generator for this coroutine.</p>
</section>
<section id="id23">
<h5>Semantics:<a class="headerlink" href="#id23" title="Link to this heading">¶</a></h5>
<p>The semantics are identical to those of the <cite>coro.begin</cite> intrinsic.</p>
</section>
</section>
<section id="llvm-coro-free-intrinsic">
<span id="coro-free"></span><h4><a class="toc-backref" href="#id110" role="doc-backlink">‘llvm.coro.free’ Intrinsic</a><a class="headerlink" href="#llvm-coro-free-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">ptr</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">free</span><span class="p">(</span><span class="n">token</span> <span class="o">%</span><span class="nb">id</span><span class="p">,</span> <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">frame</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id24">
<h5>Overview:<a class="headerlink" href="#id24" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.free</span></code>’ intrinsic returns a pointer to a block of memory where
coroutine frame is stored or <cite>null</cite> if this instance of a coroutine did not use
dynamically allocated memory for its coroutine frame.  This intrinsic is not
supported for returned-continuation coroutines.</p>
</section>
<section id="id25">
<h5>Arguments:<a class="headerlink" href="#id25" title="Link to this heading">¶</a></h5>
<p>The first argument is a token returned by a call to ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.id</span></code>’
identifying the coroutine.</p>
<p>The second argument is a pointer to the coroutine frame. This should be the same
pointer that was returned by prior <cite>coro.begin</cite> call.</p>
</section>
<section id="example-custom-deallocation-function">
<h5>Example (custom deallocation function):<a class="headerlink" href="#example-custom-deallocation-function" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nl">cleanup:</span>
<span class="w">  </span><span class="nv">%mem</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.coro.free</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%id</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%frame</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%mem_not_null</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">ne</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%mem</span><span class="p">,</span><span class="w"> </span><span class="k">null</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%mem_not_null</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%if.then</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%if.end</span>
<span class="nl">if.then:</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@CustomFree</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%mem</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%if.end</span>
<span class="nl">if.end:</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="k">void</span>
</pre></div>
</div>
</section>
<section id="example-standard-deallocation-functions">
<h5>Example (standard deallocation functions):<a class="headerlink" href="#example-standard-deallocation-functions" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nl">cleanup:</span>
<span class="w">  </span><span class="nv">%mem</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.coro.free</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%id</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%frame</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@free</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%mem</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="k">void</span>
</pre></div>
</div>
</section>
</section>
<section id="llvm-coro-alloc-intrinsic">
<span id="coro-alloc"></span><h4><a class="toc-backref" href="#id111" role="doc-backlink">‘llvm.coro.alloc’ Intrinsic</a><a class="headerlink" href="#llvm-coro-alloc-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i1</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">alloc</span><span class="p">(</span><span class="n">token</span> <span class="o">&lt;</span><span class="nb">id</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id26">
<h5>Overview:<a class="headerlink" href="#id26" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.alloc</span></code>’ intrinsic returns <cite>true</cite> if dynamic allocation is
required to obtain a memory for the coroutine frame and <cite>false</cite> otherwise.
This is not supported for returned-continuation coroutines.</p>
</section>
<section id="id27">
<h5>Arguments:<a class="headerlink" href="#id27" title="Link to this heading">¶</a></h5>
<p>The first argument is a token returned by a call to ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.id</span></code>’
identifying the coroutine.</p>
</section>
<section id="id28">
<h5>Semantics:<a class="headerlink" href="#id28" title="Link to this heading">¶</a></h5>
<p>A frontend should emit at most one <cite>coro.alloc</cite> intrinsic per coroutine.
The intrinsic is used to suppress dynamic allocation of the coroutine frame
when possible.</p>
</section>
<section id="id29">
<h5>Example:<a class="headerlink" href="#id29" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%id</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="vg">@llvm.coro.id</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">null</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">null</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">null</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%dyn.alloc.required</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.coro.alloc</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%id</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%dyn.alloc.required</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%coro.alloc</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%coro.begin</span>

<span class="nl">coro.alloc:</span>
<span class="w">  </span><span class="nv">%frame.size</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@llvm.coro.size</span><span class="p">()</span>
<span class="w">  </span><span class="nv">%alloc</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@MyAlloc</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%frame.size</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%coro.begin</span>

<span class="nl">coro.begin:</span>
<span class="w">  </span><span class="nv">%phi</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="k">null</span><span class="p">,</span><span class="w"> </span><span class="nv">%entry</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%alloc</span><span class="p">,</span><span class="w"> </span><span class="nv">%coro.alloc</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="nv">%frame</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.coro.begin</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%id</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%phi</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="llvm-coro-noop-intrinsic">
<span id="coro-noop"></span><h4><a class="toc-backref" href="#id112" role="doc-backlink">‘llvm.coro.noop’ Intrinsic</a><a class="headerlink" href="#llvm-coro-noop-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">ptr</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">noop</span><span class="p">()</span>
</pre></div>
</div>
<section id="id30">
<h5>Overview:<a class="headerlink" href="#id30" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.noop</span></code>’ intrinsic returns an address of the coroutine frame of
a coroutine that does nothing when resumed or destroyed.</p>
</section>
<section id="id31">
<h5>Arguments:<a class="headerlink" href="#id31" title="Link to this heading">¶</a></h5>
<p>None</p>
</section>
<section id="id32">
<h5>Semantics:<a class="headerlink" href="#id32" title="Link to this heading">¶</a></h5>
<p>This intrinsic is lowered to refer to a private constant coroutine frame. The
resume and destroy handlers for this frame are empty functions that do nothing.
Note that in different translation units llvm.coro.noop may return different pointers.</p>
</section>
</section>
<section id="llvm-coro-frame-intrinsic">
<span id="coro-frame"></span><h4><a class="toc-backref" href="#id113" role="doc-backlink">‘llvm.coro.frame’ Intrinsic</a><a class="headerlink" href="#llvm-coro-frame-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">ptr</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">frame</span><span class="p">()</span>
</pre></div>
</div>
<section id="id33">
<h5>Overview:<a class="headerlink" href="#id33" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.frame</span></code>’ intrinsic returns an address of the coroutine frame of
the enclosing coroutine.</p>
</section>
<section id="id34">
<h5>Arguments:<a class="headerlink" href="#id34" title="Link to this heading">¶</a></h5>
<p>None</p>
</section>
<section id="id35">
<h5>Semantics:<a class="headerlink" href="#id35" title="Link to this heading">¶</a></h5>
<p>This intrinsic is lowered to refer to the <a class="reference internal" href="#coro-begin">coro.begin</a> instruction. This is
a frontend convenience intrinsic that makes it easier to refer to the
coroutine frame.</p>
</section>
</section>
<section id="llvm-coro-id-intrinsic">
<span id="coro-id"></span><h4><a class="toc-backref" href="#id114" role="doc-backlink">‘llvm.coro.id’ Intrinsic</a><a class="headerlink" href="#llvm-coro-id-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">token</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">id</span><span class="p">(</span><span class="n">i32</span> <span class="o">&lt;</span><span class="n">align</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">promise</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">coroaddr</span><span class="o">&gt;</span><span class="p">,</span>
                                                        <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">fnaddrs</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id36">
<h5>Overview:<a class="headerlink" href="#id36" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.id</span></code>’ intrinsic returns a token identifying a
switched-resume coroutine.</p>
</section>
<section id="id37">
<h5>Arguments:<a class="headerlink" href="#id37" title="Link to this heading">¶</a></h5>
<p>The first argument provides information on the alignment of the memory returned
by the allocation function and given to <cite>coro.begin</cite> by the first argument. If
this argument is 0, the memory is assumed to be aligned to 2 * sizeof(ptr).
This argument only accepts constants.</p>
<p>The second argument, if not <cite>null</cite>, designates a particular alloca instruction
to be a <a class="reference internal" href="#coroutine-promise">coroutine promise</a>.</p>
<p>The third argument is <cite>null</cite> coming out of the frontend. The CoroEarly pass sets
this argument to point to the function this coro.id belongs to.</p>
<p>The fourth argument is <cite>null</cite> before coroutine is split, and later is replaced
to point to a private global constant array containing function pointers to
outlined resume and destroy parts of the coroutine.</p>
</section>
<section id="id38">
<h5>Semantics:<a class="headerlink" href="#id38" title="Link to this heading">¶</a></h5>
<p>The purpose of this intrinsic is to tie together <cite>coro.id</cite>, <cite>coro.alloc</cite> and
<cite>coro.begin</cite> belonging to the same coroutine to prevent optimization passes from
duplicating any of these instructions unless entire body of the coroutine is
duplicated.</p>
<p>A frontend should emit exactly one <cite>coro.id</cite> intrinsic per coroutine.</p>
<p>A frontend should emit function attribute <cite>presplitcoroutine</cite> for the coroutine.</p>
</section>
</section>
<section id="llvm-coro-id-async-intrinsic">
<span id="coro-id-async"></span><h4><a class="toc-backref" href="#id115" role="doc-backlink">‘llvm.coro.id.async’ Intrinsic</a><a class="headerlink" href="#llvm-coro-id-async-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">token</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="k">async</span><span class="p">(</span><span class="n">i32</span> <span class="o">&lt;</span><span class="n">context</span> <span class="n">size</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">align</span><span class="o">&gt;</span><span class="p">,</span>
                                  <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">context</span> <span class="n">arg</span><span class="o">&gt;</span><span class="p">,</span>
                                  <span class="n">ptr</span> <span class="o">&lt;</span><span class="k">async</span> <span class="n">function</span> <span class="n">pointer</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id39">
<h5>Overview:<a class="headerlink" href="#id39" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.id.async</span></code>’ intrinsic returns a token identifying an async coroutine.</p>
</section>
<section id="id40">
<h5>Arguments:<a class="headerlink" href="#id40" title="Link to this heading">¶</a></h5>
<p>The first argument provides the initial size of the <cite>async context</cite> as required
from the frontend. Lowering will add to this size the size required by the frame
storage and store that value to the <cite>async function pointer</cite>.</p>
<p>The second argument, is the alignment guarantee of the memory of the
<cite>async context</cite>. The frontend guarantees that the memory will be aligned by this
value.</p>
<p>The third argument is the <cite>async context</cite> argument in the current coroutine.</p>
<p>The fourth argument is the address of the <cite>async function pointer</cite> struct.
Lowering will update the context size requirement in this struct by adding the
coroutine frame size requirement to the initial size requirement as specified by
the first argument of this intrinsic.</p>
</section>
<section id="id41">
<h5>Semantics:<a class="headerlink" href="#id41" title="Link to this heading">¶</a></h5>
<p>A frontend should emit exactly one <cite>coro.id.async</cite> intrinsic per coroutine.</p>
<p>A frontend should emit function attribute <cite>presplitcoroutine</cite> for the coroutine.</p>
</section>
</section>
<section id="llvm-coro-id-retcon-intrinsic">
<span id="coro-id-retcon"></span><h4><a class="toc-backref" href="#id116" role="doc-backlink">‘llvm.coro.id.retcon’ Intrinsic</a><a class="headerlink" href="#llvm-coro-id-retcon-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">token</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">retcon</span><span class="p">(</span><span class="n">i32</span> <span class="o">&lt;</span><span class="n">size</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">align</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">buffer</span><span class="o">&gt;</span><span class="p">,</span>
                                   <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">continuation</span> <span class="n">prototype</span><span class="o">&gt;</span><span class="p">,</span>
                                   <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">alloc</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">dealloc</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id42">
<h5>Overview:<a class="headerlink" href="#id42" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.id.retcon</span></code>’ intrinsic returns a token identifying a
multiple-suspend returned-continuation coroutine.</p>
<p>The ‘result-type sequence’ of the coroutine is defined as follows:</p>
<ul class="simple">
<li><p>if the return type of the coroutine function is <code class="docutils literal notranslate"><span class="pre">void</span></code>, it is the
empty sequence;</p></li>
<li><p>if the return type of the coroutine function is a <code class="docutils literal notranslate"><span class="pre">struct</span></code>, it is the
element types of that <code class="docutils literal notranslate"><span class="pre">struct</span></code> in order;</p></li>
<li><p>otherwise, it is just the return type of the coroutine function.</p></li>
</ul>
<p>The first element of the result-type sequence must be a pointer type;
continuation functions will be coerced to this type.  The rest of
the sequence are the ‘yield types’, and any suspends in the coroutine
must take arguments of these types.</p>
</section>
<section id="id43">
<h5>Arguments:<a class="headerlink" href="#id43" title="Link to this heading">¶</a></h5>
<p>The first and second arguments are the expected size and alignment of
the buffer provided as the third argument.  They must be constant.</p>
<p>The fourth argument must be a reference to a global function, called
the ‘continuation prototype function’.  The type, calling convention,
and attributes of any continuation functions will be taken from this
declaration.  The return type of the prototype function must match the
return type of the current function.  The first parameter type must be
a pointer type.  The second parameter type must be an integer type;
it will be used only as a boolean flag.</p>
<p>The fifth argument must be a reference to a global function that will
be used to allocate memory.  It may not fail, either by returning null
or throwing an exception.  It must take an integer and return a pointer.</p>
<p>The sixth argument must be a reference to a global function that will
be used to deallocate memory.  It must take a pointer and return <code class="docutils literal notranslate"><span class="pre">void</span></code>.</p>
</section>
<section id="id44">
<h5>Semantics:<a class="headerlink" href="#id44" title="Link to this heading">¶</a></h5>
<p>A frontend should emit function attribute <cite>presplitcoroutine</cite> for the coroutine.</p>
</section>
</section>
<section id="llvm-coro-id-retcon-once-intrinsic">
<h4><a class="toc-backref" href="#id117" role="doc-backlink">‘llvm.coro.id.retcon.once’ Intrinsic</a><a class="headerlink" href="#llvm-coro-id-retcon-once-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">token</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">retcon</span><span class="o">.</span><span class="n">once</span><span class="p">(</span><span class="n">i32</span> <span class="o">&lt;</span><span class="n">size</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i32</span> <span class="o">&lt;</span><span class="n">align</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">buffer</span><span class="o">&gt;</span><span class="p">,</span>
                                        <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">prototype</span><span class="o">&gt;</span><span class="p">,</span>
                                        <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">alloc</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">dealloc</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id45">
<h5>Overview:<a class="headerlink" href="#id45" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.id.retcon.once</span></code>’ intrinsic returns a token identifying a
unique-suspend returned-continuation coroutine.</p>
</section>
<section id="id46">
<h5>Arguments:<a class="headerlink" href="#id46" title="Link to this heading">¶</a></h5>
<p>As for <code class="docutils literal notranslate"><span class="pre">llvm.core.id.retcon</span></code>, except that the return type of the
continuation prototype must represent the normal return type of the continuation
(instead of matching the coroutine’s return type).</p>
</section>
<section id="id47">
<h5>Semantics:<a class="headerlink" href="#id47" title="Link to this heading">¶</a></h5>
<p>A frontend should emit function attribute <cite>presplitcoroutine</cite> for the coroutine.</p>
</section>
</section>
<section id="llvm-coro-end-intrinsic">
<span id="coro-end"></span><h4><a class="toc-backref" href="#id118" role="doc-backlink">‘llvm.coro.end’ Intrinsic</a><a class="headerlink" href="#llvm-coro-end-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i1</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">end</span><span class="p">(</span><span class="n">ptr</span> <span class="o">&lt;</span><span class="n">handle</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">unwind</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">token</span> <span class="o">&lt;</span><span class="n">result</span><span class="o">.</span><span class="n">token</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id48">
<h5>Overview:<a class="headerlink" href="#id48" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.end</span></code>’ marks the point where execution of the resume part of
the coroutine should end and control should return to the caller.</p>
</section>
<section id="id49">
<h5>Arguments:<a class="headerlink" href="#id49" title="Link to this heading">¶</a></h5>
<p>The first argument should refer to the coroutine handle of the enclosing
coroutine. A frontend is allowed to supply null as the first parameter, in this
case <cite>coro-early</cite> pass will replace the null with an appropriate coroutine
handle value.</p>
<p>The second argument should be <cite>true</cite> if this coro.end is in the block that is
part of the unwind sequence leaving the coroutine body due to an exception and
<cite>false</cite> otherwise.</p>
<p>Non-trivial (non-none) token argument can only be specified for unique-suspend
returned-continuation coroutines where it must be a token value produced by
‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.end.results</span></code>’ intrinsic.</p>
<p>Only none token is allowed for coro.end calls in unwind sections</p>
</section>
<section id="id50">
<h5>Semantics:<a class="headerlink" href="#id50" title="Link to this heading">¶</a></h5>
<p>The purpose of this intrinsic is to allow frontends to mark the cleanup and
other code that is only relevant during the initial invocation of the coroutine
and should not be present in resume and destroy parts.</p>
<p>In returned-continuation lowering, <code class="docutils literal notranslate"><span class="pre">llvm.coro.end</span></code> fully destroys the
coroutine frame.  If the second argument is <cite>false</cite>, it also returns from
the coroutine with a null continuation pointer, and the next instruction
will be unreachable.  If the second argument is <cite>true</cite>, it falls through
so that the following logic can resume unwinding.  In a yield-once
coroutine, reaching a non-unwind <code class="docutils literal notranslate"><span class="pre">llvm.coro.end</span></code> without having first
reached a <code class="docutils literal notranslate"><span class="pre">llvm.coro.suspend.retcon</span></code> has undefined behavior.</p>
<p>The remainder of this section describes the behavior under switched-resume
lowering.</p>
<p>This intrinsic is lowered when a coroutine is split into
the start, resume and destroy parts. In the start part, it is a no-op,
in resume and destroy parts, it is replaced with <cite>ret void</cite> instruction and
the rest of the block containing <cite>coro.end</cite> instruction is discarded.
In landing pads it is replaced with an appropriate instruction to unwind to
caller. The handling of coro.end differs depending on whether the target is
using landingpad or WinEH exception model.</p>
<p>For landingpad based exception model, it is expected that frontend uses the
<a class="reference internal" href="#coro-end">coro.end</a> intrinsic as follows:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nl">ehcleanup:</span>
<span class="w">  </span><span class="nv">%InResumePart</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.coro.end</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">null</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">true</span><span class="p">,</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="k">none</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%InResumePart</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%eh.resume</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%cleanup.cont</span>

<span class="nl">cleanup.cont:</span>
<span class="w">  </span><span class="c">; rest of the cleanup</span>

<span class="nl">eh.resume:</span>
<span class="w">  </span><span class="nv">%exn</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%exn.slot</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">8</span>
<span class="w">  </span><span class="nv">%sel</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%ehselector.slot</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
<span class="w">  </span><span class="nv">%lpad.val</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">insertvalue</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">undef</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%exn</span><span class="p">,</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="nv">%lpad.val29</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">insertvalue</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="nv">%lpad.val</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%sel</span><span class="p">,</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="k">resume</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="nv">%lpad.val29</span>
</pre></div>
</div>
<p>The <cite>CoroSpit</cite> pass replaces <cite>coro.end</cite> with <code class="docutils literal notranslate"><span class="pre">True</span></code> in the resume functions,
thus leading to immediate unwind to the caller, whereas in start function it
is replaced with <code class="docutils literal notranslate"><span class="pre">False</span></code>, thus allowing to proceed to the rest of the cleanup
code that is only needed during initial invocation of the coroutine.</p>
<p>For Windows Exception handling model, a frontend should attach a funclet bundle
referring to an enclosing cleanuppad as follows:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nl">ehcleanup:</span>
<span class="w">  </span><span class="nv">%tok</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">cleanuppad</span><span class="w"> </span><span class="k">within</span><span class="w"> </span><span class="k">none</span><span class="w"> </span><span class="p">[]</span>
<span class="w">  </span><span class="nv">%unused</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.coro.end</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">null</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">true</span><span class="p">,</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="k">none</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="s">&quot;funclet&quot;</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%tok</span><span class="p">)</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="k">cleanupret</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="nv">%tok</span><span class="w"> </span><span class="k">unwind</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%RestOfTheCleanup</span>
</pre></div>
</div>
<p>The <cite>CoroSplit</cite> pass, if the funclet bundle is present, will insert
<code class="docutils literal notranslate"><span class="pre">cleanupret</span> <span class="pre">from</span> <span class="pre">%tok</span> <span class="pre">unwind</span> <span class="pre">to</span> <span class="pre">caller</span></code> before
the <a class="reference internal" href="#coro-end">coro.end</a> intrinsic and will remove the rest of the block.</p>
<p>In the unwind path (when the argument is <cite>true</cite>), <cite>coro.end</cite> will mark the coroutine
as done, making it undefined behavior to resume the coroutine again and causing
<cite>llvm.coro.done</cite> to return <cite>true</cite>.  This is not necessary in the normal path because
the coroutine will already be marked as done by the final suspend.</p>
<p>The following table summarizes the handling of <a class="reference internal" href="#coro-end">coro.end</a> intrinsic.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td colspan="2"></td>
<td><p>In Start Function</p></td>
<td><p>In Resume/Destroy Functions</p></td>
</tr>
<tr class="row-even"><td colspan="2"><p>unwind=false</p></td>
<td><p>nothing</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ret</span> <span class="pre">void</span></code></p></td>
</tr>
<tr class="row-odd"><td rowspan="2"><p>unwind=true</p></td>
<td><p>WinEH</p></td>
<td><p>mark coroutine as done</p></td>
<td><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">cleanupret</span> <span class="pre">unwind</span> <span class="pre">to</span> <span class="pre">caller</span></code></div>
<div class="line">mark coroutine done</div>
</div>
</td>
</tr>
<tr class="row-even"><td><p>Landingpad</p></td>
<td><p>mark coroutine as done</p></td>
<td><p>mark coroutine done</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="llvm-coro-end-results-intrinsic">
<span id="coro-end-results"></span><h4><a class="toc-backref" href="#id119" role="doc-backlink">‘llvm.coro.end.results’ Intrinsic</a><a class="headerlink" href="#llvm-coro-end-results-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">token</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">results</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<section id="id51">
<h5>Overview:<a class="headerlink" href="#id51" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.end.results</span></code>’ intrinsic captures values to be returned from
unique-suspend returned-continuation coroutines.</p>
</section>
<section id="id52">
<h5>Arguments:<a class="headerlink" href="#id52" title="Link to this heading">¶</a></h5>
<p>The number of arguments must match the return type of the continuation function:</p>
<ul class="simple">
<li><p>if the return type of the continuation function is <code class="docutils literal notranslate"><span class="pre">void</span></code> there must be no
arguments</p></li>
<li><p>if the return type of the continuation function is a <code class="docutils literal notranslate"><span class="pre">struct</span></code>, the arguments
will be of element types of that <code class="docutils literal notranslate"><span class="pre">struct</span></code> in order;</p></li>
<li><p>otherwise, it is just the return value of the continuation function.</p></li>
</ul>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="p">{</span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="p">}</span><span class="w"> </span><span class="vg">@g</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%val</span><span class="p">)</span><span class="w"> </span><span class="err">presplitcorouti</span><span class="k">ne</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%id</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="vg">@llvm.coro.id.retcon.once</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="m">8</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">8</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%buffer</span><span class="p">,</span>
<span class="w">                                             </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@prototype</span><span class="p">,</span>
<span class="w">                                             </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@allocate</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@deallocate</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%hdl</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@llvm.coro.begin</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%id</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">null</span><span class="p">)</span>

<span class="p">...</span>

<span class="nl">cleanup:</span>
<span class="w">  </span><span class="nv">%tok</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="p">(...)</span><span class="w"> </span><span class="vg">@llvm.coro.end.results</span><span class="p">(</span><span class="kt">i8</span><span class="w"> </span><span class="nv">%val</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.coro.end</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="nv">%tok</span><span class="p">)</span>
<span class="w">  </span><span class="k">unreachable</span>

<span class="p">...</span>

<span class="k">declare</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="vg">@prototype</span><span class="p">(</span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">zeroext</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="llvm-coro-end-async-intrinsic">
<h4><a class="toc-backref" href="#id120" role="doc-backlink">‘llvm.coro.end.async’ Intrinsic</a><a class="headerlink" href="#llvm-coro-end-async-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i1</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="k">async</span><span class="p">(</span><span class="n">ptr</span> <span class="o">&lt;</span><span class="n">handle</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">unwind</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<section id="id53">
<h5>Overview:<a class="headerlink" href="#id53" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.end.async</span></code>’ marks the point where execution of the resume part
of the coroutine should end and control should return to the caller. As part of
its variable tail arguments this instruction allows to specify a function and
the function’s arguments that are to be tail called as the last action before
returning.</p>
</section>
<section id="id54">
<h5>Arguments:<a class="headerlink" href="#id54" title="Link to this heading">¶</a></h5>
<p>The first argument should refer to the coroutine handle of the enclosing
coroutine. A frontend is allowed to supply null as the first parameter, in this
case <cite>coro-early</cite> pass will replace the null with an appropriate coroutine
handle value.</p>
<p>The second argument should be <cite>true</cite> if this coro.end is in the block that is
part of the unwind sequence leaving the coroutine body due to an exception and
<cite>false</cite> otherwise.</p>
<p>The third argument if present should specify a function to be called.</p>
<p>If the third argument is present, the remaining arguments are the arguments to
the function call.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">call</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="p">(</span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="vg">@llvm.coro.end.async</span><span class="p">(</span>
<span class="w">                         </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="m">0</span><span class="p">,</span>
<span class="w">                         </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@must_tail_call_return</span><span class="p">,</span>
<span class="w">                         </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%ctxt</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%task</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%actor</span><span class="p">)</span>
<span class="k">unreachable</span>
</pre></div>
</div>
</section>
</section>
<section id="llvm-coro-suspend-intrinsic">
<span id="suspend-points"></span><span id="coro-suspend"></span><h4><a class="toc-backref" href="#id121" role="doc-backlink">‘llvm.coro.suspend’ Intrinsic</a><a class="headerlink" href="#llvm-coro-suspend-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i8</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">suspend</span><span class="p">(</span><span class="n">token</span> <span class="o">&lt;</span><span class="n">save</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">i1</span> <span class="o">&lt;</span><span class="n">final</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id55">
<h5>Overview:<a class="headerlink" href="#id55" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.suspend</span></code>’ marks the point where execution of a
switched-resume coroutine is suspended and control is returned back
to the caller.  Conditional branches consuming the result of this
intrinsic lead to basic blocks where coroutine should proceed when
suspended (-1), resumed (0) or destroyed (1).</p>
</section>
<section id="id56">
<h5>Arguments:<a class="headerlink" href="#id56" title="Link to this heading">¶</a></h5>
<p>The first argument refers to a token of <cite>coro.save</cite> intrinsic that marks the
point when coroutine state is prepared for suspension. If <cite>none</cite> token is passed,
the intrinsic behaves as if there were a <cite>coro.save</cite> immediately preceding
the <cite>coro.suspend</cite> intrinsic.</p>
<p>The second argument indicates whether this suspension point is <a class="reference internal" href="#final">final</a>.
The second argument only accepts constants. If more than one suspend point is
designated as final, the resume and destroy branches should lead to the same
basic blocks.</p>
</section>
<section id="example-normal-suspend-point">
<h5>Example (normal suspend point):<a class="headerlink" href="#example-normal-suspend-point" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">%0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="vg">@llvm.coro.suspend</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="k">none</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">)</span>
<span class="k">switch</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv nv-Anonymous">%0</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%suspend</span><span class="w"> </span><span class="p">[</span><span class="kt">i8</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%resume</span>
<span class="w">                              </span><span class="kt">i8</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%cleanup</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="example-final-suspend-point">
<h5>Example (final suspend point):<a class="headerlink" href="#example-final-suspend-point" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nl">while.end:</span>
<span class="w">  </span><span class="nv">%s.final</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="vg">@llvm.coro.suspend</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="k">none</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">true</span><span class="p">)</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%s.final</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%suspend</span><span class="w"> </span><span class="p">[</span><span class="kt">i8</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%trap</span>
<span class="w">                                      </span><span class="kt">i8</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%cleanup</span><span class="p">]</span>
<span class="nl">trap:</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.trap</span><span class="p">()</span>
<span class="w">  </span><span class="k">unreachable</span>
</pre></div>
</div>
</section>
<section id="id57">
<h5>Semantics:<a class="headerlink" href="#id57" title="Link to this heading">¶</a></h5>
<p>If a coroutine that was suspended at the suspend point marked by this intrinsic
is resumed via <a class="reference internal" href="#coro-resume">coro.resume</a> the control will transfer to the basic block
of the 0-case. If it is resumed via <a class="reference internal" href="#coro-destroy">coro.destroy</a>, it will proceed to the
basic block indicated by the 1-case. To suspend, coroutine proceed to the
default label.</p>
<p>If suspend intrinsic is marked as final, it can consider the <cite>true</cite> branch
unreachable and can perform optimizations that can take advantage of that fact.</p>
</section>
</section>
<section id="llvm-coro-save-intrinsic">
<span id="coro-save"></span><h4><a class="toc-backref" href="#id122" role="doc-backlink">‘llvm.coro.save’ Intrinsic</a><a class="headerlink" href="#llvm-coro-save-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">token</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">ptr</span> <span class="o">&lt;</span><span class="n">handle</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id58">
<h5>Overview:<a class="headerlink" href="#id58" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.save</span></code>’ marks the point where a coroutine need to update its
state to prepare for resumption to be considered suspended (and thus eligible
for resumption). It is illegal to merge two ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.save</span></code>’ calls unless their
‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.suspend</span></code>’ users are also merged. So ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.save</span></code>’ is currently
tagged with the <cite>no_merge</cite> function attribute.</p>
</section>
<section id="id59">
<h5>Arguments:<a class="headerlink" href="#id59" title="Link to this heading">¶</a></h5>
<p>The first argument points to a coroutine handle of the enclosing coroutine.</p>
</section>
<section id="id60">
<h5>Semantics:<a class="headerlink" href="#id60" title="Link to this heading">¶</a></h5>
<p>Whatever coroutine state changes are required to enable resumption of
the coroutine from the corresponding suspend point should be done at the point
of <cite>coro.save</cite> intrinsic.</p>
</section>
<section id="id61">
<h5>Example:<a class="headerlink" href="#id61" title="Link to this heading">¶</a></h5>
<p>Separate save and suspend points are necessary when a coroutine is used to
represent an asynchronous control flow driven by callbacks representing
completions of asynchronous operations.</p>
<p>In such a case, a coroutine should be ready for resumption prior to a call to
<cite>async_op</cite> function that may trigger resumption of a coroutine from the same or
a different thread possibly prior to <cite>async_op</cite> call returning control back
to the coroutine:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv">%save1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="vg">@llvm.coro.save</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@async_op1</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="nv">%suspend1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.coro.suspend</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%save1</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">)</span>
<span class="k">switch</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%suspend1</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%suspend</span><span class="w"> </span><span class="p">[</span><span class="kt">i8</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%resume1</span>
<span class="w">                                     </span><span class="kt">i8</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%cleanup</span><span class="p">]</span>
</pre></div>
</div>
</section>
</section>
<section id="llvm-coro-suspend-async-intrinsic">
<span id="coro-suspend-async"></span><h4><a class="toc-backref" href="#id123" role="doc-backlink">‘llvm.coro.suspend.async’ Intrinsic</a><a class="headerlink" href="#llvm-coro-suspend-async-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="p">{</span><span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">}</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">suspend</span><span class="o">.</span><span class="k">async</span><span class="p">(</span>
                           <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">resume</span> <span class="n">function</span><span class="o">&gt;</span><span class="p">,</span>
                           <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">context</span> <span class="n">projection</span> <span class="n">function</span><span class="o">&gt;</span><span class="p">,</span>
                           <span class="o">...</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">to</span> <span class="n">call</span><span class="o">&gt;</span>
                           <span class="o">...</span> <span class="o">&lt;</span><span class="n">arguments</span> <span class="n">to</span> <span class="n">function</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id62">
<h5>Overview:<a class="headerlink" href="#id62" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.suspend.async</span></code>’ intrinsic marks the point where
execution of an async coroutine is suspended and control is passed to a callee.</p>
</section>
<section id="id63">
<h5>Arguments:<a class="headerlink" href="#id63" title="Link to this heading">¶</a></h5>
<p>The first argument should be the result of the <cite>llvm.coro.async.resume</cite> intrinsic.
Lowering will replace this intrinsic with the resume function for this suspend
point.</p>
<p>The second argument is the <cite>context projection function</cite>. It should describe
how-to restore the <cite>async context</cite> in the continuation function from the first
argument of the continuation function. Its type is <cite>ptr (ptr)</cite>.</p>
<p>The third argument is the function that models transfer to the callee at the
suspend point. It should take 3 arguments. Lowering will <cite>musttail</cite> call this
function.</p>
<p>The fourth to six argument are the arguments for the third argument.</p>
</section>
<section id="id64">
<h5>Semantics:<a class="headerlink" href="#id64" title="Link to this heading">¶</a></h5>
<p>The result of the intrinsic are mapped to the arguments of the resume function.
Execution is suspended at this intrinsic and resumed when the resume function is
called.</p>
</section>
</section>
<section id="llvm-coro-prepare-async-intrinsic">
<span id="coro-prepare-async"></span><h4><a class="toc-backref" href="#id124" role="doc-backlink">‘llvm.coro.prepare.async’ Intrinsic</a><a class="headerlink" href="#llvm-coro-prepare-async-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">ptr</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">prepare</span><span class="o">.</span><span class="k">async</span><span class="p">(</span><span class="n">ptr</span> <span class="o">&lt;</span><span class="n">coroutine</span> <span class="n">function</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id65">
<h5>Overview:<a class="headerlink" href="#id65" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.prepare.async</span></code>’ intrinsic is used to block inlining of the
async coroutine until after coroutine splitting.</p>
</section>
<section id="id66">
<h5>Arguments:<a class="headerlink" href="#id66" title="Link to this heading">¶</a></h5>
<p>The first argument should be an async coroutine of type <cite>void (ptr, ptr, ptr)</cite>.
Lowering will replace this intrinsic with its coroutine function argument.</p>
</section>
</section>
<section id="llvm-coro-suspend-retcon-intrinsic">
<span id="coro-suspend-retcon"></span><h4><a class="toc-backref" href="#id125" role="doc-backlink">‘llvm.coro.suspend.retcon’ Intrinsic</a><a class="headerlink" href="#llvm-coro-suspend-retcon-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i1</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">suspend</span><span class="o">.</span><span class="n">retcon</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<section id="id67">
<h5>Overview:<a class="headerlink" href="#id67" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.suspend.retcon</span></code>’ intrinsic marks the point where
execution of a returned-continuation coroutine is suspended and control
is returned back to the caller.</p>
<p><cite>llvm.coro.suspend.retcon`</cite> does not support separate save points;
they are not useful when the continuation function is not locally
accessible.  That would be a more appropriate feature for a <code class="docutils literal notranslate"><span class="pre">passcon</span></code>
lowering that is not yet implemented.</p>
</section>
<section id="id68">
<h5>Arguments:<a class="headerlink" href="#id68" title="Link to this heading">¶</a></h5>
<p>The types of the arguments must exactly match the yielded-types sequence
of the coroutine.  They will be turned into return values from the ramp
and continuation functions, along with the next continuation function.</p>
</section>
<section id="id69">
<h5>Semantics:<a class="headerlink" href="#id69" title="Link to this heading">¶</a></h5>
<p>The result of the intrinsic indicates whether the coroutine should resume
abnormally (non-zero).</p>
<p>In a normal coroutine, it is undefined behavior if the coroutine executes
a call to <code class="docutils literal notranslate"><span class="pre">llvm.coro.suspend.retcon</span></code> after resuming abnormally.</p>
<p>In a yield-once coroutine, it is undefined behavior if the coroutine
executes a call to <code class="docutils literal notranslate"><span class="pre">llvm.coro.suspend.retcon</span></code> after resuming in any way.</p>
</section>
</section>
<section id="llvm-coro-await-suspend-void-intrinsic">
<span id="coro-await-suspend-void"></span><h4><a class="toc-backref" href="#id126" role="doc-backlink">‘llvm.coro.await.suspend.void’ Intrinsic</a><a class="headerlink" href="#llvm-coro-await-suspend-void-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="k">await</span><span class="o">.</span><span class="n">suspend</span><span class="o">.</span><span class="n">void</span><span class="p">(</span>
              <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">awaiter</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">handle</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">await_suspend_function</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id70">
<h5>Overview:<a class="headerlink" href="#id70" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.await.suspend.void</span></code>’ intrinsic encapsulates C++
<cite>await-suspend</cite> block until it can’t interfere with coroutine transform.</p>
<p>The <cite>await_suspend</cite> block of <cite>co_await</cite> is essentially asynchronous
to the execution of the coroutine. Inlining it normally into an unsplit
coroutine can cause miscompilation because the coroutine CFG misrepresents
the true control flow of the program: things that happen in the
await_suspend are not guaranteed to happen prior to the resumption of the
coroutine, and things that happen after the resumption of the coroutine
(including its exit and the potential deallocation of the coroutine frame)
are not guaranteed to happen only after the end of <cite>await_suspend</cite>.</p>
<p>This version of intrinsic corresponds to
‘<code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">awaiter.await_suspend(...)</span></code>’ variant.</p>
</section>
<section id="id71">
<h5>Arguments:<a class="headerlink" href="#id71" title="Link to this heading">¶</a></h5>
<p>The first argument is a pointer to <cite>awaiter</cite> object.</p>
<p>The second argument is a pointer to the current coroutine’s frame.</p>
<p>The third argument is a pointer to the wrapper function encapsulating
<cite>await-suspend</cite> logic. Its signature must be</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@await_suspend_function</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%awaiter</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id72">
<h5>Semantics:<a class="headerlink" href="#id72" title="Link to this heading">¶</a></h5>
<p>The intrinsic must be used between corresponding <a class="reference internal" href="#coro-save">coro.save</a> and
<a class="reference internal" href="#coro-suspend">coro.suspend</a> calls. It is lowered to a direct
<cite>await_suspend_function</cite> call during <a class="reference internal" href="#corosplit">CoroSplit</a> pass.</p>
</section>
<section id="id73">
<h5>Example:<a class="headerlink" href="#id73" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="c">; before lowering</span>
<span class="nl">await.suspend:</span>
<span class="w">  </span><span class="nv">%save</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="vg">@llvm.coro.save</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.coro.await.suspend.void</span><span class="p">(</span>
<span class="w">              </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%awaiter</span><span class="p">,</span>
<span class="w">              </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">,</span>
<span class="w">              </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@await_suspend_function</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%suspend</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="vg">@llvm.coro.suspend</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%save</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">)</span>
<span class="w">  </span><span class="p">...</span>

<span class="c">; after lowering</span>
<span class="nl">await.suspend:</span>
<span class="w">  </span><span class="nv">%save</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="vg">@llvm.coro.save</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="c">; the call to await_suspend_function can be inlined</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@await_suspend_function</span><span class="p">(</span>
<span class="w">              </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%awaiter</span><span class="p">,</span>
<span class="w">              </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%suspend</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="vg">@llvm.coro.suspend</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%save</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">)</span>
<span class="w">  </span><span class="p">...</span>

<span class="c">; wrapper function example</span>
<span class="k">define</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@await_suspend_function</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%awaiter</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="nl">entry:</span>
<span class="w">    </span><span class="nv">%hdl.arg</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="c">; construct std::coroutine_handle from %hdl</span>
<span class="w">    </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@&quot;Awaiter::await_suspend&quot;</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%awaiter</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl.arg</span><span class="p">)</span>
<span class="w">    </span><span class="k">ret</span><span class="w"> </span><span class="k">void</span>
</pre></div>
</div>
</section>
</section>
<section id="llvm-coro-await-suspend-bool-intrinsic">
<span id="coro-await-suspend-bool"></span><h4><a class="toc-backref" href="#id127" role="doc-backlink">‘llvm.coro.await.suspend.bool’ Intrinsic</a><a class="headerlink" href="#llvm-coro-await-suspend-bool-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">i1</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="k">await</span><span class="o">.</span><span class="n">suspend</span><span class="o">.</span><span class="n">bool</span><span class="p">(</span>
              <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">awaiter</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">handle</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">await_suspend_function</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id74">
<h5>Overview:<a class="headerlink" href="#id74" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.await.suspend.bool</span></code>’ intrinsic encapsulates C++
<cite>await-suspend</cite> block until it can’t interfere with coroutine transform.</p>
<p>The <cite>await_suspend</cite> block of <cite>co_await</cite> is essentially asynchronous
to the execution of the coroutine. Inlining it normally into an unsplit
coroutine can cause miscompilation because the coroutine CFG misrepresents
the true control flow of the program: things that happen in the
await_suspend are not guaranteed to happen prior to the resumption of the
coroutine, and things that happen after the resumption of the coroutine
(including its exit and the potential deallocation of the coroutine frame)
are not guaranteed to happen only after the end of <cite>await_suspend</cite>.</p>
<p>This version of intrinsic corresponds to
‘<code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">awaiter.await_suspend(...)</span></code>’ variant.</p>
</section>
<section id="id75">
<h5>Arguments:<a class="headerlink" href="#id75" title="Link to this heading">¶</a></h5>
<p>The first argument is a pointer to <cite>awaiter</cite> object.</p>
<p>The second argument is a pointer to the current coroutine’s frame.</p>
<p>The third argument is a pointer to the wrapper function encapsulating
<cite>await-suspend</cite> logic. Its signature must be</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@await_suspend_function</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%awaiter</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id76">
<h5>Semantics:<a class="headerlink" href="#id76" title="Link to this heading">¶</a></h5>
<p>The intrinsic must be used between corresponding <a class="reference internal" href="#coro-save">coro.save</a> and
<a class="reference internal" href="#coro-suspend">coro.suspend</a> calls. It is lowered to a direct
<cite>await_suspend_function</cite> call during <a class="reference internal" href="#corosplit">CoroSplit</a> pass.</p>
<p>If <cite>await_suspend_function</cite> call returns <cite>true</cite>, the current coroutine is
immediately resumed.</p>
</section>
<section id="id77">
<h5>Example:<a class="headerlink" href="#id77" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="c">; before lowering</span>
<span class="nl">await.suspend:</span>
<span class="w">  </span><span class="nv">%save</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="vg">@llvm.coro.save</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%resume</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@llvm.coro.await.suspend.bool</span><span class="p">(</span>
<span class="w">              </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%awaiter</span><span class="p">,</span>
<span class="w">              </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">,</span>
<span class="w">              </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@await_suspend_function</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%resume</span><span class="p">,</span><span class="w"> </span><span class="nv">%await.suspend.bool</span><span class="p">,</span><span class="w"> </span><span class="nv">%await.ready</span>
<span class="nl">await.suspend.bool:</span>
<span class="w">  </span><span class="nv">%suspend</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="vg">@llvm.coro.suspend</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%save</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">)</span>
<span class="w">  </span><span class="p">...</span>
<span class="nl">await.ready:</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@&quot;Awaiter::await_resume&quot;</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%awaiter</span><span class="p">)</span>
<span class="w">  </span><span class="p">...</span>

<span class="c">; after lowering</span>
<span class="nl">await.suspend:</span>
<span class="w">  </span><span class="nv">%save</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="vg">@llvm.coro.save</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="c">; the call to await_suspend_function can inlined</span>
<span class="w">  </span><span class="nv">%resume</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@await_suspend_function</span><span class="p">(</span>
<span class="w">              </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%awaiter</span><span class="p">,</span>
<span class="w">              </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%resume</span><span class="p">,</span><span class="w"> </span><span class="nv">%await.suspend.bool</span><span class="p">,</span><span class="w"> </span><span class="nv">%await.ready</span>
<span class="w">  </span><span class="p">...</span>

<span class="c">; wrapper function example</span>
<span class="k">define</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@await_suspend_function</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%awaiter</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="nl">entry:</span>
<span class="w">    </span><span class="nv">%hdl.arg</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="c">; construct std::coroutine_handle from %hdl</span>
<span class="w">    </span><span class="nv">%resume</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@&quot;Awaiter::await_suspend&quot;</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%awaiter</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl.arg</span><span class="p">)</span>
<span class="w">    </span><span class="k">ret</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%resume</span>
</pre></div>
</div>
</section>
</section>
<section id="llvm-coro-await-suspend-handle-intrinsic">
<span id="coro-await-suspend-handle"></span><h4><a class="toc-backref" href="#id128" role="doc-backlink">‘llvm.coro.await.suspend.handle’ Intrinsic</a><a class="headerlink" href="#llvm-coro-await-suspend-handle-intrinsic" title="Link to this heading">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">declare</span> <span class="n">void</span> <span class="nd">@llvm</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="k">await</span><span class="o">.</span><span class="n">suspend</span><span class="o">.</span><span class="n">handle</span><span class="p">(</span>
              <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">awaiter</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">handle</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="n">ptr</span> <span class="o">&lt;</span><span class="n">await_suspend_function</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<section id="id78">
<h5>Overview:<a class="headerlink" href="#id78" title="Link to this heading">¶</a></h5>
<p>The ‘<code class="docutils literal notranslate"><span class="pre">llvm.coro.await.suspend.handle</span></code>’ intrinsic encapsulates C++
<cite>await-suspend</cite> block until it can’t interfere with coroutine transform.</p>
<p>The <cite>await_suspend</cite> block of <cite>co_await</cite> is essentially asynchronous
to the execution of the coroutine. Inlining it normally into an unsplit
coroutine can cause miscompilation because the coroutine CFG misrepresents
the true control flow of the program: things that happen in the
await_suspend are not guaranteed to happen prior to the resumption of the
coroutine, and things that happen after the resumption of the coroutine
(including its exit and the potential deallocation of the coroutine frame)
are not guaranteed to happen only after the end of <cite>await_suspend</cite>.</p>
<p>This version of intrinsic corresponds to
‘<code class="docutils literal notranslate"><span class="pre">std::coroutine_handle&lt;&gt;</span> <span class="pre">awaiter.await_suspend(...)</span></code>’ variant.</p>
</section>
<section id="id79">
<h5>Arguments:<a class="headerlink" href="#id79" title="Link to this heading">¶</a></h5>
<p>The first argument is a pointer to <cite>awaiter</cite> object.</p>
<p>The second argument is a pointer to the current coroutine’s frame.</p>
<p>The third argument is a pointer to the wrapper function encapsulating
<cite>await-suspend</cite> logic. Its signature must be</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@await_suspend_function</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%awaiter</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id80">
<h5>Semantics:<a class="headerlink" href="#id80" title="Link to this heading">¶</a></h5>
<p>The intrinsic must be used between corresponding <a class="reference internal" href="#coro-save">coro.save</a> and
<a class="reference internal" href="#coro-suspend">coro.suspend</a> calls. It is lowered to a direct
<cite>await_suspend_function</cite> call during <a class="reference internal" href="#corosplit">CoroSplit</a> pass.</p>
<p><cite>await_suspend_function</cite> must return a pointer to a valid
coroutine frame. The intrinsic will be lowered to a tail call resuming the
returned coroutine frame. It will be marked <cite>musttail</cite> on targets that support
that. Instructions following the intrinsic will become unreachable.</p>
</section>
<section id="id81">
<h5>Example:<a class="headerlink" href="#id81" title="Link to this heading">¶</a></h5>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="c">; before lowering</span>
<span class="nl">await.suspend:</span>
<span class="w">  </span><span class="nv">%save</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="vg">@llvm.coro.save</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.coro.await.suspend.handle</span><span class="p">(</span>
<span class="w">      </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%awaiter</span><span class="p">,</span>
<span class="w">      </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">,</span>
<span class="w">      </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@await_suspend_function</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%suspend</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="vg">@llvm.coro.suspend</span><span class="p">(</span><span class="k">token</span><span class="w"> </span><span class="nv">%save</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">)</span>
<span class="w">  </span><span class="p">...</span>

<span class="c">; after lowering</span>
<span class="nl">await.suspend:</span>
<span class="w">  </span><span class="nv">%save</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">token</span><span class="w"> </span><span class="vg">@llvm.coro.save</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="c">; the call to await_suspend_function can be inlined</span>
<span class="w">  </span><span class="nv">%next</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@await_suspend_function</span><span class="p">(</span>
<span class="w">              </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%awaiter</span><span class="p">,</span>
<span class="w">              </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="k">musttail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.coro.resume</span><span class="p">(</span><span class="nv">%next</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="k">void</span>
<span class="w">  </span><span class="p">...</span>

<span class="c">; wrapper function example</span>
<span class="k">define</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@await_suspend_function</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%awaiter</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl</span><span class="p">)</span>
<span class="w">  </span><span class="nl">entry:</span>
<span class="w">    </span><span class="nv">%hdl.arg</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="c">; construct std::coroutine_handle from %hdl</span>
<span class="w">    </span><span class="nv">%hdl.raw</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@&quot;Awaiter::await_suspend&quot;</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%awaiter</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl.arg</span><span class="p">)</span>
<span class="w">    </span><span class="nv">%hdl.result</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="c">; get address of returned coroutine handle</span>
<span class="w">    </span><span class="k">ret</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%hdl.result</span>
</pre></div>
</div>
</section>
</section>
</section>
</section>
<section id="coroutine-transformation-passes">
<h2><a class="toc-backref" href="#id129" role="doc-backlink">Coroutine Transformation Passes</a><a class="headerlink" href="#coroutine-transformation-passes" title="Link to this heading">¶</a></h2>
<section id="coroearly">
<h3><a class="toc-backref" href="#id130" role="doc-backlink">CoroEarly</a><a class="headerlink" href="#coroearly" title="Link to this heading">¶</a></h3>
<p>The CoroEarly pass ensures later middle end passes correctly interpret coroutine
semantics and lowers coroutine intrinsics that not needed to be preserved to
help later coroutine passes. This pass lowers <a class="reference internal" href="#coro-promise">coro.promise</a>, <a class="reference internal" href="#coro-frame">coro.frame</a> and
<a class="reference internal" href="#coro-done">coro.done</a> intrinsics. Afterwards, it replace uses of promise alloca with
<a class="reference internal" href="#coro-promise">coro.promise</a> intrinsic.</p>
</section>
<section id="corosplit">
<span id="id82"></span><h3><a class="toc-backref" href="#id131" role="doc-backlink">CoroSplit</a><a class="headerlink" href="#corosplit" title="Link to this heading">¶</a></h3>
<p>The pass CoroSplit builds coroutine frame and outlines resume and destroy parts
into separate functions. This pass also lowers <a class="reference internal" href="#coro-await-suspend-void">coro.await.suspend.void</a>,
<a class="reference internal" href="#coro-await-suspend-bool">coro.await.suspend.bool</a> and <a class="reference internal" href="#coro-await-suspend-handle">coro.await.suspend.handle</a> intrinsics.</p>
</section>
<section id="coroannotationelide">
<h3><a class="toc-backref" href="#id132" role="doc-backlink">CoroAnnotationElide</a><a class="headerlink" href="#coroannotationelide" title="Link to this heading">¶</a></h3>
<p>This pass finds all usages of coroutines that are “must elide” and replaces
<cite>coro.begin</cite> intrinsic with an address of a coroutine frame placed on its caller
and replaces <cite>coro.alloc</cite> and <cite>coro.free</cite> intrinsics with <cite>false</cite> and <cite>null</cite>
respectively to remove the deallocation code.</p>
</section>
<section id="coroelide">
<h3><a class="toc-backref" href="#id133" role="doc-backlink">CoroElide</a><a class="headerlink" href="#coroelide" title="Link to this heading">¶</a></h3>
<p>The pass CoroElide examines if the inlined coroutine is eligible for heap
allocation elision optimization. If so, it replaces
<cite>coro.begin</cite> intrinsic with an address of a coroutine frame placed on its caller
and replaces <cite>coro.alloc</cite> and <cite>coro.free</cite> intrinsics with <cite>false</cite> and <cite>null</cite>
respectively to remove the deallocation code.
This pass also replaces <cite>coro.resume</cite> and <cite>coro.destroy</cite> intrinsics with direct
calls to resume and destroy functions for a particular coroutine where possible.</p>
</section>
<section id="corocleanup">
<h3><a class="toc-backref" href="#id134" role="doc-backlink">CoroCleanup</a><a class="headerlink" href="#corocleanup" title="Link to this heading">¶</a></h3>
<p>This pass runs late to lower all coroutine related intrinsics not replaced by
earlier passes.</p>
</section>
</section>
<section id="attributes">
<h2><a class="toc-backref" href="#id135" role="doc-backlink">Attributes</a><a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h2>
<section id="coro-only-destroy-when-complete">
<h3><a class="toc-backref" href="#id136" role="doc-backlink">coro_only_destroy_when_complete</a><a class="headerlink" href="#coro-only-destroy-when-complete" title="Link to this heading">¶</a></h3>
<p>When the coroutine are marked with coro_only_destroy_when_complete, it indicates
the coroutine must reach the final suspend point when it get destroyed.</p>
<p>This attribute only works for switched-resume coroutines now.</p>
</section>
<section id="coro-elide-safe">
<h3><a class="toc-backref" href="#id137" role="doc-backlink">coro_elide_safe</a><a class="headerlink" href="#coro-elide-safe" title="Link to this heading">¶</a></h3>
<p>When a Call or Invoke instruction to switch ABI coroutine <cite>f</cite> is marked with
<cite>coro_elide_safe</cite>, CoroSplitPass generates a <cite>f.noalloc</cite> ramp function.
<cite>f.noalloc</cite> has one more argument than its original ramp function <cite>f</cite>, which is
the pointer to the allocated frame. <cite>f.noalloc</cite> also suppressed any allocations
or deallocations that may be guarded by <cite>&#64;llvm.coro.alloc</cite> and <cite>&#64;llvm.coro.free</cite>.</p>
<p>CoroAnnotationElidePass performs the heap elision when possible. Note that for
recursive or mutually recursive functions this elision is usually not possible.</p>
</section>
</section>
<section id="metadata">
<h2><a class="toc-backref" href="#id138" role="doc-backlink">Metadata</a><a class="headerlink" href="#metadata" title="Link to this heading">¶</a></h2>
<section id="coro-outside-frame-metadata">
<h3><a class="toc-backref" href="#id139" role="doc-backlink">‘<code class="docutils literal notranslate"><span class="pre">coro.outside.frame</span></code>’ Metadata</a><a class="headerlink" href="#coro-outside-frame-metadata" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">coro.outside.frame</span></code> metadata may be attached to an alloca instruction to
to signify that it shouldn’t be promoted to the coroutine frame, useful for
filtering allocas out by the frontend when emitting internal control mechanisms.
Additionally, this metadata is only used as a flag, so the associated
node must be empty.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>%__coro_gro = alloca %struct.GroType, align 1, !coro.outside.frame !0

...
!0 = !{}
</pre></div>
</div>
</section>
</section>
<section id="areas-requiring-attention">
<h2><a class="toc-backref" href="#id140" role="doc-backlink">Areas Requiring Attention</a><a class="headerlink" href="#areas-requiring-attention" title="Link to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p>When coro.suspend returns -1, the coroutine is suspended, and it’s possible
that the coroutine has already been destroyed (hence the frame has been freed).
We cannot access anything on the frame on the suspend path.
However there is nothing that prevents the compiler from moving instructions
along that path (e.g. LICM), which can lead to use-after-free. At the moment
we disabled LICM for loops that have coro.suspend, but the general problem still
exists and requires a general solution.</p></li>
<li><p>Take advantage of the lifetime intrinsics for the data that goes into the
coroutine frame. Leave lifetime intrinsics as is for the data that stays in
allocas.</p></li>
<li><p>The CoroElide optimization pass relies on coroutine ramp function to be
inlined. It would be beneficial to split the ramp function further to
increase the chance that it will get inlined into its caller.</p></li>
<li><p>Design a convention that would make it possible to apply coroutine heap
elision optimization across ABI boundaries.</p></li>
<li><p>Cannot handle coroutines with <cite>inalloca</cite> parameters (used in x86 on Windows).</p></li>
<li><p>Alignment is ignored by coro.begin and coro.free intrinsics.</p></li>
<li><p>Make required changes to make sure that coroutine optimizations work with
LTO.</p></li>
<li><p>More tests, more tests, more tests</p></li>
</ol>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="DependenceGraphs/index.html" title="Dependence Graphs in LLVM"
             >next</a> |</li>
        <li class="right" >
          <a href="ConvergentOperations.html" title="Convergent Operation Semantics"
             >previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="Reference.html" >Reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Coroutines in LLVM</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2003-2025, LLVM Project.
      Last updated on 2025-08-26.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>