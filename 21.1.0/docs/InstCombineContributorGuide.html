
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>InstCombine contributor guide &#8212; LLVM 21.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/llvm-theme.css?v=96924833" />
    <script src="_static/documentation_options.js?v=c54a4614"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Instrumentation Profile Format" href="InstrProfileFormat.html" />
    <link rel="prev" title="How to Update Debug Info: A Guide for LLVM Pass Authors" href="HowToUpdateDebugInfo.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="InstrProfileFormat.html" title="Instrumentation Profile Format"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="HowToUpdateDebugInfo.html" title="How to Update Debug Info: A Guide for LLVM Pass Authors"
             accesskey="P">previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" accesskey="U">User Guides</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">InstCombine contributor guide</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="https://llvm.org/docs/UserGuides.html">User Guides</a></li>
    <li><a href="https://llvm.org/docs/Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/Contributing.html">Contributing to LLVM</a></li>
    <li><a href="https://llvm.org/docs/HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#discord">Discord</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/FAQ.html">FAQ</a></li>
    <li><a href="https://llvm.org/docs/Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project/">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/InstCombineContributorGuide.md.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="instcombine-contributor-guide">
<h1><a class="toc-backref" href="#id1" role="doc-backlink">InstCombine contributor guide</a><a class="headerlink" href="#instcombine-contributor-guide" title="Link to this heading">¶</a></h1>
<nav class="contents" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#instcombine-contributor-guide" id="id1">InstCombine contributor guide</a></p>
<ul>
<li><p><a class="reference internal" href="#tests" id="id2">Tests</a></p>
<ul>
<li><p><a class="reference internal" href="#precommit-tests" id="id3">Precommit tests</a></p></li>
<li><p><a class="reference internal" href="#use-update-test-checks-py" id="id4">Use <code class="docutils literal notranslate"><span class="pre">update_test_checks.py</span></code></a></p></li>
<li><p><a class="reference internal" href="#general-testing-considerations" id="id5">General testing considerations</a></p></li>
<li><p><a class="reference internal" href="#add-negative-tests" id="id6">Add negative tests</a></p></li>
<li><p><a class="reference internal" href="#add-multi-use-tests" id="id7">Add multi-use tests</a></p></li>
<li><p><a class="reference internal" href="#add-commuted-tests" id="id8">Add commuted tests</a></p></li>
<li><p><a class="reference internal" href="#add-vector-tests" id="id9">Add vector tests</a></p></li>
<li><p><a class="reference internal" href="#flag-tests" id="id10">Flag tests</a></p></li>
<li><p><a class="reference internal" href="#other-tests" id="id11">Other tests</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#proofs" id="id12">Proofs</a></p>
<ul>
<li><p><a class="reference internal" href="#basics" id="id13">Basics</a></p></li>
<li><p><a class="reference internal" href="#use-generic-values-in-proofs" id="id14">Use generic values in proofs</a></p></li>
<li><p><a class="reference internal" href="#common-pre-conditions" id="id15">Common pre-conditions</a></p></li>
<li><p><a class="reference internal" href="#timeouts" id="id16">Timeouts</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#implementation" id="id17">Implementation</a></p>
<ul>
<li><p><a class="reference internal" href="#real-world-usefulness" id="id18">Real-world usefulness</a></p></li>
<li><p><a class="reference internal" href="#pick-the-correct-optimization-pass" id="id19">Pick the correct optimization pass</a></p></li>
<li><p><a class="reference internal" href="#canonicalization-and-target-independence" id="id20">Canonicalization and target-independence</a></p></li>
<li><p><a class="reference internal" href="#patternmatch" id="id21">PatternMatch</a></p></li>
<li><p><a class="reference internal" href="#instcombine-apis" id="id22">InstCombine APIs</a></p></li>
<li><p><a class="reference internal" href="#multi-use-handling" id="id23">Multi-use handling</a></p></li>
<li><p><a class="reference internal" href="#flag-handling" id="id24">Flag handling</a></p></li>
<li><p><a class="reference internal" href="#generalization" id="id25">Generalization</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#guidelines-for-reviewers" id="id26">Guidelines for reviewers</a></p></li>
</ul>
</li>
</ul>
</nav>
<p>This guide lays out a series of rules that contributions to InstCombine should
follow. <strong>Following these rules will results in much faster PR approvals.</strong></p>
<section id="tests">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Tests</a><a class="headerlink" href="#tests" title="Link to this heading">¶</a></h2>
<section id="precommit-tests">
<h3><a class="toc-backref" href="#id3" role="doc-backlink">Precommit tests</a><a class="headerlink" href="#precommit-tests" title="Link to this heading">¶</a></h3>
<p>Tests for new optimizations or miscompilation fixes should be pre-committed.
This means that you first commit the test with CHECK lines showing the behavior
<em>without</em> your change. Your actual change will then only contain CHECK line
diffs relative to that baseline.</p>
<p>This means that pull requests should generally contain two commits: First,
one commit adding new tests with baseline check lines. Second, a commit with
functional changes and test diffs.</p>
<p>If the second commit in your PR does not contain test diffs, you did something
wrong. Either you made a mistake when generating CHECK lines, or your tests are
not actually affected by your patch.</p>
<p>Exceptions: When fixing assertion failures or infinite loops, do not pre-commit
tests.</p>
</section>
<section id="use-update-test-checks-py">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">Use <code class="docutils literal notranslate"><span class="pre">update_test_checks.py</span></code></a><a class="headerlink" href="#use-update-test-checks-py" title="Link to this heading">¶</a></h3>
<p>CHECK lines should be generated using the <code class="docutils literal notranslate"><span class="pre">update_test_checks.py</span></code> script. Do
<strong>not</strong> manually edit check lines after using it.</p>
<p>Be sure to use the correct opt binary when using the script. For example, if
your build directory is <code class="docutils literal notranslate"><span class="pre">build</span></code>, then you’ll want to run:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>llvm/utils/update_test_checks.py<span class="w"> </span>--opt-binary<span class="w"> </span>build/bin/opt<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>llvm/test/Transforms/InstCombine/the_test.ll
</pre></div>
</div>
<p>Exceptions: Hand-written CHECK lines are allowed for debuginfo tests.</p>
</section>
<section id="general-testing-considerations">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">General testing considerations</a><a class="headerlink" href="#general-testing-considerations" title="Link to this heading">¶</a></h3>
<p>Place all tests relating to a transform into a single file. If you are adding
a regression test for a crash/miscompile in an existing transform, find the
file where the existing tests are located. A good way to do that is to comment
out the transform and see which tests fail.</p>
<p>Make tests minimal. Only test exactly the pattern being transformed. If your
original motivating case is a larger pattern that your fold enables to
optimize in some non-trivial way, you may add it as well – however, the bulk
of the test coverage should be minimal.</p>
<p>Give tests short, but meaningful names. Don’t call them <code class="docutils literal notranslate"><span class="pre">&#64;test1</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;test2</span></code> etc.
For example, a test checking multi-use behavior of a fold involving the
addition of two selects might be called <code class="docutils literal notranslate"><span class="pre">&#64;add_of_selects_multi_use</span></code>.</p>
<p>Add representative tests for each test category (discussed below), but don’t
test all combinations of everything. If you have multi-use tests, and you have
commuted tests, you shouldn’t also add commuted multi-use tests.</p>
<p>Prefer to keep bit-widths for tests low to improve performance of proof checking using alive2. Using <code class="docutils literal notranslate"><span class="pre">i8</span></code> is better than <code class="docutils literal notranslate"><span class="pre">i128</span></code> where possible.</p>
</section>
<section id="add-negative-tests">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">Add negative tests</a><a class="headerlink" href="#add-negative-tests" title="Link to this heading">¶</a></h3>
<p>Make sure to add tests for which your transform does <strong>not</strong> apply. Start with
one of the test cases that succeeds and then create a sequence of negative
tests, such that <strong>exactly one</strong> different pre-condition of your transform is
not satisfied in each test.</p>
</section>
<section id="add-multi-use-tests">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Add multi-use tests</a><a class="headerlink" href="#add-multi-use-tests" title="Link to this heading">¶</a></h3>
<p>Add multi-use tests that ensures your transform does not increase instruction
count if some instructions have additional uses. The standard pattern is to
introduce extra uses with function calls:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">declare</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@use</span><span class="p">(</span><span class="kt">i8</span><span class="p">)</span>

<span class="k">define</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="vg">@add_mul_const_multi_use</span><span class="p">(</span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%add</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@use</span><span class="p">(</span><span class="kt">i8</span><span class="w"> </span><span class="nv">%add</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%mul</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">mul</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%add</span><span class="p">,</span><span class="w"> </span><span class="m">3</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%mul</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Exceptions: For transform that only produce one instruction, multi-use tests
may be omitted.</p>
</section>
<section id="add-commuted-tests">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Add commuted tests</a><a class="headerlink" href="#add-commuted-tests" title="Link to this heading">¶</a></h3>
<p>If the transform involves commutative operations, add tests with commuted
(swapped) operands.</p>
<p>Make sure that the operand order stays intact in the CHECK lines of your
pre-commited tests. You should not see something like this:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="c">; CHECK-NEXT: [[OR:%.*]] = or i8 [[X]], [[Y]]</span>
<span class="c">; ...</span>
<span class="nv">%or</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%y</span><span class="p">,</span><span class="w"> </span><span class="nv">%x</span>
</pre></div>
</div>
<p>If this happens, you may need to change one of the operands to have higher
complexity (include the “thwart” comment in that case):</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv">%y2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">mul</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%y</span><span class="p">,</span><span class="w"> </span><span class="nv">%y</span><span class="w"> </span><span class="c">; thwart complexity-based canonicalization</span>
<span class="nv">%or</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%y</span><span class="p">,</span><span class="w"> </span><span class="nv">%x</span>
</pre></div>
</div>
</section>
<section id="add-vector-tests">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">Add vector tests</a><a class="headerlink" href="#add-vector-tests" title="Link to this heading">¶</a></h3>
<p>When possible, it is recommended to add at least one test that uses vectors
instead of scalars.</p>
<p>For patterns that include constants, we distinguish three kinds of tests.
The first are “splat” vectors, where all the vector elements are the same.
These tests <em>should</em> usually fold without additional effort.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="p">&lt;</span><span class="m">2</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i8</span><span class="p">&gt;</span><span class="w"> </span><span class="vg">@add_mul_const_vec_splat</span><span class="p">(&lt;</span><span class="m">2</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i8</span><span class="p">&gt;</span><span class="w"> </span><span class="nv">%x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%add</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="p">&lt;</span><span class="m">2</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i8</span><span class="p">&gt;</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="p">&lt;</span><span class="kt">i8</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="m">1</span><span class="p">&gt;</span>
<span class="w">  </span><span class="nv">%mul</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">mul</span><span class="w"> </span><span class="p">&lt;</span><span class="m">2</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i8</span><span class="p">&gt;</span><span class="w"> </span><span class="nv">%add</span><span class="p">,</span><span class="w"> </span><span class="p">&lt;</span><span class="kt">i8</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="m">3</span><span class="p">&gt;</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="p">&lt;</span><span class="m">2</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i8</span><span class="p">&gt;</span><span class="w"> </span><span class="nv">%mul</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A minor variant is to replace some of the splat elements with poison. These
will often also fold without additional effort.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="p">&lt;</span><span class="m">2</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i8</span><span class="p">&gt;</span><span class="w"> </span><span class="vg">@add_mul_const_vec_splat_poison</span><span class="p">(&lt;</span><span class="m">2</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i8</span><span class="p">&gt;</span><span class="w"> </span><span class="nv">%x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%add</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="p">&lt;</span><span class="m">2</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i8</span><span class="p">&gt;</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="p">&lt;</span><span class="kt">i8</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="k">poison</span><span class="p">&gt;</span>
<span class="w">  </span><span class="nv">%mul</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">mul</span><span class="w"> </span><span class="p">&lt;</span><span class="m">2</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i8</span><span class="p">&gt;</span><span class="w"> </span><span class="nv">%add</span><span class="p">,</span><span class="w"> </span><span class="p">&lt;</span><span class="kt">i8</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="k">poison</span><span class="p">&gt;</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="p">&lt;</span><span class="m">2</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i8</span><span class="p">&gt;</span><span class="w"> </span><span class="nv">%mul</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, you can have non-splat vectors, where the vector elements are not
the same:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="p">&lt;</span><span class="m">2</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i8</span><span class="p">&gt;</span><span class="w"> </span><span class="vg">@add_mul_const_vec_non_splat</span><span class="p">(&lt;</span><span class="m">2</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i8</span><span class="p">&gt;</span><span class="w"> </span><span class="nv">%x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%add</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="p">&lt;</span><span class="m">2</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i8</span><span class="p">&gt;</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="p">&lt;</span><span class="kt">i8</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="m">5</span><span class="p">&gt;</span>
<span class="w">  </span><span class="nv">%mul</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">mul</span><span class="w"> </span><span class="p">&lt;</span><span class="m">2</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i8</span><span class="p">&gt;</span><span class="w"> </span><span class="nv">%add</span><span class="p">,</span><span class="w"> </span><span class="p">&lt;</span><span class="kt">i8</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="m">6</span><span class="p">&gt;</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="p">&lt;</span><span class="m">2</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i8</span><span class="p">&gt;</span><span class="w"> </span><span class="nv">%mul</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Non-splat vectors will often not fold by default. You should <strong>not</strong> try to
make them fold, unless doing so does not add <strong>any</strong> additional complexity.
You should still add the test though, even if it does not fold.</p>
</section>
<section id="flag-tests">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Flag tests</a><a class="headerlink" href="#flag-tests" title="Link to this heading">¶</a></h3>
<p>If your transform involves instructions that can have poison-generating flags,
such as <code class="docutils literal notranslate"><span class="pre">nuw</span></code> and <code class="docutils literal notranslate"><span class="pre">nsw</span></code> on <code class="docutils literal notranslate"><span class="pre">add</span></code>, you should test how these interact with the
transform.</p>
<p>If your transform <em>requires</em> a certain flag for correctness, make sure to add
negative tests missing the required flag.</p>
<p>If your transform doesn’t require flags for correctness, you should have tests
for preservation behavior. If the input instructions have certain flags, are
they preserved in the output instructions, if it is valid to preserve them?
(This depends on the transform. Check with alive2.)</p>
<p>The same also applies to fast-math-flags (FMF). In that case, please always
test specific flags like <code class="docutils literal notranslate"><span class="pre">nnan</span></code>, <code class="docutils literal notranslate"><span class="pre">nsz</span></code> or <code class="docutils literal notranslate"><span class="pre">reassoc</span></code>, rather than the umbrella
<code class="docutils literal notranslate"><span class="pre">fast</span></code> flag.</p>
</section>
<section id="other-tests">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Other tests</a><a class="headerlink" href="#other-tests" title="Link to this heading">¶</a></h3>
<p>The test categories mentioned above are non-exhaustive. There may be more tests
to be added, depending on the instructions involved in the transform. Some
examples:</p>
<ul class="simple">
<li><p>For folds involving memory accesses like load/store, check that scalable vectors and non-byte-size types (like i3) are handled correctly. Also check that volatile/atomic are handled.</p></li>
<li><p>For folds that interact with the bitwidth in some non-trivial way, check an illegal type like i13. Also confirm that the transform is correct for i1.</p></li>
<li><p>For folds that involve phis, you may want to check that the case of multiple incoming values from one block is handled correctly.</p></li>
</ul>
</section>
</section>
<section id="proofs">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">Proofs</a><a class="headerlink" href="#proofs" title="Link to this heading">¶</a></h2>
<p>Your pull request description should contain one or more
<a class="reference external" href="https://alive2.llvm.org/ce/">alive2 proofs</a> for the correctness of the
proposed transform.</p>
<section id="basics">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Basics</a><a class="headerlink" href="#basics" title="Link to this heading">¶</a></h3>
<p>Proofs are written using LLVM IR, by specifying a <code class="docutils literal notranslate"><span class="pre">&#64;src</span></code> and <code class="docutils literal notranslate"><span class="pre">&#64;tgt</span></code> function.
It is possible to include multiple proofs in a single file by giving the src
and tgt functions matching suffixes.</p>
<p>For example, here is a pair of proofs that both <code class="docutils literal notranslate"><span class="pre">(x-y)+y</span></code> and <code class="docutils literal notranslate"><span class="pre">(x+y)-y</span></code> can
be simplified to <code class="docutils literal notranslate"><span class="pre">x</span></code> (<a class="reference external" href="https://alive2.llvm.org/ce/z/MsPPGz">online</a>):</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="vg">@src_add_sub</span><span class="p">(</span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%add</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="nv">%y</span>
<span class="w">  </span><span class="nv">%sub</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">sub</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%add</span><span class="p">,</span><span class="w"> </span><span class="nv">%y</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%sub</span>
<span class="p">}</span>

<span class="k">define</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="vg">@tgt_add_sub</span><span class="p">(</span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span>
<span class="p">}</span>


<span class="k">define</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="vg">@src_sub_add</span><span class="p">(</span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%sub</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">sub</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="nv">%y</span>
<span class="w">  </span><span class="nv">%add</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%sub</span><span class="p">,</span><span class="w"> </span><span class="nv">%y</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%add</span>
<span class="p">}</span>

<span class="k">define</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="vg">@tgt_sub_add</span><span class="p">(</span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="use-generic-values-in-proofs">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Use generic values in proofs</a><a class="headerlink" href="#use-generic-values-in-proofs" title="Link to this heading">¶</a></h3>
<p>Proofs should operate on generic values, rather than specific constants, to the degree that this is possible.</p>
<p>For example, if we want to fold <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">s/</span> <span class="pre">C</span> <span class="pre">s&lt;</span> <span class="pre">X</span></code> to <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">s&gt;</span> <span class="pre">0</span></code>, the following would
be a <em>bad</em> proof:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="c">; Don&#39;t do this!</span>
<span class="k">define</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@src</span><span class="p">(</span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%div</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">sdiv</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="m">123</span>
<span class="w">  </span><span class="nv">%cmp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">slt</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%div</span><span class="p">,</span><span class="w"> </span><span class="nv">%x</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp</span>
<span class="p">}</span>

<span class="k">define</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@tgt</span><span class="p">(</span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%cmp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">sgt</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is because it only proves that the transform is correct for the specific
constant 123. Maybe there are some constants for which the transform is
incorrect?</p>
<p>The correct way to write this proof is as follows
(<a class="reference external" href="https://alive2.llvm.org/ce/z/acjwb6">online</a>):</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@src</span><span class="p">(</span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%C</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%precond</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">ne</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%C</span><span class="p">,</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.assume</span><span class="p">(</span><span class="kt">i1</span><span class="w"> </span><span class="nv">%precond</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%div</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">sdiv</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="nv">%C</span>
<span class="w">  </span><span class="nv">%cmp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">slt</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%div</span><span class="p">,</span><span class="w"> </span><span class="nv">%x</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp</span>
<span class="p">}</span>

<span class="k">define</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="vg">@tgt</span><span class="p">(</span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%C</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%cmp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">sgt</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">&#64;llvm.assume</span></code> intrinsic is used to specify pre-conditions for
the transform. In this case, the proof will fail unless we specify <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">!=</span> <span class="pre">1</span></code> as
a pre-condition.</p>
<p>It should be emphasized that there is, in general, no expectation that the
IR in the proofs will be transformed by the implemented fold. In the above
example, the transform would only apply if <code class="docutils literal notranslate"><span class="pre">%C</span></code> is actually a constant, but we
need to use non-constants in the proof.</p>
</section>
<section id="common-pre-conditions">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">Common pre-conditions</a><a class="headerlink" href="#common-pre-conditions" title="Link to this heading">¶</a></h3>
<p>Here are some examples of common preconditions.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="c">; %x is non-negative:</span>
<span class="nv">%nonneg</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">sgt</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="m">-1</span>
<span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.assume</span><span class="p">(</span><span class="kt">i1</span><span class="w"> </span><span class="nv">%nonneg</span><span class="p">)</span>

<span class="c">; %x is a power of two:</span>
<span class="nv">%ctpop</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="vg">@llvm.ctpop.i8</span><span class="p">(</span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span><span class="p">)</span>
<span class="nv">%pow2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">eq</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="m">1</span>
<span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.assume</span><span class="p">(</span><span class="kt">i1</span><span class="w"> </span><span class="nv">%pow2</span><span class="p">)</span>

<span class="c">; %x is a power of two or zero:</span>
<span class="nv">%ctpop</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="vg">@llvm.ctpop.i8</span><span class="p">(</span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span><span class="p">)</span>
<span class="nv">%pow2orzero</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">ult</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="m">2</span>
<span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.assume</span><span class="p">(</span><span class="kt">i1</span><span class="w"> </span><span class="nv">%pow2orzero</span><span class="p">)</span>

<span class="c">; Adding %x and %y does not overflow in a signed sense:</span>
<span class="nv">%wo</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">i8</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="vg">@llvm.sadd.with.overflow</span><span class="p">(</span><span class="kt">i8</span><span class="w"> </span><span class="nv">%x</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="nv">%y</span><span class="p">)</span>
<span class="nv">%ov</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">extractvalue</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">i8</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="nv">%wo</span><span class="p">,</span><span class="w"> </span><span class="m">1</span>
<span class="nv">%ov.not</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">xor</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%ov</span><span class="p">,</span><span class="w"> </span><span class="k">true</span>
<span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.assume</span><span class="p">(</span><span class="kt">i1</span><span class="w"> </span><span class="nv">%ov.not</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="timeouts">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">Timeouts</a><a class="headerlink" href="#timeouts" title="Link to this heading">¶</a></h3>
<p>Alive2 proofs will sometimes produce a timeout with the following message:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Alive2</span> <span class="n">timed</span> <span class="n">out</span> <span class="k">while</span> <span class="n">processing</span> <span class="n">your</span> <span class="n">query</span><span class="o">.</span>
<span class="n">There</span> <span class="n">are</span> <span class="n">a</span> <span class="n">few</span> <span class="n">things</span> <span class="n">you</span> <span class="n">can</span> <span class="k">try</span><span class="p">:</span>

<span class="o">-</span> <span class="n">remove</span> <span class="n">extraneous</span> <span class="n">instructions</span><span class="p">,</span> <span class="k">if</span> <span class="nb">any</span>

<span class="o">-</span> <span class="n">reduce</span> <span class="n">variable</span> <span class="n">widths</span><span class="p">,</span> <span class="k">for</span> <span class="n">example</span> <span class="n">to</span> <span class="n">i16</span><span class="p">,</span> <span class="n">i8</span><span class="p">,</span> <span class="ow">or</span> <span class="n">i4</span>

<span class="o">-</span> <span class="n">add</span> <span class="n">the</span> <span class="o">--</span><span class="n">disable</span><span class="o">-</span><span class="n">undef</span><span class="o">-</span><span class="nb">input</span> <span class="n">command</span> <span class="n">line</span> <span class="n">flag</span><span class="p">,</span> <span class="n">which</span>
  <span class="n">allows</span> <span class="n">Alive2</span> <span class="n">to</span> <span class="n">assume</span> <span class="n">that</span> <span class="n">arguments</span> <span class="n">to</span> <span class="n">your</span> <span class="n">IR</span> <span class="n">are</span> <span class="ow">not</span>
  <span class="n">undef</span><span class="o">.</span> <span class="n">This</span> <span class="ow">is</span><span class="p">,</span> <span class="ow">in</span> <span class="n">general</span><span class="p">,</span> <span class="n">unsound</span><span class="p">:</span> <span class="n">it</span> <span class="n">can</span> <span class="n">cause</span> <span class="n">Alive2</span>
  <span class="n">to</span> <span class="n">miss</span> <span class="n">bugs</span><span class="o">.</span>
</pre></div>
</div>
<p>This is good advice, follow it!</p>
<p>Reducing the bitwidth usually helps. For floating point numbers, you can use
the <code class="docutils literal notranslate"><span class="pre">half</span></code> type for bitwidth reduction purposes. For pointers, you can reduce
the bitwidth by specifying a custom data layout:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="c">; For 16-bit pointers</span>
<span class="k">target</span><span class="w"> </span><span class="k">datalayout</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;p:16:16&quot;</span>
</pre></div>
</div>
<p>If reducing the bitwidth does not help, try <code class="docutils literal notranslate"><span class="pre">-disable-undef-input</span></code>. This will
often significantly improve performance, but also implies that the correctness
of the transform with <code class="docutils literal notranslate"><span class="pre">undef</span></code> values is no longer verified. This is usually
fine if the transform does not increase the number of uses of any value.</p>
<p>Finally, it’s possible to build alive2 locally and use <code class="docutils literal notranslate"><span class="pre">-smt-to=&lt;m&gt;</span></code> to verify
the proof with a larger timeout. If you don’t want to do this (or it still
does not work), please submit the proof you have despite the timeout.</p>
</section>
</section>
<section id="implementation">
<h2><a class="toc-backref" href="#id17" role="doc-backlink">Implementation</a><a class="headerlink" href="#implementation" title="Link to this heading">¶</a></h2>
<section id="real-world-usefulness">
<h3><a class="toc-backref" href="#id18" role="doc-backlink">Real-world usefulness</a><a class="headerlink" href="#real-world-usefulness" title="Link to this heading">¶</a></h3>
<p>There is a very large number of transforms that <em>could</em> be implemented, but
only a tiny fraction of them are useful for real-world code.</p>
<p>Transforms that do not have real-world usefulness provide <em>negative</em> value to
the LLVM project, by taking up valuable reviewer time, increasing code
complexity and increasing compile-time overhead.</p>
<p>We do not require explicit proof of real-world usefulness for every transform
– in most cases the usefulness is fairly “obvious”. However, the question may
come up for complex or unusual folds. Keep this in mind when chosing what you
work on.</p>
<p>In particular, fixes for fuzzer-generated missed optimization reports will
likely be rejected if there is no evidence of real-world usefulness.</p>
</section>
<section id="pick-the-correct-optimization-pass">
<h3><a class="toc-backref" href="#id19" role="doc-backlink">Pick the correct optimization pass</a><a class="headerlink" href="#pick-the-correct-optimization-pass" title="Link to this heading">¶</a></h3>
<p>There are a number of passes and utilities in the InstCombine family, and it
is important to pick the right place when implementing a fold.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ConstantFolding</span></code>: For folding instructions with constant arguments to a constant. (Mainly relevant for intrinsics.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ValueTracking</span></code>: For analyzing instructions, e.g. for known bits, non-zero, etc. Tests should usually use <code class="docutils literal notranslate"><span class="pre">-passes=instsimplify</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">InstructionSimplify</span></code>: For folds that do not create new instructions (either fold to existing value or constant).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">InstCombine</span></code>: For folds that create or modify instructions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AggressiveInstCombine</span></code>: For folds that are expensive, or violate InstCombine requirements.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VectorCombine</span></code>: For folds of vector operations that require target-dependent cost-modelling.</p></li>
</ul>
<p>Sometimes, folds that logically belong in InstSimplify are placed in InstCombine instead, for example because they are too expensive, or because they are structurally simpler to implement in InstCombine.</p>
<p>For example, if a fold produces new instructions in some cases but returns an existing value in others, it may be preferable to keep all cases in InstCombine, rather than trying to split them among InstCombine and InstSimplify.</p>
</section>
<section id="canonicalization-and-target-independence">
<h3><a class="toc-backref" href="#id20" role="doc-backlink">Canonicalization and target-independence</a><a class="headerlink" href="#canonicalization-and-target-independence" title="Link to this heading">¶</a></h3>
<p>InstCombine is a target-independent canonicalization pass. This means that it
tries to bring IR into a “canonical form” that other optimizations (both inside
and outside of InstCombine) can rely on. For this reason, the chosen canonical
form needs to be the same for all targets, and not depend on target-specific
cost modelling.</p>
<p>In many cases, “canonicalization” and “optimization” coincide. For example, if
we convert <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">2</span></code> into <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;&lt;</span> <span class="pre">1</span></code>, this both makes the IR more canonical
(because there is now only one way to express the same operation, rather than
two) and faster (because shifts will usually have lower latency than
multiplies).</p>
<p>However, there are also canonicalizations that don’t serve any direct
optimization purpose. For example, InstCombine will canonicalize non-strict
predicates like <code class="docutils literal notranslate"><span class="pre">ule</span></code> to strict predicates like <code class="docutils literal notranslate"><span class="pre">ult</span></code>. <code class="docutils literal notranslate"><span class="pre">icmp</span> <span class="pre">ule</span> <span class="pre">i8</span> <span class="pre">%x,</span> <span class="pre">7</span></code>
becomes <code class="docutils literal notranslate"><span class="pre">icmp</span> <span class="pre">ult</span> <span class="pre">i8</span> <span class="pre">%x,</span> <span class="pre">8</span></code>. This is not an optimization in any meaningful
sense, but it does reduce the number of cases that other transforms need to
handle.</p>
<p>If some canonicalization is not profitable for a specific target, then a reverse
transform needs to be added in the backend. Patches to disable specific
InstCombine transforms on certain targets, or to drive them using
target-specific cost-modelling, <strong>will not be accepted</strong>. The only permitted
target-dependence is on DataLayout and TargetLibraryInfo.</p>
<p>The use of TargetTransformInfo is only allowed for hooks for target-specific
intrinsics, such as <code class="docutils literal notranslate"><span class="pre">TargetTransformInfo::instCombineIntrinsic()</span></code>. These are
already inherently target-dependent anyway.</p>
<p>If some canonicalization narrow/widen the integer width of expressions, please
check <code class="docutils literal notranslate"><span class="pre">shouldChangeType()</span></code> first. Otherwise, we may evaluate the expression
in illegal/inefficient types.</p>
<p>For vector-specific transforms that require cost-modelling, the VectorCombine
pass can be used instead. In very rare circumstances, if there are no other
alternatives, target-dependent transforms may be accepted into
AggressiveInstCombine.</p>
<p>Generally, we prefer unsigned operations over signed operations in the middle-end, even
if signed operations are more efficient on some targets. The following is an incomplete
list of canonicalizations that are implemented in InstCombine:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Original Pattern</p></th>
<th class="head"><p>Canonical Form</p></th>
<th class="head"><p>Condition</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">icmp</span> <span class="pre">spred</span> <span class="pre">X,</span> <span class="pre">Y</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">icmp</span> <span class="pre">samesign</span> <span class="pre">upred</span> <span class="pre">X,</span> <span class="pre">Y</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sign(X)</span> <span class="pre">==</span> <span class="pre">sign(Y)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">smin/smax</span> <span class="pre">X,</span> <span class="pre">Y</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">umin/umax</span> <span class="pre">X,</span> <span class="pre">Y</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sign(X)</span> <span class="pre">==</span> <span class="pre">sign(Y)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sext</span> <span class="pre">X</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">zext</span> <span class="pre">nneg</span> <span class="pre">X</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">&gt;=s</span> <span class="pre">0</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sitofp</span> <span class="pre">X</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">uitofp</span> <span class="pre">nneg</span> <span class="pre">X</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">&gt;=s</span> <span class="pre">0</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ashr</span> <span class="pre">X,</span> <span class="pre">Y</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">lshr</span> <span class="pre">X,</span> <span class="pre">Y</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">&gt;=s</span> <span class="pre">0</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sdiv/srem</span> <span class="pre">X,</span> <span class="pre">Y</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">udiv/urem</span> <span class="pre">X,</span> <span class="pre">Y</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">&gt;=s</span> <span class="pre">0</span> <span class="pre">&amp;&amp;</span> <span class="pre">Y</span> <span class="pre">&gt;=s</span> <span class="pre">0</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">X,</span> <span class="pre">Y</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">or</span> <span class="pre">disjoint</span> <span class="pre">X,</span> <span class="pre">Y</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(X</span> <span class="pre">&amp;</span> <span class="pre">Y)</span> <span class="pre">!=</span> <span class="pre">0</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">mul</span> <span class="pre">X,</span> <span class="pre">C</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">shl</span> <span class="pre">X,</span> <span class="pre">Log2(C)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">isPowerOf2(C)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">select</span> <span class="pre">Cond1,</span> <span class="pre">Cond2,</span> <span class="pre">false</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">and</span> <span class="pre">Cond1,</span> <span class="pre">Cond2</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">impliesPoison(Cond2,</span> <span class="pre">Cond1)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">select</span> <span class="pre">Cond1,</span> <span class="pre">true,</span> <span class="pre">Cond2</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">or</span> <span class="pre">Cond1,</span> <span class="pre">Cond2</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">impliesPoison(Cond2,</span> <span class="pre">Cond1)</span></code></p></td>
</tr>
</tbody>
</table>
</section>
<section id="patternmatch">
<h3><a class="toc-backref" href="#id21" role="doc-backlink">PatternMatch</a><a class="headerlink" href="#patternmatch" title="Link to this heading">¶</a></h3>
<p>Many transforms make use of the matching infrastructure defined in
<a class="reference external" href="https://github.com/llvm/llvm-project/blame/main/llvm/include/llvm/IR/PatternMatch.h">PatternMatch.h</a>.</p>
<p>Here is a typical usage example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Fold</span> <span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">B</span><span class="p">)</span> <span class="o">+</span> <span class="n">B</span> <span class="ow">and</span> <span class="n">B</span> <span class="o">+</span> <span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">B</span><span class="p">)</span> <span class="n">to</span> <span class="n">A</span><span class="o">.</span>
<span class="n">Value</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="o">*</span><span class="n">B</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">m_c_Add</span><span class="p">(</span><span class="n">m_Sub</span><span class="p">(</span><span class="n">m_Value</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">m_Value</span><span class="p">(</span><span class="n">B</span><span class="p">)),</span> <span class="n">m_Deferred</span><span class="p">(</span><span class="n">B</span><span class="p">))))</span>
  <span class="k">return</span> <span class="n">A</span><span class="p">;</span>
</pre></div>
</div>
<p>And another:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Fold</span> <span class="n">A</span> <span class="o">+</span> <span class="n">C1</span> <span class="o">==</span> <span class="n">C2</span> <span class="n">to</span> <span class="n">A</span> <span class="o">==</span> <span class="n">C1</span><span class="o">+</span><span class="n">C2</span>
<span class="n">Value</span> <span class="o">*</span><span class="n">A</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">m_ICmp</span><span class="p">(</span><span class="n">Pred</span><span class="p">,</span> <span class="n">m_Add</span><span class="p">(</span><span class="n">m_Value</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">m_APInt</span><span class="p">(</span><span class="n">C1</span><span class="p">)),</span> <span class="n">m_APInt</span><span class="p">(</span><span class="n">C2</span><span class="p">)))</span> <span class="o">&amp;&amp;</span>
    <span class="n">ICmpInst</span><span class="p">::</span><span class="n">isEquality</span><span class="p">(</span><span class="n">Pred</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">Builder</span><span class="o">.</span><span class="n">CreateICmp</span><span class="p">(</span><span class="n">Pred</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span>
                            <span class="n">ConstantInt</span><span class="p">::</span><span class="n">get</span><span class="p">(</span><span class="n">A</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">(),</span> <span class="o">*</span><span class="n">C1</span> <span class="o">+</span> <span class="o">*</span><span class="n">C2</span><span class="p">));</span>
</pre></div>
</div>
<p>Some common matchers are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">m_Value(A)</span></code>: Match any value and write it into <code class="docutils literal notranslate"><span class="pre">Value</span> <span class="pre">*A</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">m_Specific(A)</span></code>: Check that the operand equals A. Use this if A is
assigned <strong>outside</strong> the pattern.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">m_Deferred(A)</span></code>: Check that the operand equals A. Use this if A is
assigned <strong>inside</strong> the pattern, for example via <code class="docutils literal notranslate"><span class="pre">m_Value(A)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">m_APInt(C)</span></code>: Match a scalar integer constant or splat vector constant into
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">APInt</span> <span class="pre">*C</span></code>. Does not permit undef/poison values.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">m_ImmConstant(C)</span></code>: Match any non-constant-expression constant into
<code class="docutils literal notranslate"><span class="pre">Constant</span> <span class="pre">*C</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">m_Constant(C)</span></code>: Match any constant into <code class="docutils literal notranslate"><span class="pre">Constant</span> <span class="pre">*C</span></code>. Don’t use this unless
you know what you’re doing.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">m_Add(M1,</span> <span class="pre">M2)</span></code>, <code class="docutils literal notranslate"><span class="pre">m_Sub(M1,</span> <span class="pre">M2)</span></code>, etc: Match an add/sub/etc where the first
operand matches M1 and the second M2.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">m_c_Add(M1,</span> <span class="pre">M2)</span></code>, etc: Match an add commutatively. The operands must match
either M1 and M2 or M2 and M1. Most instruction matchers have a commutative
variant.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">m_ICmp(Pred,</span> <span class="pre">M1,</span> <span class="pre">M2)</span></code> and <code class="docutils literal notranslate"><span class="pre">m_c_ICmp(Pred,</span> <span class="pre">M1,</span> <span class="pre">M2)</span></code>: Match an icmp, writing
the predicate into <code class="docutils literal notranslate"><span class="pre">IcmpInst::Predicate</span> <span class="pre">Pred</span></code>. If the commutative version
is used, and the operands match in order M2, M1, then <code class="docutils literal notranslate"><span class="pre">Pred</span></code> will be the
swapped predicate.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">m_OneUse(M)</span></code>: Check that the value only has one use, and also matches M.
For example <code class="docutils literal notranslate"><span class="pre">m_OneUse(m_Add(...))</span></code>. See the next section for more
information.</p></li>
</ul>
<p>See the header for the full list of available matchers.</p>
</section>
<section id="instcombine-apis">
<h3><a class="toc-backref" href="#id22" role="doc-backlink">InstCombine APIs</a><a class="headerlink" href="#instcombine-apis" title="Link to this heading">¶</a></h3>
<p>InstCombine transforms are handled by <code class="docutils literal notranslate"><span class="pre">visitXYZ()</span></code> methods, where XYZ
corresponds to the root instruction of your transform. If the outermost
instruction of the pattern you are matching is an icmp, the fold will be
located somewhere inside <code class="docutils literal notranslate"><span class="pre">visitICmpInst()</span></code>.</p>
<p>The return value of the visit method is an instruction. You can either return
a new instruction, in which case it will be inserted before the old one, and
uses of the old one will be replaced by it. Or you can return the original
instruction to indicate that <em>some</em> kind of change has been made. Finally, a
nullptr return value indicates that no change occurred.</p>
<p>For example, if your transform produces a single new icmp instruction, you could
write the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">new</span> <span class="n">ICmpInst</span><span class="p">(</span><span class="n">Pred</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">);</span>
</pre></div>
</div>
<p>In this case the main InstCombine loop takes care of inserting the instruction
and replacing uses of the old instruction.</p>
<p>Alternatively, you can also write it like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="o">...</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">replaceInstUsesWith</span><span class="p">(</span><span class="n">OrigI</span><span class="p">,</span> <span class="n">Builder</span><span class="o">.</span><span class="n">CreateICmp</span><span class="p">(</span><span class="n">Pred</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">));</span>
</pre></div>
</div>
<p>In this case <code class="docutils literal notranslate"><span class="pre">IRBuilder</span></code> will insert the instruction and <code class="docutils literal notranslate"><span class="pre">replaceInstUsesWith()</span></code>
will replace the uses of the old instruction, and return it to indicate that
a change occurred.</p>
<p>Both forms are equivalent, and you can use whichever is more convenient in
context. For example, it’s common that folds are inside helper functions that
return <code class="docutils literal notranslate"><span class="pre">Value</span> <span class="pre">*</span></code> and then <code class="docutils literal notranslate"><span class="pre">replaceInstUsesWith()</span></code> is invoked on the result of
that helper.</p>
<p>InstCombine makes use of a worklist, which needs to be correctly updated during
transforms. This usually happens automatically, but there are some things to
keep in mind:</p>
<ul class="simple">
<li><p>Don’t use the <code class="docutils literal notranslate"><span class="pre">Value::replaceAllUsesWith()</span></code> API. Use InstCombine’s
<code class="docutils literal notranslate"><span class="pre">replaceInstUsesWith()</span></code> helper instead.</p></li>
<li><p>Don’t use the <code class="docutils literal notranslate"><span class="pre">Instruction::eraseFromParent()</span></code> API. Use InstCombine’s
<code class="docutils literal notranslate"><span class="pre">eraseInstFromFunction()</span></code> helper instead. (Explicitly erasing instruction
is usually not necessary, as side-effect free instructions without users
are automatically removed.)</p></li>
<li><p>Apart from the “directly return an instruction” pattern above, use IRBUilder
to create all instruction. Do not manually create and insert them.</p></li>
<li><p>When replacing operands or uses of instructions, use <code class="docutils literal notranslate"><span class="pre">replaceOperand()</span></code>
and <code class="docutils literal notranslate"><span class="pre">replaceUse()</span></code> instead of <code class="docutils literal notranslate"><span class="pre">setOperand()</span></code>.</p></li>
</ul>
</section>
<section id="multi-use-handling">
<h3><a class="toc-backref" href="#id23" role="doc-backlink">Multi-use handling</a><a class="headerlink" href="#multi-use-handling" title="Link to this heading">¶</a></h3>
<p>Transforms should usually not increase the total number of instructions. This
is not a hard requirement: For example, it is usually worthwhile to replace a
single division instruction with multiple other instructions.</p>
<p>For example, if you have a transform that replaces two instructions, with two
other instructions, this is (usually) only profitable if <em>both</em> the original
instructions can be removed. To ensure that both instructions are removed, you
need to add a one-use check for the inner instruction.</p>
<p>One-use checks can be performed using the <code class="docutils literal notranslate"><span class="pre">m_OneUse()</span></code> matcher, or the
<code class="docutils literal notranslate"><span class="pre">V-&gt;hasOneUse()</span></code> method.</p>
</section>
<section id="flag-handling">
<h3><a class="toc-backref" href="#id24" role="doc-backlink">Flag handling</a><a class="headerlink" href="#flag-handling" title="Link to this heading">¶</a></h3>
<p>When possible, favour propagation of poison-generating flags like <code class="docutils literal notranslate"><span class="pre">nuw</span></code> and <code class="docutils literal notranslate"><span class="pre">nsw</span></code> since they may be
hard to salvage later. Avoid doing so if it introduces additional complexity (e.g. requires querying <code class="docutils literal notranslate"><span class="pre">willNotOverflow</span></code>
or KnownBits).</p>
<p>Be careful with in-place operand/predicate changes, as poison-generating flags may not be valid for new
operands. It is recommended to create a new instruction with careful handling of flags. If not
applicable, call <code class="docutils literal notranslate"><span class="pre">Instruction::dropPoisonGeneratingFlags()</span></code> to clear flags in a conservative manner.</p>
<p>Do not rely on fcmp’s <code class="docutils literal notranslate"><span class="pre">nsz</span></code> flag to perform optimizations. It is meaningless for fcmp so it should not affect
the optimization.</p>
</section>
<section id="generalization">
<h3><a class="toc-backref" href="#id25" role="doc-backlink">Generalization</a><a class="headerlink" href="#generalization" title="Link to this heading">¶</a></h3>
<p>Transforms can both be too specific (only handling some odd subset of patterns,
leading to unexpected optimization cliffs) and too general (introducing
complexity to handle cases with no real-world relevance). The right level of
generality is quite subjective, so this section only provides some broad
guidelines.</p>
<ul class="simple">
<li><p>Avoid transforms that are hardcoded to specific constants. Try to figure
out what the general rule for arbitrary constants is.</p></li>
<li><p>Add handling for conjugate patterns. For example, if you implement a fold
for <code class="docutils literal notranslate"><span class="pre">icmp</span> <span class="pre">eq</span></code>, you almost certainly also want to support <code class="docutils literal notranslate"><span class="pre">icmp</span> <span class="pre">ne</span></code>, with the
inverse result. Similarly, if you implement a pattern for <code class="docutils literal notranslate"><span class="pre">and</span></code> of <code class="docutils literal notranslate"><span class="pre">icmp</span></code>s,
you should also handle the de-Morgan conjugate using <code class="docutils literal notranslate"><span class="pre">or</span></code>.</p></li>
<li><p>Handle non-splat vector constants if doing so is free, but do not add
handling for them if it adds any additional complexity to the code.</p></li>
<li><p>Do not handle non-canonical patterns, unless there is a specific motivation
to do so. For example, it may sometimes be worthwhile to handle a pattern
that would normally be converted into a different canonical form, but can
still occur in multi-use scenarios. This is fine to do if there is specific
real-world motivation, but you should not go out of your way to do this
otherwise.</p></li>
<li><p>Sometimes the motivating pattern uses a constant value with certain
properties, but the fold can be generalized to non-constant values by making
use of ValueTracking queries. Whether this makes sense depends on the case,
but it’s usually a good idea to only handle the constant pattern first, and
then generalize later if it seems useful.</p></li>
<li><p>When possible, handle more canonical patterns as well. It is encouraged to avoid
potential phase-ordering issues. For example, if the motivating transform holds for
<code class="docutils literal notranslate"><span class="pre">add</span></code>, it also holds for <code class="docutils literal notranslate"><span class="pre">or</span> <span class="pre">disjoint</span></code>. See the canonicalization list above for details.
In most cases, it can be easily implemented with matchers like
<code class="docutils literal notranslate"><span class="pre">m_AddLike/m_SExtLike/m_LogicalAnd/m_LogicalOr</span></code>.</p></li>
</ul>
</section>
</section>
<section id="guidelines-for-reviewers">
<h2><a class="toc-backref" href="#id26" role="doc-backlink">Guidelines for reviewers</a><a class="headerlink" href="#guidelines-for-reviewers" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>Do not ask new contributors to implement non-splat vector support in code
reviews. If you think non-splat vector support for a fold is both
worthwhile and policy-compliant (that is, the handling would not result in
any appreciable increase in code complexity), implement it yourself in a
follow-up patch.</p></li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="InstrProfileFormat.html" title="Instrumentation Profile Format"
             >next</a> |</li>
        <li class="right" >
          <a href="HowToUpdateDebugInfo.html" title="How to Update Debug Info: A Guide for LLVM Pass Authors"
             >previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" >User Guides</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">InstCombine contributor guide</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2003-2025, LLVM Project.
      Last updated on 2025-08-26.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>