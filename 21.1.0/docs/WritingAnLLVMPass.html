
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Writing an LLVM Pass (legacy PM version) &#8212; LLVM 21.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/llvm-theme.css?v=96924833" />
    <script src="_static/documentation_options.js?v=c54a4614"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Writing an LLVM Pass" href="WritingAnLLVMNewPMPass.html" />
    <link rel="prev" title="The Sandbox Vectorizer" href="SandboxVectorizer.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="WritingAnLLVMNewPMPass.html" title="Writing an LLVM Pass"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="SandboxVectorizer.html" title="The Sandbox Vectorizer"
             accesskey="P">previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" accesskey="U">User Guides</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Writing an LLVM Pass (legacy PM version)</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="https://llvm.org/docs/UserGuides.html">User Guides</a></li>
    <li><a href="https://llvm.org/docs/Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/Contributing.html">Contributing to LLVM</a></li>
    <li><a href="https://llvm.org/docs/HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#discord">Discord</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/FAQ.html">FAQ</a></li>
    <li><a href="https://llvm.org/docs/Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project/">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/WritingAnLLVMPass.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="writing-an-llvm-pass-legacy-pm-version">
<h1>Writing an LLVM Pass (legacy PM version)<a class="headerlink" href="#writing-an-llvm-pass-legacy-pm-version" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction-what-is-a-pass" id="id2">Introduction — What is a pass?</a></p></li>
<li><p><a class="reference internal" href="#pass-classes-and-requirements" id="id3">Pass classes and requirements</a></p>
<ul>
<li><p><a class="reference internal" href="#the-immutablepass-class" id="id4">The <code class="docutils literal notranslate"><span class="pre">ImmutablePass</span></code> class</a></p></li>
<li><p><a class="reference internal" href="#the-modulepass-class" id="id5">The <code class="docutils literal notranslate"><span class="pre">ModulePass</span></code> class</a></p>
<ul>
<li><p><a class="reference internal" href="#the-runonmodule-method" id="id6">The <code class="docutils literal notranslate"><span class="pre">runOnModule</span></code> method</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-callgraphsccpass-class" id="id7">The <code class="docutils literal notranslate"><span class="pre">CallGraphSCCPass</span></code> class</a></p>
<ul>
<li><p><a class="reference internal" href="#the-doinitialization-callgraph-method" id="id8">The <code class="docutils literal notranslate"><span class="pre">doInitialization(CallGraph</span> <span class="pre">&amp;)</span></code> method</a></p></li>
<li><p><a class="reference internal" href="#the-runonscc-method" id="id9">The <code class="docutils literal notranslate"><span class="pre">runOnSCC</span></code> method</a></p></li>
<li><p><a class="reference internal" href="#the-dofinalization-callgraph-method" id="id10">The <code class="docutils literal notranslate"><span class="pre">doFinalization(CallGraph</span> <span class="pre">&amp;)</span></code> method</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-functionpass-class" id="id11">The <code class="docutils literal notranslate"><span class="pre">FunctionPass</span></code> class</a></p>
<ul>
<li><p><a class="reference internal" href="#the-doinitialization-module-method" id="id12">The <code class="docutils literal notranslate"><span class="pre">doInitialization(Module</span> <span class="pre">&amp;)</span></code> method</a></p></li>
<li><p><a class="reference internal" href="#the-runonfunction-method" id="id13">The <code class="docutils literal notranslate"><span class="pre">runOnFunction</span></code> method</a></p></li>
<li><p><a class="reference internal" href="#the-dofinalization-module-method" id="id14">The <code class="docutils literal notranslate"><span class="pre">doFinalization(Module</span> <span class="pre">&amp;)</span></code> method</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-looppass-class" id="id15">The <code class="docutils literal notranslate"><span class="pre">LoopPass</span></code> class</a></p>
<ul>
<li><p><a class="reference internal" href="#the-doinitialization-loop-lppassmanager-method" id="id16">The <code class="docutils literal notranslate"><span class="pre">doInitialization(Loop</span> <span class="pre">*,</span> <span class="pre">LPPassManager</span> <span class="pre">&amp;)</span></code> method</a></p></li>
<li><p><a class="reference internal" href="#the-runonloop-method" id="id17">The <code class="docutils literal notranslate"><span class="pre">runOnLoop</span></code> method</a></p></li>
<li><p><a class="reference internal" href="#the-dofinalization-method" id="id18">The <code class="docutils literal notranslate"><span class="pre">doFinalization()</span></code> method</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-regionpass-class" id="id19">The <code class="docutils literal notranslate"><span class="pre">RegionPass</span></code> class</a></p>
<ul>
<li><p><a class="reference internal" href="#the-doinitialization-region-rgpassmanager-method" id="id20">The <code class="docutils literal notranslate"><span class="pre">doInitialization(Region</span> <span class="pre">*,</span> <span class="pre">RGPassManager</span> <span class="pre">&amp;)</span></code> method</a></p></li>
<li><p><a class="reference internal" href="#the-runonregion-method" id="id21">The <code class="docutils literal notranslate"><span class="pre">runOnRegion</span></code> method</a></p></li>
<li><p><a class="reference internal" href="#id1" id="id22">The <code class="docutils literal notranslate"><span class="pre">doFinalization()</span></code> method</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-machinefunctionpass-class" id="id23">The <code class="docutils literal notranslate"><span class="pre">MachineFunctionPass</span></code> class</a></p>
<ul>
<li><p><a class="reference internal" href="#the-runonmachinefunction-machinefunction-mf-method" id="id24">The <code class="docutils literal notranslate"><span class="pre">runOnMachineFunction(MachineFunction</span> <span class="pre">&amp;MF)</span></code> method</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#pass-registration" id="id25">Pass registration</a></p>
<ul>
<li><p><a class="reference internal" href="#the-print-method" id="id26">The <code class="docutils literal notranslate"><span class="pre">print</span></code> method</a></p></li>
<li><p><a class="reference internal" href="#scheduling-a-machinefunctionpass" id="id27">Scheduling a MachineFunctionPass</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#specifying-interactions-between-passes" id="id28">Specifying interactions between passes</a></p>
<ul>
<li><p><a class="reference internal" href="#the-getanalysisusage-method" id="id29">The <code class="docutils literal notranslate"><span class="pre">getAnalysisUsage</span></code> method</a></p></li>
<li><p><a class="reference internal" href="#the-analysisusage-addrequired-and-analysisusage-addrequiredtransitive-methods" id="id30">The <code class="docutils literal notranslate"><span class="pre">AnalysisUsage::addRequired&lt;&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">AnalysisUsage::addRequiredTransitive&lt;&gt;</span></code> methods</a></p></li>
<li><p><a class="reference internal" href="#the-analysisusage-addpreserved-method" id="id31">The <code class="docutils literal notranslate"><span class="pre">AnalysisUsage::addPreserved&lt;&gt;</span></code> method</a></p></li>
<li><p><a class="reference internal" href="#example-implementations-of-getanalysisusage" id="id32">Example implementations of <code class="docutils literal notranslate"><span class="pre">getAnalysisUsage</span></code></a></p></li>
<li><p><a class="reference internal" href="#the-getanalysis-and-getanalysisifavailable-methods" id="id33">The <code class="docutils literal notranslate"><span class="pre">getAnalysis&lt;&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">getAnalysisIfAvailable&lt;&gt;</span></code> methods</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#pass-statistics" id="id34">Pass Statistics</a></p>
<ul>
<li><p><a class="reference internal" href="#what-passmanager-does" id="id35">What PassManager does</a></p>
<ul>
<li><p><a class="reference internal" href="#the-releasememory-method" id="id36">The <code class="docutils literal notranslate"><span class="pre">releaseMemory</span></code> method</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#registering-dynamically-loaded-passes" id="id37">Registering dynamically loaded passes</a></p>
<ul>
<li><p><a class="reference internal" href="#using-existing-registries" id="id38">Using existing registries</a></p></li>
<li><p><a class="reference internal" href="#creating-new-registries" id="id39">Creating new registries</a></p></li>
<li><p><a class="reference internal" href="#using-gdb-with-dynamically-loaded-passes" id="id40">Using GDB with dynamically loaded passes</a></p>
<ul>
<li><p><a class="reference internal" href="#setting-a-breakpoint-in-your-pass" id="id41">Setting a breakpoint in your pass</a></p></li>
<li><p><a class="reference internal" href="#miscellaneous-problems" id="id42">Miscellaneous Problems</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<section id="introduction-what-is-a-pass">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Introduction — What is a pass?</a><a class="headerlink" href="#introduction-what-is-a-pass" title="Link to this heading">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This document deals with the legacy pass manager. LLVM uses the new pass
manager for the optimization pipeline (the codegen pipeline
still uses the legacy pass manager), which has its own way of defining
passes. For more details, see <a class="reference internal" href="WritingAnLLVMNewPMPass.html"><span class="doc">Writing an LLVM Pass</span></a> and
<a class="reference internal" href="NewPassManager.html"><span class="doc">Using the New Pass Manager</span></a>.</p>
</div>
<p>The LLVM Pass Framework is an important part of the LLVM system, because LLVM
passes are where most of the interesting parts of the compiler exist.  Passes
perform the transformations and optimizations that make up the compiler, they
build the analysis results that are used by these transformations, and they
are, above all, a structuring technique for compiler code.</p>
<p>All LLVM passes are subclasses of the <a class="reference external" href="https://llvm.org/doxygen/classllvm_1_1Pass.html">Pass</a> class, which implement
functionality by overriding virtual methods inherited from <code class="docutils literal notranslate"><span class="pre">Pass</span></code>.  Depending
on how your pass works, you should inherit from the <a class="reference internal" href="#writing-an-llvm-pass-modulepass"><span class="std std-ref">ModulePass</span></a> , <a class="reference internal" href="#writing-an-llvm-pass-callgraphsccpass"><span class="std std-ref">CallGraphSCCPass</span></a>, <a class="reference internal" href="#writing-an-llvm-pass-functionpass"><span class="std std-ref">FunctionPass</span></a> , or <a class="reference internal" href="#writing-an-llvm-pass-looppass"><span class="std std-ref">LoopPass</span></a>, or <a class="reference internal" href="#writing-an-llvm-pass-regionpass"><span class="std std-ref">RegionPass</span></a> classes, which gives the system more
information about what your pass does, and how it can be combined with other
passes.  One of the main features of the LLVM Pass Framework is that it
schedules passes to run in an efficient way based on the constraints that your
pass meets (which are indicated by which class they derive from).</p>
</section>
<section id="pass-classes-and-requirements">
<span id="writing-an-llvm-pass-pass-classes"></span><h2><a class="toc-backref" href="#id3" role="doc-backlink">Pass classes and requirements</a><a class="headerlink" href="#pass-classes-and-requirements" title="Link to this heading">¶</a></h2>
<p>One of the first things that you should do when designing a new pass is to
decide what class you should subclass for your pass. Here we talk about the
classes available, from the most general to the most specific.</p>
<p>When choosing a superclass for your <code class="docutils literal notranslate"><span class="pre">Pass</span></code>, you should choose the <strong>most
specific</strong> class possible, while still being able to meet the requirements
listed.  This gives the LLVM Pass Infrastructure information necessary to
optimize how passes are run, so that the resultant compiler isn’t unnecessarily
slow.</p>
<section id="the-immutablepass-class">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">ImmutablePass</span></code> class</a><a class="headerlink" href="#the-immutablepass-class" title="Link to this heading">¶</a></h3>
<p>The most plain and boring type of pass is the “<a class="reference external" href="https://llvm.org/doxygen/classllvm_1_1ImmutablePass.html">ImmutablePass</a>” class.  This pass
type is used for passes that do not have to be run, do not change state, and
never need to be updated.  This is not a normal type of transformation or
analysis, but can provide information about the current compiler configuration.</p>
<p>Although this pass class is very infrequently used, it is important for
providing information about the current target machine being compiled for, and
other static information that can affect the various transformations.</p>
<p><code class="docutils literal notranslate"><span class="pre">ImmutablePass</span></code>es never invalidate other transformations, are never
invalidated, and are never “run”.</p>
</section>
<section id="the-modulepass-class">
<span id="writing-an-llvm-pass-modulepass"></span><h3><a class="toc-backref" href="#id5" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">ModulePass</span></code> class</a><a class="headerlink" href="#the-modulepass-class" title="Link to this heading">¶</a></h3>
<p>The <a class="reference external" href="https://llvm.org/doxygen/classllvm_1_1ModulePass.html">ModulePass</a> class
is the most general of all superclasses that you can use.  Deriving from
<code class="docutils literal notranslate"><span class="pre">ModulePass</span></code> indicates that your pass uses the entire program as a unit,
referring to function bodies in no predictable order, or adding and removing
functions.  Because nothing is known about the behavior of <code class="docutils literal notranslate"><span class="pre">ModulePass</span></code>
subclasses, no optimization can be done for their execution.</p>
<p>A module pass can use function level passes (e.g. dominators) using the
<code class="docutils literal notranslate"><span class="pre">getAnalysis</span></code> interface <code class="docutils literal notranslate"><span class="pre">getAnalysis&lt;DominatorTree&gt;(llvm::Function</span> <span class="pre">*)</span></code> to
provide the function to retrieve analysis result for, if the function pass does
not require any module or immutable passes.  Note that this can only be done
for functions for which the analysis ran, e.g. in the case of dominators you
should only ask for the <code class="docutils literal notranslate"><span class="pre">DominatorTree</span></code> for function definitions, not
declarations.</p>
<p>To write a correct <code class="docutils literal notranslate"><span class="pre">ModulePass</span></code> subclass, derive from <code class="docutils literal notranslate"><span class="pre">ModulePass</span></code> and
override the <code class="docutils literal notranslate"><span class="pre">runOnModule</span></code> method with the following signature:</p>
<section id="the-runonmodule-method">
<h4><a class="toc-backref" href="#id6" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">runOnModule</span></code> method</a><a class="headerlink" href="#the-runonmodule-method" title="Link to this heading">¶</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">runOnModule</span><span class="p">(</span><span class="n">Module</span><span class="w"> </span><span class="o">&amp;</span><span class="n">M</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">runOnModule</span></code> method performs the interesting work of the pass.  It
should return <code class="docutils literal notranslate"><span class="pre">true</span></code> if the module was modified by the transformation and
<code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</section>
</section>
<section id="the-callgraphsccpass-class">
<span id="writing-an-llvm-pass-callgraphsccpass"></span><h3><a class="toc-backref" href="#id7" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">CallGraphSCCPass</span></code> class</a><a class="headerlink" href="#the-callgraphsccpass-class" title="Link to this heading">¶</a></h3>
<p>The <a class="reference external" href="https://llvm.org/doxygen/classllvm_1_1CallGraphSCCPass.html">CallGraphSCCPass</a> is used by
passes that need to traverse the program bottom-up on the call graph (callees
before callers).  Deriving from <code class="docutils literal notranslate"><span class="pre">CallGraphSCCPass</span></code> provides some mechanics
for building and traversing the <code class="docutils literal notranslate"><span class="pre">CallGraph</span></code>, but also allows the system to
optimize execution of <code class="docutils literal notranslate"><span class="pre">CallGraphSCCPass</span></code>es.  If your pass meets the
requirements outlined below, and doesn’t meet the requirements of a
<a class="reference internal" href="#writing-an-llvm-pass-functionpass"><span class="std std-ref">FunctionPass</span></a>, you should derive from
<code class="docutils literal notranslate"><span class="pre">CallGraphSCCPass</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">TODO</span></code>: explain briefly what SCC, Tarjan’s algo, and B-U mean.</p>
<p>To be explicit, CallGraphSCCPass subclasses are:</p>
<ol class="arabic simple">
<li><p>… <em>not allowed</em> to inspect or modify any <code class="docutils literal notranslate"><span class="pre">Function</span></code>s other than those
in the current SCC and the direct callers and direct callees of the SCC.</p></li>
<li><p>… <em>required</em> to preserve the current <code class="docutils literal notranslate"><span class="pre">CallGraph</span></code> object, updating it to
reflect any changes made to the program.</p></li>
<li><p>… <em>not allowed</em> to add or remove SCC’s from the current Module, though
they may change the contents of an SCC.</p></li>
<li><p>… <em>allowed</em> to add or remove global variables from the current Module.</p></li>
<li><p>… <em>allowed</em> to maintain state across invocations of <a class="reference internal" href="#writing-an-llvm-pass-runonscc"><span class="std std-ref">runOnSCC</span></a> (including global data).</p></li>
</ol>
<p>Implementing a <code class="docutils literal notranslate"><span class="pre">CallGraphSCCPass</span></code> is slightly tricky in some cases because it
has to handle SCCs with more than one node in it.  All of the virtual methods
described below should return <code class="docutils literal notranslate"><span class="pre">true</span></code> if they modified the program, or
<code class="docutils literal notranslate"><span class="pre">false</span></code> if they didn’t.</p>
<section id="the-doinitialization-callgraph-method">
<h4><a class="toc-backref" href="#id8" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">doInitialization(CallGraph</span> <span class="pre">&amp;)</span></code> method</a><a class="headerlink" href="#the-doinitialization-callgraph-method" title="Link to this heading">¶</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">doInitialization</span><span class="p">(</span><span class="n">CallGraph</span><span class="w"> </span><span class="o">&amp;</span><span class="n">CG</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">doInitialization</span></code> method is allowed to do most of the things that
<code class="docutils literal notranslate"><span class="pre">CallGraphSCCPass</span></code>es are not allowed to do.  They can add and remove
functions, get pointers to functions, etc.  The <code class="docutils literal notranslate"><span class="pre">doInitialization</span></code> method is
designed to do simple initialization type of stuff that does not depend on the
SCCs being processed.  The <code class="docutils literal notranslate"><span class="pre">doInitialization</span></code> method call is not scheduled to
overlap with any other pass executions (thus it should be very fast).</p>
</section>
<section id="the-runonscc-method">
<span id="writing-an-llvm-pass-runonscc"></span><h4><a class="toc-backref" href="#id9" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">runOnSCC</span></code> method</a><a class="headerlink" href="#the-runonscc-method" title="Link to this heading">¶</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">runOnSCC</span><span class="p">(</span><span class="n">CallGraphSCC</span><span class="w"> </span><span class="o">&amp;</span><span class="n">SCC</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">runOnSCC</span></code> method performs the interesting work of the pass, and should
return <code class="docutils literal notranslate"><span class="pre">true</span></code> if the module was modified by the transformation, <code class="docutils literal notranslate"><span class="pre">false</span></code>
otherwise.</p>
</section>
<section id="the-dofinalization-callgraph-method">
<h4><a class="toc-backref" href="#id10" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">doFinalization(CallGraph</span> <span class="pre">&amp;)</span></code> method</a><a class="headerlink" href="#the-dofinalization-callgraph-method" title="Link to this heading">¶</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">doFinalization</span><span class="p">(</span><span class="n">CallGraph</span><span class="w"> </span><span class="o">&amp;</span><span class="n">CG</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">doFinalization</span></code> method is an infrequently used method that is called
when the pass framework has finished calling <a class="reference internal" href="#writing-an-llvm-pass-runonscc"><span class="std std-ref">runOnSCC</span></a> for every SCC in the program being compiled.</p>
</section>
</section>
<section id="the-functionpass-class">
<span id="writing-an-llvm-pass-functionpass"></span><h3><a class="toc-backref" href="#id11" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">FunctionPass</span></code> class</a><a class="headerlink" href="#the-functionpass-class" title="Link to this heading">¶</a></h3>
<p>In contrast to <code class="docutils literal notranslate"><span class="pre">ModulePass</span></code> subclasses, <a class="reference external" href="https://llvm.org/doxygen/classllvm_1_1Pass.html">FunctionPass</a> subclasses do have a
predictable, local behavior that can be expected by the system.  All
<code class="docutils literal notranslate"><span class="pre">FunctionPass</span></code> execute on each function in the program independent of all of
the other functions in the program.  <code class="docutils literal notranslate"><span class="pre">FunctionPass</span></code>es do not require that
they are executed in a particular order, and <code class="docutils literal notranslate"><span class="pre">FunctionPass</span></code>es do not modify
external functions.</p>
<p>To be explicit, <code class="docutils literal notranslate"><span class="pre">FunctionPass</span></code> subclasses are not allowed to:</p>
<ol class="arabic simple">
<li><p>Inspect or modify a <code class="docutils literal notranslate"><span class="pre">Function</span></code> other than the one currently being processed.</p></li>
<li><p>Add or remove <code class="docutils literal notranslate"><span class="pre">Function</span></code>s from the current <code class="docutils literal notranslate"><span class="pre">Module</span></code>.</p></li>
<li><p>Add or remove global variables from the current <code class="docutils literal notranslate"><span class="pre">Module</span></code>.</p></li>
<li><p>Maintain state across invocations of <a class="reference internal" href="#writing-an-llvm-pass-runonfunction"><span class="std std-ref">runOnFunction</span></a> (including global data).</p></li>
</ol>
<p>Implementing a <code class="docutils literal notranslate"><span class="pre">FunctionPass</span></code> is usually straightforward. <code class="docutils literal notranslate"><span class="pre">FunctionPass</span></code>es may override three virtual methods to do their work.  All of these methods
should return <code class="docutils literal notranslate"><span class="pre">true</span></code> if they modified the program, or <code class="docutils literal notranslate"><span class="pre">false</span></code> if they
didn’t.</p>
<section id="the-doinitialization-module-method">
<span id="writing-an-llvm-pass-doinitialization-mod"></span><h4><a class="toc-backref" href="#id12" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">doInitialization(Module</span> <span class="pre">&amp;)</span></code> method</a><a class="headerlink" href="#the-doinitialization-module-method" title="Link to this heading">¶</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">doInitialization</span><span class="p">(</span><span class="n">Module</span><span class="w"> </span><span class="o">&amp;</span><span class="n">M</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">doInitialization</span></code> method is allowed to do most of the things that
<code class="docutils literal notranslate"><span class="pre">FunctionPass</span></code>es are not allowed to do.  They can add and remove functions,
get pointers to functions, etc.  The <code class="docutils literal notranslate"><span class="pre">doInitialization</span></code> method is designed to
do simple initialization type of stuff that does not depend on the functions
being processed.  The <code class="docutils literal notranslate"><span class="pre">doInitialization</span></code> method call is not scheduled to
overlap with any other pass executions (thus it should be very fast).</p>
<p>A good example of how this method should be used is the <a class="reference external" href="https://llvm.org/doxygen/LowerAllocations_8cpp-source.html">LowerAllocations</a> pass.  This pass
converts <code class="docutils literal notranslate"><span class="pre">malloc</span></code> and <code class="docutils literal notranslate"><span class="pre">free</span></code> instructions into platform dependent
<code class="docutils literal notranslate"><span class="pre">malloc()</span></code> and <code class="docutils literal notranslate"><span class="pre">free()</span></code> function calls.  It uses the <code class="docutils literal notranslate"><span class="pre">doInitialization</span></code>
method to get a reference to the <code class="docutils literal notranslate"><span class="pre">malloc</span></code> and <code class="docutils literal notranslate"><span class="pre">free</span></code> functions that it
needs, adding prototypes to the module if necessary.</p>
</section>
<section id="the-runonfunction-method">
<span id="writing-an-llvm-pass-runonfunction"></span><h4><a class="toc-backref" href="#id13" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">runOnFunction</span></code> method</a><a class="headerlink" href="#the-runonfunction-method" title="Link to this heading">¶</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">runOnFunction</span><span class="p">(</span><span class="n">Function</span><span class="w"> </span><span class="o">&amp;</span><span class="n">F</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">runOnFunction</span></code> method must be implemented by your subclass to do the
transformation or analysis work of your pass.  As usual, a <code class="docutils literal notranslate"><span class="pre">true</span></code> value
should be returned if the function is modified.</p>
</section>
<section id="the-dofinalization-module-method">
<span id="writing-an-llvm-pass-dofinalization-mod"></span><h4><a class="toc-backref" href="#id14" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">doFinalization(Module</span> <span class="pre">&amp;)</span></code> method</a><a class="headerlink" href="#the-dofinalization-module-method" title="Link to this heading">¶</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">doFinalization</span><span class="p">(</span><span class="n">Module</span><span class="w"> </span><span class="o">&amp;</span><span class="n">M</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">doFinalization</span></code> method is an infrequently used method that is called
when the pass framework has finished calling <a class="reference internal" href="#writing-an-llvm-pass-runonfunction"><span class="std std-ref">runOnFunction</span></a> for every function in the program being
compiled.</p>
</section>
</section>
<section id="the-looppass-class">
<span id="writing-an-llvm-pass-looppass"></span><h3><a class="toc-backref" href="#id15" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">LoopPass</span></code> class</a><a class="headerlink" href="#the-looppass-class" title="Link to this heading">¶</a></h3>
<p>All <code class="docutils literal notranslate"><span class="pre">LoopPass</span></code> execute on each <a class="reference internal" href="LoopTerminology.html#loop-terminology"><span class="std std-ref">loop</span></a> in the function
independent of all of the other loops in the function.  <code class="docutils literal notranslate"><span class="pre">LoopPass</span></code> processes
loops in loop nest order such that outer most loop is processed last.</p>
<p><code class="docutils literal notranslate"><span class="pre">LoopPass</span></code> subclasses are allowed to update loop nest using <code class="docutils literal notranslate"><span class="pre">LPPassManager</span></code>
interface.  Implementing a loop pass is usually straightforward.
<code class="docutils literal notranslate"><span class="pre">LoopPass</span></code>es may override three virtual methods to do their work.  All
these methods should return <code class="docutils literal notranslate"><span class="pre">true</span></code> if they modified the program, or <code class="docutils literal notranslate"><span class="pre">false</span></code>
if they didn’t.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">LoopPass</span></code> subclass which is intended to run as part of the main loop pass
pipeline needs to preserve all of the same <em>function</em> analyses that the other
loop passes in its pipeline require. To make that easier,
a <code class="docutils literal notranslate"><span class="pre">getLoopAnalysisUsage</span></code> function is provided by <code class="docutils literal notranslate"><span class="pre">LoopUtils.h</span></code>. It can be
called within the subclass’s <code class="docutils literal notranslate"><span class="pre">getAnalysisUsage</span></code> override to get consistent
and correct behavior. Analogously, <code class="docutils literal notranslate"><span class="pre">INITIALIZE_PASS_DEPENDENCY(LoopPass)</span></code>
will initialize this set of function analyses.</p>
<section id="the-doinitialization-loop-lppassmanager-method">
<h4><a class="toc-backref" href="#id16" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">doInitialization(Loop</span> <span class="pre">*,</span> <span class="pre">LPPassManager</span> <span class="pre">&amp;)</span></code> method</a><a class="headerlink" href="#the-doinitialization-loop-lppassmanager-method" title="Link to this heading">¶</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">doInitialization</span><span class="p">(</span><span class="n">Loop</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">LPPassManager</span><span class="w"> </span><span class="o">&amp;</span><span class="n">LPM</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">doInitialization</span></code> method is designed to do simple initialization type of
stuff that does not depend on the functions being processed.  The
<code class="docutils literal notranslate"><span class="pre">doInitialization</span></code> method call is not scheduled to overlap with any other
pass executions (thus it should be very fast).  <code class="docutils literal notranslate"><span class="pre">LPPassManager</span></code> interface
should be used to access <code class="docutils literal notranslate"><span class="pre">Function</span></code> or <code class="docutils literal notranslate"><span class="pre">Module</span></code> level analysis information.</p>
</section>
<section id="the-runonloop-method">
<span id="writing-an-llvm-pass-runonloop"></span><h4><a class="toc-backref" href="#id17" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">runOnLoop</span></code> method</a><a class="headerlink" href="#the-runonloop-method" title="Link to this heading">¶</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">runOnLoop</span><span class="p">(</span><span class="n">Loop</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">LPPassManager</span><span class="w"> </span><span class="o">&amp;</span><span class="n">LPM</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">runOnLoop</span></code> method must be implemented by your subclass to do the
transformation or analysis work of your pass.  As usual, a <code class="docutils literal notranslate"><span class="pre">true</span></code> value
should be returned if the function is modified.  <code class="docutils literal notranslate"><span class="pre">LPPassManager</span></code> interface
should be used to update loop nest.</p>
</section>
<section id="the-dofinalization-method">
<h4><a class="toc-backref" href="#id18" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">doFinalization()</span></code> method</a><a class="headerlink" href="#the-dofinalization-method" title="Link to this heading">¶</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">doFinalization</span><span class="p">();</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">doFinalization</span></code> method is an infrequently used method that is called
when the pass framework has finished calling <a class="reference internal" href="#writing-an-llvm-pass-runonloop"><span class="std std-ref">runOnLoop</span></a> for every loop in the program being compiled.</p>
</section>
</section>
<section id="the-regionpass-class">
<span id="writing-an-llvm-pass-regionpass"></span><h3><a class="toc-backref" href="#id19" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">RegionPass</span></code> class</a><a class="headerlink" href="#the-regionpass-class" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">RegionPass</span></code> is similar to <a class="reference internal" href="#writing-an-llvm-pass-looppass"><span class="std std-ref">LoopPass</span></a>,
but executes on each single entry single exit region in the function.
<code class="docutils literal notranslate"><span class="pre">RegionPass</span></code> processes regions in nested order such that the outer most
region is processed last.</p>
<p><code class="docutils literal notranslate"><span class="pre">RegionPass</span></code> subclasses are allowed to update the region tree by using the
<code class="docutils literal notranslate"><span class="pre">RGPassManager</span></code> interface.  You may override three virtual methods of
<code class="docutils literal notranslate"><span class="pre">RegionPass</span></code> to implement your own region pass.  All these methods should
return <code class="docutils literal notranslate"><span class="pre">true</span></code> if they modified the program, or <code class="docutils literal notranslate"><span class="pre">false</span></code> if they did not.</p>
<section id="the-doinitialization-region-rgpassmanager-method">
<h4><a class="toc-backref" href="#id20" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">doInitialization(Region</span> <span class="pre">*,</span> <span class="pre">RGPassManager</span> <span class="pre">&amp;)</span></code> method</a><a class="headerlink" href="#the-doinitialization-region-rgpassmanager-method" title="Link to this heading">¶</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">doInitialization</span><span class="p">(</span><span class="n">Region</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">RGPassManager</span><span class="w"> </span><span class="o">&amp;</span><span class="n">RGM</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">doInitialization</span></code> method is designed to do simple initialization type of
stuff that does not depend on the functions being processed.  The
<code class="docutils literal notranslate"><span class="pre">doInitialization</span></code> method call is not scheduled to overlap with any other
pass executions (thus it should be very fast).  <code class="docutils literal notranslate"><span class="pre">RPPassManager</span></code> interface
should be used to access <code class="docutils literal notranslate"><span class="pre">Function</span></code> or <code class="docutils literal notranslate"><span class="pre">Module</span></code> level analysis information.</p>
</section>
<section id="the-runonregion-method">
<span id="writing-an-llvm-pass-runonregion"></span><h4><a class="toc-backref" href="#id21" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">runOnRegion</span></code> method</a><a class="headerlink" href="#the-runonregion-method" title="Link to this heading">¶</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">runOnRegion</span><span class="p">(</span><span class="n">Region</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">RGPassManager</span><span class="w"> </span><span class="o">&amp;</span><span class="n">RGM</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">runOnRegion</span></code> method must be implemented by your subclass to do the
transformation or analysis work of your pass.  As usual, a true value should be
returned if the region is modified.  <code class="docutils literal notranslate"><span class="pre">RGPassManager</span></code> interface should be used to
update region tree.</p>
</section>
<section id="id1">
<h4><a class="toc-backref" href="#id22" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">doFinalization()</span></code> method</a><a class="headerlink" href="#id1" title="Link to this heading">¶</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">doFinalization</span><span class="p">();</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">doFinalization</span></code> method is an infrequently used method that is called
when the pass framework has finished calling <a class="reference internal" href="#writing-an-llvm-pass-runonregion"><span class="std std-ref">runOnRegion</span></a> for every region in the program being
compiled.</p>
</section>
</section>
<section id="the-machinefunctionpass-class">
<h3><a class="toc-backref" href="#id23" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">MachineFunctionPass</span></code> class</a><a class="headerlink" href="#the-machinefunctionpass-class" title="Link to this heading">¶</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">MachineFunctionPass</span></code> is a part of the LLVM code generator that executes on
the machine-dependent representation of each LLVM function in the program.</p>
<p>Code generator passes are registered and initialized specially by
<code class="docutils literal notranslate"><span class="pre">TargetMachine::addPassesToEmitFile</span></code> and similar routines, so they cannot
generally be run from the <strong class="program">opt</strong> or <strong class="program">bugpoint</strong> commands.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">MachineFunctionPass</span></code> is also a <code class="docutils literal notranslate"><span class="pre">FunctionPass</span></code>, so all the restrictions
that apply to a <code class="docutils literal notranslate"><span class="pre">FunctionPass</span></code> also apply to it.  <code class="docutils literal notranslate"><span class="pre">MachineFunctionPass</span></code>es
also have additional restrictions.  In particular, <code class="docutils literal notranslate"><span class="pre">MachineFunctionPass</span></code>es
are not allowed to do any of the following:</p>
<ol class="arabic simple">
<li><p>Modify or create any LLVM IR <code class="docutils literal notranslate"><span class="pre">Instruction</span></code>s, <code class="docutils literal notranslate"><span class="pre">BasicBlock</span></code>s,
<code class="docutils literal notranslate"><span class="pre">Argument</span></code>s, <code class="docutils literal notranslate"><span class="pre">Function</span></code>s, <code class="docutils literal notranslate"><span class="pre">GlobalVariable</span></code>s,
<code class="docutils literal notranslate"><span class="pre">GlobalAlias</span></code>es, or <code class="docutils literal notranslate"><span class="pre">Module</span></code>s.</p></li>
<li><p>Modify a <code class="docutils literal notranslate"><span class="pre">MachineFunction</span></code> other than the one currently being processed.</p></li>
<li><p>Maintain state across invocations of <a class="reference internal" href="#writing-an-llvm-pass-runonmachinefunction"><span class="std std-ref">runOnMachineFunction</span></a> (including global data).</p></li>
</ol>
<section id="the-runonmachinefunction-machinefunction-mf-method">
<span id="writing-an-llvm-pass-runonmachinefunction"></span><h4><a class="toc-backref" href="#id24" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">runOnMachineFunction(MachineFunction</span> <span class="pre">&amp;MF)</span></code> method</a><a class="headerlink" href="#the-runonmachinefunction-machinefunction-mf-method" title="Link to this heading">¶</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">runOnMachineFunction</span><span class="p">(</span><span class="n">MachineFunction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">runOnMachineFunction</span></code> can be considered the main entry point of a
<code class="docutils literal notranslate"><span class="pre">MachineFunctionPass</span></code>; that is, you should override this method to do the
work of your <code class="docutils literal notranslate"><span class="pre">MachineFunctionPass</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">runOnMachineFunction</span></code> method is called on every <code class="docutils literal notranslate"><span class="pre">MachineFunction</span></code> in a
<code class="docutils literal notranslate"><span class="pre">Module</span></code>, so that the <code class="docutils literal notranslate"><span class="pre">MachineFunctionPass</span></code> may perform optimizations on
the machine-dependent representation of the function.  If you want to get at
the LLVM <code class="docutils literal notranslate"><span class="pre">Function</span></code> for the <code class="docutils literal notranslate"><span class="pre">MachineFunction</span></code> you’re working on, use
<code class="docutils literal notranslate"><span class="pre">MachineFunction</span></code>’s <code class="docutils literal notranslate"><span class="pre">getFunction()</span></code> accessor method — but remember, you
may not modify the LLVM <code class="docutils literal notranslate"><span class="pre">Function</span></code> or its contents from a
<code class="docutils literal notranslate"><span class="pre">MachineFunctionPass</span></code>.</p>
</section>
</section>
<section id="pass-registration">
<span id="writing-an-llvm-pass-registration"></span><h3><a class="toc-backref" href="#id25" role="doc-backlink">Pass registration</a><a class="headerlink" href="#pass-registration" title="Link to this heading">¶</a></h3>
<p>Passes are registered with the <code class="docutils literal notranslate"><span class="pre">RegisterPass</span></code> template.  The template
parameter is the name of the pass that is to be used on the command line to
specify that the pass should be added to a program. The first argument is the
name of the pass, which is to be used for the <a class="reference internal" href="CommandGuide/opt.html#cmdoption-opt-help"><code class="xref std std-option docutils literal notranslate"><span class="pre">-help</span></code></a> output of
programs, as well as for debug output generated by the <cite>–debug-pass</cite> option.</p>
<p>If you want your pass to be easily dumpable, you should implement the virtual
print method:</p>
<section id="the-print-method">
<h4><a class="toc-backref" href="#id26" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">print</span></code> method</a><a class="headerlink" href="#the-print-method" title="Link to this heading">¶</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">raw_ostream</span><span class="w"> </span><span class="o">&amp;</span><span class="n">O</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Module</span><span class="w"> </span><span class="o">*</span><span class="n">M</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">print</span></code> method must be implemented by “analyses” in order to print a
human readable version of the analysis results.  This is useful for debugging
an analysis itself, as well as for other people to figure out how an analysis
works.  Use the opt <code class="docutils literal notranslate"><span class="pre">-analyze</span></code> argument to invoke this method.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">llvm::raw_ostream</span></code> parameter specifies the stream to write the results
on, and the <code class="docutils literal notranslate"><span class="pre">Module</span></code> parameter gives a pointer to the top level module of the
program that has been analyzed.  Note however that this pointer may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
in certain circumstances (such as calling the <code class="docutils literal notranslate"><span class="pre">Pass::dump()</span></code> from a
debugger), so it should only be used to enhance debug output, it should not be
depended on.</p>
</section>
<section id="scheduling-a-machinefunctionpass">
<h4><a class="toc-backref" href="#id27" role="doc-backlink">Scheduling a MachineFunctionPass</a><a class="headerlink" href="#scheduling-a-machinefunctionpass" title="Link to this heading">¶</a></h4>
<p>Backends create a <code class="docutils literal notranslate"><span class="pre">TargetPassConfig</span></code> and use <code class="docutils literal notranslate"><span class="pre">addPass</span></code> to schedule
<code class="docutils literal notranslate"><span class="pre">MachineFunctionPass</span></code>es. External plugins can register a callback to modify
and insert additional passes:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RegisterTargetPassConfigCallback</span><span class="w"> </span><span class="n">X</span><span class="p">{[](</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">PM</span><span class="p">,</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">TPC</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">TPC</span><span class="o">-&gt;</span><span class="n">insertPass</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">);</span>
<span class="w">  </span><span class="n">TPC</span><span class="o">-&gt;</span><span class="n">substitutePass</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">);</span>
<span class="p">}};</span>
</pre></div>
</div>
<p>Note that passes still have to be registered:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__attribute__</span><span class="p">((</span><span class="n">constructor</span><span class="p">))</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">initCodeGenPlugin</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">initializeExamplePass</span><span class="p">(</span><span class="o">*</span><span class="n">PassRegistry</span><span class="o">::</span><span class="n">getPassRegistry</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="specifying-interactions-between-passes">
<span id="writing-an-llvm-pass-interaction"></span><h3><a class="toc-backref" href="#id28" role="doc-backlink">Specifying interactions between passes</a><a class="headerlink" href="#specifying-interactions-between-passes" title="Link to this heading">¶</a></h3>
<p>One of the main responsibilities of the <code class="docutils literal notranslate"><span class="pre">PassManager</span></code> is to make sure that
passes interact with each other correctly.  Because <code class="docutils literal notranslate"><span class="pre">PassManager</span></code> tries to
<a class="reference internal" href="#writing-an-llvm-pass-passmanager"><span class="std std-ref">optimize the execution of passes</span></a> it
must know how the passes interact with each other and what dependencies exist
between the various passes.  To track this, each pass can declare the set of
passes that are required to be executed before the current pass, and the passes
which are invalidated by the current pass.</p>
<p>Typically this functionality is used to require that analysis results are
computed before your pass is run.  Running arbitrary transformation passes can
invalidate the computed analysis results, which is what the invalidation set
specifies.  If a pass does not implement the <a class="reference internal" href="#writing-an-llvm-pass-getanalysisusage"><span class="std std-ref">getAnalysisUsage</span></a> method, it defaults to not having any
prerequisite passes, and invalidating <strong>all</strong> other passes.</p>
<section id="the-getanalysisusage-method">
<span id="writing-an-llvm-pass-getanalysisusage"></span><h4><a class="toc-backref" href="#id29" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">getAnalysisUsage</span></code> method</a><a class="headerlink" href="#the-getanalysisusage-method" title="Link to this heading">¶</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">getAnalysisUsage</span><span class="p">(</span><span class="n">AnalysisUsage</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Info</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>By implementing the <code class="docutils literal notranslate"><span class="pre">getAnalysisUsage</span></code> method, the required and invalidated
sets may be specified for your transformation.  The implementation should fill
in the <a class="reference external" href="https://llvm.org/doxygen/classllvm_1_1AnalysisUsage.html">AnalysisUsage</a> object with
information about which passes are required and not invalidated.  To do this, a
pass may call any of the following methods on the <code class="docutils literal notranslate"><span class="pre">AnalysisUsage</span></code> object:</p>
</section>
<section id="the-analysisusage-addrequired-and-analysisusage-addrequiredtransitive-methods">
<h4><a class="toc-backref" href="#id30" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">AnalysisUsage::addRequired&lt;&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">AnalysisUsage::addRequiredTransitive&lt;&gt;</span></code> methods</a><a class="headerlink" href="#the-analysisusage-addrequired-and-analysisusage-addrequiredtransitive-methods" title="Link to this heading">¶</a></h4>
<p>If your pass requires a previous pass to be executed (an analysis for example),
it can use one of these methods to arrange for it to be run before your pass.
LLVM has many different types of analyses and passes that can be required,
spanning the range from <code class="docutils literal notranslate"><span class="pre">DominatorSet</span></code> to <code class="docutils literal notranslate"><span class="pre">BreakCriticalEdges</span></code>.  Requiring
<code class="docutils literal notranslate"><span class="pre">BreakCriticalEdges</span></code>, for example, guarantees that there will be no critical
edges in the CFG when your pass has been run.</p>
<p>Some analyses chain to other analyses to do their job.  For example, an
<a class="reference external" href="AliasAnalysis.html">AliasAnalysis</a> implementation is required to <a class="reference internal" href="AliasAnalysis.html#aliasanalysis-chaining"><span class="std std-ref">chain</span></a> to other alias analysis passes.  In cases where
analyses chain, the <code class="docutils literal notranslate"><span class="pre">addRequiredTransitive</span></code> method should be used instead of
the <code class="docutils literal notranslate"><span class="pre">addRequired</span></code> method.  This informs the <code class="docutils literal notranslate"><span class="pre">PassManager</span></code> that the
transitively required pass should be alive as long as the requiring pass is.</p>
</section>
<section id="the-analysisusage-addpreserved-method">
<h4><a class="toc-backref" href="#id31" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">AnalysisUsage::addPreserved&lt;&gt;</span></code> method</a><a class="headerlink" href="#the-analysisusage-addpreserved-method" title="Link to this heading">¶</a></h4>
<p>One of the jobs of the <code class="docutils literal notranslate"><span class="pre">PassManager</span></code> is to optimize how and when analyses are
run.  In particular, it attempts to avoid recomputing data unless it needs to.
For this reason, passes are allowed to declare that they preserve (i.e., they
don’t invalidate) an existing analysis if it’s available.  For example, a
simple constant folding pass would not modify the CFG, so it can’t possibly
affect the results of dominator analysis.  By default, all passes are assumed
to invalidate all others.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">AnalysisUsage</span></code> class provides several methods which are useful in
certain circumstances that are related to <code class="docutils literal notranslate"><span class="pre">addPreserved</span></code>.  In particular, the
<code class="docutils literal notranslate"><span class="pre">setPreservesAll</span></code> method can be called to indicate that the pass does not
modify the LLVM program at all (which is true for analyses), and the
<code class="docutils literal notranslate"><span class="pre">setPreservesCFG</span></code> method can be used by transformations that change
instructions in the program but do not modify the CFG or terminator
instructions.</p>
<p><code class="docutils literal notranslate"><span class="pre">addPreserved</span></code> is particularly useful for transformations like
<code class="docutils literal notranslate"><span class="pre">BreakCriticalEdges</span></code>.  This pass knows how to update a small set of loop and
dominator related analyses if they exist, so it can preserve them, despite the
fact that it hacks on the CFG.</p>
</section>
<section id="example-implementations-of-getanalysisusage">
<h4><a class="toc-backref" href="#id32" role="doc-backlink">Example implementations of <code class="docutils literal notranslate"><span class="pre">getAnalysisUsage</span></code></a><a class="headerlink" href="#example-implementations-of-getanalysisusage" title="Link to this heading">¶</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// This example modifies the program, but does not modify the CFG</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">LICM::getAnalysisUsage</span><span class="p">(</span><span class="n">AnalysisUsage</span><span class="w"> </span><span class="o">&amp;</span><span class="n">AU</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">AU</span><span class="p">.</span><span class="n">setPreservesCFG</span><span class="p">();</span>
<span class="w">  </span><span class="n">AU</span><span class="p">.</span><span class="n">addRequired</span><span class="o">&lt;</span><span class="n">LoopInfoWrapperPass</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="the-getanalysis-and-getanalysisifavailable-methods">
<span id="writing-an-llvm-pass-getanalysis"></span><h4><a class="toc-backref" href="#id33" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">getAnalysis&lt;&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">getAnalysisIfAvailable&lt;&gt;</span></code> methods</a><a class="headerlink" href="#the-getanalysis-and-getanalysisifavailable-methods" title="Link to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">Pass::getAnalysis&lt;&gt;</span></code> method is automatically inherited by your class,
providing you with access to the passes that you declared that you required
with the <a class="reference internal" href="#writing-an-llvm-pass-getanalysisusage"><span class="std std-ref">getAnalysisUsage</span></a>
method.  It takes a single template argument that specifies which pass class
you want, and returns a reference to that pass.  For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">LICM::runOnFunction</span><span class="p">(</span><span class="n">Function</span><span class="w"> </span><span class="o">&amp;</span><span class="n">F</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">LoopInfo</span><span class="w"> </span><span class="o">&amp;</span><span class="n">LI</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getAnalysis</span><span class="o">&lt;</span><span class="n">LoopInfoWrapperPass</span><span class="o">&gt;</span><span class="p">().</span><span class="n">getLoopInfo</span><span class="p">();</span>
<span class="w">  </span><span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This method call returns a reference to the pass desired.  You may get a
runtime assertion failure if you attempt to get an analysis that you did not
declare as required in your <a class="reference internal" href="#writing-an-llvm-pass-getanalysisusage"><span class="std std-ref">getAnalysisUsage</span></a> implementation.  This method can be
called by your <code class="docutils literal notranslate"><span class="pre">run*</span></code> method implementation, or by any other local method
invoked by your <code class="docutils literal notranslate"><span class="pre">run*</span></code> method.</p>
<p>A module level pass can use function level analysis info using this interface.
For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">ModuleLevelPass::runOnModule</span><span class="p">(</span><span class="n">Module</span><span class="w"> </span><span class="o">&amp;</span><span class="n">M</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">//...</span>
<span class="w">  </span><span class="n">DominatorTree</span><span class="w"> </span><span class="o">&amp;</span><span class="n">DT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getAnalysis</span><span class="o">&lt;</span><span class="n">DominatorTree</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Func</span><span class="p">);</span>
<span class="w">  </span><span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In above example, <code class="docutils literal notranslate"><span class="pre">runOnFunction</span></code> for <code class="docutils literal notranslate"><span class="pre">DominatorTree</span></code> is called by pass
manager before returning a reference to the desired pass.</p>
<p>If your pass is capable of updating analyses if they exist (e.g.,
<code class="docutils literal notranslate"><span class="pre">BreakCriticalEdges</span></code>, as described above), you can use the
<code class="docutils literal notranslate"><span class="pre">getAnalysisIfAvailable</span></code> method, which returns a pointer to the analysis if
it is active.  For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">DominatorSet</span><span class="w"> </span><span class="o">*</span><span class="n">DS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getAnalysisIfAvailable</span><span class="o">&lt;</span><span class="n">DominatorSet</span><span class="o">&gt;</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// A DominatorSet is active.  This code will update it.</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="pass-statistics">
<h2><a class="toc-backref" href="#id34" role="doc-backlink">Pass Statistics</a><a class="headerlink" href="#pass-statistics" title="Link to this heading">¶</a></h2>
<p>The <a class="reference external" href="https://llvm.org/doxygen/Statistic_8h_source.html">Statistic</a> class is
designed to be an easy way to expose various success metrics from passes.
These statistics are printed at the end of a run, when the <a class="reference internal" href="CommandGuide/opt.html#cmdoption-opt-stats"><code class="xref std std-option docutils literal notranslate"><span class="pre">-stats</span></code></a>
command line option is enabled on the command line.  See the <a class="reference internal" href="ProgrammersManual.html#statistic"><span class="std std-ref">Statistics
section</span></a> in the Programmer’s Manual for details.</p>
<section id="what-passmanager-does">
<span id="writing-an-llvm-pass-passmanager"></span><h3><a class="toc-backref" href="#id35" role="doc-backlink">What PassManager does</a><a class="headerlink" href="#what-passmanager-does" title="Link to this heading">¶</a></h3>
<p>The <a class="reference external" href="https://llvm.org/doxygen/PassManager_8h_source.html">PassManager</a> <a class="reference external" href="https://llvm.org/doxygen/classllvm_1_1PassManager.html">class</a> takes a list of
passes, ensures their <a class="reference internal" href="#writing-an-llvm-pass-interaction"><span class="std std-ref">prerequisites</span></a>
are set up correctly, and then schedules passes to run efficiently.  All of the
LLVM tools that run passes use the PassManager for execution of these passes.</p>
<p>The PassManager does two main things to try to reduce the execution time of a
series of passes:</p>
<ol class="arabic">
<li><p><strong>Share analysis results.</strong>  The <code class="docutils literal notranslate"><span class="pre">PassManager</span></code> attempts to avoid
recomputing analysis results as much as possible.  This means keeping track
of which analyses are available already, which analyses get invalidated, and
which analyses are needed to be run for a pass.  An important part of work
is that the <code class="docutils literal notranslate"><span class="pre">PassManager</span></code> tracks the exact lifetime of all analysis
results, allowing it to <a class="reference internal" href="#writing-an-llvm-pass-releasememory"><span class="std std-ref">free memory</span></a> allocated to holding analysis results
as soon as they are no longer needed.</p></li>
<li><p><strong>Pipeline the execution of passes on the program.</strong>  The <code class="docutils literal notranslate"><span class="pre">PassManager</span></code>
attempts to get better cache and memory usage behavior out of a series of
passes by pipelining the passes together.  This means that, given a series
of consecutive <a class="reference internal" href="#writing-an-llvm-pass-functionpass"><span class="std std-ref">FunctionPass</span></a>, it
will execute all of the <a class="reference internal" href="#writing-an-llvm-pass-functionpass"><span class="std std-ref">FunctionPass</span></a> on the first function, then all of the
<a class="reference internal" href="#writing-an-llvm-pass-functionpass"><span class="std std-ref">FunctionPasses</span></a> on the second
function, etc… until the entire program has been run through the passes.</p>
<p>This improves the cache behavior of the compiler, because it is only
touching the LLVM program representation for a single function at a time,
instead of traversing the entire program.  It reduces the memory consumption
of compiler, because, for example, only one <a class="reference external" href="https://llvm.org/doxygen/classllvm_1_1DominatorSet.html">DominatorSet</a> needs to be
calculated at a time.</p>
</li>
</ol>
<p>The effectiveness of the <code class="docutils literal notranslate"><span class="pre">PassManager</span></code> is influenced directly by how much
information it has about the behaviors of the passes it is scheduling.  For
example, the “preserved” set is intentionally conservative in the face of an
unimplemented <a class="reference internal" href="#writing-an-llvm-pass-getanalysisusage"><span class="std std-ref">getAnalysisUsage</span></a>
method.  Not implementing when it should be implemented will have the effect of
not allowing any analysis results to live across the execution of your pass.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">PassManager</span></code> class exposes a <code class="docutils literal notranslate"><span class="pre">--debug-pass</span></code> command line options that
is useful for debugging pass execution, seeing how things work, and diagnosing
when you should be preserving more analyses than you currently are.  (To get
information about all of the variants of the <code class="docutils literal notranslate"><span class="pre">--debug-pass</span></code> option, just type
“<code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-help-hidden</span></code>”).</p>
<p>By using the –debug-pass=Structure option, for example, we can see inspect the
default optimization pipelines, e.g. (the output has been trimmed):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>llc<span class="w"> </span>-mtriple<span class="o">=</span>arm64--<span class="w"> </span>-O3<span class="w"> </span>-debug-pass<span class="o">=</span>Structure<span class="w"> </span>file.ll<span class="w"> </span>&gt;<span class="w"> </span>/dev/null
<span class="gp gp-VirtualEnv">(...)</span>
<span class="go">ModulePass Manager</span>
<span class="go">Pre-ISel Intrinsic Lowering</span>
<span class="go">FunctionPass Manager</span>
<span class="go">  Expand large div/rem</span>
<span class="go">  Expand fp</span>
<span class="go">  Expand Atomic instructions</span>
<span class="go">SVE intrinsics optimizations</span>
<span class="go">  FunctionPass Manager</span>
<span class="go">    Dominator Tree Construction</span>
<span class="go">FunctionPass Manager</span>
<span class="go">  Simplify the CFG</span>
<span class="go">  Dominator Tree Construction</span>
<span class="go">  Natural Loop Information</span>
<span class="go">  Canonicalize natural loops</span>
<span class="gp gp-VirtualEnv">(...)</span>
</pre></div>
</div>
<section id="the-releasememory-method">
<span id="writing-an-llvm-pass-releasememory"></span><h4><a class="toc-backref" href="#id36" role="doc-backlink">The <code class="docutils literal notranslate"><span class="pre">releaseMemory</span></code> method</a><a class="headerlink" href="#the-releasememory-method" title="Link to this heading">¶</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">releaseMemory</span><span class="p">();</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">PassManager</span></code> automatically determines when to compute analysis results,
and how long to keep them around for.  Because the lifetime of the pass object
itself is effectively the entire duration of the compilation process, we need
some way to free analysis results when they are no longer useful.  The
<code class="docutils literal notranslate"><span class="pre">releaseMemory</span></code> virtual method is the way to do this.</p>
<p>If you are writing an analysis or any other pass that retains a significant
amount of state (for use by another pass which “requires” your pass and uses
the <a class="reference internal" href="#writing-an-llvm-pass-getanalysis"><span class="std std-ref">getAnalysis</span></a> method) you should
implement <code class="docutils literal notranslate"><span class="pre">releaseMemory</span></code> to, well, release the memory allocated to maintain
this internal state.  This method is called after the <code class="docutils literal notranslate"><span class="pre">run*</span></code> method for the
class, before the next call of <code class="docutils literal notranslate"><span class="pre">run*</span></code> in your pass.</p>
</section>
</section>
</section>
<section id="registering-dynamically-loaded-passes">
<h2><a class="toc-backref" href="#id37" role="doc-backlink">Registering dynamically loaded passes</a><a class="headerlink" href="#registering-dynamically-loaded-passes" title="Link to this heading">¶</a></h2>
<p><em>Size matters</em> when constructing production quality tools using LLVM, both for
the purposes of distribution, and for regulating the resident code size when
running on the target system.  Therefore, it becomes desirable to selectively
use some passes, while omitting others and maintain the flexibility to change
configurations later on.  You want to be able to do all this, and, provide
feedback to the user.  This is where pass registration comes into play.</p>
<p>The fundamental mechanisms for pass registration are the
<code class="docutils literal notranslate"><span class="pre">MachinePassRegistry</span></code> class and subclasses of <code class="docutils literal notranslate"><span class="pre">MachinePassRegistryNode</span></code>.</p>
<p>An instance of <code class="docutils literal notranslate"><span class="pre">MachinePassRegistry</span></code> is used to maintain a list of
<code class="docutils literal notranslate"><span class="pre">MachinePassRegistryNode</span></code> objects.  This instance maintains the list and
communicates additions and deletions to the command line interface.</p>
<p>An instance of <code class="docutils literal notranslate"><span class="pre">MachinePassRegistryNode</span></code> subclass is used to maintain
information provided about a particular pass.  This information includes the
command line name, the command help string and the address of the function used
to create an instance of the pass.  A global static constructor of one of these
instances <em>registers</em> with a corresponding <code class="docutils literal notranslate"><span class="pre">MachinePassRegistry</span></code>, the static
destructor <em>unregisters</em>.  Thus a pass that is statically linked in the tool
will be registered at start up.  A dynamically loaded pass will register on
load and unregister at unload.</p>
<section id="using-existing-registries">
<h3><a class="toc-backref" href="#id38" role="doc-backlink">Using existing registries</a><a class="headerlink" href="#using-existing-registries" title="Link to this heading">¶</a></h3>
<p>There are predefined registries to track instruction scheduling
(<code class="docutils literal notranslate"><span class="pre">RegisterScheduler</span></code>) and register allocation (<code class="docutils literal notranslate"><span class="pre">RegisterRegAlloc</span></code>) machine
passes.  Here we will describe how to <em>register</em> a register allocator machine
pass.</p>
<p>Implement your register allocator machine pass.  In your register allocator
<code class="docutils literal notranslate"><span class="pre">.cpp</span></code> file add the following include:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;llvm/CodeGen/RegAllocRegistry.h&quot;</span>
</pre></div>
</div>
<p>Also in your register allocator <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> file, define a creator function in the
form:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">FunctionPass</span><span class="w"> </span><span class="o">*</span><span class="nf">createMyRegisterAllocator</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">MyRegisterAllocator</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that the signature of this function should match the type of
<code class="docutils literal notranslate"><span class="pre">RegisterRegAlloc::FunctionPassCtor</span></code>.  In the same file add the “installing”
declaration, in the form:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">RegisterRegAlloc</span><span class="w"> </span><span class="n">myRegAlloc</span><span class="p">(</span><span class="s">&quot;myregalloc&quot;</span><span class="p">,</span>
<span class="w">                                   </span><span class="s">&quot;my register allocator help string&quot;</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">createMyRegisterAllocator</span><span class="p">);</span>
</pre></div>
</div>
<p>Note the two spaces prior to the help string produces a tidy result on the
<a class="reference internal" href="CommandGuide/opt.html#cmdoption-opt-help"><code class="xref std std-option docutils literal notranslate"><span class="pre">-help</span></code></a> query.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>llc<span class="w"> </span>-help
<span class="go">  ...</span>
<span class="go">  -regalloc                    - Register allocator to use (default=linearscan)</span>
<span class="go">    =linearscan                -   linear scan register allocator</span>
<span class="go">    =local                     -   local register allocator</span>
<span class="go">    =simple                    -   simple register allocator</span>
<span class="go">    =myregalloc                -   my register allocator help string</span>
<span class="go">  ...</span>
</pre></div>
</div>
<p>And that’s it.  The user is now free to use <code class="docutils literal notranslate"><span class="pre">-regalloc=myregalloc</span></code> as an
option.  Registering instruction schedulers is similar except use the
<code class="docutils literal notranslate"><span class="pre">RegisterScheduler</span></code> class.  Note that the
<code class="docutils literal notranslate"><span class="pre">RegisterScheduler::FunctionPassCtor</span></code> is significantly different from
<code class="docutils literal notranslate"><span class="pre">RegisterRegAlloc::FunctionPassCtor</span></code>.</p>
<p>To force the load/linking of your register allocator into the
<strong class="program">llc</strong>/<strong class="program">lli</strong> tools, add your creator function’s global
declaration to <code class="docutils literal notranslate"><span class="pre">Passes.h</span></code> and add a “pseudo” call line to
<code class="docutils literal notranslate"><span class="pre">llvm/Codegen/LinkAllCodegenComponents.h</span></code>.</p>
</section>
<section id="creating-new-registries">
<h3><a class="toc-backref" href="#id39" role="doc-backlink">Creating new registries</a><a class="headerlink" href="#creating-new-registries" title="Link to this heading">¶</a></h3>
<p>The easiest way to get started is to clone one of the existing registries; we
recommend <code class="docutils literal notranslate"><span class="pre">llvm/CodeGen/RegAllocRegistry.h</span></code>.  The key things to modify are
the class name and the <code class="docutils literal notranslate"><span class="pre">FunctionPassCtor</span></code> type.</p>
<p>Then you need to declare the registry.  Example: if your pass registry is
<code class="docutils literal notranslate"><span class="pre">RegisterMyPasses</span></code> then define:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MachinePassRegistry</span><span class="o">&lt;</span><span class="n">RegisterMyPasses</span><span class="o">::</span><span class="n">FunctionPassCtor</span><span class="o">&gt;</span><span class="w"> </span><span class="n">RegisterMyPasses</span><span class="o">::</span><span class="n">Registry</span><span class="p">;</span>
</pre></div>
</div>
<p>And finally, declare the command line option for your passes.  Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">RegisterMyPasses</span><span class="o">::</span><span class="n">FunctionPassCtor</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="w">        </span><span class="n">RegisterPassParser</span><span class="o">&lt;</span><span class="n">RegisterMyPasses</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span>
<span class="n">MyPassOpt</span><span class="p">(</span><span class="s">&quot;mypass&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="n">cl</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">createDefaultMyPass</span><span class="p">),</span>
<span class="w">          </span><span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;my pass option help&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>Here the command option is “<code class="docutils literal notranslate"><span class="pre">mypass</span></code>”, with <code class="docutils literal notranslate"><span class="pre">createDefaultMyPass</span></code> as the
default creator.</p>
</section>
<section id="using-gdb-with-dynamically-loaded-passes">
<h3><a class="toc-backref" href="#id40" role="doc-backlink">Using GDB with dynamically loaded passes</a><a class="headerlink" href="#using-gdb-with-dynamically-loaded-passes" title="Link to this heading">¶</a></h3>
<p>Unfortunately, using GDB with dynamically loaded passes is not as easy as it
should be.  First of all, you can’t set a breakpoint in a shared object that
has not been loaded yet, and second of all there are problems with inlined
functions in shared objects.  Here are some suggestions to debugging your pass
with GDB.</p>
<p>For sake of discussion, I’m going to assume that you are debugging a
transformation invoked by <strong class="program">opt</strong>, although nothing described here
depends on that.</p>
<section id="setting-a-breakpoint-in-your-pass">
<h4><a class="toc-backref" href="#id41" role="doc-backlink">Setting a breakpoint in your pass</a><a class="headerlink" href="#setting-a-breakpoint-in-your-pass" title="Link to this heading">¶</a></h4>
<p>First thing you do is start gdb on the opt process:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>gdb<span class="w"> </span>opt
<span class="go">GNU gdb 5.0</span>
<span class="go">Copyright 2000 Free Software Foundation, Inc.</span>
<span class="go">GDB is free software, covered by the GNU General Public License, and you are</span>
<span class="go">welcome to change it and/or distribute copies of it under certain conditions.</span>
<span class="go">Type &quot;show copying&quot; to see the conditions.</span>
<span class="go">There is absolutely no warranty for GDB.  Type &quot;show warranty&quot; for details.</span>
<span class="go">This GDB was configured as &quot;sparc-sun-solaris2.6&quot;...</span>
<span class="gp gp-VirtualEnv">(gdb)</span>
</pre></div>
</div>
<p>Note that <strong class="program">opt</strong> has a lot of debugging information in it, so it takes
time to load.  Be patient.  Since we cannot set a breakpoint in our pass yet
(the shared object isn’t loaded until runtime), we must execute the process,
and have it stop before it invokes our pass, but after it has loaded the shared
object.  The most foolproof way of doing this is to set a breakpoint in
<code class="docutils literal notranslate"><span class="pre">PassManager::run</span></code> and then run the process with the arguments you want:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="o">(</span>gdb<span class="o">)</span><span class="w"> </span><span class="k">break</span><span class="w"> </span>llvm::PassManager::run
<span class="go">Breakpoint 1 at 0x2413bc: file Pass.cpp, line 70.</span>
<span class="gp gp-VirtualEnv">(gdb)</span> <span class="go">run test.bc -load $(LLVMTOP)/llvm/Debug+Asserts/lib/[libname].so -[passoption]</span>
<span class="go">Starting program: opt test.bc -load $(LLVMTOP)/llvm/Debug+Asserts/lib/[libname].so -[passoption]</span>
<span class="go">Breakpoint 1, PassManager::run (this=0xffbef174, M=@0x70b298) at Pass.cpp:70</span>
<span class="go">70      bool PassManager::run(Module &amp;M) { return PM-&gt;run(M); }</span>
<span class="gp gp-VirtualEnv">(gdb)</span>
</pre></div>
</div>
<p>Once the <strong class="program">opt</strong> stops in the <code class="docutils literal notranslate"><span class="pre">PassManager::run</span></code> method you are now
free to set breakpoints in your pass so that you can trace through execution or
do other standard debugging stuff.</p>
</section>
<section id="miscellaneous-problems">
<h4><a class="toc-backref" href="#id42" role="doc-backlink">Miscellaneous Problems</a><a class="headerlink" href="#miscellaneous-problems" title="Link to this heading">¶</a></h4>
<p>Once you have the basics down, there are a couple of problems that GDB has,
some with solutions, some without.</p>
<ul class="simple">
<li><p>Inline functions have bogus stack information.  In general, GDB does a pretty
good job getting stack traces and stepping through inline functions.  When a
pass is dynamically loaded however, it somehow completely loses this
capability.  The only solution I know of is to de-inline a function (move it
from the body of a class to a <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> file).</p></li>
<li><p>Restarting the program breaks breakpoints.  After following the information
above, you have succeeded in getting some breakpoints planted in your pass.
Next thing you know, you restart the program (i.e., you type “<code class="docutils literal notranslate"><span class="pre">run</span></code>” again),
and you start getting errors about breakpoints being unsettable.  The only
way I have found to “fix” this problem is to delete the breakpoints that are
already set in your pass, run the program, and re-set the breakpoints once
execution stops in <code class="docutils literal notranslate"><span class="pre">PassManager::run</span></code>.</p></li>
</ul>
<p>Hopefully these tips will help with common case debugging situations.  If you’d
like to contribute some tips of your own, just contact <a class="reference external" href="mailto:sabre&#37;&#52;&#48;nondot&#46;org">Chris</a>.</p>
</section>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="WritingAnLLVMNewPMPass.html" title="Writing an LLVM Pass"
             >next</a> |</li>
        <li class="right" >
          <a href="SandboxVectorizer.html" title="The Sandbox Vectorizer"
             >previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="UserGuides.html" >User Guides</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Writing an LLVM Pass (legacy PM version)</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2003-2025, LLVM Project.
      Last updated on 2025-08-26.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>