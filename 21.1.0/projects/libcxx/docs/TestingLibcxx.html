<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Testing libc++ &#8212; libc++  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=e491ac2d" />
    <script src="_static/documentation_options.js?v=5929fcd5"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Implementation-defined behavior" href="ImplementationDefinedBehavior.html" />
    <link rel="prev" title="libc++ Coding Guidelines" href="CodingGuidelines.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>libc++  documentation</span></a></h1>
        <h2 class="heading"><span>Testing libc++</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="CodingGuidelines.html">libc++ Coding Guidelines</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="ImplementationDefinedBehavior.html">Implementation-defined behavior</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="testing-libc">
<span id="testing"></span><h1>Testing libc++<a class="headerlink" href="#testing-libc" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#getting-started" id="id4">Getting Started</a></p>
<ul>
<li><p><a class="reference internal" href="#usage" id="id5">Usage</a></p></li>
<li><p><a class="reference internal" href="#using-a-custom-site-configuration" id="id6">Using a Custom Site Configuration</a></p></li>
<li><p><a class="reference internal" href="#additional-tools" id="id7">Additional tools</a></p></li>
<li><p><a class="reference internal" href="#reproducing-ci-issues-locally" id="id8">Reproducing CI issues locally</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#writing-tests" id="id9">Writing Tests</a></p>
<ul>
<li><p><a class="reference internal" href="#structure-of-the-testing-related-directories" id="id10">Structure of the testing related directories</a></p></li>
<li><p><a class="reference internal" href="#structure-of-a-test" id="id11">Structure of a test</a></p>
<ul>
<li><p><a class="reference internal" href="#libcxx-test-support-assert-macros-h" id="id12">libcxx/test/support/assert_macros.h</a></p>
<ul>
<li><p><a class="reference internal" href="#test-fail-arg" id="id13">TEST_FAIL(ARG)</a></p></li>
<li><p><a class="reference internal" href="#test-require-condition-arg" id="id14">TEST_REQUIRE(CONDITION, ARG)</a></p></li>
<li><p><a class="reference internal" href="#test-libcpp-require-condition-arg" id="id15">TEST_LIBCPP_REQUIRE((CONDITION, ARG)</a></p></li>
<li><p><a class="reference internal" href="#test-does-not-throw-expr" id="id16">TEST_DOES_NOT_THROW(EXPR)</a></p></li>
<li><p><a class="reference internal" href="#test-throws-type-type-expr" id="id17">TEST_THROWS_TYPE(TYPE, EXPR)</a></p></li>
<li><p><a class="reference internal" href="#test-validate-exception-type-pred-expr" id="id18">TEST_VALIDATE_EXCEPTION(TYPE, PRED, EXPR)</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#libcxx-test-support-concat-macros-h" id="id19">libcxx/test/support/concat_macros.h</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#test-names" id="id20">Test names</a></p></li>
<li><p><a class="reference internal" href="#libc-specific-lit-features" id="id21">libc++-Specific Lit Features</a></p>
<ul>
<li><p><a class="reference internal" href="#custom-directives" id="id22">Custom Directives</a></p></li>
<li><p><a class="reference internal" href="#c-standard-version-tests" id="id23">C++ Standard version tests</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#benchmarks" id="id24">Benchmarks</a></p></li>
<li><p><a class="reference internal" href="#testing-hardening-assertions" id="id25">Testing hardening assertions</a></p></li>
</ul>
</nav>
<section id="getting-started">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">Getting Started</a><a class="headerlink" href="#getting-started" title="Link to this heading">¶</a></h2>
<p>libc++ uses LIT to configure and run its tests.</p>
<p>The primary way to run the libc++ tests is by using <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">check-cxx</span></code>.</p>
<p>However since libc++ can be used in any number of possible
configurations it is important to customize the way LIT builds and runs
the tests. This guide provides information on how to use LIT directly to
test libc++.</p>
<p>Please see the <a class="reference external" href="https://llvm.org/docs/CommandGuide/lit.html">Lit Command Guide</a> for more information about LIT.</p>
<section id="usage">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">Usage</a><a class="headerlink" href="#usage" title="Link to this heading">¶</a></h3>
<p>After <a class="reference internal" href="VendorDocumentation.html#vendordocumentation"><span class="std std-ref">building libc++</span></a>, you can run parts of the libc++ test suite by simply
running <code class="docutils literal notranslate"><span class="pre">llvm-lit</span></code> on a specified test or directory. If you’re unsure
whether the required libraries have been built, you can use the
<code class="docutils literal notranslate"><span class="pre">cxx-test-depends</span></code> target. For example:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>&lt;monorepo-root&gt;
$<span class="w"> </span>make<span class="w"> </span>-C<span class="w"> </span>&lt;build&gt;<span class="w"> </span>cxx-test-depends<span class="w"> </span><span class="c1"># If you want to make sure the targets get rebuilt</span>
$<span class="w"> </span>&lt;build&gt;/bin/llvm-lit<span class="w"> </span>-sv<span class="w"> </span>libcxx/test/std/re<span class="w"> </span><span class="c1"># Run all of the std::regex tests</span>
$<span class="w"> </span>&lt;build&gt;/bin/llvm-lit<span class="w"> </span>-sv<span class="w"> </span>libcxx/test/std/depr/depr.c.headers/stdlib_h.pass.cpp<span class="w"> </span><span class="c1"># Run a single test</span>
$<span class="w"> </span>&lt;build&gt;/bin/llvm-lit<span class="w"> </span>-sv<span class="w"> </span>libcxx/test/std/atomics<span class="w"> </span>libcxx/test/std/threads<span class="w"> </span><span class="c1"># Test std::thread and std::atomic</span>
</pre></div>
</div>
<p>If you used <strong>ninja</strong> as your build system, running <code class="docutils literal notranslate"><span class="pre">ninja</span> <span class="pre">-C</span> <span class="pre">&lt;build&gt;</span> <span class="pre">check-cxx</span></code> will run
all the tests in the libc++ testsuite.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you used the Bootstrapping build instead of the default runtimes build, the
<code class="docutils literal notranslate"><span class="pre">cxx-test-depends</span></code> target is instead named <code class="docutils literal notranslate"><span class="pre">runtimes-test-depends</span></code>, and
you will need to prefix <code class="docutils literal notranslate"><span class="pre">&lt;build&gt;/runtimes/runtimes-&lt;target&gt;-bins/</span></code> to the
paths of all tests. For example, to run all the libcxx tests you can do
<code class="docutils literal notranslate"><span class="pre">&lt;build&gt;/bin/llvm-lit</span> <span class="pre">-sv</span> <span class="pre">&lt;build&gt;/runtimes/runtimes-bins/libcxx/test</span></code>.</p>
</div>
<p>In the default configuration, the tests are built against headers that form a
fake installation root of libc++. This installation root has to be updated when
changes are made to the headers, so you should re-run the <code class="docutils literal notranslate"><span class="pre">cxx-test-depends</span></code>
target before running the tests manually with <code class="docutils literal notranslate"><span class="pre">lit</span></code> when you make any sort of
change, including to the headers. We recommend using the provided <code class="docutils literal notranslate"><span class="pre">libcxx/utils/libcxx-lit</span></code>
script to automate this so you don’t have to think about building test dependencies
every time:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>&lt;monorepo-root&gt;
$<span class="w"> </span>libcxx/utils/libcxx-lit<span class="w"> </span>&lt;build&gt;<span class="w"> </span>-sv<span class="w"> </span>libcxx/test/std/re<span class="w"> </span><span class="c1"># Build testing dependencies and run all of the std::regex tests</span>
</pre></div>
</div>
<p>Sometimes you’ll want to change the way LIT is running the tests. Custom options
can be specified using the <code class="docutils literal notranslate"><span class="pre">--param</span> <span class="pre">&lt;name&gt;=&lt;val&gt;</span></code> flag. The most common option
you’ll want to change is the standard dialect (ie <code class="docutils literal notranslate"><span class="pre">-std=c++XX</span></code>). By default the
test suite will select the newest C++ dialect supported by the compiler and use
that. However, you can manually specify the option like so if you want:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>libcxx/utils/libcxx-lit<span class="w"> </span>&lt;build&gt;<span class="w"> </span>-sv<span class="w"> </span>libcxx/test/std/containers<span class="w"> </span><span class="c1"># Run the tests with the newest -std</span>
$<span class="w"> </span>libcxx/utils/libcxx-lit<span class="w"> </span>&lt;build&gt;<span class="w"> </span>-sv<span class="w"> </span>libcxx/test/std/containers<span class="w"> </span>--param<span class="w"> </span><span class="nv">std</span><span class="o">=</span>c++03<span class="w"> </span><span class="c1"># Run the tests in C++03</span>
</pre></div>
</div>
<p>Other parameters are supported by the test suite. Those are defined in <code class="docutils literal notranslate"><span class="pre">libcxx/utils/libcxx/test/params.py</span></code>.
If you want to customize how to run the libc++ test suite beyond what is available
in <code class="docutils literal notranslate"><span class="pre">params.py</span></code>, you most likely want to use a custom site configuration instead.</p>
<p>The libc++ test suite works by loading a site configuration that defines various
“base” parameters (via Lit substitutions). These base parameters represent things
like the compiler to use for running the tests, which default compiler and linker
flags to use, and how to run an executable. This system is meant to be easily
extended for custom needs, in particular when porting the libc++ test suite to
new platforms.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you run the test suite on Apple platforms, we recommend adding the terminal application
used to run the test suite to the list of “Developer Tools”. This prevents the system from
trying to scan each individual test binary for malware and dramatically speeds up the test
suite.</p>
</div>
</section>
<section id="using-a-custom-site-configuration">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">Using a Custom Site Configuration</a><a class="headerlink" href="#using-a-custom-site-configuration" title="Link to this heading">¶</a></h3>
<p>By default, the libc++ test suite will use a site configuration that matches
the current CMake configuration. It does so by generating a <code class="docutils literal notranslate"><span class="pre">lit.site.cfg</span></code>
file in the build directory from one of the configuration file templates in
<code class="docutils literal notranslate"><span class="pre">libcxx/test/configs/</span></code>, and pointing <code class="docutils literal notranslate"><span class="pre">llvm-lit</span></code> (which is a wrapper around
<code class="docutils literal notranslate"><span class="pre">llvm/utils/lit/lit.py</span></code>) to that file. So when you’re running
<code class="docutils literal notranslate"><span class="pre">&lt;build&gt;/bin/llvm-lit</span></code> either directly or indirectly, the generated <code class="docutils literal notranslate"><span class="pre">lit.site.cfg</span></code>
file is always loaded instead of <code class="docutils literal notranslate"><span class="pre">libcxx/test/lit.cfg.py</span></code>. If you want to use a
custom site configuration, simply point the CMake build to it using
<code class="docutils literal notranslate"><span class="pre">-DLIBCXX_TEST_CONFIG=&lt;path-to-site-config&gt;</span></code>, and that site configuration
will be used instead. That file can use CMake variables inside it to make
configuration easier.</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>cmake<span class="w"> </span>&lt;options&gt;<span class="w"> </span>-DLIBCXX_TEST_CONFIG<span class="o">=</span>&lt;path-to-site-config&gt;
$<span class="w"> </span>libcxx/utils/libcxx-lit<span class="w"> </span>&lt;build&gt;<span class="w"> </span>-sv<span class="w"> </span>libcxx/test<span class="w"> </span><span class="c1"># will use your custom config file</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="additional-tools">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Additional tools</a><a class="headerlink" href="#additional-tools" title="Link to this heading">¶</a></h3>
<p>The libc++ test suite uses a few optional tools to improve the code quality.</p>
<p>These tools are:</p>
<ul class="simple">
<li><p>clang-tidy (you might need additional dev packages to compile libc++-specific clang-tidy checks)</p></li>
</ul>
</section>
<section id="reproducing-ci-issues-locally">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Reproducing CI issues locally</a><a class="headerlink" href="#reproducing-ci-issues-locally" title="Link to this heading">¶</a></h3>
<p>Libc++ has extensive CI that tests various configurations of the library. The testing for
all these configurations is located in <code class="docutils literal notranslate"><span class="pre">libcxx/utils/ci/run-buildbot</span></code>. Most of our
CI jobs are being run on a Docker image for reproducibility. The definition of this Docker
image is located in <code class="docutils literal notranslate"><span class="pre">libcxx/utils/ci/Dockerfile</span></code>. If you are looking to reproduce the
failure of a specific CI job locally, you should first drop into a Docker container that
matches our CI images by running <code class="docutils literal notranslate"><span class="pre">libcxx/utils/ci/run-buildbot-container</span></code>, and then run
the specific CI job that you’re interested in (from within the container) using the <code class="docutils literal notranslate"><span class="pre">run-buildbot</span></code>
script above. If you want to control which compiler is used, you can set the <code class="docutils literal notranslate"><span class="pre">CC</span></code> and the
<code class="docutils literal notranslate"><span class="pre">CXX</span></code> environment variables before calling <code class="docutils literal notranslate"><span class="pre">run-buildbot</span></code> to select the right compiler.
Take note that some CI jobs are testing the library on specific platforms and are <em>not</em> run
in our Docker image. In the general case, it is not possible to reproduce these failures
locally, unless they aren’t specific to the platform.</p>
<p>Also note that the Docker container shares the same filesystem as your local machine, so
modifying files on your local machine will also modify what the Docker container sees.
This is useful for editing source files as you’re testing your code in the Docker container.</p>
</section>
</section>
<section id="writing-tests">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">Writing Tests</a><a class="headerlink" href="#writing-tests" title="Link to this heading">¶</a></h2>
<p>When writing tests for the libc++ test suite, you should follow a few guidelines.
This will ensure that your tests can run on a wide variety of hardware and under
a wide variety of configurations. We have several unusual configurations such as
building the tests on one host but running them on a different host, which add a
few requirements to the test suite. Here’s some stuff you should know:</p>
<ul class="simple">
<li><p>All tests are run in a temporary directory that is unique to that test and
cleaned up after the test is done.</p></li>
<li><p>When a test needs data files as inputs, these data files can be saved in the
repository (when reasonable) and referenced by the test as
<code class="docutils literal notranslate"><span class="pre">//</span> <span class="pre">FILE_DEPENDENCIES:</span> <span class="pre">&lt;path-to-dependencies&gt;</span></code>. Copies of these files or
directories will be made available to the test in the temporary directory
where it is run.</p></li>
<li><p>You should never hardcode a path from the build-host in a test, because that
path will not necessarily be available on the host where the tests are run.</p></li>
<li><p>You should try to reduce the runtime dependencies of each test to the minimum.
For example, requiring Python to run a test is bad, since Python is not
necessarily available on all devices we may want to run the tests on (even
though supporting Python is probably trivial for the build-host).</p></li>
</ul>
<section id="structure-of-the-testing-related-directories">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Structure of the testing related directories</a><a class="headerlink" href="#structure-of-the-testing-related-directories" title="Link to this heading">¶</a></h3>
<p>The tests of libc++ are stored in libc++’s testing related subdirectories:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">libcxx/test/support</span></code> This directory contains several helper headers with
generic parts for the tests. The most important header is <code class="docutils literal notranslate"><span class="pre">test_macros.h</span></code>.
This file contains configuration information regarding the platform used.
This is similar to the <code class="docutils literal notranslate"><span class="pre">__config</span></code> file in libc++’s <code class="docutils literal notranslate"><span class="pre">include</span></code> directory.
Since libc++’s tests are used by other Standard libraries, tests should use
the <code class="docutils literal notranslate"><span class="pre">TEST_FOO</span></code> macros instead of the <code class="docutils literal notranslate"><span class="pre">_LIBCPP_FOO</span></code> macros, which are
specific to libc++.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">libcxx/test/std</span></code> This directory contains the tests that validate the library under
test conforms to the C++ Standard. The paths and the names of the test match
the section names in the C++ Standard. Note that the C++ Standard sometimes
reorganises its structure, therefore some tests are at a location based on
where they appeared historically in the standard. We try to strike a balance
between keeping things at up-to-date locations and unnecessary churn.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">libcxx/test/libcxx</span></code> This directory contains the tests that validate libc++
specific behavior and implementation details. For example, libc++ has
“wrapped iterators” that perform bounds checks. Since those are specific to
libc++ and not mandated by the Standard, tests for those are located under
<code class="docutils literal notranslate"><span class="pre">libcxx/test/libcxx</span></code>. The structure of this directories follows the
structure of <code class="docutils literal notranslate"><span class="pre">libcxx/test/std</span></code>.</p></li>
</ul>
</section>
<section id="structure-of-a-test">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Structure of a test</a><a class="headerlink" href="#structure-of-a-test" title="Link to this heading">¶</a></h3>
<p>Some platforms where libc++ is tested have requirement on the signature of
<code class="docutils literal notranslate"><span class="pre">main</span></code> and require <code class="docutils literal notranslate"><span class="pre">main</span></code> to explicitly return a value. Therefore the
typical <code class="docutils literal notranslate"><span class="pre">main</span></code> function should look like:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The C++ Standard has <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> requirements. The typical way to test that,
is to create a helper <code class="docutils literal notranslate"><span class="pre">test</span></code> function that returns a <code class="docutils literal notranslate"><span class="pre">bool</span></code> and use the
following <code class="docutils literal notranslate"><span class="pre">main</span></code> function:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">test</span><span class="p">()</span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="n">test</span><span class="p">());</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Tests in libc++ mainly use <code class="docutils literal notranslate"><span class="pre">assert</span></code> and <code class="docutils literal notranslate"><span class="pre">static_assert</span></code> for testing. There
are a few helper macros and function that can be used to make it easier to
write common tests.</p>
<section id="libcxx-test-support-assert-macros-h">
<h4><a class="toc-backref" href="#id12" role="doc-backlink">libcxx/test/support/assert_macros.h</a><a class="headerlink" href="#libcxx-test-support-assert-macros-h" title="Link to this heading">¶</a></h4>
<p>The header contains several macros with user specified log messages. This is
useful when a normal assertion failure lacks the information to easily
understand why the test has failed. This usually happens when the test is in a
helper function. For example the <code class="docutils literal notranslate"><span class="pre">std::format</span></code> tests use a helper function
for its validation. When the test fails it will give the line in the helper
function with the condition <code class="docutils literal notranslate"><span class="pre">out</span> <span class="pre">==</span> <span class="pre">expected</span></code> failed. Without knowing what
the value of <code class="docutils literal notranslate"><span class="pre">format</span> <span class="pre">string</span></code>, <code class="docutils literal notranslate"><span class="pre">out</span></code> and <code class="docutils literal notranslate"><span class="pre">expected</span></code> are it is not easy to
understand why the test has failed. By logging these three values the point of
failure can be found without resorting to a debugger.</p>
<p>Several of these macros are documented to take an <code class="docutils literal notranslate"><span class="pre">ARG</span></code>. This <code class="docutils literal notranslate"><span class="pre">ARG</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>if it is a <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char*</span></code> or <code class="docutils literal notranslate"><span class="pre">std::string</span></code> its contents are written to
the <code class="docutils literal notranslate"><span class="pre">stderr</span></code>,</p></li>
<li><p>otherwise it must be a callable that is invoked without any additional
arguments and is expected to produce useful output to e.g. <code class="docutils literal notranslate"><span class="pre">stderr</span></code>.</p></li>
</ul>
</div></blockquote>
<p>This makes it possible to write additional information when a test fails,
either by supplying a hard-coded string or generate it at runtime.</p>
<section id="test-fail-arg">
<h5><a class="toc-backref" href="#id13" role="doc-backlink">TEST_FAIL(ARG)</a><a class="headerlink" href="#test-fail-arg" title="Link to this heading">¶</a></h5>
<p>This macro is an unconditional failure with a log message <code class="docutils literal notranslate"><span class="pre">ARG</span></code>. The main
use-case is to fail when code is reached that should be unreachable.</p>
</section>
<section id="test-require-condition-arg">
<h5><a class="toc-backref" href="#id14" role="doc-backlink">TEST_REQUIRE(CONDITION, ARG)</a><a class="headerlink" href="#test-require-condition-arg" title="Link to this heading">¶</a></h5>
<p>This macro requires its <code class="docutils literal notranslate"><span class="pre">CONDITION</span></code> to evaluate to <code class="docutils literal notranslate"><span class="pre">true</span></code>. If that fails it
will fail the test with a log message <code class="docutils literal notranslate"><span class="pre">ARG</span></code>.</p>
</section>
<section id="test-libcpp-require-condition-arg">
<h5><a class="toc-backref" href="#id15" role="doc-backlink">TEST_LIBCPP_REQUIRE((CONDITION, ARG)</a><a class="headerlink" href="#test-libcpp-require-condition-arg" title="Link to this heading">¶</a></h5>
<p>If the library under test is libc++ it behaves like <code class="docutils literal notranslate"><span class="pre">TEST_REQUIRE</span></code>, else it
is a no-op. This makes it possible to test libc++ specific behaviour. For
example testing whether the <code class="docutils literal notranslate"><span class="pre">what()</span></code> of an exception thrown matches libc++’s
expectations. (Usually the Standard requires certain exceptions to be thrown,
but not the contents of its <code class="docutils literal notranslate"><span class="pre">what()</span></code> message.)</p>
</section>
<section id="test-does-not-throw-expr">
<h5><a class="toc-backref" href="#id16" role="doc-backlink">TEST_DOES_NOT_THROW(EXPR)</a><a class="headerlink" href="#test-does-not-throw-expr" title="Link to this heading">¶</a></h5>
<p>Validates execution of <code class="docutils literal notranslate"><span class="pre">EXPR</span></code> does not throw an exception.</p>
</section>
<section id="test-throws-type-type-expr">
<h5><a class="toc-backref" href="#id17" role="doc-backlink">TEST_THROWS_TYPE(TYPE, EXPR)</a><a class="headerlink" href="#test-throws-type-type-expr" title="Link to this heading">¶</a></h5>
<p>Validates the execution of <code class="docutils literal notranslate"><span class="pre">EXPR</span></code> throws an exception of the type <code class="docutils literal notranslate"><span class="pre">TYPE</span></code>.</p>
</section>
<section id="test-validate-exception-type-pred-expr">
<h5><a class="toc-backref" href="#id18" role="doc-backlink">TEST_VALIDATE_EXCEPTION(TYPE, PRED, EXPR)</a><a class="headerlink" href="#test-validate-exception-type-pred-expr" title="Link to this heading">¶</a></h5>
<p>Validates the execution of <code class="docutils literal notranslate"><span class="pre">EXPR</span></code> throws an exception of the type <code class="docutils literal notranslate"><span class="pre">TYPE</span></code>
which passes validation of <code class="docutils literal notranslate"><span class="pre">PRED</span></code>. Using this macro makes it easier to write
tests using exceptions. The code to write a test manually would be:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">test_exception</span><span class="p">([[</span><span class="n">maybe_unused</span><span class="p">]]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#ifndef TEST_HAS_NO_EXCEPTIONS </span><span class="c1">// do nothing when tests are disabled</span>
<span class="w">  </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span><span class="w"> </span><span class="c1">// validates foo really throws</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">([[</span><span class="n">maybe_unused</span><span class="p">]]</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">bar</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">LIBCPP_ASSERT</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">what</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span><span class="w"> </span><span class="c1">// validates bar was thrown</span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>The same test using a macro:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">test_exception</span><span class="p">([[</span><span class="n">maybe_unused</span><span class="p">]]</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">TEST_VALIDATE_EXCEPTION</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span>
<span class="w">                          </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">bar</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                            </span><span class="n">LIBCPP_ASSERT</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">what</span><span class="p">);</span>
<span class="w">                          </span><span class="p">},</span>
<span class="w">                          </span><span class="n">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="libcxx-test-support-concat-macros-h">
<h4><a class="toc-backref" href="#id19" role="doc-backlink">libcxx/test/support/concat_macros.h</a><a class="headerlink" href="#libcxx-test-support-concat-macros-h" title="Link to this heading">¶</a></h4>
<p>This file contains a helper macro <code class="docutils literal notranslate"><span class="pre">TEST_WRITE_CONCATENATED</span></code> to lazily
concatenate its arguments to a <code class="docutils literal notranslate"><span class="pre">std::string</span></code> and write it to <code class="docutils literal notranslate"><span class="pre">stderr</span></code>. When
the output can’t be concatenated a default message will be written to
<code class="docutils literal notranslate"><span class="pre">stderr</span></code>. This is useful for tests where the arguments use different
character types like <code class="docutils literal notranslate"><span class="pre">char</span></code> and <code class="docutils literal notranslate"><span class="pre">wchar_t</span></code>, the latter can’t simply be
written to <code class="docutils literal notranslate"><span class="pre">stderr</span></code>.</p>
<p>This macro is in a different header as <code class="docutils literal notranslate"><span class="pre">assert_macros.h</span></code> since it pulls in
additional headers.</p>
<blockquote>
<div></div></blockquote>
</section>
</section>
<section id="test-names">
<h3><a class="toc-backref" href="#id20" role="doc-backlink">Test names</a><a class="headerlink" href="#test-names" title="Link to this heading">¶</a></h3>
<p>The names of test files have meaning for the libc++-specific configuration of
Lit. Based on the pattern that matches the name of a test file, Lit will test
the code contained therein in different ways. Refer to the <a class="reference internal" href="#lit-meaning-of-libc-test-filenames">Lit Meaning of libc++
Test Filenames</a> when determining the names for new test files.</p>
<span id="lit-meaning-of-libc-test-filenames"></span><table class="docutils align-default" id="id2">
<caption><span class="caption-text">Lit Meaning of libc++ Test Filenames</span><a class="headerlink" href="#id2" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name Pattern</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">FOO.pass.cpp</span></code></p></td>
<td><p>Checks whether the C++ code in the file compiles, links and runs successfully.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">FOO.pass.mm</span></code></p></td>
<td><p>Same as <code class="docutils literal notranslate"><span class="pre">FOO.pass.cpp</span></code>, but for Objective-C++.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">FOO.compile.pass.cpp</span></code></p></td>
<td><p>Checks whether the C++ code in the file compiles successfully. In general, prefer <code class="docutils literal notranslate"><span class="pre">compile</span></code> tests over <code class="docutils literal notranslate"><span class="pre">verify</span></code> tests,
subject to the specific recommendations, below, for when to write <code class="docutils literal notranslate"><span class="pre">verify</span></code> tests.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">FOO.compile.pass.mm</span></code></p></td>
<td><p>Same as <code class="docutils literal notranslate"><span class="pre">FOO.compile.pass.cpp</span></code>, but for Objective-C++.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">FOO.compile.fail.cpp</span></code></p></td>
<td><p>Checks that the code in the file does <em>not</em> compile successfully.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">FOO.verify.cpp</span></code></p></td>
<td><p>Compiles with clang-verify. This type of test is automatically marked as UNSUPPORTED if the compiler does not support clang-verify.
For additional information about how to write <code class="docutils literal notranslate"><span class="pre">verify</span></code> tests, see the <a class="reference external" href="https://clang.llvm.org/docs/InternalsManual.html#verifying-diagnostics">Internals Manual</a>.
Prefer <cite>verify</cite> tests over <code class="docutils literal notranslate"><span class="pre">compile</span></code> tests to test that compilation fails for a particular reason. For example, use a <code class="docutils literal notranslate"><span class="pre">verify</span></code> test
to ensure that</p>
<ul class="simple">
<li><p>an expected <code class="docutils literal notranslate"><span class="pre">static_assert</span></code> is triggered;</p></li>
<li><p>the use of deprecated functions generates the proper warning;</p></li>
<li><p>removed functions are no longer usable; or</p></li>
<li><p>return values from functions marked <code class="docutils literal notranslate"><span class="pre">[[nodiscard]]</span></code> are stored.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">FOO.link.pass.cpp</span></code></p></td>
<td><p>Checks that the C++ code in the file compiles and links successfully – no run attempted.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">FOO.link.pass.mm</span></code></p></td>
<td><p>Same as <code class="docutils literal notranslate"><span class="pre">FOO.link.pass.cpp</span></code>, but for Objective-C++.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">FOO.link.fail.cpp</span></code></p></td>
<td><p>Checks whether the C++ code in the file fails to link after successful compilation.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">FOO.link.fail.mm</span></code></p></td>
<td><p>Same as <code class="docutils literal notranslate"><span class="pre">FOO.link.fail.cpp</span></code>, but for Objective-C++.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">FOO.sh.&lt;anything&gt;</span></code></p></td>
<td><p>A <em>builtin Lit Shell</em> test.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">FOO.gen.&lt;anything&gt;</span></code></p></td>
<td><p>A variant of a <em>Lit Shell</em> test that generates one or more Lit tests on the fly. Executing this test must generate one or more files as expected
by LLVM split-file. Each generated file will drive an invocation of a separate Lit test. The format of the generated file will determine the type
of Lit test to be executed. This can be used to generate multiple Lit tests from a single source file, which is useful for testing repetitive properties
in the library. Be careful not to abuse this since this is not a replacement for usual code reuse techniques.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">FOO.bench.cpp</span></code></p></td>
<td><p>A benchmark test. These tests are linked against the GoogleBenchmark library and generally consist of micro-benchmarks of individual
components of the library.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="libc-specific-lit-features">
<h3><a class="toc-backref" href="#id21" role="doc-backlink">libc++-Specific Lit Features</a><a class="headerlink" href="#libc-specific-lit-features" title="Link to this heading">¶</a></h3>
<section id="custom-directives">
<h4><a class="toc-backref" href="#id22" role="doc-backlink">Custom Directives</a><a class="headerlink" href="#custom-directives" title="Link to this heading">¶</a></h4>
<p>Lit has many directives built in (e.g., <code class="docutils literal notranslate"><span class="pre">DEFINE</span></code>, <code class="docutils literal notranslate"><span class="pre">UNSUPPORTED</span></code>). In addition to those directives, libc++ adds two additional libc++-specific directives that makes
writing tests easier. See <a class="reference internal" href="#libc-specific-lit-directives">libc++-specific Lit Directives</a> for more information about the <code class="docutils literal notranslate"><span class="pre">FILE_DEPENDENCIES</span></code>, <code class="docutils literal notranslate"><span class="pre">ADDITIONAL_COMPILE_FLAGS</span></code>, and <code class="docutils literal notranslate"><span class="pre">MODULE_DEPENDENCIES</span></code> libc++-specific directives.</p>
<span id="libc-specific-lit-directives"></span><table class="docutils align-default" id="id3">
<caption><span class="caption-text">libc++-specific Lit Directives</span><a class="headerlink" href="#id3" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 20.0%" />
<col style="width: 35.0%" />
<col style="width: 45.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Directive</p></th>
<th class="head"><p>Parameters</p></th>
<th class="head"><p>Usage</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">FILE_DEPENDENCIES</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">//</span> <span class="pre">FILE_DEPENDENCIES:</span> <span class="pre">file,</span> <span class="pre">directory,</span> <span class="pre">/path/to/file,</span> <span class="pre">...</span></code></p></td>
<td><p>The paths given to the <code class="docutils literal notranslate"><span class="pre">FILE_DEPENDENCIES</span></code> directive can specify directories or specific files upon which a given test depend. For example, a test that requires some test
input stored in a data file would use this libc++-specific Lit directive. When a test file contains the <code class="docutils literal notranslate"><span class="pre">FILE_DEPENDENCIES</span></code> directive, Lit will collect the named files and copy
them to the directory represented by the <code class="docutils literal notranslate"><span class="pre">%T</span></code> substitution before the test executes. The copy is performed from the directory represented by the <code class="docutils literal notranslate"><span class="pre">%S</span></code> substitution
(i.e. the source directory of the test being executed) which makes it possible to use relative paths to specify the location of dependency files. After Lit copies
all the dependent files to the directory specified by the <code class="docutils literal notranslate"><span class="pre">%T</span></code> substitution, that directory should contain <em>all</em> the necessary inputs to run. In other words,
it should be possible to copy the contents of the directory specified by the <code class="docutils literal notranslate"><span class="pre">%T</span></code> substitution to a remote host where the execution of the test will actually occur.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ADDITIONAL_COMPILE_FLAGS</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">//</span> <span class="pre">ADDITIONAL_COMPILE_FLAGS:</span> <span class="pre">flag1</span> <span class="pre">flag2</span> <span class="pre">...</span></code></p></td>
<td><p>The additional compiler flags specified by a space-separated list to the <code class="docutils literal notranslate"><span class="pre">ADDITIONAL_COMPILE_FLAGS</span></code> libc++-specific Lit directive will be added to the end of the <code class="docutils literal notranslate"><span class="pre">%{compile_flags}</span></code>
substitution for the test that contains it. This libc++-specific Lit directive makes it possible to add special compilation flags without having to resort to writing a <code class="docutils literal notranslate"><span class="pre">.sh.cpp</span></code> test (see
<a class="reference internal" href="#lit-meaning-of-libc-test-filenames">Lit Meaning of libc++ Test Filenames</a>), more powerful but perhaps overkill.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">MODULE_DEPENDENCIES</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">//</span> <span class="pre">MODULE_DEPENDENCIES:</span> <span class="pre">std</span> <span class="pre">std.compat</span></code></p></td>
<td><p>This directive will build the required C++23 standard library
modules and add the additional compiler flags in
%{compile_flags}. (Libc++ offers these modules in C++20 as an
extension.)</p></td>
</tr>
</tbody>
</table>
</section>
<section id="c-standard-version-tests">
<h4><a class="toc-backref" href="#id23" role="doc-backlink">C++ Standard version tests</a><a class="headerlink" href="#c-standard-version-tests" title="Link to this heading">¶</a></h4>
<p>Historically libc++ tests used to filter the tests for C++ Standard versions
with lit directives like:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// UNSUPPORTED: c++03, c++11, c++14, c++17, c++20, c++23</span>
</pre></div>
</div>
<p>With C++ Standards released every 3 years, this solution is not scalable.
Instead use:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// UNSUPPORTED: std-at-least-c++26</span>
</pre></div>
</div>
<p>There is no corresponding <code class="docutils literal notranslate"><span class="pre">std-at-most-c++23</span></code>. This could be useful when
tests are only valid for a small set of standard versions. For example, a
deprecation test is only valid when the feature is deprecated until it is
removed from the Standard. These tests should be written like:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// REQUIRES: c++17 || c++20 || c++23</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There are a lot of tests with the first style, these can remain as they are.
The new style is only intended to be used for new tests.</p>
</div>
</section>
</section>
</section>
<section id="benchmarks">
<h2><a class="toc-backref" href="#id24" role="doc-backlink">Benchmarks</a><a class="headerlink" href="#benchmarks" title="Link to this heading">¶</a></h2>
<p>Libc++’s test suite also contains benchmarks. The benchmarks are written using the <a class="reference external" href="https://github.com/google/benchmark">Google Benchmark</a>
library, a copy of which is stored in the LLVM monorepo. For more information about using the Google
Benchmark library, see the <a class="reference external" href="https://github.com/google/benchmark">official documentation</a>.</p>
<p>The benchmarks are located under <code class="docutils literal notranslate"><span class="pre">libcxx/test/benchmarks</span></code>. Running a benchmark
works in the same way as running a test. Both the benchmarks and the tests share
the same configuration, so make sure to enable the relevant optimization level
when running the benchmarks. For example,</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>libcxx/utils/libcxx-lit<span class="w"> </span>&lt;build&gt;<span class="w"> </span>libcxx/test/benchmarks/string.bench.cpp<span class="w"> </span>--show-all<span class="w"> </span>--param<span class="w"> </span><span class="nv">optimization</span><span class="o">=</span>speed
</pre></div>
</div>
<p>Note that benchmarks are only dry-run when run via the <code class="docutils literal notranslate"><span class="pre">check-cxx</span></code> target since
we only want to make sure they don’t rot. Do not rely on the results of benchmarks
run through <code class="docutils literal notranslate"><span class="pre">check-cxx</span></code> for anything, instead run the benchmarks manually using
the instructions for running individual tests.</p>
<p>If you want to compare the results of different benchmark runs, we recommend using the
<code class="docutils literal notranslate"><span class="pre">libcxx-compare-benchmarks</span></code> helper tool. First, configure CMake in a build directory
and run the benchmark:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>cmake<span class="w"> </span>-S<span class="w"> </span>runtimes<span class="w"> </span>-B<span class="w"> </span>&lt;build1&gt;<span class="w"> </span><span class="o">[</span>...<span class="o">]</span>
$<span class="w"> </span>libcxx/utils/libcxx-lit<span class="w"> </span>&lt;build1&gt;<span class="w"> </span>libcxx/test/benchmarks/string.bench.cpp<span class="w"> </span>--param<span class="w"> </span><span class="nv">optimization</span><span class="o">=</span>speed
</pre></div>
</div>
<p>Then, do the same for the second configuration you want to test. Use a different build
directory for that configuration:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>cmake<span class="w"> </span>-S<span class="w"> </span>runtimes<span class="w"> </span>-B<span class="w"> </span>&lt;build2&gt;<span class="w"> </span><span class="o">[</span>...<span class="o">]</span>
$<span class="w"> </span>libcxx/utils/libcxx-lit<span class="w"> </span>&lt;build2&gt;<span class="w"> </span>libcxx/test/benchmarks/string.bench.cpp<span class="w"> </span>--param<span class="w"> </span><span class="nv">optimization</span><span class="o">=</span>speed
</pre></div>
</div>
<p>Finally, use <code class="docutils literal notranslate"><span class="pre">libcxx-compare-benchmarks</span></code> to compare both:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>libcxx/utils/libcxx-compare-benchmarks<span class="w"> </span>&lt;build1&gt;<span class="w"> </span>&lt;build2&gt;<span class="w"> </span>libcxx/test/benchmarks/string.bench.cpp
</pre></div>
</div>
</section>
<section id="testing-hardening-assertions">
<span id="id1"></span><h2><a class="toc-backref" href="#id25" role="doc-backlink">Testing hardening assertions</a><a class="headerlink" href="#testing-hardening-assertions" title="Link to this heading">¶</a></h2>
<p>Each hardening assertion should be tested using death tests (via the
<code class="docutils literal notranslate"><span class="pre">TEST_LIBCPP_ASSERT_FAILURE</span></code> macro). Use the <code class="docutils literal notranslate"><span class="pre">libcpp-hardening-mode</span></code> Lit
feature to make sure the assertion is enabled in (and only in) the intended
modes. The convention is to use <cite>assert.</cite> in the name of the test file to make
it easier to identify as a hardening test, e.g. <code class="docutils literal notranslate"><span class="pre">assert.my_func.pass.cpp</span></code>.
A toy example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Note: the following three annotations are currently needed to use the</span>
<span class="c1">// `TEST_LIBCPP_ASSERT_FAILURE`.</span>
<span class="c1">// REQUIRES: has-unix-headers</span>
<span class="c1">// UNSUPPORTED: c++03</span>
<span class="c1">// XFAIL: libcpp-hardening-mode=debug &amp;&amp; availability-verbose_abort-missing</span>

<span class="c1">// Example: only run this test in `fast`/`extensive`/`debug` modes.</span>
<span class="c1">// UNSUPPORTED: libcpp-hardening-mode=none</span>
<span class="c1">// Example: only run this test in the `debug` mode.</span>
<span class="c1">// REQUIRES: libcpp-hardening-mode=debug</span>
<span class="c1">// Example: only run this test in `extensive`/`debug` modes.</span>
<span class="c1">// REQUIRES: libcpp-hardening-mode={{extensive|debug}}</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;header_being_tested&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;check_assertion.h&quot;</span><span class="c1"> // Contains the `TEST_LIBCPP_ASSERT_FAILURE` macro</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">type_being_tested</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">bad_input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="n">TEST_LIBCPP_ASSERT_FAILURE</span><span class="p">(</span><span class="n">foo</span><span class="p">.</span><span class="n">some_function_that_asserts</span><span class="p">(</span><span class="n">bad_input</span><span class="p">),</span>
<span class="w">      </span><span class="s">&quot;The expected assertion message&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that error messages are only tested (matched) if the <code class="docutils literal notranslate"><span class="pre">debug</span></code>
hardening mode is used.</p>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="CodingGuidelines.html">libc++ Coding Guidelines</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="ImplementationDefinedBehavior.html">Implementation-defined behavior</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2011-2025, LLVM Project.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>